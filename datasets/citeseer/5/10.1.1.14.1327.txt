reformulating software engineering search problem john clarke university york york yo dd uk 
tel fax accs 
york 
ac 
uk bryan jones university cf dl uk 
tel fax bj 
ac 
uk rees systems integration research british telecom park uk 
ip re tel 
fax 


com jos javier facultad de informatica university basque country spain tel fax 
ehu 
es mary systems integration research british telecom park uk 
ip re tel 
fax 
mary 

com marc roper strathclyde university livingstone tower richmond street glasgow xh uk 
tel fax 
strath 
ac 
uk mark harman robert hierons brunel university ub ph uk 
tel fax mark 

ac 
uk rob 

ac 
uk brian mitchell department mathematics computer science drexel university philadelphia pa usa 
tel fax 
drexel 
edu 
drexel 
edu martin shepperd university talbot campus poole bh bb uk 
tel fax 
ac 
uk metaheuristic techniques genetic algorithms simulated annealing tabu search wide application areas engineering 
techniques applied business financial economic modelling 
metaheuristics applied areas software engineering test data generation module clustering cost effort prediction remain software engineering problems tackled metaheuristics 
surprising metaheuristics widely applied software engineering problems software engineering characterised precisely features metaheuristic search applicable 
argued features metaheuristics applicable engineering business applications outside software engineering suggest great potential exploitation metaheuristics software engineering 
briefly reviews principal metaheuristic search techniques surveys existing application metaheuristics software engineering areas test data generation module clustering cost effort prediction 
shows metaheuristic search techniques applied additional areas software engineering maintenance evolution system integration requirements scheduling 
software engineering problem areas considered span range software development process fi om initial planning cost estimation requirements analysis integration part funded epsrc seminal software engineering metaheuristic algorithms network gr www 

org uk seminal maintenance evolution legacy systems 
aim justify claim problems software engineering re formulated search problems metaheuristic techniques applied 
goal stimulate greater interest metaheuristic search tool optimization software engineering problems encourage investigation exploitation technologies finding near optimal solutions complex constraint scenarios arise frequently software engineering 
problems associated complexity management software development process proved resistant conventional analytic solutions 
software development process products tend characterised large number competing inter related constraints 
clearly specified notoriously vague poorly defined 
changes parameter large impact related areas making balancing concerns difficult 
single solution typical set software engineering constraints software engineering probably regarded engineering 
authors take premise claim software engineers face problems consist finding solution engineering acceptable near optimal solution large number alternatives 
clear achieve optimal solution clear evaluate compare candidates 
instance may hard know achieve design low coupling high cohesion relatively easy decide design closely coupled 
metaheuristic search techniques set generic algorithms concerned searching optimal near optimal solutions problem large multi modal search space 
search spaces typically arise number competing constraints balanced arrive solution 
typically problems infeasible apply precise analytic algorithm produces best solution problem possible determine better candidate solutions 
metaheuristic algorithms applied successfully number engineering problems ranging load balancing process industries pressing sugar pulp electromagnetic system design aircraft control aerodynamics 
surprising technologies metaheuristic search penetrated software engineering research community widely applied compared traditional engineering disciplines 
argues software engineering problems thought search problems metaheuristic search applied range software engineering problems requirements gathering systems integration evolution 
aim provide new perspective software engineering problems reformulated search problems metaheuristic algorithms applied 
new perspective regarded complementary supplementary existing approaches replacement 
argues metaheuristic search techniques simply provide technology software engineering problems attacked 
order justify claim surveys existing successful results application metaheuristic search techniques automated software test data generation module clustering cost effort prediction provides reformulation software engineering problem areas metaheuristic search problems 
areas considered span software development process scheduling requirements cost effort estimation system integration source transformation maintenance re engineering 
hope stimulate greater interest metaheuristic search technologies software engineering community leading research application techniques solving complex sets constraints software development evolution demanding process 
rest organised follows 
section provides brief overview field metaheuristic algorithms 
section surveys previous application metaheuristic algorithms software testing module clustering cost estimation 
section shows software engineering thought search problem metaheuristic algorithms readily applied 
section concludes directions 
metaheuristic search techniques optimisation optimisation seeks find set parameters objective function maximum minimum value 
objective function may number local extreme points addition global extremum 
metaheuristic algorithms set techniques successfully applied solving optimisation problems presence local extrema parameters presence conflicting constraints 
find acceptable approximations solution np complete problems 
examples meta heuristic algorithms local search techniques hill climbing simulated annealing tabu search evolutionary techniques genetic algorithms 
described briefly sections 
key ingredients search optimisation problem choice representation problem definition fitness function 
local search section overviews local search metaheuristic techniques hill climbing simulated annealing tabu search 
hill climbing hill climbing search proceeds randomly chosen point considering neighbours point 
fitter neighbour current point search space process repeated 
fitter neighbour search terminates maxima definition 
approach called hill climbing fitness function thought landscape peaks representing points higher fitness hill climbing algorithm selects hill near randomly chosen start point simply moves current point top hill climbing hill 
clearly problem hill climbing approach hill located algorithm may local maxima may far poorer terms fitness global maxima search space 
hill climbing simple technique easy implement shown useful robust software engineering applications modularization cost estimation see sections 
variations hill climbing theme 
example algorithm select neighbour finds better fitness current individual ascent hill climbing consider neighbours select best fitness improvement steepest ascent hill climbing 
whichever variation chosen important characteristic hill climbing property select local peak may local optimum local peak algorithm terminates fast simple prone sub optimality 
simulated annealing tabu search local search techniques search local neighbourhood search space different approach overcoming tendency trapped local maxima 
key ingredient hill climbing algorithm definition neighbourhood configuration space 
simulated annealing simulated annealing method local searching contrast genetic algorithms sample domain improve solution recombination form 
simulated annealing value xl chosen solution cost objective function 
cost functions define relative particular solutions 
general larger values function associated larger costs 
similarly wish satisfy constraints values function dependent variable blatantly break constraints attract greater cost satisfy constraints come close doing 
initialise loop cooling loop local search derive ae xt derive random number ifr xt loop local search exit goal reached pre defined stopping condition satisfied loop cooling generic simulated annealing algorithm minimizing objective function usually referred cost function 
maximizing usually referred fitness function 
simulated annealing algorithm considers neighbouring value xl evaluates cost function constitutes neighbouring value xl may immediately obvious neighbour defined appropriate way 
cost function xl reduced search moves xl process repeated 
cost function increases move necessarily rejected small probability search move xl continue 
probability function change cost function ae parameter probability similar form maxwell boltzmann distribution law statistical distribution molecular energies classical gas ae related energy temperature respectively 
change cost function negative improvement probability set move accepted 
ae positive unfavourable move accepted probability equation probability depends strongly values ae start simulated annealing high probability accepting unfavourable move correspondingly high 
search slowly reduced function called cooling function counterpart physical world 
effect cooling simulation annealing probability unfavourable move reduced 
practice temperature decreased stages stage temperature kept constant thermal quasi equilibrium reached 
set parameters determine temperature decrement initial temperature criterion temperature decrement successive stages number transitions temperature value called cooling schedule 
cooling schedule critical success optimisation 
algorithm described 
key ingredients simulated annealing algorithm 
definition neighbourhood configuration space 
specification cooling schedule 
term simulated annealing arises maxwell boltzmann probability function procedure cooling annealing involves heating metal alloy high temperature generate initial solution loop identify neighbourhood set identify tabu set identify set choose best move exit goal satisfied stopping condition reached loop generic tabu search algorithm cooling slowly room temperature aim removing internal stresses improving reducing brittleness 
technique originates theory statistical mechanics analogy annealing solids solving optimisation problems 
helpful pursue analogy physical world greater extent 
effectiveness search depends initial temperature high search sufficiently 
subsequent cooling slow ensure equilibrium achieved temperature 
tabu search tabu search iterative procedure solving discrete combinatorial optimisation problems 
space possible solutions searched sequence moves possible solution best available alternative 
order prevent stuck sub optimal solution avoid drifting away global optimum moves classified forbidden tabu taboo 
list tabu moves formed short term long term memory previous unpromising moves 
move may regarded unpromising simply 
occasions tabu move may allowed 
aspiration criterion tabu move lead best solution obtained far 
search space neighbourhood comprises set moves lead solution applied current solution 
tabu search starts possibly random point determines sequence moves tabu set established members tabu set may classified member set 
criteria classifying moves specific application 
moves may tabu lead solution considered recency short term condition repeated times frequency long term condition 
move best neighbouring solution tabu 
generic tabu search algorithm summarised 
key ingredients setting tabu search 
define neighbourhood solution 
define move 
evolutionary search genetic algorithms genetic algorithms gas search optimal solutions sampling search space random creating set candidate solutions called population 
candidates combined mutated evolve new generation solutions may may fitter 
recombination fundamenta ga provides mechanism mixing genetic material population 
mutation vital introducing new genetic material preventing search 
population solutions chosen parent offspring generations accordance survival strategy normally favours fit individuals preclude survival fit 
way diverse pool genetic material preserved purpose breeding fitter individuals 
terminology strongly suggests gas principles darwinian evolution 
analogy taken literally darwinian set generation number choose initial population candidate solutions evaluate fitness individual pi loop recombine evaluate select exit goal stopping condition satisfied loop generic evolutionary algorithm evolution assumed blind improvements happen chance goal improved individuals better chance survival able pass genes offspring 
chance plays important role gas success locating optimum strongly depends judicious choice fitness function 
fitness function designed carefully reflect nature optimum direct search promising pathways 
gas operate population individuals called chromosomes assigned fitness 
population size suciently great allow substantial pool genetic material large search degenerates random search 
individuals undergo recombination survive chosen probability depends fitness way 
different selection mechanisms called roulette wheel population cumulative fitness normalised give set probabilities individual tournament individuals selected random population fittest chosen 
generic evolutionary algorithm 
key ingredients genetic algorithm 
specification probabilities crossover mutation 
choice recombination mutation selection algorithms 
advantage ga solution domain sampled evaluation fitness function computationally expensive advantage may rapidly disadvantage 
spite sampling guarantee global optimum search may rapidly sub optimum steps taken preserve diversity genetic material 
evolutionary search genetic programming genetic programming goal produce program solves particular problem 
fitness function defined terms close program comes solving problem 
operators mutation mating defined terms program syntax tree 
operators applied trees sequences definition typically straight forward applied gas 
genetic programming find functions describe predict data 
way genetic program algorithmic fit set data 
fit need perfect order useful 
applications genetic programming described koza require perfect fully correct solution merely 
genetic programming find fits software engineering data project estimation data described section 
sub optimum section term optimum taken subsume sub optimum 
metaheuristic algorithms solve problems software engineering strength metaheuristic algorithms seek iteratively optimum solution landscape may extremely complicated discontinuous 
key applying metaheuristic algorithms successfully formulate problem hand search optimisation problem 
instance seen section automated generation test data formulated search input domain guided fitness function captures appropriate test adequacy criterion 
having formulated problem search problem necessary define essential ingredients relevant chosen metaheuristic 
metaheuristic techniques require suitable representation candidate solution individual fitness cost function 
fitness function defines fitness landscape gives search sense direction search hindered landscapes shallow gradients landscapes sharply defined peaks 
definition suitable fitness functions software engineering problems major area required pin exploitation metaheuristics software engineering 
search techniques rely concept move individual 
form move near mutation may produce jump different individual near 
available mutation move operations applied individual typically delimited choice representation 
definition representation fitness function mutation move operations considered pre requisite application metaheuristic search techniques outlined 
having defined key ingredients possible apply hill climbing simulated annealing local search techniques 
order apply genetic algorithms necessary define crossover operator 
near may defined predecessor successor ordinal type arbitrarily close floating type 
normally search space multi dimensional decision values change way 
crossover operator takes individuals parents produces new individual offspring related parents sharing information 
literature process regarded analog sexual reproduction living individuals typically gender distinction 
order apply metaheuristics software engineering problems steps considered 
ask suitable problem 
search space sufficiently large exhaustive search impractical 

define representation possible solutions 
define fitness function 
select appropriate metaheuristic technique definability key ingredients listed section 
start application simple hill climbing 
results encouraging better random search consider local search genetic approaches 
motivation final piece advice prescription application metaheuristics observation hill climbing may produce results sufficiently application sophisticated techniques unnecessary additional effort 
course land software engineering test data input landscape genetic approaches outperform hill climbing 
landscapes hill climbing represents starting point 
results simple hill climbing approach better random search may indicate lack understanding problem area representations inadequate 
reflection fact problem area simply suited search approach 
problem characteristics section describes characteristics problem space lead suitable attack search solution 
section contains examples source engineering activity areas search techniques prove successful way bounding problem 
criteria success include 
large solution space 
building artifact thought search problem 
space possible solutions sufficiently large enumeration candidate solutions expensive 

known efficient complete solution 
clearly little gained applying new solution problem solved 
search approaches may yield additional insight may help fill gaps existing solutions partial 

existence suitable candidate fitness functions 
fields software engineering activity large number readily accepted metrics example 

cheap generation candidate solutions 
large solution space search solutions inevitable order apply candidate solutions need valuable reasonable time 
typical search algorithms require executions fitness function speed execution fitness function crucial 
areas software engineering activity profit search solutions include forms requirements elicitation aspects human interaction situations unclear required 
existing applications metaheuristics software engineering testing problem generating test data software individuals optimization occurs test cases represented ways allow mutation crossover notion neighbourhood 
crucially testing normally aims achieve certain measurable objectives 
fact test generation techniques notion coverage code specification 
coverage measured incorporated objective function 
metaheuristics applied types testing 
structural testing 
specification testing 
testing determine worst case execution time 
types testing application metaheuristics shall discussed 
structural testing structural white box test techniques determine adequacy test set considering structure code 
normally techniques consider certain constructs measure proportion constructs source code executed testing 
proportion called coverage 
construct considered normal insist full coverage feasible constructs executed testing 
number forms coverage including control flow graph ii ii triangle equilateral ii ii isosceles scalene fragment code triangle problem 
statement coverage proportion reachable program statements covered testing 
branch coverage proportion feasible program branches edges control flow graph leave node possible node covered testing 
path coverage proportion feasible paths control flow graph covered testing 
considering particular notion coverage random testing may provide high level coverage 
constructs executed random testing test generation may broken phases random testing cover constructs technique derive tests cover remaining constructs 
number authors considered metaheuristics second phase :10.1.1.33.7219
suppose construct executed testing 
tester may choose path contains construct try derive test cases follow path 
consider fragment code written style notation program produced solve triangle problem shown 
order test branch final statement sufficient follow branches statements followed branch 
naturally path chosen infeasible test generation process fails execute path significant length time tester choose alternative path 
objective function may defined test input measuring close gets path construct considered 
predicates common intended path 
fitness may measured instrumenting code test input may represented string values bit string 
suppose tester wishes test final branch code 
test case takes branch second branch notion fitness test case fitness 
particular criterion may possible refine objective function 
jones consider genetic algorithms branch testing give fitness function test reaches initial vertex branch 
fitness function depends values state reaches vertex 
test fails reach vertex low fitness 
assuming test reaches initial vertex branch considered calculation fitness considers cases case test go correct branch second go correct branch 
test fails go correct branch fitness depends close state variables point executing correct branch 
closer test executing correct branch higher fitness 
consider branch second statement 
input reaches initial node follows branch follows branch point fitness inversely proportional close close fitness la lb test goes correct branch fitness depends close state boundary branch closer boundary higher fitness 
consider branch second statement 
branch taken result executing test case fitness inversely proportional la lb second case motivated observation tests boundaries effective detecting faults fitness drive values boundary branch 
fitness may determined instrumenting code 
fitness function described potentially combined described 
branch path branch chosen 
test reach initial vertex branch fitness depends close test executing path 
test reaches initial vertex branch total fitness depends described 
fitness described called local fitness considers initial node branch 
total fitness test reaches initial node branch local fitness plus number predicates path branch 
specification testing tracey consider problem testing formal specification form set disjoint pre post conditions 
system test case leads failure pre post pairs satisfies precondition fails post condition 
pre post condition pair predicate formed 
fault detected test execution false 
order try drive test cases detecting faults fitness function depends close test case making false 
rewritten disjunctive normal form conjuncts considered turn 
conjunct tested intention try take value false 
naturally fitness depend just value true false 
assuming conjunct true value considered term conjunct contributes final fitness value sum values problem minimize fitness 
certain classes predicate el expressions el fitness function gives range values may defined 
example el fitness predicate false fitness el 
authors simulated annealing try find faults 
interestingly authors find similar approach assertions placed code intention trying false test exception conditions 
worst case execution time real time control systems designed respond stimulus fixed time interval 
failure respond sufficiently interval may lead critical condition 
important determine worst case execution time function method 
problem determining worst case execution time highly complex may depend crucially properties hardware compiler 
genetic algorithms attempt find maximum minimum execution times 
input represented chromosome fitness input depends execution time trying find maximal times fitness proportional execution time trying find minimal times fitness inversely proportional execution time 
simulated annealing similar manner 
approach consistently outperformed random testing new minimum execution time module 
module clustering shaw garlan software architecture system consists description system elements interactions patterns guide construction constraints relationships 
smaller systems elements relations may modeled source code entities procedures classes method invocation inheritance 
larger systems desired entities may high level modeled architectural artifacts subsystem components relations 
subsystems provide developers structural information numerous software components interfaces interconnections 
subsystems generally consist collection collaborating source code resources implement feature provide service rest system 
typical resources subsystems include modules classes possibly subsystems 
subsystems facilitate program understanding treating sets related source code resources high level software abstractions 
subsystems organized hierarchically allowing developers study organization system various levels detail navigating hierarchy 
entities relations needed represent software architectures source code 
external documentation techniques capable deriving reasonable approximation software architecture source code needed 
research software clustering problem proposed approaches deal challenge defining techniques partition structure software system subsystems clusters 
techniques determine clusters subsystems source code component similarity sets heuristic rules concept analysis clustering metrics information available system implementation module directory package names 
mentioned software clustering techniques shown produce results certain types systems promising results obtained variety different systems applying heuristic search techniques software clustering problem 
mitchell studied hill climbing simulated annealing genetic algorithm searches implemented software clustering algorithms suite integrated tools downloaded internet 
researchers examined modularize software systems genetic algorithms 
software clustering search problem starting point applying search techniques software clustering problem representation structure system clustered 
representation fitness function required measure relative quality system modularization structure decomposed subsystems clusters 
algorithm required traverse space candidate solutions fitness function locate solution enormous set possible solutions 
metaheuristic search problems result produced clustering algorithm need optimal solution theoretical sense 
solution perceived people 
representation goals software clustering algorithms neutral programming language syntax 
accomplish goal source code analysis tools transform structure system code language independent directed graph 
graph formally defined set named modules software system set ordered pairs form represents source level relationships exist module module module uses exported function module 
weighted edges establish strength relation pair modules 
primary goal software clustering algorithms propose subsystems clusters expose abstractions software structure 
partition software structure graph defined set non overlapping clusters cover graph nodes 
goal partition graph clusters represent meaningful subsystems 
finding partition involves navigating search space possible partitions systematic way 
noted ways define example module dependency graph places edge pair modules module uses resources provided module 
graphs created considering dynamic program behaviour dynamic loading object creation runtime method invocation inheritance relationships 
clustering alternative graph representations software systems provides users additional insight system architecture helpful activities program understanding software maintenance 
fitness functions designing fitness function software clustering applications fundamental decision constitutes partition software structure graph 
popular approaches implemented researchers define fitness function maximizes cohesion individual clusters time minimizing coupling clusters 
example consider fitness function implemented bunch clustering tool 
authors refer fitness function modularization mq 
mq software structure graph partitioned clusters calculated summing cluster factor cluster partitioned graph 
cluster factor cfi cluster defined normalized ratio total weight internal edges edges cluster half total weight external edges edges exit enter cluster 
weight external edges split half order apply equal penalty clusters connected external edge 
internal edges cluster referred intra edges 
number intra edges module denoted edges distinct clusters inter edges 
number inter edges module module denoted ci edge weights provided assumed edge weight 
note ci zj formal definition calculation defined follows mq cfi cf ti 
il ei jq ej jl notice mq increases cohesiveness individual clusters increases coupling clusters decreases 
goal search algorithms implemented bunch maximize mq 
alternative objective function integrates concept cluster granularity fitness evaluation investigated harman 
lutz describes fitness function ga measures complexity coupling cohesion principles 
software clustering search algorithms way find best partition software structure graph perform exhaustive search valid partitions select best fitness value 
approach impossible number ways system partitioned subsystems grows exponentially respect number nodes modules 
discovering optimal grouping modules clusters feasible small software systems fewer modules heuristic search algorithms required locate acceptable results quickly 
mitchell designed implemented software clustering search algorithms bunch tool 
hill climbing search algorithm 
bunch hill climbing clustering algorithms start generating random partition software structure graph modules partition rearranged systematically examining neighbouring partitions attempt find improved partition partition better fitness 
better partition process iterates improved partition basis finding better partitions 
hill climbing search algorithm eventually converges improved partitions 
iteration options available controlling behaviour hill climbing algorithm neighbouring process uses partition discovers larger fitness function mq basis iteration 
neighbouring process examines neighbouring partitions current iteration selects partition largest mq basis iteration 
neighbouring process ensures examines minimum number neighbouring partitions iteration 
multiple partitions larger mq discovered set partition largest mq basis iteration 
partitions discovered larger mq neighbouring process continues uses partition discovers larger mq basis iteration 
noted general problem graph partitioning software clustering special case np hard 

hill climbing simulated annealing 
bunch hill climbing algorithm includes ability accept probability partition worse fitness function value new solution current iteration 
probability accepting non improving partition reduced exponentially clustering process continues invoking user defined cooling function 
results associated bunch simulated annealing feature shown improvement performance sacrificing quality clustering results 

genetic algorithm ga 
bunch ga uses traditional operators selection crossover mutation determine partition software structure graph 
gas shown produce results search problems quality clustering results produced bunch hill climbing algorithm typically better bunch ga mitchell think bunch encoding crossover techniques necessary 
harman implemented gas hill climber cluster software systems fitness function maximizing cohesiveness clusters minimizing inter cluster coupling 
fitness function harman includes concept target granularity idea tool aim produce clusterings desired number modules 
fitness function achieves enforcing quadratic punishment clustering produced deviates target granularity 
gas explored cross techniques designed promote formation building blocks preserving module child 
produced improved results ga cross technique harman hill climbing far performed variations genetic algorithms confirming results bunch team 
lutz worked hierarchical clustering search techniques 
concerned problem decomposition software hierarchies different levels abstraction harman concerned single level abstraction implementation level 
lutz focuses clustering hierarchies designs code 
approach adopted lutz differs strongly approach adopted harman regard choice fitness function 
fitness function lutz information theoretic formulation inspired shannon 
function awards high fitness scores hierarchies expressed simply information theoretic terms aim rewarding understandable designs 
search software modularisation established approach software clustering promising results terms quality efficiency 
mitchell ph dissertation reports promising results terms quality performance applying search algorithms software clustering problem 
example bunch hill climbing algorithm produces acceptable clustering results systems sun swing class library seconds linux operating system approximately seconds 
cost estimation initial approaches applying metaheuristic methods problem cost estimation considered system identification symbolic regression approach :10.1.1.19.4684
genetic programming gp learn predictive functions training sets 
idea similar studied works mckay willis gp discover function relates data points independent dependent variables 
shown gp able discover nonlinear linear systems :10.1.1.19.4684
cost estimation problem data relates size application effort usually measured person months 
size usually measured function points lines code 
operands solution may constants variables 
operators include power sqrt square log exp variety operators allow approximation function required model 
population equations evolved composed set formed equations usual genetic operators mutation crossover applied 
crossover applied trees exchanging subtrees equations 
mutation consists changing value nodes trees replacing node operator new numeric value 
fitness function evaluation equations squared error rose 
usual measure assessing regression models 
measures correlation coefficient considered clear recommended 
generation formed selecting equations fitness proportionate selection method 
method individual population selected rejected probability proportional fitness 
reports number individuals generation low equations number generations provided best results surprisingly low generations cases 
parameters demanded special computing power convergence solution achieved quickly 
behaviour attributed data points available data set low number variables 
reports results regarding application gp cost estimation 
gp obtains equations approximate data classical regression method 
cases gp able obtain better cost functions classical regression 
improvement predictions dramatic gp overcome intrinsic limitations data points 
gp helped conclude best curve approximates data sets publicly available linear function size effort 
results classical regression misleading due fact small set space functions analysed 
main benefit gp provides confidence results 
gp explores solutions guided fitness equations constrain form solution 
final set equations gp best predictive values 
running algorithm times ample set approximations obtained 
methods size estimation compared component method function point method 
results gp compared obtained artificial neural networks ann classical regression 
observed anns performed slightly better gp predictive point view 
drawback anns prediction systems provide symbolic representation equation rendering method useful software project manager 
ann approach hard reason automated system choice predicted value leading uncertainty confidence placed estimate 
linear regression curve estimation worst values 
gp essentially offers best approaches provides symbolic equations result evolutionary process takes advantage computational power techniques 
advantage gp approach non parametric method assumption distribution data deriving equations fitted values 
similar approach software project cost estimation proposed burgess gp evolve functions provide fits trends software project cost data 
burgess result comparing gp effort estimation approaches stepwise regression neural nets 
show highlight statistically significant predictions 
aguilar worked problem search software project cost estimation 
evolutionary algorithms ea directed extraction management rules estimation decision software projects 
key elements approach 
construction dynamic model software development process 
simulation model different ranges parameters obtaining database 
application evolutionary algorithms database generated obtaining set management rules 
database contains values obtained dynamic simulation software process model 
database big manager wants bearing mind simulation combination ranges parameters takes time performance ea depends accuracy rules founded 
representation coding search space set individuals form ul li ui values representing interval attribute class tuple belongs classification 
algorithm sequential covering ea fitness function tries discriminate correct incorrect classifications examples 
carried maximizing function ce coverage number examples processed ce number examples belonging rule class different rule number examples correctly classified rule coverage proportion search space covered rule 
application ea numerical database classifies data series management rules 
benefit approach task finding decision rules database generated left ea 
aguilar report ea performs better classical decision tree algorithms 
shepperd case reasoning estimate unknown project attributes partial information project 
approach locate similar projects known data new project data similar previous projects estimate unknown attributes new project 
shepperd project attributes better predictors 
determining best set attributes basis prediction feature subset selection problem search approaches reasonable solutions 
interestingly shepperd mitchell harman hill climbing performed elaborate search techniques problem 
results taken give rise optimism progress search software engineering relatively simple search techniques 
software engineering search problem pushing bound aries section considers aspects software engineering metaheuristics applied shown promising candidates application techniques 
important precursor application metaheuristic algorithms software engineering ability characterise software engineering problems search problems 
notable successes test data generation partly due fact problem large natural search component easily definable fitness function 
characteristics readily identifiable areas software engineering 
section considers problem areas software engineering arguing possible view problems search problems way metaheuristic search techniques applied 
order shown natural definitions key ingredients metaheuristic search techniques identified section 
rest section considers areas software engineering requirements systems integration software maintenance evolution 
shown formulated search problem defining appropriate fitness functions mutation operations representations individuals applicable defining near neighbours cross operations 
requirements phasing need phase schedule requirements typically occurs projects relatively short development time high level user involvement operate dynamic environment 
process widespread occurs need rapid iterative product development 
essentially development system consists iterative cycle negotiate bit build bit 
negotiation takes form selecting set potential requirements implemented prior system reviewed customers 
requirement typically aspect system functionality set going trivially small 
problem interest select set requirements going constitute iteration system 
problematic cases single customer 
number customers differing needs important views taken account choice 
may impossible customers represented meeting important system reflect views customers happen vocal 
recognised boehm workers time ago motivation devel opment spiral model spiral model 
original spiral model incorporated phase required project manager establish objectives constraints alternatives level development 
determining origin objectives constraints alternatives difficult additional activities added front spiral model give spiral model 
activities involved identifying system key stakeholders developers customers users identifying stakeholders win conditions basically desired outcome negotiating win win mutually agreeable win conditions 
negotiation process supported group ware tool links stakeholders win conditions issues options negotiated agreements enables negotiations records changes attempt resolve issues automatically 
karlsson ryan analytic hierarchy process determine cost benefit tradeoffs set requirements 
relative value requirements determined customers users relative cost determined developers 
results combined system stakeholders resulting cost value diagram vehicle determining requirements implemented 
selection subset requirements number alternatives course viewed classic multi criteria decision making problem approach attempt resolve problem established techniques discipline see example 
see metaheuristic approaches address problem consider relatively straightforward case ignores criteria cost functionality development time different customers wish see optimised different ways complicated case dealt assume customer view amalgamated single opinion 
assume requirements independent 
iteration system build set requirements implemented development cost associated requirement 
resource limit customers wish spend 
set customers different opinions required phase system 
choice set requirements going incorporated phase development 
customer obviously wishes select set greatest value 
problem select set requirements going acceptable customers possible 
customer opinion expressed priority weighting px associated requirement 
suppose customers potential requirements 
customer priority matrix cp defined pj cp represents priority associated customer requirement 
values pj depend nature application 
users equal simply rank requirements desirable ranked desirable ranked 
alternatively users allocated number votes multiple votes requirement permitted 
allow users record relative magnitude desire see certain requirement implemented 
allow developer allocate greater number votes users considered important 
strategies possible score choice requirements user preferences 
association absolute value voting mechanism method quantifying value terms business benefit preferable meaningfully summed give total value requirement 
absolute value system value jth requirement defined ranking system values associated requirement merely place elements ordinal scale making forms value combination meaningless measurement theory 
ranked priority values complex way combining individual user priorities 
having scored requirements way problem find optimal set requirements build 
problem instance knapsack problem known np hard 
implied search problem appropriate metaheuristic algorithm 
individual solution problem represented bit vector bit denotes presence absence requirement 
mutation represented bit crossover simple selection crossover point neighbour proximity represented hamming distance 
encoding allow forms metaheuristic search applied problem choosing set requirements 
solution additional problem arises explain customer 
interpretation solutions nearly problem applying metaheuristic techniques importance varies problem domain 
example area test data generation discussed earlier customer case person system generate test data probably going content fact data automatically generated cover percentage program paths 
want know particular value generated just pleased system done 
attitude customer different case requirements phasing 
probably want know certain set chosen happened requirements ranked highly 
matter important particularly customer lacks confidence system 
approach save solutions provide customer list alternative solution combinations just missed selected 
try explain thinking fitness function 
approach taken important customers feel chance question enhance system mutual benefit 
unfortunately assumption requirements independent customer preferences expressed simple opinion unrealistic 
dependencies requirements impact decision set requirements select 
requirements depend system going incur greater cost 
unrealistic assume cost requirement functionality important factors 
customers concerned constraints development time developers strong desire build system way smoothes release dates 
associated requirement attribute vector attributes representing cost development time associated dependencies primary focus customer functionality additional attributes pose real problem constraints included fitness function way cost constraint simple case 
difficulty arises different groups customers decide priorities different criteria 
example set customers requirements basis functionality group focus development time basis want sort system soon possible whilst third group want cheapest working system imaginable cost 
forms classic multi criteria decision making problem 
approach try adapt fitness function accommodate danger trying find solution main focus distinct customer groups lost 
approach tackle phases firstly considering group independently extracting subset requirements meets criteria fitness functions reflect priorities combining subsets second pass algorithm uses balanced fitness function reflects relative group sizes 
additional constraints change nature problem longer matter selecting ordered list requirements 
choice requirement incorporate take vector costs times dependencies account 
constraints requirements possible generate invalid individuals set requirements denoted closed dependence relation example 
happens possible strategies available repair individual 
include requirement set transitively dependent require ments advantage reduces size search space individual represent valid solutions containing relevant dependent requirements 
may bias search inclusion requirement depend 
punish individual low fitness score 
individuals contain dependent requirements reduce fitness score selected 
disadvantage search space larger repair solution potential bias repair introduce 
course possible generate individuals require cost greater allowed customer 
allocated low fitness score making impossible selected 
coefficient determine level cost breaking solutions adjusted take account softness cost ceiling 
allow solutions selected near cost boundary noticeably attractive terms customer requirement 
flexibility metaheuristic search approach benefits methods authors believe ideally suited software engineering problems 
systems integration systems integration consists individual components combining usually incremental fashion eventually create entire system 
importance adopting incremental approach probability components going available time means stubs drivers dummy components plugged place real component simulate interaction written 
testing takes place stage important opportunity determine components interact correctly 
component fails stage sent back developers re 
re introduces problems firstly delay systems integration process important component greater delay secondly need re test corrected component re integrated 
leads turn systems integration process chaotic ideally ought operate organised assembly plant 
viewing integration problem search problem provides opportunity achieve assembly plant type process 
component system may component 
heavily component integrated late process having prior reveals faults components interacts interacting components may re worked re integrated resulting significant time delays repeated testing 
hand component uses components integrated early components uses replaced stubs 
wasteful terms resources causes problems interaction faults visible real components introduced 
leads situation ideally heavily components integrated heavily dependent components integrated 
obviously components dependent cost associated dependency 
cost information components integrated far determine ideal order integration 
turn fed back developers enable production components order lead cheapest time due fewest re works minimal system integration 
order integration components represented permutation set components 
individual permutation sensible crossover proceed simply parts individuals conjoining result valid individual 
necessary apply crossover technique order crossover cycle crossover 
guaranteed return valid permutation 
order crossover random cut point chosen left substring individual kept 
individual completed elements left order occurred second parent 
contrast cycle crossover merges permutations see example details 
mutation operators available representation systems integration problem essentially swap shuffle operators swap operator interchanges genes 
shuffle operator produces gene permutation 
application integration ordering effect swap relatively low impact fitness 
cost function depends activity comes swap changes values 
large sequence components integrated smaller effect similar swap transformation sequence 
seen section transformation sequences akin simple programs linear programming language single change programming language statement dramatic effect meaning program 
systems integration question clear notion neighbourhood 
permutations neighbours ifp obtained swapping adjacent event genes 
problem find appropriate objective function drive optimisation process 
naturally order events objective function just provide estimated cost associated order 
may determined ordered pair components determining costs associated integrating 
total cost order integration may determined 
demonstrated possible define key ingredients metaheuristic algorithms application systems integration problems 
possible claim metaheuristic techniques considered applied software engineering problem 
maintenance re engineering program transformation program transformation long history dating back darlington burstall pure functional languages 
program transformation sequence simple transformation steps applied program translate form 
approaches transformation share common principle alter program syntax affecting semantics 
transformation familiar compiler technology time support optimisation 
transformation applied higher levels abstraction goal restructure program way partially evaluate tt support activities typically associated phases software development life cycle maintenance re engineering 
systems support transformation activities sich fermat kids 
problems number transformation steps may large maintainers assistant example supports transformations 
step applicable program transformation 
effective program transformation strategies hard define cause space solutions exponentially large number basic transformation steps typical transformation sequence length 
transformation applications viewed search problem space admissible transformation sequences genetic algorithms simulated annealing tabu search applied 
techniques shown effective specific transformation problem automatic parallelisation reason hope applicable general software engineering problems 
fitness functions programs code level software metrics 
metaheuristic approach program transformation provides mechanism combine program transformation rules software metrics 
metric guide search possible solutions bounded set transformations chosen 
existing transformation evolutionary techniques focussed automated parallelization 
approaches considered 
rest section considers built allow evolutionary techniques applied software maintenance re engineering transformation 
program individual local search approach program transformed individual search space consists semantically equivalent programs reached sequence transformation steps original 
representation program syntax tree control flow graph unimportant long transformation steps applied program yield new individual 
program individual representation mutation operators transformation steps 
approach adopted williams 
compares approach uses transformation sequence individual described section reports program individual approach yields superior results 
approach essentially local search hill climbing program mutated transformation better programs retained 
williams success approach indicates landscape program transformation case auto parallelisation may smooth hill climbing produce reasonable results 
clear superior results reflected type program williams considering achieved domain consideration auto parallelisation general re engineering transformation 
required see results replicated evolutionary transformation applied re engineering 
program individual traditional genetic programming approach program individual hard define crossover programs pl identical behaviour combined produce program identical behaviour pl 
combination far obvious cases 
hope advances genetic programming may assistance 
ryan describes approach called auto parallelisation individual program transformed represented syntax tree genetic programming mutation crossover operators applied 
approach inherently lead program faithful semantics original 
language program transformation result non meaning preserving transformation 
attempt overcome possibility ryan uses set test cases incorporates fitness function 
evolutionary algorithm multi objective fitness function 
fitness function rewards solutions correctness test cases efficiency 
course problem algorithm may render programs fast incorrect 
worse algorithm yields answers fitness function correct correct respect test cases correctness longer guaranteed 
re engineering applications correctness vital approach form basis development 
transformation sequence individual genetic algorithm approach step program individual sequence transformations applied program considered individual 
approach fitness function involves applying sequence transformations original program produce transformed program metric optimised applied 
approach adopted ryan auto parallelisation ii system 
general re engineering transformation approach number mutation operations possible replacement shift left right rotate left right swap obvious choices replacement operator takes sequence transformations replaces transformation steps sequence produce mutated sequence shift left right operator takes sequence transformations removes transformation step shifts remaining transformation steps left right adding new transformation step sequence rotate left right operator replace transformation steps moves left right rotating transformation step position respectively swap operator interchanges transformation steps transformation sequence 
candidates swap rotate introduce new transformation steps 
situations mutation operators insufficient new information need introduced ensure exist areas search space explored 
replacement effective early stages search algorithm need free consider widely different individuals 
shift rotate operators tend disruptive effect transformation sequence may suited stages search 
transformation sequence individual possible define crossover relatively easily 
sequences transformations combined change information single point multiple point uniform crossover 
fit individuals subsequences transformations represent simple transformation tactics individually progress goal embodied fitness function 
sensible choose approach crossover unnecessarily disrupt transformation tacticals uniform crossover successful 
changing single transformation step radically alter way sequence transformations behaves 
hard define suitable concept near neighbour representation 
transformation sequence individual approach representation problem possible define fitness mutation crossover operators hard define concept near neighbour 
representation suggests genetic algorithm means tackling search problem 
transformation program individual adapted genetic programming approach alternative approach gp test fitness function construct transformation program individual measure fitness suite training programs 
fitness improvement individual transformation program able produce training suite 
standard syntax tree operators genetic programming applied mutate transformation programs crossover transformation programs 
fitness function reward transformation program performed range programs training suite 
primitive operations transformation language simple transformation steps constructs language sequencing selection iteration 
transformation language include predicates program structures 
may allow higher level program transformation tactics emerge 
way examining training suite set transformation primitives available 
behaviours different training suites give insights similarities programs suite transformation 
behaviours different sets transformation primitives yield insight effectiveness applicability chosen sets transformations particular task hand 
goal produce perfect transformation algorithm transforming suite programs programs resemble members suite 
aim 
aim gain insight transformation tactic applicable sets transformations useful metric training suite kinds program amenable chosen transformation goal 
metaheuristic algorithms wide application engineering problems 
problems techniques suitable consisted situations complex competing inter related constraints placed development process products 
situation implicit tradeoffs criteria form points fitness landscape defined cost function assesses fitness particular configuration constraints 
software engineering provides examples situations competing constraints balanced 
appears attractive ripe area application metaheuristic search techniques 
techniques applicable solutions easy recognise hard generate competing constraints size search space complexity cost function 
techniques applied successfully problem finding test data achieve test data adequacy criteria module clustering cost estimation 
considered areas software engineering metaheuristic search find successful application 
areas span range software development process initial planning requirements analysis maintenance evolution legacy systems 
aguilar ruiz ramos evolutionary approach estimating software projects 
information software technology dec 
aho sethi ullman compilers principles techniques tools 
addison wesley 
comparison graphs concept reverse engineering 
proc 
intl 
workshop program comprehension june 
lethbridge recovering software architecture names source files 
proc 
working conf 
reverse engineering oct 
ashcroft manna translation goto programs programs 
proceedings congress griffith rosenfeld eds vol 
north holland pp 

evolutionary algorithms theory practice 
oxford university press 
stewart multiple criteria decision analysis integrated approach 
kluwer academic publishers 
bennett automated support software maintenance 
journal information software technology 
bennett bull younger luo reverse engineering safety critical systems 
ieee international conference software maintenance ieee computer society press los alamitos california usa pp 

bennett program transformations help reverse engineering 
ieee international conference software maintenance icsm bethesda maryland usa nov ieee computer society press los alamitos california usa pp 

ershov jones partial evaluation mixed computation 
north holland 
boehm kwan port shah spiral model case study 
ieee computer july 
burgess genetic programming improve software effort estimation 
comparative evaluation 
information software technology dec 
consel hornof marlet muller thibault volanschi 
partial evaluation software engineering 
acm computing surveys es sept 
article 
darlington burstall system developing recursive programs 
acm 
de jong genetic algorithms search program spaces 
genetic algorithms applications proceedings second international conference genetic algorithms mit cambridge ma usa july grefenstette ed lawrence erlbaum associates pp 

validation component method software size estimation 
ieee transactions software engineering 
problem software cost function 
information software technology 
mitchell automatic clustering software systems genetic algorithm 
international conference software tools engineering practice step pittsburgh pa august september 
fenton software metrics rigorous approach 
chapman hall 
garey johnson computers intractability guide theory np completeness 
freeman 
glover tabu search tutorial 
interfaces 
goldberg genetic algorithms search optimization machine learning 
addison wesley reading ma 
harman hierons proctor new representation crossover operator search optimization software modularization 
gecco proceedings genetic evolutionary computation conference new york july morgan kaufmann publishers pp 

harman hu hierons zhang munro wegener post placement side effect removal algorithm 
ieee international conference software maintenance icsm montreal canada oct ieee computer society press los alamitos california usa pp 

holland adaption natural artificial systems 
mit press ann arbor 
basili system structure analysis clustering data bindings 
ieee transactions software engineering se 
jones sthamer automatic structural testing genetic algorithms 
software engineering journal 
jones sthamer strategy genetic algorithms automate branch fault testing 
computer journal 
jung 
optimizing value cost requirements analysis 
ieee software 
karlsson ryan cost value approach prioritizing requirements 
ieee software september october 
shepperd hart search heuristics case reasoning software project effort prediction 
gecco proceedings genetic evolutionary computation conference new york july morgan kaufmann publishers pp 

koza genetic programming programming computers means natural selection 
mit press cambridge ma 
lakhotia 
restructuring programs statements functions 
information software technology special issue program slicing harman gallagher eds vol 

elsevier pp 

lindig snelting assessing modular structure legacy code mathematical concept analysis 
proceedings international conference software engineering acm press pp 

lutz evolving decompositions complex systems 
journal systems architecture 
mitchell chen gansner automatic cluster ing produce high level system organizations source code 
proc 
th intl 
workshop program comprehension june 
metropolis rosenbluth rosenbluth teller teller equation state calculations fast computing machines 
journal chemical physics 
mitchell heuristic search approach solving software clustering problem 
phd thesis drexel university philadelphia pa jan 
mitchell heuristic search techniques extract design abstractions source code 
gecco proceedings genetic evolutionary computation conference new york july morgan kaufmann publishers pp 

mitchell genetic algorithms 
mit press 
miller orgun tilley uhl reverse engineering approach subsystem structure identification 
journal software maintenance research practice 
harrold peck test data generation genetic algorithms 
journal software testing verification reliability 
reeves ed 
modern heuristic techniques combinatorial problems 
blackwell scientific press oxford uk 
ryan automatic re engineering software genetic programming 
kluwer academic publishers 
ryan walsh evolution provable parallel programs 
genetic programming proceedings second annual conference stanford university ca usa july koza deb dorigo fogel garzon iba riolo eds morgan kaufmann pp 

youssef iterative computer algorithms applications engineering solving combinatorial optimization problems 
ieee computer society 
intelligent tool re engineering software modularity 
proceedings international conference software engineering may pp 

drexel university software engineering research group 
mcs drexel edu 
shannon mathematical theory communication 
bell system technical journal july october 
shaw garlan software architecture perspectives emerging discipline 
prentice hall 
shepperd foundations software measurement 
prentice hall 
smith kids semiautomatic program development system 
ieee transactions software engineering sept 
tracey clark mander automated program flaw finding simulated annealing 
international symposium software testing analysis march acm sigsoft pp 

tracey clark mander way forward unifying dynamic test case gener ation optimisation approach 
international workshop dependable computing applications january ifip pp 

van deursen kuipers identifying objects cluster concept analysis 
tech 
rep sen centrum voor wiskunde en informatica cwi sept 
van laarhoven aarts simulated annealing theory practice 
kluwer academic publishers dordrecht netherlands 
ward assembler migration fermat transformation system 
ieee international conference software maintenance icsm oxford uk aug ieee computer society press los alamitos california usa 
ward munro maintainer assistant 
proceedings international conference software maintenance ieee computer society press los alamitos california usa 
wegener baresel sthamer evolutionary test environment automatic structural testing 
information software technology special issue software engineering metaheuristic innovative algorithms 
wegener grimm sthamer jones systematic testing real time systems 
th international conference software testing analysis review 
wegener sthamer jones testing real time systems genetic algorithms 
software quality 
whitley beveridge graves messy genetic algorithms subset feature selection 
proceedings th international conference genetic algorithms san francisco july ed morgan kaufmann pp 

program developments formal explanations implementations 
communications acm nov 
williams evolutionary algorithms automatic parallelization 
phd thesis university reading uk department computer science sept 
williams williams genetic compilers new technique automatic parallelisation 
nd european school parallel programming environments france pp 

williams fagg experience developing codes distributed parallel architectures 
workshop distributed parallel divergence 
mar parallel distributed group pp 

winter periaux genetic algorithms engineering computer science 
wiley 

