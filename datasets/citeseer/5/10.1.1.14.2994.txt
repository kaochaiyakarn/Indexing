practical flow sensitive context sensitive memory leak detector presents static analysis tool automatically find memory leaks deletions dangling pointers large applications 
developed type system formalize practical ownership model memory management 
model object pointed owning pointer holds exclusive right obligation delete object transfer right owning pointer 
addition class member field required public method boundaries 
programs satisfying model leak memory delete object 
developed flow sensitive context sensitive algorithm automatically infer ownership interfaces methods program 
identifies statements inconsistent model sources potential leaks double deletes 
algorithm sound respect large subset language report possible errors 
practical useful identifies warnings correspond errors helps user understand reported errors showing assumed method interfaces 
techniques validated implementation tool call 
applied suite applications web servers chat client secure shell tools executable object manipulation tools compiler 
tool total serious memory errors applications 
tool analyzes lines code minutes ghz pentium machine lines code just minute 
categories subject descriptors software engineering coding tools techniques software engineering program verification programming languages processors memory management material supported part national science foundation 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
pldi june san diego california usa 
copyright acm 
david heine monica lam computer systems laboratory stanford university lam stanford edu general terms algorithms experimentation languages verification 
keywords program analysis type systems memory management error detection memory leaks 

existing programs written memory needs manually managed 
leaking memory deleting object multiple times common hard errors programs 
memory leaks cause long running programs server codes fail 
deleting object deleted cause memory corruption 
existing tools dynamic tools purify commonly detecting memory management errors programs 
purify instruments program reports allocated memory program exit pointed pointers 
unfortunately find leaks occur instrumented executions incurs nontrivial run time overhead 
purify identify allocation sites leaked memory users left difficult task finding statements cause leak 
number automatic static analysis tools prefix metal developed help find memory leaks programs 
tools aim identify cases program loses object having deleted object 
global pointer alias analysis tools track pointers stored recursive data structures container objects 
find memory leaks occur close allocation sites missing errors account important leaks real programs 
techniques require user participation proposed 
linear types allow dynamically allocated object 
restriction enforced contents linear typed variable read 
pointer assignment executed value ofp nullified sole object pointed byp 
memory management simple linear types deleting object unique destroyed guarantees memory leaks double deletes dangling 
unfortunately difficult program semantics linear types 
ptr template class standard library attempt practical solution 
auto ptr owns object points ptr destroyed object points automatically deleted 
auto ptr nullified copied linear types multiple allowed 
similar concepts adopted lclint require programmers decorate pointer variables shared keywords 
burden imposed programmer lack support polymorphic ownerships functions render techniques unappealing 
contributions developed fully automatic technique find memory leaks multiple deletes large programs 
powerful find leaks objects stored recursive data structures programs 
main contributions include formalization practical memory management scheme object ownership fully automatic ownership inference algorithm validation ideas implementation experiment 
practical object ownership model way ensure memory leaked check object deleted 
enforcing property difficult requires things tracking pointers recursive data structures carefully 
fact hard programmers dealing objects multiple aliases resort dynamic schemes 
dynamic counting expensive handle circular data structures 
practice programmers adopt simple programming conventions help manage memory 
convention object ownership associates object owning pointer owner times 
owning pointer holds exclusive right obligation delete object points transfer right owning pointer 
deleting object points owning pointer non owning 
non owning pointers may point object time 
note notion ownership different concept ownership encapsulation assumes accesses object go owning pointer :10.1.1.23.2115
model eliminates possibility deleting object guarantees deletion objects 
counting model may leak objects owning pointers form cycle 
rare practice programs designed acyclic ownership structures 
designed object oriented programs simple external method interfaces 
common idiom require pointer member fields object public method boundaries 
correspondingly destructor method object contains code delete objects pointed owning member fields 
adopting assumption tool reason object ownership relative ease afforded programmers 
developed formal type system small language capture object ownership model described 
expanded formal model handle safe features full languages 
ownership model applicable real programs 
linear types multiple non owning allowed point object 

ownership transferred 
object owner immediately creation ownership may transferred owner owner object deleted 

normal assignment parameter passing semantics supported allowing ownership optionally transferred 
statement object statement retain ownership transfer ownership non owning pointer assignment 

object member fields required ownership public method boundaries 
specifically invariant required hold method invocations receiving object may sending object 

polymorphic method interfaces supported 
ownership type signatures methods represented constraints ownerships input output parameters 
method may invoked parameters different ownerships long constraints satisfied 
note advocating exclusive ownership model objects 
appropriate manage objects program techniques counting region management 
system require memory managed solely ownership model 
automatic ownership inference algorithm automatically infers ownership signatures pointer member fields method interfaces directly code applied existing programs modification 
algorithm sound reports possible errors large safe subset described section 
algorithm practical useful reasons 
flow sensitive context sensitive algorithm powerful fast run real programs 
designed isolate sources errors propagate 
identifies warnings correspond errors 
lastly helps users understand error reports showing assumed method interfaces 
object ownership model designed allow fast inference 
tracking properties objects count counting requires tracking aliases objects expensive 
ownership property associated objects managed property associated pointer variables 
place ownership inference constraints pointer variables ensure ownership conserved assignments parameter passing procedures 
methods classes allowed transfer ownership pointer member fields 
assuming member fields owning owning public method boundaries easily track member fields object methods class 
alias analysis rendered unnecessary allowing ownership transferred pointer member fields outside class static pointer variables pointers pointers pointer arrays 
model simple sufficient find errors real code 
powerful flow sensitive context sensitive ownership inference 
algorithm tracks ownerships flow sensitively transferred local variables context sensitively transferred procedural parameters 
ownership tracked valued variables means owning means non owning 
ownership inference modeled solving limited forms linear inequalities 
represent method ownership types polymorphically succinctly linear inequalities ownerships input output parameters 
sparse representation akin semi pruned ssa form reduce size constraints method 
ownership constraints resolved general purpose solver developed specialized ownership constraint solver efficiency gain control inconsistencies reported 
sound practical tool prioritizing constraints 
difficult deduce actual cause errors reported polymorphic type systems 
especially model encompass legal ways managing memory sound algorithm potentially generate false positive warnings render tool ineffective 
solution satisfy precise constraints minimize propagation errors associated precise constraints 
addition warnings ranked precision constraints violated 
concentrating high ranked warnings help automatically computed method signatures user find errors program reasonable effort 
advantage having sound system researchers browse low ranked warnings understand system weakness uncover opportunities improvement 
validation implemented algorithm program analysis pass suif compiler infrastructure 
applied system called large open source software systems total lines code 
programs experiment contains classes conform object ownership model 
definite errors programs 
analyzed lines code minutes ghz pentium machine 
organization rest organized follows 
section gives overview design ownership model 
section presents formal ownership type system simple object oriented programming language describes extend system 
describe type inference algorithm section experimental results section 
describe related section conclude section 
appendix contains static typing rules ownership type system 

overview section presents high level overview rationale system help examples 
describe create constraints model ownership program order satisfaction constraints improve quality error reports 
optional ownership transfer assignments pointers returned allocation routines pointers passed deallocation routines definition owning pointers 
ownership pointer variables needs inferred illustrated simple example example 
assignment statements 
new int delete object allocated statement clearly leaked deleted statement 
system track pointer aliases se 
knows owner allocation function statement owner delete operation statement 
statement represents possible transfer ownership constraints satisfied requiring ownership transferred program leak free 
notice analysis necessarily flow sensitive 
source destination variables assignment statement may change ownership execution assignment 
addition forward backward flow information necessary resolve ownership variables illustrated example 
model statements constraints constraints extracted program satisfied program memory leaks 
analysis path sensitive variable ownership confluence control flow paths 
polymorphic ownership signatures analysis uses accurate fixpoint algorithm compute polymorphic ownership interfaces method program 
analysis initially approximates effect method ignoring methods invokes 
instantiates approximation callee constraints caller context create better approximation 
step repeated solution converges 
example 
recursive procedures 
int id int int pred int new int id delete return recursively defined id function returns original input value side effect possibly creating deleting number integers 
id called owning input parameter return value recursive cycle analysis correctly summarizes function requiring input parameter return value identical ownerships 
object ownership programs member fields objects assumed owning owning public method boundaries 
analysis starts examining class constructors destructor determine ownership signatures fields fields owning non owning public method boundaries 
object member fields modified methods invoked object analysis needs track member fields object methods object 
method invocation boundaries member fields take ownership specified signatures 
example 
object invariants 
class container elem public container elem elem elem void set elem elem delete elem elem get return elem repl elem elem elem tmp elem return tmp container delete member field easily recognized owning member class destructor container deletes 
identified owning member field analysis infer ownership pointers passed returned method class 
constructor container passed owning pointer return value get owning argument return repl owning 
example illustrates limitation model 
practice classes implement method aset delete original member field 
object invariant temporarily violated code retrieve owning pointer uses set deposit owning pointer place 
analysis flags idiom violation ownership model 
reporting errors important leak detection tool pinpoints statements leak memory 
system memory leak shows inconsistency constraints collected number statements 
tool strive identify statements erroneous 
solution try satisfy precise constraints classify constraints inconsistent errors leave consideration subsequent analysis 
furthermore rank identified errors precision constraints violated 
example 
class defined example suppose illegal class deletes element returned get analysis considered constraints generated usage conclude member field owning container class 
lead analysis generate errors correct uses class including container destructor function 
analysis avoids problem constraints destructors constructors considered precise satisfied 
system allow writes owning pointers fields structures arrays pointers 
violations restriction expected real programs 
avoid propagating inaccuracy statements program algorithm analyzes code assuming indirect accesses optionally hold owning pointers re analyzes stricter constraint generate warnings necessary system sound 
details constraint ordering section 
object ownership constraints section presents formal type system models object ownership 
define small object oriented programming language typed ownerships 
language associates ownership variables pointers indicate 
member field class field signature indicates owning non owning public method invocations 
method ownership signature specifies constraints ownership variables associated parameters results 
note language defined declared field method signature ownerships inference algorithm automatically infers signatures programs 
typed programs ownership type system shown approach developed wright felleisen satisfy properties property 
exists owning pointer object allocated deleted 
property 
delete operation applied owning pointer 
property guarantees memory leaks objects pointed variables deleted 
properties guarantee objects deleted 
language section 
sections describe handling intraprocedural constraints interprocedural constraints respectively 
section describes handle null pointers 
section describes extensions cover safe features 
language typed ownership program consists set classes cl class cl ordered set member fields set methods 
constructors destructors execute arbitrary code call methods 
constructors list formal arguments return value destructors single implicit argument methods argument formal arguments return value 
method body contains statement access variable local variables parameters 
field accesses allowed object 
language number assignment statements 
simple variables assigned null values variables class fields method invocation results 
fields class assigned variables 
language number compound statements composition 
language ownership variables associated parameters method member fields class 
ownership variables may values means owning means non owning 
constraints ownership represented linear inequalities ownership variables 
constraints form semi lattice 
top element lattice istrue bottom element 
meet operator lattice corresponds conjunction linear constraints 
solutions satisfying satisfy 
member field class associated field ownership type specifies field associated ownership variable value 
method invoked receiver object fields sender receiver objects obey ownerships specified respective field ownership types 
method class associated method ownership type 
specifies ownership variables formal arguments class member fields method entry exit return value 
specifies set linear constraints satisfied ownership variables 
signatures constructors include ownership variables formal arguments fields method exit return value 
signatures destructors include ownership variables fields method entry 
typing rules system ensure object created ownership held pointer variable 
ownership may transferred assignments parameter passing method invocations stored owning member field 
object deleted owning variable relinquishes ownership objects pointed owning member fields deleted 
typing judgments statements system form states mapping variables declared class type mapping variables ownership variables set ownership constraints legal execute statement results new ownership mapping new constraints static ownership typing rules shown appendix due space constraints discuss representative inference rule detail give readers flavor system defined formally focus explaining intuition formulation 
intraprocedural ownership constraints assignment statements 
consider assignment statement simple variables 
inference rule simple assignment statement rule stmt asgn appendix reproduced fresh term functional update map binds removing old binding 
ownerships change statement 
represents ownerships statement represent ownerships statement 
overwritten statement memory leaked 
constraint guarantees conservation ownership required property 
owns statement retains ownership transfers statement 
owner statement 
method fields object treated local variables 
define rules stmt stmt handle assignments member fields object 
similar stmt asgn counterpart 
pointer treated owning non owning 
legal delete null pointer 
relaxed constraint useful analyzing 
right hand side assignment statement require overwritten variable assignment non owning rule stmt null 
new unbound ownership variable generated represent ownership destination variable assignment 
control flow statements 
rule composition stmt comp straightforward 
treatment control flow 
join points variables fields ownership confluence control flow paths reflected rules stmt stmt 
interprocedural constraints constructors new destructors delete special guaranteed return owning pointers expect owning pointers 
separate inference rules constr method specify constructors destructors methods typed 
local variables defined statement method carry ownership entry exit return variables start non owning may carry ownership exit 
ownership constraints imposed method scope statement externally visible variables summarized method ownership type mot 
variables externally visible include parameter input parameters member fields method entry exit return value 
keep type system simple adopted convention variables passed input parameters assigned fresh variables passed parameters place 
implies owning actual parameters assumed pass ownerships formal counterparts 
formal input parameters may owning non owning entry owning exit 
convention avoids complexity arises variable passed multiple arguments method 
refer method invocations sender receiver known object internal 
method invocations considered external 
indicated inference rule internal method invocations stmt execution 
involves instantiating constraints declared method ownership type replacing formal ownership variables fresh variables 
equations set ownerships actual parameters fields corresponding instantiated formal variables 
ownership implicit argument may optionally passed invoked method 
furthermore ownership return value transferred variable caller hold ownership statement 
inference rule external method calls stmt differs rule internal calls treatment member fields 
member fields sender receiver objects match respective declared field ownership types fot 
rules constructors stmt constr destructors stmt slight modifications external calls due differing parameter return signatures 
example 
shown short program method ownership types included comments 
method ownership type represents ownership entry ownership variables second arguments ownership variables method entry exit respectively ownership variable returned result 
signature says ownership passed method input parameter owning pointer member field non owning method entry 
addition signature polymorphically captures fact argument called owning non owning pointer allows ownership transferred member field returned result 
easy tell reading code method objects created deleted leaked 
second invocation method particularly interesting object passed second arguments method fact analysis captures constraint caller 
ownership signature method ownership variables represents entry method represent field entry exit 
statements ownerships may change labeled names freshly generated ownership variables 
ai denote ownership variable method generated executing statement denote instantiated ownerships variable jth invocation extracted ownership constraints method 
keep example short constraints call call directly encode choice ownership transfer arguments 
addition omitted ownership variables associated initial ownership values local variables constrained non owning 
shall shown example seemingly complex constraints simple structure satisfiable 
memory leak method 
projecting away externally invisible variables gives constraints declared ownership type 
example illustrates system handles aliases 
signature depend input parameters aliased 
alias implicitly captured ownership constraint calling method pointer variables 
handling null pointers programs check pointer null deleting object null delete idiom problematic path insensitive system described objects deleted path 
solution handle predicates test pointer null inserting explicit null assignment pointer appropriate path 
example previous statement translated null delete null treated owning non owning pointer analysis correctly deduce pointer longer owning branches merge 
intraprocedural analysis values method precisely represented owning non owning 
class int int int int delete int return void int new int int new int int delete new int 
stmt call stmt stmt call exit short program method ownership types ownership constraints method handling features small language object oriented model simply treating functions methods defined global object 
extended system handle various features including multiple inheritance virtual dispatch static functions multiple constructors class templates 
features program cause unnecessary warnings system 
model currently requires atomic memory allocation object construction atomic object destruction deallocation 
breaking invariants placement new syntax making explicit calls destructor generate warnings 
system model ownerships language features aliases address pointer member field class concurrent execution exception handling unsafe pointer arithmetic function pointers 
features may prevent system identifying potential leaks 
conversely features algorithm sound report potential memory leaks 

ownership inference ownership inference algorithm automatically infers ownership signatures fields methods 
identifies statements inconsistent signatures warns potential memory leaks double deletes 
constraints introduced carefully designed order isolate source errors 
constraint inconsistent established constraints discarded associated statement labeled error 
describe specialized constraint solver determine set constraints consistent 
describe interprocedural type inference algorithm 
order constraints considered 
constraint resolution constraints ownership variables shown inference rules appendix integer equalities 
introduced section described section integer inequalities introduced algorithm minimize error propagation 
ownership constraints form developed solver optimized take advantage special properties held ownership constraints 
attempt apply general solver problem suggests significantly slower special purpose solver 
ownership graphs ownership constraints represented bipartite ownership graph set partitions ownership variables set flow nodes representing non constant constraints set directed edges connecting nodes nodes vice versa 
partition may label representing owning representing non owning 
initially ownership variable placed partition 
solver gradually rewrites ownership graph create smaller equivalent graphs ownership partitioning functions map elements set ownership variables respective partitions 
constant constraints represented labeling partitions accordingly 
non constant constraint represented flow node edge edges flow node incoming edge possibly multiple outgoing edges 
flow nodes named properties 
source incoming edge flow node labeled outgoing edges destinations labeled 
source incoming edge flow node labeled outgoing edge destination labeled 
special case flow node represents equality constraint exactly outgoing edge destination labeled 
consistency checks describe solver checks new constraint consistent set consistent constraints represented ownership graph partitioning function returns combined set constraints inconsistency detected 
new constraint constant constraint assign 
different label constraint inconsistent 
new constraint nonconstant constraint represent constraint adding new flow node corresponding edges described 
apply rewrite rules repeatedly applicable 
application rewrite rules requires assigning labeled partition different value new constraint inconsistent 
describing rewrite rules define terms 
say node reaches exists path edges lead unify node node merge partition assigning replacing flow edges edges respectively 
rewrite rules follows 
remove flow node edges predecessor successor nodes labeled 

equality flow node single predecessor single successor unify 
assign reachable 
eliminate edges oneout 
assign reaching multipath 
flow node reaches partition distinct paths assign 

unify partitions cyclic path assign partition reachable unified partition 
rule self explanatory 
understand cy rule consider cases 
partition cycle labeled pass ownership back cycle partitions cycle labeled 
conversely partition cycle labeled partitions necessarily labeled 
case ownership passed downstream 
refer ownership graph obtained rewrite procedure canonical ownership graph 
easy show canonical ownership graph consists set unconnected directed acyclic graphs dags root partitions may labeled rest unlabeled 
graph trivially satisfiable true 
root nodes labeled 
labeling nodes solution 

labeled root nodes common descendant 
solution assigning arbitrary descendant labeled root node 
general case simple tests fail check connected components dag independently satisfiability dags small practice 
example 
ownership graph derived method calls method instantiated 
flow nodes represented simply equal sign 
square ownership graph method instantiations nodes represent variables visible outside circles represent variables internal square circle represents partition embedded oval represents unification variables 
partition node labeled ownership assignment known 
edges ownership graph represented arrows 
nodes edges instantiated method represented dotted lines 
easy see solution graphical representation 
ownerships held flow right edge flow node rightmost descendant case labeled 
interprocedural analysis algorithm polymorphic fully context sensitive finds constrained signature method field ownership type typed programs 
algorithm introduces inaccuracy presence recursive cycles 
section describes find method ownership types assuming field ownership types 
discuss field ownerships handled section 
algorithm creates set constraints representing effect method assuming called methods constraints 
iterates find better approximation solution stabilizes 
algorithm strongly connected components program call graph 
method evaluation performed reverse topological order components iteration needed components 
ownership type method changed methods invoke changed method re evaluated 
create initial summary method collect constraints statement method inference rules appendix ignoring method invocations 
handle arbitrary control flow programs ssa algorithm generate ownership variables method unifications ownership variables join points control flow 
ownerships may change source destination variables assignment statement adapted original ssa algorithm create new ownership variables destination variables source variables 
prune ssa form removing unnecessary joins variables live ranges limited basic block 
apply intraprocedural dead code elimination reduce unnecessary assignments code 
solver defined section applied constraints collected create canonical ownership graph method 
note system may inconsistent process consistent constraints summarize method 
iterative step method visited signature callees changed 
callee new constraint information reduce current ownership constraints pure relations formal parameters 
project away internal partition nodes connecting input parameter fresh flow node connected output parameters reached input 
may create edges limits name space ownership partitions 
relations formal parameters instantiated calling context substituting actual parameters formal parameters 
solver applied check constraints consistency simplify 
ownership graph method example intraprocedural analysis interprocedural analysis 
example 
returning example algorithm creates intraprocedural summary methods calls solver simplify constraints internal method ignoring constraints callees projects away internal variables parameters 
result step shown 
remains ownership graph external parameters parameters passed callee note instantiated constraints shown dotted lines visible step shown 
second step algorithm instantiates constraints intraprocedural summary applies solver resulting graph yielding result shown 
final signature obtained projecting away internal variables including ownership variable included simply 
complication arises practice programs invoke functions methods source code available 
include system calls calls libraries compiled separately 
predefine method ownership types number system calls strcpy 
allow user give specification routines 
specification provided assume parameters undefined functions non owning 
constraint ordering specification impossible tell constraints set inconsistent constraints erroneous ones 
heuristics find statements incorrect 
misclassifying erroneous statement correct result misclassifying correct statements erroneous 
propagation errors result warnings require user effort diagnose 
statements precisely modeled 
example allocations precisely modeled return owning pointer 
hand constraint owning pointers stored indirectly imprecise violated 
similarly methods contain ownership errors 
destructors correct handling member fields methods invoke 
approach minimizing error propagation classify constraints degree precision try satisfy precise constraints 
addition rank warnings precision constraints violated 
typing fields methods assume implementation class reliable source identifying interface code uses class 
top level algorithm steps finds ownership type member fields class considering methods class uses field ownerships program analysis find method ownership signatures 
find class member field ownerships algorithm similar described section 
step analyzes class time 
constructors destructors may invoke methods interprocedural analysis 
model external invocations simply assuming constructors return owning pointers destructors accept owning pointers arguments ignoring constraints 
member field ownerships initialized meaning owning non owning 
destructors constructors analyzed methods 
member field presumed owning owning entry destructor owning exit constructors 
presumed non owning 
ranking statements intraprocedural analysis orders constraints precise constraints satisfied 
ranking starting precise 
constant constraints including allocations deletions overwritten variables variables entering exiting scope 

equality flow constraints single output generated uncommon control flow paths 
arise join nodes assignments choice 
flow nodes generated joins lower fan considered precise 

constraints generated assignments choice 

flow constraints arising joins uncommon control flow paths loop continues breaks 

constraints generated loads stores involving indirect pointer accesses 
handling inaccuracies methods order methods analyzed dictated call graph possible find ownership signature method signature callees 
creates problem errors summarizing callee propagate interprocedurally callers 
kinds constraints particular concern constraint indirectly accessed pointers may hold ownership constraint undefined functions owning parameters return values constraint fields sender object honor ownership type external invocations 
constraint overly restrictive external calls access member fields sender object 
solution analyze program relaxed versions constraints 
relax constraints allow indirectly accessed pointers parameters undefined functions optionally hold ownerships 
constraints represented inequalities 
sender member fields need obey field signatures external method invocations 
analysis walk method tighten constraints report rest violations 

experimental results memory leak detector implemented incorporates techniques described 
implemented program analysis pass suif compiler infrastructure 
finding potential errors program generates inferred ownership signatures procedure class method class member field 
signatures help users understand warnings generated 
sound safe subset section meaning report possible errors program 
warnings pertain incorrect usage ownership model main objective tool 
warnings due limitations analysis schemes object ownership managing memory 
evaluate utility system applied large applications 
tool reported warnings applications 
examined warnings determine correspond errors program 
errors package potentially serious memory leaks double deletes total 
application programs application suite experiment consists packages packages 
programs suite widely gnu set object file generation transformation tools set secure shell clients servers apache web server 
applications active development internet chat client pi web web server written suif compiler base package 
available sourceforge net suif available athttp suif stanford edu 
packages contain number executable programs libraries shown 
includes statistics package including number source files number functions lines code loc measured counting unique non blank lines preprocessed source code 
total tool analyzed lines code experiment 
report size largest program package time ownership inference takes program 
measurements taken ghz pentium machine gbytes memory 
numbers include time required front linker preprocessing transformations 
took minutes analyze lines code largest exe package exe lib files func loc loc time apache pi web suif total application characteristics number executables libraries files functions lines code lines code largest executable ownership analysis time seconds 
minutes analyze lines code 
program analysis slower extra intra class analysis determine member field ownerships inclusion member fields analysis larger call graphs generated class hierarchy analysis optimized implementation analysis fast experimentation 
packages generated total warnings programs suite 
warnings separated classes violations intraprocedural constraints violations interprocedural constraints escaping violations 
escaping violations refer possible transfers ownership pointers stored structures arrays indirectly accessed variables 
warnings tell users data structures program may hold owning pointers leave user burden determining pointers leak 
users expected examine escaping warnings examined non escaping warnings find program errors 
warnings non escaping intraprocedural interprocedural 
altogether errors shown 
error warning ratio intraprocedural violations interprocedural violations 
method signatures generated helpful examination interprocedural warnings 
intraprocedural interprocedural package reported bugs reported bugs escapes apache total reported warnings identified errors applications errors due missing object deletions abnormal control flow paths early procedure returns loop breaks 
procedures return pointers newly allocated statically allocated memory 
occasionally deletes missing normal execution loop 
memory allocation deletion routines wrapped procedures interprocedural analysis prerequisite finding leaks program 
apache web server illustrates interesting scenario 
reported warnings error 
examination warnings quickly revealed apache manages memory region scheme 
understand region management warnings generated succeed helping users understand program manages memory 
packages offers functionality finding leaks programs 
assuming member fields owning public method boundaries find errors associated leaks stored class member fields 
generates categories warnings violations receivers member field ownerships violations senders member field ownerships external invocations 
discussed section caused limitations model real errors program 
breakdown category warnings errors shown 
analyzed receiver field intraprocedural interprocedural violations look memory leaks double deletes 
common suspicious practices classify minor errors 
classes owning member fields copy constructors copy operators default implementations incorrect copying owning fields create multiple owners object 
copy constructors copy operators current code properly defined case 
second interprocedural warnings reported suif caused leaks occur just program finds assertion violation aborts 
implemented simple interprocedural analysis catch cases suppress generation errors desired 
counting minor errors examined warnings lead errors 
ignoring minor errors warnings examined warnings lead errors 
experiment shows object ownership model applications 
ignoring minor default copy constructors copy operators problem classes owning member fields leaks pi web 
suif compiler classes leak owning members class destructor delete default destructor 
identified serious errors object deleted twice 
double deletes significant memory leaks cause memory corruption undefined behavior 
discussion experience working real life applications leads number interesting observations 
field method signatures generated help explain programmer cause warnings 
explanations required effective error detection tools 
generated method interfaces allow users reason methods time 
generated method interfaces erroneous programmers easily detect errors 
second automatic tools affected problems mislead programmers 
error caused misnomer 
function alloc return ownership newly allocated objects despite name giving credence function names easily derived fact implementation 
example leaks generated macros expand include early loop exits cause memory leaks 
difficult programmer looking preprocessed code find leaks 
examples receiver field intraprocedural interprocedural sender field package reported major minor reported major reported major minor escapes pi web suif total reported warnings applications identified major minor errors suggest tools find new program errors audited code 
third needing specification find inconsistencies programs say sure statements program wrong 
inconsistencies interesting programmers correspond erroneous memory usage 
code programmer called wrong function mistake 
function happened ownership signature different intended function 
examining ownership inconsistency reported able discover hard find error 
inconsistencies due unusual programming styles 
suspicious case pointer middle object stored owning pointer 
pointer happens suitably decremented point object freed 
identification unconventional pointer usage interest programmer 
fourth detecting program errors step fixing errors 
fixing memory leaks especially errors caused poorly designed interfaces hard 
leaks appear discovered comments source files near reported problems 
fixed presumably complexity involved 
fact reported interface problem developer introduced bug attempt fix error 
incidentally bug caught run applying fix 
successfully helped identify number errors large complex programs experiment revealed weaknesses current system suggests interesting avenues 
useful possible reduce number false warnings receiver field intraprocedural interprocedural violations 
predicates indicate pointers objects adding path sensitivity reduce number false warnings 
receiver field violations due idiom combination replace owning member field 
relaxing ownership model improving analysis handle cases useful 
importantly need help programmers find leaks escaping violations 
programs pass pointers pointers parameters simulate pass semantics 
better handling pointers useful 
need improve handling objects containers 
investigation suggests containers handled having user specify relationships containers elements code augmenting static analysis described 
details subject 

related research builds previous linear types object ownership models capability type systems 
design system driven mainly goal build tool applied large existing code bases 
ownership model 
notion ownership adopted practitioners shares similarities concepts embodied auto ptr lclint 
owning pointers help find memory leaks eliminate dangling pointers 
model adds optional ownership transfer assignment allows arbitrary aliases includes object ownership invariant public method boundaries 
formalized ownership model developed algorithm automatically infer polymorphic ownership signatures methods fields programs 
clarke proposed stricter model ownership known ownership type 
basic notion object may subobject 
object owned object furthermore ownership types enforce object encapsulation objects referenced owner pointers 
notion encapsulation restricts access subobjects allowing reason subobject considering methods object 
preventing data races deadlocks 
various extensions proposed allow restricted forms access objects going owner 
uses flexible ownership type system 
possible change ownership object owner permission access object object aliases temporarily created owned objects 
enabled expression parameterized containers iterators enforcing encapsulation properties 
ownership passed system bears similarities linear types 
allow non owning pointers assignments may may transfer ownership option captured constraint system typesafe long constraints derived satisfiable 
strict linear types require right hand side pointer nullified 
language extensions proposed allow read aliases 
boyland alias allows aliases aliases nullified read 
proposed inference algorithm requires annotations placed procedural interfaces 
alias types proposed allow limited forms aliasing specifying expected data memory shape properties 
linear types applied track resource usage verify correctness region memory management 
dor propose checking memory leaks sophisticated pointer shape analysis unfortunately scalability powerful technique demonstrated 
automatic inference 
ownership inference fully automatic quite powerful 
automatic interprocedural annotation inferencing software understanding tools cluding ajax 
tools support polymorphism context sensitivity algorithm flow sensitive 
know inference algorithms allow choice ownership transfer assignment statements method invocations 
idea useful solving resource management problems 
experimental results 
includes experimental results demonstrating success system finding errors large programs 
experimental results reported previous involving ownership models 
able apply system large programs system assumes flexible model requires user intervention efficient flow sensitive context sensitive algorithm 
gnu compiler flag warns violations meyers effective rules include rules minimize memory leaks 
tool uses mainly syntactic analysis tends generate false warnings 
fully automatic tools prefix metal effective finding program errors 
unsound lacking notion object invariants tools shown find errors large systems 
handling false warnings major issue systems 
experience prefix system shows important prioritize warnings programmers focus errors 
metal statistically identifies common coding practice program classifies deviations errors 
prioritize warnings likelihood representing real errors 
errors system appear consistency violations particularly important attribute errors source correctly 
satisfying precise constraints 
experience confirms constraint ordering important generating useful error reports 

formalizes practical object ownership model managing memory 
model object pointed owning pointer 
owning pointer holds exclusive right obligation delete object transfer right owning pointer 
addition pointer typed class member field owns public method boundaries 
model analyze existing code supports normal semantics assignments method invocations 
assignments may transfer ownership source destination variable required 
capture choice ownership transfer integer linear inequalities 
addition method interfaces integer linear inequalities capture ownership relationships parameters method 
representation supports powerful form polymorphism 
developed flow sensitive context sensitive algorithm automatically infers field method ownership signatures programs identifies statements violating model errors 
optimized algorithm sparse graph representation custom constraint solver take advantage highly structured ownership constraints 
memory detection tool designed help users isolate errors program 
tries satisfy precise constraints prevent errors associated precise constraints propagating 
warnings ranked focus users warnings lead errors 
member field ownerships method signatures tool generates give context reported constraint violations minimize code inspection required identify bugs warnings 
experimental results suggest algorithm effective efficient 
finds errors large software systems experimented include web servers secure shell clients servers chat client object code tools suif compiler 
algorithm practical analyzed lines code minutes ghz pc 

aldrich chambers 
alias annotations program understanding 
proceedings oopsla object oriented programming systems languages applications pages november 
boyapati lee rinard 
ownership types safe programming preventing data races deadlocks 
proceedings oopsla object oriented programming systems languages applications pages november 
boyapati liskov shrira 
ownership types object encapsulation 
proceedings thirtieth annual acm symposium principles programming languages pages january 
boyland 
alias unique variables destructive reads 
software practice experience may 
briggs cooper harvey simpson 
practical improvements construction destruction static single assignment form 
software practice experience july 
bush pincus 
static analyzer finding dynamic programming errors 
software practice experience june 
clarke 
object calculus ownership containment 
eighth international workshop foundations object oriented languages january 
clarke drossopoulou 
ownership encapsulation disjointness type effect 
proceedings oopsla object oriented programming systems languages applications pages november 
clarke potter noble 
ownership types flexible alias protection 
proceedings oopsla object oriented programming systems languages applications pages october 
crary walker morrisett 
typed memory management calculus capabilities 
proceedings sixth annual acm symposium principles programming languages pages january 
dor rodeh sagiv 
checking linked lists 
proceedings static analysis symposium pages july 
engler chen hallem chou chelf 
bugs deviant behavior general approach inferring errors systems code 
proceedings eighteenth acm symposium operating system principles pages october 
evans 
static detection dynamic memory errors 
proceedings sigplan conference programming language design implementation pages may 
hndrich deline 
adoption focus practical linear types imperative programming 
proceedings acm sigplan conference programming language design implementation pages june 
gay aiken 
memory management explicit regions 
proceedings acm sigplan conference programming language design implementation pages may 
gay aiken 
language support regions 
proceedings acm sigplan conference programming language design implementation pages may 
gifford lucassen 
integrating functional imperative programming 
acm conference lisp functional programming pages august 
grossman morrisett jim hicks wang cheney 
region memory management cyclone 
proceedings acm sigplan conference programming language design implementation pages june 
hallem chelf xie engler 
system language building system specific static analyses 
proceedings acm sigplan conference programming language design implementation pages june 
hastings joyce 
purify fast detection memory leaks access errors 
proceedings winter usenix conference pages december 
noble vitek potter 
flexible alias protection 
th european conference object oriented programming pages july 
callahan 
generalized aliasing basis program analysis tools 
phd thesis carnegie mellon university november 
callahan jackson 
program understanding tool type inference 
proceedings th international conference software engineering pages may 
smith walker morrisett 
alias types 
proceedings ninth european symposium programming pages april 
tofte 
talpin 
region memory management 
information computation february 
wadler 
linear types change world 
broy jones editors ifip tc working conference programming concepts methods pages april 
walker morrisett 
alias types recursive data structures 
lecture notes computer science 
wright felleisen 
syntactic approach type soundness 
information computation november 
appendix static typing rules appendix includes static typing rules ownership type system 
gives typing rules statements method involving method invocations 
gives typing rules method definitions invocations 
gives syntax rules static judgments 
program typed typed constructor destructor methods fields class program 
set constraints consistent 
define restriction resulting constraint projecting away variables 
stmt null fresh null stmt asgn fresh stmt fresh stmt fresh stmt comp stmt dom stmt dom typing rules statements method cm fresh tx tr tz 
true 
cm cm tx tr scope tr tz return constr new cm fresh tx tz 
true 
cm cm newc tx scope tz return delete cm fresh tz 
true 
cm cm scope tz stmt 
fresh cm cs cm fresh cs stmt 

fresh cm cs cm fresh cs stmt constr 
fresh new cm cs cm fresh cs newc stmt 
fresh delete cm cs cm fresh cs method definition invocation typing rules program cl tx tr 
newc tx 

constraint false typed programs 
