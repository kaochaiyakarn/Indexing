theory competitive analysis distributed algorithms ajtai james aspnes cynthia dwork waarts june introduce theory competitive analysis distributed algorithms 
rst steps direction seminal papers bartal fiat rabani awerbuch kutten peleg context data management job scheduling :10.1.1.56.8354
papers subsequent cost distributed algorithm compared cost optimal global control algorithm 
done implicitly earlier awerbuch peleg 
introduce re ned notion competitiveness distributed algorithms re ects performance distributed algorithms accurately 
particular theory allows compare cost distributed line algorithm cost optimal distributed algorithm 
demonstrate method studying cooperative collect primitive rst abstracted saks shavit woll 
algorithms di erent strengths primitive provide competitive analysis 
preliminary version th symposium foundations computer science november 
ibm almaden research center harry road san jose ca 
mail ajtai almaden ibm com dwork almaden ibm com resp 
yale university department computer science prospect street box new haven ct 
supported nsf ccr 
part research performed ibm almaden 
mail aspnes james cs yale edu 
computer science division berkeley ca 
supported part nsf postdoctoral fellowship 
part research fourth author ibm almaden 
mail waarts cs berkeley edu introducing notion competitive analysis distributed algorithms technique competitive analysis proposed sleator tarjan study problems arise line setting algorithm unpredictable sequence requests perform operations decisions satisfy current request may ect eciently satisfy requests 
worst case performance algorithm depend unusual arti cial sequences requests unbounded allows arbitrary request sequences look algorithm performs relative measure diculty request sequence 
key innovation sleator tarjan measure diculty performance optimal line algorithm allowed see entire request sequence making decisions satisfy 
de ned competitive ratio supremum possible input sequences ratio performance achieved line algorithm performance achieved optimal line algorithm measure performance depends particular problem 
distributed setting additional sources nondeterminism request sequence 
include process step times request arrival times message delivery times message passing system failures 
distributed algorithm deal problems lack knowledge requests system behavior incomplete information current system state 
due additional type nondeterminism distributed setting obvious extend notion competitive analysis environment 
awerbuch kutten peleg bartal fiat rabani took rst steps direction :10.1.1.56.8354
context job scheduling data management 
papers subsequent cost distributed line algorithm compared cost optimal global control algorithm 
done implicitly earlier awerbuch peleg 
observed see paraphrased imposes additional handicap distributed line algorithm comparison optimal algorithm distributed algorithm decisions solely local information 
algorithm learn price relevant part global state necessary decision 
additional handicap imposed line distributed algorithm evaluated line algorithm pay overhead control needed intelligent decision 
claim cases re ned measure necessary achieve handicap incomplete system information imposed distributed online algorithm optimal algorithm line algorithm compared 
distributed line algorithms may competitive ratio fact totally outperforms 
approach ultimately observation purpose competitive analysis line algorithms allow distributed algorithms line avor terms distributed algorithm distributed line algorithm interchangeably 
comparison line algorithms ctitious line algorithm merely means 
natural extension competitiveness distributed algorithms de ne distributed algorithm competitive sequence requests scheduling events performs times worse distributed algorithm 
approach introduced 
algorithm competitive competitive notion current literature competitive distributed algorithms competitive notion may better 
concrete example appears 
competitive notion captures performance distributed algorithms accurately de nition literature 
de nition sleator tarjan introduced show competitive algorithm performs comparison algorithm deals type nondeterminism nondeterminism knowing requests system behavior 
contrast new de nition show competitive algorithm performs comparison algorithm deals types nondeterminism nondeterminism knowing requests system behavior nondeterminism having partial information current system state 
measure de ned formally section central contributions 
cooperative collect demonstrate technique study problem having processes repeatedly collect values cooperative collect primitive rst abstracted saks shavit woll 
shared memory applications processes repeatedly read values stored set registers 
process reads register communication costs increase dramatically degree concurrency due bus congestion contention 
interestingly trivial solution current literature wait free shared memory applications including nearly algorithms known consensus snapshots coin ipping bounded round numbers timestamps multi writer registers cost na implementation easily shown lower bound worst case cost implementation 
worst case taken set adversarially chosen schedules events give details 
show interesting cases concurrency high possible better na solution 
suggests competitive analysis problem may fruitful 
assume standard model asynchronous shared memory computation processes communicate reading writing set single writer multi reader registers 
con ne single writer registers construction registers written process principal uses cooperative collect primitive 
usual step read write shared variable 
require algorithms wait free priori bound number steps process take order satisfy request independent behavior processes 
exception consensus algorithm saks shavit woll 
discuss results section 
cooperative collect primitive processes perform collect operation operation process learns values set registers guarantee value learned fresh register point collect 
process reads register condition trivially satis ed 
sophisticated protocols may allow process learn values indirectly process diculty values may stale obtained started current collect contents registers changed interim 
additional done ascertain values fresh obtain fresh values 
competitive analysis cooperative collect algorithms assume schedule processes take steps times requests collects arrive registers updated control adversary 
intuitively adversary schedules processes perform collect operations concurrently partitioned process performs signi cantly fewer reads 
suppose adversary rst schedules perform collect isolation 
scheduled perform collect values obtained fresh 
reason read registers 
continuing way construct schedule algorithm process read registers 
worst case cost distributed algorithm high cost na algorithm 
example shows worst case measure useful evaluating cooperative collect algorithms 
unfortunately similar example shows competitive analysis proceeds comparing distributed algorithm ideal global control algorithm gives equally poor results 
underlying diculty arises global control algorithm knows registers updated 
case registers changed process collect simply return values previously saw doing read write operations 
hand distributed algorithm read registers sure new values appeared gives nite competitive ratio distributed algorithm 
competitive measure allow distinguish na algorithm algorithms totally dominate 
competitive measure allows distinction 
characterize behavior algorithm range possible schedules de ne competitive latency algorithm 
intuitively competitive latency measures ratio amount algorithm needs perform order carry particular set collects done best possible algorithm carrying collects schedule 
discussed re ne previous notions requiring best possible algorithm distributed algorithm 
choice champion algorithm depend schedule implicitly knowledge schedule optimize performance say having process read register contains needed values cut corners compromise safety guarantees schedule analogous regularity property registers read operation returns value written update operation update operation register di erent allowed process read register knows schedule register written 
algorithms trivial collect algorithm processes perform collects concurrently total reads 
rst algorithms cross barrier 
basic technique mechanism allows processes read registers cooperatively having process read registers order determined xed permutation registers 
proof competitiveness algorithms parts introduces di erent technique 
rst part partition execution intervals identi ed di erent set collect operations distributed algorithm perform steps 
technique demonstrates algorithm compared optimal distributed algorithm algorithm global control 
second part show construct set permutations set concurrent collect operations take kn steps completed independent scheduling processes steps 
rst step direction anderson woll elegant certi ed write problem see section :10.1.1.56.8354:10.1.1.56.8354
due requirement freshness adversary constrained adversary freshness issue :10.1.1.56.8354:10.1.1.56.8354
need additional insight combinatorial structure schedule 
particular part proof prove adversary short description exists set permutations 
show adversary suciently constrained choices algorithm short description 
deterministic algorithms di erences come di erent sets permutations 
rst algorithm uses set permutations strong properties allows simple elegant algorithm construction permutations probabilistic suitable permutations high probability 
second algorithm uses constructible weaker set permutations requires additional machinery 
non constructive algorithm number reads overlapping collects log 
show yields competitive latency log 
explicit construction number reads overlapping collects log tends zero goes nity 
yield competitive latency log 
bounds contrast competitiveness trivial solution 
addition absolute worst case bound done collect algorithms structured collect takes operations matter schedule 
upper bounds versus lower bound comparison show algorithm expected competitive latency better 
course implies deterministic algorithm xed schedule competitive latency ast 
lower bound holds randomized algorithms adversary need know algorithm adversary weaker usual oblivious adversary 
particular adversary determines probability distribution schedules cooperative collect algorithm uses randomization expected latency competitiveness 
contrast algorithms deterministic competitiveness measured stronger worst case adaptive adversary 
lower bound matches upper bound tightly sense 
algorithms structure processes partitioned groups size processes group collaborate read blocks registers collaboration groups 
loosely stated show groups ratio amount performed group done processes best possible algorithm schedule log rst algorithm pn log second algorithm pn number atomic steps process needs perform order complete atomic snapshot scan operation registers 
competitive latency obtained multiplying ratios number groups cf 
section 
best known atomic snapshot model computation due attiya requires process perform log atomic steps atomic snapshot follows groups ratio amount performed faster algorithm done processes best possible algorithm schedule log 
despite powerful adversary groups comes close trivial lower bound 
shows order improve signi cantly upper bound obtained allow groups collaborate way 
combinatorial problem reasoning interactions processes quite hard collaboration done solely groups signi cantly harder 
organization remainder organized follows 
section describes additional related 
section describes model computation 
section presents competitive measure 
section describes faster cooperative collect algorithm competitive analysis 
section describes second cooperative collect algorithm construction explicit analyses competitiveness 
section derives lower bound competitive latency cooperative collect algorithm 
related saks shavit woll rst recognize opportunity improving eciency shared memory algorithms nding way processes cooperate collects 
devised elegant randomized solution analyzed called big step model 
model time unit minimal interval execution algorithm non faulty process executes step 
particular time interval process takes single step takes steps time unit charged 
big step model gives information number accesses shared memory small steps performed processes execution algorithm 
stands contrast focuses shared memory accesses 
cooperative collect resembles problem arranging processes collaborate order perform set tasks 
closest problem literature certi ed problem cwa 
problem rst variant introduced kanellakis shvartsman group processes write register set write process learn register written certi cation 
followed number consider variants basic problem see example :10.1.1.56.8354
cwa assumes sort multi writer registers 
model provides multi writer registers cooperative collect equivalent certi ed write cwa problem issue freshness 
reason equivalence process learns register written information passed process wrote particular register 
certi ed write algorithm replace writes registers read pass value read certi cation particular register touched 
process nishes possesses certi cation register touched possess register value 
cwa useful simulating synchronous pram asynchronous 
specifically cwa synchronization primitive determine set tasks performed step simulated algorithm completed safe proceed simulation step 
instance cwa carried di erent set registers solution relevant problem issues freshness arise 
registers re problem complicated particularly deterministic setting 
know deterministic algorithms cwa problem addresses issues model computation 
example assumes compare swap tagged architecture associated register tag indicating time written :10.1.1.56.8354:10.1.1.56.8354
asynchronous message passing model studied problem performing number tasks system processors 
processors may fail crashing processor perform unit 
provide tight bounds number crash failures tolerated solution problem 
synchronous message passing model dwork halpern waarts studied essentially problem 
goal design algorithms minimized total amount ort de ned sum performed messages sent order non faulty process ensure tasks performed 
results extended mayer yung :10.1.1.56.8354
related notion competitive measure suggested idea comparing algorithms partial information algorithms partial information introduced papadimitriou yannakakis context linear programming model corresponds distributed system communication 
generalization approach described koutsoupias papadimitriou :10.1.1.23.97
addition long history interest optimality distributed algorithm certain conditions particular pattern failures particular pattern message delivery 
related works spirit di er substantially details applicability distinct situations 
sense optimality envisions fundamentally di erent role adversary trying produce bad performance candidate algorithm call champion algorithm contrast adversary competitive analysis usually cooperates champion 
model computation assume system processes communicate shared memory 
location memory called register 
registers read written single atomic step 
algorithms assume registers single writer multi reader register written single processor owner read processors 
assume completely asynchronous system 
process receive stimuli requests outside world 
process local state change takes step performs read write register response external stimulus 
process set halting states 
process halting state takes steps change state response outside stimulus 
process non halting state intuitively ready take step 
activated scheduler process accesses register enters new state 
new state function previous state information read step read register 
formalizes usual assumption asynchronous algorithm process change state solely response scheduler opportunity take step 
assume schedule events interleaving step times outside stimuli control adversary 
competitive analysis traditionally competitiveness algorithm measured comparing performance performance omniscient line algorithm 
intuition line algorithm measured omniscient certainly compared algorithm solves problem 
notion competitiveness extended naturally restricting class things omniscient beings algorithms algorithm compared provided resulting comparison says interesting algorithm studied 
discussed order get re ned measure performance distributed algorithm compare performance distributed algorithms algorithms processes get free knowledge current state system 
measure competitiveness algorithm certain problem compare cost schedule cost best distributed algorithm 
refer algorithm measured candidate compare schedule champion 
imagine champion guesses optimizes accordingly schedule champion operates correctly 
note restricted comparison class requiring champion distributed algorithm solve problem correctly schedules 
hand permit di erent champion 
departure usual model single line algorithm 
focus particular cost measure done algorithm 
result competitive ratio call competitive latency 
competitive latency interested algorithms carrying sequence tasks 
request scheduler request carry particular task 
complete task process enter halting states 
naturally correct algorithm fact successfully carried speci ed task enters halting state 
consider schedules process candidate algorithm completes current task asked start new 
consistent cooperative collect algorithms mentioned 
similarly schedule consider possible champions algorithms process happens nish task task arrives 
algorithms property said compatible schedule 
charge candidate champion read write operation carry part tasks 
total done algorithm adversary schedule just number reads writes writing quantity competitive ratio respect latency algorithm de ned sup inf ranges nite schedules compatible ranges correct distributed algorithms compatible restriction nite schedules required ratio de ned 
xed nite schedule de ne competitive ratio limit supremum ratio increasingly long nite pre xes schedule 
leads result supremum schedules taken 
note de nition sucient purposes consider deterministic algorithms 
randomized algorithm necessary take expectations algorithm choices adversary responses 
quantity simply length schedule process halting state 
speedy collect algorithm section non constructive algorithm log competitive respect latency 
starting point certi ed write algorithm anderson woll :10.1.1.56.8354:10.1.1.56.8354
algorithm process xed permutation integers ng 
takes step writes rst location written 
intuitively adversary advantage processes write location time causes wasted 
adversary scheduler anderson woll showed number cells written bounded follows 
longest greedy monotonic increasing subsequence permutation respect ordering constructed starting empty sequence running elements order adding subsequence larger elements subsequence 
order cells rst written adversary schedule 
anderson woll showed total number writes performed schedule bounded length longest greedy monotonic increasing subsequence respect 
shown probabilistically exists set permutations numbers ng sum lengths longest greedy monotonic increasing subsequences set respect ordering log :10.1.1.56.8354:10.1.1.56.8354
naor roth obtained explicit construction quantity log tends zero tends nity 
speedy collect algorithm process choose actions read operations write operations certi ed write xed permutation distinct process 
similarly adopt rule process carry read particular register process supplied fresh value register freshness detected timestamps 
additional requirement values fresh means set reads done process correspond greedy monotonic increasing subsequence process permutation consequence known results bounding sizes help nd set permutations algorithm competitive 
show set permutations exists probabilistic argument demonstration ect adversary described small number bits 
description algorithm partition processes groups size processes group collaborate read blocks registers collaboration groups 
process shared variable collect num initially zero incremented time begins new collect 
algorithm repeatedly computes timestamps 
timestamp array collect numbers process 
intuitively trust value tagged speci cally log log log log log 
timestamp component equals collect num values necessarily read collect began 
views processes group read updated atomic snapshot algorithm attiya 
basic operation attiya algorithm array scan update null 
process performs scan update non null ect updating current value returning copy entire contents snapshot performs scan update null simply returns snapshot scan update operations applied array view 
attiya algorithm atomic snapshot algorithm total serialization order scan update operations preserves real time order operations corresponds apparent ordering determined examining scan update operations return values 
scan update operation cost log number processes size array generally snapshots group processes case cost log 
technical reasons atomic snapshot algorithm modi cation 
main restriction algorithm addition properties common snapshot algorithms property rst step scan update operation write new value value included result scan update starts value written scan update operation done rst write 
fortunately attiya algorithm property 
process xed permutation blocks 
rst waking collect performs scan update newview newview contains newly incremented collect number 
repeatedly performs operations 

read group obtain atomic snapshot current view processes group invoking scan update log operations 
extract snapshot vector collect numbers write snapshot shared memory point 
call snapshot timestamp 

read block read registers rst block union views obtained snapshot tagged timestamp pth component collect num operations 

write view tag block just read current timestamp 
newview consist block values block seen snapshot timestamp tags value collect num unchanged 
update view invoking scan update newview log operations 
loop repeats blocks appear view tagged timestamp pth component collect num ensure worst case process performs operations interleave execution loop na collect 
atomic operation performed loop insert single read operation register process trusted value value block tagged timestamp pth component collect num 
values learned single reads included process view ect behavior loop union view directly read values include fresh values registers process nishes collect soon done current scan update operation 
worth noting timestamp vector collect numbers seen read group operation atomic snapshot sum components vector 
refer sum round number refer sum collect numbers obtained rst read group collect initial round number collect 
fact collect numbers process increase monotonically linearizability snapshot object follows process trust values tagged round numbers initial round number collect 
shorter timestamps decrease registers size factor simplicity exposition overlook possible optimization 
key performance algorithm choice permutations 
order able choose permutations need formulate precise description ect adversary scheduler 
particular show ect adversary described log bits 
case show set permutations exists combinatorial lemma described section 
section describe succinct representation adversary 
representation permutations follow existence prove competitiveness algorithm sections 
permutations exist anderson woll certi ed write algorithm possible describe schedule single permutation speci es order values rst written 
reason simplicity certi ed write problem freshness issue writing register advances goals processes equally 
symmetry hold cooperative collect problem consequence necessary model adversary collection permutations process 
intuitively captures behavior adversary relevant process show reads performed process bounded longest greedy monotonic increasing subsequence respect relation adversary scheduler follows 
algorithm describes order cells rst written scenario process concerned ordering writes blocks registers trusted fresh :10.1.1.56.8354:10.1.1.56.8354
scenario describes order rst trustworthy writes block values tagged timestamp includes collect num 
necessarily case na representation adversary requires log bits 
show section possible describe adversary log bits 
relationship completely unconstrained 
example intuitively begins collect values trusted trusted fact describe adversary succinctly important light combinatorial lemma ties existence set permutations length description adversary 
speci cally adversary described log bits set permutations sum longest greedy monotone increasing subsequences pair log 
denote length greedy monotone increasing subsequence permutation ordering 
lemma assume positive integer set element sequence ordering set ng 
exists suciently large jaj log permutations taken random independently uniform distribution set permutations ng probability log log proof main step proving lemma show single adversary sum small high probability 
simplify argument note adversary permutation independent uniformly distributed random permutations 
consequently long considering distribution random variable single xed may assume loss generality show claim suciently large xed ordering ng random permutation ng log proof may assume natural ordering numbers ng 
permutation respect ordering 
note distribution conditioned uniform set fm ng 
random variable exist probability 
de ned 
observe inequality may hold log distinct values xed integer log log 
estimate probability log 
clearly sequence jd de ned probability de ned said earlier uniform fu ng mutually independent random variables probabilities log 
complete proof claim estimate log log log log log log 
get log log log def assume picked log log 
log log log log log log log log consequently log log log done 
show claim assume constant claim arbitrary real number suciently large xed ordering ng random permutation ng 
event fl jl log ng log log proof log ng 
fx hx xed number ng hv xed sequence length elements integers de ne event 
estimate probability claim xed probability 
fact log 
events independent log integer sequence length element integer choices pair log log log log completes proof claim 
number included sum claim log total log follows claim assume constant claim arbitrary real number suciently large xed ordering ng random permutation ng 
event log log distribution claim applies equally general case replace possibly distinct permutation completes main step proof 
obtain full lemma choose constant claim 
xed event log claim implies xed log log log log log completes proof lemma 
representing scheduling adversary combinatorial object set permutations mg adversary denoted consists parts described 
de nition purely combinatorial interpretations parts terms values trusted processes intended solely give intuitive explanation representation chosen 

rst part adversary attaches process number called process trusting threshold 
process trusting threshold intuitively trusting thresholds re ect serialization order updates vector collect numbers 
process trust values attached snapshot contains current collect number 
trusts values tagged timestamps serialized update collect num lower trusting threshold corresponds earlier timestamp represents process trust processes values 
specifying trusting thresholds takes log bits 

second part adversary denoted ordered list elements 
element ordered pair numbers integer rst number appearing pair referred value pair second referred trustworthiness pair 
value pair represents index block registers trustworthiness re ects timestamp block tagged 
sequence constructed mixing sequences length rst sequence contains element block element value number block trustworthiness pairs ordered order universally trusted versions blocks rst written 
second sequence consists pair process recording write block universally trusted block 
elements sequences interleaved serialization order corresponding write operations 
elements speci ed log bits number bits needed part adversary log 

third part adversary provides trusting threshold number subset integers mg correspond 
subset called old subset corresponding trusting threshold 
old subsets required totally ordered inclusion old subset particular threshold contained old subset lower threshold containment need proper 
intuitively values old subset trusting threshold trusted fresh processes trusting threshold equal intuitively union old subsets contain values trusted processes 
old subsets ordered inclusion represented log bits 
observe adversary fully de ned log bits 
show adversary imposes order erase elements contained old set corresponding trusting threshold 
call remaining permutation rst de ne sequences follows contains exactly elements appear element precedes rst occurrence pair value trusted trusting threshold appears rst occurrence pair value trusted said di erently consider pairs second component trustworthiness large trusting threshold assigned precedes restricted list pairs rst pair form 
precedes rst pair form 
note sequences completely determined adversary described log bits 
abuse notation slightly denote length greedy monotonic increasing subsequence constructed described 
de ne max padding pre containing elements lemma prove theorem theorem constant set permutations values cm log proof construction sets described log bits 
old denote set elements de ne elements old order followed sequence note assumptions concise representation containment chain property old subsets imply represented log bits 
permutation length respect great length respect see consider cases 
rst case begins element case elements old irrelevant respect de nition fact elements old smaller elements equality case 
second case begins element old elements old add addition ect addition elements elements old rst element added elements old added irrelevant point 
start set permutations guaranteed lemma 
shown adversary described log bits 
shown description adversary construct permutations sequences applying construction previous paragraph construct orderings described log bits 
orderings satisfy conditions lemma conclude sum length respect cm log constant depend shown quantity greater equal cm log section show ect adversary scheduler speedy collect algorithm completely captured part adversary type described 
choosing set permutations existence guaranteed theorem yields algorithm latency 
collective latency speedy collect algorithm de ne collective latency set processes point time sum number operations done process time completes collect started 
recall process considered having completed collect enters halting state 
show suitable set permutations algorithm gives small collective latency sized groups processes section fact show algorithm competitive respect latency processes taken 
theorem core proof competitiveness theorem set permutations mg 
suppose set permutations group satis es de ned section 
collective latency group algorithm log 
proof fix arbitrary time set processes performing collects time read block phase read group phase requiring log operations get bound number operations bounding number read blocks 
distinguish time values trusted process globally trusted partially trusted read blocks 
bounding number partially trusted read blocks 
dicult see process performs partially trusted read block time preceding second read block get current collect num values processes 
place requirement scan update operation returns values written starts rst operation writes new value 
requirement possible process start collect ecting processes views collect num value 
overview bounding number globally trusted read blocks 
bound number globally trusted read blocks start constructing part adversary consistent representation described section 
intuitively parts follows 
rst part determined serialization order processes initial calls scan update write new collect numbers collects process ordering determined serialization order globally partially trusted blocks performed write view phases 
serialization order timestamps orders sets trusted individual members inclusion 
remainder analysis shows read blocks done process correspond greedy monotonic increasing subsequence sequence described section 
applying theorem yields bound number globally trusted read blocks 
cost read blocks associated read group phases log 
partitioning read blocks new old 
keeping overview mind get details proof 
process collect num denote collect number current initial update denote scan update operation updates collect number value collect num initial update operations serialized scan update procedure de ne initial update ordering operations initial update recall read group phase process takes snapshot collect numbers processes group 
partition read block phases performed processes started takes snapshot serialized initial update started point 
refer rst class read block phases new read blocks second class old 
refer corresponding read groups new old respectively 
new read blocks globally trusted obtain values accepted trustworthy processes bulk remainder proof obtains bound number new globally trusted read blocks 
little di erent counting number read blocks occur time 
atomic snapshot scan algorithm yields real notion time just serialization order snapshots updates consistent real time order events 
hand de nition collective latency requires bound number operations reads writes shared registers occur time rst argue process take log steps time new read group 
bounding corresponding old globally trusted read blocks 
consider process begins collect current rst thing perform atomic snapshot update scan update collect num rst step update operation write collect num property attiya scan update algorithm atomic snapshot scan begun write serialized update 
de nition process writes collect num time collects process 
follows discussion atomic snapshot scan begun time serialized initial update 
particular read group begun time returns snapshot serialized initial update new read group de nition 
follows algorithm process perform log steps time new read group 
bounding number new globally trusted read blocks 
bound number new read blocks 
de ne adversary permutation follows 

consider linearization order updates initial update attach trusting threshold process consistent order process update initial update serialized updates initial update trusting threshold 
construct merging lists pairs 
start rst list 
recall processes partitioned groups necessarily proper subset processes particular group 
consider write views done processes group correspond new read groups 
call write views new write views 
atomic snapshots perform write views read groups operations totally ordered 
block rst time ordering values written new write view 
order values block written new write view values block written new write view 
initially contain pairs elements order 
gives ordered list pairs 
second list pairs constructed follows 
process sized group contains consider old read block done follows read group atomic snapshot serialized initial update 
refer corresponding write view new write view 
write views process group 
new write view construct pair value index block read corresponding read block trustworthiness determined timestamp block follows 
timestamp vector collect numbers written updates initial update updates consider update serialized process executing update 
trustworthiness pair trusting threshold determined 
order set pairs serialization order write views corresponding pairs new write view serialized new write view order pair corresponding new write view pair corresponding new write view 
gives second list pairs 
merge lists follows 
pair rst list precedes pair second list rst write view containing block tagged trusting threshold corresponding rst write block trusted serialized new write view gave rise pair 
write views serialized merging de ned results ordered list elements 

third part adversary consider block timestamp pairs written time write view done process group containing timestamp serialized initial update 
process group containing remove set pairs pair written remove pair written new write view 
call resulting set old pairs 
process de ne old subset associated trusting threshold set block names exists old pair ts ts timestamp serialized initial update values subset trusted necessarily processes higher trusting threshold 
observe total order timestamps updates initial update old subsets totally ordered 
clearly adversary legitimate adversary de nition previous section 
follows theorem assumption sum respect adversary 
complete proof show lemma process id blocks read performing new appear longest greedy monotonic increasing subsequence respect 
proof suppose claim hold 
process read block block appear block precedes larger recall obtained erasing elements contained old subset corresponding trusting threshold 
appear old subset associated trusting threshold 
de nition old subsets means written old write view new write view 
serialized initial update de nition new read group associated new read block 
new read group serialized initial update 
follows old write view serialized initial update write view followed new read group begun write view necessarily serialized initial update new 
written write view serialized initial update tagged timestamp trusted learns trusted value rst new read group contradicting assumption reads new read block 
assume block precedes larger precedes read trustworthy value read blocks follows trustworthy value written trustworthy value read trustworthy value time contradicting fact read blocks 
combining result lemma fact shown sum respect adversary yields bound number new globally trusted read blocks 
complete proof theorem observe collective latency group bounded times maximum amount performed process time begins new read group plus upper bound number new globally trusted read blocks times cost iteration main loop algorithm 
collective latency group algorithm log log log 
collective latency bound latency competitiveness theorem key relationship collective latency competitive latency measure 
connection useful de nition particular schedule ratio group processes ratio total number operations performed processes candidate algorithm total number operations performed processes champion algorithm 
note section consider nite schedules 
theorem cooperative collect algorithm group processes schedule compatible exists bound times collective latency ratio number values collected 
proof de nition latency competitiveness section consider nite pre xes schedule 
consider arbitrary nite pre time atomic step pre takes place 
key proof process starts collect algorithm process starts collect champion algorithm 
de ne partition schedule intervals property champion performs operations interval algorithm requires operations complete collects performed processes start interval 
fact proved demonstrating interval register read obtain fresh values 
fact proved applying de nition collective latency endpoint interval 
slicing carried recursively 
simplify description treat schedule assigning operations processes individual collects operation assigned particular collect assigned process occurs starts process starts collect 
long choose longest interval starting number operations assigned collects start performed processes set collects claim 

proof claim contains fewer operations collects rst operation increase include violating de nition 
operations carried somebody nonempty 
number intervals de ned 
show interval champion perform operations observe collect starts trust value read nonempty operations carried champion collect nish 
observed nonempty de nition processes performing collects scheduled perform operations step process champion algorithm perform operation nished collect 
processes nish collects scheduled operations performed process nished collect earlier observation operations performed possibly processes performing collects 
case operations performed champion 
similarly nonempty reasoning immediately implies champion performs minfn pg operations number operations processes performing collects scheduled perform de nition follows nonempty champion performs operations complete proof show algorithm collects starting interval require operations 
divide operations performed part collects occurring occuring rst set consists operations de nition second consists operations bounded collective latency group processes carrying collects time cases empty 
empty algorithm performs steps champion performs steps 
nonempty number steps processes performing collects scheduled perform algorithm performs steps champion performs steps 
case ratio 
corollary collect algorithm processes divided groups times group maximum collective latency competitive latency ml proof number operations done champion 
theorem single group candidate algorithm operations 
follows groups total wm operations 
lemma suppose set permutations group satis es 
algorithm competitive latency log 
proof theorem collective latency group log 
groups result follows corollary set permutations theorem log theorem competitive latency speedy collect algorithm log 
observe schedule performed sized groups processes partitioned log times total performed groups best possible algorithm schedule 
seen proof theorem log factors competitive latency due fact read groups performed atomic snapshot algorithm 
atomic snapshot process takes log operations complete atomic snapshot registers 
linear algorithm snapshot performed sized groups just log times total performed groups best possible algorithm schedule matching group trivial lower bound section 
substantial improvements possible long division processes isolated groups necessary 
constructive algorithm preceding section describes log competitive algorithm set permutations satisfy strong constraint 
existence set shown probabilistically 
section develop algorithm competitive latency log explicit set permutations 
new algorithm requires machinery set weaker properties 
processes divided groups processes read registers blocks registers time 
algorithm process simulate virtual processes running time collect algorithm 
virtual processes process maintain separate view marked round number 
virtual processes particular round number cooperate virtual processes round number 
round numbers assigned virtual process round trust processes round supply fresh values 
eliminates timestamps deciding values read key technique allows simpler set permutations required non constructive algorithm 
obtain round numbers need slightly elaborate version timestamps non constructive algorithm 
process include register value collect num count collects started 
initiate collect process increase value scan update operation provided attiya protocol 
time process change collect num value 
initial round number collect sum collect num values sees scan update operation essentially process view collects initiated processes group 
process starts simulating just virtual process marked initial round number 
proceeds loop 
note read group step rst pass loop implemented scan update operation obtain initial round number 

read group performs scan update registers processes group obtain views virtual processes simulated group log operations 
virtual process simulating add view union views virtual processes round number 
step may simulating new virtual process 
starting round number collect 
round number multiple observes round number greater equal simulate virtual process round start simulating virtual process round initial view equal union views virtual processes round 
multi read block virtual process simulating performs behalf process reading rst block permutation virtual process view operations active virtual process 
add block process view tagged timestamp consists collect num values read previous read group 

write view writes current views simulated processes register scan update log operations 
time union views read read group views virtual processes contains value register tagged timestamp including collect num skips immediately write view step exits 
doing stops simulating virtual processes 
maintain views virtual processes simulated register 
ensure worst case process performs operations interleave execution loop na collect done section 
atomic operation performed loop insert single read operation register process trusted value 
values learned single reads included process view ect behavior loop union view directly read values include fresh values registers process nishes collect soon done current scan update operation 
observed section value read read block operation tagged round number virtual process read vector collect nums read simulating process preceding read group operation 
simplicity exposition overlook possible optimization 
properties algorithm depend choice permutations 
particular note lemma value returned algorithm fresh 
proof collect returns vector values tagged timestamp including current value collect num value read read group obtained current value turn followed write start collect 
lemma shows virtual processes round trust values fresh 
lemma initial round number calculated process part collect sets collect num scan update operation returns done simplicity exposition proofs hold unchanged process maintains views virtual processes simulated collect completed 
vector collect num values sum returns value collect num proof fact vector collect num values increase monotonically linearizability snapshot object follows vector collect num values obtained componentwise greater equal vector obtained rst scan update operation rst scan update operation returns vector collect num immediate corollary lemma dicult show number virtual processes active part collect bounded lemma process simulates active virtual processes single collect 
proof consider single collect process starting round number collect 
suppose sees round number greater equal read group phase collects started processes collect 
pigeonhole principle process started collects 
rst collects starting round number greater written complete set values views virtual processes round numbers greater exited second collect started 
lemma values tagged timestamps include current value collect num takes view nishes 
consequently starts virtual process round number greater equal bound follows 
remains show done behalf virtual processes 
choose permutations carefully 
recall naor roth constructed set permutations numbers sum lengths longest greedy monotonic increasing subsequences set respect ordering log tends zero goes nity 
gives set permutations processes property sum lengths log 
fact prove lemma lemma log read blocks done virtual processes round 
proof fix arbitrary round de ne adversary permutation blocks order rst written parts views virtual processes round determined serialization order scan update operations 
note immediate consequence serializability scan update operations view round obtained read group step pre 
virtual process round permutation 
show block read part read block respect 
full result follows fact bound sum lengths virtual processes round log 
block 
fact follows precedes follows 
view round obtained read group step pre view contains contain read group view contain case read immediately read block rst unread block ordering view contain case contains read block read claimed 
recall collective latency set processes time sum number operations done process time nishes collect started theorem collective latency group cooperating processes algorithm log proof fix time analogously proof theorem bound number operations done processes follow bound number read blocks done behalf virtual processes part current collect 
restrict attention read blocks extension multi read blocks part current collect process group 
call multi read block old preceding read group starts new 
old multi read block processes group total old multi read blocks 
lemma old multi read blocks contribute read blocks 
bound number new multi read blocks look closely round structure 
largest round number virtual process simulated process group time largest multiple equal smallest multiple greater equal divide new multi read blocks classes round numbers virtual processes carrying component read blocks include round round ii include round round iii include round lemma log multi read blocks classes iii 
multi read block consists read blocks total log read blocks classes iii 
consider process performs new multi read block class ii 
preceding read group time observed virtual processes rounds equal fact simulating virtual process round implies starting round number exceeds starting round number puts read block round observed process round higher 
simulating single round virtual process multi read block consists single read block virtual process 
class ii multi read block consists single read block round log read blocks rounds log class ii multi read blocks altogether 
total number read blocks contributed old multi read blocks new multi read blocks classes ii iii log read block process carries log operations including operations parts corresponding write view phases collective latency log 
combining lemma corollary gives theorem competitive latency algorithm explicit construction naor roth log 
lower bound competitive latency dicult show lower bound competitive latency cooperative collect protocol 
essential idea adversary run processes time nishes collect 
champion rst process read registers operations write summary values operation 
processes carry read operation obtain summary 
candidate algorithm adversary arrange things processes know process went rst 
second process read average output registers nds rst process summary third process read nds rst second process forth total 
log expected operations 
idea need deal technical issues 
rst issue consider freshness 
order processes champion algorithm pro orts rst process rst process able certify values collects fresh processes 
means pre main body schedule preamble process carries write timestamp champion possibly operation 
second issue ensure processes candidate guess processes run rst main body 
issue resolved choosing order processes run uniformly random care needed show information random permutation leaks 
theorem exists distribution schedules expected competitive latency collect algorithm schedule drawn distribution 
proof de ne probability distribution schedules expected competitive latency candidate algorithm ast 
follows particular algorithm xed schedule produces competitive latency 
schedules consider consist preamble process starts collect takes step main body processes run sequentially 
structure preamble xed th time unit preamble process starts new collect step 
structure main body slightly complicated consists intervals process 
interval process associated interval may take steps length interval 
interval associated process controlled random permutation chosen uniform distribution 
champion algorithm process writes timestamp preamble operations total rst process main body reads output registers processes registers containing values collected registers may identical output registers processes writes result tagged timestamps processes operations nally processes reads output register rst process obtain values total operations 
cost champion completing round operations 
candidate algorithm rst observe preamble short allow process learn value process carry operations read input register write value output register 
furthermore schedule preamble xed reveals information 
process suppose th process run main body 
wish show executes operations main body nishing collect 
rst process execute reads input registers obtain values may read value preamble learn values processes 
alternatively nishes collect reading values directly cost main body operations point learns value 
count expected number steps event occurs 
careful information point time distribution 
earliest time main body read output registers processes 
distribution values conditioned information obtained time de ne uniform distribution 
claim time read output register process precedes 
permutations processes read equally proof suppose claim true time reads output register process follows 
performed operations main body value register reveals relative ordering processes claim follows claim immediate process precedes odds nding read output register better chance 
looking output earlier processes registers takes expected reads nds contain values fresh round 
gives lower bound expected number operations executed main body 
summing expectations processes corresponding random variables may independent gives total 
log operations round 
champion needs operations round gives competitive ratio 
schedules process performs collect 
roughly speaking integer construct schedule process performs collects simply iterating schedule times 
speci cally new schedule consist sequence rounds 
round consists preamble process starts collect takes step main body process steps nish collect 
allow process complete collect round order guarantee time process receives new request perform collect completed previous collect requirement necessary construction theorem process receives single request perform collect 
structure preamble xed th time unit preamble process starts new collect step 
main body consists intervals process 
interval process associated interval may take steps length interval longer time needed process complete collect candidate algorithm 
interval associated process controlled random permutation chosen uniform distribution independently choices rounds 
exactly proof theorem follows expected competitive latency collect algorithm schedules constructed ast round sum rounds 
shows lower bound theorem arises long schedules merely side ect giving candidate steps 
construction contrast construction theorem assumes adversary adaptive knows bound number steps process may take nish collect 
consequence requirement adversary supply schedule allows candidate complete collects 
grateful noga alon richard anderson joe halpern paris kanellakis chip martel nimrod megiddo yuval rabani help 
abrahamson 
achieving consensus shared memory 
proc 
th acm symposium principles distributed computing pp 
august 
afek attiya dolev gafni merritt shavit 
atomic snapshots shared memory 
proc 
th acm symposium principles distributed computing pp 

alon 
generating pseudo random permutations maximum ow algorithms 
infor 
proc 
letters 
alon kalai stockmeyer 
lower bounds competitive ratio mobile user tracking distributed job scheduling 
proc 
rd ieee symposium foundations computer science pages october 
anderson 
composite registers 
proc 
th acm symposium principles distributed computing pp 
august 
anderson woll :10.1.1.56.8354:10.1.1.56.8354
wait free parallel algorithms union find problem 
proc 
rd acm symposium theory computing pp 

aspnes 
time space ecient randomized consensus 
journal algorithms may 
earlier version appeared proc 
th acm symposium principles distributed computing pp 
august 
aspnes herlihy 
fast randomized consensus shared memory 
journal algorithms pp september 
aspnes herlihy 
wait free data structures asynchronous pram model 
proceedings nd annual symposium parallel algorithms architectures july pp 
crete greece 
aspnes waarts 
randomized consensus expected log operations processor 
proc 
rd ieee symposium foundations computer science pp 
october 
attiya herlihy 
ecient atomic snapshots lattice agreement 
technical report technion haifa israel 
preliminary version appeared proceedings th international workshop distributed algorithms haifa israel november segall eds lecture notes computer science springer verlag pp 

attiya herzberg rajsbaum 
optimal clock synchronization different delay assumptions 
proc 
th acm symposium principles distributed computing pp 
aug 
attiya 
atomic snapshots log operations 
proc 
th acm symposium principles distributed computing pp 
aug 
awerbuch azar 
local optimization global objectives distributed deadlock resolution resource 
proc 
th ieee symposium foundations computer science pp 
november 
awerbuch bartal fiat 
competitive distributed le allocation 
proc 
th acm symposium theory computing pp 
may 
awerbuch kutten peleg :10.1.1.56.8354
competitive distributed job scheduling 
proc 
th acm symposium theory computing pp 
may 
awerbuch peleg 
sparse partitions 
proc 
st ieee symposium foundations computer science pp 
november 
bartal fiat rabani 
competitive algorithms distributed data management 
proc 
th acm symposium theory computing pp 

bartal rosen 
distributed server problem competitive distributed translator server algorithms 
proc 
rd ieee symposium foundations computer science pp 
october 
borowsky gafni 
immediate atomic snapshots fast renaming 
proc 
th acm symposium principles distributed computing pp 
august 
bracha 
randomized consensus expected log operations 
proceedings fifth international workshop distributed algorithms 
springerverlag 

fault tolerant decision making totally asynchronous distributed systems 
proc 
th acm symposium principles distributed computing pp 

buss 
certi ed write strongly asynchronous pram 
manuscript 
chandra dwork 
consensus solve atomic snapshots 
submitted publication chor israeli li 
processor coordination asynchronous hardware 
proc 
th acm symposium principles distributed computing pp 

dolev shavit :10.1.1.56.8354
bounded concurrent time stamp systems constructible 
proc 
st acm symposium theory computing pp 

extended version appears ibm research report rj march 
dolev reischuk strong 
early stopping byzantine agreement 
jacm oct pp 

appeared eventual earlier immediate ibm rj 
dwork herlihy plotkin waarts 
time lapse snapshots 
proceedings israel symposium theory computing systems 
dwork halpern waarts 
accomplishing presence failures 
proc 
th acm symposium principles distributed computing pp 

dwork herlihy waarts 
bounded round numbers 
proc 
th acm symposium principles distributed computing pp 

dwork moses 
knowledge common knowledge byzantine environment crash failures 
information computation originally proc 
tark 
dwork waarts 
simple ecient bounded concurrent timestamping bounded concurrent timestamp systems comprehensible proc 
th acm symposium theory computing pp 

fischer michael sacri cing serializability attain high data unreliable network 
research report yale feb 
gawlick lynch shavit 
concurrent timestamping simple 
proceedings israel symposium theory computing systems 

ecient bounded timestamping traceable abstraction writer guessing better reader telling 
technical report ruu cs department computer science utrecht september 
halpern moses :10.1.1.56.8354
knowledge common knowledge distributed environment journal association computing machinery vol january pp 

preliminary version appeared proc 
rd acm symposium principles distributed computing 
halpern moses waarts 
characterization eventual byzantine agreement 
proc 
th acm symposium principles distributed computing pp 
august 
herlihy 
randomized wait free concurrent objects 
proc 
th acm symposium principles distributed computing august 
israeli li 
bounded time stamps 
proc 
th ieee symposium foundations computer science 
israeli 
concurrent time stamp scheme linear time space 
manuscript 
kanellakis shvartsman 
ecient parallel algorithms robust 
proc 
th acm symposium principles distributed computing pp 
kanellakis shvartsman 
ecient robust parallel computations 
proc 
th acm symposium principles distributed computing pp 

koutsoupias papadimitriou :10.1.1.23.97
competitive analysis 
proc 
rd ieee symposium foundations computer science pp 
november 
kedem raghunathan spirakis 
combining tentative de algorithms fast dependable parallel computing 
proc 
rd acm symposium theory computing pp 

kedem 
ecient robust parallel computations 
proc 
nd acm symposium theory computing pp 

spirakis :10.1.1.56.8354
reading variables atomic operation solutions linear sublinear complexity 
proceedings th international workshop distributed algorithms 
lamport 
interprocess communication parts ii 
distributed computing pp 

martel 
complexity certi ed write algorithms 
manuscript 
martel park 
asynchronous prams synchronous prams 
proc 
nd ieee symposium foundations computer science pp 

moses tuttle 
programming simultaneous actions common knowledge 
algorithmica pp 
appeared proc 
th ieee symposium foundations computer science pp 

naor roth 
constructions permutation arrays certain scheduling cost measures 
manuscript 

knowledge achieve consistent coordination distributed systems 
manuscript 
tuttle 
common knowledge consistent simultaneous coordination 
proceedings th international workshop distributed algorithms 
papadimitriou yannakakis 
linear programming matrix 
proc 
th acm symposium theory computing pp 
may 
patt shamir rajsbaum 
theory clock synchronization 
proc 
th acm symposium theory computing pp 
may 
mayer yung :10.1.1.56.8354
time optimal message ecient performance presence faults 
proc 
th acm symposium principles distributed computing pages 
saks shavit woll 
optimal time randomized consensus making resilient algorithms fast practice 
proceedings nd acm siam symposium discrete algorithms pp 

sleator tarjan 
amortized eciency list update paging rules 
comm 
acm pp 

vitanyi awerbuch 
atomic shared register access asynchronous hardware 
proc 
th ieee symposium foundations computer science 

