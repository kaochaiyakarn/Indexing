anomaly detection call stack information henry feng oleg wenke lee gong department electrical computer engineering university massachusetts amherst ma gong ecs umass edu call stack program execution information source intrusion detection 
prior dynamically extracting information call stack effectively detect exploits 
propose new method anomaly detection call stack information 
basic idea extract return addresses call stack generate execution path program execution points 
experiments show method detect attacks detected approaches convergence false positive performance comparable better approaches 
compare method approaches analyzing underlying principles achieve better characterization performance particular attacks missed various approaches 
lot research focused anomaly detection learning program behavior 
methods proposed modeling system call traces 
improvement system call methods part system calls provide limited amount information 
invoking system calls aspect program behavior 
aspects information contained call stack intrusion detection purposes 
prior finite state automata fsa model program behavior 
wagner proposed statically generate non deterministic finite automaton non deterministic pushdown automaton global control flow graph program 
automaton monitor program execution online 
sekar proposed generate compact deterministic fsa monitoring program college computing georgia institute technology atlanta ga ok wenke cc gatech edu execution runtime 
methods proposed system call 
really appealing implicitly explicitly program counter information construct states 
program counter pc indicates current execution point program 
instruction program corresponds distinct pc location information may useful intrusion detection 
addition current pc lot information obtained current status history depending interpreted program execution call stack particularly form return addresses 
call stack information source intrusion detection 
best knowledge prior dynamically extracting information call stack effectively information detect exploits 
propose new anomaly detection method called vtpath utilizes return address information extracted call stack 
method generates execution path program execution points decides path valid learned normal runs program 
developed techniques handle implementation issues adequately addressed techniques simpler described 
understanding principles vt path approaches believe vtpath method detect attacks detected approaches 
developed attacks experiments verify case 
experimental results show vtpath method similar convergence false positive performance deterministic fsa approach 
contribution attempt compare various approaches analyzing underlying principles achieve better characterization performance particularly attacks missed various approaches 
rest organized follows 
section describes related research 
section presents vt path method 
section discusses important implementation issues 
section presents experimental evaluation results 
section presents comparison vtpath method approaches 
section summarizes discusses 
related callgraph model wagner proposed characterizes expected system call traces static analysis program code 
global control flow graph naturally transformed 
automaton nondeterministic general branch choices taken statically predicted 
monitor program execution online 
operation simulated observed system call trace non deterministically 
non deterministic paths blocked point anomaly 
stated false alarms possible execution paths considered automaton 
wagner pointed callgraph model allows impossible paths 
basically function called place returns model allow impossible path occur normal run 
refer impossible path problem 
solve wagner proposed complex pushdown automaton model called stack model stack forms version program call stack 
return addresses abstracted away 
similar virtual stack structure method avoid complex generation simulation pushdown automata 
addition method dynamically extracts information call stack runtime models dynamically monitor system calls 
main problem models monitor efficiency low programs 
monitor overhead longer minutes transaction half programs experiments 
complexity pushdown automata non determinism simulation 
nondeterminism may impair ability detect intrusions 
problem addressed 
may scalability problem human efforts refining models libraries 
refined ideas models 
approach applies static analysis binary executables dependent programming language working platforms 
developed optimization obfuscation techniques improve preci sion efficiency 
particular inserting null calls main technique largely decrease degree nondeterminism help solve impossible path problem consequently increase precision 
technique requires rewriting executables change call name space 
may appropriate remote execution systems application context approach 
technique may inappropriate undesired common host anomaly detection environment 
addition reported high efficiency low overhead experiments 
added large delay real system call simulate network round trip time rtt small delay magnitudes lower simulated rtt delay null call inserted 
possible run time spent simulated rtt delay relative overhead appeared small null calls added 
particular network delay thousands null calls inserted comparable delay real system call 
relative overhead may appear small common anomaly detection environment network delay involved 
method proposed sekar problems related non determinism 
statically analyzing source code binary method call fsa method generates deterministic fsa monitoring normal program executions runtime 
distinct program counter system call state 
system calls labels transitions 
fsa monitor program execution online 
stack crashes state transition exist may anomaly 
false positives legal transitions states may occur training 
transition deterministic efficiency high method intrusions due non determinism 
fsa method suffers impossible path problem mentioned earlier section 
problem addressed 
implementation issues adequately addressed 
way dlls handled simple intrusions dlls may missed 
detailed discussion issues 
proposed programmer written compiler extensions catch security holes 
basic idea find violations simple rules static analysis 
example rules integers untrusted sources sanitized 
agree method kind methods useful finding programming errors think panacea solve problems 
lot security requirements subtle described simple rules 
example range checker guarantee integers untrusted sources checked range checked right range right range subtle instance specific developed instance untrusted integers 
result decide action permitted checking action occurs normal situations 
think dynamic monitoring anomaly detection methods method fsa method important static bug 
fact kinds approaches complements 
static methods remove logically obvious bugs remove bugs dynamic monitoring help detect exploits remaining holes 
problem approach rules person meat person poison 
human efforts develop rules may easy 
rules developed precise generate low false positives programmers just think ways bypass rule checking 
methods model system call traces 
gram method models program behavior fixed length system call sequences data mining approaches generate rules system call sequences hidden markov model hmm neural networks algorithms originally developed computational biology introduced area 
wespi novel technique build table variable length system call patterns teiresias algorithm 
teiresias algorithm initially developed discovering rigid patterns unaligned biological sequences 
algorithm quite time space consuming applied long traces containing maximal patterns 
wespi announced method worked better gram 
gram generated highest scores possibly generate intrusion traces 
may suggest attacks chose inherently easy detect 
wespi method generated higher looking scores necessarily mean works better 
cowan proposed method called stackguard detect prevent buffer overflow attacks 
stack guard compiler technique providing code pointer integrity checking return address 
basic idea place canary word return address stack check word modified function returns 
idea may buffer overflow attacks effective detecting kinds attacks 
methods described advantages disadvantages 
section develop new method combines advantages automaton methods avoiding problems 
method trains model monitoring runtime closer fsa method 
vtpath model closely related method properties fsa method possess 
uses call stack history current pc information 
help detect intrusions 
explicitly lists function boundaries transition traverses 
model precise 
method able handle implementation issues signal handling 
issues considered fsa method 
method handles dll functions just statically linked functions 
avoids potential problems fsa method related unnecessary simplification 
model called vtpath main concept called virtual path 
background instruction corresponds distinct program counter 
necessary possible efficiency follow program counters 
fsa method records program counter information system call 
choice system calls program interacts kernel 
approach record program counter information system call 
may record information places example jump function call instruction executed 
assumption assumption program counter call stack visited low runtime overhead system call 
kernel level mechanism intercept system calls achieve low runtime overhead 
experiments show overhead pure algorithm execution low 
discuss handle dlls 
section assume functions program invokes statically linked 
relative program counters program may loaded different places different runs relative positions program memory space remain 
virtual stack lists virtual paths system call extract system call name current pc fsa method 
addition extract return addresses call stack virtual stack list 
number frames call stack return address function called 
current pc added list item 
example assume function called main function 
elements virtual stack list system call function 
return addresses main respectively current pc 
virtual stack list denotes history functions 
model uses virtual path denote transition system calls 
assume 

bm virtual stack lists current system calls respectively 
note system calls may called different functions 
compare lists find subscript bl 
shown virtual path system calls defined bm exit 
bl exit bl entry 
entry entry exit specially defined pcs denoting entry exit points function 

virtual path system call current system call virtual stack lists respectively 
definition virtual path abstracts execution system calls 
program sequentially returns functions corresponding return addresses bm bl gradually enters functions corresponding return addresses 
traverse virtual stack lists back common function corresponding return address bl equal system calls 
recursive functions control flows generally data driven 
virtual stack lists obtained may different distinct set parameters results lot distinct virtual paths 
training harder converge result higher false positive rates 
modified method avoid problem 
common property recursion virtual stack lists return address occurs repeatedly 
method finds pair return addresses return addresses removed virtual stack list including pair 
reflects fact record function call history 
training phase training hash table called ra return address table save return addresses occurred virtual stack lists system calls 
return address item virtual stack list current pc item corresponding system call number saved 
hash table called vp virtual path table save virtual paths 
virtual paths denoted compact string form 
return addresses virtual paths gradually added normal program runs 
run assume null system call empty virtual stack list real system call real system call 
virtual path null system call real system call virtual stack list 
entry 
entry virtual path real system call virtual stack list 
bm null system call bm exit 
exit online detection phase training hash tables monitor program execution online 
system call record virtual stack list 
training assume null system calls program run 
may types anomaly phenomena get virtual stack list stack corrupted 
stack anomaly 
kind anomalies happens coarse buffer overflow attack 
assume current virtual stack list 

check item ra table 
return address missing return address anomaly 
correct system call system call anomaly 
generate virtual path current system call equations 
virtual path vp table virtual path anomaly 
problem fsa method intruder possibly craft overflow string call stack looks corrupted really evading detection 
method attack probably generate virtual path anomaly call stack altered 
method uses saves information training harder attacks evade detection 
impossible path problem method help solve impossible path problem mentioned 
assume attacker modify return address function program enters function call point exits 
trigger alarm fsa method transitions legal 
experiments show carefully designed attacks exploiting problem fool callgraph stack methods 
kind attacks help intruder critical part program jumped example permission checking code 
intruder technique repeat execution program part create race conditions 
method disallow virtual path system call call stack alteration point system call alteration point 
call stack return addresses function system calls different 
return addresses included resulting invalid virtual path 
implementation issues wagner addressed implementation issues statically generated models 
handled properly issues affect effectiveness dynamic monitoring approaches 
sekar addressed issues regarding dlls 
believe method simplifies behavior dlls intrusions dlls may missed 
find implementation issues easier handle runtime static analysis information available runtime 
wagner pointed second principle 
non standard control flows optimization convenience non standard control flows function pointers signal handlers setjmp function programming 
wagner stated features real applications interests intrusion detection 
function pointers setjmp extensively library functions 
signals signal handler function invoked corresponding signal received 
program suspends current execution turn signal handler 
continues execution suspended point signal handler returns 
hard consider signal handling model signal may occur anytime program execution 
problem complicated signal handlers called 
treat signal handler calls ordinary function calls training false positives signals occur new places 
system call signal handler executed save information system call including virtual stack list 
system call set null system call 
signal handler returns restore information system call 
framework easily extended multi level signal handler case 
execution signal handlers treated program run 
techniques training online detection applied signal handlers 
linux signal handler called receipt signal system call inserted stack frame 
called signal handler returns clean stack process restart suspended point 
find new system call call stack system call know signal handler executed 
encounter signal handler just returned 
method simpler wagner method need monitor signals received signal handler registrations 
setjmp longjmp calls function pointers setjmp longjmp library functions useful exception error handling 
setjmp call saves stack context environment longjmp restores 
longjmp call finished execution continues corresponding setjmp call just returned 
function pointers dynamically choose function call runtime 
hard handle statically hard predict statically value function pointer setjmp call corresponding longjmp call 
wagner come rough solutions model permissive necessary add nondeterminism methods train runtime 
method problem need aware function pointers library calls 
detection phase new function called function pointer new longjmp setjmp pair appears method generate anomaly 
reasonable generate anomaly new situations happened occurred training 
dynamically linked libraries problem method fsa method related dynamically linked libraries dlls 
difficulty functions dlls may loaded different relative locations comparing static portion different program runs program counters may change run run 
methods wagner proposed problem pc information online monitoring 
fsa method tried solve problem traversing stack back statically linked portion 
virtual stack list concept means fsa method uses item list statically linked portion state 
behavior function dlls simplified list system calls generated function functions called 
states transitions pointing labeled system calls 
simplifies model dlls lot 
intrusions may occur dlls 
example intruder may install trojan version dll 
fsa method may model dlls simple detect intrusions 
detailed section security critical daemon programs experiments system calls dlls 
model functions dlls just statically linked function 
training block lookup table save information executable memory block forked process including start address block length name full path offset file memory block loaded 
block length file name offset start address match memory blocks different runs 
get return address block lookup table decide memory block relative pc block pieces information uniquely distinguish return address 
return address denoted global block index offset block 
kind anomaly block anomaly 
happens match memory block memory block occurred training 
intruder trying load dll 
linux pseudo file named maps process information pseudo file system proc 
file contains memory block information need 
structures containing similar information flavors unix solaris 
approach match dynamically loaded code block code blocks runs block may loaded different place 
return address uniquely distinguished functions dlls modeled checked just statically linked functions 
threads currently different ways implement threads 
far distinguish thread generates system call problem applying method multi threaded applications 
linux different threads different process ids distinguish threads distinguishing ids 
flavors unix try find ways distinguish threads 
experimental evaluation section results experiments 
describe experiments comparing vtpath fsa terms convergence time false positives overhead detection common root exploits 
describe experiments evaluating effectiveness vtpath attacks including impossible path exploits evade detection models discuss lessons learned 
experiments comparing vtpath fsa sekar conducted experiments normal data security critical daemon programs 
showed fsa uniformly worked better gram sense convergence speed false positive rates overhead 
conducted similar experiments compare vtpath method fsa 
functions statically linked program run new transition fsa new virtual path vtpath 
virtual path contains information corresponding transition 
generally speaking virtual paths specific transitions 
vtpath expect slower convergence speed higher false positive rate higher detection rate 
dlls involved situation somewhat complicated 
fsa simplifies dll behavior model faster convergence speed fewer false positives lower detection rate 
situations simplification may increase convergence time false positives 
intra dll function transition may map different transitions different dll function call points due stack traverse statically linked portion 
situation severe frequently called dll functions intra function transitions 
programs lot signal handling convergence time false positive rates vtpath benefit signal handling mechanism 
conducted experiments security critical daemon 
original fsa implementation authors compared vtpath 
fairness comparison data collected program runs 
experiments conducted redhat workstation dual pentium iii mhz processors 
webstone benchmark suite generate traffic 
files visiting distribution copied laboratory web server 
ftp experiments wrote scripts expect tool 
scripts execute commands mimic common user activities downloading uploading files directories 
scripts randomly executed exercise ftp server 
files copied lab user home directory 
bugs original fsa implementation contributed higher false positive rates slower convergence 
modified programs created fsa implementation 
results vtpath implementation fsa implementations 
convergence training process considered converged normal profile stops increasing new behavior added 
convergence speed important faster training converges time effort needed 
fsa normal profile consists states transitions 
new transition new state state part corresponding transition 
statements true vtpath return address state virtual path transition 
believe number virtual paths transitions metric measure convergence speed profile stops increasing number stops increasing 
numbers plotted numbers system calls training logarithmic scale 
program start daemon program simultaneously record traces methods 
number system calls exceeds preset limit program stops daemon program 
way generate traces different lengths 
apply traces incrementally starting shortest traces training methods 
time trace applied profile copied convergence metric calculated 
shows results ftpd 
solid line star marks vtpath dashed line square marks fsa implementation dotted line circle marks original fsa implementation 
interesting thing number virtual paths increases slowly number transitions 
may due dll signal handling related issues discussed section 
original fsa implementation generates number transitions 
vtpath fsa implementation profile increase stops system calls processed 
httpd experiments show similar results terms comparisons methods 
virtual paths transitions vtpath method fsa method impl 
fsa method orig 
impl 
training period system calls 
convergence httpd experiments system calls statically linked portion 
system calls fsa go back call stack frames find return address statically linked portion 
means levels dll functions called system calls 
facts may suggest dlls important simplification dll behavior fsa may severely impaired detection capability 
false positives ftpd experiments collect normal testing traces ranging system calls method script execution distribution slightly different convergence experiments 
sekar argued account fact things may change training detecting times 
profiles saved convergence experiments analyze testing traces 
sekar mismatched return address state virtual path transition counted false positive 
false positive rates calculated number false positives number system calls trace averaged testing traces method 
shows relationship average false positive rate number system calls training experiments 
note axes logarithmic scale 
vtpath false positive rates fsa implementation 
profiles corresponding system calls false positives testing traces 
original fsa implementation generates higher false positive rates points 
httpd experiments show similar results terms comparisons methods 
false positives system call vtpath method fsa method impl 
fsa method orig 
impl 
training period system calls 
false positive rates runtime space overhead user level mechanism intercept system calls fsa 
pointed sekar mechanism incurs relatively high runtime overhead 
estimated system call interception incurs runtime overhead overhead algorithm execution 
real applications want kernel level mechanisms incur lower system call interception overhead 
section compare algorithm execution overhead methods 
average process time system call evaluate algorithm runtime overhead 
experiments fsa value milliseconds training milliseconds detection 
vtpath value milliseconds training detection 
interesting vtpath algorithm executes faster theoretically little bit slower needs 
reason may paid attention efficiency vtpath implementation 
space overhead vtpath higher fsa 
needs save information call stack 
experiments profiles fsa code creates bytes profiles vtpath code creates bytes 
profiles require spaces loaded memory profiles saved disk human readable 
detection common exploits tested vtpath fsa local remote root exploits local root rc gdm beta 
vtpath fsa successfully detected exploits experiments 
impossible path exploits implemented example attacks including impossible path exploit introduced demonstrate effectiveness vtpath approach 
attacks realized tested redhat machine 
evaluate implementation approach related approaches stack gram callgraph fsa conditions determine effective approaches test attacks develop 
experiments working implementations gram fsa received authors bugs impair detection ability fsa test attacks 
stack callgraph access implementations tests manually algorithms described 
approach able detect attacks described 
approaches analyze detect 
tested approach mimicry attacks described 
find approach fsa able detect mimicry attacks 
find way improve mimicry attacks invisible fsa 
achieve manipulating stack contents analyzed fsa implementation way fsa mistakenly trace back legitimate system call text segment 
masked mimicry attack develop detected fsa implementation 
vtpath able detect original masked mimicry attack 
plan describe improvements mimicry attacks evade ids separate 
section section critique attacks implemented consider general ideas possible attacks detection models discussed 
attack mentioned earlier due lack precision program execution models may possible attacker jump security critical section program code detected ids 
refer class attacks exploits vulnerability impossible path exploits 
attack implement belongs ipe class 
best knowledge working implementation ipe attack 
attack description 
attack works follows 
consider login user function shown 
possible execution paths function statement 
regular user returns true path number followed 
path number followed 
suppose function read cmd called contains overflow strcpy statement 
attacker substitute return address function read cmd returns ii address read cmd return 
void read cmd input buf sys 
copy command strcpy input buf getenv printf sys write void login user int user regular user unprivileged mode read cmd function overflowed 
handle commands allowed regular user return privileged mode read cmd ii function call skipped control transferred ret read cmd system rsync master passwd ok com ipe privileged commands accessible superuser 
pseudo code attack existing models vtpath able differentiate sys write called read cmd called sys write called read cmd ii called 
consequently cause imprecision models including ones gram stack callgraph fsa jump ids detect anomaly 
ids think program followed legitimate execution path number 
vtpath detect attack addition verifying program counters state transitions sees stack context invocations read cmd 
specifically see invalid virtual path sys sys write read cmd return address read cmd changed overflow strcpy 
attack attack description 
attack works follows 
shown called main twice operations checking user name checking password 
selects operation perform parameter 
parameter saved variable mode 
variable modified attacker adjacent local buffer input overflowed 
local buffer overflowed valid username trailing zeros called value mode changed zero 
attack checking user name checking password checks user name twice 
result attacker obtains access knowing password 
attack detected vtpath see invalid path sys close called sys write main 
gram stack callgraph models able detect attack branches system calls system call sequence stays unchanged attack 
fsa attack transition sys close sys write valid fsa transition 
observations attacks described general observations 
attacks require way change control flow program 
sample attacks buffer overflows 
realize buffer overflows possible eventually significant threat 
believe choice justified third cert advisories years buffer overflows 
second programs vulnerable need specific structure allowing example critical section jumped 
attacks described show examples possible program structures exploited security critical function argument controls execution overflowed 
ipe attack necessary function called point program 
int arg int mode arg variable overflowed char input fopen sys open open passwd file overflow changes mode variable execution flow scanf input mode check uname check username 
fread sys read read passwd file fclose sys close valid user input ret ret mode check passwd check password 
fread sys read read passwd file fclose sys close valid pass input ret ret return ret void main printf prompt sys write ret read check username ret ret ii read check password username correct printf authenticated sys write ret execve bin sh superuser mode 
pseudo code attack control flow vulnerable program changed attack function exploited jump occurs 
generalizations attacks describe common property take advantage inherent limitations insufficient level granularity ids model 
information audit data modeling algorithm ids model inadequate way attacks manifest anomalies 
instance attackers exploit fact anomaly ids check program behavior models time system call 
consider example 
attack detected approaches described far 
vtpath unable detect attack ip program different level nestedness anomaly stack contents detected 
proposed pointed important intended behavior program taken account model 
program comes complete specification intended behavior attack causes program behave differently violating specification detected provided ids check pro 
read large string fine important system calls copies larger overflowed ret instruction overflow code jump long system call example code jump ip cond regular user privileges return 
ip superuser privileges execve bin sh 
pseudo code granularity attack gram behavior specification precisely 
purposes ids considered maximal level granularity detect attacks cause program deviate intended behavior 
cases ids inadequate level granularity attacks program evade detection 
importance recognize successful execution attacks described contingent quite variables may possible 
tempting dismiss problem altogether having little relevance finding existing piece code exploitable may easy 
attacks attacker constrained need perform reconnaissance access details environment attacked host particularly ids protection tools 
point looking vulnerable code attackers introduce ipe vulnerable code open source products form innocent improvements legitimate bug fixes 
contrast security flaws attackers may attempt inject changes needed subtle detected code inspection 
reasons typically structure code vulnerable ipe actual commands 
furthermore natural assume attackers power disguise ipe vulnerable code 
done example gradually shaping structure program code series patches 
comparison system call anomaly detection approaches section compare anomaly detection methods underlying principles 
methods include gram fsa vtpath callgraph stack method wespi proposed call uses variable length gram patterns 
principles methods proposed callgraph stack analysis callgraph stack applied methods 
comparison algorithmic approaches models types information 
analyze performance characteristics terms false positives detection capability space requirement convergence time runtime overhead 
realize performance methods vary lot due implementation details issues regarding signals dlls system call parameters 
example detection approaches equipped mechanisms predict static system call parameter values 
mechanisms applied detection approaches appropriate modification static analysis dynamic monitoring 
develop appropriate mechanisms regarding implementation issues approach 
section ignore implementation issues focus underlying principles 
state approach information captured 
model execution program state diagram 
start program system start state 
event occurrence system transits state 
point valid state start state valid intermediate transitions valid 
consider instantiation monitored program 
capture normal behavior model tries capture valid states valid state transitions monitoring behavior program different event points 
model ignore variables specific particular run program 
tries learn behavior program generalizing observed instances program 
feasible monitor program event 
approaches study states system recorded point system calls 
decision monitor system calls justifiable attacks manifest system call level 
possible variables considered defining states system include contents data heap registers code segment program stack system call arguments system variables 
objective model record relevant state variables 
state transition diagram run training period build generalized state transition diagram represents normal behavior program 
data heap register values highly specific particular run program generalize ignore 
code segment useful cases 
system calls arguments certainly useful 
arguments system calls worth recording arguments possible values resulting model slow convergence high overhead 
call stack important learning flow program 
general information develop intrusion detection model helps attaining better detection rate 
may cause higher runtime overhead false positives 
gram var gram choose record system calls 
gram records fixed length sequences system calls occurred training data 
var gram extracts variable length sequences system calls occur repeatedly 
fsa chooses store current system call pc 
involvement pcs possible distinguish system calls name called different locations location sensitive 
vtpath keeps additional entries call stack distinguishes system calls called different contexts context sensitive 
gram achieve characteristics location context sensitive larger believe vtpath better tradeoff considering performance gram fsa vtpath experiments 
state stack callgraph models different approach learning behavior program statically analyzing source code 
concern system calls detection time gram 
false positives false positives depend model captures normal behavior program ignoring information generalize 
callgraph stack models false positive statically derived source code possible paths execution encoded grammar model 
gram var gram record sequences system calls occur training data 
path covered training set may produce new sequence raising false positive 
gram probability alert depends largely size larger higher probability new paths generate new length sequences 
fsa tries model programs accurately account locations system calls 
logical location system call determines system call executed 
model may generate false positive valid system call location valid transition system call locations covered training 
vtpath hand models program strictly valid transitions valid return address combinations 
generate little bit false positives fsa 
fsa vtpath essentially diagrams 
comparing gram location context sensitive property increase false positives hand digram property decrease false positives comparing gram large detection capability section specific attacks missed detection approaches detected 
detection capability ids depends granularity turn determined amount relevant information ids storing modeling technique 
ids granularity better detection capability 
approaches study try model system call behavior program 
attack introduces new system call causes noticeable changes system call sequences common buffer overflow attacks detected approaches 
easier fsa vtpath find trojan horses program counters system calls return addresses function calls probably change change code system call sequences may 
fsa vt path detect attacks system call invalid points 
approaches attacks system call sequences change 
vtpath provides level protection hard jump skip place program changing return addresses avoiding detection 
attacks effect system call sequences return addresses evade approaches discussed frequency parameter value information 
gram var gram detection capability depends statistical regularity normal data properties attack particular attack sequences deviate normal behavior 
concrete research done types attack detected gram var gram 
due context insensitive treatment function calls callgraph model allows ipe 
result attacks follow go undetected 
stack model tries remove imprecision including contextsensitive information 
experiments showed carefully designed evade detection 
non determinism may impair detection capability callgraph stack models 
fsa checks transition pcs system calls 
suffers problems context insensitive property callgraph 
particular ipe evade fsa 
vtpath stores system call points allowed virtual execution paths 
attack changes call stack changes virtual path valid 
space requirement gram var gram main space requirement store system call sequences 
depends number different sequences data structure storage 
example storing sequences form array generally takes space tree structure takes 
callgraph stack models space requirement proportional number transitions size context free grammars cfgs proportional number positions function calls system calls program code 
fsa memory requirement proportional number transitions automaton 
upper bound number transitions proportional square number places system calls program code 
general number transitions comparable callgraph 
vtpath space requirement driven number virtual paths 
extreme case number virtual paths pass function boundaries exponential number function calls program code 
general number virtual paths level number transitions fsa callgraph 
convergence time convergence time mean amount training time data required stable model 
gram converges possible sequences encountered training data set 
depends value increases size required training data increases possibly exponentially 
converges wanted patterns appear repeatedly extracted 
teiresias algorithm uses suitable incremental training usage check convergence training data sets different sizes separately comparing resulting patterns 
fsa need cover possible states possible transitions 
necessary go path execution 
needs data time form stable model 
stack callgraph models static analysis source code require training data 
need just pass program 
vtpath converges possible virtual paths covered 
require somewhat larger data set fsa 
essentially diagrams call stack attached take training data time gram large runtime overheads runtime overhead ids due system call interception processing time ids model 
system call interception overhead similar models discuss processing time model system call 
gram var gram need check matches database system call sequences starting current point 
trie structure done time linear sequence length 
fsa vtpath system call need check valid state valid return addresses valid transition valid virtual path 
hash table take constant time 
non determinism aggravate runtime overhead callgraph stack 
callgraph model multiple paths current state 
efficient techniques cover possible valid states time proportional number states 
system call upper bound time overhead proportional number states 
stack model system call need go possible path cfg determine possible states stack contents 
may take exponential time cases 
summary call stack useful intrusion detection purposes 
developed new method dynamically extracts return address information call stack anomaly detection 
experiments show method effective terms detection ability false positive rates 
compared various related approaches achieve better understanding attacks missed approaches 
main advantages fsa vtpath deterministic location context sensitive 
main advantages callgraph stack remove false positives require training 
may able combine methods advantages 
binary analysis techniques similar extract generate possible system calls corresponding pcs return addresses virtual paths executables 
profile generated dynamically monitor program executions 
avoid false positives profile generated techniques similar static analysis techniques compared 
determinism location sensitive properties kept 
conduct research subject 
yong huang providing related material discussions 
john levine suggestions corrections 
reported supported part aro contract daad nsf contracts ccr ccr 
contents solely responsibility authors necessarily represent official views army nsf 
engler programmer written compiler extensions catch security holes ieee symposium security privacy oakland ca 
cowan pu maier hinton beattie wagle zhang stack guard automatic adaptive detection prevention buffer overflow attacks th usenix security symposium san antonio tx 
cowan wagle pu beattie walpole buffer overflows attacks defenses vulnerability decade darpa information survivability conference expo hilton head island sc 
rigoutsos time complexity teiresias algorithm research report ibm 
forrest hofmeyr somayaji longstaff sense self unix processes ieee symposium computer security privacy los alamos ca pp 
ghosh study neural networks anomaly misuse detection th usenix security symposium pp 

jha miller detecting manipulated remote call streams th usenix security symposium 
hofmeyr somayaji forrest intrusion detection system sequences system calls journal computer security pp 

ko execution monitoring security critical programs distributed systems approach 
phd thesis uc davis 
ko fink levitt automated detection vulnerabilities privileged programs execution monitoring th computer security applications conference orlando fl pp 
lee stolfo data mining approaches intrusion detection th usenix security symposium san antonio tx 
lee stolfo chan learning patterns unix process execution traces intrusion detection aaai workshop ai approaches fraud detection risk management 
webstone benchmark information www com webstone 
rigoutsos combinatorial pattern discovery biological sequences teiresias algorithm bioinformatics pp 

schneier process security information security april www 
com articles april columns shtml 
sekar fast automaton method detecting anomalous program behaviors ieee symposium security privacy oakland ca 
wagner dean intrusion detection static analysis ieee symposium security privacy oakland ca 
wagner soto mimicry attacks host intrusion detection systems acm conference computer communications security 
forrest pearlmutter detecting intrusions system calls alternative data models ieee symposium security privacy pp 

wespi dacier debar intrusion detection variable length audit trail patterns rd international workshop advances intrusion detection lncs springer pp 

