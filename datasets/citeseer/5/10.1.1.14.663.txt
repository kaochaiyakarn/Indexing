adoption focus practical linear types imperative programming type system linearity useful checking software protocols resource management compile time 
linearity provides powerful reasoning state changes price restrictions aliasing 
hard division linear nonlinear types forces programmer trade checking protocol object aliasing object 
onerous restriction type linear component linear 
checking protocol object imposes aliasing restrictions data structure directly indirectly points object 
propose new type system reduces restrictions adoption focus constructs 
adoption safely allows programmer alias objects checking protocols focus allows reverse 
programmer alias data structures point linear objects focus safe access objects 
discuss implemented ideas vault programming language 

successful software component requires just familiarity types functions data component interface 
rules governing proper interaction interface gleaned component documentation case learned local folklore 
rules call interface protocol govern order interface functions may called data accessed 
familiar example file system interface protocol typically rules file opened read written file may read written closed file opened eventually closed 
context permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
pldi june berlin germany 
copyright acm 
manuel hndrich robert deline microsoft research microsoft way redmond wa maf microsoft com vault programming language studied type system tracks lifetime symbolic state objects 
file type states open closed specify read write functions expect open file close function changes file state open closed checking states associated objects requires ability tell different objects apart 
instance code sequence close read obeys interface protocol refer different files incorrect variables alias file 
solve problem vault type system splits program values groups check protocols aliasing restrictions apply values linear type check protocols free aliasing restrictions values nonlinear type 
distinction necessary tractability trade protocol checking aliasing annoyance programmers 
division linear nonlinear types presents annoyance 
linear type system typically restricts programmer design data structures forbidding nonlinear type having linear components 
instance nonlinear records fields refer linear files code sequence close read unsafe aliases due nonlinear types 
prevent safety violations linear type system restricts aliasing objects check protocols object directly indirectly refers 
restrictions checking protocols types objects large program impractical 
aliasing restrictions quickly spread program data structures including graphs caches inherently involve aliasing 
protocol checking practical presents new type system removes restrictions 
contributions allow linear components nonlinear containers control access ensure safety 
introduce adoption construct safely allows aliasing objects check protocols refer 
introduce focus operator provides temporary scope check protocol aliased object 
features allow check vault code struct tracked open file void reset logs msgs errs tracked log msgs close log log open msg log filename log errs close log log open err log filename previous linear type systems reject declaration nonlinear type due linear tracked code reset logs due potential aliasing msgs errs 
system acceptance code demonstrates focus operation 
automatically infer focus operation statements second focus operation statements 
focus temporarily gives log alias msgs linear type field may updated 
safety scope focus access potential alias msgs errs illegal 
potential aliases known due presence guards nonlinear types 
guard means errs msgs aliases 
guards focus prevents access potential aliases 
second focus works similarly 
adoption operation shown allows object allocated linear type initialize field nonlinear type allow aliased 

overview details techniques sections small expression language type system 
section discusses extensions section describes ideas realized applied vault 
section discusses related 
section introduces concepts relax boundary linear nonlinear types provides overview techniques example 
unified view object allocation deallocation 
contrast previous heap objects linear nonlinear objects model allocated linear type deallocated linear type 
model intuitive object creation aliases object 
similarly object freed aliases object dead avoid accesses dangling 
adoption 
objects start linear type impractical program aliasing need way obtain aliases nonlinear type existing objects 
propose adoption construct vault structs types pointers 
adopt takes result adopter result linear type 
construct consumes linear creating internal 
exactly adopter 
result adoption expression nonlinear type 
nonlinear type previous linear type top level type constructor changed linear nonlinear 
nonlinear valid lifetime adopter disallow access internal adopter 
linear components object directly accessed nonlinear 
lead uncontrolled shared access objects linear type 
linear components may accessed scope focus operation discussed 
adopter freed nonlinear adopted object inaccessible mechanism described 
adopter returns internal linear linear type 
multiple adoption expressions adopter object adopt number objects 
access control nonlinear 
adoption construct allows temporary aliases linear object type system ensure aliases invalid object recovers linear type 
aliases witness changes object linear type 
adoption approach recovers linear type adopter freed 
approach invalidating aliases tie lifetime aliases lifetime adopter 
solution builds techniques developed crary deal explicit region deallocation capability calculus alias types walker 
superscripted dot denote linear types absence dot denote nonlinear types 
desired lifetime correlation object basis give static names objects linear type tell apart 
type system object linear type singleton type tr static name 
call static names keys singleton types tracked types 
point program type system maintains keys tracked objects allocated program point deallocated point 
call set keys capabilities 
capabilities means object tracked key type alive program point 
short tracked object allocation lifetime set program points key capabilities 
correlate nonlinear allocation lifetime guarded type form anobject guarded type may expression requiring value type program point key capabilities 
guarded types nonlinear shared freely 
object type tr adopts object linear type result adoption guarded type 
adopter freed key removed capabilities type invalid 
focus 
final important novel concept construct call focus temporarily provides linear view object nonlinear type 
insight violate type invariant nonlinear object including existence long alias object witness violation 
focus construct focus requires evaluate object guarded type 
object called focused object 
change context type checked ways 
bind focused object give type tr fresh key add capabilities 
tracked type expression change underlying type associated remove capabilities access replace linear components 
second ensure aliases witness changes context remove original guarding key capabilities 
temporarily revoking key guaranteed aliases focused object accessible 
capabilities contain live final type matches initial type focus 
guarantees alias witness effects focused object outside scope focus 
focus revoking temporary key granting allowing renewed access objects guarded 
motivating example illustrate benefits type system introduce simple example discuss 
showed previous checking state protocols file example requires typing machinery checking memory safety 
type system check object referenced deletion objects eventually deleted 
keep example simple memory safety protocol 
example central data structure array 
consider program builds dictionary hold sequences monetary amounts indexed person social security number phone number sketched 
program uses function add entry add new amount person entry dictionary 
program stores person data array grows full 
dictionary contains array indexed social security number phone number 
natural representation array mutable cell containing array ref int 
want able free array resize operations array linear type cell shared nonlinear type 
pseudo code assume function dict lookup allocates fresh sharable entry call entry 
similarly function add amount fun dict lookup phone int ssn int dictionary fun add amount cell ref int elem int resize cell fun add entry dictionary phone int ssn int amount int cell dict lookup phone ssn add amount cell amount pseudo code motivating example 
calls resize array full 
show detail implementation resize type checked 
example ill suited previous type systems linearity 
traditional linear type system cell need nonlinear type ref int order shared dictionary 
support destructive resize operation want array linear type 
linear type component nonlinear type give cell linear type ref int incompatible types ref int ref int seminal linear types wadler began soften boundary linear nonlinear types 

construct give temporary nonlinear type linear object 
construct 
recursively changes variable linear type nonlinear form scope expression returns linear type scope expression 
wadler syntactic restriction type prevent escape nonlinear 
odersky proposed observer types prevent escape 
give cell linear type ref int wadler 
obtain nonlinear type cell 
unfortunately issues 
unsuitable case 

sound original setting functional language unsound applied types mutable storage 
case point applying 
view cell linear type ref int nonlinear type ref int allows update cell shared array shown example fun crash int ref int 
free return sub 
gives type ref int scope assignment assignment overwrites unique array pointer stored cell creating heap type type int tr linear type 
tr guard capability type context type language leak 
furthermore subsequent free cell frees array causes index operation sub access freed memory 
second problem 
reliance lexical scope allow implementation fresh sharable object created returned context nonlinear type 
short 
allow represent dictionary 
new type system removes restriction nonlinear types may contain linear types components provides adoption alternative 
adoption handles mutable types rely lexical scoping 
example track dictionary key adopt cells dictionary 
gives cells type ref int allows cells shared nonlinear arrays support deallocation resize linear 
contained linear array needs accessed focus operation cell temporarily revoke provide fresh key focused cell 
possible access contained linear array replace resize operation 
focus possible alias cell accessible access require key 
types expressions illustrate adopt focus allow programs dictionary example type check section presents small type expression language 
section presents typing rules 
types type language formalize ideas discussed previous sections 
type language distinguishes kinds types 
heap types represent mutable tuples arrays stored heap 
objects types 
represent type ref int tuple form int ordinary types include integers tracked types tr guarded types tracked types singleton types tr key static name address object tracked 
objects key stored address heap aliases memory block 
contents memory heap type new free adopt focus fun pre post expressions separately capability form 
note guarded types refer heap type 
type system separate handle linear object tr capability access object 
traditional linear type system couples linear type express linear type handle capability combined existential package 
tr storing linear object data structure object particular address important long capability access object address 
existential type binds address capability address anonymous universal quantification function types captures intuition functions operate uniformly objects different addresses existential quantification linear types captures intuition data structure stored particular way heap exactly irrelevant 
convert linear type ordinary tracked type tr capability unpacked added capabilities current program point 
similarly convert tracked type tr linear type extract capability current capabilities 
conversions captured relation shown appendix 
spatial conjunction capabilities formed expressing keys disjoint keys 
function types form argument type result type 
capability needed call function capability provided return 
function operates heap object stored particular address useful 
avoid problem functions reusable parametric polymorphism 
type context allows function names keys capabilities 
expressions presents small call value expression language manipulating integers updatable tuples functions 
expression obtain ith component tuple updates ith component 
function application written 
tuple components allocated expression new freed expression free tion written adopt type constraint allows programmer specify form adopted type order pack particular fields linear types 
expression provides name binding usual lexical scoping rules 
examples expression sugar 
focus expression focus focuses 

expression fun pre cb post ca defines recursive function wherex formal parameter type ande body type 
cb ca respectively capabilities contains universally quantified variables 
expression instantiate polymorphic functions particular type arguments capabilities keys 
examples multi argument functions formalizing trivial extension 
reduce size language provide primitive expressions creating reading updating arrays rely predefined functions 
examples newarray allocates tracked array size semantics operational semantics language relatively straight forward 
expressions form equivalent type instantiation runtime effect 
similarly focus expression operationally equivalent ordinary expression 
non standard construct adoption 
simple implementation uses special fields object 
field object hold list objects adopted chained fields 
adoption operationally corresponds typing rules guarantee structures formed fields unshared trees 
simplify language types assume free recursively frees linear components object reachable fields 
section discuss alternative semantics recover adopters freed 

typing rules ready show details typing discipline treats adoption focus 
typing judgements form express type context type environment mapping program variables types initial capabilities expression evaluates value type final capabilities 
capabilities threaded expression evaluation track state heap type liveness tracked objects 
standard linear type systems type environments map program variables nonlinear types 
linearity enforced capabilities environment splitting 
similarly type expression nonlinear 
full set typing rules appendix 
highlight interesting rules illustrating example 
adoption ideally tracked types objects program 
tracked types allow sharing nonlinear guarded types needed 
objects guarded type obtained adoption 
adoption involves adopter oa 
objects tracked moment adoption key key adopter 
type rule adoption tr tr adopt adopt typing adopted object adopter capability sure adopted object live type check adopter accessible live judgement 
result adoption type guard reflects key adopter heap type adopted object 
final capability reflecting key adopted object 
operationally adoption adds pointer adopter oa guaranteeing loose 
invariant accessible guarded type enforced key tracked access consumed recovered free adopter 
reason object adopted adopter time 
pointers adopters form linear unshared tree 
adoption allows collection tracked objects adopted single object oa viewed common type type refer adopted objects allowing arbitrary aliasing 
example adoption code dictionary allocate fresh sharable cell 
fun dct tr int pre dictionary post dictionary cell tr new cell newarray adopt cell int dct function takes dictionary argument allocates fresh cell initializes contents fresh array size cell adopted dictionary 
evaluation new capability dictionary int key relax requirement adopter 
freshly allocated tuple initial contents type int 
call newarray returns new tracked array type tr fresh new capability int 
point tuple update rule update appendix tr update instantiate update rule tr dictionary int int tr update capabilities dictionary tr int changed contents refer new array type tr 
note strong update type level content cell changed type int tr 
point adoption require adopted cell type int stated adopt expression 
current type associated tr tr form desired linear type package capability int tr applying rule cap transform appendix judgement tr int int current capability dictionary int 
adopt rule consumes key leaves new cell guarded type int matches expected return type 
focus allowing nonlinear types linear components useful focus operation linear components accessed nonlinear container 
focusing object guarded type allows temporary access linear components illustrate focus running example implementing resize function arrays 
function takes parameter cell guarded type int containing old array parameter size new array size 
function expects capability entry includes dictionary guarding cell 
fun resize cell int size int int pre dictionary post dictionary newarray size focus cell copy free allocate new array bind result 
assuming newarray returns tracked integer array assign type tr 
current capability dictionary int 
apply focus cell 
typing rule focus fresh tr focus instantiate rule int dictionary int split current capability wherec sufficient prove guard andc needed prove guard 
case dictionary key needed key new array needed 
proceed body focus capability int int fresh key giving linear access focused cell 
notice longer dictionary key focus 
prevents focusing alias cell body focus 
type selection 
appropriate type rule indexing appendix tr index rule requires type ith component selected non linear satisfy type judgement invariant expressions evaluate non linear types 
example heap type associated transformed unpacking linear array type cell judgement rule cap transform appendix int tr int unpacking step simply names hidden key int changes cell type refer tr adding capability int current capability 
instantiate index rule tr bind tr 
capabilities point tr int int 
copy contents old array new assuming copy takes tracked arrays change capabilities 
update cell applying rule update shown previous section 
capabilities step tr int int reflecting contains pointer new array 
free consuming key leaving capability tr int 
point scope focus ends 
apply remainder focus rule need apply packing step cell tr int int instantiate remaining part focus rule empty capability 
focus key maps correctly int focus scope aliases focused cell see correct type focus consumes focus key capability dictionary temporarily revoked leaving dictionary matches final capability resize 
recovering free simplify type systems assumed freeing adopter recursively free 
possible way deal 
section briefly contrast different semantics free 
recursive free 
possibly simplest semantics free recursively frees 
semantics raises practical issue avoid leaks operation free components linear types object encountered 
order traverse objects recursively generic needs understand layout objects memory garbage collector 
requirement goes desire apply techniques low level system language explicit data layout control important 
slightly restrictive scenario rely generic memory traversal widely 
region abstraction memory allocation allows individual objects allocated region 
objects freed individually collectively freeing entire region 
model viewed special case adoption objects common block memory immediately adopted region linear type accessible new block 
data allocated regions restricted nonlinear components need traverse blocks recursively free components 
freeing remains constant time operation expected region implementations 
callback semantics 
possibility avoid generic object traversal free register callback function time adoption 
adopter freed callback called corresponding linear type returning context 
particular callback function needs understand layout 
semantics applied region implementation gay aiken 
linear list 
third semantics find useful requires free return linear list 
context free applied choose deal objects way appropriate 
semantics restriction previous proposals requires type 
express having special adopter type form adopter reflecting type 
experience semantics useful programming scenarios 
realistic programming language provide libraries 

algorithmics main detail glossed technical presentation treatment control flow merge points 
prototype compiler insist obtaining single capability description modulo key renaming program point 
capabilities control flow edges target compatible 
requirement restricts set programs typed techniques described earlier encoding correlations values capabilities program limitation cases 
restriction complexity type checking number edges control flow graph function maximal number keys program point maximal size type expression 
practice relatively small number local variables refer tracked objects 

extensions section discusses number extensions important practice obscured previous development unnecessarily 
multi guards 
guards discussed far consist single key name adopter 
straight forward extend guards conjunctions keys guards introduced guard strengthening subtyping step expression type give type 
strengthening guard harder access object keys held time access 
guard strengthening useful view objects adopted different adopters common type 
instance objects types may want hold objects 
types incompatible possible weakening object type guards 
definition resize unfortunate property mentions pre post capability fact key guarding cell key dictionary object 
nature guard irrelevant code hand 
solve problem extend guards guard variables guards form 
guard place explicit guard capability explicit capability dictionary type resize applicable contexts 
extra piece information needed capability implies guard 
recorded type context 
type resize int int int applicable guarded cells matter guard idea bounded quantification capabilities proposed crary allow region aliasing particular contexts 
similarly guards bounded capabilities give control aliasing granularity guarded types 
consider type context capability objects respective types capability bounds imply guard may overlap 
guard satisfiable guard capabilities prove disjoint 
tracked vs linear functions 
far treated function types ordinary types heap types ignoring space requirement associated closure record 
want programmer control closure allocation deallocation treat function types heap types 
closures need allocated new result tracked type explicitly freed point free 
tracked functions called number times point deallocation 
contrast linear functions proposed wadler property called called functions 
functions arise naturally linear type systems function closures capture objects linear type 
note formalism possible type environment contains linear types 
function requires access key key explicitly mentioned pre capability 
interestingly functions easily modeled formalism tracked functions function deallocates closure record 
type function tr heap type associated form pre capability contains requiring key closure post capability contain expressing function consumes closure record 
functions allowed capture objects linear type closure 
interesting note wadler 
applied linear function types unsound 
interestingly adoption sound tracked functions 
long function require closure record pre capability called adoption 
guarded function type key closure available 
autofocus 
described focus explicit construct extent focus lexical scope 
requiring full lexical scope focus impractical focus released scope static typing perspective action occurring focus scope temporary key revoked checking associated heap type scope reinstate revoked capability prove focus guard 
away lexical scope simply record information capability state perusal focus 
propose extend capabilities linear implication focus elimination rule focus simple expression typing rule fresh focus tr focus applying rule establishes focus result expression focus elimination rule applied 
step infer focus expressions automatically tracked type expected guarded type provided providing autofocus 
self adoption 
wadler 
advantage adoption runtime operation involved adoption establishes adoption pointer 
ways provide similar noop behavior adoption model 
lifetime relationship established adoption states outlive adopter 
reflexive relation okay lifetimes simultaneously 
view adopter adopter 
simple unsound approach doing view tracked type tr current capability approach unsound handle type tr possible change heap cell type strong update view cell guarded type ways solve problem provide virtual adopter revoke capability making impossible change type temporarily focus 
release linear implication focus elimination rule introduced issue similar early deallocation region memory management 
expressed typing rule tr fresh self serves virtual adopter arbitrary type actual available linear implication allows adoption undone eliminating virtual adopter 
second solution strengthen guard include heap type alias established 
tracked type tr current capability provide alias guarded type guard satisfied capability contains 
solution allows object viewed tracked type tr simultaneously guarded type strong updates tracked type change guarded inaccessible 
transitive adoption 
adoption relationship transitive object adopted turn adopted effectively adopted 
observation exploited ways object key adopted key object earlier adopted having type viewed new guard 
second reason adopt objects having adopted 
guarded type adopt object tr underlying type viewed type 

validation incorporated ideas adoption focus vault programming language 
briefly describe vault features available conveniently mini language show real world example 
implementation vault implemented adoption focus vault programming language including extensions guards tracked functions autofocus self adoption 
vault surface syntax tracked type tr written tracked guarded type written rn guard 
protocol checking programmer may attach state token key example file open 
function syntax combines preand postconditions change specification states difference capabilities 
constituents change specification syntax precondition postcondition new fresh suffix may omitted protocols track object lifetime state 
change specification terse separate pre postconditions hides universally quantified context capability self adoption vault provides general adoption forms described section 
region allocation provided primitives language callback linear list approaches provided library interfaces 
interfaces functions create adopter adopt objects delete adopter relinquish 
example direct vertex buffers microsoft direct graphics library provides example realistic interface protocol 
library supports vertex buffer abstraction rendering images screen 
render image programmer create buffer clear draw primitives 
calls drawing primitives directly enclosed calls functions 
shows vault specification protocol 
right side illustrates interface state machine 
draw single frame animation program loops cycle protocol buffer states raw clear rendering ready back raw 
larger cycle program typically call times draw complex scene 
function surrogate collection drawing functions 
direct graphics programs vertex buffers tend program central objects referenced data structures 
need alias vertex buffers cyclic nature protocol lend adoption focus 
graphics program create vertex buffers adopt raw state 
adopted vertex buffers referenced data structures static knowledge aliasing relations available 
program wants render animation frame focuses particular vertex buffer order call interface state changing operations 
focus buffer back raw state leaving alias buffer unaware intermediate states 
example illustrates adoption focus allow object switch back forth supporting aliasing supporting protocol checking course lifetime 

related briefly review related reasoning state changes programs dynamically allocated memory 
interface vertex buffer type buffer tracked buffer new raw void clear tracked buffer raw clear void tracked buffer clear rendering void buffer 
rendering void tracked buffer rendering ready void tracked buffer ready raw ready raw rendering interface vertex buffer objects direct library 
region memory management 
tofte talpin inference system classifying allocated data program regions deducing safe lifetime region enables provably memory safe implementations ml languages garbage collector 
crary capability calculus extends allowing explicit region allocation deletes making sure data accesses region happen lifetime 
similarly niss henglein study explicit region calculus albeit order programs 
commonality systems regions treated linearly objects allocated regions types akin guarded types 
regions class values stored data structures 
linear type systems 
starting wadler linear types systems purely functional languages enforce single threading state world implement operations array updating cost full copy 
linear type systems enable resource management granularity single object 
object linear type consumes object leading programming style linear objects threaded computation 
wadler 
construct variations give temporary nonlinear type object linear type 
walker watkins study type system kinds objects linear counted region allocated 
kind object fixed allocation means change kind 
provide 
regions 
alias type systems 
originally developed track incremental initialization tal alias types provide compile time names unshared objects 
walker extends approach existentially bound capabilities support recursive data structures bringing back full expressibility linear types fine grained resource management 
advantage alias types linear types uses destructive local aliasing handled 
leads natural imperative programming style threading values linear type systems done type level 
walker examine ways switch linear clear clear nonlinear views objects 
object oriented analyses 
problem representation exposure uncontrolled sharing internals abstraction problematic object oriented systems sharing destructive updates common 
number different approaches declaring checking representation invariants proposed incomparable expressivity 
example pivots esc correspond linear component possibly shared container formalism developed leino allow pivots reused 
roles enable description precise heap structures allow single tracked objects long known 
object role equivalent guarded type unknown number object role frozen type changes freed garbage collector 
alias system boyland allows unique pointers shared data structures access control exercised read effects possible aliasing express guards 
furthermore alias approach provide lifetime control 
heap logic 
logic bunched implications bi formalism allows reason heap allocated structures sharing properties 
core bi uses spatial conjunction reason disjoint parts heap 
aware automatic reasoning systems bi 
shape analysis valued logic tvla reasoning heap structures 
tvla promising exists effective algorithm inferring precise heap properties albeit high worst case 

current address problem sharing objects multiple threads 
exclusive object access easily modeled keys sharing data threads 
adoption provide solution adopter key available thread time 
investigating mechanisms sharing keys 
shared key scenarios focus operation shared keys explicit locking operation 

enforcing interface protocols data structure invariants proper memory management compile time greatly improves quality imperative resource handling software 
aims develop techniques language features static enforcement practical mainstream 
provides large step direction enabling property checking data structure invariants larger class programming idioms 
data structure scenarios type system handle 
instance object adopted recovered independently adopter 
furthermore techniques address issues related concurrency 
boyland 
alias unique variables destructive reads 
software practice experience may 
crary walker morrisett 
typed memory management calculus capabilities 
popl 
deline hndrich 
enforcing high level protocols low level software 
proceedings acm sigplan conference programming language design implementation june 
gay aiken 
memory management explicit regions 
proceedings acm sigplan conference programming language design implementation number sigplan notices pages june 
henglein niss 
direct approach control flow sensitive region memory management 
acm conference principles practice declarative programming sept 
hearn assertion language mutable data structures 
conference record th annual acm symposium principles programming languages pages 
jan 
lam rinard 
role analysis 
conference record th annual acm symposium principles programming languages jan 
nelson information hiding 
technical report compaq src nov 
odersky 
observers linear types 
krieg br editor esop th european symposium programming rennes france proceedings pages new york 
springer verlag 
conference record th annual acm sigplan sigact symposium principles programming languages 
jan 
sagiv reps wilhelm 
parametric shape analysis valued logic 
popl pages 
smetsers barendsen eekelen plasmeijer 
guaranteeing safe destructive updates type system uniqueness information graphs 
lecture notes computer science 
smith walker morrisett 
alias types 
european symposium programming pages 
strom yemini 
typestate programming language concept enhancing software reliability 
se jan 
tofte birkedal elsman olesen sestoft bertelsen 
programming regions ml kit version 
technical report department computer science university copenhagen 
tofte 
talpin 
implementation typed call value calculus stack regions 
conference record st annual acm principles programming languages pages jan 
wadler 
linear types change world 
broy jones editors programming concepts methods 
apr 
ifip tc working conference 
walker morrisett 
alias types recursive data structures 
proceedings th workshop types compilation sept 
walker watkins 
linear types regions 
proceedings international conference functional programming icfp sept 
appendix var tr index tr update cb ca cb ca fun pre cb post ca fun key cap int int fresh new int new tr tr adopt cap transform adopt 
tr tr unpack tr 
tr pack int int index update cb ca cb ca app guard tr free int free fresh tr focus focus 
