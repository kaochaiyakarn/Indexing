utility file names daniel ellard jonathan margo seltzer tr computer science group harvard university cambridge massachusetts utility file names daniel ellard jonathan margo seltzer harvard university ellard jonathan margo eecs 
harvard 
edu typical workloads file naming conventions size lifespan read write ratio access pattern nearly files file system accurately predicted name file created 
discuss name related properties observed contemporary nfs workloads method automatically creating name models predict interesting file properties new files analyze accuracy models workloads 
show predictions hints optimize strategies file system manage new files created 
cpu memory bandwidth continue grow faster rate disk access speed disk increasingly important concern system designers 
constant improvements disk latency aspects hardware architectures increasingly case performance depends accurate predictions operations allow system anticipate prepare requests occur 
particularly true read requests extensive prefetching called pre caching true file systems benefit knowledge size access patterns file writing 
long history benchmarking shown effectiveness heuristics popular fast file system ffs including aggressive read ahead clustering 
ffs employs heuristic grouping files belonging directory area disk expectation files directory accessed 
idea concept immediate files files short sense embed disk page metadata extended create variants ffs ffs locates inode directory information improve directory lookups uses explicit grouping allow groups small files directory accessed entirely sequentially 
heuristics effective cases limited static adapt variations workload violate assumptions designers 
overcome limitation re search dynamically learning inter file access patterns groups files generalpurpose file systems highly tuned special purpose file systems applications web servers file system 
considerable devel oping exploiting predictive models level file system level 
done hardware level autoraid control operating system hybrid block file level optimiza tion 
widespread heuristic approach suffers problems heuristics wrong may cause performance degrade second heuristics dynamic may take considerable time com putation storage space adapt current workload workload varies time adaptation converge 
partial solution problem inappropriate incomplete file system heuristics application files supply hints file system anticipated access patterns 
hints extremely successful especially combined techniques prefetching selective caching 
drawback approach requires applications modified provide hints 
having application compiler automatically generate hints success area largely confined scientific workloads highly regular access patterns 
analysis long term nfs traces discovered names files powerful predictor file properties 
essence applications lesser extent users applications give useful hints file system file form file name information available immediately time file created 
furthermore possible build name predictive models file properties augment static heuristics file layout accelerate process developing adaptive model usage patterns file 
rest organized follows 
section describe predictive models file properties constructed give analysis accuracy models nfs traces 
section briefly describe nfs traces analysis limitations trace analysis 
analysis relationship file name features prop erties files follows section 
section give example file system optimization trace workloads name information 
section discusses plans fu ture section concludes 
names predictions earlier trace study discovered email oriented workload strong relationship patterns names files properties files 
thing human able perceive patterns trace data thing entirely able automate process discovering patterns building predictive models guide decisions file system policies 
section show possible construct accurate predictive models distinct loads 
constraints algorithms construct predictive models efficient compute require low space overhead computing storing model 
model overly cumbersome compute represent cost may benefit provides 
goal develop efficient algorithm building reasonably accurate models striving achieve accuracy cost 
file name features features build predictive models file properties entirely file names 
considered additional information readily available file system file created including effective user id user creating file flags open creat file created properties directory file created time day discovered way exploit information constructing substantially larger computationally complex model 
feature algorithm classifying file names set components file names 
components construct simple regular expressions tested file names 
initial procedure discovering components file name simple training period predicates file live seconds 
file length zero 
fs activity model nfs local online file name create time pico short lived 
zero length predictions nary files suffix 
pico files distinct interesting properties models constructed components entirely overlook 
address limitation add step component generating procedure file name contains characters characters add prepended set components 
generating model 
model generator takes user generated predicates traces file system activity input creates model 
models take names files creation time predict predicates satisfied corresponding files 
currently training done 
example predicates shown italics 

file name 
function escape string protecting characters string interpreted regular expression operators 

add prepended appended set components 

prepend append split resulting string period giving sn 
si add si set components 
extremely simple partitioning worked quite predicting properties kinds files applications construct file names pasting components periods 
unfortunately applications periods build file names concatenating random opaque string fixed template 
example netscape browser names cached files 
su opaque identifier suf suffix original file pine composer pico creates temporary files string 
files learn useful information suffix benefit learning part browser cache tend different lifetime characteristics example file name prediction tex components prediction tex prediction tex 
diagram system algorithm building predictive model model generator 
algorithm produces model uses file name classify file matching set predicates file length zero file length zero bytes megabyte 
note algorithm properly handles sets logically disjoint predicates 
predicate true particular file instance resulting model weakened 
example predicates file length zero file length logically disjoint file satisfies satisfy second 
similarly predicates file length zero file live seconds logically disjoint possible file satisfy 
set predicates logically disjoint better partition set logically disjoint subsets construct separate models subset 
note predicates chosen statically 
envision file system designers choose predicates properties file system help identify files properties exploit 
example different block layout strategies files predicted large accessed sequentially short rewritten times 
algorithm building predictive name model 
cn set disjoint predicates file attributes 
set tuples pattern count 
initially empty 
store number times file name matching pattern satisfied predicate set tuples string count 
initially empty 
store number times string observed 

file observed training period sin set components file name defined section 
ci subset predicates satisfied file 
predicates logically disjoint imi exists tuple replace 
add re 
tuple default 
ct st nt find corresponding ss ns ns default 
final set defines predictive model 
new file name exists matches file name predict true corresponding file 
note possible model predict true 
case predict rule highest 
computation costs model generator modes 
mode collects data file accessed training file 
second mode collects information files created training period 
algorithm quite simple terms implementation computational complexity 
considering files files created training period algorithm requires seconds piii mhz processing full day trace data busiest system approximately files created day 
building model files observed training period requires approximately seconds piii mhz day 
cases time spent parsing log files stored text represented efficient manner parsing files additional cost approximately seconds predicate depending complexity predicate 
drawback algorithm requires noticeable amount space store information observed training period busy day busiest server log consume nearly megabytes 
largest inefficiency current implementation gathers information file directly nfs traces uncompressed form exceed server day 
simply scanning volume data extract appropriate mb relevant information time consuming process inherent algorithm 
believe gathering information file system interface reduced nfs traces include information need full transcript nfs call response greatly reduce overhead terms storage space needed computational overhead 
accuracy models test effectiveness algorithm generated tested models variety predicates nfs different workloads 
workloads described section 
table show accuracy models produced systems simple predicates 
models generated day test predict properties files created days 
err columns table express accuracy model comparison simple guessing probabilities 
example typical day achieve accuracy simply guessing files created campus zero length guessing files created eecs zero length 
estimate accurate useful considering names trim error rate nearly perfect typical days campus respectable eecs 
predicates small file eecs typically increase accuracy approximately considering names 
models appear accurate long workload remains similar 
workloads campus converge hours training data 
run models long consecutive days perceptible loss accuracy 
situations models better considerably worse simple guessing 
example small file write predictions worse campus 
examination traces output testing system records file names predictions incorrect training reason quite clear day user source code large software package compile package creating sev eral small files written read 
small write files rare campus naming convention source files particular package match files seen training day 
models suffer flaw predictive model training 
behavior system changes rapidly model degrade accuracy 
discussion primary focus predicting behavior files especially short lived files properties files created training period active files properties files created training period 
campus example nearly read write traffic mailbox files files essentially immortal 
default model generator attempt learn files mailboxes primarily interested properties newly created files 
experimented extending training note properties older files system requires processing slightly decreases accuracy shortterm predictions 
believe critical problem problem dynamically adapting access patterns longlived files relatively studied 
feel important fine tune name predictions behavior file young methods deal file ages trade 
zero length deas date correct err campus date correct err eecs date correct err lock file deas correct err campus correct err eecs correct err small file deas correct err campus correct err eecs correct err write deas correct err campus correct err eecs correct err table accuracy predicates files created day 
zero length predicate file contain data 
lock file predicate file live seconds 
small file predicate file written grow 
write predicate data written file file read hour testing period 
predictive model created data day held fixed rest test 
err improvement accuracy provided model compared simply guessing value predicate file observed probability predicate files created day model built model 
workloads investigate accuracy name predictions analyzed traces systems referred campus eecs deas 
campus eecs traces described analyzed extensively previous deas traces new 
campus campus system primary email system harvard college campus harvard graduate school arts sciences gsas 
time trace taken user accounts entire college gsas including students administration spread nfs file systems 
traces analyzed taken file systems 
eecs eecs system network appliance filer hosts home directories research groups departments electrical engineering computer science harvard university 
file server sees predominantly engineering workload email www server traffic 
mail spool eecs users main eecs web site stored different servers traces 
observe traffic caused users filing mail archives home directories caused department web server accessing home pages individual users relatively small fraction workload 
deas deas system network appliance filer hosts home directories mem bers division engineering applied sciences deas harvard 
system serves mail spool deas users web pages central deas web site 
workload system described combination campus eecs anonymized forms traces freely avail able 
contact ellard eecs 
harvard 
edu informa tion 
deas campus eecs total ops getattr lookup access read write read mb write mb ratio table aggregate statistics analysis pe workloads contains elements research development workloads email oriented workloads 
sees traffic due web service 
summary average hourly activity hours test week just peak usage hours am pm monday friday table 
previous trace study give statistics peak usage hours entire analysis period gives accurate representation way systems behave load 
note slightly different subsets data eecs campus ones ana earlier analyses sense week starting monday sunday 
discussion aggregate hourly statistics clear workloads differ 
deas campus workloads heavily read oriented read write ratio deas workload includes requests metadata getattr access 
eecs contrast frequent operation lookup writes outnumber reads reads 
hours deas campus eecs total ops thousands data read mb read ops thousands data written mb write ops thousands peak hours deas campus eecs total ops thousands data read mb read ops thousands data written mb write ops thousands table average hourly activity 
hours columns entire week deas eecs campus 
peak hours hours am pm monday friday respective weeks 
numbers parentheses standard deviations hourly averages expressed percentage mean 
name analysis campus deas campus predict size lifespan access patterns files extremely simply examining component pathname 
nearly files accessed campus fall categories lock files dot files application configuration files unix typically located user home directory prefixed period temporary files created editors create mail messages mailboxes 
size lifespan access patterns predicted strongly categories 
earlier study observed zero length lock files mail programs approximately files created deleted lock files lived seconds 
temporary files created mail composer accounted files created day live minute length smaller 
dot files small multi block dot files example primary mail client configuration file pj nerc varies size 
mailbox files including primary files archive mail considerably larger commonly accessed file rarely deleted 
campus workload entirely dominated email surprising workload characterized terms file names 
table shows distributions file access count cost boxplots size lifespan common suffixes prefixes file names observed campus single day sorted cost 
metric estimating total cost operations file number accesses file plus number blocks read written 
scale factor intended approximation additional block requires assuming reasonably contiguous disk layout 
crude metric give feel amount file system activity associated file 
table shows information deas 
deas string count cost size lifespan lock host sent mail na mbox na pac na bo gif stt abq na inbox dat inp res qn pdf jpg html db na ps na prt oq rto aa mp na sel na campus string count cost size lifespan inbox na lock host sent mail na sent items na pico sent mail xn inbox na doc history 
na login na na aliases na logout na postponed msgs saved messages na jpg letter mp na lu friends na pdf table file statistics simple file name prefix suffix strings deas campus sorted file cost files accessed deas campus 
table string prefix suffix file name 
special string host substituted file prefix suffix name originating host 
count number times file name matching prefix suffix accessed hour period 
cost estimate amount activity generated accesses 
size column shows file size distribution shown log scale boxplot ranging bytes 
lifespan column shows linear scale boxplot lifespan files created hour period ranging hours 
fewer files prefix suffix created sample period na shown boxplot 
boxplots horizontal lines extend minimum maximum values sample 
vertical lines box plot represent left fight lower quartile median upper quartile boundaries 
mean value shown small circle 
uniform distribution boxplot look mini max mean eecs string count cost size lifespan dig core na gz na gif mbox na ps applet dig pdf html jpg host lock na save prev db na table file statistics simple file name prefix suffix strings eecs sorted file cost files accessed 
please refer table description column 
predictions order test theory name information enhance file system performance constructed experiment shows accomplished 
speculate possible improve performance email workload treating lock files short lived files differently ordinary files 
named predictive models shown excellent job identifying files time created remains seen information useful 
test assumption benefit handling small short lived files differently files devised experiment perfectly predict files small short lived 
modified postmark mail oriented benchmark differentiate lock files small mail composer files mailboxes 
mailboxes treated ordinary files modified benchmark allows treat lock files com poser files differently 
section discuss benchmark modified provide discussion file system perform aware priori characteristics files times creation 
experiment shows gained accurate name predictor lock files message files 
experimental setup embedding lfs eecs user activity eecs union kinds activities observed workload complex campus rich deas 
preliminary analyses show files eecs pathname file strong predictor file properties 
table illustrates distributions file access count cost size lifespan file name 
zero length files contain data blocks manipulating purely meta data problem 
solving problems addressed techniques soft updates journaling 
techniques require disk head movement incur rotational delay 
believe better approach purely logstructured approach lfs store files 
short lived files particular lfs particularly advantageous overhead creating files low cleaning process efficient expect nearly files segment die segment cleaned 
single spindle solution best solution combine layout policies ffs ordinary files log scheme lfs short lived files 
building new file system combine major undertaking approximate behavior system relatively simple experiment 
methodology default ffs ordinary files lfs files anticipate short lived 
construct ordinary ffs file system lfs file system single disk way space ffs lfs file systems interleaved 
done initially partitioning disk partitions large partitions smaller partition 
large partitions glued form virtual partition ccd ffs built top partition 
lfs built top middle partition 
arrangement illustrated 
purpose embedding lfs space ffs minimize penalty seeking file system switch accessing ordinary files creating deleting lock files 
locating lfs region disk ffs closely mimic actual behavior observe lfs ffs shared cylinders disk 
postmark postmark industry standard synthetic benchmark measuring electronic mail netnews web commerce 
performs create delete read append transactions user specified workload 
decides size new files append choosing uniformly random smallest largest possible file sizes 
simple knob accurately depict campus accesses bytes accessed come files larger kilobytes vast majority accesses mail workload small files 
accesses ccd concatenated disk driver utility provided unix distributions 
ffs lfs exp ffs exp lfs disk platter ffs lfs sharing disk drive lfs embedded ffs 
tended fall categories zero length lock files generally short dot composer files large mailboxes 
modified postmark ways support experiments 
uniform distribution modified file creation size provide stepped distribution follows simplification observations campus files byte lock files byte kb kb byte mb 

input parameter modified postmark put files lock files lock small files lfs partition exp lfs 
files put lfs put ffs 

lock files small files appended created 
netbsd lfs implementation default ffs 
lfs partition put locks lfs small files lfs locks lfs files stored lfs modified postmark 
number transac tions second shown files stored lfs just locks locks small files 
lfs functioning poor man circular buffer 
mb mb 
ffs parti tions gb 
experiment performed machines similar configurations mhz pentium iii processor mb ram netbsd os 
differences hardware configuration machine ide disk machine older scsi disk 
configured postmark simulate concurrent mail users parameters subdirectories user reads writes occur blocks maximum number files reads biased appends similar read write ratio seen campus 
shows average runs transactions variance average 
experiment shows lfs store lock files message files provide order magnitude increase number transactions compared configuration ffs 
course holds accurately predict access patterns files avoid putting long lived files lfs partition 
particular performance gain peak artifact synthetic workload experiment provide evidence potential significant performance gains properties file size lifespan correctly predicted handled accordingly 
trace data nfs systems remains open question build useful name models predict properties files non unix non nfs workloads 
leave aspects experimentation 
run simi lar test postmark test tune able synthetic workload generator 
includes eleven sample workloads mail workload saito analysis mail file size zipf distribution set average message size kb long tail pareto dis tribution mb 
uniform postmark distribution distribution need augmented zero length lock files appear zipf distribution 
second additional aspect experimentation add copy thread runs immediately front lfs cleaner thread 
thread examine block lar buffer lfs experiments copy standard file system ffs files deleted mark contents buffer deleted 
cleaner see empty blocks 
serve purpose fixing guesses wrong 
lived longer sweep buffer exist standard file system mechanism serves put 
steps provide information performance circular buffer workload 
logical step file system transparently incorporates name predictor circular buffer migration thread copy incorrect guesses long term storage long term storage 
shown strong relationship file names properties files distinct workloads 
shown models discover relationships predict properties new files created systems efficient construct evaluate 
demonstrated models highly accurate predicting properties interest file system designers including file size lifespan 
kenneth salem 
adaptive block rearrangement 
computer systems 
darrell anderson jeff chase 
flexible network file service benchmark 
technical report tr duke university may 
pei cao edward felten anna kar lin kai li 
implementation performance integrated application controlled file caching prefetching disk scheduling 
acm transactions computer systems 
dan ellard jonathan pia margo seltzer 
passive nfs tracing email research workload 
proceedings rid usenix fast conference 
gregory ganger frans kaashoek 
embedded inodes explicit grouping exploiting disk bandwidth small files 
usenix annual technical conference pages 
griffioen appleton 
improving file system performance predictive caching september 

postmark new file system benchmark 
technical report tr network appliance october 
thomas kroeger darrell long 
case efficient file access pattern modelling 
proceedings seventh workshop hot topics operating systems hotos vii rio rico az march 
ieee 
marshall mckusick william joy samuel leffler robert fabry 
fast file system unix 
computer systems 
todd mowry angela krieger 
automatic compiler inserted prefetching core applications 
proceedings symposium operating systems design implementation pages 
usenix association 
mullender tanenbaum 
immediate files 
software practice experience number apr 
hugo patterson garth gibson daniel jim zelenka 
informed prefetching caching 
acm sosp proceedings 
mendel rosenblum john ousterhout 
design implementation logstructured file system 
acm transactions computer systems 
yasushi saito brian bershad henry levy 
manageability availability performance porcupine highly scalable cluster mail service 
proceedings th acm symposium operating systems principles sosp pages 
konrad schroder 
lfs netbsd implementation 
www 

org ht ml 
margo seltzer greg ganger kirk mckusick keith smith craig soules christopher stein 
journaling versus soft updates asynchronous meta data protection file systems 
usenix annual technical conference june 
margo seltzer keith smith 
file system logging versus clustering performance comparison 
usenix annual technical conference june 
elizabeth shriver eran gabber lan huang christopher stein 
storage management web proxies 
usenix annual technical conference pages june 
carl hudson staelin 
high performance file system design 
technical report tr princeton university 
john wilkes richard golding carl staelin tim sullivan 
hp autoraid hier storage system 
high performance mass storage parallel technologies applications pages 
ieee computer society press wiley 
