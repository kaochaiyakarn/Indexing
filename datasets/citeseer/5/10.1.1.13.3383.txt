generalization paillier public key system applications electronic voting ivan damgard mads jurik jesper nielsen aarhus university dept computer science brics 
propose generalization paillier probabilistic public key system expansion factor reduced allows adjust block length scheme public key fixed losing homomorphic property 
show generalization secure paillier original system propose ways optimize implementations generalized original scheme 
construct threshold variant generalized scheme zero knowledge protocols show ciphertext encrypts set plaintexts protocols verify multiplicative relations plaintexts 
show building blocks applying scheme cient electronic voting 
reduces dramatically needed compute final result election compared previously best known schemes 
show basic scheme vote easily adapted casting vote candidates 
basic building blocks adapted provide receipt free elections appropriate physical assumptions 
scheme elections optimized certain range parameter values logarithmic paillier proposes new probabilistic encryption scheme computations group rsa modulus 
scheme attractive properties homomorphic allows encryption bits operation constant expansion factor allows cient decryption 
propose generalization paillier scheme computations modulo 
show system simplified degrading security public key consist modulus allows instantiating system block length encryption chosen freely encryption independently size public key losing homomorphic property 
generalization allows reducing expansion factor paillier original system 
prove generalization secure paillier basic research computer science centre danish national research foundation 
original scheme 
provide number ways optimize encryption decryption operations particular new algorithm encryption compared naive implementation paillier original scheme saves factor computing time 
general saves factor compared straightforward implementation generalized system 
propose threshold variant generalized system allowing number servers share knowledge secret key large subset decrypt ciphertext smaller subsets useful information 
prove random oracle model scheme secure standard centralized implementation 
propose zero knowledge proof knowledge allowing prover show ciphertext encodes plaintext 
derive tools protocol showing ciphertext encodes number plaintexts 
propose protocol allows verification multiplicative relations encrypted values revealing extra information 
look applications electronic voting schemes 
large number schemes known cient terms needed voters cramer gennaro schoenmakers 
protocol provides fact general framework allows usage probabilistic encryption scheme encryption votes encryption scheme set nice properties particular homomorphic 
basic idea straightforward voter broadcasts encryption vote sending bulletin board proof vote valid 
valid votes combined produce encryption result homomorphic property encryption scheme 
set share secret key scheme threshold fashion decrypt publish result 
paillier pointed encryption scheme homomorphic may applicable electronic voting 
order apply framework important building blocks missing needs cient proof validity vote cient threshold variant scheme result decrypted allowing single entity possibility learning single voters voted 
building blocks precisely provide 
immediately get voting protocol 
protocol needed voters order original version 
needed produce result reduced dramatically explain 
el gamal encryption decryption process election produces mod prime generator desired result 
needs solve discrete log problem order find result 
bounded number voters feasible moderate size 
requires exponentiations may certainly wants avoid large scale elections 
problem worse consider election choose candidates 
method exponential requires time prohibitively expensive elections large scheme propose removed completely 
decryption process produces desired result directly 
scale easily larger values choosing new keys just going larger value give ways implement ciently constraints voting occur real elections allowing vote precisely candidates vote 
schemes size single ballot bit length modulus propose variant di erent technique ballots size max log log 
log cient optimal constant factor log bits distinguish candidates 
furthermore scheme requires decryption operation 
results preliminary form 
related independent earlier stern proposed threshold version paillier original scheme 
threshold scheme uses adaptation shoup threshold rsa scheme techniques somewhat di erent particular construct threshold version generalized crypto system paillier original scheme 
voting pointed potential application suggestion protocols prove encrypted vote correctly formed course necessary secure election practice 
done concurrently independent pointcheval stern propose voting scheme somewhat similar 
seen complementary sense proposal oriented system architectural aspects large scale election optimization building blocks 
compare scheme note modulus length chosen log scheme produces ballots size 
estimate explicit constants dominating term notation kl 
voting scheme uses generalized paillier crypto system chosen independently particular scheme scale size election keys generated 
choose log ballots produce size log 
working concrete constants involved finds complexity complexities assume length challenges zeroknowledge proofs dominated term log moderate size elections gained significant factor complexity compared 
hirt sako propose general method building receipt free election schemes protocols vote buying coercing possible voters prove voted 
method applied receipt free version scheme 
applied scheme ciency gain non receipt free case 
threshold version scheme assume simplicity trusted dealer setting keys initially assume modulus safe prime product similar done shoup 
damgard propose techniques drop restrictions shoup scheme expense extra intractability assumption 
idea easily applied scheme producing scheme trusted dealer general rsa modulus 
threshold version scheme general secure multiparty computation shown cramer damgard nielsen 
generalization paillier probabilistic encryption scheme public key crypto system describe uses computations modulo rsa modulus natural number 
contains paillier scheme special case setting 
consider modulus pq odd primes gcd 
large randomly chosen satisfied negligible probability 
called admissible 
multiplicative group direct product cyclic order isomorphic follows directly chinese remainder theorem fact cyclic order factor group cyclic order arbitrary element ah denote element represented factor group lemma 
admissible element order proof 
consider integer number modulo modulo clearly case follows order divisor number form set consider term sum claim term divisible trivial follows 
prime factors divide assume contradiction loss generality assume means know divides dividing numbers see divide number term sum division rest divisible number fact modulo contradiction 
order relatively prime lemma implies immediately element generator possibly cosets leads natural numbering cosets 
lemma captures structure concrete way lemma 
admissible map zn mod isomorphism mod mod mod proof 
mod enumeration cosets prove mod mod maps clear looking binomial expansion easy see mod 
proves homomorphic property directly pigeon hole principle implies injective 
lemma gives encoding cosets 
final technical observation need inverted factorization particular discrete logarithms base easy factorization 
theorem 
admissible map zn mod inverted polynomial time common multiple 
proof 
show find mod define function clearly mod 
mod describe algorithm computing number 
general idea algorithm extract value part part extract mod mod forth 
easy extract mod mod extract rest induction step th step know means mod 
mod notice term satisfies mod contributions vanish modulo multiplication means get mod 
mod just rewrite get wanted mod 
mod mod 
mod equation leads algorithm mod mod 
mod assume mod show find 
find compute modn modn modn algorithm find mod extract compute mod compute mod possible gcd 
mod mod mod mod ready describe crypto system 
fact natural number build crypto system cs follows key generation input security parameter choose admissible rsa modulus pq length bits choose element mod known relatively prime done choosing random computing alternatives described 
common multiple 
chinese remainder theorem choose mod mod 
choice 
paillier original scheme smallest possible value 
making threshold variant choices better expand section 
public key secret key encryption plaintext set zn plaintext choose random ciphertext mod decryption ciphertext compute mod clearly get ji apply algorithm proof theorem compute mod applying method replaced clearly produces value jd mod computed fly saved part secret key 
case obtain cleartext jd mod clearly system additively homomorphic zn product encryptions messages encryption mod facilitate comparison paillier original system kept system description close possible paillier 
particular description allows choosing variety ways 
shall see semantic security system equivalent particular computational assumption matter choose particular may simplify matters choose 
allows cient implementation 
sections refer cs usually mean system 
security basic flavors strengths security may consider strictly speaking need insignificant practice smaller scheme way hard compute plaintext ciphertext 
scheme semantically secure information plaintext leak ciphertext 
give short informal discussion wayness look semantic security detail 
homomorphic property scheme means problem computing plaintext ciphertext public key random ciphertext public key may choose zn random try decrypt ciphertext cg mod respect public key mod succeeds find original plaintext multiplying subtracting modulo note random ciphertext generator pair matter chosen 
algorithm break non trivial fraction ciphertexts choices break random instance significant probability 
motivates calling scheme way hard find plaintext random public key random ciphertext proposition 
scheme cs way cs way especially cs way paillier original scheme cs way 
proof 
assume cs way 
assume sake contradiction cs way 
public key ciphertext cs transform decryption problem cs 
concretely means consider number modulo choose public generator random number mod randomize modulo described 
produces random instance decryption problem cs assumption find plaintext cs corresponding course zn clearly mod plaintext corresponding cs cs way 
want claim cryptosystem hides plaintext reasonable sense way assumption essentially weakest possible assumption 
gennaro graham show assumption cs implies semantically secure system hiding logarithmic number bits ciphertext original system somewhat stronger assumption implies system hiding linear number bits ciphertext 
easy generalize results cs schemes constructed way homomorphic 
semantic security schemes assumption introduced paillier decisional composite residuosity assumption dcra conjecture 
probabilistic polynomial time algorithm assume gets input 
bits chosen described random random th power random element subgroup defined earlier 
outputs bit probability random probability random th power 
negligible negligible usual means smaller polynomial large discuss semantic security cs equivalent formulations semantic security 
definition 
adversary public key crypto system gets public key pk generated security parameter input outputs message encryption pk message chosen uniformly message space outputs bit 
respectively probability outputs encryption respectively random encryption 
define advantage adv 
crypto system semantically secure probabilistic polynomial time adversary adv negligible paillier showed crypto system equivalent security cs semantically secure dcra holds 
holds choice follows easily fact ciphertext random encrypts message cg mod random random th power 
particular assuming dcra may choose degrading security 
show security cs equivalent dcra theorem 
crypto system cs semantically secure dcra true 
holds allowed increase polynomially security parameter 
proof 
ciphertext cs obtain ciphertext cs reducing modulo implicitly reduces message modulo clear dcra fails cs secure converse assume cs secure start showing relation security cs cs values message space cs zn message written adic notation tuple zn dn distribution obtained encrypting message public key replaced means corresponding position message chosen uniformly zn encrypting 
assume simplicity consider adversary cs assume adv polynomial infinitely values value assume loss generality 
suppose public key security parameter show get message show sample dn 
probability outputs 
course cases true infinitely values case successful adversary cs follows get public key show get return output 
get ciphertext encrypts cs random ciphertext 
consider element know encryption plaintext random elements significant positions 
mod encryption 
random encryption give mod return bit outputs 
encrypts shown sample dn sample dn 
assumption breaks cs advantage infinitely second case adversary cs follows get public key show get message 
output get back ciphertext encrypts cs random 
consider number modulo know corresponding plaintext cs random elements significant positions unknown top positions 
random encryption show cd mod return bit outputs 
encrypted shown sample dn sample dn 
breaks cs advantage infinitely sum adversary cs exists adversary cs adv infinitely similarly odd show existence adversary cs cs advantage infinitely repeated result shows adversary cs exists adversary cs advantage sf infinitely polynomially bounded function cs semantically secure contradicts paillier original result 
point view exact security analysis note proof follows maximal advantage cs broken factor larger corresponding advantage cs great security risk large values believes cs secure place 
adjusting block length mentioned may choose losing security public key may consist modulus means decide value point keys generated sender decide fly encrypts message 
concretely system follows key generation choose admissible rsa modulus pq 
public key secret key common multiple 
encryption plaintext represented non negative integer choose choose random ciphertext mod decryption ciphertext compute mod note length decide correct value negligible probability 
clearly get modn mod mod apply algorithm theorem compute mod get message multiplying modulo immediate corollary proposition theorem scheme way cs way respectively semantically secure dcra holds 
optimizations implementation issues alternative encryption function zn isomorphism mod lemma 
encrypt element zn random element coset 
element chosen random note reduce ciphertext modulo obtain mod mod mod jacobi symbol modulo easy compute factors see odd jacobi symbol multiplicative see compute jacobi symbol ciently 
multiplying number form arbitrary constant jacobi symbol obtain ciphertext rr guaranteed jacobi symbol 
easily follows crypto system cs restrict jacobi symbol exactly secure cs notion security 
exploit obtain alternative cient encryption function 
standard techniques generate random rsa modulus pq known mod mod gcd 
means subgroup quadratic residues sq cyclic odd order say 
ensure elements subgroup negligible fraction generators 
done picking prime factors su ciently large 
extreme special case safe prime product option threshold version scheme 
elements jacobi symbol contains sq order cyclic 
sq choice implies choose random mod negligible probability 
allows generate uniformly random element mod uniformly random integer 
secret key allow owner secret key encrypt course useless 
remedy result 
generated 
uniformly random integer uniformly random element 
theorem random variables mod mod computationally indistinguishable assuming intractability factoring implied dcra 
means mod uniformly random element distinguished uniformly random element polynomial time algorithm su ces application 
gives crypto system cs key generation choose admissible rsa modulus pq length bits mod gcd random square generates sq negligible probability 
choose generator zn described 
public key secret key common multiple 
encryption plaintext zn choose random ciphertext mod mod mod 
decryption 
theorem follows directly fact mod pseudorandom dcra generated just security cs unchanged restricting randomness jacobi symbol 
theorem 
crypto system cs semantically secure dcra true 
holds allowed increase polynomially security parameter 
exact security point view aware order argue security dcra twice argue cs secure cs mod pseudorandom argue cs secure 
means want build instances cs broken advantage larger instances cs security parameter need moduli somewhat longer bits 
longer depends exactly strong assumptions willing complexity reduction result 
may partly eliminate ciency advantage show cs hand issue completely avoided randomness choose random number modulo random bit number 
mod statistically close random element assumptions negligible term security variant cs cs cost factor performance encryption 
optimizations encryption decryption encryption 
encrypting computing directly compute mn 
mod trades exponentiation size exponent multiplications calculating th step calculate mod multiplication calculate binomial modulo optimize computations precomputed 
pseudo algorithm calculating part encryption looks array precomputed values mod mn tmp tmp tmp mod tmp mod crypto system cs elements generated mod mod computed naively certainly leads optimization 
simple observation allows reduce number steps computation 
mod isomorphism theorem mod mod mod mod follows mod precompute save standard methods exponentiation fixed base mod computed expected number multiplications modulo entire encryption done multiplications 
compared straightforward implementation cs value full scale exponentiations saves factor computing time particular times fast paillier original system 
decryption 
technique precomputing factors binomial coe cients encryption faster applies corresponding computations decryption see algorithm proof theorem 
way encryption exploit fact algorithm involves modular multiplication variable power means value variable needs known modulo smaller power thing optimized function 
algorithm theorem function calculated iteration loop 
doing calculate largest mod property mod mod mod means remove division modular reductions smaller 
standard trick splitting computations doing modulo relatively prime parts modulus moduli th run outer loop 
aware need di erent functions mod mod mod mod case decryption speeded precomputing 
mod 
mod performance evaluations 
generalized crypto system compared el gamal rsa crypto systems 
table focused fixed plaintext size variable size security parameter generalized cryptosystem 
comparison corresponds scenario need certain fixed plaintext size instance large scale election su cient smaller security parameter 
shows security parameter doesn need size encryption block significant performance improvement achieved 
comparison number milli seconds takes encrypt bit security parameter variable block size 
shows el gamal generalized crypto system achieves rates encryption 
shows expected encryption time bit increases somewhat larger values 
small ciphertext expansion large block size important achieved reasonable performance penalty speed important parameter best choice 
fig 

comparison bit plaintext size java implementation generalized el gamal rsa security ciphertext size expansion factor encryption ms decryption ms fig 

comparison bit plaintext size java implementation generalized paillier el gamal rsa security ciphertext size expansion factor encryption ms decryption ms fig 

ms bit encrypted decrypted mhz pentium iii java implementation security generalized paillier parameter el gamal rsa encryption decryption building blocks threshold variant scheme section way distribute secret key set servers subset decryption ciently useful information 
course done degrading security system 
shoup proposes cient threshold variant rsa signatures 
main part protocol allows set servers collectively ciently raise input number secret exponent modulo rsa modulus little precisely input server returns share result proof correctness 
su ciently correct shares ciently combined compute mod secret exponent 
explain quite simple transplant method case allowing servers raise input number secret exponent modulo solve problem letting servers help compute mod choose mod mod remaining part decryption easy knowledge warn reader secure particular choice instance paillier original choice seeing value mod allow adversary compute break system completely 
case exponentiation result safely public contains trace secret 
concrete description compared secret exponent public exponent things slightly di erently decryption process 
assume decryption servers minimum needed correct decryption 
modulus product safe primes pq primes 
need subroutine zero knowledge proof values holds log log 
guaranteed values group squares modulo generates entire group squares 
note group cyclic order safe prime product 
protocol easily derived corresponding works follows protocol equality discrete logs 
input private input log log application length bits modulus length 

chooses number random length bits sends mod mod verifier secondary security parameter 

chooses random challenge length bits 

sends number ey checks au mod bv mod protocol non interactive fiat shamir heuristic hash function prover computes sets computes reply defines proof 
verify proof checks 
note need include input application fixed chosen honest dealer 
assuming random oracle model replacing random function show soundness zero knowledge protocol 
done exactly way shoup working cyclic group large prime factors order 
leave details reader 
key generation key generation starts find primes satisfies primes di erent set pq decide plaintext space zn pick satisfy mod mod polynomial mod picking random values secret share th authority public key 
verification actions decryption servers need fixed public values generating cyclic group squares decryption server verification key mod 
encryption encrypt message random picked cipher text computed mod seen previous schemes generator chosen improve ciency 
ects encryption ect security threshold decryption scheme 
share decryption th authority compute ciphertext 
zero knowledge proof described log log convince raised secret exponent share combining required number shares correct proof combine result subset shares combine mod value form noting mod mod conclude mod desired plaintext means compute applying algorithm theorem multiplying result mod compared scheme proposed technical di erences apart fact works original paillier version modulo extra random value related public element part public key share combining algorithm 
avoided scheme way choose get slightly shorter public key slightly simpler decryption algorithm 
system described requires trusted party set keys 
may acceptable operation trusted party delete secret information soon keys distributed 
multiparty computation techniques possible key generation trusted party particular ideas give reasonably cient solution 
note key generation phase requires value parameter fixed 
means system able handle messages encrypted modulo simply exponent satisfies mod completely general decryption procedure needed done assume secret shared key set phase servers compute suitable running secure protocol inverts modulo get result computes product integers 
require generic multiparty computation techniques done quite ciently techniques 
note require communication servers needed decryption value 
show random oracle model threshold version secure centralized scheme trusted player decryption particular threshold version secure relative complexity assumption basic scheme 
done model static adversary corrupts players start 
concretely theorem 
assume random oracle model static adversary corrupts players 
ciphertext decryption protocol outputs correct plaintext negligible probability 
oracle input ciphertext returns corresponding plaintext adversary view key generation decryption protocol ciently simulated statistically indistinguishable distribution 
fact random oracle needed ensure non interactive proofs correctness shares 
doing proofs interactively allow dispense random oracle proof follows closely corresponding proof 
sketch basic ideas correctness scheme immediate assuming adversary contribute incorrect values negligible probability 
turn ensured soundness zero knowledge proofs simulation start public key simulate shares bad players choosing random numbers modulo statistically indistinguishable real values chosen modulo fixed choice means shares uncorrupted players polynomial fixed particular easy simulator compute 
simulate choosing ciphertext known plaintext mod compute mod mod set indices lagrange coe cients interpolating value polynomial point times values points compute correct values uncorrupted players get ciphertext input ask oracle plaintext allows compute mod means interpolate compute contributions uncorrupted players 
zero knowledge property invoked simulate proofs correct 
auxiliary protocols suppose prover presents skeptical verifier ciphertext claims encodes plaintext precisely knows 
trivial way convince reveal random choice verify mod need solution extra useful information revealed 
easy see equivalent convincing mod encryption equivalently th power 
propose protocol purpose simple generalization 
note protocols zero knowledge stand honest verifier zero knowledge 
zero knowledge protocols problems constructed standard methods secondly applications non interactive variant fiat shamir heuristic means obtain zero knowledge obtain security random oracle model 
soundness prove protocols satisfy called special soundness see particular implies satisfy standard knowledge soundness 
protocol th powers input private input 

chooses random sends 
chooses random bit number sends 
sends rv mod checks prime au mod accepts case 
simple show lemma 
protocol complete honest verifier zero knowledge satisfies pair accepting conversations prover form ciently compute provided smaller smallest prime factor proof 
completeness just plug equation checks lemma get au rv mod mod honest verifier simulation simulator chooses random random sets mod outputs 
easily seen perfect simulation 
claim observe conversations accepting au mod au mod get mod mod prime assumption choose 
mod set mod notice mod mod 
get mod desired th root application protocol modulus chosen trusted party multiparty computation prime factors roughly size 
bit length set assured cheating prover verifier accept probability lemma immediately implies techniques build cient proof encryption contains values revealing encryption candidate plaintexts prover verifier compute mod mod prover shows encrypt proves knowledge corresponding th roots 
done protocol assume loss generality prover knows denotes simulator power protocol protocol th power input private input 
chooses random invokes input get conversation sends 
chooses random bit number sends 
computes mod mod sends 
checks mod mod mod relatively prime accepts case 
proof techniques lemma immediately imply lemma 
protocol th power complete honest verifier zeroknowledge satisfies pair accepting conversations prover form ciently compute provided smallest prime factor final building block allows prover convince verifier encryptions contain values ab mod propose protocol inspired similar construction 
protocol multiplication mod input private input ab mod 
chooses random values zn db sends encryptions db db db 

chooses random bit number sends 
opens encryption ea mod sending ea mod mod opens encryption db db mod sending db mod 
verifies openings encryptions previous step correct values sent relatively prime accepts case 
lemma 
protocol multiplication mod complete honest verifier zeroknowledge satisfies pair accepting conversations prover form db db ciently compute plaintext corresponding ab mod provided smaller smallest prime factor proof 
completeness clear inspection protocol 
honest verifier zero knowledge observe equations checked mod db mod clear generate conversation choosing random computing db satisfy equations 
requires inversion modulo generates right distribution values independent random real conversation 
claim note encryptions uniquely determine plaintexts fixed values contained value contained db fact conversations accepting implies ea mod mod fb ec mod putting obtain mod ab mod invertible modulo assumption conclude ab mod compute 
protocols section non interactive standard fiat shamir heuristic computing challenge message hash function 
proved secure random oracle model 
furthermore protocols phrased prove statements values encrypted cs directly way values encrypted cient variant cs follows fact know mod words ciently compute 
prover protocols pretending encrypted cs note applies ciphertexts input protocols generated prover executions 
cient electronic voting general model elections briefly recall set voters vm bulletin board set tallying authorities bulletin board assumed function follows player write message deleted written 
players access messages written identify player message comes 
implemented secure way instance existing public key infrastructure server replication prevent denial service attacks 
assume purpose vote elect winner candidates voter allowed vote candidates 
denote fixed hash function noninteractive proofs fiat shamir heuristic 
assume instance threshold version paillier scheme public key set acting decryption servers 
assume true choosing large 
notation roof logical statement denote bit string created player follows selects appropriate protocol previous section interactively prove computes message protocol computes id id user identity system result challenge verifier computes answer roof 
inclusion id input done order prevent vote duplication 
check proof note auxiliary protocols easily compute proof correct 
instance protocol powers statement consists single number modulo verifier checks au mod mod computed checks id 
protocol case simple describe 
equivalent vote vote thought number equal 
voter decides vote calculates randomly chosen 
creates roof encryption th power protocol 
writes encrypted vote proof 
set 
check proof written valid mod executes part threshold decryption protocol input ciphertext writes result 
messages written reconstruct plaintext corresponding possibly discarding invalid messages 
assuming simplicity votes valid evident mod mod 
decryption result mod security protocol random oracle model proved security results shown sub protocols semantic security paillier encryption scheme 
voting schemes play role example applications crypto system auxiliary protocols give formal proof 
groth presents full proof security voting scheme definition canetti 
ways generalize 
probably simplest way hold parallel votes 
voter votes candidates wants 
means send votes form ij ij ij roof ij ij encryption prove voted exactly candidates writes number ij mod allows talliers verify ij ij encryption check su cient individual votes proved 
immediate decryption results immediately give number votes candidate received 
size vote protocol seen lk bit length simple inspection protocol 
protocol requires decryption operations 
numeric example suppose challenges bits proofs 
vote system size kbyte 
note easily generalizes cases voters allowed vote candidates simply introduces dummy candidates addition actual execute protocol candidates 
voter places votes want dummy candidates 
cient method large add dummy candidate receive unused votes 
voter prove product encryptions decrypts su cient prove addition number votes dummy candidate small order reduction modulo take place votes voter added 
done bit string representing number votes dummy candidate voter encryptions ij ij proof roof ij ij encryption votes dummy candidate calculated il verified ij encryption uses blocks log proofs 
variant smaller vote size parameters log significantly better 
conditions satisfied realistic situations instance numeric example 
basic idea vote candidate defined encryption number voter create encryption prove correctness detailed 
encryptions multiplied get encryption number form mod number votes cast candidate log relation holds integers decrypting writing ary notation directly produce 
remains describe produce encryption hiding number form prove correctly formed 
subsections 
note idea generalizes loss ciency simply allow voter cast votes form just described 
want prevent voters voting candidate times homomorphic property compute encryptions pairwise di erences votes voter prove non zero 
show non zero encryption voter provides encryption mod uses multiplication mod protocol prove product plaintexts 
case simplicity describe prove correctness vote case form treat general case 
bits binary representation clearly factor product power algorithm producing desired proof denotes prover 
computes encryptions computes encryption 


computes encryption set computes plaintexts corr 
satisfy mod multiplication mod protocol 
encryption desired encryption 
straightforward verity proofs computed encryption number form furthermore simply encryptions determining bit clear straightforward see vote system length log bits assuming course log 
parameter values numeric example vote size kbyte factor better previous system 
need decryption operation opposed 
case general nice form assumed may attempt adapt solution follows define smallest power run protocol changes 
drawbacks idea allows voters vote non existing candidates second implies log may get overflow votes added result incorrect 
prevent voters voting non existing candidates need log simple minded solution may force block length larger strictly necessary worst case twice large 
way get add extra step verification vote encryptions determining bits voter proves zero knowledge recall defined 
encryption provided shown encrypts define mod easy see mod mod modn mod encryption cs furthermore verifier compute value interaction public information 
going cs means complexity protocol follow independent point ways proceed sketch simple option represented bits exploit fact notice binary value 
public verifier compute encryption interaction 
clearly product precisely index confirming easy see providing encryptions values prover show encryptions contain correct values multiplication proofs 
prover needs show done trivial generalization oneof protocol showed earlier 
total solution complexity log bits assuming log 
asymptotically larger constant 
note lipmaa proposed conceptually simpler solution general cient constant factor 

algorithmic number theory volume cient algorithms 
foundations computing series 
mit press cambridge massachusetts london england 

blum blum shub simple secure unpredictable pseudo random number generator siam journal computing pp 
may 


pointcheval stern practical multi candidate election scheme proceedings podc 

cramer damgard nielsen multiparty computation threshold homomorphic encryption proceedings eurocrypt springer verlag lncs series pp 

cramer damgard schoenmakers proofs partial knowledge proceedings crypto springer verlag lncs series pp 


cramer damgard hirt rabin cient multiparty computations secure adaptive adversary proceedings eurocrypt springer verlag lncs series pp 


gennaro graham bit security paillier encryption scheme applications proceedings eurocrypt springer verlag lncs series pp 


cramer gennaro schoenmakers secure optimally cient multi authority election scheme proceedings eurocrypt springer verlag lncs series pp 


damgard jurik generalisation simplification applications paillier probabilistic public key system proceedings public key cryptography springer verlag lncs series pp 


damgard practical threshold rsa signatures trusted dealer proceedings eurocrypt springer verlag lncs series pp 


frankel mackenzie yung robust cient distributed rsa key generation proceedings stoc pp 



stern sharing decryption context voting lotteries proceedings financial crypto 

goldreich rosen security modular exponentiation application construction pseudorandom generators cryptology eprint archive record eprint iacr org december 

groth extracting witnesses proofs knowledge random oracle model manuscript december eprint archive report nr 



quisquater practical zero knowledge protocol fitted security microprocessor minimizing transmission memory proceedings eurocrypt springer verlag lncs series pp 


hirt sako cient receipt free voting homomorphic encryption proceedings eurocrypt springer verlag lncs series pp 


lipmaa asokan secure vickrey auctions threshold trust iacr eprint archive 

paillier public key cryptosystems composite degree residue classes proceedings eurocrypt springer verlag lncs series pp 


shoup practical threshold signatures proceedings eurocrypt springer verlag lncs series pp 


bar ilan beaver non cryptographic fault tolerant computing constant number rounds proceedings acm symposium principles distributed computation pp 

