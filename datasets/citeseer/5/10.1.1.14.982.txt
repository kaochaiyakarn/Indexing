interpretation standard ml type theory robert harper christopher stone june cmu cs school computer science carnegie mellon university pittsburgh pa report appears fox memorandum cmu cs fox research sponsored part advanced research projects agency title fox project advanced languages systems software arpa order 
issued esc ens contract 
part national science foundation 
ccr part army research ce 
daah 
views contained document authors interpreted representing cial policies expressed implied advanced research projects agency government national science foundation 
keywords standard ml type theory semantics programming language design compilation translation elaboration static semantics dynamic semantics de ne interpretation standard ml type theory 
interpretation takes form set elaboration rules reminiscent static semantics de nition standard ml 
particular elaboration rules relational style exploiting indeterminacy avoid commitment speci implementation techniques 
elaboration consists identi er scope resolution type checking type inference expansion derived forms pattern compilation overloading resolution equality compilation coercive aspects signature matching 
underlying type theory explicitly typed calculus product sum function recursive types module types derived translucent sum formalism harper lillibridge 
programs type theory type passing dynamic semantics compatible constructs polymorphic equality rely type analysis run time 
document previous cmu cs technical reports cmu cs cmu cs 
revision re ects experience implementing speci ed elaborator includes essential corrections simpli cations presentation 
contents overview 
notes implementation 
major di erences standard ml 
value restriction 
abstype 
local higher order functors 
top level 
major technical di erences version 
internal language 
datatypes 
generativity 
subtyping 
syntactic concatenation 
internal language syntax constructors kinds 
expressions 
modules signatures 
useful abbreviations notation 
bindings scope 
static semantics 
notation 
judgment forms 
inference rules 
formed declarations 
formed bindings 
formed kinds 
formed constructors 
constructor equivalence 
formed expressions 
formed signatures 
signature subtyping 
signature equivalence 
formed modules 

dynamic semantics 
transition relation 
search redex 
reduction 
external language notation 
grammar syntax 
syntactic restrictions 
elaboration 
notation 
initial basis 
derived forms 
judgment forms 
translation rules 
expressions 
matches 
declarations 
structure expressions 
structure bindings 
functor bindings 
speci cations 
signature expressions 
type expressions 
type de nitions 
type descriptions 
equality type descriptions 
datatype de nitions 
polymorphic instantiation 
equality compilation 
pattern compilation 
coercion compilation 
signature patching 
lookup rules 
context lookup 
signature lookup 
overloading 
properties properties internal language 
static semantics 
dynamic semantics 
soundness internal language 
properties elaborator 
acknowledgments overview document consists type theoretic account variant revised standard ml referred simply standard ml sml 
approach taken elaborate sml syntax external language explicitly typed calculus internal language il 
internal language designed simple orthogonal possible able represent entire standard ml language 
translation set inference rules reminiscent static semantics de nition standard ml internal language playing role static semantic objects de nition 
translation rules typically de ne translation phrase terms translation constituent phrases subject context sensitive constraints expressed internal language type system 
contextsensitive formation constraints expressed type checking constraints translation 
type propagation controlled translucent sum formalism representation types modules opaque type components 
internal language ensures abstraction respected provides requisite association type representation run time 
believe looking standard ml language features terms translate type theory clari es number issues design sml 
example notion type generativity replaced explicit control type propagation 
internal language may shared di erent language descriptions style 
particular envision possibility il minor modi cations scheme caml special light haskell 
long term goal see changes needed especially regards object oriented features order handle java modula 
elaboration application language implementation may viewed implementation front sml compiler 
particular translation guide re implementation til ml compiler hm mor tar tmc 
compilers languages de ned interpretation internal language share back til ml compiler front need written speci language 
disadvantages approach 
translation sml language features quite complex 
extent direct re ection intrinsic complexity mechanisms datatype de nitions introduce mutually recursive types sum product types polymorphic recursive function bindings 
ensuring invariants encodings respected document canbe tedious error prone 
furthermore understanding elaboration requires understanding internal language may mitigated internal language di erent external languages 
type theoretic interpretation standard ml divided main parts 
type structure internal language 
internal language explicitly typed calculus second class modules system 
core internal language xml ml calculi hm hmm 
constructors kind kind types include partial total function types record types sum types types recursive types single extensible sum 
additionally constructors extended restricted tuples constructors functions constructor level 
note polymorphic types system 
modules system translucent sum manifest type modules calculi hl ler 
addition translucent signatures total partial functor signatures 
subtyping relation signatures involves forgetting type de nitions totality dropping reordering components 
means subtyping run time ect 
levels connected ability tode local core expression 
dynamic semantics internal language 
dynamic semantics essentially contextual semantics wf 
handling exceptions similar harper account polymorphic har 
elaboration 
translation de ned series translation judgments general form el phrase il phrase il classi er internal language context extended information mapping el identi ers il variables 
notes implementation document experiment formally specifying rst stage til compiler additionally see generates plausible de nition language 
advocating compiler generate exactly il code internal language compiler exactly il 
implementation elaborator essentially equivalent suggest compiler internal language de nable terms il 
di erences expect actual implementation include internal language extended derived forms primitives possibly de nable forms 
compiler complicated pattern compiler generating cient pattern matching code particular making better case 
clausal function de nitions sequenced uses exception mechanism 
compiler cient implementation elaboration contexts avoiding sequential search formalized 
equality functions cached multiple equality tests values type generate multiple equality functions 
order achieve sml typing behavior locally de ned types module level hidden renaming internal language local bindings 
simplicity module level local de nitions including values translated fashion required cause wasted space run time 
implementation sophisticated criterion local bindings rename 
major di erences standard ml value restriction value restriction translation di erent speci ed sml 
treat derived form val pat expr pat expr val pat pat expr expr value treat binding val completely equivalent val hd val tl cases generalized hd tl may raise exceptions polymorphic case 
translation allows variables val binding generalized translations bindings valuable 
external language level equivalent tothe right hand side value variable argument constructor pattern constructor single constructor datatype 
note pose problem projection total function 
corresponds notion polymorphism substitution val id expr expr considered equivalent expr value 
di erence variables polymorphic sml speci cation generalized treatment 
abstype consider abstype declarations document data types easily created sml module system 
technical di culties including abstype desired 
local higher order functors external language permits structure functor declarations local declarations structure functor declarations re ection fact internal language local higher order modules 
higher order modules translucent sum formalism hl 
compatible rst class modules included de nition higher order functors propagate type sharing information system macqueen tofte mt 
finding clean type theoretic description system subject current research 
top level allow locally de ned modules external language su ces consider programs closed expressions type ans ans xed base type answers 
explicitly consider translation sml top level declarations 
note require implementation accept complete programs xed type 
example batch compiler may expect sequence structure functor signature bindings sml top level declarations possibly separately compiled logically treated sequence declarations wrapper generated compiler 
unix system example wrapper lines handle ans chosen type int program returns normal termination uncaught exception 
enable interpretation declarations simple macros de ning abbreviations signatures 
translation assumes abbreviations previously expanded program body 
major technical di erences version internal language minor changes internal language purposes cient implementation mutual recursion projection operations constructor expression levels purposes cleaner elaboration internal language generalization kind structure replacement partial destructuring operations total versions expression level 
datatypes rule datatypes simpli ed additionally internal language extended allow valid sml datatypes elaborate 
certain datatypes sml de nes admitting require polymorphic recursion implement equality function 
language currently admit polymorphic recursion correspond recursive functors datatypes admit equality formulation 
generativity technical problem presentation caused reject legal standard ml programs type information tracked properly 
problem involved types de ned anonymous structure expressions de ned locally local module level hidden sml transparent ascription sigexp 
corrected 
restricting el named form module level leroy ler 
achieved simple program 
grammar section shows mean named form 

case local module forms de ne types locally translation augment bodies forms extra hidden elds containing types 
conjunction restriction named form ect causing types concealed transparent ascription renamed dropped entirely 
internal language module system speci signatures general ensure modules generated elaborator speci signatures 
means elaborator requires guessing signatures modules functor applications 
subtyping dropped implicit subsumption total partial function types expression unique speci types equivalence 
unfortunately means datatype exception constructors handled specially function values 
full subtyping relation overkill features objects added internal language 
syntactic concatenation starred structure convention general concatenation modules syntactic concatenation structure eld bindings 
includes renaming prevent ill formed constructions elds share label 
simplicity rules essentially augment bodies local locally de ned quantities 
including value components transparent type components obviously unnecessary undesirable actual implementation 
internal language syntax constructors kinds con var type variables int float char base types record type con ref type con con partial function type con con total function type tagged extensible sum type con tag exception tag type lab con labn conn labelled sum type mod lab module projection var knd con constructor level nonrecursive function con constructor level xpoint con con constructor application con labn records constructors lab con record projection empty sequence lab con record eld type knd kind types knd labn knd ng knd knd constructor tuple kinds constructor function kinds constructors kinds syntax denotes phrase may optionally appear 
expressions exp constants var variables loc memory locations tag exception tags mutually recursive functions exp exp application record expression lab exp handle exp exp record projection handle exception raise con exp raise exception ref con exp allocate new ref cell get exp dereference set exp exp assignment roll con exp coerce type unroll exp coerce type exp coerce partial total function inj con lab exp injection sum proj con lab exp total projection sum case con exp exp exp sum case analysis new tag con extend type tagged tag exp exp injection type tagged exp exp exp exp exception tag case analysis mod lab module projection exp exp equalities base types empty sequence lab exp record eld binding empty sequence var var con con exp function binding labs lab labs lab sequence labels path var var labs path quali ed variable expressions modules signatures mod var module variable sbnds structure var sig mod functor mod mod functor application mod lab projection structure mod sig signature ascription sbnds structure eld bindings sbnds lab bnd bnd var con constructor binding var exp expression binding var mod module binding sig sdecs structure signature var sig sig partial functor signature var sig sig total functor signature sdecs structure eld declarations sdecs sdec sdec lab dec decs declaration lists decs dec dec var con expression variable declaration var sig module variable declaration var knd opaque type declaration var knd con transparent type declaration loc con typed locations tag con typed exception tag modules signatures useful abbreviations notation readability elide internal names var writing sbnds sdecs 
cases immediately obvious consistently restore fresh variables 
sig sig sig abbreviate var sig sig var sig sig respectively var free sig grammatical classes labs decs sdecs sbnds specify lists elements 
classes de ne binary append operation written comma 
example de ne decs decs decs decs dec decs decs dec analogous de nitions classes listed 
useful de ne general syntactic categories program phrases program phrase classi ers phrase exp class con mod sig con knd notation denotes capture free substitution phrase free occurrences var phrase abbreviate structure bindings lab var phrase lab phrase similarly signature bindings lab var class lab class local name 
cases obvious consistently insert fresh variables correct omissions 
occasionally abbreviation phrase shorthand phrase phrase phrases comma separated 
syntactic values language de ned 
view class syntactic values class subsets corresponding class syntax class 
expv path loc tag var sig mod path var expv var inj con lab exp var con tag expv expv roll con expv expv lab lab exp val expv con il values bindings scope de ne functions bv dom various bindings declarations lists thereof function de nition bv dec bv var con var bv var knd var bv var knd con var bv var sig var bv loc con loc bv tag con tag bv decs bv dec decn dec bv decn bv sdecs bv lab dec labn decn dec bv decn bv bnd bv var exp var bv var con var bv var mod var bv sbnds bv lab bnd labn bnd bnd bv bnd dom sdecs dom lab dec labn decn dom dom lab con labn conn scopes bound variables table binding phrase bound vars scope var var con exp var entire phrase var exp var knd con var con sbnds bv sbnds var sig mod var mod sdec sdecs bv sdec sdecs var sig sig var sig var sig sig var sig follow standard practice identify phrases di er respect bound variables locations exception names 
notation fv phrase denote set free variables phrase 
phrase said closed free variables may contain free locations tags 
static semantics section de ne formedness typing judgments internal language 
points interest include semantic objects sense de nition 
rules explicitly formulated judgment holds constituents declaration lists formed 
valuable expressions evaluate value side ects referencing store raising exceptions 
similarly valuable modules evaluate ects referencing store raising exceptions 
purpose distinguishing total partial functions total partial functors specify function functor applications valuable 
notation static semantics optional elements enclosed single brackets single rule optional elements occur 
judgment forms section judgment 
meaning 
decs ok decs formed decs dec ok dec formed decs bnd dec bnd declaration dec decs knd kind knd formed decs con knd con kind knd decs con con knd constructor equivalence kind knd decs exp con exp type con decs sdecs ok sdecs formed decs sig sig sig formed decs sdecs sdecs component wise subtyping decs sig sig sig signature subtyping decs sdecs sdecs component wise equivalence decs sig sig sig signature equivalence decs sbnds sdecs sbnds declaration list sdecs decs mod sig mod signature sig decs exp con exp valuable type con decs mod sig mod valuable signature sig decs exp decs sbnds decs mod inference rules formed declarations formed bindings ok decs dec ok decs dec ok decs knd kind var bv decs decs var knd ok decs con knd var bv decs decs var knd con ok decs con var bv decs decs var con ok decs sig sig var bv decs decs var sig ok decs con con ref loc bv decs decs loc con ok decs con con tag tag bv decs decs tag con ok decs con knd decs var con var knd decs con con knd decs var con var knd con decs exp con decs var exp var con decs mod sig decs sig sig sig decs var mod var sig decs ok decs dec ok decs bnd dec formed kinds formed constructors decs kind lab labn distinct decs knd labn knd ng kind decs knd kind decs knd kind decs knd knd kind decs ok decs decs var coni decs decs var knd decs tagged decs con decs con ref decs con decs con tag decs con decs con decs con con decs con decs con decs con con lab labn distinct decs con decs conn decs con labn hi ni lab labn distinct decs con decs conn decs ii lab con labn conn lab labn distinct decs con knd decs conn knd decs con lab knd lab knd ng decs knd kind decs con knd constructor equivalence decs con knd labn knd ng decs lab con knd decs var knd con knd decs var knd con knd knd decs con knd knd decs con knd decs con knd knd decs con knd decs con con knd decs mod sdecs lab var knd sdecs decs mod lab knd decs ok decs decs var knd con decs decs var con knd decs con con knd rule formedness judgment decs ok guarantees fv con bv decs 
decs mod sdecs lab knd con sdecs bv sdecs fv con decs lab con knd rule projection yield valid constructor respect ambient context decs 
arranged self rules rules 
decs con con decs con con decs con con con con decs con con decs con con decs con con con con decs con con decs con ref con ref decs con con decs con tag con tag lab labn distinct decs coni con decs con labn con labn con ng rule equivalent il record types equivalent components labels order 
decs con con knd labn knd ng decs lab con lab con knd decs con con labn knd labn knd ng decs lab con coni knd formed expressions decs con con knd knd decs con con knd hi ni decs con con decs conn con decs ii lab con labn conn ii lab con labn con decs con con knd knd decs con con knd decs con con con con knd decs var knd con knd decs con knd decs var knd con con knd decs con knd decs con con knd decs con con knd decs con con knd decs con con knd decs con con knd decs con con knd decs ok decs decs var con decs decs var con decs ok decs decs loc con decs decs loc con decs exp con decs ok decs decs tag con decs decs tag con decs exp con con decs exp con decs exp exp con decs exp con con decs exp con decs exp exp con decs var conj con var coni exp con rule apply 
decs var var coni con expi con con conn con ng var decs var con exp con decs var var con con exp con con lab labn distinct decs exp con decs expn conn decs exp labn con labn rule record bindings typed respect declarations labels order duplicate labels components typed elementwise 
decs exp lab con decs lab exp con decs exp con decs exp tagged con decs handle exp exp con decs exp tagged decs con decs raise con exp con decs con decs new tag con con tag decs exp con decs ref con exp con ref decs exp con ref decs get exp con decs exp con ref decs exp con decs set exp exp unit decs con lab con decs exp lab con con decs roll con exp con decs con lab con decs exp con decs unroll exp lab con con decs exp con con decs exp con con con lab lab con labn conn decs exp coni decs inj con lab exp con decs exp lab lab con labn conn decs proj lab lab con lab con lab exp coni con lab con labn conn decs exp con decs exp lab lab con labn conn con decs case con exp exp exp con decs exp con tag decs exp con decs tag exp exp tagged decs exp tagged decs exp con tag decs exp con con decs exp con decs exp exp exp exp con decs mod sdecs lab con sdecs bv sdecs fv con decs mod lab con rule projection formed result typable 
mod value projection formed 
decs exp con decs con con decs exp con formed signatures signature subtyping decs ok decs ok decs dec ok decs dec sdecs ok lab dom sdecs decs lab dec sdecs ok decs sdecs ok decs sdecs sig decs var sig sig sig decs var sig sig sig decs var sig sig sig decs var sig sig sig decs decs sdecs ok decs sig sig decs sdecs sdecs decs var knd con sdecs sdecs decs lab var knd con sdecs lab var knd sdecs decs sig sig sig decs var sig sdecs sdecs decs lab var sig sdecs lab var sig sdecs decs lab dec lab dec decs dec sdecs sdecs decs lab dec sdecs lab dec sdecs signature equivalence decs sdecs sdecs decs sdecs sdecs sig decs sig sig sig decs var sig sig sig sig decs var sig sig var sig sig sig decs sig sig sig decs var sig sig sig sig decs var sig sig var sig sig sig decs sig sig sig decs var sig sig sig sig decs var sig sig var sig sig sig decs decs sig sig sig decs sdecs sdecs decs var knd sdecs sdecs decs lab var knd sdecs lab var knd sdecs decs con con knd decs var knd con sdecs sdecs decs lab var knd con sdecs lab var knd con sdecs decs con con decs var con sdecs sdecs decs lab var con sdecs lab var con sdecs decs sig sig knd decs var sig sdecs sdecs decs lab var sig sdecs lab var sig sdecs decs sdecs sdecs decs sdecs sdecs sig decs sig sig sig decs var sig sig sig sig decs var sig sig var sig sig sig decs sig sig sig decs var sig sig sig sig decs var sig sig var sig sig sig decs sig sig sig formed modules decs decs bnd dec decs dec sbnds sdecs decs lab bnd sbnds lab dec sdecs decs ok decs decs var sig decs decs var sig decs sbnds sdecs decs sbnds sdecs decs sbnds sdecs decs mod sig decs var sig mod sig decs var sig mod var sig sig decs var sig mod sig decs var sig mod var sig sig decs mod sig sig decs mod sig decs mod mod sig rule functors non dependent types may applied 
dependencies eliminated uses subtyping equivalence rules 
argument dependencies eliminated 
decs mod sdecs lab sig sdecs bv sdecs fv sig decs mod lab sig rule projection formed result signature ambient context 
mod value occur 
decs mod sig decs mod sig sig rule ascription signature module types mod forgetting equations 
decs mod sdecs lab var knd sdecs decs sdecs lab var knd lab sdecs rule self rule 
mod labs speci es type mod de ned value mod labs mod labs add fact signature 
decs sdecs lab var sig sdecs decs lab sig decs mod sdecs lab var sig sdecs rule self rule recursively applied 
decs mod sig decs sig sig sig decs mod sig decs exp con decs exp decs exp con decs mod sig decs mod decs mod sig decs exp decs mod decs mod lab decs exp con con decs exp decs exp exp decs exp decs exp decs exp labn exp ng decs exp decs lab exp decs exp decs roll con exp decs exp decs unroll exp decs exp con decs mod sig decs exp decs exp decs inj con lab exp decs proj con lab exp decs exp decs exp decs tag exp exp decs exp decs exp decs exp decs case con exp exp exp decs decs exp con decs var con sbnds decs lab var exp sbnds decs con knd decs var knd con sbnds decs lab var con sbnds decs mod sig decs var sig sbnds decs lab var mod sbnds decs mod decs sbnds decs sbnds decs mod sig sig decs mod decs mod mod decs mod decs mod lab decs mod decs mod sig decs sbnds decs mod dynamic semantics dynamic semantics internal language call value operational semantics rewriting system states machine 
presentation strongly uenced plotkin plo wright felleisen wf signi cant departure framework employed de nition 
particular employ small step semantics transitions represent basic evaluation steps machine 
rely substitution environments values particular expressions language 
exception propagation handled explicitly maintaining evaluation context relying implicit rules exception propagation 
maintain store assignable cells de nition context types locations dynamically created tags associated tagged extra linguistic constructs formalism 
demonstrated part language introducing letref construct 
state machine tuple form phrase context decs locations tags created run time 
maintains record exception tags locations allocated soundness proofs 
nite mapping locations loc typed expression values exp 
syntax internal language values appeared 
stack evaluation frames see 
represents implementation control stack equivalently current continuation 
appending stacks corresponds composition continuations accordingly write concatenation de ned obvious way 
meta variable ranges control stacks contain frame form handle exp 
phrase expression module constructor 
range set terminal states state called terminal forms val normal termination raise con expv uncaught exception states called nonterminal 
dynamic semantics transition relation 
states 
usual denote re exive transitive closure 

exp expv lab lab handle exp raise con ref con get set exp set expv roll con unroll inj con proj con exp expn tag expv exp exp exp expv exp exp lab lab var sbnds mod sig transition relation search redex evaluation frames exp exp 
exp exp exp exp 
exp exp lab exp 
lab exp exp value lab expv 
lab expv lab lab exp expv 
lab exp lab exp exp value lab exp 
lab exp exp value handle exp exp 
handle exp exp raise con exp 
raise con exp exp value raise con expv 
raise con expv ref con exp 
ref con exp get exp 
get exp set exp exp 
set exp exp set exp exp 
set exp exp roll con exp 
roll con exp exp value roll con expv 
roll con expv unroll exp 
unroll exp exp 
exp exp exp 
exp inj con lab exp 
inj con lab exp exp avalue inj con lab expv 
inj con lab expv proj con lab exp 
proj con lab exp reduction tag exp exp 
tag exp exp exp exp value tag exp expv 
tag expv exp tag expv expv 
tag expv expv exp exp exp exp 
exp exp exp exp exp exp exp exp 
expv exp exp exp lab var phrase sbnds 
lab var sbnds phrase sbnds lab var lab var phrase sbnds val 
lab var val lab var fval fval sbnds lab var val 
sbnds lab var val mod lab 
lab mod mod mod 
mod mod mod mod 
mod mod mod sig 
sig mod exp expv 
var var var exp var var coni con exp lab lab expv 
expv handle exp expv 
expv ref con expv 
loc con loc expv loc loc bv get loc 
exp loc expv set loc expv 
loc expv fg con unroll roll expv 
expv new tag con 
tag con tag tag tag bv con exp lab 
expv exp expn inj lab con labn con expv exp 
tag tag expv exp exp tag 
exp exp tag tag exp exp exp tag 
exp tag tag var sig mod 
sig 
handle exp raise con expv 
exp expv raise con expv 
raise ans expv external language notation de nition optional elements enclosed single brackets double brackets hh ii 
purposes grammar optional choices completely independent 
grammar syntax disjoint base syntax classes include syntactic constants tyvar type variables id core level identi ers tycon type constructors structure identi ers functor identi ers 
de nition standard ml rst corresponding long forms containing nite sequence structure identi ers pre expr longid lab expr labn expr expr expr expr expr ty expr handle match raise expr fn match expr expr mrule pat expr match mrule mrule match val tyvar tyvar pat exp val tyvar tyvar rec pat exp open longid longid exception id exception id ty exception id longid local type datatype datatype tyvar tyvar tycon datatype tyvar tyvar structure functor tyvar tyvar tycon ty hand tyvar tyvar tycon hand id hof hh struct sigexp sigexp spec val id ty type datatype datatype tyvar tyvar tycon datatype tyvar tyvar exception id exception id ty structure sigexp functor sigexp sigexp include sigexp spec spec spec sharing type longid longid tyvar tyvar tycon hand tyvar tyvar tycon ty hand tyvar tyvar tycon hand sigexp sig spec sigexp type tyvar tyvar ty pat longid pat ty longid pat lab pat labn pat nh pat pat ref pat ty base tyvar lab ty labn ty ty ty ty ty hand sigexp hand syntactic restrictions record expression record pattern record type may contain duplicate eld labels 
tyvar may appear single sequence 
type variable occuring appear enclosing 
type variable appearing ty type appear type variable sequence 
val type datatype exception structure signature functor spec may bind identi er twice applies value constructors 
val rec declaration pattern form expression form lab id labn id lab fn match labn fn 
el notation may appear pattern 
elaboration addition type checking type reconstruction elaborator performs tasks 
datatypes expanded structures signatures components include type implemented recursive sum type operations corresponding datatype constructors values datatype constructors carry values total functions non value carrying constructors constants type expose operation presents datatype values elements tagged sum type 
generativity datatypes handled signature ascription type opaque inequivalent previous type 
matching datatypes signatures reduces matching substructures 

polymorphism including equality polymorphism encoded modules system 
polymorphic values translated functors explicitly instantiated structures types equality functions 
precisely functor takes structure containing type constructors kind types polymorphic value requires equality types structure contains equality functions instantiating types functor returns structure single component label polymorphic value monomorphic instantiating types 

equality polymorphism just mentioned handled explicitly constructing passing equality functions needed 
explicitly distinguish types admit equality atype admits equality equality compiler create equality function type 

explicit propagation types de ned locally module level local constructors hidden transparent signature ascription 
particular hiding ect constructs types implemented renaming simple scoping 
necessary obtain type propagation behavior stamp semantics de nition 

patterns expanded uses appropriate record projections datatype 
elaboration speci es pattern compiler 

series external language bindings elaborates structure containing component variable bound external language 
external language identi ers correspond internal language labels 

structure labels explicitly marked asterisk lab 
indicates structure open purposes identi er lookup 
see lookup rules details 

coercive aspects signature matching relation reordering forgetting components handled introducing explicit coercion functors witnessing relation 
order number components structure apparent signature run time cost signature ascription 
notation function maps el identi er il label 
assume function injective range coin nite set il labels identi ers di erent classes map di erent labels 
particular assume parser distinguishes classes expression variables type constructors type variables structure identi ers signature identi ers functor identi ers 
identi er expression variable datatype constructor exception constructor 
distinguished labels eq expose tag elaborator range mapping labels chosen fresh similarly range mapping 
extend mapping component wise long identi ers map sequences labels 
optional elements enclosed single double angle brackets 
rule elements single angle brackets similarly elements double angle brackets 
single double angle brackets rule represent independent choices 
cases optional element notation insu cient 
additional notation element element means element element 
multiple choices single rule means rst element chosen cases second element chosen cases 
extension notation gives choices subscripts 
choices subscript agree rst element second element choices di erent subscripts completely independent 
elaboration maintains elaboration context simply list structure declarations sdecs allow duplicate labels 
appears il judgment decs expected implicit coercion drops top level labels signature declarations 
extend notion variable bindings section function de nition bv bv sdec sdec bv dom dom sdec sdec dom binding phrase bound vars scope sdec bv sdec operation syntactic concatenation renaming sbnds parallel sdecs 
de ned sbnds sdecs sbnds sdecs lab bnd sbnds sbnds lab bnd sdecs sdecs lab bnd sbnds lab dec sdecs lab dom sbnds lab bnd sbnds lab dec sdecs lab dom sbnds sbnds sbnds sdecs sdecs sbnds sdecs initial basis elaborator assumes presence structure basis sig basis serving initial basis internal language 
contain elds de ne exceptions bind tag unit tag bind tagged match tag unit tag match tagged fail tag unit tag fail tagged derived forms translation number derived forms kinds constructors expressions 
shown 
representation tuples records numbered elds copied sml 
encoding multi argument functions single argument functions standard encoding booleans sum type 
purpose catch form serve special handler fail exception propagate exceptions 
fail exception elaborator signal failure pattern matching 
knd knd 
knd knd ng knd 
knd unit 
fg 
unit unit con conn 
con var var con 
var var var var var con conn 
con exp exp 
exp exp ng var con con exp 
var var con con exp var fv exp var con var conn con exp 
var con conn con var var var var var fv exp bnd bnd exp 
bnd bnd exp fail con 
raise con basis fail fail catch con exp exp 
handle exp var tagged var basis fail tag var unit exp raise con var fv exp var con con exp exp lab con 
case exp var con lab exp var con con lab proj var var con labn exp con lab con labn conn false 
inj bool true fg 
inj bool exp exp exp fg 
exp exp exp var bool exp var fv exp exp 
exp exp false var bool exp var var exp 
var var eq var var var eq var var fvar var fvar var var var con 
var var eq var var var eq var var fvar var fvar var derived forms judgment forms judgment 
meaning 
expr exp con expression match exp con pattern match sbnds sdecs declaration mod sig structure expression spec sdecs signature speci cation sigexp sig sig signature expression ty con type expression sbnds sdecs type de nition sbnds sdecs datatype de nition ctx labs path class lookup ctx labs path decs path sig sig labs labs class lookup signature sig sig lab labs decs nst sbnds sdecs polymorphic instantiation pat exp con exp sbnds sbnds pattern compilation decs con exp equality compilation decs sub path sig sig mod sig coercion compilation decs path sig sub sdec sdec sig wt labs con knd sig sig impose de nition sig sh labs labs knd sig sig impose sharing translation rules expressions type expr exp con rule assume meta level function type gives il type constant 
rule monomorphic variables 
ctx longid path con rule apply 
longid path con ctx longid path con con longid path con con rule monomorphic datatype exception constructors 
il subsumption coerced partial function type function values immediately applied 
ctx longid path sig con nst mod sig rule apply 
longid path mod con rule instantiation polymorphic variables 
polymorphic functions translated total functors body contains single component label 
module mod structure types equality functions needed instantiate polymorphic function 
ctx longid path sig con con nst mod sig longid path mod con con rule polymorphic datatype constructors 
rule partial function type 
permutation var var bv lab lab expr exp con expr expn conn lab expr labn expr var exp var expn var var var con lab con rule order labels appear record type signi cant il el translation normalize record values types sorting labels xed ordering 
order ects occur determined order expressions el 
sbnds sdecs var bv var sdecs expr exp con var sdecs con con con expr var mod exp con rule starred label convention locally de ned bindings accessible translating expr 
elaborator veri es translated expression type depend types datatypes de ned 
rule general application 
expr exp con con expr exp con con con expr expr exp exp con ctx longid path con con expr exp con longid expr exp exp con rule application monomorphic datatype constructor valuable expr valuable 
ctx longid path sig con con nst mod sig expr exp con longid expr path mod exp con rule application polymorphic datatype constructor valuable expr valuable 
expr exp con ty con con con expr ty exp con rule type constraints expressions veri ed appear translation 
expr exp con match exp tagged con con con var bv expr handle match handle exp var tagged con catch con exp var raise con var con rule handling expression exp var fail handler pattern match exception caught il handle inwhich case re raise exception 
expr exp tagged con raise expr raise con exp con rule raise expressions valid type 
preserve property il expression unique type equivalence annotate il raise type 
match exp con con var bv fn match var con con catch con exp var raise con basis match match con con rule application exp var fail match fails turn failure match exception 
resulting function partial type syntactically raise exception 
expr exp con expr exp con con con con exp expr expr exp exp exp bool rule translation equality comparison exp equality function generated equality compiler type con con bool 
matches match exp con var var bv con pat var con basis fail fail sbnds sdecs var sdecs expr exp con pat expr var con con var sbnds exp con con rule result translating match function may fail match fails 
il expression formed pattern compiler returns type components sbnds 
var bv mrule exp con con match exp con con con con con con exp var exp var con con mrule match var con con catch con rule failure pattern matching rst clause caught try clause 
declarations sbnds sdecs var bv expr exp con var con pat var con basis bind bind sbnds sdecs val pat expr var exp sbnds var con sdecs rule monomorphic non recursive variable bindings 
sig tyvar tyvar var eq var var var eq var var var eq var var var eq var var var sig expr exp con var sig exp con var sig basis bind bind exp con pat sdec exp coni var sig expi var sig expi expi coni sdec var sig coni var sig coni expi coni val tyvar pat expr sdec sdec rule polymorphic non recursive val bindings 
assume annotates val declarations explicit type variables implicitly scoped declaration 
type inference may introduce new type equality type variables mentioned source val fn val fn 
formulation variables pattern may polymorphic may remain monomorphic 
sdec choose rst option polymorphic choose second option monomorphic 
sig tyvar tyvar var eq var var var eq var var var eq var var var eq var var lab var sig id var con con id var conn con var coni con exp coni con ctx id path con path expose path tag aren formed 
exp var var con con exp var var con exp val tyvar id fn id var sig exp id var sig exp id sig con con id sig conn con rule rule handles recursive val bindings 
rule assume implicit scoping explicit type variables explicit el 
assume val rec syntactic sugar single val rec binding record functions 
rule pattern compiler explicitly check re rede ne datatype exception constructors 
sbnds sdecs sdecs sbnds sdecs sbnds sbnds sdecs sdecs rule syntactic concatenation renaming operation de ned section 
ctx sig open path path sig sig ty con var bv exception id ty id tag var new tag con id var con tagged tag var var id tag var con tag id con tagged exception id id tag var new tag unit id tag var fg id tag var unit tag id tagged ctx longid path lab con path tag con exception id longid id tag path tag id path lab id tag con id con rule structures containing tag component created el exception 
var bv sbnds sdecs var sdecs sbnds sdecs local var sbnds sbnds var sdecs sdecs rule create bindings declarations local bindings segregated substructure inaccessible el 
sbnds sdecs type sbnds sdecs ctx path tycon path tycon var lab dec labn decn labn expose datatype tyvar tyvar tycon datatype tyvar tyvar tycon tycon var path tycon lab path lab labn path labn tycon tycon var path tycon lab dec labn decn rule sml adds ability copy datatypes 
structures translations el datatype declarations initial type component nal component named expose 
structure expressions sbnds sdecs datatype sbnds sdecs sbnds sdecs structure sbnds sdecs sbnds sdecs functor sbnds sdecs ctx path sig path sig sbnds sdecs struct sbnds sdecs mod sig ctx var sig sig ctx path sig sub path sig sig mod sig var sig sig sig sig sig sig sig mod sig rule insert explicit coercion drop reorder components argument structure signature sig order match domain signature functor sig 
signature sig speci fully transparent signature coerced structure types sub signature sig 
ctx path sig sigexp sig sig sub path sig sig mod sig sigexp mod sig rule sml ascribing signature structure hides components hiding accomplished explicit coercion allows identity remaining type components leak 
rules coercions ensure sig fully transparent maximizing propagation type information 
ctx path sig sigexp sig sig sub path sig sig mod sig sigexp mod sig sig rule ascribing signature structure hides components restricts information types appears signature 
structure bindings var bv sbnds sdecs var sdecs mod sig var sbnds mod var sdecs sig sbnds sdecs mod sig mod sig ni hand ni mod mod ni sig sig ni functor bindings var bv sbnds sdecs sigexp sig sig var sig mod sig sigexp sig sig var sig mod sig ni sigexp hand sigexp ni var sig mod var sig sig var sig sig rule functions expression level user de ned functors partial functor types 
speci cations tv ty ty con val id ty id con spec sdecs rule avalue speci ation monomorphic el type contains type variables 
set type variables el type ty denoted tv ty 
tv ty tyvar ng sig tyvar tyvar var eq var var var eq var var lab var sig ty con val id ty id var sig con rule speci cation polymorphic value 
sdecs type sdecs sdecs sdecs ty con exception id ty id tag con tag id con tagged exception id id tag con tag id tagged sdecs datatype sdecs ctx path tycon path tycon sdecs datatype tyvar tyvar tycon datatype tyvar tyvar tycon tycon var path tycon sdecs sigexp sig sig structure sigexp sig sigexp sig sig var bv var sig sigexp sig sig functor sigexp sigexp var sig sig sigexp sdecs sig include sigexp sdecs spec sdecs sdecs spec sdecs sdecs sdecs ok spec spec sdecs sdecs rule disallow el identi ers signature 
presence include syntactically restrict el guarantee syntactic concatenation sdecs sdecs formed 
spec sig sig var bv var sig sig longid labs knd var sig sig longid labs knd var sig var labs var labs knd var sig var labs var labs knd sig sh labs labs knd sig sig sig sh labs labs knd sig sig spec sharing type longid longid sig sig rule atype component signature considered eligible appear sharing constraint equivalent type component abbreviation spec 
nd opaque types components equivalent patch signature opaque type smaller scope type abbreviation opaque type 
signature expressions spec sig sig sig spec sig sig sigexp sig sig var var var bv sigexp sig sig tyvar var tyvar var ty con var sig sig labs var sig var labs var labs sig wt labs var var con sig sig sigexp type tyvar tyvar ty sig sig rule note type el type expression ty evaluated ambient scope 
type expressions int int ty con rule analogous rules base types float bool unit string base type constructors ref 
exn tagged ctx tyvar path tyvar path ty con ty conn permutation lab lab lab ty labn ty con lab con ctx path ty coni ty ty path con conn ty con ty con ty ty con con rule way express total 
types external language 
type de nitions sbnds sdecs var var bv tyvar var tyvar var ty con con var var con sbnds sdecs var fv sdecs tyvar tyvar tycon ty hand tycon var tycon var type descriptions sdecs type tyvar tyvar id id var var bv tyvar var tyvar var ty con con var var con sdecs var type tyvar tyvar id ty hh id equality type descriptions sdecs polymorphic equality functions de ned judgment default structural equality supplied sml 
essentially atype equality type judgment equality function type 
sig tyvar tyvar var eq var var bool tyvar tyvar var eq var var bool con var var tyvar tyvar var tyvar tyvar tyvar tyvar id hand id id var eq var sig con con bool datatype de nitions sbnds sdecs loss generality may assume duplicate tyvar bindings 
tycon var dt var dt np tyvar var tyvar pnp var pnp var var bv unit ty ij ij id coni id im con var dt dt var var var jnj coni con var var ini var var coni var mod tycon var dt con var ini id ij var var ini var var ini exp eq ii exp eq ii roll con con inj sum id ij fg var coni roll con con inj sum expose var var ini var coni unroll var sig sig tycon var var dt var var var var coni id ij var var ini mi coni expose var var ini coni id ij var ij mi mod tycon var dt con var dt con tycon mod tycon mod sig tycon var dt var dt np tycon sig tycon sig tyvar tyvar tycon id ty id ty tyvar tyvar tycon pnp id ty id pmp ty pmp mod sig sig pmp polymorphic instantiation decs con con nst sdecs ii decs nst sdecs decs nst lab lab var eq hh lab lab var eq var var hh rule nondeterministically choose types corresponding equality functions match fully transparent signature 
equality compilation decs int var int var int bool var int var decs con exp rule assume primitive equality operations exist type int similar rules base types 
con con labn decs con exp decs conn expn decs con var con var con bool exp lab var lab var exp labn var labn var rule records compared component wise equality 
con conn decs coni exp exp var con exp proj con lab var con lab var decs con var con var con bool catch case con var exp false rule values sum type equal tag tagged values equal 
coni con con con con con con decs decs var var con eq var var bool var var conn eq var var bool decs unroll con expi exp eq eq fvar var eq fvar var unroll var unroll var decs var eq var coni coni bool exp eq eq rule recursive type generates recursively de ned equality functions 
decs path eq path lab path lab bool decs path lab path eq rule constructor simply path name type look equality function type structure 
con path lab con conn decs nst mod sig decs path eq sig con con bool decs con path eq rule rule deal application type tuple types 
instantiation judgment may recursively invoke equality compiler order create equality functions con con decs con con decs con exp decs con exp decs sig mod sig var var sig var eq var var var eq var var decs var sig con exp decs var sig con var sig exp pattern compilation patterns pat exp con exp sbnds sdecs judgment read bindings result matching exp pattern pat sbnds 
rules apply 
exp con id exp con exp id exp id con rule pattern match variable datatype exception constructor 
lab fresh type con exp con exp con exp lab exp fg raise unit exp lab unit rule pattern match constant 
need primitive equality functions constants appear patterns 
lab fresh exp con exp con exp lab exp lab con rule pattern match wildcard 
ty con con con pat exp con exp sbnds sdecs pat ty exp con exp sbnds sdecs rule pattern match explicitly typed pattern 
ctx longid path coni con path expose con 
lab con labn conn pat lab con labn con lab longid pat exp con exp sbnds sdecs path expose exp exp coni exp sbnds sdecs rule pattern match monomorphic datatype constructor carries value 
ctx longid path con lab fresh exp con path expose con 
lab con labn conn longid exp con exp lab lab con labn con path expose exp exp lab unit rule pattern match constant monomorphic datatype constructor 
ctx longid path sig path expose sig con 
lab con labn conn nst mod sig path expose mod exp exp coni exp pat lab con labn con lab sbnds sdecs longid pat exp con exp sbnds sdecs rule pattern match polymorphic datatype constructor carrying value 
ctx longid path sig exp con path expose sig con 
lab con labn conn nst mod sig lab fresh longid exp con exp lab lab con labn con path expose mod lab exp exp lab unit rule pattern match constant polymorphic constructor 
ctx longid path lab con tagged path tag con tag pat exp path tag var con var raise con sbnds sdecs longid pat exp con exp sbnds sdecs rule pattern match value carrying exception constructor 
exp exp ctx longid path lab tagged lab fresh exp con path tag unit tag longid exp con exp lab exp path tag var unit fg raise unit exp lab unit rule pattern match constant exception constructor 
con con lab con kg lab ng lab var con pat exp coni exp lab pat labn pat nh exp con exp sbnds sbnds sdecs rule pattern match record patterns 
disallow repeated variables patterns syntactic concatenation structure formed 
pat exp con exp sbnds sdecs pat exp con exp sbnds sdecs pat pat exp con exp sbnds sbnds sdecs sdecs rule pattern match patterns simultaneously 
pat get exp con exp sbnds sdecs ref pat exp con ref exp sbnds sdecs rule pattern match involving implicit dereferencing ref cell 
pat exp con exp sbnds sdecs con con pat exp con exp sbnds sdecs coercion compilation decs path sig sub sdec sdec decs var sig sig lab labs con decs path sig sub lab var con lab var var labs lab var con rule coercion monomorphic value speci cation monomorphic value speci cation 
decs var sig sig lab labs con con decs path sig sub lab var con con lab var var labs lab var con con decs var sig var sig sig lab labs sig con decs var sig var sig nst mod sig decs path sig sub lab var var sig con lab var var sig var labs mod lab var var sig con rule coercion polymorphic value speci cation polymorphic value speci cation may involve implicit polymorphic instantiation 
rule handles matching phic datatype constructors val speci cations 
note sig sig need labels rule handles alpha conversion el type variables 
decs var sig var sig sig lab labs sig con con decs var sig var sig nst mod sig decs path sig sub lab var var sig con con lab var var sig var labs mod lab var var sig con con decs var sig sig lab labs var sig con decs nst mod sig decs path sig sub lab var con lab var var labs mod lab var con rule coercion polymorphic value datatype constructor match monomorphic value speci cation 
decs var sig sig lab labs var sig con con decs nst mod sig decs path sig sub lab var con con lab var var labs mod lab var con con decs var sig sig lab labs knd var sig var labs con decs path sig sub lab var coni lab var var labs lab var knd var labs rule coercion type component speci cation 
decs var sig sig lab labs var sig var labs con decs var sig var labs exp decs path sig sub lab lab var coni eq var var bool lab lab var var labs eq exp lab lab var var labs eq var var bool coercion type declaration corresponding signature speci cation involving type variables 
invoke equality compiler create equality function type copied 
decs var sig sig lab labs con var var lab lab var lab labn decs var sig var sig con exp decs path sig sub lab lab var eq var sig con con bool lab lab var var labs eq var sig exp lab lab var var eq var sig con con bool coercion type declaration correspond signature speci cation involving type variables foo 
decs var sig sig lab labs sig decs var sig sub path labs sig sig mod sig decs path sig sub lab var sig lab var mod lab var sig rule coercion module component 
decs sub path sig decs path sig sub lab dec sdec decs dec path sig sub lab dec sdec decs dec decn path sig sub labn decn decs sub path sig lab dec labn decn sdec decs sub var sig sig mod sig sig mod sig decs var sig sub var sig decs var sig mod sig decs sub path var sig sig var sig sig var sig var path mod mod var sig sig sig mod sig rule coercions functor subtyping 
need rule subtyping total functors shown 
signature patching type sig wt labs con knd sig sig judgment read adding signature sig fact type component selected labs equal con knd get signature sig fv con bv sdecs sig sdecs lab var knd sdecs sig wt lab con knd sdecs lab var knd con sdecs sig fv con bv sdecs sig sdecs lab var sig sdecs sig wt labs con knd sig sig sig wt lab labs con knd sdecs lab var sig sdecs sig sharing sig sh labs labs knd sig sig judgment read adding signature sig fact type components kind knd selected labs labs equal get signature sig sig sdecs lab var knd sdecs lab var knd sdecs sig sh lab lab knd sdecs lab var knd sdecs lab var knd var sdecs sig sig sdecs lab var knd sdecs lab var sig sdecs sig wt labs var knd sig sig sig sh lab labs lab knd sdecs lab var knd sdecs lab var sig sdecs sig sig sdecs lab var sig sdecs lab var sig sdecs sig wt labs var labs knd sig sig sig sh lab labs lab labs knd sdecs lab var sig sdecs lab var sig sdecs sig sig sdecs lab var sig sdecs sig sh labs labs knd sig sig sig sh lab labs lab labs knd sdecs lab var sig sdecs sig lookup rules lookup rules specify order translation contexts il signatures searched 
prevent explosion rules metavariable class denote type signature kind appropriate 
il structure label starred asterisk lab treated specially lookup checks inside structure 
looking identi er context look inside starred structure declarations 
identi er inside structure full path identi er open structure returned 
type signature returned lookup valid respect ambient context 
context lookup main rules looking identi ers translation context 
ctx labs path path con ctx labs path con ctx labs path path knd ctx labs path knd ctx labs path path sig ctx labs path sig utility rules look identi ers translation context 
lab lab lab var con ctx lab var lab lab ctx lab path lab var con ctx lab path lab lab lab var coni ctx lab var lab lab ctx lab path lab var coni ctx lab path ctx labs path class ctx labs path signature lookup lab lab lab var sig ctx lab var lab lab ctx lab path lab var sig ctx lab path sig sig lab path lab var sig ctx lab var path sig sig lab ctx lab path lab var sig ctx lab path ctx lab path sig path sig sig labs labs class ctx lab labs path labs main rules looking identi ers signature 
decs path sig sig labs labs class decs sig sig sig sig lab labs decs path labs con decs path sig sig lab labs con decs sig sig sig sig lab labs decs path labs sig decs path sig sig lab labs sig decs sig sig sig sig lab labs decs path labs knd decs path sig sig lab labs knd decs sig sig decs path sig sig lab labs sig decs path labs sig sig labs labs class decs path sig sig lab labs labs labs class utility rules look identi ers signature 
lab lab sdecs lab var con sig lab lab lab lab sdecs sig lab labs sdecs lab var con sig lab labs sig sig lab labs overloading lab lab sdecs lab var coni sig lab lab lab lab sdecs sig lab labs sdecs lab var coni sig lab labs lab lab sdecs lab var sig sig lab lab lab lab sdecs sig lab labs sdecs lab var sig sig lab labs sig sig lab labs sdecs lab var sig sig lab lab labs sig sig lab sdecs sig lab labs sdecs lab var sig sig lab labs overloaded identi er wish add el add translation rule overloaded type 
example may want overload el identi er addition types int real 
case add rules lines int int int int float float float float int float il primitive addition functions 
properties proofs sketches standard ml language far large check case hand reasonable amount time 
may involve attempting check proofs automated system 
properties internal language static semantics lemma formedness propositions hold 
decs dec ok decs ok 
decs bnd dec decs dec ok 
decs knd kind decs ok 
decs con knd decs knd kind 

decs con con knd decs con knd decs con knd 

decs exp con decs con 
decs sdecs ok decs ok 
decs sig sig decs ok 
decs sdecs sdecs decs sdecs ok decs sdecs ok 
decs sig sig sig decs sig sig decs sig sig 

decs sdecs sdecs decs sdecs ok decs sdecs ok 
decs sig sig sig decs sig sig decs sig sig 

decs sbnds sdecs decs sdecs ok 
decs mod sig decs sig sig 

decs exp con decs exp con 
addition decs exp con decs exp con 
decs mod sig decs mod sig 
addition decs mod sig decs mod sig lemma states internal language judgments preserved substitution values free variables typing judgment value de ned syntactically phrase evaluated form 
proposition substitution 
decs var class decs con con knd decs val class decs fval fval fval knd 
decs var class decs sig sig sig decs val class decs fval fval fval sig 

decs var class decs sig sig sig decs val class decs fval fval fval sig 

decs var class decs exp con decs val class decs fval fval fval 

decs var class decs mod sig decs val class decs fval fval fval 

decs var class decs con knd decs val sig decs fval fval knd 

decs var class decs exp con decs val class decs fval fval fval 

decs var class decs mod sig decs val class decs fval fval fval 
proof sketch induction derivation rst premises due space constraints show sample cases case derivation ends typing rule decs var class decs exp con con decs var class decs exp con decs var class decs exp exp con decs val class 
inductive hypotheses decs fval fval fval fval decs fval fval fval typing rule conclude decs fval varg exp exp con case derivation ends typing rule decs var class decs mod lab dec lab var knd con sdecs decs var class decs dec con con knd decs var class decs con knd decs var class decs mod lab con knd decs val class 
properties ofthe induction hypothesis typing rule decs fval fval lab fval knd claim decidability internal language judgments considered elaborator decidable 
proof sketch internal language module expressions generated elaborator speci signatures decidability static semantics reduced straightforward fashion decidability constructor equivalence 
constructor equivalence judgments rules describe familiar simply typed lambda calculus records constants 
allowing simple abbreviations context rule seen preserve decidability 
roughly speaking rst inline abbreviations test equivalence previous case 
obvious extend proof include rule simple fashion 
lillibridge lil gives complex argument decidability constructor equivalence related system records constructors 
conjecture analogous argument apply system 
dynamic semantics de ne states equivalent written phrase phrase states equal componentwise consistent renaming locations exception tags appearing normal renaming bound variables 
clearly equivalence relation states preserves property terminal state 
lemma determinacy evaluation properties hold 
terminal terminal 


exists state 






context phrase single hole written 
write phrase result lling hole phrase possibly incurring variable capture 
stack frames determines context obvious way context context 
proposition decomposition replacement 
decs exp con exp closed decs exp con type con furthermore decs exp con exp closed decs exp con 

decs mod con mod closed decs mod sig signature sig 
furthermore decs mod sig mod closed decs mod con 

decs con con con closed decs con knd kind knd 
furthermore decs con knd con closed decs con con 
proof sketch induction proposition trivial phrase phrase 
assume due space constraints show just typical case 
case exp 
exp exp exp 
inductive hypothesis decs exp exp con con inspection typing rules shows derivation contain application rule rule show case similar 
inversion decs exp con con decs exp con type con 
furthermore decs exp con con decs exp exp con inductive hypothesis decs exp exp con decs exp con 
soundness internal language harper har say store formed respect context written loc bv loc con ref con formulation store typing avoids need complex maximal xed point constructions tof 
essentially similar observation wf 
fix base type ans answers complete closed program evaluate 
say machine state formed written phrase phrase ans phrase closed important property internal language semantics formedness state preserved evaluation 
proposition preservation phrase phrase 
phrase 
phrase proof sketch transition search rule preservation follows trivially phrase phrase 
need consider reduction rules 
show sample case 
reasonable choice string unit model updating store particular choice ect results 
case transition rule lab lab expv 
expv lab lab expv lab lab expv 
formedness assumption decomposition decs lab lab expv con type con judgement proven typing rules inversion decs expv con expv closed formedness assumption decs expv ans replacement formedness preserved 
furthermore evaluation typed program get stuck formed state terminal applicable transition formed state 
proof relies shapes closed values type 
lemma canonical forms 
assume exp con expv closed 
con form expv form con con con con con labn expv labn ii lab con labn conn inj lab con labn con con con exp lab roll con con expv tagged tag tag expv con ref loc base type 
assume mod sig closed 
sig form mod form sdecs sbnds var sig sig var sig mod var sig sig var sig mod proof inspection applicable typing rules values 
example consider case expv con con record type 
numerous rules allow expression record type application record projection rule record expressions applies case closed value 
possible form expv 
cases analogous 
proposition progress terminal exists state 
proof sketch cases 
terminal 

phrase phrase avalue 
inspection possible phrase syntax applicable rule dynamic semantics reduction rule new tag con search rules 

val 
subcase possible frame show case case get 
formedness decomposition get val con type con inversion rule val con ref 
canonical forms val location formedness val bv 
transition rule applies 
properties elaborator minimal requirement elaborator elaboration el code yields wellformed il code proposition formed translation assume ok propositions hold 
expr exp con exp con 

match exp con exp con 

sbnds sdecs sbnds sdecs 

mod sig mod sig 

sbnds sdecs sbnds sdecs 

sbnds sdecs sbnds sdecs 

spec sdecs sdecs ok 
sigexp sig sig sig sig 

ty con con 
sbnds sdecs sbnds sdecs 

sbnds sdecs sbnds sdecs 

sbnds sdecs sbnds sdecs 

sbnds sdecs sbnds sdecs 

decs nst mod sig decs mod sig 
furthermore mod syntactic value sig speci signature mod 

decs con exp decs exp con con bool 
furthermore exp syntactic value 
decs var var con mod decs mod var var con con bool 

pat exp con sbnds sdecs exp tagged exp con sbnds sdecs 

decs path sig sub sdec sdec decs path sig decs sdec ok decs sdec 
decs sub path sig sig mod sig decs path sig decs sig sig sig decs mod sig decs sig sig sig 

ctx labs path class path class 
furthermore path class ctx labs path class 

path sig sig labs labs class path labs class 
furthermore path labs class path sig sig labs labs class 
sig wt labs con knd sig sig sig sig con knd sig sig 

sig sh labs labs knd sig sig sig sig sig sig 
proof follows induction derivation rst premises 
claim de ned language need elaboration function sense possible elaborations el program yield equivalent il programs 
argue coherence plausible attempted formal proof 
claim coherence terminal state basis basis sig basis expr exp ans basis basis sig basis expr exp ans basis mod basis exp 
basis mod basis exp 
proof sketch enumerate instances non determinism elaborator argue cause incoherence 

elaborator may guess types bound variables fn expressions instantiating polymorphism 
types dead code may fn fn nitely choices type identity fn dynamic semantics su ciently choices types ect course evaluation 

similarly elaborator may regarding resolve overloading 
simplest argument overloaded operator corresponds single operator dynamic semantics evaluation depend resolved type 
sophisticated argument able show complete program choice resolve overloading operator applied 

elaborator decide valuable expressions monomorphic polymorphic case type variables generalize 
turns expressions functor abstractions general causes incoherence changing order evaluation expression wrapped functor evaluated functor applied 
generalize valuable expressions ects choices ect observable behavior 

nondeterminism creation equality functions may di erent de nitions equality type 
maintain invariant equality functions perform structural equality underlying values regardless abstraction 
candidate de nitions behavior incoherence arise 
acknowledgments perry cheng martin elsman particularly helpful comments 
har robert harper 
simpli ed account polymorphic 
technical report cmu cs school computer science carnegie mellon university 
hl robert harper mark lillibridge 
atype theoretic approach higher order modules sharing 
st symposium principles programming languages pages 
hm robert harper john mitchell 
type structure standard ml 
acm transactions programming languages systems 
hm robert harper greg morrisett 
compiling polymorphism intensional type analysis 
nd symposium principles programming languages pages 
hmm robert harper john mitchell eugenio moggi 
higher order modules phase distinction 
th symposium principles programming languages pages 
ler xavier leroy 
manifest types modules separate compilation 
st symposium principles programming languages pages 
ler xavier leroy 
syntactic theory type generativity sharing 
journal functional programming 
lil mark lillibridge 
translucent sums foundation higher order module systems 
phd thesis school computer science carnegie mellon university 
available cmu technical report cmu cs 
mor greg morrisett 
compiling types 
phd thesis school computer science carnegie mellon university 
available cmu technical report cmu cs 
mt david macqueen mads tofte 
semantics higher order functors 
european symposium programming pages 
springer verlag lncs april 
mth robin milner mads tofte robert harper 
de nition standard ml 
mit press 
robin milner mads tofte robert harper dave macqueen 
de nition standard ml revised 
mit press 
plo gordon plotkin 
structural approach operational semantics 
technical report daimi fn aarhus university september 
tar david tarditi 
design implementation code optimizations type directed compiler standard ml 
phd thesis school computer science carnegie mellon university 
tmc david tarditi greg morrisett perry cheng chris stone robert harper peter lee 
til type directed optimizing compiler ml 
proceedings acm sigplan conference programming language design implementation pages 
tof mads tofte 
type inference polymorphic 
information computation november 
wf andrew wright matthias felleisen 
syntactic approach soundness 
technical report tr department computer science rice university 

