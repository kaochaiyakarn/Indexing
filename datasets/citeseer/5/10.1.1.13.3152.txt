logic property verification haskell programs richard kieburtz ogi school science engineering oregon health science university beaverton oregon usa version august proof supported logical verification program properties topic research interest years 
feasibility proof construction verification technique demonstrated examples application remains technique rarely practice variety reasons technical sociological 
lack verification logics modern programming languages remains strong deterrent proof supported verification 
introduces logic verification logic haskell 
logic modal mu calculus supports direct expression recursively defined properties complex data structures 
term language logic haskell 
logical assertions expressed logic interleaved definitions haskell program text incorporate term variables bound program context 
properties finite infinite data structures expressed 
describes syntax proof rules semantics logic provides examples 
project www cse ogi edu projects default htm exploring variety means validation haskell programs including comprehensive verification logic haskell 
particular requirement verification logic provide direct expression properties programs 
term language logic programming language simplified modeling language 
logic provide syntax express properties structured data codata naturally directly 
programming language supports recursive definitions verification logic rules reasoning properties consequent definitions 
particularly haskell syntax type system discriminate values latent computations verification logic support discriminations 
desired properties verification logic generic order higher order predicate logics 
describes logic verification logic haskell 
logic modal mu calculus supports direct expression recursively defined properties complex data structures 
modal logic intended domain interpretations simply sets family sets particular structure 
modalities logic dictate interpretations sets structure specific haskell datatypes 
logic allows concise precise exact assertions kinds properties possible logics familiar 
logic accommodates haskell lazy evaluation semantics predicates specifically require haskell expression defined satisfaction predicate 
logic intended reasoning programs independently determined typed satisfy constraints static semantics correctness 
intended programs compile correctly 
allows soundness criteria logic stated relative standard model haskell universe pointed model semantics haskell types 
rules logic omitted 
omitted rules capture constructs haskell allow programs written concisely inessential 
include strict data constructors deferred match patterns syntax guarded patterns mutually recursive definitions 
rules algebras predefined primitive types predefined operators io monad 
structure follows 
section gives informal structure logic modalities haskell terms embedded logic 
section defines concrete syntax logic gives typing rules provides examples 
section inference rules 
section gives rules applicable recursive definitions haskell recursively defined properties 
semantics logic notion soundness discussed section 
initial experiments logic prove properties small interesting haskell functions reported section 
concludes section discussion related preliminary research 
logic non strict programming language lazy evaluation semantics haskell term necessarily denote value term need normalized value demanded 
logic expressing properties haskell terms interpreted values interpretation accommodate latent computations 
possible answers proposition values term exhibit property true false 
answer appropriate interpreted computation reached normal form 
haskell lazy evaluation rules terms abound 
atomic propositional forms logic assert term equality term property expressed unary predicate generally ary predicate expresses property terms 
symbol expresses unary property assertion analogy symbol expresses typing assertion haskell 
informally intend assertion true context evaluating haskell operational semantics results normal form manifestly satisfies property evaluation necessarily demanded program context assertion occurs 
haskell non strict evaluation semantics notions satisfaction unary predicate sensible 
say predicate weakly satisfied expression denotation belongs set defined interpretation strongly satisfied addition denotation proper value bottom element type domain 
logic strength associated assertion determined primarily syntactic context occurs 
weak assertion context explicitly strengthened prefixing symbol predicate formula 
constrains interpretation strengthened predicate false computationally undefined expression 
principal ways compound predicate formulas formed logic 
connectives underlying propositional logic lifted connectives predicates 
example conjunction connective lifted predicate connective definition def 
constructors datatypes declared haskell program text implicitly lifted act predicate constructors logic 
example context program list constructor combines expression type expression type list new expression type list context formula constructor combines predicate predicate new predicate formula 
formula satisfied haskell expression normalizes term form component expressions weakly satisfy assertions default mode interpretation component predicates weak semantics data constructor allow undefined values arguments 
arrow predicate constructor compose formulas express properties expressions 
formula satisfied function function applied argument satisfies resulting application satisfies greatest fixpoint constructor may bind predicate variable prefix appended predicate formula 
fixpoint constructors binders mu calculus written lfp gfp formulas logic 
modality haskell terms taken connectives predicate constructors fixpoint binders allow detailed properties haskell expressions formulated logic 
example predicate asserting expression type list denotes finite list defined property finite list lfp 
univ univ universal predicate satisfied term 
body formula finite list asserts disjunction constructor formulas 
lifting data constructor satisfied expression denoting nil list 
second lifting list constructor satisfied term denoting constructed list head satisfies universal property undefined tail defined satisfies finite list property 
characterize lists listed element satisfies common declare property elts def predicate parameter declaration 
property elts defined greatest fixpoint binding includes finite infinite lists 
property definition differs finite list important details binding operator formula gfp lfp predicate variable representing recursive assertion predicate tail list 
detailed properties term structures model values haskell datatypes directly expressible modalities logic 
difficult importance achieving degree expressiveness verification logic 
syntax logic syntax logic defined carefully property declarations assertions intended embedded text haskell program logic uses haskell term language 
important syntax provides visual distinction property assertion expression function application 
distinction help avoid semantic confusion part reader 
declarations properties assertions certain contexts haskell program equational declarations expected 
declarations appear top level module embedded expression keyword keywords 
property declarations assertions allowed exactly contexts property annotated program 
property declaration keyword property assertion keyword assert provide visual distinction haskell expressions allow parser recognize formulas distinct expressions 
text segment keywords certain symbols special roles different customary roles operator symbols haskell 
ordinary haskell program text symbols revert customary roles 
change role lexical symbols necessary haskell language design assigned role name space virtually printable ascii character short sequence characters leaving little room creation new lexemes occur prescribed context 
identifiers reserved symbols syntax logic reserves small number identifiers formulas effect stealing identifiers name spaces operators variables data constructors 
property assert reserved keywords 
symbols reserved assertion forming operators data constructor operator symbols haskell program 
identifiers exist reserved quantifiers assertions data constructors haskell program 
identifiers univ undef reserved predicate constants data constructors haskell program 
operator symbols identifiers lfp gfp special uses syntax formulas 
reserved operators haskell expressions data declarations 
name spaces predicate constructors propositions named property assert declarations respectively 
name space occupied predicate proposition names predicate variables coincides name space data constructors haskell 
identifiers name space initial letter capitalized 
name space resolved syntactically annotated program fragment provides sufficient context constructor name denotes predicate constructor occurs property assertion declaration set comprehension formula denotes data constructor expression context 
haskell expression complicated individual variable constant enclosed curly braces argument predicate application 
predicates predicate constructors predicate logic unary predicate formula characterizes set haskell terms specifying properties semantic interpretation formulas declarations assert identifier assertion declaration names assertion assertion identifier proposition constant identifier proposition variable term pred asserts property term equal term term asserts equality terms identifier term asserts property terms conj assertion conjunction propositions disj assertion disjunction propositions neg assertion negation proposition quant assertion assertion quantification prefix identifier type universally quantified term variable exists identifier type existentially quantified term variable pred decl pred pat pred predicate declaration pred pat pred abs identifier identifier identifier predicate pattern pred identifier predicate constant arrow pred pred formula function property identifier term pred predicate instance lfp pred identifier pred predicate formula gfp pred identifier pred predicate formula pred ref identifier named predicate constructor pred var identifier predicate variable lifted section term lifted section pred section pred nat term predicate section pred ary strong pred strengthened predicate comprehension identifier type pred set comprehension formula pred type typed predicate rules axioms rule rule sequent sequent axiom sequent sequent entails assertion assumption assertion assumption variable term term haskell term possibly containing variables term lifted section property haskell section 
word identifier capitalized accidental 
distinguishes meta variables syntax range formulas terms respectively 
syntax formulas nt produces ast assertion assert ident proposition ident proposition proposition proposition quant quantifier ident type quantifier ident type quantifier exist exist neg disj conj univ prop const univ undef prop const undef expr expr equal expr expr expr formula expr formula ident expr ident expr 
property decl property prop pat formula prop pat formula prop pat ident pred abs ident ident ident ident pred abs ident ident ident formula arrow formula formula formula cons formula formula lfp ident formula lfp pred ident formula gfp ident formula gfp pred ident formula ident formula ident formula predicate constructor applications may ident pred ref ident nil lifted section single token parenthesized expr ident expr pred section ident expr ident expr pred section ident expr strong formula syntactic category stands translation phrase represents syntax tree 
concrete syntax formulas binary equality predicate variable denoting place predicate 
basic forms unary predicate formulas predicate constants univ undef set comprehensions patterned predicates lifted section expressions section expression range type bool designated lifted prefix example 
symbol preempted prefix operator formulas 
conflict reserved symbol datatype declarations operator symbol haskell expression 
lifted section expression restricted respect scope identifiers may appear 
identifiers scope haskell language specified definition logical variables 
logical variable variable symbol bound quantifier prefix introduced set comprehension formula 
multi place predicates multi place predicate defined set comprehension term variable bound 
special syntax provided multi place predicates equality predicate 
note multi place predicate thing predicate constructor explicitly abstracted term variables 
constructor abstracted term variables may instantiated applying haskell term composed constants predefined operators logical variables 
multi place ary predicate specifies relation unconstrained terms values may range respective types 
predicate sections sectioning infix binary predicate bind second argument resulting unary predicate 
example equality predicate term obtain unary predicate equality symmetric 
just lifted section predicates term argument predicate section restricted contain constants predefined operators logical variables 
compound predicate formulas compound predicates formed greatest fixed point operations predicates lifted propositional connectives applying predicate constructor arguments suitable kind type 
forms predicate constructors 
unary predicate strengthening operator mandates strong interpretation formula argument strengthened formula embedded weak position 

data constructor haskell datatype lifted predicate constructor 
lifted data constructor arity constructs pattern predicate occurs predicate formula 
data constructor typed occur predicate expression assumes predicate type pred pred pred 
construct predicate ary constructor applied unary predicate formulas 
constructor appearing predicate formula requires syntactic annotation distinguish data constructor context occurrence resolves potential ambiguity 
contextual interpretations exist haskell allow constructors occur patterns expressions 
take advantage contextual resolution allow predicate patterns formed data constructors 

identifier may explicitly defined predicate constructor predicate declaration keyword property 
written equation left hand side simple applicative pattern right hand side predicate formula 
formula right hand side abstracted respect variables bound applicative pattern 
notice argument unary predicate abstracted variable left hand side pattern right hand side type prop type assertion type predicate type terms pred 
note symbol right associative infix operator applications predicate constructors arguments haskell expression syntax 
property assertions property assertion consists propositional formula prefixed quantifier clauses bind logical term variables formula 
variables introduced set comprehension logical variables implicitly quantified types 
basic propositional formula 
unary predicate formula applied haskell expression 
expressions related infix equality predicate 
application predicate formula typed pred term arguments types respectively 
predicate naming binary predicate may enclosing 
assertions keyword assert may appear top level program text ii interleaved sequence definitions expression clause iii body set comprehension expression 
assertions top level may optionally named 
unary property assertion relates term type predicate formula complementary type pred 
assertion stands evaluation rules reduce eliminate 
assert term property characterized predicate write predicate specifies set values assertion read member set 
application predicate term different syntax function application different semantics 
function application application predicate constructor abstracted arguments reduction semantics 
semantics described operationally substitution argument expressions body function 
operational description property satisfaction 
predicated assertion may shown logically equivalent assertions deduction inference rules logic assertion reduced 
type indexed predicates predicate formulas propositions logic strongly typed expressions haskell 
haskell type system extended additional kinds kind type prop pred pred distinguish types haskell expressions type type propositions assertions prop prop types predicate formulas pred pred type types match clauses types predicates match clauses pred pred 
predicate formulas logic may indexed types mirror haskell types 
type indexing necessary resolve instances overloading lifted operators occur formulas instance lifted section expressions 
needed express rules characterize properties standard algebras various arithmetic algebras operations implemented haskell 
type index formula specifies type terms may satisfy formula 
ascii text predicate type appears haskell type expression bracketed pred pred integer 
explicit typing predicates required type inferred 
type index associated assertion equality pair haskell expressions common type expressions 
types context judgment forms type indexed predicate formula judged typed relative typing environment represents program context formula occurs 
typing environment extends typing environment un annotated haskell program augmenting type bindings program variables typings predicate variables scope 
judgment form logic sequent prop typing environment binding term variables types predicate variables predicate types logical environment binds terms predicates 
judgment form type consistent type bindings typing environment logical environment type proposition asserted right hand side structure 
type consistent judgements logical interpretation judgment considered false 
notion type consistency summarized typing rules 
type consistent judgments interpreted shall erase typing environment explicit typings term variables predicate formulas judgment forms expression rules logic 
typing annotations retained rules specific type 
reader keep mind typing logic type annotations omitted reduce notational clutter 
typing rules predicate formulas shall express rules typing formulas terms sequents stands typing environment stands typing consequence relation 
typing rules 
class qualifications instance types haskell supports operator overloading class mechanism 
class declaration gives signatures operators defined type instance class 
operator declared class signature said overloaded assume type corresponding instance class 
resolution overloading haskell program possible static type inference 
dynamic resolution provided dictionary passing mechanism supported haskell implementation 
property verification relies type indexed predicates resolve overloading dynamic dictionary passing mechanism runtime 
typing context operator occurrence property assertion determined type indexed predicate 
typing context compatible types statically inferred haskell program may refine 
declaration type ranges instances class may accompanied set assertions asserting properties may differ 
example operator type num haskell standard prelude associated property assertions assoc pred integer integer integer assoc pred int int int 
property need asserted instances class num 
operator occurs assertion typing context occurrence determine properties associated operator belong logical context particular occurrence 
formula containing operator symbols overloaded allows generic properties derived instances overloaded operator asserted 
generic properties may associated derived operator defined prelude library module 
generic properties derived operator assumed verification context operator scope 
course assertion bind program specified instances operator symbol 
predefined classes contain declarations infix operators may embedded predicates 
typical typing rule section predicate 
typing determine predicate associated derived instance operator program defined instance 
examples module examples import list section type ord pred assert map map map assert universal predicate may indexed type 
universal type type univ pred typing rules list constructor congruences 
nil list type type pred cons list type pred pred pred typing rules datatype constructor congruences 
congruence type typing rule arrow typed predicates 
arrow type typing rule set comprehensions 
comprehension type pred pk pred pk pred pred pred pred 
xk prop 
xk pred typing rules formulas logical connectives 
negation type conjunction type disjunction type implication type strengthened type lfp type gfp type pred pred pred pred pred pred pred pred pred pred pred pred pred typing rules typed propositions 
pred formula type equality type ary formula type pred pred lfp pred pred pred gfp pred pred prop prop pred tk tk prop typing rules formulas 
property specified set abstraction property assoc op op op op op pred int int int assert assoc ordering predicate constructor declared explicit abstraction property wo bool property wo lfp true property wo int wo subtract pred int assert factorial wo int wo int comprehension defining binary predicate uses lifted section predicates property gfp int xs int xs true xs assert int 
xs int 
insert xs rules logic logic formulated classical sequent calculus rules apply particular term construction typically duals 
form rule introduces term construction right consequence symbol dual form introduces construct assumption left 
left sequent fulfills similar role elimination rule construct natural deduction style calculus 
shall omit structural rules sequents conventional focus rules specific logic 
rules logic partitioned sets structural rules support inference new sequent formulas existing ones preserving validity independently structure particular assertions content rules support inference sequents valid respect standard interpretation terms modal operators predicate constructors 
structural rules trivial sequent axiom logic 
structural rules specify relations assumptions sequent left symmetry left conj left disj left negate left strengthen tk tk strengthen assumptions right symmetry right conj right disj right negate right weaken tk tk weaken propositional connectives lifted predicate connectives propositional connectives defined unary predicate connectives equivalences 
negation lifted connective predicates arity 
notice particular negation strongly assertion weak vice versa 
equality lift conj def lift disj def lift negate tk def tk lift negate tk def tk assume reflexivity symmetry equality predicate 
addition axiom states equality transfers properties 
content rules pair construction projections univ univ haskell explicit pair projection operators fst snd 
right rules operators 
note hypothesis rules assert strong pair construction lifted semantics haskell 
univ fst abstraction univ snd predicate satisfied function typed term application argument property gives result property rule asserts arrow property haskell term formed explicit abstraction apply rule abstraction body strict abstracted variable necessary furnish explicitly strengthened predicate order discharge proof obligation antecedent 
case consequent property strict abstraction 
rule sound assertion arrow property left sequent notice assumption consequent clause weakened rule unsound case substituted strengthened predicate 
application left rule application constructor application variable fv place data constructor defined datatype declaration data 
right rule schema saturated application constructor tk pk 
tk 
pk data constructor implicitly lifted serve predicate constructor 
predicate formula 
pk satisfied defined term form 
tk tj weakly satisfies corresponding predicate pj 
term congruence enriches formula language 
corresponding left rule schema ti pi ti tk univ pi univ rule assumption contains explicitly constructed term generalized account pattern matching constructs 
restricted form rule applies constructor declared strict arguments data 
tj pj tk pk 
tj 
tk 
pj 
pk conditional expressions right rules conditional expressions true false univ left rules true false univ pattern matching haskell allows patterns abstractions local definitions case instances 
attempt match pattern term match succeeds binds subterms local variables occurring pattern fails 
match clauses associated predicates distinct kind 
match clause expression body haskell type may satisfy predicate kind pred 
predicates formed unary predicate constructor just nullary constructor 
coercions kind rules relate property kind pred property kind pred 
just univ rules allow property application patterned abstraction propagated context expects property kind pred 
context pattern match application shown fail resulting property univ provides specific information 
pattern predicates patterns nested terms formed variables wildcard pattern symbol saturated applications data constructors pattern arguments 
occurrence variable pattern deemed binding occurrence variable repeated occurrence pattern 
patterns may nested arbitrary depths inconvenient syntax patterns directly rules 
define syntactically flattened representation patterns allow simpler representation pattern predicates rules 
need concept fringe pattern variables defining occurrences pattern listed left right 
definition fringe pattern list distinct variables defined inductively follows frg variable frg frg pn frg frg pn define function produces pattern predicate pattern environment binds predicates variables fringe pattern 
definition pattern predicate formed instantiating pattern relative predicate environment defined inductively follows 
function yields predicate paired truth value proposition predicate strengthened 
xi xi xi variable proposition xi strong predicate univ false pk 
pk map 
pk true pk true univ false false map false map ps ps map ps ps notation designate flattened pattern predicate constructor 
formally pn def fst zip frg 
pn true length frg pattern satisfies typing judgment 
xn 
xn frg pattern predicate derived satisfies typing judgment pred 
xn pred pred domain pattern informally domain pattern set terms match pattern 
criterion patternmatching haskell complicated somewhat called irrefutable patterns normally stricter patterns 
term required match irrefutable pattern prefixed symbol evaluation body match clause containing pattern strict variable bound pattern 
match failure occur match irrefutable demanded match failure unrecoverable 
domain pattern defined set terms match pattern independently body match clause strict variable bound pattern 
definition characterizes domain pattern 
definition domain pattern predicate defined applying predicate pattern constructor derived list univ predicates 
dom def univ univ notice dom univ explicitly strengthened predicate 
formula dom asserts term fails match undefined 
strengthened predicate dom effect partial definedness predicate 
term satisfies dom defined subterm necessary evaluate match pattern patterned lambda abstraction patterned lambda abstraction pair properties exhibits applications argument successfully matched characterizes behavior pattern matching argument fails xn pn matches matches pn just 
xn frg matches dom term designated matches rules sequence guarded expressions 
unguarded expression equivalent expression guard true definition haskell 
right rules properties guarded expressions 
xn pn false 
xn pn 
xn pn true 
xn pn 
xn pn just 
xn pn false 
xn pn matches 
xn pn matches 
xn pn true 
xn pn 
xn pn matches just fatbar connective set alternative patterned applications tried argument term connective type designates sequential composition 
right rules fatbar compositions alt alts alt alts kind pred alt just alt alts just case expressions term keyword case expression list matches 
simple syntactic transformation prefixes pattern case match converts patterned abstraction erasing inverts transformation 
denote list case matches obtained connected list patterned abstractions eliding prefixed rules express equivalence case expression application composite patterned abstraction 
right rules just case case univ transformation produces syntactically formed abstraction case alternative guards clause 
non recursive expressions just frg fv recursive definitions haskell definition tm justifies adding propositions context sequent scope definition tm tm univ univ proposition tm asserts weak equality provided definition implication asserts sense definition 
logic provides framework formulate proof rules recursively defined haskell terms 
basic rule singly recursive definition compatible fixed point semantics haskell definitions 
tm tm antecedent rule able conclude body tm definition strongly exhibits property assumption undefined property consequence recursive definition tm strong property 
rule embodies fixed point scott induction fundamental mode reasoning fixed points pointed rule adequate proof construction 
inadequate haskell definitions may mutually recursive property asserted defined greatest fixed point construction 
consider possibilities separately properly considered 
mutually recursive definitions rule easily extended rule schema accommodates multiple mutually recursive definitions 

mn tn set definitions haskell program 
rule schema allows properties definition concluded 

mn hn ti 
mn tn mj hj fixed point properties recursive function definition typically properties wishes express terms arise recursive definitions haskell characterized fixed point greatest fixed point predicates mu calculus 
predicate variable bound prefix fixed point formula lfp gfp scope entire formula formula admissible fixed point iteration contains positive occurrences free predicate variable bound fixed point iterator 
positive occurrence defined section logic identifiers lfp gfp substitutes greek letters mathematical treatments mu calculus 
fixed point properties prove property recursively defined function function definition may partitioned base cases induction cases 
simplicity shall limit number cases just characterized separation predicates respectively 
intended separation predicates partition argument domain subset function definition yields result recursive invocation second subset definition invoke recursion return result 
rule property proven univ tm tm tm lfp fv predicate variable may occur occur fv 
antecedent clause provides base case induction 
assertion univ context antecedent ensures depend specific property assumed term variable antecedent clause asserts term tm applied argument restricted property application proved satisfy predicate formula assuming property function hold recursive application 
second antecedent clause provides induction step 
inductive assumption asserts property application tm argument restricted property 
term variable may occur tm predicate variable may occur consequent rule asserts property recursively defined function definition tm added context 
constraint necessary ensure soundness rule 
completeness usually want additional condition strong fixed point properties rule assure fixed point property range recursively defined function strong interpretation rule prove termination property function 
termination issue domain predicate admits infinite domain 
case may fixed point definition strong predicate providing basis induction 
discover appropriate formula domain predicate helpful analyze structure function typed term property proved 
function definition linear recursive exactly occurrence function name body 
assume definition linear recursive function type written explicit predicate function bool control evaluations recursive non recursive subexpressions function body see transfer function mapping argument function body argument recursive call body 
define composition property function definition def separation predicates linear recursion form specified true predicate variable fixed 
assumptions total functions predicate characterizing domain convergence 

example suppose subtract 

subtract set inductively specified 
greatest fixed point properties prove property stated term congruences fact haskell data constructors uniquely invertible 
constructor pattern provides implicitly deconstruction functions project component subterms constructed term matching pattern 
semantics pattern matching haskell relies isomorphism constructed term components 
term congruences logic 
prove property rule sound tm tm gfp predicate variable may occur occur fv 
antecedent asserts tm strongly satisfies term variable satisfies property predicate consequent defined formula base case required 
monads monad class haskell specifies operator signature containing return 
reasoning programs results typed monad class assumption instance class operators satisfy equations left id 
return right id 
return assoc 
call conjunction set properties monad eqs reasoning expressions typed monad account implicitly properties operational context affects operations monad properties associated pure expressions 
property accounting represented lifting type constructor monad type constructor monadic predicates 
offer comprehensive explanation means expression typed monad satisfy monadic predicate 
meanings stating rules non proper operators particular monads 
context judgment may include component asserts properties operational context computation 
shall designate component proposition subscripting rules follow 
rules monadic computations rules express properties computations formed standard monadic operators monad unit monad bind monad eqs return monad eqs case monadic computation distributed pair list 
express monad enriched distribution operator 
haskell chooses left right distribution defined dist dist return rule monad distribution monad dist dist monadic predicates hide details structure underlying monadic computation 
reason interesting computations monad formulate laws algebra non proper operators particular monad 
monads commonly haskell programmers state environment monads io monad 
laws state monad example give laws basic operations state transformer monad st specified launchbury peyton jones pl 
monad defined haskell standard prelude operators newvar st mutvar readvar mutvar st writevar mutvar st type indexing state monad may think mutvar type cells state contain values type laws specific st monad overwrite newvar newvar writevar newvar read newvar readvar newvar readvar readvar idempotent readvar readvar readvar readvar destructive writevar writevar writevar writevar writevar readvar writevar readvar writevar return expect additional laws hold particular newvar readvar return readvar writevar return return st defined lazy state newvar formulas hold laws 
laws augment set monad laws monad eqs established instance monad class 
note laws means complete axiomatization st monad 
pairing introduced allowing copied side effects normally associated mutable state variables observed computations monad 
side effects sensitive order evaluation components pair difficult predict haskell program 
laws sound account side effects 
laws environment monad environment monad env equipped operators newvar readvar 
satisfy laws read newvar idempotent readvar st monad 
environment monad distributive meaning distribution operator dist env env env env isomorphism 
side effects observable monad symmetric distribution 
foundations section specify meaning logic 
interpretation maps propositional formulas logic propositions refer specific model truth proposition judged 
interpretation parts model term language model predicate formulas logic 
haskell expression stands denotation poset domain 
haskell strongly typed meaning expression type terms domain specific type 
accordingly shall assume semantics function gives meanings type derivations term paired type 
term type env meaning function maps formed haskell expression type denotation domain models type env var type semantics interpretation logic say exactly formulas logic mean formulas interpreted characteristic predicates sets posets domain haskell semantics 
formula interpreted haskell type type scheme shall admit type variables 
notation distinguish formulas terms meanings lifted set interpretations terms type set interpretations terms type excluding interpretation constant symbol type universal predicates predicate constants univ undef represent universal predicate unsatisfiable predicate type 
interpretations predicates univ undef univ undef constant sections predicates predicate asserts equality constant satisfied denotation specified constant 
inequality predicates defined numeric types ord class 
ord order inequality algebra 
term congruence predicates term congruence predicates formed constructors datatypes lifted act predicates 
declaration datatype datatype constructor produces finite set signatures contains arity constructors datatype paired tuple argument types 

pk tk 
tk pk note interpretation non strict datatype constructor 
arrow predicates arrow predicate characterizes property function typed term 
read proposition assertion applied argument property application property 
call subformula left arrow domain predicate right range predicate 
argument non strict function required satisfy weak interpretation domain predicate 
characterize strict functions domain predicate explicitly strengthened 
predicates predicate types pred kind distinguish codomain types match clauses function typed expressions 
modeled tagged semantic values 
just predicate conjunction disjunction strong interpretations conjunction disjunction exclusion bottom value distributes subformulas 
equality binary equality predicate defined terms equality underlying semantics domain type 
strong interpretation equality requires terms denote equal non bottom elements domain 
fixed point formulas interpretations greatest fixed point formulas terms infinite unions intersections interpretations finitely iterated syntactic substitutions matrix place recursion variable zeroth iteration specified definition undef interpretation formula univ interpretation formula 
interpretations dual 


example tail strict lists undef univ consider formula 
unique nullary constructor datatype declared data sequence iterated formulas interpretation begins undef undef undef 
predicate substituted predicate variable iteration strengthened context predicate variable strengthened definition 
consider example interpretation second formula sequence undef undef undef undef sequence starts singleton set containing adds set containing set containing lists unit length 
contains element tail list bottom element consequence strengthened predicate undef tail position constructor congruence 

limit sequence set finite lists 
omit tail strictness specification formula 
unfolded sequence iterated substitutions begins undef undef undef 
interpretation 
sequence interpretations richer tail strict formula component sets include approximations extensions lists 
sequence previous element st set approximated domain ordering non bottom element th set approximates element nd set 
limit sequence set containing tail strict finite lists elements contains partially evaluated approximations including approximations infinite lists 
approximating elements terminate nil list infinite lists type appear limit 
means say term satisfies predicate atomic unary predicate logic predicate constants univ undef formed lifted section expression nullary data constructor implicitly lifted status predicate 
compound predicates composed logical connectives arrow predicate constructor ary data constructors greatest fixed point bindings 
shall say predicates form satisfied respect context 
properties assumed context sequent clause constrain possible environments give meanings term variables 
specify assertion interpreted respect environment assigns meanings term variables 
definition expr type env pointed domain haskell meanings 
meaning function haskell providing meanings expressions specified types 
defined 
definition prop env true false 
interprets propositions respect environments 
pred tk 
tk pred definition say environment refines context written map true list assertions list homomorphism conjunction 
environment supports written map true definition abused notation haskell function map designate functor set category finitely iterated products set 
definition term weakly satisfies predicate pred context represented 
term strongly satisfies predicate pred context represented 
equality terms satisfy equality predicate pred respect context 
true 
strengthened equality satisfied respect ii 
type indexed orderings total ordering defined instances ord class 
inequality operator lifted binary predicate logic 
terms belonging base type ord class satisfy predicate pred context iff 
inequality operator domain 
inequality predicate weakly satisfied strongly satisfied terms compared denote 
universal predicates predicate univ pred satisfied term type 
strongly satisfied term respect context 
predicate undef pred satisfied term respect context 
haskell term satisfies undef type 
term strongly satisfies undef 
nullary constructors predicates satisfaction criteria nullary constructor predicate pred 
strong satisfaction criteria disallow alternative term denote environment refines 
constructor congruence predicates constructor congruence predicate application lifted ary constructor predicate formulas 
satisfaction criterion congruence predicate formed non strict constructor pk pred 

vk 
vk vi pi strong satisfaction similar imposes additional condition 
weak satisfaction congruence predicate built strict constructor defined pk pred 

vk 
vk vi pi arguments constructed term satisfy strong interpretations respective predicates 
recursive predicates predicate context predicate formula embedded occurrences arbitrary predicate predicate context parity positive negative embedded predicate variable nested odd number negation symbols counting zero number 
inductive definition linear predicate contexts definition positive negative linear predicate contexts respectively specified 
pk pk 
pn 
pk pk 
pn ary constructor symbol 
symmetry connectives assumed 
fixed point predicate formula limit disjunctive sequence predicate contexts undef undef undef undef positive linear predicate context 
intuition leads formal definition satisfaction formula 
nat 
undef dually satisfaction formula defined 
nat 
univ definition type conformity implicit 
predicate typing annotations omitted brevity 
soundness sequent valid interpretation iff 
standard interpretation outlined section indexed environment validity sequent expressed logical implication 
sequent rule antecedents consequent sound respect interpretation context antecedents valid consequent valid 
theorem logic sound respect standard interpretation outlined section 
proof logical axioms valid rules sound 
proofs rules machine checked 
full soundness proof 
experiments logic conducted experiments logic state properties expected small haskell functions 
proofs properties constructed hand rules logic augmented ad hoc rules express properties needed integer arithmetic ordering integer values 
proofs checked coding proof rules strategies employed proofs stratego vis vis vis 
interesting examples briefly described 
example length list defining equations haskell functions length length length xs length xs ys ys xs ys xs ys proof context assumptions contained clauses ys finite list length def length xs def length xs ys def ys xs ys def bx xs ys predicate finite list defined sec 

assumed monoid rules ad hoc assumption algebra integer arithmetic 
assertion proved xs finite list ys finite list length xs ys length xs length ys proof assertion employed specific induction rule equality terms list datatypes 
specialized rule shown preceding sections 
rule univ xs finite list xs xs xs xs xs finite list ws xs xs substituting context expression length length ys context expression length ys antecedents inductive list equality rule proved properties assumed 
encoded stratego support proof comprises strategy declarations addition rules logic 
strategies largely manipulate terms definitions haskell syntax apply rules logic terms form expected rules 
term manipulations implemented strategies include tupling multiple arguments function unfolding refolding definitions implementing substitutions free variables term 
example property insertion list integer values 
haskell function non duplicating ordered insertion integer list defined recursively follows insert int int int insert insert ys ys ys insert ys insert ys sequent wish prove insert int 
xs int 
xs elts univ insert xs unary predicate elts defined section binary predicate defined section 
list insertion restricted finite 
intuitively insertion property hold insertions infinite list integers 
assertion proven logic proof somewhat longer proof assertion example coinductive proof rules establish property 
proof insertion property duplicated stratego directed appropriate programmed strategies rules logic 
related simon thompson early effort give verification logic tho tho miranda lazy functional language predecessor haskell exposed difficulties inherent adapting order predicate calculus verification logic 
logic miranda employs quantification operators bind variables range defined terms finite structures datatype 
meanings quantifiers extra logical defined logic 
verification tool clean pla lazy functional programming language 
tactical theorem prover order logic specialized verifying properties functional programs 
expressions term language core clean embedded propositions including logical variables bound universal existential quantifiers 
logic notation express undefined value provide modalities 
temporal logics pnu lam programs developed provide formalism express properties programmed processes 
linear temporal logic ltl supports property assertions quantified temporal traces process trace mean sequence states entered process trajectory progression time measured discrete steps 
branching temporal logic ctl ce ec properties quantified possible forward state trajectories process specifically allowing choice points alternate continuations trajectory possible 
interest observe ties formal definitions ltl ctl notion time perceive physical universe 
ltl modal logic modal predicates interpreted sets semi unbounded sequences unstructured sets elements 
ctl modal logic predicates interpreted finitely branching unbounded node labeled trees 
logics applied universe sequences trees furnishes appropriate model 
modal mu calculus koz modal operators ltl ctl defined recursively greatest fixed point operators express quantifications respect depth sequence term conjunction modal operators quantify possible paths term 
formulating logic interested models constructed unbounded terms specific syntax 
stratego language learned data constructor congruences initial algebra property freely constructed datatype lift strategies rewriting arguments particular construction homomorphic strategy rewriting construction 
logic constructor congruences form homomorphic predicates satisfied constructed terms predicates characterize subterms 
different kind modality logic characterize normalization terms differentiating strong weak satisfaction criteria 
modality inspired valued propositional logic ws logic owe conservatively extends classical propositional logic notable exception trivial sequent sound modality analogous weak strong modality logic introduced larsen lar discriminate may transitions process algebra 
observed conventional process models specify may nondeterministic transitions safety properties stated model 
introducing required transitions possible assert liveness properties 
huth jagadeesan schmidt generalized larsen analysis provided semantic interpretation modality general framework 
semantic interpretation predicate pair power domain elements downward closed upward dense 
interpretations modeling may properties respectively 
general characterization predicate interpretations applies weak strong notions predicate satisfaction logic 
initial presentation logic comprehensive integrated verification logic programming language haskell 
logic intended tightly integrated haskell assertions logic embedded program text roughly points declarations explicit typing assertions allowed 
terms properties asserted logic exactly haskell expressions variables scope point assertion embedded 
formulas unary binary general ary 
equality distinguished binary predicate form 
formula language logic modal mu calculus modalities modalities haskell terms 
modality partial definedness property hold term denotes undefined value semantics domain 
modality strong definedness property holds defined values 
modalities appropriate properties asserted non strict strict contexts respectively 
notice swap rule classical sequent logic disjunctive propositions consequent fail saturate possible valuations valued ws logic 
data constructors declared haskell program introduce additional modalities 
data constructors lifted predicate constructors logic congruence implicit isomorphism constructed term tuple subterms constructed 
lifted data constructor applied tuple unary predicate formulas propagates assertion formulas subterms data value constructed constructor 
greatest fixed point binding operators mu calculus rich set predicate constructors affords logic ability define modalities specific data structures haskell 
logic supports definition type specific modal operators haskell datatype 
logic designed support reasoning observable properties programs preference semantic equivalence 
direct way assert function equal function may partial functions 
assert equivalent defined common domain characterized 
property observable principle domain enumerable 
type indexed predicates logic provide means reason properties expressions contain overloaded operators 
logic type indexed predicates coherent semantics gives meanings type derivations fully type annotated expressions 
logic distinction compile time run time isn necessary specify mechanism dynamic type resolution overloaded expressions 
necessary semantics haskell specify mechanism required conforming operational semantics 
proof rules establish fixed point properties function rely separation predicates characterize domains application function invoke recursion 
separation predicate characterizing domain recursion guessed supplied oracle support proof 
analogous invariant property required proof rules iteration constructs floyd hoare logic imperative programming language 
show soundness logic proved soundness proof rules relative standard semantics haskell 
semantics described manually derived haskell language definition numerous papers specific aspects semantics 
prototyped haskell language interpreter checked systematically consistency hugs interpreter mature implementation haskell 
attempt axiomatize properties operators predefined haskell datatypes defined standard prelude 
includes arithmetic operators operators lists io operations operators defined haskell functions rely operations supported directly hardware platforms operating system 
operations particular haskell 
approach taken defining logic properties operations supported insofar possible efficient model decision procedures may invoked proof search proof checking engine logic 
basis experience solution 
remains done support property verification logic robust readily usable technology 
tools constructed developing content specific software base 
important tool building tasks build extended haskell front parser type checker capable recognizing formulas logic translating terms syntax 
formula declarations property assertions embedded haskell program text parsing type checking formulas assertions integrated front haskell translator provide uniform translation 
complete encoding rules proof strategies stratego adding specialized verification rules logic needed 
envision reaching increasingly automated proof discovery system achieved accumulation useful proof strategies triggered patterns intermediate verification conditions recognized course developing proof 
programmed strategies specify rules may tried discharge proof obligations order alternative rules strategies tried 
new strategies suggested patterns proofs discovered pencil proof attempts machine aided interactive proof construction 
strategy formalized programmed tried automatically programmed control 
adapt interactive proof editor logic 
interactive proof editor analogous interactive programming environment 
support browsing data base known proof rules strategies guided knowledge type form assertion verification focus point 
excellent model provided alfa hal proof editor constructive type theory 
alfa uses syntax formulas type theoretic structure narrow range plausible selections known terms proof step 
principles successfully employed alfa may applicable design proof editor logic 
acknowledgments colleagues pacific software research center helped inform improve research comments 
author particularly grateful bill harrison jim hook criticism encouragement 
assistance provided bellegarde carrying experiments programmed proof construction invaluable 
magnus carlsson provided valuable observations properties st env monads haskell 
deficiencies remain presentation sole responsibility author 
van eekelen van plasmeijer barendregt 
clean language functional graph rewriting 
kahn editor proc 
conference functional programming languages computer architecture fpca number lecture notes computer science pages 
springer verlag 
ce clarke emerson 
design synthesis synchronization skeletons branching time temporal logic 
kozen editor logics programs volume lecture notes computer science pages 
springer verlag 
maarten de mol marko van eekelen rinus plasmeijer 
theorem proving functional programmers 
arts editors proceedings th international workshop implementation functional languages ifl pages september 
ec emerson clarke 
branching time temporal logic synthesize synchronizations skeletons 
science computer programming 
hal thomas 
proof editor alfa 
www cs chalmers se alfa 
huth schmidt 
modal transition systems foundation program analysis 
proc 
european symposium programming volume lecture notes computer science 
springer 
william harrison tim sheard james hook 
fine control demand haskell 
proceedings sixth international conference mathematics program construction mpc july 
simon peyton jones report programming language haskell 
technical report url www haskell org definition february 
koz dexter kozen 
results propositional calculus 
theoretical computer science december 
lam leslie lamport 
temporal logic programs 
conference record seventh annual acm symposium principles programming languages pages 
acm press 
lar larsen 
modal specifications 
sifakis editor cav number lecture notes computer science pages 
springer 
owe olaf owe 
partial logics reconsidered conservative approach 
formal aspects computing 
pl simon peyton jones john launchbury 
lazy functional state threads 
acm sigplan symposium programming language design implementation pldi pages 
acm press june 
pla plasmeijer 
clean programming environment term graph rewriting 
corradini montanari editors proc 
joint workshop graph rewriting computation volume electronic notes theoretical computer science pages 
elsevier 
pnu pnueli 
temporal logic programs 
proc 
eighteenth ieee symposium foundations computer science pages 
ieee computer society press 
tho simon thompson 
logic miranda 
formal aspects computing july 
tho simon thompson 
logic miranda revisited 
formal aspects computing march 
eelco visser el benaissa 
core language rewriting 
claude kirchner kirchner editors second international workshop rewriting logic applications electronic notes theoretical computer science 
elsevier september 
vis eelco visser 
bootstrapped compiler strategies 
gramlich kirchner pfenning editors strategies automated deduction strategies pages july 
vis eelco visser 
scoped dynamic rewrite rules 
mark van den brand rakesh verma editors rule programming rule volume electronic notes theoretical computer science 
elsevier science publishers september 
vis eelco visser 
stratego language program transformation rewriting strategies 
system description stratego 
middeldorp editor rewriting techniques applications rta volume lecture notes computer science pages 
springer verlag may 

