volume issue published february issn managed runtime technologies intel technology journal open runtime platform flexible high performance managed runtime environment compiled version papers issue intel technology journal developer intel com technology index htm open runtime platform flexible high performance managed runtime environment michal cierniak microprocessor research labs intel eng microprocessor research labs intel neal glew microprocessor research labs intel brian lewis microprocessor research labs intel james microprocessor research labs intel index words mrte java cli virtual machine interface design open runtime platform orp high performance managed runtime environment mrte features exact generational garbage collection fast thread synchronization multiple coexisting just time compilers jits 
orp designed flexibility order support experiments dynamic compilation garbage collection synchronization technologies 
built run java common language infrastructure cli applications run windows linux operating systems run ia itanium processor family ipf architectures 
achieving high performance mrte presents challenges particularly flexibility major goal 
enable different garbage collectors jits component isolated rest environment defined software interface 
careful attention isolation easily harm performance 
second correctness safety requirements traditional languages lack 
requirements including null pointer checks array bounds checks type checks impose additional runtime overhead 
dynamic nature traditional compiler optimizations method calls difficult implement limited applicability 
get full performance jits core virtual machine vm brands names property respective owners 
itanium registered trademark intel united states countries 
cooperate reduce eliminate possible mrte specific overheads 
describe structure orp detail paying particular attention supports flexibility preserving high performance 
describe interfaces garbage collector jit core vm interfaces enable multiple garbage collectors jits sacrificing performance allow jit core vm reduce eliminate mrte specific performance issues 
modern languages java execute managed runtime environment mrte provides automatic memory management type management threads synchronization dynamic loading facilities 
environments differ number ways traditional languages fortran provide challenge language implementers developers high performance microprocessors 
concentrates language implementation challenges describing particular mrte implementation developed intel labs 
articles issue intel technology journal discuss implications microprocessors 
intel labs microprocessor research lab mrl developed mrte implementation called open runtime platform orp 
orp designed support experimentation different technologies just time compilers jits garbage collection gc multithreading synchronization 
past years researchers orp conduct number mrte implementation experiments 
different garbage collectors different open runtime platform flexible high performance managed runtime environment intel technology journal vol 
issue jits developed integrated orp 
version orp described internal research tool publicly available 
characteristics provide key challenges implementation 
dynamically load execute code delivered portable format 
means code converted native instructions interpretation compilation 
result mrte implementations typically include jit interpreter 
addition challenges just time compilation dynamic loading adversely affects important object oriented optimizations reduces overhead virtual method calls 
second provide automatic memory management require garbage collector 
different applications may impose different requirements garbage collector raw throughput versus gc pause time constraints garbage collector design significant challenge 
third multi threaded providing facilities creation management threads facilities locks monitors synchronizing thread execution 
design efficient locking schemes modern memory hierarchies bus protocols microprocessors significant challenge 
addition garbage collector designed multiple threads may need parallel 
core vm jit jit block diagram orp order provide flexibility needed jit garbage collector experiments designed interfaces cleanly separate jit garbage collector parts orp core virtual machine vm 
interfaces represented ovals 
evaluating experiments requires performance studies meaningful interfaces impose insignificant overhead 
result key contributions orp design clean gc interfaces jits garbage collectors sacrifice performance 
mrte implementation challenges described may require cooperation different components achieve result 
example optimizations may require cooperation jits optimization core vm manages class hierarchy 
balance need clean interfaces support flexibility need cooperation overcome performance hurdles 
section elaborate nature challenges provide implementers 
describe orp detail paying close attention design interfaces clean lead high performance 
managed runtime environments java programming language java virtual machine jvm emerged mainstream managed runtime environment mrte 
java joined common language infrastructure cli associated languages second major mrte market 
significant differences compilers runtimes similar important ways 
section describe terminology key features distinguish traditional systems particular may require new optimization techniques gain full performance 
key features dynamically load execute code 
code related data loaded class files read disk read network stream synthesized memory running application 
class file describes single class including superclass superinterfaces fields methods 
concrete methods include bytecodes specify method invoked 
bytecodes machine independent slightly higher level abstraction native instructions 
result require means convert bytecodes native instructions interpreter jit 
mrte controls bytecodes converted native instructions may place additional requirements conversion help perform functions garbage collection exception throwing discussed 
tend produce brands names property respective owners 
open runtime platform flexible high performance managed runtime environment intel technology journal vol 
issue information compiled bytecodes just native instructions code referred managed code implementations native methods mrte called unmanaged code 
manage type information store information classes fields methods loaded types define derive automatically primitive array types 
provide reflection facilities allow application code enumerate inspect information types fields methods 
provide automatic memory management 
region memory belonging mrte called heap 
bytecodes request instantiation class creation array space new object allocated heap 
heap full mrte tries reclaim space objects longer process known garbage collection gc 
part mrte manages heap allocates objects performs gc known garbage collector 
gc consists phases 
phase garbage collector find direct objects currently executing program called roots root set process finding called root set enumeration 
stack frame managed code native instruction may potentially different set roots stack physical registers purpose jit usually maintains gc map provide mapping individual instructions roots 
second phase gc garbage collector finds objects reachable root set called marking scanning 
final phase garbage collector reclaims space objects phases 
generational garbage collectors attempt improve gc efficiency scanning portion heap collection 
doing requires additional support rest mrte particularly jits write barrier called type pointer heap modified 
write barrier part garbage collector code typically fast mark garbage collector data structure completing object field write 
provide exceptions deal errors unusual circumstances 
exceptions thrown explicitly throw bytecode implicitly mrte result illegal action null pointer dereference 
bytecode method associated list exception handlers 
exception thrown jvm examine stack frame turn finds matching exception handler list associated exception handlers 
requires stack unwinding ability examine stack frames remove stack 
note stack unwinding needed implement security policies root set enumeration individual stack frames may contain roots 
significant differences cli java due additional features cli 
cli largely superset java relatively straightforward add java support mrte jit compiler supports cli 
addition cli richer set types java 
key value types 
value types resemble structures especially useful implementing lightweight types complex numbers 
cli supports managed pointers uses including implementation call parameters 
may point runtime stack static fields interior objects heap 
pointers called managed reported garbage collector order prevent object prematurely collected 
managed pointers require garbage collector properly deal objects referenced pointer interior means garbage collector needs mechanism locate start object interior pointer 
additions cli include support unsafe code may example operate pointers representation objects 
code required accessing legacy libraries 
contrast java cli objects set pinned guaranteeing objects relocated pinning may required objects interfacing legacy code 
cli supports platform library invocation service automates involved calling native library routines 
optimization challenges particularly java systems gained early reputation performing traditional languages 
part reputation arose implementations interpreted bytecodes 
jits introduced way achieve better performance interpretation thought optimizing code quick producers native code quick startup response times driving requirements 
time jit code quality increased due mature jit technology dynamic recompilation techniques relaxation fast startup requirement particularly longer running server type applications 
despite general maturation jit technology remain fundamental issues separate mrte jit traditional compiler 
set open runtime platform flexible high performance managed runtime environment intel technology journal vol 
issue issues lack program analysis mrte 
classes dynamically loaded system time new classes may invalidate assumptions earlier compilations methods 
making decisions inlining direct call conversion jits take account possibility target method may overridden compile time possible target target class may subclassed class currently extended 
generally results extra overhead method dispatch inlining typically system 
set issues safety checks required mrte semantics 
example array access test array index falls bounds array 
type cast test valid cast 
object dereference test null 
lack runtime requirements 
achieve competitive performance jits employ additional techniques minimize overhead 
performance challenges relate garbage collector 
batch style applications may demand highest possible throughput interactive applications may require short gc pause times possibly cost throughput 
requirements profound impact design garbage collector 
addition garbage collector responsible mapping objects specific heap locations may need detect relationships objects ensure related objects collocated memory order maximize memory hierarchy locality 
jit related overheads reduced compiler techniques 
require level cooperation core virtual machine vm 
identify techniques implemented orp 
overview open runtime platform open runtime platform orp high performance managed runtime environment mrte features exact generational garbage collection gc fast thread synchronization multiple just time compilers jits including highly optimizing jits 
code compiled compilers interpreter 
orp supports different mrte platforms java common language infrastructure cli 
basic structure orp divided components core virtual machine vm just time compilers jits garbage collector 
core vm responsible class loading including storing information classes fields methods loaded 
core vm responsible coordinating compilation methods managed code root set enumeration gc exception throwing 
addition core vm contains thread synchronization subsystem planning split separate component version orp 
jits responsible compiling methods native instructions 
garbage collector responsible managing heap allocating objects reclaiming garbage heap full 
orp written lines small amount assembly code includes core vm code excludes jit garbage collector code 
compiles microsoft visual gnu runs windows nt xp linux freebsd orp supports ia itanium processor family ipf cpu architectures 
orp uses gnu classpath library open source implementation java class libraries ocl open source implementation cli libraries ecma compliant 
orp originally designed jits java 
simple code generator known jit produces code directly jvm bytecodes applying complex optimizations 
optimizations include strength reduction load store elimination simple versions elimination cse eliminating checks register allocation 
optimizing compiler known jit converts jvm bytecodes intermediate representation ir aggressive optimizations 
optimizations performed jit applies inlining global optimizations copy propagation dead code elimination loop transformations constant folding complete implementations cse elimination array bounds checks 
brands names property respective owners 
itanium registered trademark intel united states countries 
open runtime platform flexible high performance managed runtime environment intel technology journal vol 
issue simple code generator unoptimized native code bytecode counters profiling data representation optimizing compiler optimized native code structure dynamic compilation shown orp run mode uses jits 
mode method invoked time orp uses compile method way instruments generated code counters incremented method call back edge loop 
counter reaches predetermined threshold orp invokes recompile method 
dynamic recompilation approach allows orp avoid cost expensive optimizations applying optimizations methods payoff high 
provides jit profiling information help guide optimizations 
orp supports simple jit cli currently ia platform known jit 
optimizations designed simplicity ease debugging 
cli bytecode instruction generates sequence machine instructions fixed set operand types 
new jit designed plug orp 
supports java cli produces aggressively optimized code ia ipf 
translates jvm cli bytecodes single common intermediate representation rest operates 
includes ssa optimizer supports profile optimizations dynamic optimizations continuous profiling monitoring program execution 
orp supported different gc implementations lifetime including simple world collector implementation train algorithm concurrent collector 
support vm jit interfaces moving collectors objects relocated lifetimes generational collectors require write barrier support jits core vm 
orp supports dynamic linking gc module making possible select specific gc implementation command line option 
common support java cli cli java semantically similar orp implementation common runtimes 
java cli require approximately support class loading exception handling threads reflection runtime low level non library specific native methods 
course cli uses different object file format java object file loaders different 
similarly class libraries runtimes different require different set native method implementations 
cli bytecode instructions different differences jits 
differences relatively minor code common 
general significant differences cli java due additional features cli 
means mrte jit supports cli relatively straightforward add support java 
orp relatively java specific cli specific source files load classes implement native methods required different cli java class libraries 
mrte specific source changes short sequences code conditionally compiled orp built 
currently refactoring orp share code significantly reduce need conditionally compiled code sequences 
example indicate attempt cast object class instance java mrte throw instance java lang cli mrte throw system 
refactoring part orp implementation simply involves raising exception stored variable initialized appropriate value 
core virtual machine core virtual machine vm responsible coordination activities open runtime platform orp 
responsible class loading stores information class field method loaded 
class data structure includes table vtable class shared instances class attributes class public final element type array class information inner classes static initializers 
field data structure includes reflection information name type containing class internal orp information field offset base object instance fields field address memory static fields 
method data structure contains similar information 
open runtime platform flexible high performance managed runtime environment intel technology journal vol 
issue data structures hidden components outside core vm core vm exposes contents functions vm interface 
example just time compiler jit compiles access instance field calls vm interface function obtaining field offset uses result generate appropriate load instruction 
data structure shared orp components including jits garbage collectors describes basic layout objects 
object heap including arrays begins fields typedef struct managed object vtable vt uint obj info managed object fields managed object data structure exposed outside core vm 
field pointer object vtable 
vtable class stores class specific information perform common operations virtual method dispatch 
vtable gc may supply information size object offset stored instance 
second field obj info bits wide ia itanium processor family ipf architectures synchronization garbage collection 
field stores instance default hashcode 
class specific instance fields immediately follow fields 
garbage collectors jits share knowledge representation array instances 
specific offsets array length element stored determined core vm available garbage collector jits vm interface 
small important piece shared information 
garbage collector expressly allowed portion cache frequently information avoid runtime overhead 
cached information private garbage collector correspondence class structure vtable possible unify single data structure 
chose separate sure offsets entries vtable method dispatch small instructions generated virtual method dispatch encoded shorter sequences 
information accessed frequently improves spatial locality reduces dtlb misses 
itanium registered trademark intel united states countries 
accessed orp components 
apart basic assumptions object layout vtable cache interaction major orp components achieved function calls 
vm interface includes functions support managed code jits garbage collector 
functions described part discussion specific components turn 
just time compiler interface just time jit compilers responsible compiling bytecodes native managed code providing information stack frames root set enumeration exception propagation security checks 
compilation overview core virtual machine vm loads class new overridden methods immediately compiled 
core vm initializes vtable entry methods point small custom stub causes method compiled invocation 
jit compiles method core vm iterates containing entry method replaces pointer original stub pointer newly compiled code 
open runtime platform orp allows jits coexist 
jit interacts core vm jit interface described detail provide implementation jit side interface 
interface completely cpu independent exception data structures model set physical registers stack unwinding root set enumeration ia jits itanium processor family ipf jits 
jits linked statically loaded dynamically dynamic library 
previously mentioned orp overview managed code may include instrumentation causes recompiled certain number invocations 
option background thread supports recompiling methods concurrently rest program execution 
native methods compiled sense 
native method invoked time core vm generates custom wrapper native method installs appropriate 
purpose wrapper resolve different calling conventions managed native code 
open runtime platform flexible high performance managed runtime environment intel technology journal vol 
issue interface description jit interface consists set functions jit required export set functions core vm exports 
obvious function jit interface instructs jit compile method 
jit interface includes obvious jit exported functions implement functionality traditionally thought part core vm 
include functions unwind stack frame enumerate roots stack frame 
stack unwinding required exception handling garbage collection gc security 
allow exact gc jit interface provides mechanism enumerate exactly roots stack frame 
instruction address jit consults gc map method constructs root set frame 
contrast jit interfaces sun jdk jit interface assumes conservative scanning stack 
course conservative collector orp mechanism root set enumeration 
basic solutions providing stack unwinding root set enumeration stack 
white box approach core vm jits agree common format gc maps 
compile time jits create gc maps native code core vm unwind enumerate help jits 

black box approach jit store gc maps arbitrary format understood jit 
core vm unwinds stack enumerates roots calls back appropriate jit frame question jit decodes gc map performs operation 
orp uses scheme black box approach 
advantage orp approach simplicity flexibility jit design 
example jit supports gc native instruction simpler jit supports gc call sites backward branches 
possible jit interface 
support multiple jits support multiple jits simultaneously core vm maintains array pointers jit objects represent jit 
standard orp java ia configuration includes statically linked jits 
additional jits may specified command line supplying name library containing implementation 
brands names property respective owners 
method invoked time custom stub transfers control core vm tries jit turn returns success 
jit succeeds orp terminates fatal error 
core vm support jits managed code vm interface includes functions allocate memory code data jit specific information 
core vm allocates memory jits allows space reclaimed longer needed orp currently implement unloading gc methods 
vm interface includes functions query exception information provided application class files set exception information managed code 
core vm uses information exception propagation 
core vm provides runtime support functions managed code 
provide functionality throwing exceptions subtype checks complex arithmetic operations nontrivial operations 
optimizations mentioned section safety requirements features dynamic class loading affect applicability effectiveness traditional compiler optimizations 
get performance comparable unsafe static languages jits include optimizations reduce eliminate safety overheads effectively presence dynamic loading 
optimizations implemented entirely jits require cooperation core vm 
outline key problems solutions additional interface functions provide needed cooperation 
null check elimination 
java cli semantics require null pointer dereferences throw exception 
object dereferences typically frequent applications safety check costly implemented naively 
compiler analysis prove certain null checks redundant eliminate checks null checks remain 
help obtained core vm 
instruct operating system hardware catch null pointer dereferences notify core vm identify offending instruction throw exception 
ia version orp uses technique eliminating need null checks managed code 
core vm able assist way 
frequent example involves open runtime platform flexible high performance managed runtime environment intel technology journal vol 
issue method invocations 
virtual dispatch typically involves dereferencing object extract vtable implicitly contains null check 
call removes implicit null check explicit check added back managed code 
done program semantics changed null exception raised raised visible side effect occurred 
experience orp vast majority explicit checks removed simple compiler analysis proving null check dominated previous explicit implicit null check implicit null check happens shortly intervening side effects 
array bounds checking 
java cli semantics require bounds array accesses throw exceptions 
core vm provides function tells jits compilation time offset array array length stored jit responsible testing array index throwing exception necessary 
managed code execute function call determine array length 
cases jits prove array accesses array bounds 
array created scope accessed may possible symbolically prove array index bounds 
application explicitly tests array index bounds example loop explicitly iterates lower upper bound array implicit bounds check eliminated 
unfortunately instances clean source code rare practice 
cases jits eliminate array bounds checks loop cloning jit generates versions loop bounds checks 
loop prolog code created tests starting conditions loop determines version loop execute 
note techniques completely capabilities jits require cooperation core vm 
fast subtype checking 
java cli support single inheritance interfaces multiple supertypes 
instance subtype instance supertype expected 
testing object instance specific supertype frequent thousands type tests done second program execution 
type tests result explicit tests application code example java checkcast bytecode implicit checks array stores example java bytecode 
array store checks verify types objects stored arrays compatible element types arrays 
checkcast instanceof take couple percent execution time java benchmarks justify inlining managed code 
core vm provides interface allow jits perform faster inlined type check conditions common practice 
direct call conversion 
orp calls default indirect calls 
target method may precisely known may compiled may recompiled 
indirect call managed code method easily changed method compiled recompiled 
unfortunately indirect calls may require additional instructions ipf may put additional pressure branch predictor 
important able convert direct calls 
allow happen core vm includes callback mechanism allow jits patch direct calls targets change due compilation recompilation 
jit produces direct call method calls function inform core vm fact 
target method re compiled core vm calls back jit patch redirect call 
dynamic loading 
jit performs class hierarchy analysis determine single target virtual method invocation 
cases compiler generates code takes advantage information example direct calls inlining registers class hierarchy assumption core vm 
core vm detects loading class violates registered class hierarchy assumption calls back jit registered assumption instruct code standard dispatch mechanism virtual methods 
variant guarded require stack frame patching see details 
functions jit interface scheme method overridden method handle 
function checks method overridden subclasses 
method set inline assumption method handle caller method handle callee function informs core vm jit assumed caller calls callee 
method overridden method handle caller method handle callee core vm calls function notify jit new class overrides method callee just loaded 
open runtime platform flexible high performance managed runtime environment intel technology journal vol 
issue small set methods somewhat specialized sufficient allow jits implement important optimization requiring detailed knowledge core vm internal structures 
fast constant string instantiation 
loading constant strings common operation java applications 
original jit interface managed code call runtime function instantiate constant strings 
extended interface reduce constant string instantiation runtime single load similar load static field 
optimization jits compile time call function class get const string intern addr 
function string returns address location pointing string 
note core vm reports location part root set gc 
string objects created compile time regardless control paths executed possibility applying optimization blindly managed code allocate significant number unnecessary string objects 
experiments confirmed performance applications degraded jits fast constant strings 
fortunately simple heuristic fast strings exception handlers avoids problem 
native method support orp gives jits wide latitude defining lay stack frames determining physical registers 
consequence jits responsible unwinding stack frames enumerating roots implement functions core vm calls 
native platform compiler jit compiles unmanaged native methods core vm assume cooperation 
result core vm generates special wrapper code native methods 
wrappers called control transferred managed native code 
record information stack thread local storage support unwinding past native frames enumerating java native interface jni gc 
wrappers include code perform synchronization native synchronized methods 
orp managed code interact native code native interfaces direct calls raw native interface orp implementation close identical original raw native interface microsoft java sdk 
java native interface jni platform invoke cli code uses java code uses jni 
optimization purposes native methods may called directly 
jni require customized wrapper discussed 
java methods jni 
interestingly jni methods useful implementing cli internal call methods 
methods implemented mrte provide functionality regular managed code provide system object 
native interfaces comparison 
jni preferred interfaces native method calling mechanisms available application programmers 
native methods called frequently performance time critical orp internally uses direct call interface better performance 
direct interface simply calls native function wrapper record necessary information transition managed code native code 
lack wrapper means orp unwind stack frame 
means direct native interface methods guaranteed require gc exception handling security support 
jni interfaces orp generates specialized wrapper method 
wrapper performs exact amount needed method signature 
specialization approach reflects general orp philosophy performing possible compile time minimum required runtime 
wrapper saves information unwind stack frame managed code method called native function described detail performs locking synchronized methods calls actual native method 
jni similar major difference managed objects handled 
passed native code raw pointers managed heap 
jni passed handles 
jni handles incur additional overhead writing debugging native methods simpler 
cli designed simplify existing libraries native code 
supports look name functions specified dynamic link libraries dlls 
handles details loading dlls invoking functions various calling conventions marshalling arguments return values 
automatically open runtime platform flexible high performance managed runtime environment intel technology journal vol 
issue translates marshals cli native representations common data types including strings dimensional arrays small set types 
stack unwinding native methods 
unwinding thread stack proceeds identifying frame managed native 
frame managed corresponding jit called unwind frame 
core vm uses managed frame list find managed frame nearest native frame 
thread thread local storage pointer list links stack frames wrappers native methods 
included wrapper stack frames list information find managed frame immediately wrapper frame previous wrapper frame 
included callee saved registers instruction pointer needed unwind managed frame 
pointer stack bottom frame managed frame top frame managed frame wrapper native frame native frame managed frame managed frame managed frame wrapper native frame managed frame managed frame managed frame managed frame wrapper native frame list call native method shows thread stack just call native method 
thread local variable points head list 
unwinding list traversed native managed transition encountered wrapper information unwind past native frames 
jni optimizations 
core vm generates specialized jni wrappers support transition managed native code 
straightforward implementation wrappers calls function allocate storage initialize jni handles argument 
jni methods small number parameters 
take advantage fact inline sequence instructions allocate initialize jni handles directly 
improve percent performance applications jni calls 
flexibility versus performance jits performance impact interfaces minimal interface functions called infrequently program execution 
naturally compilation interface method compiled including wrapper generation native methods number methods executed typically orders magnitude greater number compiled compilation cost far exceeds interface cost 
depending application number calls related exception unwinding root set enumeration may higher compilation related calls 
cost performing operations generally greatly exceeds cost interface 
garbage collection interface main responsibility garbage collector allocate space objects manage heap perform garbage collection gc 
gc interface defines garbage collector interacts core virtual machine vm just time jit compilers described detail 
describe typical garbage collection process open runtime platform orp 
overview garbage collection typically heap exhausted gc proceeds stopping managed threads gc safe points determining set root performing actual collection resuming threads 
garbage collector relies core vm enumerate root set 
core vm enumerates global thread local runtime data structures 
enumerates frame thread stack calls jit produced code frame enumerate roots frame unwind previous frame 
garbage collector responsible allocating managed objects 
core vm managed code native methods need allocate new object call function gc interface 
heap space exhausted garbage collector stops managed threads performs gc described 
generational garbage collector needs support core vm managed code execute write open runtime platform flexible high performance managed runtime environment intel technology journal vol 
issue barrier field managed object changed 
particular requires jit insert calls write barrier function gc interface managed code appropriate 
overview interface interface gc potentially greater performance impact jit interface large number objects created garbage collected lifetime typical managed runtime environment mrte application 
calling core vm function access type information slow common gc operations object scanning 
common solution problem expose core vm data structures garbage collector exposure increases dependency garbage collector core vm 
solution orp expose core vm data structures call interface provides separation core vm garbage collector allow garbage collector certain assumptions space thread local storage 
experience non call parts important feature gc interface 
sections describe explicit functions gc interface implicit data layout assumptions shared core vm garbage collector 
data layout assumptions part gc interface consists implicit agreement core vm garbage collector regarding layout certain data memory 
classes memory assumptions interface 
garbage collector assumes layout objects described previously terms managed object data type 
allows load object vtable calling core vm 
addition object info field certain purposes storing forwarding pointer performing gc 
field synchronization subsystem garbage collector ensure interfere uses 
second core vm reserves space vtable garbage collector cache type information needs gc 
cached information frequent operations scanning calling core vm costly 
core vm loads prepares class calls gc function gc class prepared garbage collector obtain information needs core vm vm interface store vtable 
third core vm reserves space thread local storage garbage collector thread creation calls gc thread init allow garbage collector initialize space 
garbage collector typically stores pointer thread allocation areas space 
fourth garbage collector assumes arrays laid certain way 
call vm function obtain offset length field array object array type offset element arrays type 
assume elements laid contiguously 
assumptions garbage collector enumerate array interaction core vm 
note offsets cached garbage collector data structures 
initialization gc interface contains number functions provided initialize certain data structures state core vm garbage collector specific points execution 
points include system startup new classes loaded new application threads created 
startup orp core vm jits call gc interface function gc requires barriers determine kinds write barriers garbage collector requires 
write barriers generational partial collection concurrent garbage collection techniques track root sets portions heap presence updates portions 
garbage collector requires write barriers jits generate calls gc function gc write barrier code stores object field 
previously mentioned core vm calls gc class prepared loading class gc thread init creating thread 
core vm calls gc init initialize garbage collector gc orp initialized tell garbage collector core vm sufficiently initialized enumerate roots gc allowed gc command line argument inform garbage collector command line arguments 
allocation functions related allocating space objects 
function gc malloc main function allocates space object size object object vtable 
functions special cases pinned objects 
allocation functions invoked core vm managed code 
open runtime platform flexible high performance managed runtime environment intel technology journal vol 
issue root set enumeration garbage collector decides gc calls vm function orp enumerate root set threads 
core vm responsible stopping threads enumerating roots 
roots consist global thread local object 
global static fields classes jni global handles constant strings core vm data structures 
thread local managed stack frames local jni handles thread data structures maintained core vm 
core vm jits communicate roots garbage collector calling function gc add root set entry managed object 
note parameter points root object root points allowing garbage collector update root moves objects gc 
core vm returns orp enumerate root set threads garbage collector roots proceeds collect objects longer possibly moving live objects 
calls vm function orp resume threads 
core vm resumes threads garbage collector proceed allocation request triggered gc 
flexibility versus performance relatively interface functions need called gc largely result cached type information 
managed code potentially gc interface crossings 
majority object allocation objects arrays write barriers 
write barrier sequence consists just straight line instructions control flow extra call return instructions proven performance issue practice 
object array allocation extra call return instructions significant source overhead mrte applications true functional languages 
benchmarks warranted jit gc interfaces extended allow inlining fast path allocation managed code 
performance open runtime platform relevant groups intel open runtime platform orp perform commercial java virtual machines jvm 
result put significant effort designing interfaces impose minimal overhead 
purpose section provide depth analysis orp performance merely show orp comparable commercial jvms set standard benchmarks 
extensive performance analysis appears study 
commercial jvms developed ia platform 
examples include ibm jdk sun hotspot jdk bea jrockit jvm 
compare orp sun hotspot jdk spec jvm set benchmarks designed reflect workload client machine 
comparison appears 
numbers taken ghz dual processor pentium xeon machine hyper threading gb physical memory running redhat linux set initial maximum heap sizes value mb vms command line options 
unable strictly follow official run rules benchmarks example java class library gnu classpath support awt run applets required conforming spec jvm run 
tried approximate closely possible conditions required conforming runs limits research infrastructure 
unmodified benchmarks run command line 
performance numbers relative fashion performance orp normalized numbers greater indicate better performance orp graph shows inverse execution time 
orp run default configuration methods compiled jit parameter modified heap size 
brands names property respective owners 
research project information components spec jvm published guidelines listed spec jvm run reporting rules section research www spec org jvm rules html research 
results represent spec jvm metrics run times directly comparable spec metrics 
information provided allow people reproduce results 
pentium registered trademark intel united states countries 
xeon trademark intel united states countries 
open runtime platform flexible high performance managed runtime environment intel technology journal vol 
issue performance relative orp compress jess db mpegaudio mtrt jack javac orp sun hotspot client 
relative performance sun hotspot client orp performance compares sun hotspot benchmarks 
believe performance comparison demonstrates interfaces consistent performance 
general overview open runtime platform orp described strict interfaces core virtual machine vm components particular just time compilers jits garbage collector 
interfaces allowed construct new jits garbage collectors having understand modify internal structure core vm components 
contrary conventional wisdom able provide level abstraction maintain high performance 
performance cost interfaces minor jits interface crossings infrequent 
heavily crossed interface garbage collector maintain high performance exposing small heavily portion java object structure part interface allowing caching frequently information 
experience shown approach effective terms software engineering performance 
experience orp component design positive encouraged modularize implementation 
currently developing interfaces managed runtime environment mrte components orp threading synchronization subsystems simplify experimentation runtime technologies 
acknowledgments possible contributions entire open runtime platform orp development team 
orp users outside intel contributions gnu classpath developers providing open source class library java 
gnu classpath www classpath org jikes research virtual machine 
ibm www research ibm com jikes jit compiler interface specification sun microsystems java sun com docs jit interface html microsoft sdk java 
microsoft www microsoft com java spec java business benchmark standard performance evaluation www spec org jbb spec jvm standard performance evaluation www spec org jvm intel architecture software developer manual intel 
ia architecture software developer manual intel 
language specification ecma 
ecma 
common language infrastructure ecma 
ecma 
java platform standard edition se sun microsystems 
open cli library ocl 
intel sf net projects ocl weblogic jrockit jvm version bea commerce bea com downloads weblogic jrockit 
jsp adl tabatabai bharadwaj chen menon murphy serrano dynamic compiler managed runtime environments intel technology journal 
adl tabatabai cierniak parikh fast effective code generation just time java compiler acm conference programming language design open runtime platform flexible high performance managed runtime environment intel technology journal vol 
issue implementation montreal canada pp 

cierniak lewis open runtime platform flexibility performance interfaces joint acm java grande conference seattle washington 
cierniak 
practicing java dynamic optimizations acm conference programming language design implementation vancouver british columbia 
hudson moss incremental collection mature objects international workshop memory management 
hudson moss sapphire copying gc stopping world java grande 
hudson moss cycles recycle garbage collection ia international symposium memory management 
calder annotations reduce dynamic optimization time acm conference programming language design implementation 
lindholm yellin java virtual machine specification second edition addison wesley 

adl tabatabai just time java compilation itanium processor international conference parallel architectures compilation techniques pact charlottesville virginia 
performance comparison jits january 
www net jit perf 
cierniak support garbage collection instruction java compiler acm conference programming language design implementation atlanta georgia pp 

wilson uniprocessor garbage collection techniques revision accepted acm computing surveys 
ftp ftp cs utexas edu pub garbage ps authors biographies michal cierniak senior staff researcher programming systems lab 
joined intel years experience compiler design years experience managed runtime design 
michal ph degree university rochester degree university edinburgh degree university technology 
mail address michal cierniak intel com 
eng researcher programming systems lab 
joined intel degree computer engineering university california san diego degree computer engineering university washington 
email address eng intel com 
neal glew staff researcher programming systems lab 
received ph degree computer science cornell university january 
email address neal glew intel com 
brian lewis senior staff researcher programming systems lab 
brian joined intel 
previously worked sun olivetti research xerox 
sun microsystems laboratories brian worked development virtual machines languages 
worked techniques binary translation portions spring research operating system 
brian received ph degree computer science degree mathematics university washington 
email address brian lewis intel com 
james senior staff researcher programming systems lab 
jim joined intel ph degree computer science carnegie mellon university 
jim worked extensively core vm jits open runtime platform orp 
mail address james intel com 
copyright intel 
publication downloaded developer intel com 
legal notices www intel com sites corporate htm 
open runtime platform flexible high performance managed runtime environment information visit developer intel com technology index htm copyright intel 
rights reserved 
intel trademark registered trademark intel united states countries 
complete listing trademark information www intel com sites corporate htm 
