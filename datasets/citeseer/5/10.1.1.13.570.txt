implementation cient algorithm bisimulation equivalence jean claude fernandez imag bp grenoble cedex france tel mail imag imag fr november cient algorithm bisimulation equivalence 
generally bisimulation equivalence tested mn labeled transition system transitions states 
order come cient algorithm establish relationship bisimulation equivalence relational coarsest partition problem solved paige tarjan log time 
initial partition binary relation problem find coarsest partition compatible 
computing bisimulation equivalence viewed instance generalization problem instance universal partition considered initial partition generalization want find partition compatible family binary relations single binary relation 
describe adapted paige tarjan algorithm complexity log minimize labeled transition systems modulo bisimulation equivalence 
algorithm implemented aldebaran tool verification concurrent systems 
bisimulation equivalence plays central role verification concurrent systems equivalence relations labeled transition systems 
theories equivalence concurrent systems proposed literature 
equivalences stronger trace equivalence weaker strong bisimulation equivalence shortly bisimulation equivalence 
example observational acceptance failure testing equivalences belong class equivalences 
usually problem deciding equivalences labeled transition systems reduced computing bisimulation equivalence canonical forms systems 
computation bisimulation reducing canonical form respect number states comparing canonical forms 
cient algorithm computing bisimulation equivalence reveals quite useful deciding equivalence relations 
kanellakis smolka studied connection relational coarsest partition problem bisimulation equivalence 
proposed algorithm running mn time 
case image set sizes bounded constant gave algorithm running log time generalization hopcroft algorithm computing minimum state deterministic finite automaton 
connection relational coarsest partition problem parametrized bisimulations stated 
paige tarjan proposed algorithm solve relational coarsest partition problem log time 
adapted version algorithm computing coarsest partition problem respect family binary relations binary relation 
section recall properties bisimulation relations 
greatest bisimulation obtained maximal fixpoint monotonic operator binary relations 
maximal fixpoint equivalence relation section describe relational coarsest partition problem relationship solution greatest bisimulation 
give formal specification relational coarsest partition problem characteristic property compatibility partition family binary relations 
allows derive algorithm correct construction 
algorithm described section 
addition measures performed aldebaran tool verification concurrent systems algorithm 
bisimulations labeled transition system quadruple set states finite set actions transition relation initial state 
transition relation considered binary relation function 
notations denotes number elements set image finite finite 
convention denotes number elements denotes number elements maximum image set sizes 
order compare minimize labeled transition systems recall notion bisimulation 
intuitively states bisimilar state reachable execution action state reachable execution action bisimilar symmetrically 
definition labeled transition system binary relation qq bisimulation 



set bisimulations ordered inclusion maximal element may obtained maximal fixpoint operator qq define qq 




bisimulation 
monotonic operator complete lattice binary relations inclusion 
image finite continuous decreasing sequence maximal fixpoint may obtained computing limit sequence qq proposition equivalence relation partition proof 
equivalence relation equivalence relation 
relational coarsest partition problem section consider labeled transition system 
represent equivalence relation partition represents equivalence classes 


partition refinement partition coarser 

consider partition set refinements ordered forms complete lattice unique maximum element unique minimum element greatest lower bound upper bound 
note sublattice complete lattice partitions definition equivalence relation compatible 

say compatible compatible proposition equivalence relation compatible bisimulation 
proof logically equivalent rewrite definition compatibility follows 


fact partition property equivalent definition bisimulation 
consider relational coarsest partition problem partition set family binary relations find coarsest refinement compatible space refinements partition complete lattice unique coarsest partition exists 
proposition gives characteristic property compatibility 
proposition equivalence relation compatible 

proof 
property logically equivalent property 

easy prove property equivalent definition compatibility 
proposition basis design algorithm computing partitions bisimulations 
define properties 
illustrates expression terms 
property corresponds paige tarjan notion stability 
note compatible 
computing relations define operator manner define operator refines partition respect class action operator partition property holds 
second define operator operators operator partition property holds 
operator obtained operator 
operator holds 
definition define operator follows 
proposition properties elements subsets partitions 
partition ii monotonicity iii refinement iv 
vi 
proof 
iii element split pieces belonging 
ii holds properties set operators 
iv consider cases 
cases 
follows symmetric reasoning 
holds construction 
vi iii su cient prove 
case second case 
follows 
subset partition sequence refinements respect may computed order property iv proposition 
define operator refines partition respect definition elements set define operator 
proposition properties subsets partitions 
partition ii monotonicity iii refinement iv 
vi vii viii proof 
iv follow properties operator 


definition 
definition property proposition get furthermore property iv proposition deduce 


vi property vi proposition 

vii prove consider cases fact commute 





monotonicity 
viii partition iii iv 
conversely ii vi vii partition sequence refinements respect may computed order property iv proposition 
class split refining respect useless property viii proposition 
definition family subsets partition define operator 
bn proposition properties subset partitions 
partition ii left monotonicity iii right monotonicity iv refinement vi vii 
proof 
vi follow properties operator 
vii definition 
easy see partitions 

property vi proposition deduce 
set partitions ordered refinement complete lattice 
operator define operator complete lattice partitions shown continuous 
maximal fixpoint partition coarsest refinement compatible transition relation 
proposition 
monotonicity ii image finite continuous iii initial partition maximal fixpoint coarsest partition compatible limit sequence proof 
prove property ii continuity 
monotonicity 
conversely prove 

prove 
exist decreasing sequences 
property proposition implies 
furthermore fact continuous 
conclude 
proposition establishes maximal fixpoints see section 
proposition labeled transition system maximal fixpoint operator maximal fixpoint 
proof 

conversely solution section paige tarjan algorithm adapted order compute maximal fixpoint 
resulting algorithm complexity original 
major di erence algorithms lies fact refinement step computation reduced computation original 
words refinement step algorithm consists repeating paige tarjan refinement step finite state labeled transition system partition 
suppose image set sizes uniformly bounded constant rest section organized follows develop algorithm computing maximal fixpoint 
show algorithm implemented mn time properties algorithm derive adaptation paige tarjan algorithm 
maximal fixpoint limit sequence property proposition 
property viii proposition sequence limit previous derive algorithm computing limit repeat multiple assignment prescribes computed executing assignments 
elements called splitters 
definition properties viii proposition element split subblocks need partition respect consider replace computation appearing property iv proposition refinements steps may performed order 
transform algorithm repeat choose replace replace definition obtain algorithm computed time repeat choose remove algorithm implemented mn time computed time 
algorithm terminates steps 
total cost algorithm obtained summing blocks refinement elements blocks 
consider case 
paige tarjan algorithm computes coarsest refinement log time space 
order reduce size generalize hopcroft algorithm minimizes number states deterministic finite automaton 
intuitively basic idea keep track blocks partition split subblocks refinement step 
splitter class simple splitter union classes compound splitter stable respect splitter regarded set expression 
structures consist binary associative operator operands elements current partition expressions 
subexpression splitter proper subexpression 
unions classes current partition write mean subexpression notice element occurs expression describe computation improved 
stable respect splitter property holds hopcroft process smaller half idea may exploited order perform refinement step respect property proposition set subset disjoint 
refinement step consists transformation replacing sets resp 
subset successors resp 
decomposition may obtained searching smaller set say map info info info computed time 
sets computed applying rules info info ii info iii info info suppose compound splitter subexpression code computes compute maps info info set replace andx described update win manner substitute xin add unstable respect refinement step consists transformation replacing sets suppose sample splitter 
code computes compute map info set replace andx described update win manner substitute xin add general case stability expressed property refinement step consists repeating previous algorithm data structures required represent states classes splitters 
state points list couples represented list 
allows scanning set time proportional size 
class associated integer giving size points list elements 
state points predecessor class allows deletion time class containing 
maintain set splitters 
refinement step respect performed case performed second 
compound splitter represented binary tree info map associated root children class maintain piece information indicates leaf compound splitter 
maintain list couples info elements 
space needed data structures 
algorithm consists repeating refinement step respect 
case class refinement step performed follows step remove element perform steps step compute set 
copy elements temporary set state move new class 
elements class moved new class 
new class point associated old class 
scan compute map info step update 
step old class contains elements 
perform statements performed time comparison numbers elements old new classes point case element new class point scanning add update manner add leaf compound splitter replaced subtree root new node leaves point point back 
performed time old class points father 
leaf create new node previously add case compound splitter suppose refinement step performed follows step remove perform steps step compute maps info scanning leaves scanning decrement info compute set copy elements leaves temporary set scanning leaves mark info info nodes add step perform statement split info info split point add non null classes 
update manner simple case classes non null nodes created points points example consider labeled transition system start universal partition 
decompose info info info info represent info graph 

refinement respect label info label modified info label info 
refinement respect info info info info info info info info modified 
refinement respect info info info info partition modified 
evaluation measures carried experimentation aldebaran 
aldebaran system verifying communicating systems represented labeled transition systems 
allows reduction comparison labeled transition systems respect equivalence bisimulation observational acceptance equivalence 
various operations parallel compositions labeled transition systems possible di erent strategies reductions 
algorithm section allows reduction labeled transition systems thousands transitions minutes 
aldebaran may interfaced systems manipulate labeled transition systems 
aldebaran sample input format list triples representing transition relation 
instance aldebaran interfaced lotos compiler common object code produced lustre esterel compilers 
aldebaran written runs unix 
presently limit size labeled transition system sun mega bytes memory transitions memory cost transition bytes 
give example reduction carried aldebaran 
reduction observational equivalence 
reduction respect observational equivalence consists transforming labeled transition system computing transitive closure transition relation labeled finding coarsest partition respect transition relation universal partition 
example milner problem scheduling see page 
example interesting evaluation purposes numbers states transitions equivalence classes grow proportion number tasks increases 
give specifications lotos 
consider ring elementary identical components called 
specification lotos process gi ai bi gi gi ai bi gi gi ai bi gi gi bi gi ai bi gi endproc cycle endlessly follows enabled predecessor gi ii receive initiation request ai iii receive termination signal bi enable successor gi order 
give specifications scheduler ai bi visible second ai visible 
specification expresses scheduler observationally equivalent 
cases give table summarizes time seconds spent finding coarsest partition compatible transition relation universal partition 
specification specification scheduler bn behaviour hide gn gi ai bi gi gi 
gn bn library numbers number states number transitions number classes time second specification specification scheduler behaviour hide gn bn gi ai bi gi gi 
gn bn library numbers number states number transitions number classes time notice cases time increases quasi linearly number transitions 
formally established description bisimulation equivalence terms relational coarsest partition problem 
adaptation paige tarjan algorithm implementation 
new algorithm provides cient decision procedure equivalence relations requiring computation bisimulation equivalence 
practice algorithm runs ciently context verification communicating systems state number successors 
aho hopcroft ullman 
design analysis computer algorithms 
addison wesley 

incremental development tool equivalence verification 
protocol specification testing verification viii 
smolka 
fundamental results verification observational equivalence 
rudin west editors protocol specification testing verification vii 
plaice saint 
lustre esterel portable format 
unpublished 
fernandez 
aldebaran un systeme de verification par reduction de processus 
phd thesis universite de grenoble 
fernandez 
aldebaran manuel de 
technical report imag grenoble 
hubert 
compilation verification de programmes lotos 
phd thesis universit joseph fourier de grenoble 
graf 
complete inference system algebra regular acceptance models 
mathematical foundations computer science 
lncs 
hennessy 
acceptance trees 
jacm 
kanellakis smolka 
ccs expressions finite state processes problems equivalence 
proceedings acm symp 
principles computing 
larsen 
context dependent bisimulation processes 
technical report cst departement computer science university may 
ph milner 
calculus communication systems 
lncs springer verlag 
olderog 
specification oriented programming 
logics models concurrent systems 
park 
concurrency automata infinite sequences 
computer science th conference springer verlag 
lncs 
paige tarjan 
partition refinement algorithms 
siam comput 
sanderson 
proof techniques ccs 
phd thesis university 
cst 
sifakis 
unified approach studying properties transition systems 
tcs 

