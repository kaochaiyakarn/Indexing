discovering algebraic specifications java classes johannes henkel amer diwan university colorado boulder boulder usa henkel diwan cs colorado edu www home page www cs colorado edu henkel diwan 
evaluate automatic tool extracting algebraic specifications java classes 
tool maps java class algebraic signature uses signature generate large number terms 
tool evaluates terms results evaluation proposes equations 
tool generalizes equations axioms eliminates redundant axioms 
tool uses dynamic information guaranteed sound complete 
manually inspected axioms generated experiments correct 
program specifications useful program development understanding 
gries describes programming methodology develops axiomatic program specifications code 
anecdotal evidence suggests programs developed gries methodology relatively bug free easier maintain 
developing formal program specifications difficult requires significant mathematical maturity part programmers 
reason programmers rarely develop full formal specifications code 
proposes tools automatically discover specifications program runs :10.1.1.164.9197:10.1.1.13.1381:10.1.1.14.8279
tools allow programmers benefit formal specifications effort 
research inspired tools 
knowledge methodology tackle high level functional specifications significant software components 
main shortcoming prior tools daikon refer inner state software components specifying pre postconditions 
nsf ccr ccr ibm faculty partnership award 
opinions findings recommendations expressed material authors necessarily reflect sponsors 
ecoop 
springer verlag 
preprint 
tool discovers algebraic specifications java classes 
algebraic specifications describe java classes implement revealing implementation details 
approach follows 
start extracting signatures classes automatically java reflection api 
signatures automatically generate large number terms heuristics guide term generation 
term corresponds legal throw exception sequence method invocations instance class 
evaluate terms compare outcomes 
comparisons yield equations terms 
generalize equations axioms term rewriting eliminate redundant axioms 
note systematically generate terms low confidence axioms 
evaluate approach variety classes 
experiments reveal approach effective discovering specifications java classes access implementation details classes 
employ dynamic techniques specifications discover unsound 
experiments reveal axioms discover correct useful understanding behavior classes 
remainder organized follows 
section motivates need algebraic specifications 
section describes approach implementation approach 
section presents case studies demonstrate usefulness effectiveness current prototype 
section discusses extensions prototype 
section reviews related 
section concludes 
motivation fig 
contains java source integer stack implementation 
concept integer stack simple details implementation tricky 
particular implementations push pop may need resize internal array involves copying contents array 
levels understanding code concept implement way implement concept 
understand concept intstack class implements needs know pop method returns int value argument call push 
applying pop state stack equivalent state push 
pop throw exception applied empty stack 
understand way intstack class implements concept needs know inner state integer stack modeled array int state containing stack elements integer int size maintaining pointer free index state array 
ecoop 
springer verlag 
preprint 
public class intstack private int store private int size private static final int initial capacity public intstack store new int initial capacity 
size public void push int value 
size store length int store new int store length system store store 
size store store store 
size value 
size public int pop int result store 
size 
size store length initial capacity size store length int store new int store length system store store 
size store store return result fig 

integer stack implementation java 
push checks state large accommodate value allocates new state array twice big old copies old elements 
potentially scaling state array push adds new value position size state array increments size 

discovering algebraic specifications reveal implementation characterize interfaces addressing level understanding concept 
tools daikon useful second level specifications characterize implementation details resizing state array 
fig 
shows algebraic specification java integer stack discovered tool 
part algebraic specification called signature gives type operations integer stack 
second part specification gives axioms describe behavior integer stack 
axiom states applying pop operation stack returns value pushed previously 
second axiom states pop operation yields state stack push applied 
third axiom specifies applying pop empty integer stack results exception 
explain axioms syntax section 
note axioms refer observable behavior stack internal implementation details 
algebraic specifications discovered tool uses ecoop 
springer verlag 
preprint 
type intstack functions intstack intstack void push intstack int intstack void pop intstack intstack int axioms intstack int pop push state retval pop push state state pop intstack state retval fig 

algebraic specification intstack fig 
discovered tool 
reverse engineering program understanding 
example illustrates algebraic specifications discovered tool useful program understanding 
program documentation 
programmer tool document code written 
case programmer may want start specifications generated tool edit necessary 
prototyping 
suppose developer wants implement efficient integer stack 
case developer start slow simple correct integer stack tools generate specifications specifications guide test efficient final implementation :10.1.1.23.2625
automatic test generation 
specifications discovered tool automatically generate test cases :10.1.1.23.2625
example specification fig 
generate test case pop pop push push intstack state state state retval test case derived axioms fig 
test fails know axioms hold 
generating test cases particular axioms tool able characterize circumstances particular axiom fails hold determine difference specification implementation 
debugging 
tool generates axioms sense may indicate bug implementation 
example axiom indicates bug implementation says applying pop times stack causes exception stack pop pop pop pop state state state state exception approach fig 
gives overview approach 
start generating terms algebra derived java class sections 
terms represent sequences ecoop 
springer verlag 
preprint 
invocations methods instance class 
terms generate equations 
example may find terms evaluate value 
observational equivalence determine values produced terms equal section consider behave respect public methods :10.1.1.23.2625
observational equivalence abstracts away low level implementation details considers interface 
discover equations section generalize equations replacing subterms universally quantified typed variables section 
generalization results axioms 
axioms may may true 
determine probability axioms true check generating test cases 
rewrite axioms eliminate redundant axioms section 
ja va la lg bra ic ig tu re rm ra te rm tio ra tio uses ra rm le uses io ra io gin re nt io fig 

architectural overview tool discovering algebraic specifications mapping java classes algebras algebraic specifications describe object oriented systems previous assumed method invocation side effects return value 
mapping java classes algebras represent methods side effects return values 
consider java intstack class fig 

note pop method returns value observer modifies internal state receiver pop message 
represent side effects return value time operation algebra returns entities receiver normal return value 
precisely java method named defined class cls arguments arg arg arg types type arg type arg type arg return type construct signature algebraic operation algebra cls follows cls type arg 
type arg cls receiver argument typed cls left arrow characterizes original state 
receiver type right arrow represents possibly modified state receiver result evaluating operation 
operation invocation state qualification refer receiver return ecoop 
springer verlag 
preprint 
value retval qualification refer normal return value 
example consider java fragment 
intstack new intstack push int result pop pop push intstack state state retval denotes integer value stored result pop push intstack state state state denotes state computation 
similarly axiom fig 
refers return value pop second axiom refers state stack pop 
constructors take implicit argument leave object state algebraic signature 
constructors void 
signature constructor class cls looks follows void type arg 
type arg cls void algebra mapping described implemented tool means capturing side effects arguments receiver methods 
generalize mapping equation take side effects arguments consideration returning just possibly modified receiver potentially modified arguments cls type arg 
type arg cls type arg 
type arg implementation handle side effects static variables interactions objects object modifies state owned object state observed 
handle terms throw exceptions capture possibly modified state object exception thrown 
operator distinguishes exception throwing terms regular terms third axiom fig 

contrast previous algebraic tools users tools needed define elaborate mappings java classes algebras implementation extracting algebraic signatures java classes fully automated retrieves information necessary java reflection api 
generating ground terms section considers generate terms algebra obtained java class 
output term generator endless stream terms 
quality generated terms important terms test cases critical ingredient successful dynamic invariant detection 
term generator may systematically generate terms size randomly generate terms distribution function having bias shorter terms :10.1.1.122.9788
terms satisfy properties 
terms throw exceptions evaluated 
second terms return state object return value 
example generate pop push intstack state state state pop push intstack state state retval computes return ecoop 
springer verlag 
preprint 
value state 
equation generation generate terms return values throw exceptions section 
prototype implementation represents terms trees nodes representing operation application constructor application array construction constants free variables 
children term arguments 
node represented java object containing appropriate java reflection api object needed evaluation 
example node may contain pointer java lang reflect method instance representing pop method class intstack 
ints ta state intstack executes fine keep growing ints ta state intstack state intstack parameter intstack back 
ints ta state intstack parameter intstack state intstack int parameter int works keep going 
ints ta state intstack parameter intstack parameter int state intstack parameter intstack state intstack fig 

growing terms incrementally growing terms grow terms incrementally constructor 
fig 
shows generate term intstack algebra 
selecting constructor intstack 
execute term java reflection 
executes throwing exception continue extend selecting operation applied existing term 
grow term pop evaluate result throws exception 
backtrack choose push 
push requires argument generate term returns value particular type case integer constant 
time term executes throwing exception 
keep growing term 
extend term pop executes throwing exception 
goal term generator explore state space instances class operations modify state receiver need part terms 
determine operation modify state receiver compile time mod ref analysis runtime heuristic 
run time heuristic works follows 
grow term keep new term operation term modifies internal state receiver 
hash sum serialized inner state determine operation changes inner state 
process int ecoop 
springer verlag 
preprint 
remove operation applications modify observable state object significantly improves quality terms 
generating arguments terms terms object arguments operations term 
interest efficiency quality ultimate results identify special cases handle differently arguments primitive type integer arguments instances immutable classes classes object modifying operations 
arguments primitive type maintain precomputed set constant nodes values primitive type values 
need argument primitive type select value set 
set small explore state space may missing axioms 
set large tool inefficient practical random selection test cases terms populate state space sparsely 
approach primitive types works types integers booleans 
approach generating arguments immutable classes similar primitive types precompute set values type 
immutable class class methods modifying state instance creation object string classes java 
example push state object state state prefer generate push state obj state obj object precomputed set 
object state term generate new instance object time evaluated second term contains particular instance obj object constant 
elaborate section technique constants immutable classes allows exploit equality instances immutable classes avoids high cost incurred traditional eqn method :10.1.1.23.2625:10.1.1.23.2625
equality need sure chance computing instance comparing terms 
example pop push state obj state retval pop push push state obj obj state retval compute instance obj 
analogously primitive types important pick set big small 
non immutable classes safely replace subterms particular instance precomputed constant potentially modified state instance evaluation term 
example execute term push intstack state multiple times compute different inner state time 
just serialized inner state different guarantee objects applications different externally observable way 
experience floating point values 
ecoop 
springer verlag 
preprint 
algorithm describes determine class immutable 
intuitively generate number instances class apply operations instance look hash code serialized instance operator application 
hashes sufficiently large number instances confident class immutable 
alternative approach compile time mod ref analysis 
mod sets methods class constructors empty class immutable 
algorithm class immutability class immutable require class repeat instance operations op class serialize hash serialize hash op return false confident outcome return true term equivalence compare ground terms variation frankl eqn method :10.1.1.23.2625:10.1.1.23.2625
eqn tries determine terms evaluate observationally equivalent values 
frankl define values observationally equivalent behave apply arbitrary operations 
values observationally equivalent different internal representations 
example consider intstack implementation java fig 
pop implemented public int pop return store size case applying push operations pop operations results different inner state compared push operations values observationally equivalent pushed values 
eqn method observational equivalence effective inefficient needs apply operations terms order gain confidence operator requires arguments may need generate test cases arguments confident 
recall intstack uses array representation initial size ele ments 
ecoop 
springer verlag 
preprint 

identify special cases handle quickly primitive types immutable classes 
algorithm describes dispatch possibilities 
algorithm parameters algorithm general term equivalence dispatch gte dispatch require terms type primitive type return primitive equals applies return eval ref eval return eqn gte dispatch terms values computed terms 
necessary primitive equals applies eqn needs single sample terms evaluate 
eval denotes result evaluation ref checks equality 
gte dispatch conservative accurate exposes non equivalence 
may inaccurate finds equivalence 
describe algorithms cases detail 
algorithm equivalence primitive types primitive equals require terms computing values primitive type 
result eval result eval result eval result eval consistent result val result consistent result val result consistent consistent return true consistent consistent return false return result val result equivalence primitive types consider question pop push intstack state retval equivalent terms 
confirm equivalence checking terms evaluate 
consider term hashcode intstack state retval 
hashcode function compute different value intstack instance term evaluate different value time 
identify cases ecoop 
springer verlag 
preprint 
algorithm evaluates term twice 
terms evaluate value times equal 
terms evaluates value times terms equal 
terms evaluate different values time evaluated assume equal 
algorithm checking equality applies require terms type 
return eval ref eval eval ref eval comparing computed terms algorithm currently handles side effects instance variables receivers instances immutable classes fixed set section may situations equality resorting expensive observational equivalence algorithm section 
heuristic similar primitive types algorithm evaluate term twice see term evaluates value evaluations 
simply compare return 
observational equivalence procedure 
example terms pop push state obj retval obj applies returns true returns false state 
pop push state obj state observational equivalence algorithm shows pseudocode version eqn 
eqn approximates observational equivalence terms class follows 
checks terms evaluate objects identical inner state serialize hash serializes object computes hash value serialization 
objects inner state safely assume observationally equivalent 
serialize hash fails prove equivalence test observational equivalence 
start generating term stubs take argument type apply stubs 
pick observer apply terms 
compare outputs observers gte dispatch algorithm 
gte dispatch returns false know observationally equivalent confident equivalence 
algorithm run infinite recursion 
cured adding recursion limit left clarity 
observer operation op type op 
retval void 
ecoop 
springer verlag 
preprint 
algorithm observational equivalence eqn require terms evaluating instances class serialize hash eval hash eval return true repeat generate term stub stb argument type observers ob applicable evaluation results stb stb stb ob retval ob retval gte dispatch return false confident outcome return true example consider applying procedure terms intstack algebra 
example stub push push state state example observer pop 
push intstack state application stub observer yields pop push push push intstack state state state state retval finding equations form equations determines form algebraic specifications system discover 
current implementation handles equalities 
limitation current implementation approach 
easily add new types equations enable disable equation types 
far added kinds equations implementation state equations equality distinct terms 
example pop push intstack state state state intstack state state equation 
equations useful characterizing operations affect observable state object 
generate equations find distinct terms equivalent 
approach able find state equations follows 
take terms produced term generator evaluate hash evaluation results table 
detect conflict hash table possible equation 
note hashing full observational equivalence method find state equations 
call optimized equation generator state hash general generator observational equivalence called state eqn 
ecoop 
springer verlag 
preprint 
observer equations equality term constant 
equations take form obs observer constant primitive type obs term arg arg retval observer equations characterize interactions operations modify operations observe 
example pop push intstack state state retval observer equation 
generate observer equations start term apply operation returns constant primitive type 
form equation equating term constant 
difference equations constant difference terms 
equations take form obs observer op operation computing value primitive type diff constant primitive type op obs term state retval diff retval obs term retval example operation size signature size intstack intstack int returns size integer stack formulate equation 
size intstack state retval size push intstack state state retval example op integer addition diff 
generate axioms generate terms apply observer terms take difference 
practice difference equations small value diff interesting ones 
generate equation diff lower fixed threshold 
technique filters spurious difference equations 
generating axioms axioms tuples terms set universally quantified typed variables appear free variables 
equation simply axiom 
generation axioms abstraction process introduces free variables equations 
example equation size intstack state retval retval size push intstack state state retval axiom generator intstack state quantified variable type intstack type int discover axiom intstack int size retval retval size push state retval ecoop 
springer verlag 
preprint 
algorithm axiom generation algebra term term generate equation algebra subterms set unique subterms occurring term term set typed universally quantified variables xn xi subterms xi replace occurrence variable xi term term generate large set test cases testset test case set generated terms test test test replace xj testcase testset set xj corresponding test testcase eqn dispatch term term false undo replacement term term executing test cases eliminate xi occur term term return axiom term term algorithm describes axiom generator minor optimizations left clarity 
generate axiom particular algebra equation generators described section come equation 
compute set subterms term term 
example terms push intstack state state intstack state set subterms push intstack state state intstack state 
initialize set universally quantified variables subterm exactly corresponding universally quantified variable loop checks subterm occurrences free variable 
replace occurrences subterm free variable 
generate test cases test case replaces free variables terms generated terms 
compare term term equivalent test cases 
undo replacement particular subterm 
eliminate free variables occur terms return axiom 
axiom redundancy elimination axiom rewriting axiom generator section generates redundant axioms 
example intstack algebra generator may generate intstack int pop pop push push state state state state intstack int pop push state state ecoop 
springer verlag 
preprint 
eliminate redundant axioms term rewriting 
axioms satisfy requirements rewriting rules left right hand sides different length ii free variables occurring shorter side subset free variables occurring longer side 
rewrite rule axiom try unify longer side rewrite rule terms axiom 
match replace term shorter side rewrite rule 
add new axiom note existing rewrite rules simplify axiom 
simplified axiom rewrite rule try rewrite existing axioms rule 
rewriting axiom redundant trivial throw away 
rewritten axiom yields rewrite rule rule simplify existing axioms 
process terminates rewriting application reduces length terms axioms rewrites means general addition axiom lead finite number rewriting elimination steps 
sketch rewrite example axioms shown 
suppose axiom exists add axiom 
try rewrite axiom axiom rewriting rule 
unfortunately left longer term axiom unify subterm axiom rewriting fails 
find axiom exist trivial axiom add set known axioms 
axiom rewriting rule try rewrite existing axioms axiom 
find left side axiom unifies subterm axiom unifier pop push push state state state push state instantiate right side axiom unifier obtain push state replacement subterm axiom 
axiom rewrites intstack int pop push state state equivalent axiom 
rewritten axiom identical axiom eliminate axiom 
summary axiom axiom final set axioms 
evaluation prototype conducted evaluations pentium ghz workstation mb running linux sun jdk 
configured system follows default term size equation ecoop 
springer verlag 
preprint 
generators test case size 
hashmap chose term size equation generators observer equation generator size beneficial 
configured system way hashmap test case size sufficient 
configured distinct instances object similar small pools primitive types 
table describes benchmark programs 
column op gives number operations class observ gives number operations observers operations non void return type 
table 
java classes evaluation java class description source op observ 
minimal integer stack henkel efficient integer stack fig 
henkel objects henkel object stack henkel fifo queue integers henkel mapping objects henkel fifo queue objects henkel linkedlist linked list sun jdk hash set sun jdk hashmap hash map sun jdk section gives performance characteristics system 
section presents data suggests tool successful exercising class consideration sound 
section discusses axioms tool discovers 
performance tool table 
timings benchmark programs benchmark rewriting final axioms time sec sec sec sec min sec min linkedlist min hashmap term size defined number nodes tree representing term 
example size push intstack state state 
means test cases nodes term representation 
ecoop 
springer verlag 
preprint 
algebra time sec generated terms size size linkedlist hashmap time ms time ms state hash state eqn diff obs equation generators term generation efficiency efficiency equation generation linkedlist state hash state eqn diff obs underlying equation generators rewrites rewritten axiom set size state hash state eqn axioms rewriting diff obs efficiency axiom generation linkedlist learning curve linkedlist fig 

efficiency effectiveness tool table gives performance system 
benchmark display number axioms rewriting rewriting time took generate axioms 
table shows redundancy reduction rewriting effective 
shows system fast classes hashmap 
hashmap demanding operations take arguments enlarges state space 
running system smaller test term sizes classes takes time introduces erroneous axioms infect correct axioms rewriting 
see table linkedlist axioms 
axioms quite lot worth noting java standard implementation linked list large number operations axioms excessive 
ecoop 
springer verlag 
preprint 
fig 
explores performance system detail 
fig 
gives time generate terms sizes column second column respectively 
see number terms increase significantly term length prune away useless terms 
see classes large number terms ones take time system 
fig 
box plots give distribution time generate different kinds equations axioms linkedlist 
example consider state eqn plot fig 

box denotes interquartile range contains values fall second third quartile 
line inside box median overlaps bottom box due strong bias low values 
values whisker outliers 
fig 
see state axioms equations expensive generate state eqn slowest 
part observer difference equations axioms fast generate equations axioms type take approximately time 
results suggest may worthwhile try orderings kinds equations order speed equation axiom generation 
fig 
gives insight behavior tool discovering axioms linkedlist 
axis denotes time terms axioms generated axiom generator 
learning curve number axioms discovered rewritten 
note curve ascend monotonically discovery axiom lead elimination numerous axioms 
dots denote number rewriting events discovered axiom 
run system follows discover state axioms hash table optimization state hash generate general state axioms state eqn generate difference axioms observer axioms 
shaded areas fig 
denote different zones 
coverage measurements system dynamic approach sound complete 
way system fail sound generated terms adequately exercise full range behavior class consideration 
section basic block coverage determine effectiveness term generator exploring class code 
find terms yield high coverage linkedlist hashmap 
coverage terms adequately explore argument space operations linkedlist generate term called collection contains subset receiver elements 
reasons include dead code code linkedlist sublist corner cases corner cases hashtable 
currently results observations improve tool 
ecoop 
springer verlag 
preprint 
manual inspection axioms table 
representative selection example axioms retval hashmap size state hashmap state hashmap object get put state retval object get put hashmap state object state object retval null linkedlist integer linkedlist state state sure axioms discovered tool correct manually verified generated axioms classes mistakes axioms 
axioms classes linkedlist relatively easy read hour time class 
table gives sample axioms tool 
axiom table trivial arises tool background axioms integer arithmetic 
axiom says invoking size hashmap modify internal state 
system generates axioms pure observer operation non void return value change state object example finds axioms linkedlist 
axiom says add mappings hashmap equivalent hashmap receiver state change 
axiom gives partial characterization get put operations 
axiom axioms tool support conditional axioms constants object object axiom rewritten object get put hashmap state state retval null axiom points incompletely specified behavior documentation linkedlist 
adds elements third argument position 
axiom says matter position specify adding empty list modify 
words verify bounds list 
worth noting manually verify axioms generated tool correct harder verify tool generates axioms needed fully specify interface class 
limitations limitations implementation fall categories unsoundness incompleteness inefficiency 
strive improvements areas 
note time limit better efficiency allow ecoop 
springer verlag 
preprint 
execute tests discover axioms improve soundness completeness 
limited side effects 
currently allow side effects receiver method 
means specifications may unsound states considered equivalent may incomplete side effects described 
section sketches deal side effects non receiver arguments 
planning model interactions objects currently unable capture 
arguments methods naively generated 
currently methodology choosing arguments methods insensitive body method 
plan domain analysis select arguments carefully order achieve better coverage faster 
plan extended domain analysis simple types 
improve efficiency tool 
support conditional axioms 
support conditional axioms enhance completeness 
support conditional axioms changing abstraction mechanism axiom generator section 
specifically particular test case satisfy axiom add exception set derive constraint conditional axiom exception set 
capture information 
measuring unsoundness incompleteness 
plan axioms emulate data types describe 
achieved re generating implementations discovered specifications 
generated implementation parallel original implementation realistic benchmark programs allow study soundness completeness tool practice 
related describe related algebraic specifications dynamic invariant detection automatic programming static analysis testing 
algebraic specifications drew ideas inspirations previous algebraic specifications data types 
give algebraic specifications 
sannella give overview motivation theory algebraic specifications 
book astesiano contains reports developments algebraic specification community 
antoy describes systematically design algebraic specifications 
particular describes techniques help identify specification complete 
observations setting limited particular class algebras 
ecoop 
springer verlag 
preprint 
prior demonstrates algebraic specifications useful variety tasks 
rugaber study adequacy algebraic specifications reengineering task 
specified existing system algebraic specifications able regenerate system specifications code generator 
find defining data types algebraic specifications preferable trace assertion method dynamic invariant detection dynamic invariant detection 
dynamic invariant detection systems discover specifications learning general properties program execution set program runs 
daikon discovers hoare style axiomatic specifications 
daikon useful understanding implemented exposes full complexity implementation 
daikon improved ways various applications including program evolution refactoring test suite quality evaluation bug detection generator specifications checked statically 
whaley describe discover specifications finite state machines describing order method calls object 
similarly ammons extract nondeterministic finite state nfas model temporal data dependencies apis code 
specifications nearly expressive algebraic specifications capture values returned methods 
preliminary studies show current implementation tool scale systems mentioned 
unaware dynamic tool discovers high level specifications interfaces classes 
prior system interleaves automatic test generation specification discovery 
previous systems require test suite 
automatic programming automatic programming systems discover programs examples synthesize programs specifications deduction 
programs analogous specifications specifications high level descriptions examples 
algorithmic program debugging similar automatic programming uses inductive inference procedure test side effect loop free programs input output examples helps users interactively correct bugs program 
techniques goals generate programs find bugs goal system generate formal specifications course generate programs find bugs 
ecoop 
springer verlag 
preprint 
static analysis program analyses generate output describes behavior program 
example shape analyses describe shape data structures may useful debugging 
type inference systems generate types describe flow values program 
system dynamic black box technique need look code effective 
various static techniques guide system example experimented mod ref analyses 
testing woodward describes methodology mutation testing algebraic specifications 
mutation testing introduces change mutations specification check coverage test set 
woodward system includes simple test generation method uses signatures specifications 
algebraic specifications successfully test implementations data types 
systems allows algebraic testing oo programs presence side effects 
user defines mapping algebraic specification implementation specification 
system checks axioms hold user defined test vectors 
similarly system antoy requires users give explicit mappings specification implementation 
system automatically generates mapping test suite 
builds frankl definition observational equivalence inspired algorithm generating test cases algebraic specifications :10.1.1.23.2625
system semi automatically checks implementations generated test cases 
improved frankl test case generation mechanism combining white box black box techniques 
tool potentially benefit employing static analysis code generating test cases white box testing 
addition prior test case generation relevant particularly deals term generation 
methods evaluating test suites test selection relevant 
techniques expect useful improving speed tool quality axioms 
korat system automated testing java programs :10.1.1.122.9788
korat translates method pre post conditions java predicates generates exhaustive set test cases finite domain pre condition predicate checks correctness method applying post condition predicate 
approach generating terms borrows ideas korat 
describe dynamic approach automatically discovering algebraic specifications java classes 
specifications form axioms ecoop 
springer verlag 
preprint 
terms public methods classes 
describe observable behavior classes burdened implementation details 
approach dynamic system sound complete 
compared dynamic systems system generates test cases terms keep generating terms attains adequate confidence discovered axioms 
example system may determine basic block coverage test cases inadequate may decide generate test cases 
experiments number java classes reveals system generates axioms correct useful understanding classes 
experiments reveal situations approach fails discover certain axioms 
specifically find situations conditional axioms useful 
approach specific java applied object oriented languages sufficient reflection capabilities 
michael burke dan connors daniel von matthias hauswirth martin james martin christoph reichenbach william waite alexander wolf anonymous popl ecoop reviewers insightful comments suggestions earlier versions 

ammons bodik larus 
mining specifications 
proceedings th acm sigplan sigact symposium principles programming languages pages 

angluin 
inference reversible languages 
journal acm jacm 

antoy 
systematic design algebraic specifications 
proceedings fifth international workshop software specification design pittsburgh pennsylvania 

antoy hamlet 
automatically checking implementation formal specification 
ieee transactions software engineering jan 

astesiano 
kreowski krieg br editors 
algebraic foundations systems specification 
springer 

parnas 
assertions traces write specifications software modules 
information systems methodology proceedings nd conference european cooperation informatics venice october lecture notes computer science volume 
springer verlag 

biermann 
inference turing machines sample computations 
artificial intelligence 

biermann 
inference regular lisp programs examples 
ieee transactions systems man cybernetics aug 

biermann krishnaswamy 
constructing programs example computations 
ieee transactions software engineering sept 
ecoop 
springer verlag 
preprint 

boyapati khurshid marinov 
korat automated testing java predicates 
international symposium software testing analysis rome italy july 

buy 
automated testing classes 
proceedings international symposium software testing analysis portland oregon 

chen tse chan chen 
black white integrated approach class level testing object oriented programs 
acm transactions software engineering july 

donovan lin ernst 
selecting predicates implications program analysis 
pag lcs mit edu pubs invariants implications pdf march 

frankl 
astoot approach testing object oriented programs 
acm transactions software engineering apr 

ernst cockrell griswold notkin 
dynamically discovering program invariants support program evolution 
acm transactions software engineering feb 

ernst griswold notkin 
quickly detecting relevant program invariants 
proceedings nd international conference software engineering pages june 

ernst griswold notkin 
dynamically discovering program invariants involving collections 
tr uw cse university washington 
revised version march 

gannon hamlet 
implementation specification testing 
acm transactions programming languages systems 

graves harrold 
kim porter rothermel 
empirical study regression test selection techniques 
acm transactions software engineering methodology 

gries 
science programming 
texts monographs computer science 
springer verlag 

guttag garland jones wing 
larch languages tools formal specification 
springer verlag 
print 

guttag horning 
algebraic specification data types 
acta informatica 

lam 
tracking software bugs automatic anomaly detection 
proceedings international conference software engineering pages may 

harder morse ernst 
specification coverage measure test suite quality 


hardy 
synthesis lisp functions examples 
proceedings fourth international joint conference artificial intelligence pages 

helm holland 
contracts specifying behavioral compositions object oriented systems 
proceedings european conference object oriented programming object oriented programming systems languages applications pages 
acm press 

hoare 
axiomatic basis computer programming 
communications acm 
ecoop 
springer verlag 
preprint 


algebraic specifications software engineering 
springer verlag 

hughes stotts 
systematic algebraic testing oo programs presence side effects 
proceedings international symposium software testing verification san diego california 


foundations trace assertion method module interface specification 
acm transactions software engineering july 

weyuker 
simplified domain testing strategy 
acm transactions software engineering july 

ernst griswold notkin 
automated support program refactoring invariants 
international conference software maintenance florence italy 

lin 
procedural implementation algebraic specification 
acm transactions programming languages systems 


testing object oriented software 
proc 
ieee international conference engineering complex computer systems 

mitchell 
foundations programming languages 
mit press 

nimmer ernst 
automatic generation program specifications 
proceedings international symposium software testing analysis issta rome july 

callahan jackson 
program understanding tool type inference 
international conference software engineering pages 

rugaber shikano 
adequate reverse engineering 
proceedings th annual international conference automated software engineering pages 

sagiv reps wilhelm 
parametric shape analysis valued logic 
acm transactions programming languages systems may 

sankar 
run time consistency checking algebraic specifications 
proceedings symposium testing analysis verification victoria british columbia canada sept 

sannella tarlecki 
essential concepts algebraic specification program development 
formal aspects computing 

shapiro 
algorithmic program debugging 
acm distinguished dissertation 
mit press 

summers 
methodology lisp program construction examples 
journal acm jacm 

whaley martin lam 
automatic extraction object oriented component interfaces 
proceedings international symposium software testing analysis 

woodward 
errors algebraic specifications experimental mutation testing tool 
ieee software engineering journal july 

zhu hall may software unit test coverage adequacy 
acm computing surveys 
