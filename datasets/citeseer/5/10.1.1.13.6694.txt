amorphous program slicing mark harman brunel university ub ph uk 
david binkley college maryland baltimore maryland usa 
sebastian danicic college university london new cross london se nw uk 
traditional syntax preserving program slicing simpli es program deleting components statements predicates ect computation interest 
amorphous slicing removes limitation component deletion means simpli cation retaining semantic property slice preserves selected behaviour interest original program 
leads slices considerably smaller syntax preserving counterparts 
formal framework introduced de ne compare amorphous traditional program slicing 
de nition algorithm computing amorphous slices system dependence graph 
implementation algorithm demonstrate utility amorphous slicing respect code level analysis array access safety 
resulting empirical study indicates programmers comprehension array safety improved amorphous slicing 
key words program slicing program dependence graph program transformation program comprehension concerns variation traditional program slicing called amorphous slicing produce smaller slices abandoning traditional restriction syntax preservation 
traditional syntax preserving program slicing simpli es program removing program components statements predicates ect computation interest 
resulting preprint submitted elsevier preprint may scanf scanf sum sum product sum sum sum sum product product original program slice sum line fig 

program syntax preserving slices smaller program called slice captures projection semantics original program 
illustrates syntax preserving program slicing simple example program slices slicing useful aspects software engineering preserves projection semantics original program reducing size program 
originally slicing applied debugging weiser weiser lyle weiser algorithmic debugging kamkar 
applications investigated example cohesion measurement bieman ott ott lakhotia re engineering liu ellis simpson lakhotia component re beck eichmann cimitile program comprehension de lucia harman danicic maintenance gallagher lyle testing hierons binkley binkley hierons gupta program integration horwitz binkley software conformance certi cation krinke snelting tip tip binkley gallagher binkley gallagher harman hierons harman hierons de lucia de lucia survey paradigms applications algorithms program slicing 
addition capturing projection program semantics original application slicing required syntactic property slice preserve subset original program syntax 
syntax preservation allows statements slices bug error commission manifests wrong value variable statement slice respect contains bug 
syntactic requirement important slicing applied cohesion measurement algorithmic debugging program integration 
applications re engineering program comprehension testing primarily semantic property slice interest 
describes variation slicing theme termed amorphous program slicing syntactic requirement dropped semantic requirement retained 
slice taken respect statement amorphous slicing preserves ect original program values variable places restriction syntax slice 
example consider program fragment sum biggest sum biggest biggest average sum fragment written intention variable biggest assigned largest value element array variable average assigned average elements fragment contains bug ects variables sum average variable biggest 
illustrate amorphous slicing variables biggest average analyzed traditional syntax preserving slicing amorphous slicing 
syntax preserving slice nal value biggest consists statement 
help clear correctness computation biggest 
amorphous slice constructed transformations loop unrolling changed loop bounds biggest biggest biggest amorphous slice little clearer computation biggest correct 
syntax preserving slice nal value average contains statement original program 
simpli cation relatively weak aid comprehension 
amorphous slice goes average amorphous slice reveals fault program ecting computation respect average ect biggest uenced fault 
slicing refer static backward slicing horwitz venkatesh 
kinds slicing studied traditional syntax preserving static backward slicing syntax preserving slicing amorphous static backward slicing amorphous slicing 
slices termed backward dependences followed backward sources termed static input values known 
contrast forward slice dependences followed forward targets capturing components ected particular component 
dynamic slice considers particular input program 
rest organized follows 
section theoretical foundations 
section describes theory program projection uses de ne compare syntax preserving slicing amorphous slicing 
section safety slicing 
section describes application implementation amorphous slicing array access safety analysis 
section empirical study 
section describes results empirical study aimed assessing suitability amorphous slicing aid program comprehension 
section related 
section describes previous involved level slice construction combination slicing transformation 
section summary 
section provides brie summary 
theoretical foundations order formalize amorphous slicing compare syntax preserving slicing framework program projection introduced 
syntax preserving slicing amorphous slicing cast instances framework 
framework program projection projection framework essence generalization program slicing 
de ned respect relations programs syntactic ordering semantic equivalence 
syntactic ordering simply ordering relation programs 
capture syntactic property slicing seeks optimize 
programs lower ordering considered better 
semantic relation equivalence relation captures semantic property remains invariant slicing transformation 
de nition syntactic ordering syntactic ordering denoted computable transitive re exive relation programs 
de nition semantic equivalence semantic equivalence denoted equivalence relation projection program semantics 
de nition projection syntactic ordering semantic equivalence program projection program projection syntax improve semantics interest remain unchanged 
syntax preserving slicing framework de nition formalizes oft quoted slice subset program constructed 
de nes syntactic ordering syntax preserving slicing 
note ease presentation assumed program component occupies unique line 
line number uniquely identify particular program component 
de nition syntax preserving syntactic ordering function takes program returns partial function line numbers statements function maps program contains statement line number syntax preserving syntactic ordering denoted sp de ned follows sp example sp second part projection framework semantic equivalence 
semantic property syntax preserving slicing respects concept state trajectory de nitions state trajectory state restriction roj roj extracted weiser de nition slice weiser 
de nition state trajectory state trajectory nite sequence line number state pairs entry statement executions state component executed line number de nition state restriction state set variables restricts de ned variables de nition roj slicing criterion line number state roj denotes empty string 
de nition roj slicing criterion state trajectory roj roj roj slicing criterion speci es slice taken respect set variables line number roj extracts state trajectory values variables statement roj semantic equivalence static slicing de ned de nition static semantic equivalence programs slicing criterion syntax preserving semantically equivalent written sp states execution gives rise trajectory execution gives rise trajectory roj roj 
example sp sp weiser deliberately left unspeci ed behaviour slices states original program fails terminate weiser 
subsequent cartwright felleisen cartwright felleisen clari ed behavior slicing related dependence analyses showing respect lazy demand driven semantics 
semantic equivalence preserved slicing re cast parameter de nition slice 
allows di erent interpretations de nitions way slicing behave 
framework suciently general allow de nition dynamic korel laski conditioned slices canfora 
syntax preserving semantic equivalence relation parameterized de nition describes class relations choice re ects fact slicing criterion yields slice respects di erent projection semantics program constructed 
instantiating de nitions de nition yields de nition syntax preserving slicing program syntax preserving slice program respect slicing criterion sp sp projection example program shown sp sp projection amorphous slicing framework de ne amorphous slicing syntactic ordering needs altered semantic equivalence remains 
amorphous slicing natural choice syntactic relation contains fewer statements 
de nition syntactic ordering naturally depends statements counted 
approach adopted keeping spirit slicing count nodes program control ow graph cfg ferrante horwitz 
de nition amorphous syntactic ordering number nodes cfg program amorphous syntactic relation denoted de ned follows example de nition amorphous semantic equivalence sp de nition amorphous slicing program amorphous slice program respect slicing criterion projection example consider program fragments 
shows trajectories initial state fg corresponding program fragments 
projecting nal state projecting nal state mapping variables interest fxg gives result fx 
case indicating fxg equivalent 
syntax preserving slice syntactic subset 
contrast contains fewer statements contains fewer statements amorphous slice amorphous slice observe programs equivalent amorphous slice 
possible equivalent programs amorphous slices observations true syntax preserving slicing 
order determine programs equivalent nal issue worth discussing important identify slice point slice original program 
syntax preserving slicing fig 

examples amorphous slices variable slice point fg fx 
fg fy 
fy 

fg fz 
fz 

fz 


fig 

trajectories examples normally issue usually obvious point sliced program corresponds slice point original lines numbered numbering preserved part syntax slicing 
amorphous slicing slicing algorithm need return just amorphous slice pointer slice point located slice generally obvious context 
amorphous slicing subsumes syntax preserving slicing sp sp see converse true observe amorphous slice syntax preserving slice 
consequence implementation syntax preserving slicing implementation amorphous slicing albeit sub optimal implementation 
amorphous slice larger syntax preserving slice constructed slicing criterion 
course amorphous slice contains program corresponding syntax preserving slice 
amorphous slicing attractive preservation syntax unimportant 
safety slicing application amorphous slicing trying understand large program bene cial tool answer questions program 
questions represent speculative hypotheses supposed behavior program 
attractive fully automated formal reasoning tool suciently powerful decide propositions 
unfortunately trivial propositions concern properties system undecidable tool impossible 
attempt prove propositions technique section advocates production simpli ed program question 
technique approximates answers undecidable propositions program simpli cation harman 
recasting problem simpli cation circumvents undecidability problem simpli cation process consists approximating ideal simplest program 
provides partial automation tool progress deciding truth proposition cases impossible fully decide 
large class hypotheses concern aspects program explicitly represented program state recall state maps identi ers values 
de nition implicit state information reach program slicing slice computed respect set variables 
problem circumvented making part implicit state explicit 
order program augmented assignments pseudo variable 
assignments capture ect original program implicit semantic property interest making explicit 
section describes example application amorphous slicing problem involves implicit state 
particular problem studied array bounds safety array analysis seeks determine guaranteed bounds array 
introducing steps array bound state information explicit algorithm computing safety slices amorphous slice augmented program 
followed extended example discussion algorithm complexity 
section presents empirical study safety slicing aid program comprehension 
case safety slicing necessary implicit state explicit program augmented include assignments new variable safe safe value true executions cause array access error false harman danicic 
detail augmentation adds program assignment safe true start execution array bounds errors 
program statement print safe added 
array assignment statement safe safe added assumes arrays start index target language tool 
augmentation array safety part explicit state 
amorphous slice taken respect statement print safe captures computations relevant array safety question 
computing safety slices prototype implementation system dependence graph sdg built study safety slices 
sdg represents program collection vertices edges horwitz 
vertices represent components program assignment statements predicates edges represent dependences 
example sdg rst loop initialization code precedes column shown 
kinds edges sdg control dependence edges data dependence edges 
control dependence edge labeled true false 
connects predicate vertex vertex execution predicate represented evaluated value matches edge label program component represented eventually executed provided program terminates normally 
control dependence edge label denoted label omitted clear context 
data dependence edges implementation ow dependence edges 
ow dependence edge denoted runs vertex represents assignment variable vertex represents variable reached assignment 
ow dependence edge loop carried denoted lc value passed loop iteration loop independent denoted li 
implementation follows algorithm shown 
rst builds program sdg calling function repeatedly takes syntax preserving slice applies collection transformation rules 
function returns additional slicing transformations ect graph 
simple inductive argument shows recursion terminates function returns program larger syntax preserving slice input 
function produces program resulting graph 
requires sdg feasible feasible sdg sdg program 
kind transformation applied sdg step simpli cation existing algorithms binkley choi ferrante horwitz 
feasible graph program producing linear order vertices graph respects ordering constraints dependence edges 
function program set statements returns program declare sdg program return function sdg vertex set returns program declare sliced transformed sdgs sliced transformed sliced transformed return sliced return smaller transformed sliced fig 

construction algorithm amorphous slicing function transform captures part algorithm slicing process amorphous 
transformations essentially graph compiler optimizations ferrante ernst 
example sdg constant propagation data ow model nodes re updating graph example placing values ow dependence edges binkley 
examples include procedure lining procedure specialization 
figures example sdg transformation rules safety slicing 
gures highlight transformations standard compiler optimizations useful amorphous slicing 
contains auxiliary de nitions transformation rules 
auxiliary functions straightforward 
exception function allowable explained description flow edge removal rule 
note removal node includes removal edges involve 
function transform contains kinds transformations general purpose transformations domain speci transformations 
rst rules examples general purpose rules 
second examples domain speci rules explicitly designed safety slicing 
distinction blurred general rules specialized 
example denotes path containing edges kind denotes replacement dup denotes duplicate node copy incoming outgoing edges denote duplicate copy denotes duplicate created 
denotes node labeled text fv ug allowable fw def def fig 

auxiliary de nitions rule flow edge removal allowable rhs label sdg sdg fv ug fx vg rule loop anti fusion loop body partitioned init init lc dup dup init dup init fn init fn init sdg sdg copy bg fx 
fx ag rule dependent assignment removal safe safe safe safe sdg sdg fug fv xg rule induction variable elimination 

init 

safe 
init lc body ug induction variable symbolic expression nal value uf copy rhs label sdg sdg fng fu xg fx uf safe def def fu fx ng fx uf fx uf ng fig 

example sdg transformation rules loop anti fusion rule rule specialized favor separating assignments safe 
transformation rules considered detail 
flow edge removal rule states expression propagated ow edge assignment vertex labeled vertex rewriting allowable target exactly ow dependence edge variable furthermore represents vertex de nes rewriting rule requires incoming ow edges subset incoming ow edges excluding edge 
ensures rewritten graph transformed back sequential program 
example unsafe remove ow edge second fourth assignment sequence rewriting allowed sdg updated copying incoming ow dependence edges rewriting label substituting removing ow dependence edge loop anti fusion rule rule splits single loop loops 
referring init represents loop initialization loop increment loop predicate 
recall copy denotes duplicated case refers duplicate 
set edges copy bg includes edges sdg necessary new edges required connect new vertices 
unwanted edges link loops excluded nal line rule 
implementation loop anti fusion rule requires loop initialization increment achieved node 
furthermore assumes right hand sides expressions side ect free 
possible provide general rule ferrante handle side ects multi node initialization increment 
alternatively additional transformations enforce side ect freedom harman 
transformation replace initialization sequence tmp tmp second plays role initialization 
dependent assignment removal rule rule specialized form loop independent code removal fischer leblanc 
works assignments safe idempotent pre conditions hold possible remove second assignments 
rule potentially applied control structures statements implementation attempt 
init init init 


anti fusion fig 

anti fusion transformation induction variable elimination rule replaces qualifying loops assignments capture requirements array safety 
informally replaces graph equivalent safe safe graph equivalent safe safe safe safe final final value nal iteration loop 
note transformation safe structure 
created speci cally check array bounds form 
max 
rule may limited applicability works slicing loop anti fusion produced suitable candidates induction variable elimination 
rule updated vertex copy uf represent safety test performed rst nal iterations loop 
control edges added cause decrease nesting level uf role changed ensuring downward exposed de nition correct value 
uf form straight line code ow edges uf simpli ed sole ow successor uf 
ow edges added sdg cover variables rewritten expression uf implementation presently includes simpli ed version general induction variable elimination fischer leblanc 
simpli cations include assumption rule applied structured loops 
second assumed nal value induction variable determined expressions labeling init resulting expression may symbolic 
implementation determine rule applied 
transformation applied determined loop executes 
places transformations better exploit available information 
example sdg encodes signi cant information pointers including function pointers dependence edges 
points analysis user selectable andersen andersen steensgaard steensgaard algorithm 
points information directly available transformation phase sdg algorithm codesurfer api 
fully exploited current implementation 
safety slicing example section traces computation safety slice program shown column 
program computes frequently occurring lower case character input augmented assignments safe 
italicized statements column removed rst slice note program remains syntax preserving slicing 
column shows program slice rst rewriting 
italicized statement column removed second slice 
results second rewriting shown column 
italicized statements column removed third slice 
column shows results third rewriting expression simpli cation performs constant folding similar simpli cations 
italicized statement column removed fourth rewriting 
bulk rewriting concerns loops discussed greater detail 
consider transformation rst loop statements immediately preceding 
illustrated slicing loop subgraph candidate assignment safe assignment result post rst slice post rst rewrite post second rewrite post simplify third rewrite int safe char source max int result int bc safe starts safe printf enter string scanf source safe safe result safe safe source safe safe source safe safe safe safe result result safe safe bc safe safe result bc safe safe bc result printf frequent printf occurs times bc printf safe safe int safe char source max int result int bc safe starts safe scanf source safe safe result safe safe source safe safe safe safe source source source source source result result bc safe safe result bc bc result printf safe safe int safe char source max int scanf source safe safe safe source safe safe source source source source safe safe safe printf safe safe int safe char source max int scanf source safe source safe safe source source safe safe printf safe safe fig 

computation safety slice data dependent 
shows result transformation isolates computation safe boxed region computations loop 
induction variable elimination replaces loop pair assignment vertices followed ow edge removal reduces single assignment vertex 
illustrates removal ow edges middle loop program 
initial loop shown ow edges candidates ow edge removal 
example shows result rewriting edges labeled low low rewriting low adds edge labeled low shown 
edge copy ow dependence edge rst assignment safe second assignment safe 
scanf 
result safe safe safe safe scanf 
safe safe result edge key control dependence edge flow dependence edge loop carried flow dependence edge fig 

anti fusion transformation rst loop example program 
rewriting low essence moves nal assignment safe increment part change graph subtle edge increment loop carried edge indicating increment follow assignment safe loop body 
addition target low target edge initialization copy edge initialization increment 
rewritings update expression labeling targets edges 
example target low rewritten safe safe shows result removing edges labeled low low removal source vertex outgoing edges removed gure 
reconstruction program text graph shown produces code loop column 
implementation simpli es resulting expression producing statement shown column 
advantage iterating slicing transformation illustrated third loop 
initial slice removes sucient parts loop body allow application dependent assignment removal rule 
results removal inner assignment safe control safe source source flow safe source source flow safe source safe safe safe safe save safe save safe save safe flow flow save safe safe safe safe safe source source source source fig :10.1.1.39.1532

middle loop example program 
vertex labeled safe original program 
result rewriting rst loop 
anti fusion removed vertex labeled result result loop 
dependence edge statement 
consequently second slice include statement 
results appear columns 
slicing transformation parts program 
example anti fusion separates computations rst loop loops 
slice shown column excludes loop unrelated safe 
shown column nal program scanf source safe source safe safe source source printf safe safe location code immediately tells engineer array rst third loops safe 
code indicates middle loop may cause array subscript errors 
particular program stores false safe condition violated source words input string long greater equal max input character held source outside range 
implementation recognize greater equal technical reason 
remaining conditions highlight invalid assumptions previous programmer rst string read source assumed longer max characters second input characters assumed ascii characters range 
discovery assumptions easily enforced 
algorithmic complexity section considers complexity algorithm 
variables complexity discussion number nodes sdg number edges maximum degree vertex theory practice small independent program size 
largest number nodes controlled predicate bounded practice small independent program size 
sets represented bit vectors assumed manipulated constant time 
consider complexity rules combined complexity algorithm 
ow edge removal requires testing transformation allowable pre processing step computes assignment variables de ned single source 
step considers ow dependence edges complexity 
rule considers ow dependence edge 
identifying correct form application safe require constant time requires constant number bit vector operations 
cost ow edge removal bounded 
loop anti fusion considers node candidate node determining suitable init nodes exist requires time 
greedy partitioning algorithm requires bd time partition nodes partitions combined arbitrarily 
nal test involving duplicate creation require time 
remaining modi cations sdg require time assuming set copy bg materialized size 
leaves complexity 
dependent assignment removal rule rule starts possible takes time attempt nd exists 
node ow successors potential takes time test path exists nding requires de time 
conservative 
union find algorithm example reduce complexity practice degree small additional algorithmic complexity warranted 
remaining conditions rst line rule require constant time verify 
general testing implication unsolvable 
simple safe system compare term term recall essentially conjunctive normal form log time number terms requires constant number bit vector operations test 
combining terms yields de log 
dependent assignment removal rule induction variable elimination rule starts candidate finding verifying init require time 
symbolic computation depends expressions init complexity represented 
updates rule require time total time rule 
complexity syntax preserving slicing recursive call worst case complexity de log 
rule reduces aspect graph 
example anti fusion reduces size loop body ow edge removal shortens length ow edge chains 
ensures recursion terminate 
purely pathologic case anti fusion rule divide single loop program half times 
similar cases exist rules resulting complexity de log somewhat misleading transformations act locally 
larger program simply locales require recursive iterations 
furthermore log dominate de informative statement complexity nde 
empirical study safety slicing claim application algorithm improves comprehension evaluated section presents series experiments designed assess ectiveness safety slicing 
experiments qualitative quantitative methods gauge ectiveness safety slicing helping programmer identify array subscript violations 
section begins discussion experimental setup design 
considers quantitative results followed subjective results provide context numerical data 
experimental setup design experiment designed test general hypothesis safety slice assists program comprehension 
speci cally hypotheses test experiment safety slices human debugging array safety accurate safety slices human debugging array safety ecient 
subjects participated controlled experiments 
groups included students half way rst second third years study college 
students year divided control group experimental group 
rst year students groups created simply separate sections course taught instructor 
believed provide sucient random distribution talent 
unfortunately assumption incorrect 
obvious students con rmed instructor 
second third year students divided class standing providing uniform distribution talent 
test hypotheses groups de nition array bounds violation worked example brief minute lecture array bounds violations 
person gave lecture groups 
rst year students back back classes 
second third year students simultaneously groups 
cases set notes followed avoid biasing particular group 
order train subjects safety slices lecture included explanation safety slicing safety slice searching array violations 
groups programs containing array subscript violations 
addition experimental groups received safety slice program 
programs included training exercises designed determine subjects understood task program generate results section 
experiment programs students completed questionnaire asked participants subjectively rate performance con dence diculty problems 
group remainder lecture period nd array subscript violations 
interesting note syntax preserving slice programs study essentially entire program cases amorphous slice smaller syntax preserving slice 
combined results experiment suggests amorphous slicing provides additional comprehension bene syntax preserving slicing 
quantitative results statistical evidence safety slicing assists program comprehension 
part improved subjects ability identify array access violations 
experiments involving novice programmers rst null hypothesis rejected possible conclude amorphous slicing assisted programmers 
noted subjects weeks study arrays subjects probably premature 
contrast experienced groups experimental subjects able consult safety slice signi cantly outperformed control group 
subjectively safety slicing improved eciency result statistically signi cant 
data related hypothesis groups summarized 
row labeled year experimental represents subset experimental group answered understood safety results summary group year control year experimental year experimental second year control second year experimental third year control third year experimental fig :10.1.1.39.1532

empirical study results average number correct responses year control year experimental year experimental second year control second year experimental third year control third year experimental fig 

mean con dence intervals groups slice represented 
exception rst year experimental group mean scores increase experience level access safety slice 
graph shows mean con dence interval group 
graph short vertical bars represent means longer horizontal bars represent con dence intervals 
gure direct comparison groups requires test di erence means 
show con dence expected mean 
furthermore trend length lines illustrates decrease standard deviation experience 
data related hypothesis meaningful second year students 
di erent reasons rst third year students didn produce meaningful timing numbers binkley 
subjectively experimental groups nished faster completed problems time 
result statistically signi cant 
comparing various groups study sided test involving di erence means tests groups small 
null hypothesis case alternative hypothesis experimental group higher mean score 
case value common standard deviation degrees freedom 
value interpreted follows values highly signi cant values signi cant values weakly signi cant 
analysis assumes parent populations normal deviations known robust non normality data 
analysis assumes standard deviations populations unequal 
repeating analysis assuming equal ect 
numerically values change 
subjects safety slicing signi cant improve identifying array bounds violations 
replacing rst year students subset rst year students said understood safety slicing produces dramatic turnaround 
safety slicing clearly helps 
importantly considering advanced second third year students safety slicing quite ective 
study lends empirical support assertion amorphous slicing assists program comprehension 
subjective results third year subjects asked rank con dence answers guessed sure 
subjects lled con dence ranking experimental group subject marked array identi ed safe safety slice 
subject marked guess got wrong 
experimental group con dence rankings array safety slice provided guidance 
contrast con dence rankings control group slightly lower evenly distributed possible responses 
indicates control group working need 
experiment included qualitative questions designed provide subjective context numerical data 
general responses indicated subjects safety slice technique liked 
individual responses question nd safety slice helpful nding errors included helped nd confused answer rst year student points need better training 
student responded safety slice helpful especially harder programs 
second year student responded somewhat gave idea fig 

slightly amorphous slice errors exactly safety slice designed 
third year student responded nice see possible problems code displayed 
related authors indicated syntactic subset requirement slicing hindrance computation small slices 
authors implicitly seeking construct amorphous slices 
abandon syntactic requirement altogether 
sought remain faithful original syntax possible producing reasonably small slices 
previous slightly amorphous slices brie reviewed followed discussion techniques combine slicing transformation 
slightly amorphous slicing envisaged weiser weiser slice syntactic subset program constructed 
thesis weiser immediately recognized acknowledged weiser page possible slice constructed purely faithful subset original program syntax 
example happens program syntax rich statement deletions considered syntactically valid programs 
consider slicing program 
suppose programming language allow empty clauses 
ideally slice constructed respect nal value consist deleting part conditional leads syntactically invalid program 
order maintain syntactic subset original program slice forced include original program 
awkward 
possible alternative slice shown right hand section 
produce slice minor syntactic re write required 
rewrite appear take slice far away syntax original 
strictly speaking slice right hand section gure course slightly amorphous slice 
int int int int int int scanf scanf scanf original program non executable slice amorphous slice fig 

pointer problems syntax preservation authors lyle binkley choi ferrante necessary create slightly amorphous slices order avoid restrictions imposed purely syntax preserving straight jacket 
authors implicitly amorphous slices indicating idea removing syntactic restriction syntax preserving slicing wholly new previously useful 
considering problems associated slicing programs pointers lyle binkley lyle binkley showed unnecessary statements computation ect values stored variables slicing criterion need included order ensure slice program containing pointers executable 
problem illustrated example 
consider slice program respect nal value variable possible slice depicted central section 
unfortunately value entered variable non zero pointer variable remains uninitialized execution may abort 
pure syntax preservation requirement dictate assignment address line associated computation included 
lead dramatic increase size slice 
possible remedy considered lyle binkley inclusion slice additional new guards 
approach yield slightly amorphous slice depicted rightmost section 
choi ferrante faced similar problem attempting slice unstructured programs 
presence goto statements original slicing algorithm ottenstein ottenstein horwitz produce correct slices 
goto statement source transitive control dependence predicate transitive data dependence assignment 
solution adopted choi ferrante choi ferrante con sider goto pseudo predicate true edge target original goto false edge fall node control pass goto deleted 
ball horwitz ball horwitz agrawal agrawal independently developed algorithms produce similar results 
choi ferrante observed reformulation goto predicate created spurious control dependences lead dramatic increases slice size 
overcome considered alternative approach new goto statements added slice 
new goto statements essentially nodes slice identi ed pdg algorithm 
ensure exists path original program containing nodes retained slice exists associated path slice containing nodes order 
alternative choi ferrante second algorithm choi ferrante introduces new goto statement 
new goto statements causes algorithm deviate syntax preserving requirement syntax preservation 
choi ferrante completely drop syntactic requirement problem slicing unstructured programs interesting goto removal algorithm ashcroft manna algorithm ashcroft manna algorithm peterson peterson applied original program followed conventional slicing resulting structured program 
combining transformation slicing ernst considered inter alia possibility slicing optimized code 
ernst comes close suggesting full amorphous slicing says compiler transformations constant folding dead code elimination elimination partial redundancies update program structure re ect knowledge gleaned analyses 
analysis transformation remove simplify dependence relations making better approximation true dependences underlying computations slicing optimization produces precise informative slices 
ernst similar transformations ernst describes implementations described section 
ernst considers transformation inform slicing draws back amorphous slice construction 
information gleaned sharpen precision syntax preserving slicing 
fig 

slicing optimized code example ernst considers problem slicing program fragment reproduced 
slice constructed respect nal value variable fragment consists entire program 
compiler optimization result result produced amorphous slicing 
tip tip considered example constant propagation statically determine value predicates statements eliminating predicates controlled branches code predicates depend 
tip tip suggested computation slices mixture slicing transformation algorithm consisting components translation program suitable intermediate representation ir 
transformation optimization ir 
maintaining mapping source text original ir optimized ir 
extraction slices ir 
sequence steps similar algorithms considered ast sdg ir tip algorithmic schema 
essential di erence algorithms include iteration domain speci transformations improves simpli cation power 
example tip considered problem slicing program fragment column respect nal value variable tip goal produce slice column gure 
syntax preserving slicing algorithms produce slice assume paths feasible 
tip pointed slicing algorithm capable merging conditionals produce optimized program column ought capable producing slice column 
tip goal drop restriction syntax preservation 
slice column syntax preserving 
small step syntax preserving slice optimized program amorphous slice section 
amorphous slice computed syntax preserving slicing optimized version column 
scanf scanf scanf scanf scanf scanf scanf scanf printf printf original optimized version syntax preserving slice amorphous slice fig :10.1.1.39.1532

tip optimization example corresponding amorphous slice harman danicic harman danicic showed slicing support testing focusing value pseudo variable 
early form termed safety slicing 
combination slicing ah hoc transformations term amorphous slice coined harman danicic detailed algorithms appear binkley 
gerber hong gerber hong described approach scheduling relies slicing identify observable parts real time system interact environment operations unobservable components perform 
unobservable computations need time frame allocated task moved task computation increasing schedulability 
system mixes slicing single transformation code motion simply re order computation delete computations 
systems produce amorphous slices 
norris pollock norris pollock considered register allocation pdg intermediate representation 
algorithm consists phases 
initial phase consists bottom register allocation pass 
pass uses graph colouring algorithm exploits pdg hierarchical structure allocate registers 
second third phase implement specialized code motion redundant computation elimination transformations 
code motion consists moving register store retrieve operations loop bodies possible 
redundant code removal phase simply eliminates unnecessary store retrieve operations created allocation motion phases 
system perform slicing pdg clearly little additional ort 
transformations second third passes considered examples termed domain speci tailored special goal optimized register allocation 
das das introduced technique partial evaluation system representation graph srg 
main goal show srg suitable representation computing binding time analysis phase partial evaluation 
das considered problem constructing residual program intraprocedural variant srg called program representation graph prg 
rule propagation expressions generalization constant propagation rule introduced das page thesis das :10.1.1.39.1532
field ramalingam field ramalingam described experience cobol restructuring tool theory underlying 
tool rewrite unstructured control ow embodied perform paragraph procedural abstraction cobol 
restructured program equivalent sense contains valid paths original behaved cases contains additional paths 
restructuring phase pre processing phase prior analyses including slicing 
slices restructured program considered amorphous slices original syntactic subsets original program 
liao described suif tool liao parallelization tool contains transformations automated semi automated parallelization 
suif contains interprocedural slicing analysis phase detect independent parallelizable array accesses determine previously computed loop dependent computations ect subsequent iterations 
tool contains ability mix slicing transformation purpose suif combination supported explored 
corbett corbett describe bandera tool extracting nite state models java 
models veri cation model checkers 
tool includes syntax preserving slicer allows ed transformations added adapted implement amorphous slicing currently possess ability 
harman harman introduced general purpose amorphous slicing system transformation system fermat developed ward ward 
system produces similar amorphous slices sdg approach described produce slices tailored address array access safety problem uses syntax tree ast internal data structure sdg 
ward ward introduced approach slicing wsl programs hoped easily generalised produce amorphous static conditioned slices mixing new primitive transformation slicing existing fermat wsl transformations available fermat transformation workbench 
ward introduces notion semantic slice generalisation amorphous slicing allows abstraction speci ca tion level addition non syntax preserving slicing 
slicing ideas applied declarative languages harman danicic ahn han nilsson fritzson transformation common comparatively straightforward semantics languages concerned 
slices automatically amorphous slices arises consequence linguistic formulation statement deletion clearly meaningless concept 
mark harman supported part engineering physical sciences research council gr gr gr development daimlerchrysler ag 
david binkley supported national science foundation ccr 
sebastian danicic part supported engineering physical sciences research council gr gr 
preliminary versions material appeared conferences harman danicic binkley binkley 
summary traditional approaches slicing simplifying transformation create slices component deletion 
choice motivated original application slicing debugging syntax preserving nature slice important 
restriction statement deletion necessary applications slicing emerged slicing originally introduced 
greater simpli cation power possible restriction statement deletion lifted clearly advantageous lift restriction situations syntax preservation relatively unimportant compared slice size 
de ned amorphous slicing compared traditional syntax preserving slicing 
algorithm computing amorphous safety slices results empirical study performed implementation algorithm 
study showed amorphous slicing assists programmers understanding array safety access issues 
study illustrated utility philosophy programs answers undecidable propositions hypotheses concerning subject program expressed slicing criteria answers returned form smaller programs 
particular answer hypothesis holds approximated amorphous program slicing 
approximate nature approach avoids known decidability problems associated attempt provide de nite answer 
agrawal agrawal 

slicing programs jump statements 
acm sigplan conference programming language design implementation pages orlando florida 
proceedings sigplan notices june 
ahn han ahn han 

static slicing rst order functional language operational semantics 
technical report cs tr kaist korean advanced institute science technology 
andersen andersen 

program analysis specialization programming language 
phd thesis diku university copenhagen 
diku report 
ashcroft manna ashcroft manna 

translation goto programs programs 
rosenfeld editors proceedings ifip congress volume pages 
north holland 
ball horwitz ball horwitz 

slicing programs arbitrary control ow 
fritzson editor st conference automated algorithmic debugging pages link oping sweden 
springer 
available wisconsin madison technical report extended form tr december 
beck eichmann beck eichmann 

program interface slicing reverse engineering 
ieee acm th conference software engineering icse pages :10.1.1.39.1532
ieee computer society press los alamitos california usa 
bieman ott bieman ott 

measuring functional cohesion 
ieee transactions software engineering 
binkley binkley 

precise executable interprocedural slices 
acm letters programming languages systems 
binkley binkley 

interprocedural constant propagation dependence graphs data ow model 
fritzson editor proceedings international conference compiler construction edinburgh scotland pages 
lecture notes computer science volume springer verlag 
binkley binkley 

semantics guided regression test cost reduction 
ieee transactions software engineering 
binkley binkley 

application program slicing regression testing 
harman gallagher editors information software technology special issue program slicing volume pages 
elsevier 
binkley binkley 

computing amorphous program slices dependence graphs data ow model 
acm symposium applied computing pages menger san antonio texas acm press new york ny usa 
binkley gallagher binkley gallagher 

program slicing 
zelkowitz editor advances computing volume pages 
academic press 
binkley binkley harman smith 

empirical study amorphous slicing program comprehension support tool 
th ieee international workshop program comprehension iwpc pages limerick ireland 
ieee computer society press los alamitos california usa 
binkley binkley horwitz reps 

program integration languages procedure calls 
acm transactions software engineering methodology 
canfora canfora cimitile de lucia 

conditioned program slicing 
harman gallagher editors information software technology special issue program slicing volume pages 
elsevier science cartwright felleisen cartwright felleisen 

semantics program dependence 
acm sigplan conference programming language design implementation pages 
choi ferrante choi ferrante 

static slicing presence goto statements 
acm transactions programming languages systems 
cimitile cimitile de lucia munro 

speci cation driven slicing process identifying reusable functions 
software maintenance research practice 
corbett corbett dwyer laubach pasareanu robby zheng 

bandera extracting nite state models java source code 
nd international conference software engineering icse pages 
ieee computer society press los alamitos california usa 
das das 

partial evaluation dependence graphs 
phd thesis university wisconsin madison 
de lucia de lucia 

program slicing methods applications 
st ieee international workshop source code analysis manipulation pages florence italy 
ieee computer society press los alamitos california usa 
de lucia de lucia munro 

understanding function behaviours program slicing 
th ieee workshop program comprehension pages berlin germany :10.1.1.39.1532
ieee computer society press los alamitos california usa 
ernst ernst 

practical ne grained static slicing optimised code 
technical report msr tr microsoft research redmond wa 
ferrante ferrante ottenstein warren 

program dependence graph optimization 
acm transactions programming languages systems 
field ramalingam field ramalingam 

identifying procedural structure cobol programs 
proceedings acm workshop program analysis software tools engineering volume software notes sen pages acm press 
fischer leblanc fischer leblanc 

crafting compiler 
benjamin cummings series computer science 
benjamin cummings publishing menlo park ca 
gallagher lyle gallagher lyle 

program slicing software maintenance 
ieee transactions software engineering 
gerber hong gerber hong 

slicing real time programs enhanced schedulability 
acm transactions programming languages systems 


deriving analysers folding sol unfolding natural semantics case study slicing 
technical report rr inria institut national de recherche en informatique en automatique 
gupta gupta harrold 

approach regression testing slicing 
proceedings ieee conference software maintenance pages orlando florida usa 
ieee computer society press los alamitos california usa 


static slicing logic programs 
editor nd international workshop automated algorithmic debugging pages saint malo france 
irisa cnrs 
harman danicic harman danicic 

projecting functional models imperative programs 
acm sigplan notices 
harman danicic harman danicic 

program slicing simplify testing 
software testing veri cation reliability 
harman danicic harman danicic 

amorphous program slicing 
th ieee international workshop program iwpc pages michigan usa 
ieee computer society press los alamitos california usa 
harman harman fox hierons binkley danicic 

program simpli cation means approximating undecidable propositions 
th ieee international workshop program iwpc pages pittsburgh pennsylvania usa 
ieee computer society press los alamitos california usa 
harman hierons harman hierons 

overview program slicing 
software focus 
harman harman hu zhang munro 

amorphous slicing system combines slicing transformation 
st workshop analysis slicing transformation ast pages stuttgart 
ieee computer society press los alamitos california usa 
harman harman hu zhang munro 

side ect removal transformation 
th ieee international workshop program comprehension iwpc pages toronto canada 
ieee computer society press los alamitos california usa 
hierons hierons harman danicic 

program slicing assist detection equivalent mutants 
software testing veri cation reliability 
hierons hierons harman fox 

conditioned slicing supports partition testing 
software testing veri cation reliability 
horwitz horwitz prins reps 

integrating non interfering versions programs 
acm transactions programming languages systems 
horwitz horwitz reps binkley 

interprocedural slicing dependence graphs 
acm transactions programming languages systems 
kamkar kamkar 

interprocedural dynamic slicing applications debugging testing 
phd thesis department computer science information science link oping university sweden 
available link oping studies science technology dissertations number 
korel laski korel laski 

dynamic program slicing 
information processing letters 
krinke snelting krinke snelting 

validation measurement software application slicing constraint solving 
harman gallagher editors information software technology special issue program slicing volume pages 
elsevier 
lakhotia lakhotia 

rule approach computing module cohesion 
proceedings th conference software engineering icse pages 
lakhotia lakhotia 

restructuring programs statements functions 
harman gallagher editors information software technology special issue program slicing volume pages 
elsevier 
liao liao diwan bosch jr lam 

suif explorer interactive interprocedural 
chien snir editors proceedings acm sigplan symposium principles practise parallel programming ppopp volume acm sigplan notices pages acm press 
liu ellis liu ellis 

approach eliminating common blocks deriving adts fortran programs 
technical report university uk 
lyle binkley lyle binkley 

program slicing presence pointers 
foundations software engineering pages orlando fl usa 
lyle weiser lyle weiser 

automatic program bug location program slicing 
nd international conference computers applications pages 
ieee computer society press los alamitos california usa 
nilsson fritzson nilsson fritzson 

lazy algorithmic debugging ideas practical implementation 
fritzson editor automated algorithmic debugging volume lecture notes computer science pages 
springer verlag 
norris pollock norris pollock 

design implementation rap pdg register allocator 
software practice experience 
ott ott 

slice metrics estimating cohesion 
proceedings ieee cs international metrics symposium pages baltimore maryland usa 
ieee computer society press los alamitos california usa 
ottenstein ottenstein ottenstein ottenstein 

program dependence graph software development environments 
sigplan notices :10.1.1.39.1532
peterson peterson kasami 

capabilities repeat exit statements 
communications acm 


hybrid backward slicing algorithm producing executable slices prolog 
proceedings th workshop logic programming environments pages portland usa 


generalized algorithmic debugging 
phd thesis department computer science information science link oping university sweden 
available link oping studies science technology dissertations number 
simpson simpson mitchell liu ellis 

maintaining fortran 
acm fortran forum 
harman danicic 

slicing implicit state 
kamkar editor rd international workshop automated debugging volume link oping electronic articles computer information science pages link oping sweden 
url www ep liu se ea cis 
steensgaard steensgaard 

points analysis linear time 
acm editor conference record popl rd acm sigplan sigact symposium principles programming languages papers symposium st petersburg beach florida january pages new york ny usa 
acm press 
tip tip 

generation program analysis tools 
phd thesis centrum voor wiskunde en informatica amsterdam 
tip tip 

survey program slicing techniques 
journal programming languages :10.1.1.39.1532
venkatesh venkatesh 

semantic approach program slicing 
acm sigplan conference programming language design implementation pages toronto canada 
proceedings sigplan notices pp 
ward ward 

reverse engineering formal transformation 
computer journal 
ward ward 

program slicing fermat transformations 
th ieee annual computer software applications conference compsac oxford uk 
ieee computer society press los alamitos california usa 
appear 
weiser weiser 

program slices formal psychological practical investigations automatic program abstraction method 
phd thesis university michigan ann arbor mi 
weiser weiser 

programmers slicing debugging 
communications acm 
weiser weiser 

program slicing 
ieee transactions software engineering 

