protecting data privacy private information retrieval schemes yael yuval ishai eyal kushilevitz tal malkin private information retrieval pir schemes allow user retrieve th bit bit data string replicated databases information theoretic setting databases computational setting keeping value private 
main cost measure scheme communication complexity 
introduce model symmetrically private information retrieval spir privacy data privacy user guaranteed 
invocation spir protocol user learns single physical bit information data 
previously known pir schemes severely fail meet goal 
show transform pir schemes spir schemes information theoretic privacy paying constant factor communication complexity 
introduce utilize new cryptographic primitive called conditional disclosure secrets believe may useful building block design cryptographic protocols 
particular get database spir scheme complexity constant log database spir scheme complexity log 
log log 
schemes require single round interaction resilient dishonest behavior user 
results yield rst implementation distributed version ot oblivious transfer information theoretic security sublinear communication complexity 
private information retrieval pir schemes allow user retrieve information database maintaining query private 
model database viewed bit string user retrieves th bit giving database information index main cost measure schemes communication complexity 
notion pir preliminary version appeared stoc 
department computer information science university pennsylvania philadelphia pa usa 
mail saul cis upenn edu 
supported darpa dabt 
department computer science technion haifa israel 
mail cs technion ac il department computer science technion haifa israel 
mail cs technion ac il url www cs technion ac il laboratory computer science massachusetts institute technology cambridge ma 
mail tal theory lcs mit edu 
supported darpa dabt 
introduced shown copy database available bits communication needed information theoretic user privacy 
non communicating copies database solutions better sublinear communication complexity 
introduce stronger model symmetrically private information retrieval spir privacy data user guaranteed 
invocation spir scheme addition maintaining user privacy prevents user dishonest obtaining information single physical bit data 
data privacy natural crucial requirement settings 
example consider commercial database sells information stock information users charging amount data user retrieved 
user privacy data privacy essential 
original pir model concerned user privacy requiring protection data privacy 
previous pir schemes allow user obtain physical bits data information exclusive certain subsets bits example happens single invocation best database information theoretic scheme currently known user systematically retrieve physical bits data see section example 
eciently realize spir schemes introduce utilize new cryptographic primitive called conditional disclosure secrets may independent interest building block designing general cryptographic protocols 
informally conditional disclosure secrets allows set players disclose secret external party carol subject condition joint inputs 
setting consider carol knows inputs held players secret conditionally disclosed knows condition holds obtain secret 
player hand sees portion input necessarily know carol obtain secret 
protocol involves unidirectional communication players carol 
simple example illustrates conditional disclosure secrets player input bit indicating agrees reveal secret carol 
carol obtains secret subject condition majority players agree reveal secret 
concerned information theoretic setting spir 
techniques applied computational pir schemes privacy requirement relaxed computational privacy computationally bounded databases :10.1.1.26.7042
computational setting better solution realizing spir may constructed pseudo random functions 
note addition theoretical signi cance unconditional security information theoretic schemes possess advantages known computational schemes time ecient communication complexity typically smaller moderately sized data strings asymptotic complexity higher 
realizing spir involves modi cation previous multi database model 
necessary information theoretic spir schemes regardless complexity possibly achieved original pir setting databases interact see appendix 
minimal extension original setting continue disallow direct interaction databases access shared random string unknown user 
similar kind extension studied contexts private computation non interactive zero knowledge scenarios 
extension particularly natural basic pir setting databases required maintain identical copies data string 
subsection discuss alternative approach shared pseudo random strings sharing truly random strings 
results construct ecient spir schemes sublinear communication complexity may improved better pir schemes designed 
precisely transformations pir schemes spir schemes preserving user privacy guaranteeing data privacy small penalty communication complexity 
give types reductions 
general reduction show pir scheme possible construct spir scheme number rounds constant factor overhead communication complexity linear shared randomness query 
resultant spir scheme requires additional auxiliary database need hold original data shared random string 
achieve database spir scheme communication complexity database pir scheme complexity 
additional database requirement may costly 
particular allow obtain information theoretic sublinear spir solution databases 
case important minimal number databases required solution exist 
speci reductions manage avoid additional database particular obtain solution database case 
speci reductions require signi cantly shared randomness 
speci reductions reductions exploit speci structural properties existing pir schemes transform spir schemes number databases underlying pir scheme communication complexity small constant factor pir scheme shared randomness complexity query order magnitude communication complexity 
particular extending schemes obtain database spir scheme complexity constant log database spir scheme complexity log 
log log 
schemes maintain general paradigm existing pir schemes databases hold identical copy protocols single queries answers round 
willing settle computational privacy data maintaining information theoretic privacy user consider slight variation model replacing shared random strings pseudo random ones 
speci cally databases may share short random seed longer shared pseudo random strings generated extra communication 
allows databases save storage space save amount random bits need produce 
pseudorandom functions possible databases execution protocol directly expand seed portion expanded string needed particular execution expanding string 
results cited pir works concentrate mainly case privacy 
general notion privacy requires view collusion databases independent user retrieval index generalization spir protocols satis es stronger privacy requirement described subsection 
note restrict attention retrieval single bits retrieval blocks consisting multi bit records 
subsection address block retrieval show single round schemes concentrating single bit records compromise generality 
describe generalize results multi round schemes achieving spir multi bit records 
interesting observation spir problem may viewed distributed version known cryptographic primitive called oblivious transfer ot 
ot protocol allows bob secretly choose secret bits held alice way protocol bob learns single bit choice alice learns bob choice 
results give rst round distributed implementations ot information theoretic security sublinear communication complexity 
ot useful tool cryptographic protocol design hope spir useful tool design cryptographic protocols 
related private information retrieval information theoretic user privacy introduced schemes achieve communication complexity bits databases bits databases log log log bits log databases 
database upper bound improved constant see improved dependence generalization privacy 
computational counterpart pir schemes user privacy respect polynomial time databases relying certain intractability assumptions rst considered show obtain schemes communication complexity constant databases assuming existence way functions 
rst computational pir scheme single database obtained achieving communication complexity constant quadratic residuosity assumption 
single database computational pir polylogarithmic communication complexity new intractability assumption called hiding assumption :10.1.1.26.7042
schemes require single round queries answers 
shown necessary assumption single database pir communication complexity existence way functions 
result strengthened show oblivious transfer necessary pir 
subsequent computational counterpart spir addressed showing ecient transformation single database low communication pir spir transformation constructed assuming oblivious transfer primitive assumption removed constructing primitive pir 
organization section introduce notations basic de nitions 
section show general transformation pir schemes spir schemes including conditional disclosure secrets subsection 
sections speci schemes outperform ones obtained applying general transformation 
section includes spir schemes rely user honest 
section schemes keep data private possibly dishonest user minor extra communication cost 
section contains extensions generalization results subsection generalizes results block retrieval multi bit records subsection generalizes results schemes higher levels user privacy privacy coalitions databases subsection outlines generalization spir called private retrieval costs techniques results 
appendix contains proof impossibility spir usual pir setting direct interaction databases shared randomness appendix gives lower bound amount shared randomness necessary general pir spir transformation 
preliminaries general notations de nitions notations conventions 
denote set def denote additive group residues modulo 
sets denote symmetric di erence sns ns 
set denote characteristic vector bit binary string th bit equal simplify notation fjg fjg respectively 
binary string weight denote number nonzero entries particular weight 
tuple index set yj denote restriction entries indices default referring random choice element nite domain associated distribution uniform random choice independent random choices 
addition multiplication operations carried nite eld group implied context 
boolean function called monotone 
boolean formula variables labeled binary tree leaves representing inputs labeled literals fy internal nodes representing boolean operators labeled 
formula computes boolean function natural way 
formula said monotone leaves labeled positive literals implies function formula computes monotone 
size formula measured number leaves 
pir schemes denote number databases db denote th database denote bit data string held databases denote user denote position called index data bit user wants retrieve 
pir scheme randomized protocol db db access random input unknown databases db db access shared random input unknown user round protocol messages exchanged user databases queries sent user database answers sent database user 
view user protocol denoted view consists input random input answers received databases execution protocol inputs 
similarly view th database denoted view consists data string shared random input queries sent user db execution protocol 
execution user applies reconstruction function view outputs corresponding value view 
party user database pir scheme called honest follows protocol speci cation 
user interacts possibly dishonest databases db db denote view th database view 
similarly databases db db interact possibly dishonest user denote view user view 
private information theoretic pir scheme protocol satis es requirements correctness user databases honest user reconstructs data bit view user privacy view single database independent retrieval index formally possibly dishonest databases db db interacting honest user shared random input data string retrieval indices database index view view db pr view view pr view view noted de nition pir schemes literature allow shared randomness databases 
context pir de nitions equivalent 
spir context shared randomness crucial 
spir schemes spir scheme pir scheme invocation scheme user learn information doesn follow single physical bit data 
formally spir scheme satisfy addition correctness user privacy requirements third requirement data privacy possibly dishonest user interacting honest databases db db random input held exists index data strings satisfying view view pr view view pr view view assumed loss generality databases deterministic 
case pir literature interested single round schemes 
de nitions may take slightly simpler form schemes restricted single round 
argue de nition yields intuitive notion data privacy 
intuitive notion want capture user learn information data follow single physical bit 
may tempted require user exists single index view independent data string stronger variant de nition satis ed 
see consider spir scheme satisfying requirement consider user starts randomly choosing index proceeds run retrieval index clearly single index view user depends 
de nition requires random string held user user explicitly implicitly index view depends note equivalent formulation data privacy requirement deterministic user exists index user view independent data string honest user spir scheme pir scheme satis es data privacy requirement respect honest curious user follows scheme speci cation may try deduce extra information communication 
notice formulation model concerned answering single retrieval query single user 
multiple queries possibly originating di erent users may handled independent repetitions single query scheme invocation databases independent source shared randomness fresh portion single shared random string 
default terms pir scheme spir scheme refer round query information theoretically private schemes 
complexity main complexity measure pir spir schemes communication complexity 
communication complexity database scheme denoted total number query bits sent user databases total number answer bits sent databases user data string size single parameter measure communication complexity scheme total communication complexity 
shared randomness complexity spir scheme de ned entropy shared random input equals length string case uniformly distributed strings xed length 
de nitions subsections address aspect computational eciency protocols constructed computationally ecient polynomial 
note user priori information regarding data string retrieval priori information may give information bits obviously unavoidable 
general reduction spir pir section construction spir scheme pir scheme blackbox 
construction introduces overhead single auxiliary database constant factor communication complexity linear amount shared randomness corresponding pir scheme 
auxiliary database need hold copy data string needs access shared random string speci cally general reductions 
rst respect honest user costs additive logarithmic factor communication complexity subsection 
second strengthens rst deal user possibly dishonest subsection 
constructed utilizing new cryptographic primitive called conditional disclosure secrets introduced subsection sections 
note reductions theorems stated proved single round pir generalized apply pir schemes number rounds 
general reduction respect honest users theorem 
round database pir scheme communication complexity 
exists round database honest user spir scheme communication complexity dlog ne shared randomness complexity proof 
simplify notation assume index taken set 
scheme involves databases db db corresponding databases original scheme auxiliary database db databases share random string scheme proceeds follows queries user picks queries speci ed pir scheme independently picks random shift amount 
user sends db shift amount 

query user sends shifted index def 
modn db answers database db locally computes virtual data string def 
denotes bitwise exclusive 
denotes cyclic shift random string 
places right 
db answers query original pir scheme respect computed string auxiliary database db replies single bit reconstruction user reconstructs rst reconstructing answers db db bit pir scheme computing exclusive bit bit received db correctness reconstruction step yields proves correctness user privacy follows privacy fact additional queries 
uniformly distributed independently queries show scheme meets data privacy requirement respect honest user general claim 
claim 
hi 


tuple queries possibly necessarily picked honest user 
suppose 


def 
joint answers db db corresponding queries independent 
probability space choice sum 
taken modulo 
proof 
def 
note virtual data string computed database db process answering query consider joint distribution 
distribution uniform set 

depending 
determines answers db db answer db follows joint distribution answers query tuple depends 

claim implies distribution view honest user holds input random input depends single data bit honest user sets 



shows data privacy respect honest user concludes proof theorem 
note scheme dishonest user send invalid queries send di erent shifts 
di erent databases 
claim dishonest behavior potentially give user information data 
words user sends shifts databases data privacy maintained regardless validity queries 
extend scheme dishonest user suce databases sees single 
send answers disguised user learns answers condition 

satis ed 
primitive conditional disclosure secrets introduced subsection 
natural question regarding transformation shared randomness complexity may reduced 
partial answer question appendix shown transformation general applicable underlying pir scheme shared bit string uniformly distributed linear shared randomness required regardless communication complexity underlying pir scheme 
note claim implies trivial database pir scheme entire data string sent user database spir scheme constructed resilient dishonest user 
corollary 
exists round database spir scheme communication complexity dlog ne shared randomness complexity scheme inecient requires linear communication complexity subprotocol small data strings constructions 
conditional disclosure secrets subsection describe implement new cryptographic primitive called conditional disclosure secrets cds short 
primitive subsection obtain general reduction spir pir user behavior 
informally conditional disclosure setting involves players holding input external party carol knows inputs held players 
addition secret known players carol 
goal players disclose secret carol subject condition joint input condition holds carol learns secret doesn obtains information secret 
model allows players access shared random string hidden carol communication allowed single unidirectional message sent player carol 
simple example illustrating cds player input bit condition disclosing secret carol majority players bits set 
formal de nition 
convenience start de ning version secret disclosed known players call version conditional disclosure common secret 
xed boolean function condition partition sets called th player input portion sd secret domain binary strings particular length 
conditional disclosure common secret condition input partition secret domain sd consists set players modeled functions external party carol follows 
denote shared random input players drawn distribution xed input sd secret de ne random variable yj th player message randomness choice conditions hold 
correctness carol condition holds carol able reconstruct secret input messages received 

secrecy sd tuples random variables yj yj identically distributed probability choice 
condition hold carol obtains information secret messages received carol identically distributed possible secrets 
similar version de ned secret known players necessarily 
case yj players hold message constructed portion input shared randomness 
call general version conditional disclosure secret 
communication complexity conditional disclosure protocol maximal total size messages sent players choices shared randomness complexity entropy note model conditional disclosure similar non interactive model private computation described subsection 
known results sense general model sucient yield solutions conditional disclosure problem 
instance results imply conditional disclosure protocols communication quadratic size branching program formula describing condition see discussion 
solutions obtained general results usually ecient purposes 
show achieve ecient solutions communication linear size reduction generalized secret sharing show implement conditional disclosure secrets arbitrary condition reducing generalized secret sharing relative corresponding access structure 
generalized secret sharing 
problem generalized secret sharing extension usual notion secret sharing 
informally generalized secret sharing protocol randomized protocol sharing secret shares secret reconstructed quali ed set shares combination ed set shares give information secret 
formally generalized secret sharing scheme secret domain sd de ned triple dealing function maps secret sd random input tuple shares hs distribution random input chosen reconstruction function maps set jaj tuple shares reconstructed secret sd 
collection quali ed sets speci ed monotone boolean function hm called access structure set shares said quali ed hm said ed 
scheme said generalized secret sharing scheme realizing access structure hm satis es requirements correctness quali ed set secret sd random input reconstruction succeeds secrecy ed set secrets sd random variables identically distributed probability choice distributed 
share complexity maximum total size shares tuple randomness complexity entropy lemma 
hm monotone boolean function 
boolean function de ned hm depends single variable fy referred projection hm 
generalized secret sharing scheme secret domain sd realizing access structure hm share complexity randomness complexity partition players inputs exists protocol disclosing common secret sd subject condition communication complexity shared randomness complexity proof 
recall cds protocol involves players holding portion input player holds secret sd 
players wish reveal secret carol subject condition 
show construct generalized secret sharing scheme realizing access structure hm hm protocol uses shared random string distributed proceeds follows 
player evaluates generating tuple shares hs note players generate shares secret random input evaluating 
player includes share message sent carol conditions hold owned evaluates 
message sent carol player consists restriction shares hs satisfy conditions 
observe input variable held player carol receives exactly shares 
observation hm carol exactly de nition generalized secret sharing quali ed set shares reconstruct secret reconstruction function 
hand hm carol receives ed set shares gains information complete proof recall hm carol reconstruct condition holds obtains information shared randomness complexity randomness complexity communication complexity larger share complexity share sent player 
lemma obtain upper bound complexity conditional disclosure secrets depending size formula computing condition 
proof theorem known result complexity generalized secret sharing 
fact 
suppose hm computed monotone boolean formula size exists generalized secret sharing scheme realizing hm sd communication complexity shared randomness complexity bounded theorem 
suppose computed boolean formula size sd 
partition inputs 
exists protocol disclosing common secret bit sd known players subject condition communication complexity shared randomness complexity bounded 
exists protocol disclosing secret bit sd known player subject condition communication complexity shared randomness complexity bounded 
proof 
protocol conditional disclosure common secret bit known players constructed follows 
boolean formula variables computing size replacing negative literal positive literal obtain monotone boolean formula hm size computing monotone function hm 
note projection hm hm 
fact follows lemma players disclose bit subject condition communication bits shared random bits completes proof rst part theorem 
second part protocol conditional disclosure secret bit known player proceeds follows 
players rst conditionally disclose shared random bit known subject condition done protocol described 
single player holding sends bit carol 
clearly carol reconstruct reconstruct obtains information obtain information theorem follows 

best known general upper bounds complexity generalized secret sharing result theorem strengthened apply function span program gf size see de nition span program model 
direct constructions special cases sequel conditional disclosure primitive reductions dealing dishonest behavior user 
applications conditional disclosure require simple condition testing equality inputs 
give direct constructions conditional disclosure protocols realizing speci conditions 
direct constructions ecient ones obtained straightforward application theorem 
stress general results described useful cryptographic scenarios described subsection 
lemma shows ecient implementation conditional disclosure secrets condition tests sum eld elements equals 
implement conditional disclosure secrets condition tests equality strings 
lemma 
nite eld arithmetic operations eld 
suppose players holds input secret known player 
exists protocol disclosing secret subject condition player sends single eld element shared random string consists random eld elements 
proof 
assume loss generality player holds secret independent random elements shared parties 
protocol proceed follows player sends carol single eld element def player sends carol def note inputs add reconstructed sum messages show tuple messages uniformly distributed independently sequence messages de ne support set choices players send sequence messages carol inputs secret 
construction protocol support consists exactly satisfying system equations 
system linear equations variables equations linearly independent adding rst equations yield triangular system equations 
sequence messages support singleton particular sequences size support 
implies uniform distribution eld elements induces uniform distribution messages input tuple nonzero sum secret note lemma outperforms general construction theorem 
general construction communication randomness required disclosing single bit secret larger total size eld elements lower bound size formula evaluating condition speci construction lemma communication randomness size sucient disclosure longer secret eld element 
lemma shows possible reduce communication dominated secret size secret smaller inputs 
lemma 
suppose players holds input string secret string known player 
exists protocol disclosing secret subject condition player sends string length shared randomness complexity 
max 
proof 
nite eld gf standard representation eld elements bit strings element represented coecient vector polynomial associated 
recall element gf may identi ed polynomial gf degree modulo irreducible degree polynomial 
representation de nes isomorphism groups hf hf consider possible cases 
protocol proof lemma letting gf associating secret corresponding eld element input string eld element corresponding bit padding second case protocol gf eld element sent original protocol projected leftmost bits representation eld element originally sent represented string 
message sent carol new protocol bit pre 
key observation representation projection operator commutes eld addition 
sum bit projections sent new protocol equal projection follows observation analysis proof lemma condition holds reconstructed exclusive messages 
hand condition hold original messages uniformly independently distributed follows projected bit messages independently uniformly distributed proves correctness secrecy protocol 
cases player sends message string length speci ed communication bound met cases protocol lemma invoked gf max speci ed shared randomness bound met 
lemma formulated binary strings generalized strings nite eld 
particular result lemma applied conditionally disclosing secret subject condition tests equality strings held players 
protocol clearly outperforms protocol obtainable general result theorem testing equality bit strings requires formula size best protocol obtainable theorem require communication bits conditionally disclosing single bit subject equality bit strings compared communication bits required lemma 
improved eciency obtained lemma subsection 
general reduction respect dishonest users conditional disclosure secrets primitive described theorem gives general reduction pir scheme spir scheme case user possibly dishonest 
theorem 
round database pir scheme communication complexity 
exists round database spir scheme communication complexity dlog ne shared randomness complexity 
proof 
protocol general honest user reduction theorem 
claim satis es data privacy long user sends database db shift amount 
modi cation ectively forcing user send shifts 
user queries answers db auxiliary database db addition db db disclose original answer db subject condition 


dlog ne bit shift sent db 
conditional disclosure implemented lemma 
user privacy original clearly maintained 
scheme meets data privacy requirement conditional disclosure guarantees possibly dishonest user obtain information answers databases db 

claim implies user learns single physical bit data 
spir scheme 
analyze complexity scheme 
denote length answer sent db scheme theorem know 
lemma communication complexity required implement conditional disclosure subprotocol involving databases db db scheme 
total communication sent databases user 
total communication sent user dlog ne 
shared randomness complexity plus randomness required lemma sums max dlog ne 
subsequent sections spir schemes rely speci structural properties underlying pir schemes exploit outperform general transformations 
particular sublinear shared randomness require auxiliary database 
speci spir schemes respect honest users section construct honest user spir schemes perform pir counterparts multiplicative constant terms communication randomness 
constructions utilize primitives private simultaneous messages protocols described conditional disclosure secrets introduced subsection 
schemes rely speci pir schemes literature rst review details pir schemes important constructions 
known pir schemes start describing pir scheme referred basic cube scheme 
scheme basis database scheme described turn serves basis recursive database scheme 
schemes polynomial interpolation scheme described proofs theorems respectively 
basic dimensional cube scheme pir scheme databases 
assume loss generality database size integer 
index set identi ed dimensional cube index naturally identi ed tuple 
dimensional subcube subset 
dimensional cube sm subset 
subcube denoted tuple 
databases assigned binary strings length db scheme proceeds follows 
queries user picks random subcube independent random subsets 
index user wishes retrieve 

user sends database db subcube set represented characteristic bit string 
answers database db computes exclusive data bits residing subcube sends resultant bit user 
reconstruction user computes exclusive bits received 
scheme correctness follows fact bit appears number subcubes appears exactly subcube see details 
communication complexity database scheme worse scheme generalization achieves communication constant number databases scheme scheme may regarded database implementation basic database dimensional cube scheme described 
index data bit retrieved 
databases db db emulates databases db hamming distance index 
done way 
user sends db subcube db subcube basic cube scheme 
answers exclusive empty set bits de ned 
databases include answer bits databases emulates 
db replies answer bit bit long strings contains answer bit databases emulates 
instance th bit string emulating db obtained computing exclusive data bits residing subcube implying th bit string equal symmetrically db sends single bit bit long strings corresponds subcubes obtained masking set possible values altogether user receives answer strings contain bits contain single bits 
bit long strings required answer bit bit string bit bit 
user locate bits answer strings reconstruct computing exclusive 
private simultaneous messages psm model typical pir scheme honest user extract databases answers information just reconstructed value solving problem idea 
consider round pir scheme 
execution scheme user rst produces queries depending index sends query corresponding database response receives answer strings user applies reconstruction function obtain desired bit idea user compute output getting answers obtain information get messages keep privacy string precisely idea captured model non interactive private computation introduced studied called private simultaneous messages psm model 
model players player holding private input string external referee called carol 
players access shared random input unknown carol 
goal psm protocol carol evaluate function learning additional information inputs scenario psm protocol similar conditional disclosure protocol see subsection psm input carol input players formally psm protocol player sends single message carol private input shared random input carol applies reconstruction function messages received 
psm protocol computing argument function satisfy requirements correctness input tuple shared random input value reconstructed carol privacy input tuples messages viewed carol identically distributed 
communication complexity shared randomness complexity psm protocol de ned conditional disclosure secrets model 
denote communication complexity player psm protocol total number input bits held players shared randomness complexity 
upper bounds psm complexity obtained 
particular shown boolean function branching program size partition input bits players computed psm protocol communication complexity shared randomness complexity 

general quadratic overhead turn expensive purposes 
functions admit simple psm protocols linear complexity see lemma 
lemma 
nite abelian groups linear function 
exists psm protocol computing communication complexity shared randomness complexity larger total number input bits proof 
psm protocol proceeds follows 
player masks input setting def random shared tuple satisfying 
sends masked input carol 
carol compute desired output value 
privacy protocol follows observing input tuple message tuple exists unique random input messages induced inputs random input message tuple size support singleton implying identical distribution messages 
communication shared randomness complexity clearly speci ed 
lemma sequel groups binary strings xed length operation exclusive 

cds psm note conditional disclosure secrets cds primitive described subsection theorem may implemented eciently psm computation 
speci cally disclosing bit subject condition may reduced psm computation function correctness psm protocol carol reconstruct hand privacy psm protocol carol view identically distributed inputs implying carol learns general upper bound complexity conditional disclosure secrets established theorem linear size formula span program computing condition best known results psm complexity yield bound quadratic representation size 
function formula size computable branching program size see chapter 
mentioned gives psm complexity 
spir schemes psm cds protocols subsection psm cds protocols construct honest user spir schemes 
lemma apply psm solutions pir scheme particular type reconstruction function order get honest user spir scheme 
discuss implications lemma provide example 
example lemma helpful constructions particular ones involve pir schemes general reconstruction function 
lemma suppose round database pir scheme communication complexity reconstruction function depends answers databases function computed psm protocol communication complexity shared randomness complexity 
exists round database honest user spir scheme communication complexity shared randomness complexity 
proof 
scheme speci ed complexity obtained follows 
user chooses queries pir scheme sends query corresponding database db database db computes answer sending answer user databases shared randomness simulate psm computation 
database db sends user message player send carol psm protocol correctness privacy follow correctness privacy psm protocol complexity clearly stated 
stress lemma yields honest user spir schemes dishonest user potentially generate invalid queries applying reconstruction function answers gives forbidden information follow physical data bit 
idea hiding input reconstruction function help dishonest user may get information output reconstruction function 
direct application lemma example 
example 
psm honest user spir scheme dimensional cube scheme 
consider basic dimensional cube scheme subsection reconstruction function consists computing exclusive answer bits sent databases 
scheme maintain data privacy user learns exclusive di erent subsets data bits 
case extra information eliminated applying lemmas 
speci cally sending original answer database db send masked answer 



bit shared random string 
computed exclusive bits modi ed scheme honest user view uniformly distributed tuples exclusive scheme correctness equal physical bit pir schemes linear reconstruction function lemma applicable communication overhead include polynomial interpolation schemes log databases dishonest user spir counterparts subsection 

generality lemma note lemma requires underlying pir scheme reconstruction function depends answers computed databases 
case basic cube scheme see example case scheme instance reconstruction heavily depends index held user 
order satisfy requirement pir scheme reconstruction function may depend index queries may augmented pir scheme reconstruction depends answers follows 
user index databases independently original queries sending dlog ne bit random string database exclusive random string binary representation database 
sharing violate user privacy introduces minor overhead query complexity 
database db appends original answer query received including share 
original reconstruction function induces reconstruction function augmented scheme depends databases answers 
lemma applied augmented scheme 
complexity solution prohibitive 
remainder section derive honest user spir scheme database pir scheme case possible psm methodology lemma eciently meet goal 
constructions sections introduce alternative conceptually simpler methodology conditional disclosure secrets top psm 
similar methodology may useful di erent contexts demonstrated subsection 
theorem exists database honest user spir scheme communication complexity shared randomness complexity 
proof 
recall pir scheme see section particular reconstruction function may viewed stage procedure user selects single bit answer strings depending index user takes exclusive bits selected obtain honest user learn exclusive bits corresponding data privacy requirement met 
achieved conditional disclosure secrets primitive top psm protocol computing exclusive bits 
scheme honest user spir version proceeds follows queries user sends subcubes db db scheme addition user independently shares characteristic vectors databases 
done picking random bit strings sending strings db strings db answers databases computes answer strings length bit answer scheme 
denote answer string emulating db databases treat bit string input psm protocol computing exclusive bits shared randomness compute send psm message sent bit 
simple psm protocol xor see lemma example message single bit 
denote string obtained replacing bit corresponding psm message bit 
case obtained masking bit random bit bits fr random bits exclusive 
jw databases shared randomness disclose user th bit subject appropriate condition 
condition 
single bits sent plain form 
possible extend construction apply database generalization postpone generalization section deals case dishonest user 
user honest extra sharing redundant characteristic vectors sets sent user may viewed shares presentation closely resembles solution dishonest user described section 
reconstruction user reconstructs psm message bits corresponding index reconstruction function conditional disclosure protocol computes exclusive obtain correctness scheme user privacy follow correctness user privacy pir scheme correctness cds psm schemes easy verify 
turn show scheme meets data privacy requirement respect honest user 
rst introduce notation 
denote tuple answers computed databases execution induced data string user input query shared randomness databases random input user 
similarly denote tuple psm strings computed databases corresponding execution tuple index wj denote restriction bits corresponding index user honest correctness exclusive bits equal privacy psm protocol xor follows pr pr secrecy conditional disclosure protocol independence shared randomness psm randomness follows pr view pr view combining equations get pr view pr view 
pr pr view 
pr pr view concluding proof data privacy property 
note proof explicitly refers relevant random variables subsequent proofs similar nature detailed analysis replaced higher level arguments 
remains show scheme meets speci ed complexity bounds 
condition disclosing bits strings form equivalently single bits follows lemma theorem masked answer bits conditionally disclosed total communication shared randomness cost bits 
altogether communication complexity scheme shared randomness complexity required 
speci spir schemes respect dishonest users previous section concerned honest curious user 
section construct spir schemes guarantee data privacy respect dishonest users 
example demonstrates extra information dishonest user may obtain ordinary pir schemes honest user spir scheme constructed 
example 
consider scheme suppose user sends subcube fi fi fi legitimate query rst database 
answers database include bits reveal physical bits data 
note randomly setting query honest user learn physical data bits occurs exponentially small probability 
scheme perfectly maintains data privacy honest user dishonest user may similarly obtain physical data bits 
user sends rst database cube sends second database empty cube 
sharing characteristic vectors user share vectors automatically satisfy disclosure conditions allow user learn entirety strings physical bits reconstructed combined answers databases 
instance user may reconstruct bit computing observe honest user spir scheme dishonest user cheat ways 
way improperly share characteristic vector index share ones vector 
way send invalid queries 
may give user extra information index properly shared invalid queries output reconstruction function depend bit data 
order resilient dishonest users honest user spir scheme principle modi ed lter original answer bit conditional disclosure primitive condition tests validity user queries 
complexity disclosing answer bit subject full validity test prohibitive 
subsections alternative means transform best known pir schemes spir schemes 
transformations involve constant multiplicative communication overhead 
cube schemes subsection construct constant database spir scheme communication complexity best known database pir scheme 
rst address database case generalize database scheme 
theorem 
exists database spir scheme communication complexity shared randomness complexity 
proof 
assume integer 
scheme proceeds follows queries user sends db subcube db subcube scheme addition user independently shares dense representations index components opposed unary representation scheme 
done viewing index component element picking random dlog bit elements mod sending strings db strings db answers answers constructed top intermediate computations scheme recall denotes answer database db basic dimensional cube scheme denotes answer string corresponding db original scheme denotes strings constructed exclusive bit string random bit correspond messages psm protocol computing xor 
shared random strings length shared random bits masks guarantee user gets information subcubes sent consistent index binary representation shared 
databases reply messages 
db sends user bits def um 
denotes inner product gf 
similarly db sends bits def um 
db sends user bit similarly db sends bit 
db db spir scheme corollary provide user single bit bit strings known db known db positions corresponding shared index 
done user queries queries scheme retrieval retrieval retrieval index retrieved scheme sum queries databases means user obtains bits position rst pair strings second pair third 
reconstruction honest user reconstruct follows 
user reconstructs bit computing bits bits obtained invocations computes correctness user privacy scheme easy verify 
show scheme data privacy relative user 
lemma 
denote queries sent possibly dishonest user def mod 
queries satisfy fi answers reveal bit information data 
answers reveal information data 
proof 
observe random bits um guarantees answers uniformly distributed bits satisfying user recall databases needs know data needs access shared random string 
honest fi user obtain fi messages jointly give information 
note case user may learn exclusive bit bits gives information observe data privacy spir scheme guarantees user learns single physical bit bit strings scheme applied 
position bit corresponds shared index component properties underlying psm protocol information revealed bits exclusive altogether information user obtain follows outcome expression 
fi implying information learned user 
hand fi exists user gets information learns information data 
corollary invocations implemented total communication complexity shared randomness complexity 
scheme meets speci ed complexity bounds 
note spir scheme constructed fact communication ecient pir scheme additive logarithmic overhead 
give database generalization theorem 
theorem 
constant exists database spir scheme communication complexity shared randomness complexity 
proof 
start giving short description pir scheme 
scheme databases denoted db db jointly emulate databases dimensional cube scheme 
scheme proceeds follows 
user sends db subcube basic cube scheme sends db db subcube answers db emulates databases db original scheme hamming distance similarly way emulation done scheme simultaneously remaining databases db db jointly emulate remaining databases original scheme db contains 
done constant number recursive invocations scheme user db db invocation user retrieves single bit virtual data string entries correspond di erent subcubes possibly sent db basic cube scheme bit virtual data strings exclusive data bits residing potential subcube 
exclusive bits selected answers db bits retrieved recursive invocations user reconstructs show adapt proof theorem database generalization 
intuitively combine recursive construction outlined techniques constructing scheme theorem 
note databases role main database having information send user auxiliary database help database disclose information revealing extra information 
similarly db main database emulating databases db hamming distance original cube scheme db auxiliary database purpose 
addition db db recursively emulate databases original cube scheme scheme described 
start describing induction assumption followed description scheme 
suppose database spir scheme communication complexity shared randomness complexity 
case additional assumption assume user required commit index retrieved 
assumption precise way 
say round pir scheme satis es strong data privacy requirement parameter conditions hold 
data string length user sends special queries element 
user possibly dishonest user sends queries mod answers reveal bit notice strong data privacy implies usual data privacy 
note scheme satis es stronger requirement follows lemma 
additional assumption carried satis es strong data privacy requirement 
scheme proceeds follows queries user sends db subcube db db subcube 
addition user independently shares dense representations index components db db additive shares scheme user sends queries necessary recursive invocations described item 
answers denote strings corresponding psm message strings emulating database db dimensional cube scheme 
weight strings described weight constructed query exactly 
particular consider em denotes th unit vector length note databases index hamming distance db db em emulated db 
shared random strings length shared random bits 
databases reply messages 
db sends user bits def um similarly db sends bits def um 
db sends bit shared random bit conditionally disclosed item 

db computes bit long psm message strings em emulating databases db em dimensional cube scheme 
db db spir scheme provide user bit position string em scheme done shares queries 
weight user databases db db db recursively invoke virtual data string de ned 
weight denote position th zero 
weight tuple associate subcube cube obtained replacing set weight set de ned bit string th bit equal exclusive data bits residing subcube psm random bit recursive invocation virtual data string user retrieves bit index represented tuple weight 

databases conditionally disclose shared bit subject conjunction conditions subcube sent db equal subcube sent db 
weight index shared user invocation accordance strong data privacy assumption equal veri ed comparing component corresponding component shared user 
eciently disclosing conjunction conditions databases may write exclusive independent random bits disclose bits subject single condition equality strings 
reconstruction user reconstructs recursively reconstructing bits retrieved exclusive bits disclosed user 
start analyzing communication shared randomness complexity 
lemma corollary conditional disclosure bit spir retrievals strings em implemented communication shared randomness complexity constant induction basis communication complexity 
similarly shared randomness complexity 
correctness user privacy easily veri ed 
remains show strong data privacy requirement holds argue user commits index sharing components db db learn bit scheme honest user learns 
order learn information involving bits dishonest user deviate scheme speci cation sending db db subcubes don meet requirements imposed trying retrieve recursive invocations di erent bits corresponding speci ed disclosure conditions data privacy strong data privacy assumption guarantee cases user learn information 
polynomial interpolation scheme section prove polynomial interpolation pir scheme dlog databases see transformed spir scheme number databases constant factor communication randomness overhead 
theorem 
exists dlog database spir scheme communication complexity shared randomness complexity log 
log log 
proof 
start describing underlying pir scheme method low degree polynomial interpolation see details 
assume loss generality positive integer number databases 
gf nite eld elements distinct nonzero elements gf 
index associate tuple corresponding binary representation data string denote multivariate degree polynomial may taken multilinear extension function def 
user picks random tuple gf sends database db query 
database db replies single eld element def 
user reconstructs interpolation unique degree univariate polynomial gf 
communication complexity scheme log log log 
noted subsection linearity reconstruction function interpolation allows obtain psm honest user spir scheme communication complexity 
prevent dishonest user obtaining illegitimate information require user prove queries consistent gf proof consist sharing entry validation consist verifying 
observation yields slight improvement original pir scheme described 
note user reconstructs computing xed linear combination gf eld elements replied databases 
rst step database multiply original answer corresponding coecient reconstruction consist computing sum answers gf 
chosen power dlog suces databases reply signi cant bit answer user reconstruct exclusive answer bits 
refer modi ed scheme 
corresponding spir scheme construct formally described follows queries user sends database db query original scheme 
addition user picks random tuples gf sends db db db answers independent random bits included databases shared randomness denote exclusive 
database db replies def answer modi ed scheme 
addition databases shared randomness disclose bit subject conjunction conditions shares sent db identical sent db denotes th entry th share nally note condition may expressed boolean formula ks log log atomic conditions testing equality elements gf known di erent databases 
instance verifying condition equivalent comparing known db known db theorem conditional disclosure implemented communication complexity shared randomness complexity log 
log log 
reconstruction user reconstructs computes exclusive correctness user privacy original scheme clearly maintained 
see data privacy scheme consider possible cases 
user queries valid tuple uniformly distributed tuples gf add implying answer distribution depends user obtains information consequently uniformly independently distributed gf independent conditional disclosure messages 
follows case user obtains information excluding conditional disclosure communication complexity scheme dominated query complexity log 
log log 
complexity disclosing discussed entire scheme requires log 
log log communication shared randomness bits 
extensions methodology allows implement communication ecient spir schemes requiring round interaction dishonest behavior user 
methodology may useful dealing variants basic pir question demonstrate section cryptographic scenarios 
show extend results directions dealing retrieval blocks single bit records dealing privacy privacy coalitions colluding databases 
application methodology spir particular conditional disclosure secrets primitive implemented quite eciently 
application termed private retrieval costs allows user privately retrieve single round collection data items provided total cost exceed previously paid 
block retrieval spir schemes far restricted attention retrieval single bits multi bit records referred blocks 
subsection show results previous sections extended yield block retrieval spir schemes 
start observing pir schemes generality lost single bit retrieval considered pir scheme single bit retrieval may simply invoked times parallel retrieve block bits 
argument carry spir schemes cheating user may invoke scheme bits belong record obtaining information physical block 
describe modi cation procedure works single round spir schemes 
single round spir scheme user retrieve single bit bit data string construct single round spir scheme retrieve bit record data string records follows user sends queries original bit retrieval scheme databases reply times user queries bit record 
reply allows user learn single bit selected record user generates queries guaranteed bits learns form single record database 
transformation single bit multi bit retrieval applicable multi round spir schemes set queries multiple times di erent record bits queries bit depend replies received previous rounds 
hand multi round schemes general pir spir transformation section may extended multi bit block retrieval letting entry shared random string consist bits single bit 
protocols proofs modi ed straightforward way support extension 
addition note speci spir schemes sections single round may block retrieval transformation 
true general spir scheme section underlying single round pir scheme case pir schemes known literature 
private spir schemes general reduction described section original pir scheme private resultant spir scheme private 
db database db joint view colluding databases includes shift 
shifted index 
modn user index easily recovered 
generalizing construction private spir scheme obtained private pir scheme follows 
directly asking db 
th bit shared random string user retrieve bit recursively invoking private spir scheme fresh set databases 
basis recursion may take trivial database scheme user explicitly asks desired index 
particular database private scheme described section may viewed second level recursion 
general private database pir scheme applying recursion yields private kt database spir scheme communication complexity roughly times original private scheme 
generalization theorem show number databases private spir scheme reduced expense increasing communication factor theorem round database private pir scheme communication complexity 
exists round database private spir scheme communication complexity dlog ne shared randomness complexity mn proof 
private spir scheme databases db described 
construction uses collection fs sm sm database sets sm singleton set size set size exists set 
exists sm fkg subset size honest user spir scheme proceed follows actions performed round communication user picks random shift amounts 


databases hold shared random strings length denote data string 
sends 
database invokes pir scheme database set privately retrieve bit position def 
mod 

notice particular explicitly asks single database sm bit position def 
mod reconstructs exclusive bits show scheme correct satis es privacy requirements 
follows induction 

proves correctness scheme 
prove user privacy consider view collusion databases 
private invocations involving members disclose information potential source information messages set 


viewed members de nition guarantees collusion view proper subset messages contains information prove data privacy honest user suces show shift amounts 

position picked user random variable 



strings uniformly independently distributed depends single data bit 
proved iterating argument proof theorem 
letting shown backward induction joint distribution 


independent 


mod 
particular obtain desired result 
conditional disclosure mechanism proof theorem guarantee data privacy possibly dishonest user 
speci cally invocation involving database set answer disclosed subject condition corresponding shift amounts sent user equal 
analysis shows suces guarantee data privacy 
aside conditional disclosure protocol communication resultant scheme involves invocations scheme extra log bit query strings extra answer bit 
hard observe described minimal cardinality exist smaller increasing number databases cardinality decreased 
instance low tk corresponding recursive scheme described 
conditional disclosure protocol induces constant multiplicative communication shared randomness overhead 
gives communication randomness bounds stated theorem 
private retrieval costs subsection brie sketch conditional disclosure secrets methodology underlying spir scheme implement private retrieval costs 
denote indices data records user wishes retrieve denote public vector bit integral costs tuple th entry contains binary representation cost th data record denote public cost threshold amount money paid user 
scheme private retrieval costs allows user retrieve data records indexed privately giving database information provided total cost records exceed amount pre paid user hand allow user obtain information follow valid set records 
high level description generic implementation scheme underlying round spir scheme loss generality possibly small complexity overhead may assume reconstruction function applied user depends answers index random input 
see notice case schemes constructed section 
scheme proceed follows 
queries user chooses independently desired retrieval index tuple queries scheme sends databases corresponding messages parallel 
answers database locally computes answers user queries considering data string considering cost vector data string precisely considered bit vectors answers construct bit entry 
databases conditionally disclose answers subject appropriate condition answers 
condition answers assert sum costs reconstructed answers obtained applying reconstruction function larger public threshold complexity realizing conditional disclosure kept low ways 
better underlying scheme reconstruction function computationally easy case schemes constructed 
second possible facilitate realization disclosures complicated conditions requiring user send witness validity queries serve additional input condition 
setting general upper bounds theorem extended apply nondeterministic formulas span programs yielding ecient conditional disclosure protocols condition computed ecient circuit 
letting witness supplied user consist intermediate gate values possible verify circuit evaluates boolean disclosed database upper bound number data records user wishes retrieve 
user wants retrieve records rest indices point dummy record cost 
formula size linear circuit size 
addition bit integers computed circuit size amount communication required disclosing answer bit plus times size circuitry required reconstructing selected costs answers 
acknowledgments anonymous referee helpful comments suggestions 
grateful sha goldwasser enlightening discussions madhu sudan comments earlier version 
ambainis 
upper bound communication complexity private information retrieval 
proc 
th icalp lncs springer verlag pages 
beaver 
perfect privacy party protocols 
technical report tr harvard university 
beaver feigenbaum 
hiding instances queries 
proc 
th stacs lncs springer verlag pages 
ishai kushilevitz malkin 
way functions essential single database private information retrieval 
proc 
st stoc pages 
benaloh 
generalized secret sharing monotone functions 
proc 
crypto pages 
blum feldman micali 
non interactive zero knowledge applications 
proc 
th stoc pages 
blum micali 
generate cryptographically strong sequences pseudo random bits 
siam jour 
computing 
early version appears proc 
rd focs 
brassard cr robert 
information theoretic reductions disclosure problems 
proc 
th stoc pages 
brassard cr 
oblivious transfers intersecting codes 
ieee transaction information theory special issue coding complexity 
cachin micali stadler :10.1.1.26.7042
computationally private information retrieval polylogarithmic communication 
proc 
eurocrypt lncs springer verlag 
schemes constructed section exists single answer bit eliminated user view user learn information data 
chor gilboa 
computationally private information retrieval 
proc 
th stoc pages 
chor goldreich kushilevitz sudan 
private information retrieval 
proc 
th focs pages 
chor kushilevitz 
zero law boolean privacy 
siam jour 
disc 
math february 
early version appears proc 
th stoc pp 

di malkin ostrovsky 
single database private information retrieval implies oblivious transfer 
manuscript november 
goldreich lempel 
randomized protocol signing contracts 
comm 
acm 
feige kilian naor 
minimal model secure computation extended 
proc 
th stoc pages 
goldreich goldwasser micali 
construct random functions 
jacm 
ishai kushilevitz 
private simultaneous messages protocols applications 
proc 
th pages 
ishai kushilevitz 
improved upper bounds information theoretic private information retrieval 
proc 
st stoc pages 
ito saito 
secret sharing schemes realizing general access structures 
proc 
ieee global telecommunication conf globecom pages 
wigderson 
span programs 
proc 
th ieee structure complexity theory pages 
kushilevitz 
privacy communication complexity 
siam jour 
disc 
math may 
early version proc 
th focs pp 

kushilevitz ostrovsky 
single database computationally private information retrieval 
proc 
th focs pages 
naor pinkas 
oblivious transfer polynomial evaluation 
proc 
st stoc pages 
rabin 
exchange secrets oblivious transfer 
technical report tr harvard university 
shamir 
share secret 
commun 
acm june 
wegener 
complexity boolean functions 
teubner 
yao 
theory applications trapdoor functions 
proc 
rd focs pages 
necessity shared randomness shared randomness necessary spir section show addition shared randomness resource basic pir setting sense minimal 
suppose allow databases private randomness answering user queries allow interact mediation user particular allow share random string unknown user 
argue setting information theoretic spir implemented regardless complexity user honest 
claim exists multi round database spir scheme direct interaction di erent databases databases allowed hold private independent random inputs user honest 
proof 
user view includes communication strong privacy requirement implies single database db respond user queries way depends data string formally round distribution db answer previous communication depend answer distribution follow single bit violating data privacy requirement alternatively reveal db index depends violating user privacy 
independence private random inputs held di erent databases implies previous communication answers di erent databases independently distributed 
combining observations joint distribution answers previous communication independent fixing index follows induction number rounds accumulated communication rst rounds distributed independently implies user output depend value contradicting correctness requirement 
special case claim may conclude corollary 
exists single database information theoretic spir scheme 
note corollary derived known results party computation 
shared randomness general reduction spir pir shown resource shared randomness necessary order spir achievable 
section general transformations pir spir linear shared randomness sections speci transformations shared randomness communication complexity 
natural question concerning general transformations shared randomness complexity reduced possibly function communication complexity 
argue want general reduction apply pir scheme shared randomness complexity information theoretic honest user case sense minimal uniform distribution shared random string chosen replaced distribution entropy straightforward observe case trivial database pir scheme database sends entire data string user claim indicates case pir schemes arbitrarily small communication complexity 
claim 
pir scheme answer bit gives boolean data bits requires shared random string scheme theorem uniformly distributed proof 
denote distribution picked suppose uniform easily follows exist index 
denote scheme constructed proof theorem shared random string distributed consider invocation user retrieval index speci ed shift 

observe invocation user distinguish data strings correctness user learn th data bit implying obtains single physical bit data 

