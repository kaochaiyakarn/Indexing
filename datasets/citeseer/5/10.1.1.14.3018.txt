isabelle tutorial user manual lawrence paulson tobias nipkow computer laboratory university cambridge copyright lawrence paulson tobias nipkow january manual describes theorem prover isabelle 
beginners explains perform simple single step proofs built logics 
include order logic classical sequent calculus zf set theory constructive type theory higher order logic 
logics described 
manual explains develop advanced tactics tacticals derive rules 
describes define new logics isabelle 

isabelle uses dave matthews standard ml compiler poly ml 
philippe de groote wrote version logic lk 
funding equipment provided serc alvey gr esprit bra 
philippe brian monahan martin coen annette schumann 
contents basic features isabelle overview isabelle 
representation logics 
theorem proving isabelle 
fundamental concepts 
get started 
theorems rules theories 
notation theorems rules 
type theorems operations 
type theories 
subgoal module 
basic commands 
advanced commands 
tactics 
example 
example elimination rules 
example eresolve tac 
proofs involving quantifiers 
successful quantifier proof 
unsuccessful quantifier proof 
nested quantifiers 
priority grammars 
isabelle order logics order logic natural deduction 
intuitionistic logic 
classical logic 
intuitionistic example 
classical example 
classical order logic 
syntax rules inference 
tactics cut rule 
proof procedure 
sample proofs 
contents isabelle set type theories zermelo fraenkel set theory 
syntax rules inference 
derived rules 
tactics 
examples 
constructive type theory 
syntax rules inference 
tactics 
example type inference 
examples logical reasoning 
arithmetic 
higher order logic 
tactics 
examples 
developing tactics rules theories tacticals 
type tactics 
basic tacticals 
derived tacticals 
tacticals numbered subgoals 
examples tacticals 
prolog interpreter 
deriving rules 
definitions derived rules 
defining logics types terms ml type typ ml type term theories meta logic defining syntax mixfix syntax lexical conventions parse translations logical types default syntax printing miscellaneous restrictions identifiers constants type inference putting contents internals types terms basic declarations operations representation object rules higher order unification sequences environments unification functions terms valid signature ml type sg ml type cterm declarations meta inference theorems derived meta rules backwards proof tactics tacticals derived rules tactics filtering object rules bibliography index find truth logic truth 
man orthodox basic features isabelle chapter theorem prover isabelle far finished users justify writing manual 
manual describes pure isabelle natural deduction order logic constructive classical versions constructive type theory classical sequent calculus zf set theory higherorder logic syntax rules proof procedures 
theory ideas isabelle described 
fortunately beginners need understand exactly isabelle works 
need know meta level rules proof tactics interactive proof commands 
manual starts introductory level leaves worst details appendices 
understand report need knowledge standard ml language simple 
studying advanced material may want isabelle sources hand 
advanced isabelle theorem proving involve writing functions ml 
isabelle distributed 
version higher order meta logic lifting quantifiers 
version added limited polymorphism lifting natural deduction 
current version includes pretty printer automatic parser generator object level higher order logic 
isabelle development continue change 
syntax concise upwards compatible previous versions 
existing isabelle users convert files tool provided distribution tape 
manual organized different ways experienced 
chapter introduces pure isabelle things common logics 
include theories rules tactics subgoal commands 
simple proofs demonstrated 
chapter introduces versions order logic provided isabelle 
easiest way get started isabelle 
logic large collection examples proofs try 
automatic tactics available 
gain confidence standard examples develop proofs tactics 
chapter 
basic features isabelle chapter describes isabelle advanced logics set theory constructive type theory higher order logic 
possible plunge knowing single step proofs want skip chapter reading 
chapter describes detail tactics 
introduces tacticals building blocks tactics describes define search procedures 
chapter describes simple extensions logic defining new constants 
chapter written tobias nipkow describes build object logic syntax definitions role signatures theories combined 
defining object logic major undertaking 
thorough understanding logic chance successfully representing isabelle 
appendices document internal workings isabelle 
information experienced users 
overview isabelle isabelle theorem prover cope large class logics 
need specify logic syntax rules 
go proof checking implement search procedures built tools 
representation logics object logics formalized isabelle meta logic intuitionistic higher order logic implication universal quantifiers equality 
implication means implies expresses logical entailment 
quantification means true expresses generality rules axiom schemes 
equality means equals allows new symbols defined abbreviations 
instance isabelle represents inference rule axiom meta logic structure rules generalizes prolog horn clauses proof procedures exploit logic programming techniques 
isabelle borrows ideas lcf 
formulae manipulated meta language standard ml proofs developed backwards direction tactics tacticals 
key difference lcf represents rules functions 
overview isabelle axioms 
lcf rule function maps theorems theorem higher order logic uses typed calculus including formalization quantifiers 
represented new constant formula containing viewed semantically represented variable denotes truth valued function 
isabelle represents rule axiom 
rule subject proviso free assumptions 
axiom involves proving arbitrary enforcing proviso 
similar techniques handle existential quantifiers operators type theory indexed union operator set theory forth 
isabelle easily handles induction rules axiom schemes set theory axiom separation involve arbitrary formulae 
theorem proving isabelle proof trees derived rules built joining rules 
comprises forwards backwards proof 
backwards proof works matching goal rule premises subgoals 
forwards proof works matching theorems premises rule making new theorem 
rules joined higher order unification involves solving equations typed calculus respect conversion 
unifying constant gives unifiers 
multiple unifiers indicate ambiguity unifiers reflect different ways regarded depending 
demonstrate implementation logics examples provided 
proofs performed logics 
order logic automatic procedure prove theorems involving quantifiers 
constructive type theory examples include derivation choice principle simple number theory 
set theory examples include properties union intersection cartesian products 
fundamental concepts isabelle comprises tree object logics 
branching deep broad logic 
root tree pure isabelle implements meta logic 
pure isabelle provides concepts operations common object logics types terms syntax signatures theorems theories tactics proof commands functor building 
chapter 
basic features isabelle types denoted greek letters include basic types correspond syntactic categories object logic 
function types form 
types ml type typ 
terms denoted usual terms typed calculus 
encode syntax object logics 
encoding object formulae meta logic usually obvious semantic reading 
isabelle implements operations terms complex higher order unification 
terms ml type term 
automatic package written tobias nipkow performs parsing display terms 
specify syntax logic collection mixfix operators including directives isabelle pretty printer 
theorems meta logic ml type thm 
meta theorems represent theorems inference rules object logics object theorems rules type thm 
meta level inference rules implemented lcf style functions theorems theorems 
theories ml type theory 
object logic theory 
extending logic new constants axioms creates new theory 
basic step developing proofs fortunately easier creating entire new logic 
proofs constructed tactics 
simplest tactics apply objectlevel inference rule subgoal producing new subgoals 
simple tactic solves goal assumption isabelle framework natural deduction 
complex tactics typically apply tactics repeatedly certain goals possibly depth search strategies 
tactics permit proofs performed higher level fewer top level steps 
novice need write new tactics deriving new rules lead shorter proofs easier way writing new tactics 
tactics ml type tactic 
get started order conduct simple proofs need know details isabelle 
sections introduce theories theorems subgoal module commands tactics including ml identifiers types 
concepts apply object logics demonstrated order logic 
ideally terminal nearby run isabelle logic 
necessary see installation instructions advice setting things 
user interface 
isabelle top level simply standard ml system 
workstations provides window system easy menu put common commands window pick insert isabelle session 
may get started serious project see main problems logical 

theorems rules theories theorems rules theories theorems rules object logic represented theorems metalogic 
logic defined theory 
isabelle provides operations ml functions involve theorems involve theories 
chapters examples theory construction 
consider built theories 
notation theorems rules keyboard rendering symbols meta logic summarized 
precise syntax described sections 
meta equality meta implication nested implication xyz xyz meta quantification xyz xyz meta abstraction ga ga scheme variables meta abstraction normally invisible quantification 
comes play new binding operators introduced example operator defining primitive recursive functions 
symbols object logics rendered keyboard characters 
typically follows conjunction disjunction negation implication bi implication xyz xyz ex xyz xyz exists illustrate notation consider order logic formalized 
presents natural deduction system intuitionistic order logic implemented isabelle 
rule expressed meta axiom pq translates literally keyboard characters leading universal quantifiers usually dropped favour scheme variables chapter 
basic features isabelle conjunction disjunction implication contradiction universal quantifier existential quantifier elimination conditions provided free assumptions provided free assumption save intuitionistic order logic 
theorems rules theories parentheses optional groups right 
shorthand scheme variables logically equivalent ordinary variables may instantiated unification ordinary variables remain fixed 
subscripts renamed easily prior resolution 
definition rules isabelle theory usually involves ordinary variables isabelle converts scheme variables rule unification 
convention theories avoids cluttering rules question marks 
stating goal scheme variables answer extraction 
free variables goal remain fixed proof converted scheme variables 
examples syntax clearer 
rule represented axiom pqr isabelle theory definition axiom representing nested meta quantifier isabelle theory definition 
foundations earlier versions isabelle enclose special brackets notation clearly distinguishes object meta levels verbose dropped 
note ambiguous meta object formulae 
isabelle assumes object formulae intended 
matter types meta formulae type prop object formulae typically type form 
force variable type prop constraint psi prop theta prop occasions doing 
chapter 
basic features isabelle type theorems operations inference rules theorems axioms logic type thm 
theorems axioms regarded rules premises speak just rules 
proof constructed series rule applications usually subgoal module commands 
type 
ml print values types command 
rules theory normally bound ml identifiers 
suppose running isabelle session natural deduction order logic described chapter 
print disj intr rules disj intr val unit user input preceded character prompt poly ml system 
prompt character input lines 
response val henceforth omitted 
command prints list theorems 
definitional axioms order logic true def def iff def true false false false summary theorem printing commands thm unit thm list unit type theories logic ml object type theory 
natural deduction order logic identifiers int rule thy intuitionistic logic cla thy classical logic 
theory includes information types constants syntax 
particular theory includes information parse string logical formula 
lcf isabelle session restricted single theory 
theory stated start proof theory initial goal 
tactics theory certain isabelle functions take theory argument 
type theory type theory values printed 
way opening theory value see inside 

subgoal module subgoal module isabelle proofs conducted subgoal module maintains proof state manages proof construction 
isabelle largely functional program kind interaction imperative 
ml top level invoke commands ml functions side effects establish goal apply tactic proof state undo proof step obtain theorem proved 
tactics operations proof states described section 
peek demonstration subgoal commands 
basic commands start new proof type goal theory formula formula written ml string 
apply tactic proof state type tactic tactic proof state replace completely unrelated state tactics apply rule rules numbered subgoal 
proof call result get theorem just proved 
dissatisfied previous step type undo cancel 
undo operation repeated 
demonstrate commands consider elementary proof 
enter goal classical order logic 
goal cla thy level val thm list isabelle responds printing proof state formula main goal subgoal initial proof state 
note goal returned empty theorem list ignore deriving rule 
level number state number tactics applied level 
step resolve tac described section applies rule imp intr subgoal resolve tac imp intr level chapter 
basic features isabelle new proof state subgoal assumption 
indicates assumptions 
apply rule disj intr subgoal resolve tac disj intr level 
level subgoal prove assuming 
easy tactic assume tac 
assume tac level subgoals 
isabelle tells longer subgoals proof complete 
finished call result get theorem just proved 
val result val thm ml print theorems force note changed free variables scheme variables free variables remain fixed proof scheme variables theorem applied formulae place go back level undo level 
undo undo right back 
undo irreversible 
incidentally omit parentheses undo val fn unit unit just function value 
advanced commands commands mainly importance experienced users feel free skip section reading 

subgoal module subgoal package stores current proof state previous states commands produce new states return previous ones 
state list level list pairs current proof state previous initial proof state 
sequences proof states storing branch points tactic returned sequence longer 
chopping elements state list reverts previous proof states 
undo command uses list previous states package 
print current proof state type pr 
calling prints proof state level variable goals limit initially holds upper bound number subgoals print 
starting top level back looks state list alternative state 
current proof state 
previous state discarded level reset alternative 
calling chop deletes top level state list cancelling effect command 
provides limited undo facility undo command cancel effect 
note undo undo 
calling truncates state list level quicker typing chop undo times 
returns top level proof state theorem 
best way extract theorem proved try result 
calling result returns final theorem 
theorem generalizing free variables discharging assumptions raises exception proof state zero subgoals theorem proved stated goal command 
differ proof involved answer extraction example 
case omits comparison initial goal final theorem 
calling returns subgoal term 
debugging tactic employ function 
middle proof may discover lemma needs proved 
isabelle provides commands put aside current proof prove lemma resume previous proof 
call getstate return entire state subgoal package 
object belongs type 
bind state ml identifier say save 
resume proof call setstate save 
chapter 
basic features isabelle summary subgoal module commands back unit unit tactic unit chop unit unit int unit int term getstate unit goal theory string thm list goals limit int ref pr unit unit int unit result unit thm setstate unit unit thm undo unit unit unit thm tactics tactics operations proof state apply rules subgoals 
time may want regard part syntax command 
separate existence combined operators called tacticals powerful tactics 
tactics similarly combined 
tacticals discussed chapter 
consider basic tactics 
tactics provided built logics able substantial proofs 
applying tactic changes proof state new proof state 
tactic may produce multiple outcomes permitting backtracking search 
pretend tactic produce state 
tactic produces state said fail 
tactics act subgoal designated number starting 
fail subgoal number range 
understand tactics need read foundation generic theorem prover particularly discussion backwards proof 
shall perform proofs isabelle 
basic resolution tactic proof steps resolve tac thms thms represent object rules 
rules list tried subgoal proof state 
rule resolution form state unifying subgoal replacing instantiated premises 
outcomes rules may unifiable 
tactics higher order unifiers 
tactic fails rules applied subgoal 
natural deduction proof subgoal assumptions represented 
resolution lifts object rules assumptions effect assumptions copied new subgoals 
subgoal represented meta quantifiers resolution lifts object rules 
tactic solve subgoal assumption assume tac isabelle recognize subgoal holds assumption tell applying tactic 
simply erased 
proving subgoal assumption involve unification instantiating variables shared subgoals possibly making false 
tactic fails subgoal solved assumption 
elimination resolution tactic eresolve tac thms resolve tac thms followed assume tac applies object rule solves premise assumption 
eresolve tac thing deletes assumption subgoals resulting resolution 
assumption discarded 
tactic appropriate typical elimination rules applying rule generates new assumptions stronger old 
steps 
tactics important 
permit reasoning definitions deriving rules demonstrated chapter 
rewriting tactics rewrite goals tac thms rewrite tac thms fold tac thms thms list equational theorems form theorems rules premises 
rewrite goals tac rewrite tac apply left right rewrite rules 
rewrite tac rewrites entire proof state including main goal rewrite goals tac rewrites subgoals normally preferable 
calling fold tac applies theorems right left rewrite rules proof state 
typically rewrite goals tac expand definitions subgoals fold tac inverts operation 
calling cut facts tac thms inserts thms assumptions subgoal allows eresolve tac rewrite goals tac operate thms 
rules outright theorems premises inserted eresolve tac cope general rules assumptions 
cases thms fact premises rule derived illustrated chapter 
chapter 
basic features isabelle summary tactics assume tac int tactic cut facts tac thm list int tactic eresolve tac thm list int tactic fold tac thm list tactic resolve tac thm list int tactic rewrite goals tac thm list tactic rewrite tac thm list tactic tactics resolve tac assume tac eresolve tac suffice single step proofs 
examples demonstrate subgoal commands tactics practice 
eresolve tac strictly necessary proofs involve elimination rules 
example example proof foundations 
enter goal goal int rule thy level subgoal apply toit resolve tac imp intr level subgoal assumption outer form implication 
apply rule 
resolve tac imp intr level assumptions outer form conjunctive 
apply rule resolve tac conj intr level 
tactics subgoals assumptions 
subgoal holds trivially assumption assume tac level noting assumption backwards applying version resolve tac conjunct level subgoal contains scheme variable instantiated formula 
subgoal provable assumption 
assume tac level subgoals 
bind theorem ml variable inspect 
val example result val example thm example example elimination rules proof disjunction commutative requires enter isabelle apply goal int rule thy level resolve tac imp intr level assumption available apply resolve tac 
resolve tac disj elim level chapter 
basic features isabelle elimination rule premises disjunction subgoal 
proving subgoal instantiate subgoals 
prove subgoal assume tac instantiating assume tac level old subgoal disappears subgoals slide fill gap 
provable new assumptions 
follows assumption redundant subgoals 
example shall apply eresolve tac delete assumption 
prove subgoal assumption 
resolve tac disj intr level assume tac level remaining subgoal proved similarly 
resolve tac disj intr level assume tac level subgoals 
result called return theorem just proved 
new goal entered theorem lost 
example eresolve tac tac tac proof steps shorter clearer 
eresolve tac important involves elimination rule deletion assumption 

tactics enter apply 
done previous example terminal type undo times get back level 
goal int rule thy level resolve tac imp intr level premise formula eliminated disjunction 
tactic eresolve tac searches assumptions unifies premise simultaneously unifying rule subgoal 
unifies formula simply 
uses selected assumption prove premise deletes assumption resulting subgoals 
short assumption eliminated 
eresolve tac disj elim level subgoals assumption compared previous proof proved exactly 
eresolve tac simplifies steps consist application rule followed proof assumption 
eresolve tac disj intr level thing 
eresolve tac disj intr level subgoals 
importance eresolve tac clearer larger proofs 
prevents assumptions accumulating getting reused 
eliminated assumption redundant elimination rules save deletion especially important automatic tactics 
chapter 
basic features isabelle proofs involving quantifiers important aspects isabelle treatment quantifier reasoning 
illustrate comparing proof attempted proof happens false 
proof succeeds fails scope quantified variables 
proofs discussed foundations 
unification helps trivial proofs 
exists simply need say 
choice forced reflexive law equality happens automatically 
proof forces correct instantiation variables 
course instantiation complicated may reasonable amount time 
successful quantifier proof theorem simplest contain quantifiers 
proof illustrates rules enter goal goal int rule thy ex level ex exy applicable rule resolve tac intr level ex 
ka 
ex ka ka introduces subgoal 
exclamation mark character meta forall 
subgoal proved possible values ka 
isabelle chooses names ka kb kc order 
applicable rule resolve tac exists intr level ex 
ka 
ka ka note bound variable changed ka scheme variable 
function applied ka 
instantiating change ka term may may contain ka 
particular 
proofs involving quantifiers instantiated identity function ka changes simply ka 
corresponds proof reflexivity equality 
resolve tac refl level exy subgoals 
proof finished 
unfortunately observe instantiation appears 
unsuccessful quantifier proof formula theorem 
hope isabelle prove 
enter goal goal int rule thy ex level exy 
ex rule considered resolve tac exists intr level exy scheme variable may replaced term complete proof 
problem term equal apply resolve tac intr level exy 
ka 
ka compare position previous level 
ka cases scheme variable instantiated term free entire proof state 
doing change ka depends ka 
position 
reflexivity axiom unify subgoal ka bound variable 
happens try resolve tac refl tactic returned results exception error raised think reduction changes ka ka 
regard ka term possibly containing ka 
chapter 
basic features isabelle nested quantifiers multiple quantification produces complicated terms 
consider contrived example 
information prove observe scheme variables develop 
goal int rule thy ex ex ex level ex ex ex 
ex ex ex resolve tac exists intr intr level ex ex ex 
ex ex scheme variable appeared 
note resolve tac list rules choose rule applies 
rules worth considering resolve tac exists intr intr level ex ex ex 
ka 
ex ex ka resolve tac exists intr intr level ex ex ex 
ka 
ex ka ka bound variable ka scheme variable appeared 
note applied bound variables existing time course bound variables introduced 
resolve tac exists intr intr level ex ex ex 
ka kb 
ex ka ka kb resolve tac exists intr intr level ex ex ex 
ka kb 
ka ka kb ka kb final state term ka term containing ka ka kb term containing bound variables 
example discussed foundations 
priority grammars remainder manual shall frequently define precise syntax logic means context free grammars 
grammars obey 
priority grammars conventions identifiers denote nonterminals typewriter denotes terminals constructs enclosed 
repeated times kleene star alternatives separated 
predefined categories alphanumeric identifiers scheme variables denoted identifier variable respectively see section 
order simplify description mathematical languages introduce extended format permits priorities precedences 
scheme generalizes precedence declarations ml prolog 
extended grammar format nonterminals decorated integers priority 
sequel priorities shown subscripts 
nonterminal ap right hand side production may rewritten production aq formally set context free productions induces derivation relation strings follows ap iff 
aq extended grammar kind translated normal context free grammar 
translation may require large number new nonterminals productions 
example simple grammar arithmetic expressions demonstrates binding power associativity operators enforced priorities 
choice priorities determines binds tighter binds tighter associate left right respectively 
minimize number subscripts adopt conventions priorities range fixed priority right hand side priority left hand side may omitted 
addition write production ap 
conventions assuming grammar example priority grammars just describe logics manual 
supported isabelle syntax definition facility see chapter 
chapter 
basic features isabelle isabelle order logics chapter isabelle developed generic theorem prover customize logics logics come 
reside various subdirectories built installation instructions 
isabelle simply implementation 
chapter describes versions order logic provided isabelle 
chapter describes set type theories 
order logic natural deduction comes constructive classical versions 
order logic available classical sequent calculus lk 
sequent form am bn 
formulation equivalent deductive tableaux 
object logic comes simple proof procedures 
reasonably powerful interactive complete amazingly scientific 
take examples tactical programming 
perform single step proofs resolve tac assume tac referring inference rules logic ml identifiers type thm 
call rule safe applied provable goal resulting subgoals provable 
rule safe applied automatically goal destroying chances finding proof 
instance rules classical sequent calculus lk safe 
intuitionistic logic includes unsafe rules disjunction true false existential true false certain 
universal elimination unsafe formula deleted necessary termination 
proof procedures safe rules possible delaying application unsafe rules 
safe rules preferred generate fewest subgoals 
safe rules definition deterministic unsafe rules require search 
design suitable set rules important strategy applying 
proof procedures backtracking 
typically attempt solve subgoal repeatedly applying certain tactic 
tactic known step tactic resolves selection rules subgoal may replace subgoal search persists fewer subgoals total start 
backtracking happens search reaches dead step tactic fails 
alternative outcomes searched depth best chapter 
isabelle order logics strategy 
techniques writing tactics discussed chapter 
logic distributed sample proofs described 
isabelle users doubtless find better proofs tactics mine examples show isabelle prove interesting theorems various logics 
order logic natural deduction directory fol contains theories order logic gentzen natural deduction systems called nj nk 
intuitionistic logic defined classical logic obtained adding double negation rule 
natural deduction typically involves combination forwards backwards reasoning particularly rules isabelle backwards style handles rules badly alternative rules derived eliminate conjunctions implications universal quantifiers 
resulting system similar cut free sequent calculus 
basic proof procedures provided 
intuitionistic prover works derived rules simplify uses implication assumptions 
far complete prove complex theorems automatically 
classical prover works straightforward implementation lk deductive tableaux prover 
complete 
serious theorem prover classical logic exploit sophisticated methods efficiency completeness 
known methods unfortunately certain fixed inference systems 
isabelle evolving inference system deriving rules go 
classical resolution theorem provers extremely powerful course support interactive proof 
type expressions term type formulae form 
ml names types aterm aform respectively 
infixes equals sign connectives 
note meanings ml constructor type typ fol implication sign 
gives syntax including translations quantifiers 
intuitionistic logic intuitionistic theory ml identifier int rule thy 
shows inference rules ml names 
connective defined elimination rules derived 
derived rules shown ml names 
hardest rule search implication elimination expressed mp elim 
may assume provided prove classical logic proof assume intuitionistic proof may require repeated proof fails branch proof abandoned 
intuitionistic propositional logic requires backtracking 
elementary example consider intuitionistic proof 
order logic natural deduction symbol meta type precedence description term term form left equality form form form right conjunction form form form right disjunction form form form right implication form form form right infixes symbol meta type description form prop meta predicate truth form form negation forall term form form universal quantifier exists term form form existential quantifier true form formula false form absurd formula constants external internal standard notation forall ex exists translations form identifier identifier form ex identifier identifier form form 
grammar syntax fol chapter 
isabelle order logics refl sym trans conj intr conjunct conjunct equality disj intr disj intr disj elim imp intr mp false elim false true def true false false def false iff def propositional rules intr spec exists intr ex exists elim ex quantifier rules meta axioms intuitionistic fol 
order logic natural deduction conj elim imp elim elim contr false intr false elim sequent style elimination rules iff intr iff elim derived rules conj imp elim disj imp elim imp imp elim imp elim exists imp elim ex intuitionistic simplification implication disj exists ex ex middle imp iff swap derived rules classical logic derived rules fol chapter 
isabelle order logics implication needed twice 
theorem prover intuitionistic logic avoids imp elim trying simplify implication derived rules 
idea reduce antecedents implications atoms modus ponens deduce derived rules unsafe method incomplete 
belong structure int prover 
structure open full identifier avoid name clashes instance int prover step tac pc step tac 
tactic mp tac performs modus ponens assumptions 
calling mp tac searches assumptions form subgoal replaces subgoal new replaced unification may take place selecting implication antecedent unifiable assumption 
pair assumptions satisfies conditions tactic produce multiple outcomes 
tactic tac performs safe step 
calling tac tries solve subgoal completely assumption absurdity tries mp tac tries safe rules 
badly named due unification really safe 
mp tac instantiates variables example resulting subgoals unprovable 
may produce multiple outcomes 
calling safe tac tries solve subgoal backtracking tac step tactic 
tactic useful demonstrations debugging 
solves easy parts proof leaving hard parts 
tac performs step basic strategy 
tac tries reduce subgoal tac tries unsafe rules 
may produce multiple outcomes 
main theorem proving tactic pc tac 
calling pc tac tries solve subgoal backtracking step tac step tactic 
theorems pc tac proves automatically 
principia mathematica 
ex ex ex ex ex ex 
order logic natural deduction summary tactics belong structure int prover mp tac int tactic pc tac int tactic tac int tactic safe tac int tactic step tac int tactic classical logic classical theory ml identifier cla thy 
consists intuitionistic logic plus rule natural deduction classical logic really natural 
derived rules help pages 
exploit classical equivalence third swap rule typically applied assumption ifp complex formula resulting subgoal broken rules 
classical proof procedures combine swap rule rules applied purpose 
simulates sequent calculus lk sequent pm qn multiple formulae right 
isabelle strange system better lk 
functor theorem proving tactics arbitrary collections natural deduction rules 
applied example elimination rules constants set theory 
applied basic rules classical logic 
main tactics defined fast tac best tac comp tac belong structure pc 
tactic onestep tac performs safe step 
classical counterpart int prover tac 
tactic step tac performs step int prover step tac 
calling step tac thms tries reduce subgoal safe rules unsafe rules 
rules thms treated unsafe rules 
tactic may produce multiple outcomes 
main theorem proving tactic fast tac 
calling fast tac thms tries solve subgoal backtracking step tac thms step tactic 
slower powerful tactic best tac 
calling best tac thms tries solve subgoals best search step tac 
chapter 
isabelle order logics slower complete tactic comp tac 
calling comp tac thms tries solve subgoals best search 
step tactic judicious expanding quantifiers forth 
proved respectively fast tac best tac comp tac 
due pelletier 
ex ex 
ex ex ex summary tactics belong structure pc best tac thm list tactic comp tac thm list tactic fast tac thm list int tactic onestep tac int tactic step tac thm list int tactic intuitionistic example session similar book lcf pages 
lcf users may want compare treatment quantifiers isabelle proof begins entering goal intuitionistic logic applying rule goal int rule thy ex ex level ex ex 
ex ex resolve tac imp intr level ex ex 
ex ex example subgoal 
applying changed assumption 
choice eliminating introducing 
apply resolve tac intr level ex ex 
ex ka 
ex ka 
order logic natural deduction applying replaced ka 
universal quantifier changes object meta 
bound variable renamed ka parameter subgoal 
choose happens wrong rule chosen 
resolve tac exists intr level ex ex 
ex ka 
ka ka new subgoal contains function variable 
ka bound variable instantiating replace ka term containing ka 
simplify assumption elimination rules 
apply assumption call eresolve tac 
eresolve tac exists elim level ex ex 
ka kb 
kb ka ka step produced parameter kb replaced assumption universally quantified 
step eliminate quantifier 
subgoal unprovable 
way unify ka bound variable kb assigning kb illegal 
undo return went wrong correct matters 
time apply 
level ex ex 
ex ka 
ex ka eresolve tac exists elim level ex ex 
ka kb 
kb ex ka parameters scheme variables 
parameters produced early 
applying produce scheme variables 
resolve tac exists intr level ex ex 
ka kb 
kb ka ka kb eresolve tac elim level ex ex 
ka kb 
ka kb kb ka ka kb chapter 
isabelle order logics subgoal variables applied parameters 
obvious projection functions unify ka kb ka ka kb kb 
assume tac level ex ex subgoals 
theorem proved tactic steps counting abandoned ones 
proof checking tedious pc tac proves theorem step 
level ex ex 
ex ex level ex ex subgoals 
classical example illustrate classical logic shall prove theorem 
fails constructively exhibited 
classically meaning theorem proved follows 
chose true 
way theorem holds 
proof counterintuitive 
formal proof conform obvious way sketch 
key step rule exists classical rule 
establishes case analysis 
goal cla thy ex level ex 
ex resolve tac exists level ex 
exhibit term satisfy subgoal produce contradiction assumption 
steps routine 
order logic natural deduction assumption broken obvious rules 
resolve tac intr level ex 
ka 
ka resolve tac imp intr level ex 
ka 
ka eresolve tac elim level ex 
ka 
ka ka classical logic negated assumption equivalent 
get effect invoke eresolve tac swap rule 
current ka negated assumption 
eresolve tac swap level ex 
ka 
ka ka rules analyse new subgoal 
resolve tac intr level ex 
ka 
ka kb 
ka kb resolve tac imp intr level ex 
ka 
ka kb 
ka kb subgoal assumptions 
may hard read third assumption separated meta quantifier kb 
produce contradiction assumptions ka ka 
eresolve tac elim level ex 
ka 
kb 
ka ka assume tac level ex subgoals 
chapter 
isabelle order logics way proving theorem tac 
classical tactics prove expand quantifier 
goal cla thy ex level ex 
ex comp tac size size size level ex subgoals 
classical order logic implements classical order logic gentzen sequent calculus lk see gallier takeuti 
resembling method semantic tableaux calculus suited backwards proof 
assertions form lists formulae 
associative unification simulated higherorder unification handles lists 
easily get powerful proof procedures 
syntax rules inference gives syntax lk sequents quantifiers descriptions 
types include formulae expressions type representation lists 
actual list type sequ just 
infixes equality connectives 
traditionally sequence variables 
fixed variable declarations inconvenient dollar prefix designates sequence variables 
sequence expression prefixed formula 
presents rules 
connective defined 
presents derived rules including rules weakened quantifier rules 
automatic proof procedures weakened rules throw away quantification single 
usually terminate quickly incomplete 
multiple quantifier obtained duplication rule 
tactic res inst tac instantiate variable rules specifying formula duplicate 
tactics cut rule theory set built lk derives rules cut rule 
ask cut elimination 
cut rule eliminated proofs sequents needed derivations rules 

classical order logic symbol meta type precedence description term term form left equality form form form right conjunction form form form right disjunction form form form right implication form form form right infixes symbol meta type description true sequ sequ prop meta predicate truth form sequ singleton formula list form form negation forall term form form universal quantifier exists term form form existential quantifier term form term description operator constants external internal standard notation true sequent forall ex exists translations prop sequence sequence sequence item item empty item identifier variable form form identifier identifier form ex identifier identifier form form 
grammar syntax lk chapter 
isabelle order logics basic thin right thin left cut structural rules conj right conj left disj right disj left imp right imp left right left iff def propositional rules right left exists right ex ex exists left ex quantifier rules meta axioms calculus lk 
classical order logic duplicate right duplicate left iff right iff left left thin exists right thin ex derived rules lk example trivial cut free proof sequent noting want derive rule swapping conjuncts righthand formula cut rule subformula closer look derivations shows cuts directly involve premise rule derived meta assumption 
cases cut formula part premise serves bridge premises 
proofs cut formula specified calling appropriate tactic 
tactic cut tac reads string lk formula applies cut rule subgoal new subgoal right new subgoal left 
tactic cut right tac similar deletes formula right side new subgoal typically replace right hand formula tactic cut left tac similar deletes formula left side new subgoal replacing left hand formula proof procedure lk proof procedure powerful hand coded theorem provers natural flexible 
restricted fixed set rules 
may derive new rules derive working concepts definitions 
rules classified safe unsafe 
unsafe rule typically weakened quantifier rule safe rule 
pack simply pair component list safe rules second list unsafe rules 
packs joined obvious way allow reasoning various fragments logic extensions 
backtracking choice safe rule accomplishes applying order leads essentially result 
backtracking may necessary example lk set resolve ml chapter 
isabelle order logics basic sequents perform unification 
suppose constants subgoals assignment satisfies subgoals discovered search 
clarity imagine isabelle declares type pack 
type pack thm list thm list pack triv pack consists reflexivity basic sequent 
pack lk pack contains safe rules propositional rules plus right exists left 
unsafe rules left thin exists right thin 
calling pack pack combines packs obvious way lists safe rules concatenated lists unsafe rules 
calling resolve tac rules maxr determines rules affect formula subgoal number exceeds maxr tactic fails 
behaves resolve tac runs faster 
tactic tac rules repeatedly applies rules subgoal resulting subgoals 
keeps track number new subgoals generated affect subgoal tactic repeat goal tac packs applies safe rules packs goal resulting subgoals 
safe rule applicable unsafe rule tried 
example disj left tried left thin rule produces subgoals 
tactic safe goal tac packs applies safe rules packs goal resulting subgoals 
ignores unsafe rules 
tracing proof step tac packs applies rule subgoal considers safe rules unsafe rules 
tactic pc tac attacks subgoal triv pack lk pack 
summary tactics cut left tac string int tactic cut right tac string int tactic cut tac string int tactic resolve tac thm list int int tactic lk pack pack pc tac int tactic pack pack pack repeat goal tac pack list int tactic tac thm list int tactic safe goal tac pack list int tactic step tac pack list int tactic triv pack pack type synonyms ml modules 

classical order logic sample proofs pelletier problems solved pc tac 
problem 
goal lk rule thy ex level ex 
ex level ex subgoals 
problems solved pc tac 
ex ex ex ex ex unfortunately lk tactic similar comp tac fol repeated quantifier expansion 
problem requires step 
goal lk rule thy ex level ex 
ex resolve tac exists right level ex 
ex ex rule exists right expanded existential quantifier leaving copy unchanged 
pc tab finish proof perform rule rule 
rule apply applies formulae subgoal fortunately isabelle chooses occurrence 
resolve tac exists right thin level ex 
ex tactic returns occurrence additional outcome reached backtracking 
chapter 
isabelle order logics rule lk sequent calculus formula assumption 
moves left turnstile 
resolve tac imp right level ex 
ex universal quantifiers stripped 
existential formula lies dormant 
resolve tac right level ex 
ka 
ka ex resolve tac right level ex 
ka kb 
ka kb ex note formulae ka kb unifiable basic sequent 
strip existential quantifiers 
resolve tac exists right thin level ex 
ka kb 
ka kb ex ka kb resolve tac exists right thin level ex 
ka kb 
ka kb ga ka kb ka kb applying produces basic sequent solving goal 
resolve tac imp right level ex 
ka kb 
ga ka kb ga ka kb ka kb resolve tac basic level ex subgoals 
chapter isabelle set type theories discussion isabelle object logic continues set type theories 
large complicated involving subtle mathematical ideas 
section sense people familiar logic question 
theories follows zermelo fraenkel set theory subtheory lk 
zermelo fraenkel axiom system established formulation set theory 
martin constructive type theory partially implemented 
universes main omission 
higher order logic largest isabelle logics 
elaborate church known formulation 
object logic confused isabelle meta logic version higher order logic 
theorem proving theories extremely difficult may imagined encompasses large portions mathematics 
proof procedures supplied isabelle regarded attempts 
zermelo fraenkel set theory isabelle theory called set implements zermelo fraenkel set theory classical sequent calculus lk 
theory includes collection derived rules form sequent calculus sets 
simplistic sequent calculus proof procedure lk works reasonably set theory 
syntax rules inference gives syntax set extends lk finite sets ordered pairs comprehension 
constant set cons 
starting empty set constructs finite sets obvious way chapter 
isabelle set type theories separation axiom set collect forms set satisfy 
replacement axiom set replace forms set syntax set express kinds comprehension separation replacement 
infixes include union intersection subset membership relations 
big union big intersection operators form union intersection set sets written operators big union primitive 
language set theory studied logicians constants 
empty set axiom asserts set empty empty set union powerset formal proofs language isabelle theory declares constants 
constants primitive empty set defined intersection 
axioms appear 
contain unusual definitions formula defined denote 
extensionality axiom states means thing power set axiom states pow means thing definitions conservative 
theory defines abbreviations ordered pairs successor axioms expressed different ways 
example rule equal members expressed formula 
applying axiom involve lk rules 
books set theory omit axiom altogether 
axiom regularity expressed useful form transfinite induction 
replacement axiom involves concept class function function defined entire universe sets 
examples include power set operator successor operator succ 
set theory function graph 
graph class function big set represented place predicate 
theory set assumes class function expressed isabelle term possibly involving lk description operator 
experience gives evidence favour traditional formulation replacement axiom 
derived rules theory derives sequent calculus axioms 
figures rules refer constants set logical constants 
rule named thin weakened 
typical weakened rule formula omitted premises allow repeated application rule looping proof procedure incomplete 
scheme variables appear premises 
backwards proof rules introduce new variables subgoals 

zermelo fraenkel set theory symbol meta type precedence description term term term left function application int term term term right intersection un term term term right union term term term right difference term term term right inclusion element term term form right subset term term form right membership infixes term empty set inf term infinite set pow term term powerset operator union term term big union operator inter term term big intersection operator pair term term term pairing operator succ term term successor operator choose term term choice operator collect term term form term separation operator replace term term term term replacement operator constants external internal standard notation collect replace replace collect notation term term term identifier identifier term form term identifier term term identifier term form 
grammar syntax set chapter 
isabelle set type theories null left def pair def empty set finite sets ordered pairs subset def equal members ext def subsets equality extensionality pow def pow collect def collect replace def replace exists power set separation replacement union def union ex un def un union inter def inter union int def int diff def union intersection difference succ def succ un inf right inf inf right succ inf succ inf choose choose induction infinity choice transfinite induction meta axioms set 
zermelo fraenkel set theory null right right left subset right subset left thin equal right equal left left thin left thin finite sets subsets equality extensionality union right thin union union left union un right un left un inter right inter inter left thin inter int right int int left diff right diff left union intersection difference derived sequent calculus set chapter 
isabelle set type theories pow right pow pow left pow collect right collect collect left collect replace right thin replace replace left replace power set separation replacement derived sequent calculus set continued recall rule called unsafe reduce provable goal unprovable subgoals 
rule subset left thin uses fact reason reduces obviously valid subgoals valid subgoals false 
safe variant rule reduce subgoals trivially valid 
contrast subset right safe true premise true arbitrary rules big intersection completely analogous big union empty set 
clearly equals 
expect equal universal set zf set theory 
definition happens equal may regard undefined 
rule inter right says ifc non empty implies collection derived rules considers set operators subset relation shown 
tactics set theorem prover uses pack techniques lk 
set theory sequent calculus prove theorems sets logical connectives 
proofs shorter involve rules lk 
combining packs gives various collections rules repeat goal tac 
equality reasoning difficult extensionality rules surprising amount equalities 
rewriting ought provided 
sequent rules set theory belong set pack 
extensionality rules equal right left thin belong ext pack 
rules treat 
zermelo fraenkel set theory set pack costly 
calling set tac tackles subgoal triv pack set pack 
calling tac tackles subgoal set theory predicate calculus rules triv pack set pack lk pack 
single step tactics debugging 
calling set step tac applies subgoal rule triv pack set pack 
calling step tac applies subgoal rule triv pack set pack pack 
summary tactics ext pack pack set pack pack set step tac int tactic set tac int tactic step tac int tactic tac int tactic examples simple example intersections powersets prove half equation pow pow pow 
compared order logic set theory involve maze rules 
proof go straight solution 
instructive try proof choosing rules observing 
enter goal forced step right 
goal set rule thy pow int pow int pow level pow int pow int pow 
pow int pow int pow resolve tac subset right level pow int pow int pow 
ka 
ka pow int ka pow int pow note parameter ka subgoal says element ka element pow pow 
pow left replaced instance subset relation 
resolve tac pow left level pow int pow int pow 
ka 
ka int ka pow int pow intersection conjunction intersection right produces subgoals 
henceforth subgoal 
resolve tac int right level pow int pow int pow 
ka 
ka int ka pow 
ka 
ka int ka pow chapter 
isabelle set type theories pow converted subset reduced 
resolve tac pow right level pow int pow int pow 
ka 
ka int ka 
ka 
ka int ka pow resolve tac subset right level pow int pow int pow 
ka kb 
ka int kb ka kb 
ka 
ka int ka pow val unit subgoal parameters ka kb 
reduce subset relation left asking element ka asserting element element may depend ka kb 
resolve tac subset left thin level pow int pow int pow 
ka kb 
kb ka kb ka kb ka 
ka kb 
ka kb int kb ka kb 
ka 
ka int ka pow subgoal formulae right 
recall suffices prove assuming left 
resolution basic sequent instantiates term ka kb kb solving subgoal 
resolve tac basic level pow int pow int pow 
ka kb 
kb int kb ka kb 
ka 
ka int ka pow note occurrences ka kb instantiated 
showing element element simple matter 
resolve tac int left level pow int pow int pow kb kb kb ka kb 
ka 
ka int ka pow resolve tac basic level pow int pow int pow 
ka 
ka int ka pow 
zermelo fraenkel set theory remaining subgoal tackled back level 
repeating steps go automatic tactic 
set tac level pow int pow int pow subgoals 
calling set tac step proof 
example prove big union monotonic implies 
inference reduces right 
goal set rule thy union union level union union 
union union resolve tac subset right level union union 
ka 
ka union ka union big union existential quantifier occurrence left reduced right 
resolve tac union left level union union ka kb kb ka union steps infer kb follows kb resolve tac subset left thin level union union ka kb kb ka union ka kb 
ka kb 
ka kb ka kb kb ka union resolve tac basic level union union kb ka kb kb ka union possible step reduce big union operator right 
resolve tac union right thin level union union kb ka kb kb ka ka kb kb ka kb kb ka kb chapter 
isabelle set type theories show ka suffices find element moment called ka kb containing ka element 
subgoals proved resolution basic sequent 
resolve tac basic level union union kb ka kb kb kb resolve tac basic level union union subgoals 
calling set tac proved theorem immediately 
proofs big intersection tend complicated ill behaved empty set 
theorem difficult proof inter int inter int inter traditional notation large example justifies standard definition pairing 
proving implies easier said done 
constructive type theory isabelle written intuitionistic theory types formal system great complexity 
original formulation kind sequent calculus 
included rules building context variable bindings types 
typical judgement xn xn xn xn early versions isabelle object logic itt implemented sequent calculus 
satisfactory assumptions suppose type suppose type formalized 
isabelle permits natural deduction formulation type theory 
judgement expressed xn xn xn xn xn section presupposes knowledge martin 

constructive type theory assumptions judgement forms instance express family types type isabelle logic called ctt constructive type theory distinguish obsolete predecessor 
justify ctt formulation probably best appeal directly semantic explanations rules rules 
order assumptions longer matters standard type theory 
am sure faithfully ctt reflects martin semantics researchers type theory bother considerations 
type theory supported apart list types ordering types universes 
universes introduced la tarski adding new constants names types 
formulation la russell types denote possible identify meta types aterm atype 
ctt uses version equality judgements eq interchangeable 
rewriting tactics prove theorems form new equality rules rewriting tactics prove theorems form eq large construction 
syntax rules inference meta types types expressions 
constants shown 
infixes include function application operator called apply place type operators 
note meta level abstraction application differ object level abstraction application lam empty type called element type finite sets built ctt syntax similar university gothenburg sweden 
write sum prod sum prod recall type abbreviated abbreviated provided depend isabelle accepts abbreviations parsing uses possible printing 
equality versions rules called long versions rules describing computation called computation rules 
rules reproduced illustrate syntax 
shows rules include zero ne succ fourth peano axiom derived universes page 
shows rules general product 
extra judgement reduce implement rewriting 
judgement reduce holds holds 
holds syntactically identical ill typed rule refl red verify belongs rules give rise new theorems standard judgements note rule reduce chapter 
isabelle set type theories symbol meta type precedence description term term term left function application type type type right product types type type type right sum types type type type right function type infixes external internal standard notation prod prod prod sum sum sum lam lambda translations prop type type type type term type term term type type prod identifier type type sum identifier type type term lam identifier term term term 
grammar syntax ctt 
constructive type theory symbol meta type description type type prop judgement form type type prop judgement form elem term type prop judgement form term term type prop judgement form reduce term term type prop extra judgement form type natural numbers type term constructor succ term term constructor rec term term term term term term eliminator prod type term type type general product type lambda term term term constructor sum type term type type general sum type pair term term term constructor split term term term term term eliminator fst snd term term projections inl inr term term constructors term term term term term term eliminator eq type term term type equality type eq term constructor type empty type contr term term eliminator type singleton type tt term constructor constants ctt chapter 
isabelle set type theories form type intr intr succ succ intr succ long succ succ elim succ rec elim long succ rec rec comp succ rec comp succ succ rec succ rec succ zero ne succ succ meta axioms type prod form type type prod type prod form long prod prod prod intr type lambda prod prod intr long type lambda lambda prod prod elim prod prod elim long prod prod comp lambda prod comp prod lam prod meta axioms product type 
constructive type theory plus form type type type plus form long plus intr inl btype inl plus intr inr type inr plus intr inl long btype inl inl plus intr inr long type inr inr plus elim inl inr plus elim long inl inr plus comp inl inl inr inl inl plus comp inr inl inr inr inr type refl red reduce red equal reduce trans red reduce judgement reduce fst def fst split snd def snd split definitions meta axioms ctt chapter 
isabelle set type theories subst prod elim prod sum elim fst sum fst sum elim snd sum type type snd fst derived rules ctt trans red premise ensures typed 
shows rules reduce definitions fst snd 
shows rules sum types 
proof procedures repeatedly resolving certain type theory rules proof state 
theory defines lists type thm list related rules 
form rls formation rules types eq form long rls long formation rules eq 
types refl type 
intr rls rules types andt 
intr long rls long rules 
refl elem 
elim rls elimination rules types andf 
rules eq omitted involve eliminator 
elim long rls long elimination rules andf 
comp rls computation rules types 
eq involve eliminator 
basic defs definitions shown 
tactics type theory tactics provide rewriting type inference logical reasoning 
derived rules shown 
rule subst prod elim derived prod elim easier backwards proof 
rules sum elim fst sum elim snd express properties fst snd 

constructive type theory subgoal reordering blind application rules seldom leads proof 
rules especially elimination rules create subgoals containing new schematic variables 
variables unify causing search 
standard tactics filt resolve tac compat resolve tac appendix reject ambiguous goals ctt tactic test assume tac 
tactical repeat achieve simple kind subgoal reordering inappropriate subgoals ignored 
try doing single step proofs study examples see necessary 
object level simplification accomplished proof ctt equality rules built rewriting functor 
rewrites computation rules long versions rules 
transitivity extra judgement 
meta level simplification handles definitional equality 
calling test assume tac subgoal form head scheme variable calls assume tac solve subgoal assumption 
cases rejected 
ctt tactics subgoal reordering 
important type thm list tactic 
uses built rules additional rules argument 
calling tac thms uses formation elimination rules check typing constructions 
designed solve goals rigid flexible 
performs type inference essentially milner algorithm expressed rules 
tactic solve goals form type 
calling equal tac thms solves goals rigid long elimination rules 
intended deriving long rules defined constants arithmetic operators 
tactic perform type checking 
calling intr tac thms uses rules break type 
designed goals flexible rigid 
typically arise trying prove proposition expressed type 
calling rew tac thms applies left right rewrite rules 
solves goal rewriting ifb scheme variable assigned rewritten form subgoals rewritten 
calling hyp rew tac thms rewrites subgoal theorems rewrite rules assumptions 
tactics logical reasoning interpreting propositions types lets ctt express statements intuitionistic logic 
proof procedures fol adapted ctt prove statements automatically 
constructive type theory just syntax order logic 
key question assumptions deleted 
occurrence type represents proposition type theory assumptions declare variables 
order logic elimination assumption creates subgoal chapter 
isabelle set type theories assuming assuming deleted 
type theory elimination assumption creates subgoal assuming assuming arbitrary 
deleting may render subgoals unprovable assumptions refer people argue subgoals meaningful 
tactic mp tac performs modus ponens assumptions 
calling mp tac searches assumptions form subgoal replaces subgoal parameter replaced 
unification may take place selecting implication antecedent unifiable assumption 
tactic add mp tac mp tac assumption retained 
calling tac thms attacks subgoal formation rules certain safe rules elim prod intr sum elim plus elim calling mp tac appropriate 
uses theorems thms typically premises rule derived 
calling safe tac thms tries solve subgoal backtracking tac thms step tactic 
calling step tac thms tries reduce subgoal tac tries unsafe rules 
may produce multiple outcomes 
calling pc tac thms tries solve subgoal backtracking step tac thms step tactic 
tactic logical reasoning type checking 
summary tactics belong structure ctt resolve add mp tac int tactic mp tac int tactic pc tac thm list int tactic tac thm list int tactic safe tac thm list int tactic step tac thm list int tactic example type inference type inference involves proving goal form term scheme variable standing type 
type initially unknown takes shape course proof 
example predecessor function natural numbers 
goal ctt rule thy lam rec level lam rec 
lam rec name borrowed inappropriate type theory 
tactic performs unsafe steps incomplete 

constructive type theory term constructive type theory abstraction confused meta level abstraction rule worth considering 
result gets instantiated product type domain range unknown 
resolve tac prod intr level lam rec prod 
type 
ka 
ka rec ka ka subgoal solved ways invalidate subgoal 
tackle subgoal 
asks type term rec elimination 
eresolve tac elim level lam rec prod ka ka ka 
type 
ka 
ka 
ka kb kc 
kb kc ka kb kb ka succ kb know type natural numbers 
continue subgoal 
type 
resolve tac intr level lam rec 
type kb kc kb type determined ka equivalent prove subgoals show original term validly typed 
current subgoal provable assumption 
remaining subgoal falls formation 
assume tac level lam rec 
type resolve tac form level lam rec subgoals 
calling tac prove theorem step 
extract theorem call result 
function insists theorem identical goal chapter 
isabelle set type theories instantiated 
result result proved different theorem exception error raised lam rec examples logical reasoning logical reasoning type theory involves proving goal form type expresses proposition scheme variable standing proof term value type term course initially unknown type inference 
takes shape proof 
example expresses propositions types theorem quantifiers sorted logic seen generalization distributive law type theory derive rule type type type derive rule premises bound ml variable 
premises returned goal name prems 
val prems goal ctt rule thy type type type sum sum sum level sum sum 
sum sum val prems thm list premises involves summation 
premise assumption goal eresolve tac 
insert 
constructive type theory calling cut facts tac prems apply elimination rule calling resolve tac 
resolve tac sum elim level split sum sum 
sum 
ka kb 
ka kb ka ka kb sum sum call resolve tac time premises solves subgoal 
subgoal new parameters 
main goal instantiated split term 
resolve tac prems level split sum sum 
ka kb 
ka kb ka ka ka kb sum sum assumption kb ka ka eliminated causing case split new parameter 
observe main goal appears 
eresolve tac plus elim level split ka kb 
kb ka kb ka kb sum sum 
ka kb 
ka kc 
kc ka ka kb kc sum sum 
ka kb 
ka kc 
kc ka ka kb kc sum sum complete proof object main goal need instantiate terms ka kb kc ka kb kc 
attack subgoal 
assumptions ka kc ka take left injection inl 
resolve tac plus intr inl level split ka kb 
kb kc 
inl ka kb kc ka kb sum sum 
ka kb 
ka kc 
kc ka ka kb kc sum 
ka kb 
ka kc 
kc ka sum type 
ka kb 
ka kc 
kc ka ka kb kc sum sum chapter 
isabelle set type theories new subgoal appeared verify type 
continuing subgoal introduce resolve tac sum intr level split ka kb 
kb kc 
inl ka kb kc ka kb kc ka kb sum sum 
ka kb 
ka kc 
kc ka ka kb kc 
ka kb 
ka kc 
kc ka ka kb kc ka kb kc 
ka kb 
ka kc 
kc ka sum type 
ka kb 
ka kc 
kc ka ka kb kc sum sum new subgoals hold assumption assume tac level split ka kb 
kb kc 
inl ka ka kb kc ka kb sum sum 
ka kb 
ka kc 
kc ka ka kb kc ka 
ka kb 
ka kc 
kc ka sum type 
ka kb 
ka kc 
kc ka ka kb kc sum sum assume tac level split ka kb 
kb kc 
inl ka kc ka kb sum sum 
ka kb 
ka kc 
kc ka sum type 
ka kb 
ka kc 
kc ka ka kb kc sum sum subgoal just type checking yields tac provided premises ml variable prems supplied 
tac prems level split ka kb 
kb kc 
inl ka kc ka kb sum sum 
ka kb 
ka kc 
kc ka ka kb kc sum sum 
constructive type theory tedious 
prove case pc tac 
prems level split ka kb 
kb kc 
inl ka kc kc 
inr ka kc sum sum subgoals 
proof derives currying functional type includes special case type argument functional function maps toc resulting function maps toc 
family family 
val prems goal ctt rule thy type type sum type prod sum prod prod level prod sum 
prod prod 

prod sum 
prod prod 
val prems thm list proved step pc tac 
observe instantiated 
prems level lam ka 
lam kb 
lam kc 
ka kb kc prod sum 
prod prod 
subgoals 
examples martin performed isabelle 
law elimination page derived step pc tac 
choice principle page delicate proof steps 
resulting constructions equivalent published martin arithmetic largest example develops elementary arithmetic properties addition multiplication subtraction division remainder culminating theorem mod chapter 
isabelle set type theories local open syntax def val mixfix infixr aterm aterm aterm infixr aterm aterm aterm infixr aterm aterm aterm infixr aterm aterm aterm infixr aterm aterm aterm infixr aterm aterm aterm val arith ext logical types mixfix mixfix parse translation print translation val arith const decs constants mixfix val arith syn syntax extend ctt syntax syn arith ext val arith thy enrich theory ctt rule thy arith arith const decs arith syn add def rec succ diff def rec rec def mult def rec mod def rec rec succ succ quo def rec rec succ succ defining theory arithmetic 
higher order logic declaration arith thy appears 
demonstrates extend theory 
see chapter complete description infix kinds syntax definitions 
axioms define operator terms 
operator defined isabelle accepts arbitrary axioms complaint 
type theory permits primitive recursion definitions may unfamiliar 
difference computed computing predecessors predecessor function rec remainder counts cyclic fashion count reach cyclic count returns zero 
absolute difference gives equality test 
quotient computed adding number 
lemmas leading main result include commutative distributive associative laws 
higher order logic isabelle theory hol combines aspects object logics 
formulation higher order logic includes type system rich constructive type theory logical rules generalizing order logic theory classes 
gone long way origins church version simple theory types development continuing 
discussing isabelle version date 
logic large preliminary justify detailed discussion 
shall just consider syntax rules 
figures syntax inference rules 
lists constants gives definitions 
forms judgement means value type means formula true formulae sorted order logic 
higher order reasoning reflection functions term form map formulae terms type bool 
terms include descriptions pairs abstractions class abstractions 
boolean valued abstractions viewed sets 
theory ctt arith ml sample proofs ctt ex arith ml chapter 
isabelle set type theories types include general products sums generalizing types dependent types possible subtypes form formula may depend variables 
founded recursion 
type natural numbers embodies axiom infinity permitting construction list tree types 
isabelle implementation derives disjoint sums type lists 
tactics theory hol provides tactics similar classical order logic see section 
exploit swap rule get effect sequent calculus 
perform type checking 
generated functor accepts classical natural deduction systems 
module pc works just logical connectives module class uses class theory 
natural deduction rules derived logical constants defined equationally class theory union intersection functions 
main tactics described 
remember belong structures refer fast tac write pc fast tac class fast tac forth 
tactic onestep tac performs safe step 
calling onestep tac tries solve subgoal completely assumption absurdity tries mp tac tries safe rules 
tac thms tries reduce subgoal safe rules unsafe rules including thms 
may produce multiple outcomes 
calling fast tac thms tries solve subgoal backtracking step tac thms step tactic 
argument thms supplies additional rules 
calling best tac thms tries solve subgoals best search step tac 
calling comp tac thms tries solve subgoals best search 
step tactic expand quantifiers repeatedly necessary 
summary tactics belong structures pc class best tac thm list tactic comp tac thm list tactic fast tac thm list int tactic onestep tac int tactic step tac thm list int tactic rewriting tactics available 
type thm list tactic 
calling rew tac thms applies left right rewrite rules 
solves subgoal rewriting ifb scheme variable assigned rewritten form subgoals rewritten 

higher order logic symbol meta type precedence description term term form left class membership form form form right conjunction form form form right disjunction form form form right implication form form form right term term term left function application type type type right product types type type type right sum types type type type right function type infixes external internal standard notation forall ex exists pick pick lam lambda abstraction lambda term class prod subtype pi subtype product sum sigma sum prod function space sum binary product translations syntax hol chapter 
isabelle set type theories prop form term type form identifier type form ex identifier type form form term term type term pick identifier type form lam identifier type form identifier type form type prod identifier type type sum identifier type type 
grammar hol calling hyp rew tac thms rewrites subgoal theorems rewrite rules assumptions 
may universal quantifier 
examples theory hol comes body derived rules 
range simple properties logical constants class theory simplification lemmas tarski theorem founded recursion 
dozens worth studying 
deriving natural deduction rules logical constants defining equations requires higher order reasoning 
illustrates derive rules involving definitions 
derive rules conjunction 
enter desired rule deriving rule list premises bound ml variable prems 
val prems goal hol rule thy level subgoals rewritten definition conjunction rewrite goals tac conj def level 
bool 
form form 
higher order logic symbol meta type description form prop truth formula elem term type prop membership type form form negation eq reduce term term type form typed equality pick type term form term description forall exists type term form form quantifiers term form term reflection term form term form reflection form void type empty type unit type singleton type subtype type term form type subtypes bool type type truth values true false form elements bool cond type term term term term conditional nat type natural numbers type term constructor succ term term constructor rec term term term term term term eliminator pi type term type type general product type lambda term term term constructor sigma type term type type general sum type pair term term term constructor split term term term term term eliminator fst snd term term projections inl inr term term constructors type type type term term term term term term eliminator subset type term term form subset relation un type term term term union classes int type term term term intersection classes union type term term union family inter type term term intersection family pow type term term constants hol chapter 
isabelle set type theories pair type sum sigma elim sum pair inject sum fst type sum fst snd type sum snd fst fst conv fst snd conv snd split def split fst snd type subtype intr subtype elim subtype elim subtypes term type term bool term conv bool term form bool form intr form term form elim form term term congr term term bool reflection pick type ex pick pick congr ex pick pick pick intr ex pick descriptions rules hol 
higher order logic false def false term bool form true def true term bool form form conj def bool 
form form disj def bool 
form form form def form false iff def exists def ex bool 
form form definitions logical constants void def void bool 
form false unit def unit bool 
true bool plus def bool bool 
ex inl bool bool ex inr bool bool inl def inl lam false inr def inr lam false def pick 

inl 
inr definitions types definitions hol chapter 
isabelle set type theories rules applied resolve tac intr level 
ka 
ka bool form ka form ka resolve tac imp intr level 
ka 
ka bool form ka form ka rule applied twice subgoal resulting subgoal completely decomposing implication 
eresolve tac imp elim level 
ka 
ka bool 
ka 
ka bool form ka form ka eresolve tac imp elim level 
ka 
ka bool 
ka 
ka bool 
ka 
ka bool form ka form ka subgoals proved premises supplied resolve tac 
resolve tac prems level 
ka 
ka bool 
ka 
ka bool form ka form ka resolve tac prems level 
ka 
ka bool form ka form ka remaining subgoal holds assumption 
rule just derived premises 
assume tac level subgoals 
result 
higher order logic derivation elimination rule requires reflection 
bind list premises case prems 
val prems goal hol rule thy level 
working premises involve defined constants tricky 
simplest method uses cut facts tac 
premises assumptions subgoal rewritten rewrite goals tac 
cut facts tac prems level rewrite goals tac conj def level 
bool 
form form rewritten assumption broken eresolve tac elim level 
form form 
bool eresolve tac imp elim level 
form 
form 
bool applying form elimination rule subgoal solves instantiating term 
key step 
eresolve tac form elim level 
form term 
term bool chapter 
isabelle set type theories implications subgoal decomposed applications resolve tac imp intr level 
form term 
term bool resolve tac imp intr level 
form term 
term bool subgoal holds form term equivalent second trivial typing condition 
eresolve tac form intr level 
term bool resolve tac term type level subgoals 
result developing tactics rules theories chapter single step proofs studied give gentle isabelle logics 
gain experience realize way prove significant 
single step proofs long 
isabelle basic tactics combined form sophisticated ones operators called tacticals 
resulting tactics perform hundreds thousands inferences invocation 
simple prolog interpreter easily expressed 
chapter describes extend logic new constants axioms definitions 
definitions viewed abbreviations meta level rewrite rules 
expanding abbreviations lead gigantic formulae tedious proofs 
deriving rules new constants permits shorter proofs 
tacticals tacticals provide control structure tactics operators resembling regular expressions 
tacticals orelse repeat form new tactics follows tactic tac tac performs tac followed tac form sequencing 
tactic tac orelse tac performs tac fails tac form choice 
tactic repeat tac performs tac repeatedly fails form repetition 
users systems lcf hol nuprl recognize tacticals people may find descriptions simple 
descriptions mere sketches complex operations involving sequences proof states 
understand take closer look tactics 
chapter 
developing tactics rules theories type tactics isabelle tactic maps theorem representing proof state possibly infinite sequence proof states datatype tactic tactic thm thm sequence seq lazy lists implemented ml type sequence seq described appendix need know details type isabelle builtin tacticals may find discussion comprehensible programming experience lazy lists 
higher order unification return infinite sequence results tactics invoke especially resolve tac eresolve tac assume tac 
multiple proof states arise tactics supplied rule unifiable subgoal 
subgoal unifiable assumptions assume tac returns multiple outcomes 
considerations apply basic tactics require sequences proof states 
lcf tactic returns result fails 
returning possibly infinite sequence outcomes isabelle tactics perform backtracking search 
furthermore search strategies expressed tacticals operations tactics 
chapter describes isabelle tactics 
tac tac interest identities tacticals 
tactic tac identity element tactical 
maps proof state element sequence containing state 
succeeds states 
tactic tac identity element tacticals orelse append maps proof state empty sequence 
succeeds state 
basic tacticals tacticals combining sequences proof states 
tactic constructed tacticals consider output sequence results applied proof state 
tactic tac tac computes tac obtaining sequence states 
applies tac states 
output sequence concatenation sequences tac tac tac 
common notation lazy lists output tac tac tactic tac orelse tac computes tac 
sequence non empty returned result tac returned 
deterministic choice bit prolog cut directive 
tac succeeds tac excluded consideration 
tactic tac append tac returns concatenation sequences tac tac 
fair interleaving tac infinite 
tacticals sequence result 
tactical interleaving written append uses causes excessive branching search 
tactic tac truncates sequence tac element 
resulting tactic deterministic 
tactical limit search space 
tacticals ary versions orelse 
list tactics 
tactic tac behaves tac 
tac tactic tac behaves tac orelse 
orelse tac derived tacticals tacticals suffice describe implement sophisticated ones 
recursively defined tacticals perform repetition search 
describe output sequence returned new tactic applied state 
tactic try tac returns tac sequence non empty returns singleton sequence 
definition tactical ml fun try tac tac orelse tac tactic repeat tac computes tac 
sequence non empty tactic recursively applies element concatenating results 
returns singleton sequence 
ml definition function applies tactic state fun repeat tac tactic fn state tac repeat tac orelse tac state recursive tacticals coded awkward fashion avoid infinite recursion 
tac return multiple outcomes repeat tac 
repeat uses orelse append applies tac times possible outcome 
common idiom repeat tac orelse tac repeatedly applies tac times possible giving priority tac 
tactic depth tac performs depth search satisfactory proof states returns true 
true attractive definition loops fun repeat tac tac repeat tac orelse tac chapter 
developing tactics rules theories tactic returns tactic recursively applied element tac results concatenated 
ml definition involves state function permitting inspection initial state fun depth tac state fn state state tac tac depth tac tactic best tac returns sequence satisfactory proof states best search 
function tests state satisfactory returns cost 
collection states tactic chooses state having cost computes tac 
sequence contains satisfactory states returned result search 
replaced elements tac search continues 
initial collection states contains just input state 
cost function typically size state 
tactic breadth tac performs breadth search satisfactory proof states returns true 
applications slow 
tacticals numbered subgoals tactics resolve tac designate subgoal number 
tacticals exploit numbering subgoals 
typical example repeat resolve tac rules repeatedly applies rules subgoal eventually solve subgoals 
resolve tac fails numbered subgoal exist repetition terminates subgoals remain 
tactic depth solve tac performs depth search states having fewer subgoals initial state 
function fewer prems common satisfaction predicate 
testing number subgoals fewer prems holds just state fewer subgoals 
particular tactic depth fewer prems tac searches tac proof state having subgoals 
tacticals applied function tf type int tactic assume tac currying resolve tac rules 
apply tactic tf proof state 
tactic tf applied state subgoals behaves tf 
tf go tf may add delete subgoals altering numbering subgoal 
examples tacticals tactic tf applied state subgoals behaves tf orelse 
orelse tf instance assume tac solves subgoal assume tac fails 
tactical works repeat repeatedly attacking subgoal 
infixes orelse append provided ease writing tactics involving subgoal numbers 
defined follows fun tac tac fn tac tac fun tac orelse tac fn tac orelse tac fun tac append tac fn tac append tac instance tactic resolve tac thms orelse assume tac solves subgoal resolve tac thms assume tac 
readable fn resolve tac thms orelse assume tac summary tactics tacticals tac tactic int tactic tactic append tactic tactic tactic append tactic tactic tactic best thm bool thm int tactic tactic breadth thm bool tactic tactic depth thm bool tactic tactic depth solve tactic tactic tactic tactic tactic list tactic tactic list tactic tac tactic orelse tactic tactic tactic orelse tactic tactic tactic repeat tactic tactic int tactic tactic tactic tactic tactic tactic tactic tactic try tactic tactic examples tacticals far valuable tacticals orelse repeat 
express natural control structures letting avoid typing command sequences 
instance consider proving order theorem chapter 
developing tactics rules theories apply rules succession resolve tac apply assume tac twice total commands 
want try proof 
tacticals proof accomplished steps 
goal int rule thy level 
repeatedly apply resolve tac subgoal 
supply rules needed repeat resolve tac intr imp intr conj intr level 
ka 
ka kb 
ka kb ka kb 
ka 
ka kb 
ka kb ka rules applied possible 
subgoals result solved assumption 
repeat assume tac level subgoals 
single tactic combining repetition assume tac resolve tac prove theorem single command repeat assume tac orelse resolve tac intr imp intr conj intr elimination rules applied repeatedly eresolve tac 
tactic selects assumption deletes allow termination 
proof goes order critical applied subgoal 
tackle proof follows goal int rule thy ex ex ex level ex ex ex 
ex ex ex resolve tac imp intr level ex ex ex 
ex ex ex 
prolog interpreter repeatedly applying eliminations subgoal gets stuck 
needs rule repeat eresolve tac exists elim disj elim level ex ex ex 
ka 
ka ex 
ex ex deal subgoal resume applying eliminations 
theorem proved step tactic combines elimination rules proof assumption 
revert original state calling apply tactic level ex ex ex 
ex ex ex repeat assume tac orelse eresolve tac exists elim disj elim orelse resolve tac imp intr exists intr level ex ex ex subgoals 
note exists elim tried exists intr 
exists case unification finds terms automatically 
prolog interpreter demonstrate power tacticals construct prolog interpreter execute programs involving lists 
illustrate extend theory new constants axioms 
function adding rules theory called extend theory fully described chapter 
example may serve model allowing small theory extensions knowing theories 
prolog program take form theory 
avoid having define extra syntax theory extension order logic interpreter exploit fol rules 
theory defines constants meta types nil term cons term term term append term term term form reverse term term form chapter 
developing tactics rules theories viewed object level nil constant cons place function append place predicate reverse place predicate 
declare const decs hold constant declarations val const decs nil aterm cons aterm aterm aterm append aterm aterm aterm aform reverse aterm aterm aform theory defines append rules correspond usual prolog clauses append nil ys ys append xs ys zs append cons xs ys cons zs defines reverse slow version append reverse nil nil reverse xs ys append ys cons nil zs reverse cons xs zs rules included theory declaration val prolog thy extend theory int rule thy prolog const decs append nil ys ys append xs ys zs append cons xs ys cons zs reverse nil nil reverse xs ys append ys cons nil zs reverse cons xs zs go point point 
theory extends int rule thy theory intuitionistic order logic 
string prolog essentially comment part theory value helps identify 
pair const decs combines empty list type names constant declarations 
new types seldom required theory extensions 
final list consists rules paired names represented strings 
evaluating declaration parses type checks rules constructs theory binds ml identifier prolog thy 
rules bound 
prolog interpreter ml identifiers function get axiom 
val get axiom prolog thy val thm val get axiom prolog thy val thm val get axiom prolog thy val thm val get axiom prolog thy val thm repeated application rules solves prolog goals 
append lists goal prolog thy append cons cons cons nil cons cons nil level append cons cons cons nil cons cons nil 
append cons cons cons nil cons cons nil rules applied observe answer builds scheme variable resolve tac level append cons cons cons nil cons cons nil cons zs 
append cons cons nil cons cons nil zs resolve tac level append cons cons cons nil cons cons nil cons cons zs 
append cons nil cons cons nil zs seen main goal elements result list resolve tac level append cons cons cons nil cons cons nil cons cons cons zs 
append nil cons cons nil zs resolve tac level append cons cons cons nil cons cons nil cons cons cons cons cons nil subgoals 
prolog run functions backwards 
list appended produce 
goal prolog thy append cons cons nil cons cons cons cons nil level append cons cons nil cons cons cons cons nil 
append cons cons nil cons cons cons cons nil chapter 
developing tactics rules theories tactical repeat answer 
repeat resolve tac level append cons cons nil cons cons nil cons cons cons cons nil subgoals 
example backtracking 
lists appended form list 
goal prolog thy append cons cons cons cons nil level append cons cons cons cons nil 
append cons cons cons cons nil repeat apply rules find solution quickly 
repeat resolve tac level append nil cons cons cons cons nil cons cons cons cons nil subgoals 
subgoal module back command finds possible outcome tactic 
back level append cons nil cons cons cons nil cons cons cons cons nil subgoals 
solutions generated similarly 
back level append cons cons nil cons cons nil cons cons cons cons nil subgoals 
solution 
solutions back level append cons cons cons nil cons nil cons cons cons cons nil subgoals 
back level append cons cons cons cons nil nil cons cons cons cons nil subgoals 

prolog interpreter solution back backtrack alternatives exception error raised try reverse 
reverse list 
goal prolog thy reverse cons cons cons cons nil level reverse cons cons cons cons nil 
reverse cons cons cons cons nil bundle rules ml identifier rules giving resolve tac 
naive reverse runs surprisingly fast 
val rules val rules thm list repeat resolve tac rules level reverse cons cons cons cons nil cons cons cons cons nil subgoals 
run reverse backwards reverse list 
list reverse 
goal prolog thy reverse cons cons cons nil level reverse cons cons cons nil 
reverse cons cons cons nil repeat resolve tac rules level reverse cons nil cons cons cons nil 
append nil cons nil cons cons cons nil tactic failed find solution 
reaches dead subgoal appended equals 
outcomes considered backtracking 
back level reverse cons cons nil cons cons cons nil 
append nil cons nil cons cons nil dead outcome success 
back level reverse cons cons cons nil cons cons cons nil subgoals 
chapter 
developing tactics rules theories problem repeat stops continue regardless state reached 
tactical depth searches satisfactory state subgoals 
return start proof solve depth search 
level reverse cons cons cons nil 
reverse cons cons cons nil depth fewer prems resolve tac rules level reverse cons cons cons nil cons cons cons nil subgoals 
prolog uses depth search tactic prolog interpreter 
real prolog systems run overwhelmingly faster logic programming techniques great importance designing isabelle tactics 
name 
val prolog tac depth fewer prems resolve tac rules val prolog tac tactic fn tactic try example goal prolog thy reverse cons cons cons cons nil cons cons cons level reverse cons cons cons cons nil cons cons cons 
reverse cons cons cons cons nil cons cons cons tactic prolog tac solves immediately prolog tac level reverse cons cons cons cons nil cons cons cons cons nil subgoals 
deriving rules tacticals complicated mechanism writing short proofs 
simplest way write short proofs derived rules 
section describes derive rules isabelle showing pitfalls avoid 

deriving rules suppose style proof involves replacing frequently 
want derive rule logical derivation simple wrong way derive rule isabelle goal try reduce subgoals 
try stating goal applying things working goal int rule thy level 
resolve tac conj intr level 

intend apply conjunction elimination rules subgoals reducing resolve tac conjunct level 

subgoal refers new variable 
things get worse especially mistake 
resolve tac conj intr level 


rule conjunct applied 
conj intr accepted modifying main goal 
words intended rule chapter 
developing tactics rules theories changed 

undo level 

resolve tac conjunct level 

way derive avoid problems remember things scheme variables main goal intended instantiated proof 
ordinary free variables 
state premises rule meta assumptions discussed 
isabelle meta logic natural deduction system theorems may depend assumptions 
theorems proofs assumptions accumulate 
proof discharged forming 
time free variables theorem converted schematic variables 
need perform meta inferences directly isabelle subgoal commands take care 
correct way derive rule 
premise proposed rule stated original goal 
command goal returns list theorems containing premise 
premise depends assumption may proof axiom 
val prems goal int rule thy level val prems 
thm list variable prems bound list premises returned goal 
seldom done premises resulting empty list ignored 
apply rules derivation 
resolve tac conj intr level 

resolve tac conjunct level 


deriving rules time incorrectly applied conj intr subgoal 
error impossible instantiated 
resolve tac conjunct level 

resolving subgoals premise instantiates variables completing derivation 
resolve tac prems level 
resolve tac prems level subgoals 
function result discharges premise scheme variables 
result expert replace steps initial conj intr tactic 
designed prevent rules conjunct conjunct causing infinite repetition 
apply goal body repeat insists solving resulting subgoal resolution premise repeat resolve tac conjunct conjunct resolve tac prems call resolve tac conjunct conjunct returns outcomes call resolve tac prems kills 
collection derivations may kept file executed batch mode function prove goal 
function creates initial proof state applies series tactics 
resulting state multiple outcomes generated returned prove goal checking identical chapter 
developing tactics rules theories theorem originally proposed 
subgoal commands prove goal purely functional 
derivation packaged follows val conj rule prove goal int rule thy fn prems resolve tac conj intr repeat resolve tac conjunct conjunct resolve tac prems theorem proved bound ml identifier conj rule 
definitions derived rules serious proofs seldom performed pure logic concern properties constructions consequences additional assumptions 
isabelle involves extending theory new constants definitions axioms 
isabelle little distinction defining trivial abbreviation succ defining entire logic 
considered example extending theory prolog interpreter 
shall definition prove rules 
classical order logic extended propositional connective theorems proved treating abbreviation 
tactic rewrite goals tac replace byp subgoals 
unfortunately may produce unreadable subgoal 
formula duplicated possibly causing exponential blowup 
problem tends get worse abbreviations introduced 
natural deduction demands rules introduce eliminate directly definition 
design natural rules seldom easy 
identity straightforwardly demonstrated suggests rule elimination rule follows definition elimination rules 
having plans get isabelle 
theory natural deduction classical logic cla thy extended constant type form form form form 
definitions derived rules axiom def equates val thy extend theory cla thy aform aform aform aform def val thy theory val def get axiom thy def val def thm derivations elimination rules demonstrate methods rewriting definitions 
complicated classical reasoning involved tactic pc fast tac able cope 
rule 
state premises goal 
calling rewrite goals tac rewrites occurrences subgoals leaving main goal unchanged 
val prems goal thy level 
val prems thm list rewrite goals tac def level premises variable prems passed pc fast tac uses proving goal 
pc fast tac prems level subgoals 
val intr result val intr thm state elimination rule 
premises rules 
simply val prems goal thy level 
val prems thm list rewrite occurrences premises 
way incorporate premises subgoal rewrite goals tac 
chapter 
developing tactics rules theories tactic cut facts tac inserts theorems subgoal assumptions 
simple theorems inserted rules having premises 
cut facts tac prems level 
assumption subgoal rewritten 
resulting subgoal falls pc fast tac 
rewrite goals tac def level pc fast tac prems level subgoals 
val elim result val elim thm way rewriting premises rewrite rule rule function theorems theorems 
calling rewrite rule def th rewrites occurrences theorem th 
occurrences premises may rewritten help standard list functional map map rewrite rule def prems val thm list premise affected 
observe assumptions appear square brackets right 
rules just derived saved names intr elim 
permit natural proofs theorems additional rules needed classical reasoning rule called iff intr confuse intr 

definitions derived rules display rules action analyse proof step step 
goal thy level 
resolve tac iff intr level 

elimination rule applied twice succession 
eresolve tac elim level 


eresolve tac elim level 



subgoals formulae reduced atoms 
applied 
observe rules break occurrences come top outermost connective 
resolve tac intr level 




resolve tac intr level 





chapter 
developing tactics rules theories stand 
subgoal holds assumption second third contradiction 
starting get tedious 
revert initial proof state solve thing 
tactic uses mp tac detect contradictions 
level 
repeat assume tac orelse mp tac orelse eresolve tac elim orelse resolve tac iff intr intr level subgoals 
example harder prove requires swap rule 
classical logic tactic pc step tac takes care 
try proof single steps 
goal thy level 
repeat pc step tac intr orelse eresolve tac elim level subgoals 
course dispense rules entirely treating abbreviation 
resulting propositional formula easily proved pc fast tac 
level 
rewrite goals tac def level pc fast tac level subgoals 
formulating theory sequent calculus lk avoid problem deriving rules sequent calculus complicated 

definitions derived rules formally speaking problems extended logic reduced basic logic 
approach merits especially prover basic logic poor error detection 
suppose goal hard prove 
reducing problem unreadable little hope determining wrong 
try prove invalid goal thy level 
repeat pc step tac intr orelse eresolve tac elim level 



subgoal unprovable tells false true original goal false 
fact evaluates true false 
subgoals recognizable form 
tackle original goal rewrite goals tac pc fast tac tactic fails terminate 
undo level 
rewrite goals tac def level val unit pc fast tac bad advertisement pc fast tac 
tactic simply failed idea goal invalid 
case isabelle 
chapter 
developing tactics rules theories defining logics chapter chapter isabelle experts 
explains define new logical systems isabelle raison tre 
doing isabelle internals discussed certain amount detail 
section describes internal representations types terms prerequisite understanding rest chapter 
followed sections define hierarchical theories precise definition meta logic syntax specify concrete syntax pretty printer new object logic 
section shows fits giving simple examples complete logic definitions 
types terms isabelle idea proofs logics naturally represented intuitionistic higher order logic henceforth called meta logic 
isabelle higher order logic terms typed calculus 
types terms represented ml types typ term 
ml type typ term type 
type typ defined follows infixr datatype typ ground string poly string op typ typ ground type name represented string polymorphic type type variable 
function type form types equal identical structure ml equality test correct types 
term type denotes function applied term type resulting term type term obey type checking rules typed calculus 
possible construct ill typed terms meta rules ensure terms theorems typed 
functions arguments expressed currying 
operator associates right chapter 
defining logics written ml operator writing example suppose types distinct types type typet 
thenf typet andf types ill typed 
note means 
type variables poly permit ml style type inference see section 
internally may appear theorems 
typed object logic represented making object level typing rules explicit 
see section constructive type theory ultimate example typed logic 
ml type term kinds term 
type string int infix datatype term const string typ free string typ var typ bound int abs string typ term op term term constant name type 
constants include connectives logical constants constants succ 
constants may required define concrete syntax logic 
free variable free name type 
scheme variable var type string paired non negative index 
var logically free variable 
stands variable may instantiated unification 
vars term systematically renamed incrementing indices 
prolog jargon logical variables may standardized apart 
bound variable name number de bruijn representation 
number counts number lambdas starting zero occurrence variable lambda binds 
representation prevents capture bound variables allowing simple quick substitution function 
type bound variable stored binding lambda abs node 
information see de bruijn look functions incr boundvars subst bounds 
abstraction stores name type bound variable body 
name parsing printing logical significance 
application consists term applied term 
constructor infix ml expression constructs application 
theories theories isabelle logics hierarchies theories 
theory consists signature inference rules 
signatures describe syntax logic concrete 
definition concrete syntax described great detail section 
section assume ml type abbreviations type sorts string list type ops string list typ list type rules string string list describe syntax corresponds signature universal algebra sorts list type names ops list typed constants declared theory 
example syntax defined introduces type names int form binary operations int binary function int form 
val tint ground int val ground form val int form val tint tint tint tint tint isabelle equivalent syntax trees 
syntax determines terms valid constants ground types declared term type correct 
context example const tint tint tint free tint valid term typ tint tint 
names types constants suggest represent addition subtraction equality respectively 
arbitrary strings priori connection concrete syntax exception name constant identifier opposed arbitrary string occurrence identifier input string treated constant special concrete syntax necessary 
parser know identifiers types 
reason ignores type information completely dummy typ parser terms generates 
real types inferred stage see section 
isabelle users need know internal concepts types constants think terms external representation determined concrete syntax associated theory 
ml type rules list pairs rule names rules example val irls comm chapter 
defining logics name rule arbitrary string rule conform syntax associated theory 
functions construct elements type theory theories incremental way pure thy theory enrich theory theory string sorts ops syntax rules theory extend theory theory string sorts ops rules theory merge theories theory theory theory type syntax hierarchical definition syntaxes described section 
pure thy contains just types constants syntax meta logic 
note rules meta logical inferences carried ml functions lcf 
enrich theory thy sorts ops syn returns new theory enriches thy ground types sorts constants ops rules 
concrete syntax new theory syn 
note concrete syntaxes built incrementally different set functions described section 
rules interpreted new signature 
frees replaced vars axioms written question marks 
name new theory merely reasons documentation 
example enrich theory pure thy int syn irls irls example syn defines appropriate syntax 
extend theory thy sorts ops equivalent enrich theory thy sorts ops syn syn concrete syntax theory thy 
simplified way enriching theories case new concrete syntax information added 
essence means signature extension involves identifiers 
merge theories th th merges theories th th 
resulting theory contains union types constants axioms constituent theories 
isabelle support overloading theory contain constants name different types 
trying create theory enriching merging raises exception 
constants name type identified theories enriched merged 
axioms extracted theories function get axiom theory string thm 
meta logic created theory axiom name get axiom returns arbitrary 
axiom name exception raised 
examples functions section 
meta logic define new object logics know meta logic 
section gave brief account features presents precise description syntax 
prop atomic prop prop prop prop prop prop prop id list prop prop atomic identifier variable identifier variable id list identifier identifier meta logic syntax syntactic category prop corresponds ml identifier typ 
type types 
initially contains just prop 
syntax extended new object logics productions added see section 
syntax constants equality implication universal quantification respectively 
atomic propositions qualified prop order allow formulae embedded meta logic minimal syntactic overhead 
seen type constraint 
syntax meta logic defined exactly way object logic 
ext contains definition changed easily suit different tastes 
chapter 
defining logics defining syntax isabelle supports syntax definitions form unrestricted context free grammars 
module syntax exports type syntax interface definition facility 
syntaxes built incremental fashion functions pure syntax extend syntax extension syntax merge syntax syntax syntax constant pure holds syntax pure isabelle higher order logic 
new syntaxes defined extending merging existing ones 
sequel extension abbreviate record type type extension logical types typ list mixfix mixfix list parse translation string term list term list print translation string term term list fields extension explained sections respectively 
sections explain define aspects syntax parsing section concerned unparsing 
mixfix syntax mixfix field extension defines actual syntax list productions type mixfix 
fact mixfix describes concrete syntax translation syntax pretty printing scheme 
isabelle syntax definitions inspired obj mixfix syntax 
element type mixfix datatype mixfix mixfix string typ string int list int string typ string infixl string typ int infixr string typ int defines production context free concrete syntax priorities associates typed syntax constant 
moment concentrate mixfix ml constructors 
derived forms 
simple introductory example relationship obj mixfix syntax isabelle variant consider obj declaration int int int isabelle mixfix ground int ground int ground int 
ml function constants explained section avoid having declare constants concrete syntax 
defining syntax arguments encode information priority part obj declaration 
general form mixfix sy ty con pl interpreted follows sy right hand side production specified obj mixfix form 
general sy form occurrence denotes argument nonterminal strings contain 
ty types nonterminals left right hand side 
sy form ty form ai may function types 
con name syntax constant associated production 
parsing phrase sy generates term const con ai term generated parsing th argument 
pl form pn pi minimal priority required phrase may appear th argument 
null list interpreted list appropriate length 
priority production 
notice close connection concrete syntax production associated syntax constant ml type typ represents types syntax syntactic categories concrete syntax 
emphasize connection refer nonterminals right hand side production arguments nonterminal left hand side result 
terms priority grammar format introduced section declaration mixfix sy ty con pl defines production tp maximal legal priority section called max pri 
want ignore priorities safest way mixfix max pri production puts priority constraints arguments remember equivalent maximum priority applicable exclude productions arguments 
example mixfix notation grammar example written follows mixfix aterm mixfix aterm aterm aterm mixfix aterm aterm aterm mixfix aterm aterm dummy type obvious ty consistent treatment types identifiers 
see section chapter 
defining logics parsing string produces term const const const 
interpretation mixfix declaration meta character represent argument position 
characters meta characters preceding character quote turns ordinary character 
write really want single quote 
purpose meta characters explained section 
remember ml strings different kind meta character 
derived forms ml constructors type mixfix derived mixfix 
semantics explained translation lists mixfix expressions sy ty con mixfix sy ty con max pri infixr sy ty mixfix op sy ty sy max pri mixfix sy ty sy infixl sy ty mixfix op sy ty sy max pri mixfix sy ty sy abbreviates common form priority independent production 
infixl infixr declare infix operators associate left right respectively 
ml prefixing infix operators op turns curried functions 
copy productions productions create new node syntax tree called copy productions 
exactly nonterminal right hand side 
term generated parsing nonterminal simply passed result parsing copy production 
isabelle copy production indicated empty constant name mixfix sy 
special kind copy production modulo white space sy 
called chain production 
chain productions seen abbreviation mechanism 
conceptually removed grammar adding appropriate new rules 
priority information attached chain productions ignored 
example demonstrates effect 
defining syntax example grammar defined mixfix ab mixfix mixfix mixfix admits string 
constant second production non empty string legal 
lexical conventions lexical analyzer distinguishes kinds tokens delimiters identifiers variables 
delimiters user defined extracted syntax definition 
mixfix declaration decomposed substrings 
separated contain white space blanks tabs newlines 
delimiter 
delimiter arbitrary string containing white space 
identifiers scheme variables predefined 
identifier sequence letters digits primes starting letter 
variable followed identifier optionally followed dot 
sequence digits 
parsing identifier generates free 
parsing variable generates var integer value longest numeric suffix possibly remaining prefix 
parsing variable generates var 
table covers different cases arise var var var var 
identifiers sid typ svar typ refer identifiers variables syntax definition 
example sid adds identifiers alternative syntactic category mixfix sid aform aform defines syntax universal quantification 
note chosen priorities prohibit nested quantifiers 
think sid svar nonterminals predefined syntax may assume productions priority max pri 
lexical analyzer translates input strings token lists repeatedly maximal prefix input string forms valid token 
maximal prefix chapter 
defining logics delimiter identifier variable treated delimiter 
white spaces separators 
important consequence translation scheme delimiters need separated white space recognized separate 
delimiter string treated consecutive occurrences 
contrast ml treat single undeclared identifier 
consequence isabelle liberal scheme string may parsed different way extending syntax adding delimiter input treated single occurrence 
parse translations far close relationship concrete syntax allow automatic translation constant names supplied production 
cases scheme powerful especially constructs involving variable bindings 
extension associate user defined translation function constant name parse translation field type string term list term list input string translated term syntax definition second phase term translated user supplied functions 
type translated follows 
form const tn returned unchanged 
ti translated ti 
const tn 
pair tab return 
apply tn 
raises exception return return result 
example isabelle represents phrase internally constant type term form form 
assuming term form represented concrete syntax mixfix allt allt sid aform aform 
parsing syntax yields term const free body quantified formula 
need term const abs syntax constant type aterm aform aform abstracted version define function fun free const abs free associate fragment syntax extension 
defining syntax mixfix mixfix allt parse translation 
remember replaced correct types stage see section 
logical types default syntax isabelle concerned mathematical languages certain minimal vocabulary identifiers variables parentheses lambda calculus 
syntactic categories allow phrases called logical types distinguish auxiliary categories id list expect able 
logical types field extension lists logical types introduced extension 
logical types ground form ground 
logical type productions added default identifier variable application id list abstraction type type constraint type identifier base type type type type function type id list identifier identifier application binds tightly abstraction loosely 
type logical types 
syntactic categories id list referred ml identifiers id list type typ respectively 
infix introduces type constraint 
interpretation type typ identifier denotes ground denotes denotations 
phrase term const constrain term produced typ denoted forced typ type constraints disappear type checking visible translation functions 
chapter 
defining logics printing syntax definitions provide printing information distinct ways syntax language parsing pretty printing information print translation functions 
bare mixfix declarations enable isabelle print terms result necessarily pretty may look different expected 
produce pleasing layout need read sections 
printing mixfix declarations const tn term mixfix sy mixfix declaration sy form printing means printing string result printing ti 
note system insert blanks 
part mixfix syntax required separate tokens achieve certain layout 
pretty printing order format output possible include pretty printing directions part mixfix syntax definition 
course directions ignored parsing affect printing 
characters interpreted meta characters mixfix definition 
meaning open block 
sequence digits interpreted indentation block 
causes output indented positions line break occurs block 
followed digit indentation defaults 
close block 
allow line break 
white spaces immediately printed line broken point 
print translations terms subject translation parsing see section similar mechanism translate back printing 
extension associate user defined translation function constant name print translation field type string term term list including pair results applied term head const printing 

defining syntax example example showed translate concrete syntax universal quantification proper internal form 
string parses const abs 
term printed translating back result 
abstraction turned back term matches concrete mixfix syntax fun abs id val id variant abs id const allt free id function variant abs basic term manipulation function replaces bound variable id free variable id having unique name 
term produced printed concrete syntax mixfix allt 
notice application fails second component argument abstraction example just free variable 
intentional signals caller intended translation inapplicable 
syntax extension including concrete syntax translation functions form mixfix mixfix allt parse translation print translation 
parse translation process types attached variables constants print translation immaterial printing insensitive types 
means definition function written const free id 
printing term set mixfix declarations set string function pairs print translations current syntax 
terms printed recursively 
free printed var printed ifi digit followed ifi digit ifs ends digit 
cases arise var var var abs abs abs abstraction printed result printing replaced new unique names 
chapter 
defining logics bound printed application const tn may 
printed follows pair print 
application raises exception pair set sy mixfix sy empty printed application 
sy mixfix declaration maximal number nonterminals arguments print sy print application 
applications printed applications 
printing term tn application means printing sn si result printing ti 
ifcis const argument 
terms printed described 
printer inserts parentheses necessary reasons priority 
miscellaneous addition ml identifiers introduced far syntax module provides functions read syntax typ string term calling read sy parses term type syntax sy 
valid types logical types see section function types 
input conform syntax error message printed exception error raised 
prin syntax term unit print top level syntax term unit sy tm performs inverse translation prints syntax sy 
print top level prin output written separate line 
print syntax syntax unit prints syntax readable format 
constants mixfix list string list typ list calling constants ml builds list pairs mixfix infixl ml 
occurrence loose bound variables indicates trying print subterm abstraction wrong print translations 

defining syntax table typed constants part ops argument extend theory enrich theory removing need declare constants twice 
syntax extensions introduce constants part term parser produces removed translation 
typical example example contrast part logical language represented syntax 
avoid picking constants constants selects strings start blank 
examples 
syntactic building blocks section introduces predefined syntactic classes utilities operating 
abstraction quantification lists variables common category id list see available typ id list 
example syntax object level universal quantification defined mixfix id list aform aform permitting phrases 
facilitate translation syntax additional functions defined 
abs list tr term term term term translates concrete syntax 
idl term type id list representing list variables vn abs list tr const idl body yields const abs vn const abs body 
body body free occurrence vi replaced bound 
syntax universal quantification introduced parse translation function associated defined fun idl body abs list tr const idl body replaces function name example 
abs list tr term string typ list term term performs reverse translation 
vars list variable names types vn tn abs list const vars body evaluates const body term type id list representing list variables un un list distinct names occurring body body body bound replaced free ui ti 
chapter 
defining logics case universal quantification print translation achieved fun tm abs list tr const strip vars tm strip body tm replaces function name example 
functions fun strip body tm const abs strip body tm strip body tm tm fun strip vars const abs strip vars strip vars tm predefined 
restrictions addition restrictions mentioned text ones apply 
constant names start 
type names start ground int 
parser designed context free grammar 
ambiguous grammar input string parse parser selects arbitrary issue warning 
identifiers constants type inference final step translation strings terms covered 
explains constants distinguished frees frees vars typed 
issues arise frees vars declared 
identifier appear delimiter concrete syntax free variable constant syntax 
parser knows constants appear concrete syntax description parses predefined dummy typ 
parser function read produces raw terms user interface level functions goal type terms syntax say step occurrence free const replaced const provided constant typ means identifiers treated frees iff declared syntax 
types remaining frees vars inferred ml 
resulting term contains polymorphic typ exception raised isabelle support polymorphism 
type constraints introduced section remove unwanted ambiguities polymorphism 

putting peculiarity current type inference algorithm variables name type irrespective free bound 
example take order formula constants type term term form term form form 
conjunct forces term term term second term 
distinct required type leading type clash formula 
putting having discussed individual building blocks logic definition remains shown fit 
particular need say object logic syntax hooked meta logic 
theorems conform syntax prop see syntax extended object level syntax 
assume syntax object logic defines category form formulae 
formulae appear axioms theorems prop add production prop form 
precisely need coercion formulae propositions mixfix aform prop constant prop name arbitrary acts invisible coercion function 
simplest nontrivial logics minimal logic implication 
definition isabelle needs advanced features illustrates mechanism quite nicely val aform ground form val mixfix mixfix aform prop infixr aform aform aform val impl syn extend pure logical types aform mixfix mixfix parse translation print translation val impl thy enrich theory pure thy impl form constants mixfix impl syn mp chapter 
defining logics start prove theorems logic goal impl thy level 
resolve tac get axiom impl thy mp level 

resolve tac get axiom impl thy mp level 


resolve tac get axiom impl thy level 

resolve tac get axiom impl thy level 
resolve tac get axiom impl thy level subgoals 
see hilbert style formulation minimal logic easy define difficult 
natural deduction formulation far preferable val thy enrich theory pure thy impl form constants impl ext impl syn note systems equivalent fact proved isabelle derived thy exercise derived thy 
reason admissible rule impl thy shown induction possible proofs impl thy 
simple matter extend minimal logic falsity new syntax involved val nf thy extend theory thy extension false aform false 
putting hand may wish introduce conjunction val mixfix mixfix aform prop infixr aform aform aform val conj syn extend pure logical types aform mixfix mixfix parse translation print translation val thy enrich theory pure thy conj form constants mixfix conj syn el er want connectives define val thy merge theories nf thy thy prove mixed theorems goal thy false resolve tac get axiom thy resolve tac get axiom thy eresolve tac get axiom thy er try exercise 
chapter 
defining logics internals appendix appendix tour isabelle sources listing functions identifiers types purpose 
types terms isabelle types terms typed calculus 
basic declarations exceptions isabelle mainly signal errors 
exception includes string error message data identify error 
exception type string typ list term list signals errors involving types terms 
exception term error string term list signals errors involving terms 
ml identifiers denote symbols meta logic 
type propositions 
implication symbol implies 
term universal quantifier type term equals equality predicate type operations number basic functions terms types 
op typ list typ typ types forms type 
loose term int list appendix internals calling loose returns list loose bound variable 
particular bound loose enclosed abstraction 
loose enclosed abstractions enclosed just list contain number 
formed term contain loose variables 
computes type term raises applications typed 
op term term bool calling tests terms convertible identical renaming bound variables 
constants frees vars convertible just names types equal 
variables having name different types distinct 
confusing situation avoided 
bound variables convertible just number 
abstractions convertible just bodies bound variables type 
applications convertible just corresponding subterms 
incr boundvars int term term increments term loose bound variables offset required moving subterm context enclosed different number lambdas 
term term term abstracting term subterm replaces occurrence bound variable correct index 
calling subst bounds un substitutes ui loose bound variables achieves reduction un replacing bound ui 
xy bound variable indices 
appropriate call subst bounds 
loose bound variables reduced compensate disappearance lambdas 
subst term term term list term term simultaneous substitution atomic terms term 
atomic term constant kind variable 
term term int 
types terms computes maximum index vars term 
vars result 
term match term term list term term term term list calling term match vts instantiates vars int match resulting list variable term pairs extends vts typically empty 
order pattern matching implement meta level rewriting 
representation object rules module logic contains operations concerned inference especially constructing terms represent object rules 
op term term bool term occur 
reflexive relation 
add term vars term term list term list accumulates vars term suppressing duplicates 
second argument list vars far 
add term frees term term list term list accumulates frees term suppressing duplicates 
second argument list frees far 
mk equals term term term term dest equals term term term returns pair 
list implies term list term term pair term 
strip imp prems term term list returns list 
strip imp concl term term returns term 
list equals term term list term term appendix internals adding flex flex constraints object rule 
tk uk term tk uk 
strip equals term term term list term tk uk returns tk uk 
rule term term list term list term term object rule triple tk uk returns term tk uk strip horn term term term list term list term breaks object rule parts tk uk returns triple tk uk 
strip term term int list string typ list term strips premises rule allowing general form may intermixed 
typical assumptions subgoal natural deduction 
returns additional information number names types quantified variables 
discussion assumptions see section 
strip prems int term list term term list term finding premise subgoal triple returns triple need atomic 
raises exception range 
higher order unification unification resolution object rules 
logics formalized typed calculus isabelle uses huet higher order unification algorithm 
sequences module sequence declares type unbounded sequences usual closure idea page 
sequences defined terms type option declared isabelle basic library handles possible presence value 
datatype option 
higher order unification operations type seq include conversion lists sequences truncation concatenation mapping function sequence 
sequences unification tactics 
normally closed declares 
type seq type possibly unbounded sequences type unit seq option seq calling fn constructs sequence head tail evaluated 
null seq fn empty sequence 
single seq fn null element sequence 
pull seq seq option sequence empty sequence head tail 
evaluated 
calling pull recompute value 
stored 
append seq seq seq concatenates sequences 
flats seq seq seq concatenates sequence sequences 
maps seq seq applies function element sequence producing new sequence 
environments module normally closed declares type environments 
environment holds variable assignments index generating variable 
datatype env term int operations lookup update generation variables unification 
empty int env appendix internals creates environment assignments index 
lookup env term option looks variable specified returns appropriate 
update term env env variable term environment produces new environment variable updated 
side effect environment 
env typ env term generates variable type returns paired new environment incremented field 
alist env term list converts environment association list containing assignments 
norm term env term term copies term assignments environment performing possible reductions 
rewrite env term term list term term rewrites term term pairs rewrite rules 
assignments ignored environment generate unique vars placeholders bound variables 
unification functions module unify implements unification 
uses depth search depth limit set 
switch tracing specify print function tracing 
search bound int ref default holds depth limit unification search 
message unification bound exceeded appears search cut 
usually means search run forever proofs require increasing default value search bound 
printer term unit ref 
higher order unification function print terms tracing 
set function prin 
default dummy prints 
trace bound int ref default tracing information printed search depth exceeds bound 
trace simp bool ref default false controls tracing information include simpl phase unification 
match traced 
unifiers env term term list env term term list seq main unification function 
environment list disagreement pairs returns sequence outcomes 
outcome consists updated environment list flex flex pairs discussed 
smash unifiers env term term list env seq unification function maps environment list disagreement pairs sequence updated environments 
function flex flex pairs choosing obvious unifier 
may tidy flex flex pairs remaining proof 
flexible flexible disagreement pairs flexible flexible disagreement pair heads terms variables 
set flex flex pairs obvious unifier usually 
function unifiers returns flex flex pairs constrain unifications smash unifiers uses obvious unifier eliminate flex flex pairs 
example unifiers include 
trivial unifier introduces new variable 
unifiers instance 
flex flex pairs simplified eliminate redundant bound variables shown example xy xy bound variable right hand term 
unifier terms delete occurrences left 
choosing new variable assignment uv reduces disagreement pair xy xy losing unifiers 
dropped sides adjusting bound variable indices leave assigning eliminates unifies terms 
appendix internals multiple unifiers higher order unification generate unbounded sequence unifiers 
multiple unifiers indicate ambiguity usually source ambiguity obvious 
unifiers natural 
solving solution better reveals dependence unifiers case 
isabelle generates better ones preferring projection imitation 
unification procedure performs huet match operation big steps 
solves tp finding ways copying trying projection arguments ti 
copies variable returns new variable resulting flex flex disagreement pair 
encounters allows projection 
prevents looping obvious cases fooled cycles involving disagreement pairs 
incomplete 
associative unification associative unification comes free encoded function composition associative operation page 
represent lists new constant 
empty list list tn represented term tn unifiers give ways expressing tn concatenation lists 
standard associative unification technique represent certain infinite sets unifiers finite sets containing flex flex disagreement pairs 
represent list 
garbage terms may appear pairs accumulate dramatically 
associative unification handles sequent calculus rules comma associative operator multiple unifiers occur resolved goal containing conjunction left 
note really need associative unification associative matching 
terms valid signature module sign declares types signatures checked terms 
signature contains syntactic information needed building theory 
checked term simply term checked conform signature packaged type 
terms valid signature ml type sg signature lists ground types may appear terms theory 
lexical symbol table declares constant infix variable keyword 
syntax contains theory notation internal format concerns users logical meaning 
type sg gnd types string list ground types const tab typ symtab table types constants ident tab typ symtab table default types identifiers syn syntax syntax parsing printing operations stamps string ref list unique theory identifier stamps identify theory 
primitive theory single stamp 
union theories taken lists stamps merged 
unique identifiers 
compared contents 
signatures combined new provided constants compatible 
identifier constant signatures kind symbol type signatures 
union operation idempotent commutative associative 
build signatures ought different syntax functions functions compared 
ml type cterm term valid signature provided type declared signature constant declared constant infix type signature 
typed monomorphic loose bound variables 
note subterm valid term need valid may contain loose bound variables 
valid subterm loose bound variable 
checked term stored signature type maximum index vars 
information computed checks 
datatype cterm cterm sign sg term typ int inference rules maintain terms theorem valid theorem signature 
rules specialization operate terms take raw terms checking 
possible obtain theorems saving effort checking terms 
appendix internals declarations important declarations module sign 
module normally closed 
type sg type signatures type constructor exported 
signature created calling new typically call prim theory 
type cterm type checked terms 
cterm created calling cterm read cterm 
rep sg sg gnd types string list table 
representation function type sg returns underlying record 
new string 
sg calling new gnd types parser printer creates new signature named type names lexical table parser printing functions 
rep cterm cterm typ int sign sg term representation function type cterm 
term cterm term maps cterm underlying term 
cterm sg term cterm signature term checks term valid signature produces corresponding cterm 
raises exception term error message type error term term signature appropriate 
read cterm sg string typ cterm reads string term parsing information signature 
checks term valid produce cterm 
note type supplied aids type inference considerably 
intended interactive read cterm catches various exceptions arise prints error messages 
commands goal call read cterm 
print cterm cterm unit 
meta inference prints cterm printing function signature 
print term sg term unit prints term printing function signature 
type assign cterm cterm produces cterm updating signature argument include variable type assignments 
type inference resulting signature assume type assignments argument 
goal package give persistence type assignments proof 
contrast lcf sticky types page 
meta inference theorems theories mutually recursive 
theorem associated theory theory contains axioms theorems 
avoid circularity theorem contains signature theory 
module thm declares theorems theories meta rules 
sign module critical isabelle correctness modules call construct valid terms theorems 
theorems natural deduction system meta logic represented obvious sequent calculus 
theorems form set hypotheses proposition 
meta theorem signature stores maximum index vars 
datatype thm thm sign sign sg int hyps term list prop term proof state subgoals main goal represented object rule turn represented meta theorem tk uk field hyps holds set meta level assumptions 
field prop holds entire proposition broken 
function returns pairs prems returns concl returns 
exception thm string int thm list appendix internals signals incorrect arguments meta rules 
tuple consists message premise number premises 
rep thm thm prop term hyps term list 
function returns representation theorem underlying record 
thm term term list maps theorem list flex flex constraints tk uk 
prems thm term list maps theorem premises 
concl thm term maps theorem 
meta rules meta rules implemented 
raise exception thm signal malformed premises incompatible signatures similar errors 
assume sign cterm thm sequent checking contains vars 
recall vars allowed 
implies intr sign cterm thm thm 
implies elim thm thm thm elimination 
forall intr sign cterm thm thm rule generalizes variable var 
variable free hypotheses var check 
forall elim sign cterm thm thm elimination 
reflexive sign cterm thm reflexivity equality 
symmetric thm thm symmetry equality 
transitive thm thm thm transitivity equality 
instantiate sign cterm sign cterm list thm thm simultaneous substitution terms distinct vars 
result normalized 

meta inference definitions axiom form defines constant term rewriting axiom unfolds constant replaces rewriting theorem obtained rule symmetric folds constant replaces rules concerned definitions 
rewrite rule thm list thm thm uses list equality theorems rewrite theorem 
rewriting right continues rewrites applicable subterm 
rewrite goals rule thm list thm thm uses list equality theorems rewrite just antecedents theorem typically proof state 
unfolds definitions subgoals main goal 
unfolding needed proving basic theorems defined symbol 
proofs treat symbol primitive 
example firstorder logic bi implication defined terms implication conjunction deriving basic rules connective forget definition 
treatment definitions contrasted theorem provers defined symbols automatically unfolded 
derived meta rules backwards proof rules coded directly ml efficiency handle backwards proof 
typically involve proof state subgoal form xk may preceded zero quantifiers scope extends 
represent assumptions subgoal xj represent parameters 
object rule lifted assumptions parameters subgoal write lifted object rule recall example form xk appendix internals obtained replacing free variables certain terms 
rule raises exception thm subgoal exist 
resolution thm int thm list thm sequence seq state rules performs higher order resolution theorem rules typically object rule subgoal proof state held theorem state 
sequence theorems contains result successful unification replacing instantiating variables state 
rules order 
assumption thm int thm sequence seq state attempts solve subgoal assumption natural deduction 
call tries unification form sequence theorems contains outcome successful unification deleted variables may instantiated state 
thm int bool thm list thm sequence seq state pairs form true rule involve implicit call assumption 
permits natural deduction object rules sequent style principal formula deleted 
write lifted object rule rule interpreted elimination rule major premise insist finding assumptions subgoal call tries unification form sequence theorems contains result successful unification replacing subgoals instantiating variables state 
relevant assumption deleted subgoals unification involved occurrence deleted pairs form false rule treated exactly resolution 
pairs order 
trivial sign cterm thm theorem initial state backwards proof 
proposition may contain vars 
tactics tacticals obscure tactics tacticals derived meta rules items available 

tactics tacticals derived rules derived rules implemented primitive rules 
forall intr frees thm thm generalizes meta theorem free variables free hypotheses 
forall elim vars int thm thm replaces outermost quantified variables vars index 
zero var indexes thm thm replaces having index preserving distinctness renaming necessary 
standard thm thm puts meta theorem standard form hypotheses free variables outer quantifiers 
generality expressed vars having index 
resolve thm int thm list thm calling resolve rules tries rules turn resolving premise 
raises exception thm resolution produces exactly result 
function paste object rules making simple derived rules 
op res thm thm thm calling rule res rule equivalent resolve rule rule resolves rule premise rule 
raises exception thm exactly unifier 
tactics tactics mainly intended proof procedures process lots rules 
res inst tac single step proofs keep control unification 
tac bool thm list int tactic analogous resolve tac calls 
suitable mixture rules paired false elimination rules paired true 
res inst tac string string typ list thm int tactic appendix internals selective instantiation variables res inst tac rule reads strings obtaining variable term type term may refer parameters subgoal tactic modifies compensate parameters lifts rule assumptions subgoal 
tactic replaces rule resolves subgoal 
smash ff tac tactic eliminates flex flex constraints proof state applying trivial higherorder unifier 
filtering object rules higher order resolution involving long list rules slow 
filtering techniques shorten list rules resolution 
second filtering detect resolving subgoal cause excessive branching 
rules applicable subgoal selected 
module implements data structure fast selection rules 
term classified head string string symbols obtained argument function calls var encountered 
instance constructive type theory judgement rec succ head string elem rec succ constant elem represents judgement form head strings compatible equal prefix 
terms incompatible head strings clearly unifiable 
theorem classified head string indicating goals resolve 
method fast easy implement powerful 
head strings discriminate terms arguments 
type theory rules inl type second argument head string discriminate types 
unify term term bool function quickly detects terms 
assumes variables distinct reporting may unify 
filt resolve tac thm list int int tactic calling filt resolve tac rules maxr uses resolve discover applicable 
number tactic fails returning null sequence 
behaves resolve tac 
compat resolve tac thm list int int tactic 
tactics tacticals calling compat resolve tac rules maxr builds rules discover applicable subgoal number exceeds maxr tactic fails returning null sequence 
behaves resolve tac 
avoid repeated construction apply compat resolve tac list rules bind result identifier 
appendix internals bibliography de bruijn lambda calculus notation nameless dummies tool automatic formula manipulation application church rosser theorem mathematicae pages 
futatsugi goguen 
jouannaud meseguer principles obj th acm symposium principles programming languages pages 
gallier logic computer science foundations automatic theorem proving harper row 
huet unification algorithm typed calculus theoretical computer science pages 
huet lang proving applying program transformations expressed second order patterns acta informatica pages 
martin intuitionistic type theory bibliopolis 
paulson natural deduction higher order resolution journal logic programming pages 
paulson logic computation interactive proof cambridge lcf cambridge university press 
paulson foundation generic theorem prover journal automated reasoning 
paulson isabelle theorem provers odifreddi editor logic computer science academic press press 
pelletier problems testing automatic theorem provers journal automated reasoning pages 
suppes axiomatic set theory dover publications 
takeuti proof theory nd edition north holland 
whitehead russell principia mathematica paperback edition cambridge university press 
functional programming standard ml prentice hall 
index prop constrain abs abs list tr abs list tr add term frees add term vars tac append append append assume assume tac assumption back best tac bound breadth chop compat resolve tac concl const constants unify cut facts tac depth depth solve dest equals enrich theory eresolve tac extend extend theory extension filt resolve tac flats fold tac forall elim forall elim vars forall intr forall intr frees index free get axiom getstate goal goals limit ground fewer prems identifier id list implies elim implies intr incr boundvars infixl infixr instantiate list equals list implies logical types loose maps max pri term merge merge theories mixfix mixfix mk equals tac null op option orelse orelse parse translation poly pr prems prin print syntax print top level print translation printer prop prove goal pull pure pure thy read reflexive rep thm repeat res res inst tac resolution resolve resolve tac result rewrite goals rule rewrite goals tac rewrite rule rewrite tac rule search bound seq setstate sid single smash ff tac standard strip strip equals strip horn strip imp concl strip imp prems index strip prems subst bounds subst term svar symmetric tactic tactic term term match theory thm trace bound trace simp transitive trivial try typ type undo var variable variant abs zero var indexes 
