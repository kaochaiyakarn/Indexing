extended appears proc 
th acm conference computer communications security ccs washington dc usa 
asynchronous verifiable secret sharing proactive cryptosystems christian cachin klaus kursawe anna lysyanskaya august verifiable secret sharing important primitive distributed cryptography 
growing interest deployment threshold cryptosystems practice traditional assumption synchronous network reconsidered generalized asynchronous model 
proposes practical verifiable secret sharing protocol asynchronous networks 
protocol creates discrete logarithm sharing uses quadratic number messages number participating servers 
yields asynchronous byzantine agreement protocol standard model efficiency suitable practice 
proactive cryptosystems important application verifiable secret sharing 
second part introduces proactive cryptosystems asynchronous networks presents efficient protocol refreshing shares secret key discrete logarithm sharings 
idea threshold cryptography distribute power cryptosystem fault tolerant way 
cryptographic operation performed single server group servers adversary corrupts servers observes secret key shares break cryptosystem prevent system correctly performing operation 
threshold cryptosystem operates longer time period may realistic assume adversary corrupts servers entire lifetime system 
proactive cryptosystems address problem operating phases tolerate corruption different servers phase 
rely assumption servers may erase data special reboot procedure remove adversary corrupted server 
idea proactively reboot servers phase subsequently refresh secret key shares phase knowledge shares previous phases give adversary advantage 
proactive cryptosystems tolerate mobile adversary may move server server eventually corrupt server system 
refreshing distributed protocol network model determines cryptosystem proactively secure 
synchronous networks delay messages bounded proactive cryptosystems known see 
asynchronous networks proactive cryptosystem known far 
absence common clock arbitrary delay messages problems arise clear define proactive phase servers common notion time 
second notion common phase imposed external means message refresh protocol delayed arbitrarily phase boundaries poses additional problems 
needs asynchronous share refreshing protocol 
ibm research zurich research laboratory ch switzerland 
cca rts zurich ibm 
com 
brown university providence ri usa anna cs brown edu 
done ibm zurich 
distributed share refreshing protocols proactive cryptosystems rely verifiable secret sharing 
verifiable secret sharing fundamental primitive distributed cryptography numerous applications secure multi party computation byzantine agreement threshold cryptosystems 
verifiable secret sharing protocol allows distinguished server called dealer distribute shares secret group servers qualified subgroup servers may reconstruct secret corrupted servers learn information secret 
furthermore servers need reach agreement success sharing case dealer faulty 
asynchronous verifiable secret sharing protocols proposed previously 
existing solutions prohibitively expensive suitable practical best message complexity communication complexity log 
surprising achieve unconditional security 
contrast consider computational setting obtain efficient protocol 
protocol achieves message complexity communication complexity security parameter optimal resilience 
specifically assume hardness discrete logarithm problem 
protocol reminiscent pedersen scheme dealer creates dimensional polynomial sharing secret 
servers exchange asynchronous rounds messages reach agreement success sharing analogous deterministic reliable broadcast protocol bracha 
combining verifiable secret sharing scheme protocol canetti rabin obtain asynchronous byzantine agreement protocol provably secure standard model efficiency suitable practice 
respect asynchronous proactive cryptosystems contributions twofold 
conceptual level propose formal model cryptosystems asynchronous proactive networks technical level efficient protocol proactively refreshing discrete logarithm shares secret key 
model asynchronous proactive network extends asynchronous network timer accessible server 
timer scheduled adversary defines phase server locally 
assume adversary corrupts servers local phase 
uncorrupted servers local phase may communicate private authenticated channels 
channel guarantee message delayed longer local phase lasts lost 
proactive cryptosystem refreshes sharing secret key phase sufficiently servers enter local phase 
model implies liveness cryptosystem guaranteed extent adversary delay messages refresh protocol longer phase lasts 
secret key may 
despite danger believe model achieves coverage real world loosely synchronized networks internet phase typically lasts longer maximal delay message network 
propose efficient proactive refresh protocol discrete logarithm sharings 
builds verifiable secret sharing protocol randomized asynchronous multi valued byzantine agreement primitive :10.1.1.106.7506
refresh protocol achieves optimal resilience expected message complexity communication complexity 
organization section introduce system model recall definition asynchronous multi valued byzantine agreement external validity 
section defines asynchronous verifiable secret sharing presents efficient protocol creating discrete logarithm sharings secret 
section extend asynchronous system model proactive network section describe asynchronously refresh shares secret key discrete logarithm cryptosystems 
preliminaries asynchronous system model adopt basic system model describe asynchronous network servers computationally bounded adversary 
computational model parameterized security parameter function called negligible exists 
network 
network consists servers 
pn probabilistic interactive turing machines run polynomial time 
adversary runs polynomial time 
servers controlled adversary called corrupted remaining servers called honest 
adversary corrupts servers called limited 
initialization algorithm run trusted party system starts 
input parameters generates state information initialize servers may thought read tape 
assume pair servers linked secure asynchronous channel provides privacy authenticity scheduling determined adversary 
contrast adversary observes network traffic 
formally model network follows 
communication driven adversary 
exists global set messages elements identified label denoting sender receiver length message 
adversary sees labels messages contents 
initially empty 
system proceeds steps 
step adversary performs computation chooses honest server pi selects message label 
pi activated communication input tape 
activated pi reads contents communication input tape performs computation generates response messages writes communication output tape 
response message may contain destination address index server 
added label pj honest pj corrupted adversary 
case control returns adversary 
step repeated arbitrarily adversary halts 
steps define sequence events view logical time 
phrase certain point time refer event 
assume adaptive adversary may corrupt server pi point time activating input message 
case messages label removed adversary 
gains complete control pi obtains entire view pi point may send messages label 
view server consists initialization data messages received random choices far 
termination 
define termination protocol instance extent adversary chooses deliver messages honest servers 
technically termination protocol follows bound number messages honest servers generate behalf protocol independent adversary 
say message associated particular protocol instance generated server honest protocol execution behalf protocol 
message complexity protocol defined number associated messages generated honest servers 
random variable depends adversary 
similarly communication complexity protocol defined bit length associated messages generated honest servers 
random variable depends adversary 
recall adversary runs time polynomial 
assume parameter bounded fixed polynomial independent adversary holds messages protocol larger messages ignored 
particular protocol protocol statistic family real valued non negative random variables xa parameterized adversary security parameter xa random variable induced running system 
message complexity example statistic 
restrict protocol statistics bounded polynomial adversary running time 
say protocol statistic uniformly bounded exists fixed polynomial adversaries negligible function pr xa 
protocol statistic called probabilistically uniformly bounded exists fixed polynomial fixed negligible function adversaries negligible function pr xa lp 
probabilistically uniformly bounded adversaries xa hidden constant independent additionally probabilistically uniformly bounded probabilistically uniformly bounded probabilistically uniformly bounded probabilistically uniformly bounded statistics closed polynomial composition main benefit analyzing composition randomized protocols :10.1.1.106.7506
protocol execution notation 
introduce notation writing asynchronous protocols 
recall server activated input message message added internal input buffer activation 
model protocols invoked adversary 
protocol instance identified unique string id called tag chosen adversary invokes instance 
may threads execution server active concurrently 
server activated threads wait states 
wait state specifies condition defined received messages contained input buffer local state variables 
threads wait state condition satisfied thread scheduled arbitrarily thread runs reaches wait state 
process continues threads wait state condition satisfied 
activation server terminated control returns adversary 
types messages protocols process generate type contains input actions represent local activation carry input protocol output actions signal termination potentially carry output protocol messages called local events 
second message type ordinary point point network message delivered peer protocol instance running server messages called protocol messages 
messages denoted tuple id 
tag id denotes protocol instance message associated 
input actions form id type 
output actions form id type 
type defined protocol specification 
messages form id type 
protocol messages type defined protocol implementation 
describe protocols modular way protocol instance may invoke protocol instance sending suitable input action obtain output output action sub protocol 
realized server internal mechanism message generated calling protocol contains input action sub protocol creates corresponding protocol instance running delivers input action furthermore passes output actions sub protocol calling protocol adding input buffer 
pseudo code notation describing protocols follows 
enter wait state thread may execute command form wait condition condition ordinary predicate input buffer state variables 
executing command thread enters wait state condition 
specify condition form receiving messages events 
case messages describes set protocol messages events describes set local events outputs sub protocol satisfying certain predicate possibly involving state variables 
executing command thread enters wait state waiting arrival messages satisfying predicate predicate satisfied matching messages moved input buffer local state variables 
set matching messages chosen arbitrarily 
may specify condition form detecting messages 
semantics receiving messages matching messages copied input buffer local state variables 
global implicit wait statement protocol instance repeatedly executes matches conditions clauses form condition block 
time condition satisfied corresponding block executed 
satisfied condition corresponding blocks executed arbitrary order 
terminology condition block denote block executed long specified condition hold 
thread enters wait state block activation server changes internal state specified condition holds execution block aborted 
cryptographic assumptions large primes satisfying denote multiplicative subgroup order zp generators chosen initialization algorithm server knows log discrete logarithm problem compute log description generator element assume problem hard solve means probabilistic polynomial time algorithm solves problem negligible probability 
multi valued validated byzantine agreement byzantine agreement fundamental problem distributed computation 
asynchronous networks impossible solve deterministic protocols means resort randomized protocols 
polynomial time solution problem canetti rabin 
standard notion byzantine agreement implements binary decision asynchronous networks 
guarantee particular outcome honest servers propose value 
validated byzantine agreement extends arbitrary domains means called external validity condition 
global polynomial time computable predicate qid known servers determined external application 
server may propose value contains validation information 
agreement ensures decision value satisfies qid proposed server 
server pi starts validated byzantine agreement vba protocol tag id input say pi proposes id honest servers propose values satisfy qid 
server terminates validated byzantine agreement protocol tag id outputs value say pi decides id definition 
validated byzantine agreement protocol validated byzantine agreement predicate qid satisfies conditions limited adversary negligible probability external validity honest server terminates decides id qid holds 
agreement honest server decides id honest server terminates decides id liveness honest servers activated id associated messages delivered honest servers decided id integrity servers follow protocol server decides id server proposed id efficiency id communication complexity instance id probabilistically uniformly bounded 
protocol cachin multi valued validated byzantine agreement called consistent broadcast protocol protocol binary byzantine agreement rely threshold signatures threshold coin tossing protocol 
sub protocols implemented efficiently random oracle model 
primitives expected message complexity multi valued validated agreement expected communication complexity longest value proposed server length threshold signature 
protocols proven secure static adversaries :10.1.1.106.7506
show binary asynchronous byzantine agreement implemented efficiently standard model adaptive security verifiable secret sharing 
solution incurs larger communication complexity 
asynchronous verifiable secret sharing section define asynchronous verifiable secret sharing avss propose novel efficient avss protocol discrete logarithm problem 
definition consider dual threshold sharings generalize standard notion secret sharing allowing reconstruction threshold exceed number corrupted servers 
dual threshold sharing servers holding shares secret may corrupted adversary group servers may reconstruct secret 
dual threshold sharings important primitive distributed computation agreement problems 
protocol tag id share secret zq consists sharing stage reconstruction stage follows 
sharing stage 
sharing stage starts server initializes protocol 
case say server initializes sharing id special server pd called dealer activated additionally input message form id share 
occurs say pd shares id group 
server said complete sharing id generates output form id shared 
reconstruction stage 
server completed sharing may activated message id reconstruct 
case say server starts reconstruction id reconstruction stage server output shared secret 
server pi terminates reconstruction stage generating output form id reconstructed zi 
case say pi reconstructs zi id terminates protocol 
definition asynchronous verifiable secret sharing synchronous networks extra care required ensure servers agree fact valid sharing established 
definition provides computational correctness unconditional privacy 
definition 
protocol asynchronous verifiable dual threshold secret sharing satisfies conditions limited adversary liveness adversary initializes honest servers sharing id delivers associated messages dealer pd honest sharing stage honest servers complete sharing negligible probability 
agreement provided adversary initializes honest servers sharing id delivers associated messages holds honest server completes sharing id honest servers complete sharing id honest servers subsequently start reconstruction id honest server pi reconstructs zi id negligible probability 
correctness honest servers completed sharing id exists fixed value zq holds negligible probability 
dealer shared id honest sharing stage 
honest server pi reconstructs zi id zi privacy honest dealer shared id honest servers started reconstruction id adversary information efficiency id communication complexity uniformly bounded 
conditions liveness conditions 
imply form termination agreement required byzantine generals problem implements reliable broadcast byzantine faults distinguished server 
servers terminate protocol distinguished server honest agree termination protocol honest servers terminate protocol generate output 
definition analogous definition avss information theoretical model canetti rabin 
implementation section describes novel verifiable secret sharing protocol asynchronous network computational security 
protocol creates discrete logarithm sharing kind introduced pedersen efficient previous vss protocols asynchronous networks proposed information theoretic model 
protocol uses exactly communication pattern asynchronous broadcast primitive proposed bracha implements byzantine generals problem asynchronous network 
protocol avss creates dual threshold sharing sharing stage works follows assume moment 

dealer computes dimensional sharing secret choosing random bivariate polynomial zq degree commits second random polynomial zq degree computing matrix cjl cjl jl 
dealer sends server pi message containing commitment matrix share polynomials ai sub share polynomials bi respectively 

receive message dealer servers echo points share sub share polynomials overlap 
effect pi sends message containing ai bi server pj 

receiving messages agree contain valid points server pi interpolates share sub share polynomials bi received points standard lagrange interpolation 
case dealer honest resulting polynomials message 
pi sends message containing bi server pj 
possible server receives messages agree contain valid points received valid echo messages 
case server interpolates share sub share polynomials messages sends message servers 

server receives total messages agree completes sharing 
share secret si 
reconstruction stage straightforward 
server pi reveals share si server waits shares servers consistent commitments interpolates secret shares 
smaller values particular protocol modified receive echo messages step 
guarantees uniqueness shared value 
detailed description protocol figures 
protocol description predicates verify poly polynomials degree bjx jx predicate verifies polynomials share sub share polynomials pi consistent true holds ij cjl holds il cjl verify point verifies values correspond points respectively committed pi supposedly receives pm true cjl mj cjl ij verify share verifies pair forms valid share pm respect true mj cj servers may need interpolate polynomial degree zq set points 
mk mk mj mj 
done standard lagrange interpolation 
abbreviate saying server interpolates contain elements arbitrary subset elements interpolation 
protocol description variables count number messages respectively 
instantiated separately values received incoming messages 
intuitively protocol avss performs reliable broadcast protocol bracha message servers pi pj additionally contains values common 
protocol uses messages communication complexity 
size messages dominated reduced factor shown section 
protocol avss server pi tag id sharing stage initialization ec rc ac bc receiving message id share pd choose random bivariate polynomials zq degree jl xj cjl cjl jl aj bj send message id send aj bj pj receiving message id send pd time verify poly send message id echo pj receiving message id echo pm time verify point ac ac bc bc ec ec ec max rc interpolate ac bc respectively send message id ready pj receiving message id ready pm time verify point ac ac bc bc rc rc rc ec max interpolate ac bc respectively send message id ready pj rc si si share pi output id shared protocol avss asynchronous verifiable secret sharing sharing stage 
protocol avss server pi tag id reconstruction stage receiving message id reconstruct send message id reconstruct share si pj receiving message id reconstruct share pm verify share interpolate output id reconstructed halt protocol avss asynchronous verifiable secret sharing reconstruction stage 
note protocol avss creates ordinary sharing optimal resilience sharing resilience 
open problem develop avss protocol comparable efficiency creates arbitrary dual threshold sharings sharings optimal resilience 
prove theorem section 
theorem 
assuming hardness discrete logarithm problem protocol avss implements asynchronous verifiable dual threshold secret sharing analysis show protocol avss satisfies liveness agreement correctness privacy efficiency definition 
proof relies lemma 
lemma 
suppose honest servers pi sends ready message containing ci distinct honest server pj sends message containing cj 
ci cj 
proof 
prove lemma contradiction 
suppose ci cj 
pi generates ready message ci received echo messages containing ci ready messages containing ci 
second case honest server sent message containing ci receiving echo messages may assume pi simplify rest argument 
pi received echo messages containing ci corrupted servers 
argumentation pj received echo messages containing cj 
echo messages received pi pj honest servers 
honest server generates message protocol 
liveness 
dealer pd honest follows directly inspection protocol honest servers complete sharing id provided servers initialize sharing id adversary delivers associated messages 
agreement 
show honest server completes sharing id honest servers complete sharing id provided servers initialize sharing id adversary delivers associated messages 
suppose honest server completed sharing 
received valid ready messages agree sent honest servers 
ready message satisfies verify point easy see definition verify poly verify point honest servers send messages 
honest server sends message servers honest server receives valid ready messages lemma sends ready message containing assumption theorem honest server receives valid ready messages containing completes sharing 
reconstruction part follows lemma honest server pi computes pi received messages respect computes messages valid share si respect share si holds 
honest servers subsequently start reconstruction stage server receives valid shares reconstruct value provided adversary delivers associated messages 
correctness 
index set honest servers pj completed sharing sj shares 
denote appropriate lagrange interpolation coefficients set position 
define sj 
prove part suppose dealer shared honest sharing stage 
contradiction assume dealer honest easy see message sent honest pi pj contains computed dealer 
furthermore servers computed shares echo messages sj 
honest server pi computed polynomial pi accepted echo ready message corrupted pm containing 
pi evaluated verify point true cjl mj 
hand dealer sent polynomials am pm satisfying am cjl ij am 
easy see lemma fact dealer honest dealer pi equal 
gam ha 
am implies 
rewriting log comparing exponents yields log am log 
compute log am contradiction 
prove second part assume distinct honest servers pi pj reconstruct values zi zj zi zj 
means received distinct sets si sj shares valid respect unique commitment matrix pi pj uniqueness follows lemma 
protocol zi zj interpolated sets obtained si sj respectively 
interpolated analogously 
shares si sj valid easy see zi zj rewrite log compute log zi zj 
privacy 
fix point time index set servers corrupted started reconstruction id assume adversary view consists polynomials commitments computed dealer 
show value zq exist polynomials zq degree consistent adversary view note unique value zq values polynomials view adversary define uniquely polynomials zq degree remains show clm lm 
define 
clm 
analogously define show 
recall construction 
inserting definition addition know ge definitions order 
polynomials equal 
efficiency 
honest server sends ready share message server yields total messages 
size messages bounded follows easily communication complexity uniformly bounded 
reducing message sizes sharing stage protocol avss described server pi resends commitment matrix message sends 
intuitively needed reasons allow honest servers agree value commitment secret shared second allow servers verify secret shares receive correspond commitment 
show section guarantee ends having servers resend data 
new protocol relies collision resistant hash function extra assumption known hardness discrete logarithm problem implies efficient hash functions 
practice hash functions implemented little cost 
recall section create secret sharing dealer selects bivariate polynomials recall notation ai bi description section 

denote element list formed setting ha 
derived analogously bi define lists analogously gf gf 
modifications dealer part sharing protocol 
sending server pd adds values denote message 

ha ha 
ha hb hb 
hb ha hb 
addition dealer sends polynomials ai bi server pi 
note result dealer sends messages length 
modifications pi part sharing protocol 
modified protocol pi computes lists received data adds message public dealer message 
allows server perform checks reduces length message 
furthermore messages counted separately respect modified protocol uses predicates ha hb described check poly element lists satisfied ha hb 
check point checks commitment satisfied verify poly polynomials degree satisfied check poly lists 

bn formed setting aj bj respectively 
verify point element lists received pm verifies values correspond points respectively committed true check poly check point ai check point bi 
verify share verifies pair forms valid share pm respect true remaining details modified protocol easily filled 
part reconstructing secret remains new definition verify share predicate 
clear message complexity revised protocol message complexity protocol section 
clear communication complexity reduced single message sent new protocol includes size size 
analysis 
argue resulting protocol retains properties asynchronous verifiable secret sharing protocol 
liveness agreement privacy properties follow exactly way section 
correctness property needs elaborated 
observe lemma holds protocol obvious modifications replacing 
proof correctness section 
suppose dealer honest shared dealer honest easy see echo message sent honest pi pj contains computed dealer 
furthermore servers computed shares echo messages sj 
honest server pi computed polynomial pi accepted message corrupted pm containing 
pi evaluated verify point true know check poly check point ai hold 
suppose broken hash function check poly fail ha 
break assumption 
suppose dealer corrupted distinct honest servers pi pj reconstruct values zi zj zi zj 
lemma accepted unique commitment includes value means received distinct sets si sj shares valid respect protocol zi zj interpolated sets obtained si sj respectively 
interpolated analogously 
shares si sj pass verify share test interpolate distinct values obtain ways opening commitment contained contradicts discrete logarithm assumption 
details similar left reader 
improvements 
suppose just generators group generators 
gn order share secrets 
sn dealer computes bivariate polynomials 
fn forms entries verification matrix cjl fn hf rest protocol carried analogously protocol described 
result dealer share secrets cost messages communication 
application asynchronous byzantine agreement byzantine agreement fundamental problem distributed computation 
asynchronous networks impossible solve deterministic protocols means resort randomized protocols 
polynomial time solution problem canetti rabin 
result proof concept practical solution complexity protocol high message complexity communication complexity log 
cost protocol dominated asynchronous verifiable secret sharing protocol sharing secrets 
protocol task previous section times efficient message complexity approximately times efficient communication complexity 
propose plug avss protocol directly byzantine agreement protocol canetti rabin excellent exposition avss asynchronous byzantine agreement 
result assuming hardness discrete logarithm problem complexity asynchronous byzantine agreement reduced message complexity communication complexity 
stress works computational setting canetti rabin unconditional model 
mention called random oracle model efficient protocol exists secure static adversary 
random oracle model assumption cryptographic hash functions involves certain problems proof model falls short proof real world 
avss protocol yields asynchronous byzantine agreement protocol provably secure standard model efficiency suitable practice 
asynchronous proactive model proactive cryptosystems combine distribution periodic refresh operation order protect secret key mobile adversary move server corrupt servers lifetime system 
section propose extension asynchronous system model section proactive cryptosystems 
argue extension necessary proposal minimal 
asynchronous proactive refresh protocol shared secrets forms core proactive cryptosystem section 
motivation 
proactive cryptosystem threshold cryptosystem tolerates adversary gradually break number servers 
protect leaking secret key operates sequence phases servers periodically refresh shares phases 
new set shares independent previous old shares erased 
adversary may corrupt different servers phase learning secret key 
underlying assumption breaking server requires certain amount time occurs server corrupted independent corruptions 
possible remove adversary rebooting server trusted way read device erase information server permanently 
concept maps synchronous network straightforward way 
asynchronous network issues regarding phases secure channels arise 
notion common phase readily available common clock 
refreshing requires distributed protocol servers participate synchronization primitive needed define length phase meaningful way 
turns single time signal clock tick defines start phase locally 
formal model leave scheduling signal network adversary 
practice impulse external clock say day utc 
phases defined locally server 
adversary may corrupt servers local phase 
second channels link servers adapted model 
recall servers linked secure channels private authenticated links scheduled adversary 
locally defined phases purely asynchronous scheduling possible adversary break secure channels assumption follows 
suppose servers local phase adversary corrupted 
order read message sent honest servers adversary may delay message receiver enters phase previously corrupted servers honest 
corrupts receiver observes message gives access private information previous phase servers 
assume secure channels proactive model guarantee messages delivered local phase sent 
precisely message sent local phase sender arrives receiver local phase invariably lost 
restrictions leave scheduling adversary 
practice proactive secure channels implemented re keying point point link phase change occurs discussed 
proceed formal description model 
formal model 
server erase information 
define erasing terms restricting server view 
erase information means exclude corresponding values server view 
adversary may corrupt server point time removed corrupted server reboot procedure 
case server restarted correct initialization data proactive protocols running corruption invoked protocols determined outside model 
internal state server may modified arbitrarily adversary 
server operates sequence local phases defined respect trivial protocol timer 
honest server continuously runs instance protocol starts server initialized 
initialization protocol sends timer message called clock tick 
server receives clock tick server resends message network 
local phase uncorrupted server pi defined number clock ticks received far 
adversary corrupts server phase define corrupted server remain local phase rebooted adversary removed 
assume reboot server automatically activated clock tick continues operate subsequent phase 
server honest point time enters local phase 
adversary cause server appear corrupted multiple subsequent phases phase changes corrupting immediately phase change 
set honest servers may change phase define set associated messages accordingly 
adversary proactive network model called limited phase index corrupts servers local phase 
recall activations atomic interrupted corruption 
allows honest server perform actions erasing critical data phase detecting clock tick corrupted adversary phase 
assume pair servers linked proactive secure asynchronous channel defined follows 
recall asynchronous network model adversary schedule messages set labels form 
proactive network number added label denoting local phase ps sent message 
restrict scheduling follows 
pj enters local phase messages labels removed furthermore adversary may schedule message label pj entered local phase 
say adversary delivers messages phases denote adversary delivers messages label form receiver pj pj local phase 
adversary corrupts server pj local phase messages label removed adversary may send messages label 
note honest server runs separate instance timer protocol view protocol integral part proactive system model 
required terminate satisfy uniform bound communication complexity 
simply run adversary halts 
implementation 
practice asynchronous proactive secure channels described properties implemented secure processors follows 
communication link pair servers encrypted authenticated phase session key stored secure hardware 
fresh session key established processor soon enter new phase authentication data stored secure hardware public key infrastructure may single root certificate 
adversary corrupts server gains access phase session key calls processor 
external clock triggers phase changes trusted path secure processor intruder able influence 
related problem maintaining proactive authenticated communication synchronous network investigated canetti 
related 
proactive systems asynchronous networks discussed castro liskov zhou aims maintaining common state maintaining shared secret 
works phases defined respect proactive protocols phase ends termination corresponding update protocol 
approach general sense postulate phases respect timeout mechanism independent proactive protocols 
models systems refresh protocol may terminate phase 
protocols postulate types conditions liveness conditions hold protocol terminates phase safety conditions hold case 
difference lies network model identifies main security requirements asynchronous proactive secure communication 
authenticity messages setting addressed terms special freshness requirement formal treatment aspects missing 
practical point view implementation refresh protocol efficient zhou 
expected message complexity opposed 
asynchronous proactive refresh protocol section describe group servers holding shares secret may refresh shares asynchronous proactive network adversary learn secret 
protocols form basis proactive cryptosystem 
define notion verifiable sharing properties protocol refresh sharing 
propose implementation refresh protocol discrete logarithm verifiable sharings established protocol avss section 
restrict ordinary sharings section 
definitions verifiable sharing 
sharing secret value zq seen encoding set shares si sets shares uniquely define set shares give information 
sharing results example stage avss protocol 
sharing robust erasures sense unique secret reconstructed subset shares 
missing shares honest servers denoted 
verifiable sharing sharing short additional property secret defined uniquely adversary corrupts servers modifies shares arbitrary way 
define verifiable sharing terms algorithm reconstruct takes input set shares si outputs value zq 
definition 
say servers hold verifiable sharing tag id respect algorithm reconstruct server pi holds share si conditions satisfied integrity set si shares contains shares honest servers different running reconstruct input si yields negligible probability 
privacy set si shares contains information 
notice integrity property computational privacy property unconditional 
refreshing verifiable sharing 
goal proactive refresh protocol protect verifiable sharing providing servers new shares phase adversary knowledge shares previous phase rendered useless 
suppose servers hold sharing 
sn value tag id respect algorithm reconstruct point time honest servers local phase 
honest server starts refresh protocol tag id input si soon detects receives clock tick ongoing computations aborted soon clock tick detected 
marks local phase phase 
refresh protocol terminates server generates output form id refreshed detects clock tick 
case say server completes refresh sharing id refresh protocol ensure honest servers compute fresh sharing value limited adversary learn information 
captured definition 
definition 
suppose servers hold verifiable sharing value tag id respect algorithm reconstruct 
asynchronous secure refresh protocol satisfies conditions limited adversary liveness adversary activates honest servers clock tick delivers associated messages phases honest servers complete refresh sharing id negligible probability 
correctness honest servers completed refresh sharing id detected subsequent clock tick servers hold verifiable sharing tag id respect reconstruct negligible probability 
privacy polynomial number consecutive executions protocol adversary view statistically independent 
efficiency id communication complexity instance id probabilistically uniformly bounded 
note definition guarantees servers complete refresh adversary delivers messages phases 
model allows adversary cause secret lost order preserve privacy 
imagine different formalization asynchronous proactive refresh protocols preserves correctness cost privacy adversary may learn secret 
trade privacy correctness unavoidable asynchronous networks messages may delayed longer duration proactive phase interestingly arise proactive cryptosystems synchronous networks 
difference synchronous case fact phases overlap 
consequence server erase old share activation receives clock tick order guarantee privacy secret 
point time corresponds refresh protocol server may receive messages servers corrupted new local phase 
contrast subsequent phases synchronous proactive cryptosystems usually assumed overlap duration refresh protocol server may delay erasure old share refresh protocol 
implementation section describes protocol refresh refreshing discrete logarithm verifiable sharing asynchronous network 
implementation needs multi valued validated byzantine agreement protocol section digital signature scheme secure adaptive chosen message attacks server avss protocol section building blocks 
assume sub protocols property calling protocol access modify internal state abort necessary terminating corresponding instance erasing associated local data 
local variable associated sub protocol instance id denoted id recall primitives defined purely asynchronous non proactive network 
sub protocols running single phase protocol terminate phase aborted calling protocol 
security keys digital signature scheme vba protocol proactive corruption model guaranteed storing inside secure processors proactively secure refresh protocols 
details scope 
verifiable sharing 
investigate refresh discrete logarithm verifiable sharing computed protocol avss section 
share honest server pi form si si 
vt servers ij vj words exist polynomials jxj zq si correct shares si vj 
note vj cj notation protocol avss 
algorithm reconstruct works follows 
input set shares selects value shares discards shares contain different value unique exist returns computes set tuples si satisfy ij vj returns interpolates polynomial degree set si si returns 
refresh protocol 
high level point view protocol works stages 
server pi shares share si avss protocol 
second servers multi valued byzantine agreement select sharings successfully terminated 
third compute fresh share set sharings agreed 
precisely suppose servers hold verifiable sharing tag id described previous paragraph set digital signature scheme server verify signatures issued server 
server executes steps protocol refresh phase 

server pi initializes verifiable sharings id avss extended version protocol avss 
shares si id avss id avss set immediately erases current share sharing polynomials id avss id avss instance id avss extension protocol avss server adds digital signature ready message avss instance id avss signature computed id avss ready 
list signatures output server completes sharing may serve proof fact 
server sends current value 
vt servers recover message 
waits receiving identical recover messages assigns value 
server waits completing sharings id avss id avss consistent id avss jl dl recall extended avss protocol returns proof completion sharing 
pi proposes set completed sharings validated byzantine agreement tag id vba 
proposal set li tuples indicating dealer pj completed sharing containing list signatures ready messages extended sharing 
predicate vba protocol set verify termination described verifies proposal contains valid lists signatures instances protocol avss 

server decides vba protocol set indicates avss instances waits sharings complete 
pi computes new share follows interpolates polynomials zq set shares computed avss instances indicated precisely polynomials degree interpolated sets id avss id avss respectively 
server sets shares si respectively 
new commitments computed analogously 
server aborts sub protocols id avss automatically erases information protocol instances 
predicate verify termination id vba vba instance id vba verifies contains tags avss protocols proofs protocols terminate 
true list contains valid signatures string id avss ready distinct servers 
shows detailed description protocol 
server may interpolate polynomial zq degree points 

denote appropriate lagrange interpolation coefficient set position 
protocol refresh server pi phase tag id local inputs si initialize sharing id avss extended protocol avss si share si id avss id avss erase si id avss id avss instance id avss send message id recover server clock tick detected wait receiving identical messages id recover distinct servers 
dt wait sharings tag id avss complete id avss li sharings id avss completed previous step propose li multi valued validated byzantine agreement id vba predicate verify termination wait vba protocol decide id vba wait sharings id avss complete interpolate id avss vl id avss si 
vt output id refreshed abort protocols id vba id avss local outputs si jl dl id avss resp 
protocol refresh proactive share refreshing asynchronous network started receiving th clock tick 
mentioned key point protocol server erases old share activation waiting network input 
event receiving clock tick starting refresh protocol defines local phase 
tolerate leave share information phase entering wait state phase point time corruption occur counts phase 
reason protocol follow approach gennaro establish set sharings value add shares shares secret phase 
protocol creates sharings previous shares secret uses agreed set sharings polynomial sharing secret 
purpose messages supply verification information phase honest servers corrupted phase rebooted phase 
protocol refresh invokes protocols avss vba sub protocol 
avss implemented section vba expected message complexity expected communication complexity 
prove theorem section 
theorem 
assuming hardness discrete logarithm problem protocol refresh asynchronous secure refresh protocol 
analysis show verifiable sharing satisfies definition protocol refresh satisfies liveness correctness privacy efficiency properties definition 
verifiable sharing 
recall shares verifiable sharing form si si 
vt exist polynomials zq degree si ij vj correct shares si 
furthermore equal shared secret 
may assume adversary knows shares sj corrupted servers 
integrity show adversary compute shares sj sj corrupted servers pj running reconstruct shares shares honest servers different yields value different 
contradiction suppose adversary computed values 
adversary corrupts servers reconstruct accepts shares contain value shares 
case sj jl vl reconstruct ignores shares 
adversary computed tuple sj sj sj jl vl rewriting comparing exponents gives sj sj adversary computed sj sj 
privacy follows directly privacy property protocol avss computes verifiable sharing 
liveness 
show conditions wait states server enters eventually satisfied provided adversary delivers associated messages phases 
server waiting identical recover messages containing value verifiable sharing receive integrity property sharing implies honest servers identical values guarantees value computed honest servers unique 
step wait sharings consistent complete 
honest servers completed phase valid shares different 
corrupted honest servers sharings complete consistent honest server blocked 
honest servers start vba protocol valid proposals liveness efficiency conditions vba imply vba protocol terminates 
step wait agreed sharings complete 
external validity vba protocol definition predicate verify termination avss instance id avss valid signatures message extended protocol avss 
honest servers sent message instances sufficient guarantee termination agreed instances protocol avss 
correctness 
fix point time set honest servers completed refresh protocol detected clock tick 
show hold verifiable sharing 
properties discrete logarithm sharing sufficient show shares si computed refresh protocol satisfy si bj vj polynomials jyj servers 
si denote shares initial verifiable sharing servers hold refresh protocol 
start condition 
definition verifiable sharing honest servers start honest servers accept 
dt recover messages honest servers receive id avss agreement property vba protocol follows easily servers assign value completing refresh protocol 
denote set agreed sharings computed honest servers denote lagrange interpolation coefficients set position 
recall protocol avss establishes discrete logarithm verifiable sharing 
exist polynomials id avss share id avss computed server pi satisfies define id avss id avss id avss 

show si servers combining yields id avss id avss 
denote polynomials interpolated pi protocol refresh 
protocol pi interpolates id avss id avss 
write si id avss id avss 
combining gives si required 
proceed showing vl 
definition polynomials coefficients linear combination coefficients respectively id avss second step follows step protocol 
vl remains show 
contradiction assume 
definition case avss protocol tag id avss resulted verifiable sharing defining polynomials 
id avss sj 
dl properties protocol avss protocol refresh 
properties initial verifiable sharing vl 
shown earlier 
dt computed protocol equal conclude implies log sj sj 
privacy 
show adversary view execution protocol statistically independent 
protocol starts verifiable sharing 
denote index set corrupted servers initial verifiable sharing 
regular operation proactive cryptosystem instance corrupted servers previous execution refresh protocol 
furthermore adversary may corrupt set servers execution refresh protocol activation proactive system model 

assume 
view adversary protocol refresh consists initial shares si 
vt past corruptions ii polynomials received corrupted servers sub protocol avss honest servers current protocol id avss id avss id avss id avss iii commitments id avss iv set output byzantine agreement protocol 
observer new shares corrupted servers determined 
show view consistent possible zq 
protocol starts verifiable sharing follows directly privacy property discrete logarithm sharing exist polynomials zq si vl 
polynomials define initial shares sj pj sj vl jl 
privacy property avss sub protocol know adversary view instance id avss honest pj consistent sj values consistent id avss remains show sj id avss obtain sj vl jl dl jl id avss proof correctness acceptance condition avss subprotocols protocol 
efficiency sketch 
servers execute avss protocols vba sub protocol 
addition send recover messages total 
communication complexity protocol avss uniformly bounded communication complexity vba sub protocol probabilistically uniformly bounded follows argumentation cachin communication complexity protocol refresh probabilistically uniformly bounded 
acknowledgment supported european ist project ist 
represents view authors 
project partially funded european commission swiss department education science 
ben canetti goldreich asynchronous secure computation proc 
th annual acm symposium theory computing stoc 
bracha asynchronous resilient consensus protocol proc 
rd acm symposium principles distributed computing podc pp 

cachin kursawe shoup secure efficient asynchronous broadcast protocols extended advances cryptology crypto kilian ed vol 
lecture notes computer science pp 
springer 
cachin kursawe shoup random oracles practical asynchronous byzantine agreement cryptography proc 
th acm symposium principles distributed computing podc pp 

canetti studies secure multiparty computation applications 
phd thesis weizmann institute 
canetti gennaro herzberg naor proactive security long term protection break ins rsa laboratories cryptobytes vol 

canetti goldreich halevi random oracle methodology revisited proc 
th annual acm symposium theory computing stoc pp 

canetti halevi herzberg maintaining authenticated communication presence break ins journal cryptology vol 
pp 

canetti rabin fast asynchronous byzantine agreement optimal resilience proc 
th annual acm symposium theory computing stoc pp 

castro liskov proactive recovery byzantine fault tolerant system proc 
fourth symp 
operating systems design implementation osdi 
chor goldwasser micali awerbuch verifiable secret sharing achieving simultaneity presence faults proc 
th ieee symposium foundations computer science focs pp 

desmedt threshold cryptography european transactions telecommunications vol 
pp 

fischer lynch paterson impossibility distributed consensus faulty process journal acm vol 
pp 
apr 
gennaro jarecki krawczyk rabin secure key generation discrete log cryptosystems advances cryptology eurocrypt stern ed vol 
lecture notes computer science pp 
springer 
goldwasser micali rackoff knowledge complexity interactive proof systems siam journal computing vol 
pp 
feb 
goldwasser micali rivest digital signature scheme secure adaptive chosen message attacks siam journal computing vol 
pp 
apr 
hadzilacos toueg fault tolerant broadcasts related problems distributed systems mullender ed new york acm press addison wesley 
herzberg jarecki krawczyk yung proactive secret sharing cope perpetual leakage advances cryptology crypto coppersmith ed vol 
lecture notes computer science pp 
springer 
lamport shostak pease byzantine generals problem acm transactions programming languages systems vol 
pp 
july 
ostrovsky yung withstand mobile virus attacks proc 
th acm symposium principles distributed computing podc pp 

pease shostak lamport reaching agreement presence faults journal acm vol 
pp 
apr 
pedersen non interactive information theoretic secure verifiable secret sharing advances cryptology crypto feigenbaum ed vol 
lecture notes computer science pp 
springer 
shoup practical threshold signatures advances cryptology eurocrypt preneel ed vol 
lecture notes computer science pp 
springer 
zhou fault tolerant secure line services 
phd thesis cornell university 

