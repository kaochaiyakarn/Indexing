secure execution program shepherding vladimir derek saman amarasinghe laboratory computer science massachusetts institute technology cambridge ma saman lcs mit edu introduce program shepherding method monitoring control flow transfers program execution enforce security policy 
program shepherding provides techniques building blocks security policies 
shepherding restrict execution privileges basis code origins 
distinction ensure malicious code masquerading data executed large class security attacks 
second shepherding restrict control transfers instruction class source target 
example shepherding forbid execution shared library code declared entry points ensure return instruction targets instruction call 
shepherding guarantees sandboxing checks placed type program operation bypassed 
implemented capabilities efficiently runtime system minimal performance penalties 
system operates unmodified native binaries requires special hardware operating system support runs existing ia machines linux windows 
goal security attacks gain unauthorized access computer system control vulnerable privileged program 
done exploiting bugs allow overwriting stored program addresses pointers malicious code 
today prevalent attacks target buffer overflow format string vulnerabilities 
difficult prevent ex research supported part defense advanced research projects agency 
originally published proceedings th usenix security symposium security san francisco california august 
allow address overwrites varied program bugs 
unreasonable try malevolent writes memory containing program addresses addresses stored different places legitimately manipulated application compiler linker loader 
security attacks thwarted simply inserting checks application code may cause systemwide changes 
malicious entity gains control simply inject code perform operation application permission 
hijacking trusted applications web servers mail transfer agents login servers typically run global permissions gives full access machine resources 
attempt multitude attack paths protection powerful weakest link approach prevent execution malicious code 
program shepherding monitoring control flow transfers enforce security policy 
program shepherding prevents execution data modified code ensures libraries entered exported entry points 
focusing preventing memory corruption prevent final step attack transfer control malevolent code 
allows broad range security exploits simple central system easily secure 
program shepherding provides sandboxing circumvented allowing construction customized security policies 
program shepherding requires verifying branch instruction easily done static instrumentation due dynamism shared libraries indirect branches 
implementation interpreter straightforward solution 
reduce overhead interpretation performing security checks placing resulting trusted code cache executed overhead free 
im plementation naturally fits rio infrastructure dynamic optimizer built ia version dynamo 
resulting system imposes minimal performance overhead operates unmodified native binaries requires special hardware operating system support 
shepherding implementation top rio implemented windows linux mainly focuses linux 
section classify types security exploits aiming prevent 
program shepherding techniques described section section shows combine produce potent security policies 
section discusses implement program shepherding efficiently section describes prevent attacks directed system 
experimental results performance system section 
security exploits section provides background types security exploits targeting 
classify security exploits characteristics program vulnerability exploited stored program address overwritten malicious code executed 
program vulnerabilities exploited classes program bugs involve buffer overflows format strings 
buffer overflow vulnerabilities buffer weak bounds checking populated user supplied data 
trivial example unsafe library functions strcpy gets 
allows attacker corrupt adjacent structures containing program addresses return addresses kept stack 
buffer overflows affecting regular data pointer disastrous effect allowing memory write arbitrary location subsequent data pointer 
particular attack corrupts fields double linked free list kept headers malloc allocation units 
subsequent call list update operation prev modify arbitrary location arbitrary value 
format string vulnerabilities allow attackers modify arbitrary memory locations arbitrary values rank buffer overflows security bulletins 
format string vulnerability occurs format string function family sn printf syslog provided constructed data outside source 
common case printf str str 
problem attackers may introduce conversion specifications enable read memory contents process 
real danger comes conversion specification directs number characters printed far written back 
location number stored value easily controlled attacker type width specifications write arbitrary value arbitrary address performed single attack 
assume attackers exploit vulnerability gives random write access arbitrary addresses program address space 
ability overwrite stored program address transfer control process attacker 
stored program addresses entities participate transferring control program execution 
compilers linkers loaders runtime systems hand crafted assembly code legitimate reasons transfer control 
program addresses manipulated entities dynamic loaders patch shared object functions dynamic linkers update relocation tables language runtime systems modify dynamic dispatch tables 
generally program addresses intermingled indistinguishable data 
environment preventing control transfer malicious code stopping illegitimate memory writes impossible 
requires cooperation numerous trusted untrusted entities need check different conditions understand high level semantics complex environment 
security exploits attack program addresses stored different places 
buffer overflow attacks target addresses adjacent vulnerable buffer 
classic return address attacks local function pointer attacks exploit overflows stack allocated buffers 
global data heap buffer overflows allow global function pointer attacks structure attacks 
data pointer buffer overflows malloc overflow attacks format string attacks able modify stored program address vulnerable application addition aforementioned addresses attacks target entries list destructor routines global offset table got shared object entries 
malicious code attacker cause damage injection new malicious code malicious reuse code 
usually approach taken attack code implemented new native code injected program address space data 
new code injected various areas address space stack buffer static data segment near far heap buffer global offset table 
normally distinction read execute privileges memory pages case ia requirement pages writable injection phase 
modifying stored program address point introduced code trigger intrusion address control transfer 
possible reuse existing code changing stored program address constructing activation record suitable arguments 
simple powerful attack reuses existing code changing function pointer library arranges argument arbitrary shell command run 
note reuse existing code include jumping middle sandboxed operation bypassing sandboxing checks executing operation intended protected 
addition jump middle instruction ia instructions variable sized unaligned cause execution unintended possibly malicious instruction stream attack 
attacker may able form higher level malicious code introducing data carefully arranged chain activation records return function execution continues function chain 
prepared activation record return address points code function epilogue shifts stack pointer activation record continues execution function 
overwriting suitable sequence function pointers may produce higher level malicious code 
program shepherding program shepherding approach preventing execution malicious code monitor control transfers ensure satisfies security policy 
allows ignore complexities various vulnerabilities difficulties preventing illegitimate writes stored program addresses 
catch large class security attacks preventing execution malevolent code 
employing techniques restricted code origins restricted control transfers un sandboxing 
section describes techniques section discusses build security policies techniques 
restricted code origins monitoring code executed instruction origins checked security policy see execute privileges 
code origins classified categories original image disk unmodified dynamically generated unmodified generation code modified 
finer distinctions 
describe section distinguish original code modified possibly malicious code 
hardware execute flag memory pages provide similar features restricted code origins 
duplicate program shepherding features inadvertent malicious changes protection flags 
program shepherding uses un sandboxing described section prevent happening 
furthermore program shepherding provides bit privilege information distinguishes different types execute privileges different security policies may specified 
restricted control transfers program shepherding allows arbitrary restrictions placed control transfers efficient manner 
restrictions source destination transfer type transfer direct indirect call return jump 
example calling convention enforced requiring return instruction target instruction call 
example forbidding execution shared library code declared entry points 
un sandboxing program shepherding provides direct support restricting code origins control transfers 
execution restricted ways adding sandboxing checks types operations 
ability monitor transfers control program shepherding able guarantee sandboxing checks bypassed 
sandboxing guarantee provide true security attack gain control execution jump straight sandboxed operation bypassing checks 
addition allowing construction arbitrary security policies guarantee enforce program shepherding techniques protecting shepherding system see section 
security policies program shepherding techniques provide powerful security guarantees 
allow strictly enforce safe subset instruction set architecture operating system interface 
tradeoffs program freedom security restrictions strict false alarms result actual intrusion 
section discusses potential design space security policies provide significant protection reasonable restrictions program freedom 
envision system customizable policy settings current system implements single security policy described section 
table lists sample policy decisions implemented program shepherding 
consider policy decision upper right table allowing unrestricted execution code original application library image disk unmodified 
policy allow vast majority programs execute normally 
policy security exploits inject code masquerading data program 
covers majority currently deployed security attacks including classic stack buffer overflow attack 
relaxation policy allows dynamically generated code requires contain system calls 
legitimate dynamically generated code usually performance example high level languages employ just time compilation generate op pieces code executed natively interpreted 
code contains system calls potentially dangerous operations 
reason imposing strict security policy dynamically generated code reasonable approach 
shared libraries explicitly loaded dynamically selected user input considered potentially unsafe 
similarly self modifying code usually disallowed may explicitly allowed certain applications 
direct control transfers satisfy code origin policies allowed segment 
calls jumps transition executable segment application code shared library shared library restricted enforce library interfaces 
targets inter segment calls jumps verified export list target library import list source segment order prevent malevolent jumps middle library routines 
indirect control transfers carefully limited 
calling convention enforced preventing return instructions targeting non call sites limiting direct call sites target return site 
controlling return targets severely restricts exploits overwrite return addresses opportunities stitching fragments existing code attack 
indirect calls completely disallowed applications 
restrictive general policies needed require higher level information compiler support 
code possible keep readonly virtual method tables allow indirect calls targets areas 
relaxations needed allow callback routines programs 
policy provides general solution requires compiler support profiling runs external sources information determine valid indirect call targets 
relaxed policy restricts indirect calls libraries direct calls restricted segments target import export entries calls application text segment target intra segment function entry points 
requirement function entry points simple intra segment requirement prevents indirect calls targeting direct calls indirect jumps validly cross executable segment points avoid restriction 
possible extract valid user program entry points symbol tables binaries 
unfortunately stripped binaries keep infor restricting restrictive restrictive code origins dynamically written code selfcontained system calls function returns intra segment call jump inter segment call jump calls direct call targeted return code disk dynamically loaded random xor stackghost function entry points symbol table export target segment indirect calls address stored read memory import source segment user segment library execve static arguments operation validated cause problem open disallow writes specific files passwd subregion file system code disk originally loaded return called function bindings interface list bindings interface list table sample list policies built program shepherding 
row shows continuum choices ranging restrictive right restrictive left control action left hand column 
bold entries indicate policy choices implemented experimental system 
mation 
indirect jumps implementation switch statements dynamically shared libraries 
easily allowed targets validated coming read memory trusted 
second shared library calls allowed inter segment indirect jumps restricted library entry points 
restrictions allow indirect jump instruction function return place actual return instruction 
see code 
certainly generated compilers breaks important hardware optimizations modern ia processors 
sandboxing provide detection attacks get past barriers 
example attack overwrites argument passed routine may stopped aforementioned policy 
program shepherding guaranteed sandboxing intrusion detection attacks 
security policy decide check example suspicious calls system calls execve intrusion detected 
issues scope discussed 
sandboxing checks load store ensure certain memory regions accessed execution untrusted code segments 
provide significant security great expense performance 
turn attention specific security policy bold entries table 
implemented policy prototype system 
security policy summarizes contribution program shepherding technique stopping types attacks described section 
sections describe detail policy components sufficient attack type 
restricted code origins restricted control transfers un sandboxing attack type injected code existing code single calls chained calls multiple calls return indirect jump call imported imported return indirect jump call imported imported information symbol table information capabilities program shepherding components stopping different attack types security policy indicated bold table 
boxes represent components 
filled box indicates component completely attack type 
stripes indicate attack stopped cases 
vertical order techniques indicates preferred order stopping attacks 
higher box completely stops attack invoke techniques sandboxing capable stopping attacks type techniques provide full protection 
injected code attacks code origin policy disallows execution address ranges text pages binary mapped shared libraries 
stops exploits introduce external code covers majority currently deployed security attacks 
code origin checks insufficient thwart attacks change target address pointer point existing code program address space 
existing code attacks vulnerable programs code maliciously attacker 
standard library mapped address space 
restrictions inter segment control transfers limit available code attacked explicitly declared application 
large programs import library routines simple attack needs 
reason restricting transitions imported entry points attacks 
return address attacks severely limited may target code previously executed call instructions 
restriction easily provided restricted control transfers emulate technique proposed stackghost 
random number ed return address stored stack call return 
modification return address result high probability request invalid target 
threat model attackers write memory technique renders execution attacker intended code 
protection comes low cost extra instructions function call additional value hard determine due limited applicability kind exploit 
furthermore able exploit vulnerability provides random read rights stopped policy 
currently impose 
single calls single call attack mean attack overwrites single program address overwriting data resulting single malicious control transfer 
consider readily system call vulnerable point single call attack 
possible construct intrusion detection predicate distinguish attacks valid execve calls terminate application drop privileges limit exposure 
single call executed system calls need combination intrusion need sandboxed 
prevents intrusion argument overwrite attack 
sandboxing provide protection sequences operations application allowed controlled attacker 
example exploit emulates normal behavior listens network socket accepts connection reads password file authentication writes password file contents network stopped simple sandboxing 
restrictions control transfers crucial prevent construction higher level code primitives limiting possible attacks data attacks targeting sequences existing code 
chained calls attacker may able execute malicious code sequence carefully constructing chain activation records return function execution continues 
requiring return instructions target call sites sufficient thwart chained call attack needed functions explicitly imported allowed inter segment restrictions 
chaining technique countered reliance return instructions gain control existing function code shift activation record function call 
multiple calls able construct applications open exploit forms higher level malicious code changing targets sequence function calls arguments 
multiple sequential intrusions may allow execution higher level malicious code 
higher level semantic information needed thwart attacks intrusion method limiting valid indirect call targets 
policy able attacks general false alarms requires knowing advance list bindings built previous run generated 
possible extract valid user program entry points symbol tables binaries 
allowing indirect calls target valid entry points executable shared libraries limits targets higher level code construction 
simple wrappers executable allow arbitrary arguments passed lower level library functions possibility successful attack type minimal 
interpreters permissive going vulnerable data attacks may form higher level malicious code recognized threat techniques 
efficient implementation program shepherding order security system viable efficient 
widely easily transparent 
transparency includes target application recompiled instrumented security system requires special hardware operating system support 
examined possible implementations program shepherding terms requirements efficiency transparency 
possible method monitoring control flow instrumentation application library code prior execution add security checks branch instruction 
difficulties statically handling indirect branches dynamically loaded libraries introduced checks impose significant performance penalties 
furthermore attacker aware instrumentation design attack overwrite bypass checks 
instrumentation viable start basic block cache non control flow instructions basic block builder indirect branch lookup dispatch context switch trace selector trace cache non control flow instructions indirect branch stays trace 
flow chart rio system infrastructure 
dark shading indicates application code 
note context switch simply code cache rio application code rio code runs process address space 
dotted lines indicate performance critical cases control leave code cache return rio 
applicable 
possibility interpreter 
interpretation natural way monitor program execution application operation carried central system security checks placed 
interpretation emulation slow especially architecture ia complex instruction set shown table 
dynamic optimization framework advances dynamic optimization focused low overhead methods examining execution traces purpose optimization 
infrastructure provides exact functionality needed efficient program shepherding 
dynamic optimizers interpretation engine 
reduce emulation overhead native translations frequently executed code cached directly executed 
security system caching means security checks need performed code copied cache 
code cache protected malicious modification executions trusted cached code proceed security emulation overhead 
decided build program shepherding system extension dynamic optimizer called rio 
rio built top ia version dynamo 
rio optimizations development 
hindrance security purposes performance reasonable see section 
rio implemented ia windows linux capable running large desktop applications 
flow chart showing operation rio 
concentrates flow control code cache bottom portion 
copied application code looks just original code exception control transfer instructions shown arrows 
give overview rio operation focusing aspects relevant implementation program shepherding 
techniques program shepherding fit naturally rio infrastructure 
monitoring operations need performed allowing achieve performance steady state program 
implementation performance critical inner loop execute single additional instruction original application code 
rio runtime introspection optimization rio copies basic blocks sequences instructions single control transfer instruction code cache executes natively 
block application machine state saved control returned rio context switch copy basic block 
target basic block code cache targeted direct branch rio links blocks direct jump 
avoids cost subsequent context switch 
indirect branches linked way targets may vary 
maintain transparency original program addresses application stores indirect branch targets example return addresses function calls 
addresses translated corresponding code cache addresses order jump target code 
translation performed fast hashtable lookup 
improve efficiency indirect branches achieve better code layout basic blocks frequently executed sequence stitched unit called trace 
connecting basic block ends indirect branch check inserted ensure actual target branch keep execution trace 
check faster hashtable lookup check fails full lookup performed 
superior code layout traces goes long way amortizing overhead creating speeds program 
table shows typical performance improvement enhancement basic interpreter design 
caching dramatic performance improvement adding direct links nearly dramatic 
final steps adding fast cache lookup indirect branches building traces improve performance significantly 
windows operating system directly invokes application code changes program counter callbacks exceptions asynchronous procedure calls setjmp api routine 
types control flow intercepted order ensure application code executed rio 
signals linux similarly intercepted 
normalized system type execution time crafty vpr emulation basic block cache link direct branches link indirect branches traces table performance achieved various features added interpreter measured spec benchmarks crafty vpr 
pure emulation results slowdown factor 
successively adding caching linking traces brings performance dramatically 
restricted code origins restricting execution trusted code accomplished adding checks point system copies basic block code cache 
checks need executed basic block 
code origin checking requires rio know code modified original image disk dynamically generated 
done write protecting pages declared containing code program start 
normal elf binaries code pages separate data pages write protected default 
dynamically generated code easily detected application tries execute code writable page self modifying code detected monitoring calls code pages 
code data allowed share page copy page write protect original page 
copy source basic blocks original page data freely modified 
complex scheme self modifying code allowed 
rio keep track origins block code cache invalidating block source page modified 
original page kept detect modification 
performance overhead depends writes code pages expect self modifying code rare 
extensive evaluation applications linux windows reveal code 
restricted control transfers dynamic optimization infrastructure monitoring control flow transfers simple 
direct branches desired security checks performed point basic block linking 
transition blocks disallowed security policy linked 
direct branch linked routine announces handles security violation 
checks need performed potential link 
link allowed direct jump overhead 
indirect control transfer policies add performance overhead steady state checks required execution continues trace 
hashtable lookup routine translates target program address basic block entry address 
separate hashtable different types indirect branch return instruction indirect calls indirect branches enable type specific restrictions sacrificing performance 
security checks indirect transfers examine targets little performance overhead place hashtable targets allowed security policy 
targets indirect branches matched entry points plt defined dynamically resolved symbols enforce restrictions inter segment transitions targets returns checked ensure target instructions call sites 
security checks source target transfer slightly slower hashtable lookup routine 
implemented policies examine source target apply transformations target experimental results show actual performance impact schemes 
handle non explicit control flow signals windows specific events callbacks exceptions 
place security checks interception points similarly indirect branches 
abnormal control transfers rare extra checks interception affect performance 
un sandboxing required security policy rio inserts sandboxing basic block copied code cache 
normal sandboxing attacker jump middle block bypass inserted checks 
rio allows control flow transfers top basic blocks traces code cache preventing 
indirect branch targets middle existing block indirect branch hashtable lookup go back rio copying new basic block code cache duplicate bottom half existing block 
necessary checks added new block block entered top ensuring follow security policy 
sandboxing system calls system call number determined statically avoid sandboxing checks system calls interested 
important providing performance applications perform system calls 
restricted code cache entry points crucial just building custom security policies sandboxing enforcing shepherding features protecting rio 
discussed section 
protecting rio program shepherding defeated attacking rio data structures including code cache address space application 
section discusses prevent attacks rio 
core rio relatively small piece code rio rely component system believe secure leave loopholes exploitation 
memory protection divide execution modes rio mode application mode 
rio mode corresponds top half 
application mode corresponds bottom half including code cache rio routines executed performing context switch back rio 
modes give type memory page privileges shown table 
rio data includes indirect branch hashtable data structures 
application rio code pages write protected modes 
application data course writable application mode reason protect page type rio mode application mode application code application data rw rw rio code cache rw rio code rio data rw table privileges type memory page belonging application process 
stands read write execute 
separate execute privileges clear code allowed rio execute 
rio remains writable rio mode 
rio data code cache written rio protected application mode prevent inadvertent malicious modification application 
basic block copied code cache contains system call may change page privileges call sandboxed prevent changes violate table 
program shepherding un sandboxing guarantees system call checks executed 
rio data pages code cache pages write protected application mode allow application code change protections guarantee rio state corrupted 
protect rio global offset table got binding symbols program startup write protecting got prototype implementation 
multiple application threads rio data structures code cache thread private 
thread unique code cache data structures 
system calls modify page privileges checked data pages threads 
thread enters rio mode thread rio data pages code cache pages unprotected 
potential attack occur thread rio mode thread application mode modifies thread rio data pages 
solve problem forcing threads exit application mode thread enters rio mode 
implemented solution performance cost minimal single processor multiprocessor thread spending time executing code cache 
performance cost unreasonable multiprocessor threads continuously context switching 
investigating alternative solutions 
windows need prevent api routine setting register values threads 
rio hashtable lookup routine uses register temporary storage indirect branch target 
register overwritten rio lose control application 
interception api routine interfered execution large applications running 
fact observe calls 
experimental results program shepherding implementation able detect prevent wide range known security attacks 
section presents test suite vulnerable programs shows effectiveness system test suite evaluates performance system spec benchmarks 
effectiveness constructed programs exhibiting full spectrum buffer overflow format string vulnerabilities 
experiments included spec benchmark applications applications reported security vulnerabilities format string vulnerability ssl tunnel allows remote malicious servers execute arbitrary code custom file descriptor wrapper calls format argument 
groff preprocessor groff formatting system exploitable buffer overflow allows remote attackers gain privileges lpd printing system 
pic picture compiler groff package format string vulnerability 
ssh cve integer overflow bug crc compensation attack detection code causes ssh daemon typically run root create hashtable size zero response long input 
attempts write values hashtable provide attackers random write access memory 
sudo cve sudo superuser allows local users gain root privileges 
vulnerability caused bound access due incomplete loop condition triggered long command line arguments 
exploit corruption published 
attack code usually immediately give attacker root shell prepare system easy takeover modifying system files 
exploits tests tried start shell privilege running process typically root add root entry passwd file 
exploits cookbook proof concept works inject new code reuse existing code single call reuse code chain multiple calls 
existing code attacks standard library functions 
run natively test suite exploits able get control modifying wide variety code pointers including return addresses local global function pointers setjmp structures got entries 
investigated attacks rio overwriting rio got entry allow malicious code run rio mode come attack bypass protection mechanisms section 
vulnerable programs successfully exploited run standard redhat linux installation 
execution vulnerable binaries rio security checks disabled allowed successful intrusions 
rio interfered exploits due changed addresses targets trivial modify exploits system 
execution vulnerable binaries rio enforcing policies shown bold table effectively blocked attack types 
intrusion attempts led successfully exploitable conditions detected 
vulnerable applications able execute normally benign input 
spec benchmarks gave false alarms data set 
performance show performance system linux windows respectively 
fig ure shows normalized execution time spec benchmarks compiled full optimization run unlimited code cache space 
note fortran compiler linux fortran compiler windows 
bar gives performance rio 
rio breaks benchmarks performing optimizations code layout creating traces 
second bar shows performance program shepherding enforcing policies shown bold table 
results show overhead program shepherding negligible 
final bar gives overhead protecting rio 
overhead minimal noise measurements benchmarks 
linux gcc significant slowdown due page protection consists short runs little code re 
windows benchmarks serious slowdowns especially gcc 
explanation point difference linux windows protection slowdowns windows efficient changing privileges memory pages linux working improving page protection scheme lazily pages needed return rio mode 
memory usage security system shown table 
sizes shown kb 
left half table shows total size text sections benchmark shared libraries uses compared amount code executed 
third column gives percentage total static code executed 
operating dynamically system able focus small portion code run static approach examine text sections entirety 
right half table shows memory overhead rio compared memory usage benchmark 
benchmarks memory rio small fraction total memory natively 
related reflecting significance popularity buffer overflow format string attacks efforts provide automatic protection detection vulnerabilities 
summarize successful ones 
normalized execution time ammp applu apsi art bzip crafty program shepherding performance linux eon equake gap gcc gzip mcf mesa benchmark mgrid parser perlbmk swim twolf vortex vpr har 
mean rio rio program shepherding rio program shepherding protection normalized program execution time system ratio execution time native execution time spec benchmarks excluding fortran benchmarks linux 
compiled 
final set bars harmonic mean 
bar rio middle bar shows overhead program shepherding security policy table final bar shows overhead page protection calls prevent attacks system 
normalized execution time art bzip crafty eon program shepherding performance windows equake gap gcc gzip mcf benchmark mesa parser perlbmk twolf vortex vpr har 
mean rio rio program shepherding rio program shepherding protection normalized program execution time system ratio execution time native execution time spec benchmarks excluding fortran benchmarks windows 
compiled ox 
final set bars harmonic mean 
bar rio middle bar shows overhead program shepherding security policy table final bar shows overhead page protection calls prevent attacks system 
benchmark static code executed code executed native total rio extra rio extra ammp applu apsi art bzip crafty eon equake gap gcc gzip mcf mesa mgrid parser perlbmk swim twolf vortex vpr arithmetic mean harmonic mean table memory usage spec benchmarks kb linux 
benchmarks multiple data sets run maximum memory usage shown 
static code total size text sections benchmark shared libraries uses 
executed code total size instructions processed rio running benchmark 
rio total total memory rio running benchmark 
native total total memory benchmark run natively outside rio 
stackguard compiler patch modifies function place adjacent return address pointer 
stack buffer overflow modify canary overwriting return pointer check function epilogue detect condition 
technique successful sequential overwrites protects return address 
stackghost example hardware facilitated return address pointer protection 
kernel modification openbsd uses sparc architecture trap register window written read stack performs operations return address written stack function entry control transfer function exit 
return address corruption results transfer unintended attacker attacks 
techniques stack smashing protection keeping copies actual return addresses area application proposed stack ghost compiler patch 
proposals suffer various complications presence multi threading deviations strict calling convention setjmp exceptions 
memory areas unreadable application hard guarantee attack targeted protection scheme 
hand return stack copy protected duration function execution unprotected call prohibitively expensive mprotect linux ia times expensive empty function call 
techniques write protection stack pages shown significant performance penalties 
library patch eliminating format string vulnerabilities 
provides wrappers printf functions count number arguments match specifiers 
applicable functions standard library functions directly requires recompilation 
enforcing non executable permissions ia kernel patches done stack pages data pages pax 
system provides execution protection user mode achieves better steady state performance 
randomized placement position independent code proposed pax technique protection attacks existing code open attacks able read process addresses determine program layout 
system infrastructure dynamic optimization system ia version dynamo 
software dynamic optimizers wiggins employs program counter sampling form traces specialized particular alpha machine running mojo targets windows nt running ia 
optimization 
introduces program shepherding employs techniques restricted code origins restricted control transfers un sandboxing provide strong security guarantees 
implemented program shepherding rio runtime system rely hardware operating system compiler support operates unmodified binaries generic linux windows ia platforms 
shown implementation successfully prevents wide range security attacks efficiently 
program shepherding prevent exploits overwrite sensitive data 
assertions data verified functions verifications bypassed declared entry points 
discussed potential design space security policies built program shepherding 
system currently implements set policy settings expanding set security policies system provide loss performance 
expansions include semantic information provided compilers specify permissible operations fine grained level performing explicit protection monitoring known program addresses prevent corruption 
example protecting application got allowing updates dynamic resolver easily implemented secure efficient fashion 
potential application program shepherding allow operating system services moved efficient user level libraries 
example exokernel operating system usual operating system abstractions provided unprivileged libraries giving efficient control system resources user code 
program shepherding enforce unique entry points libraries enabling exokernel provide better performance sacrificing security 
believe program shepherding integral part security systems 
relatively simple implement little performance penalty coexist existing operating systems applications hardware 
security components built top un sandboxing provided program shepherding 
program shepherding provides useful security guarantees drastically reduce potential damage attacks 
matthew arnold stephen fink david grove michael hind peter sweeney 
adaptive optimization jalape jvm 
acm sigplan conference object oriented programming systems languages applications oopsla october 
bala evelyn duesterwald sanjeev banerjia 
dynamo transparent runtime optimization system 
proceedings acm sig plan conference programming language design implementation pldi june 
derek evelyn duesterwald saman amarasinghe 
design implementation dynamic optimization framework windows 
th acm workshop feedback directed dynamic optimization december 
kil 
bypassing stackguard stack shield 
phrack may 
wen ke chen lerner david 
mojo dynamic optimization system 
rd acm workshop feedback directed dynamic optimization december 
crispin cowan matt barringer steve beattie greg hartman 
automatic protection printf format string vulnerabilities 
th usenix security symposium washington august 
crispin cowan calton pu dave maier jonathan walpole peat steve beattie aaron perry wagle qian zhang heather hinton 
stackguard automatic adaptive detection prevention buffer overflow attacks 
proc 
th usenix security symposium pages san antonio texas january 
common vulnerabilities exposures 
mitre 
cve mitre org 
rubin 
wiggins line program specializer 
proceedings hot chips august 
solar designer 
non executable user stack 
www com linux 
peter deutsch allan schiffman 
efficient implementation smalltalk system 
acm symposium principles programming languages popl january 
executable linking format elf 
tool interface standards committee may 
dawson engler frans kaashoek james toole 
exokernel operating system architecture application level resource management 
symposium operating systems principles pages 

stackghost hardware facilitated stack protection 
proc 
th usenix security symposium washington august 
ian goldberg david wagner randi thomas eric brewer 
secure environment untrusted helper applications 
proceedings th usenix security symposium san jose ca 
michel 
object believed embody magical powers 
phrack august 
calvin ko timothy fraser lee badger douglas 
detecting countering system intrusions software wrappers 
proc 
th usenix security symposium denver colorado august 

advanced return lib exploits 
phrack december 
tim 
format string attacks 
september 
www com docs pdf 
aleph 
smashing stack fun profit 
phrack november 
intel pentium intel xeon processor optimization manual 
intel 
zenith parsec 
remote linux groff exploitation lpd vulnerability 
www securityfocus com bid 
pax team 
non executable data pages 
net txt 
eric rotenberg steve bennett smith 
trace cache low latency approach high bandwidth instruction fetching 
th annual international symposium microarchitecture micro december 
spec cpu benchmark suite 
standard performance evaluation 
www spec org osg cpu 

stack smashing technique protection tool linux 
www com sk 

defeating solar designer stack patch 
www securityfocus com archive 
