inductive verification cryptographic protocols bella clare college university cambridge dissertation submitted degree doctor philosophy march ii preface stated text dissertation result outcome done collaboration 
dissertation substantially submitted degree diploma qualification university 
part dissertation currently submitted degree diploma qualification 
dissertation exceed words including footnotes bibliography 
publications dissertation published may 
comments suggestions email bella cl cam ac uk dissertation copyright bella 
iii iv am extremely grateful larry paulson supervisor perfect mixture knowledge experience patience guided research 
human side taught face unsuccessful experiments learn evaluate successful ones 
practical side solution unexpected financial due problems initial awarding body compromised completion research 
acknowledge assistance epsrc gr gr 
am particularly grateful ph mike gordon peter ryan gave invaluable suggestions dissertation readable intelligible 
special due lewis librarian computer laboratory making library friendly environment speeding access printed information margaret levitt secretary laboratory assistance bureaucratic steps ph sincere gratitude goes professors university catania educational psychological support granted studies domenico favoured security seminars catania giovanni gallo supervised degree alfredo ferro encouraged undertake ph cambridge discovered impetus research general guided impetus expertise 
people dieter gollmann microsoft research clarified relation integrity authenticity peter honeyman university michigan technicalities shoup rubin protocol gavin lowe university leicester facilitated understanding authentication markus kuhn computer laboratory discussed risks affecting smart cards 
am indebted david office mate date responsive dictionary english especially proof reading entire dissertation 
am deeply grateful particularly brother giuseppe filling absence home vitality skill accepted live abroad 
deepest recognition go father death helped broaden views life mother ada loss helped bring views focus 
vi vii mother loving memory father viii dissertation aims tailoring paulson inductive approach analysis classical cryptographic protocols real world protocols 
aim pursued extending approach new elements timestamps smart cards new network events message reception expressive functions agents knowledge 
aim achieved analysing large protocols kerberos iv shoup rubin studying specify verify goals 
precisely modelling timestamps discrete time developed ban kerberos comparing outcomes ban logic 
machinery applied kerberos iv complicated session keys requires dedicated treatment 
new guarantees limiting spy abilities case compromise specific session key established 
discovered kerberos iv subject attack due weak guarantees confidentiality protocol responder 
develop general strategies investigate goals authenticity key distribution non injective agreement strong form authentication 
strategies require formalising agents knowledge messages 
approaches implemented 
agent creates message knows components message including cryptographic key encrypts 
alternatively broad definition agents knowledge developed new network event message reception formalised 
concept smart card secure device store long term secrets perform easy computations introduced 
model cards stolen cloned spy 
kernel built algorithm works correctly spy acquire unlimited knowledge 
functional interface unreliable send correct outputs unspecified order 
provably secure protocol smart cards designed shoup rubin mechanised 
design weaknesses unknown authors treatment bellare rogaway approach feasible corrections suggested verified 
realise evidence protocol achieves goals available peers 
consequence develop new principle prudent protocol design goal availability holds protocol suitable guarantees confirming goals exist assumptions peers verify 
failure observe principle raises risk attacks case example attack kerberos iv 
ix contents informal vs formal protocol analysis 
induction theorem proving 
motivations 
developing inductive approach 
verifying significant protocol goals 
investigating principles protocol design 
contributions 
inductive approach 
protocol goals 
principles protocol design 
outline 
notation 
analysis protocols formal approaches 
belief logics 
state enumeration model checking 
provable security 

interpreting findings 
tmn 
woo lam 
public key needham schroeder 
shared key needham schroeder 
inductive approach basics 
agents 
xi messages 
events 
spy knowledge 
operators 
protocol model 
verifying protocol goals reliability protocol model 
regularity 
authenticity 
unicity 
confidentiality 
authentication 
key distribution 
minimal trust goal availability 
modelling timestamps modelling numbers 
ban kerberos protocol 
modelling ban kerberos 
verifying ban kerberos 
reliability ban kerberos model 
regularity 
authenticity 
unicity 
confidentiality 
authentication 
key distribution 
temporal modelling accidents 
verifying deployed protocol kerberos iv protocol 
overview 
details 
modelling kerberos iv 
basics 
authentication phase 
authorisation phase 
service phase 
accidents 
xii verifying kerberos iv 
reliability kerberos iv model 
regularity 
authenticity 
unicity 
confidentiality 
authentication 
key distribution 
modelling agents knowledge agents knowledge trace inspection 
basic lemmas 
proving knowledge 
agents knowledge message reception 
spy knowledge agents knowledge 
updating existing models 
basic lemmas 
updating existing theorems 
proving knowledge 
revisiting guarantees ban kerberos 
trace inspection 
message reception 
revisiting guarantees kerberos iv 
trace inspection 
message reception 
comparing approaches 
otway rees 
public key protocols 
timestamps vs nonces design 
modelling smart cards smart cards 
card vulnerabilities 
card usability 
card secrets 
events 
agents knowledge 
spy illegal behaviour 
formal protocol model 
xiii verifying smart card protocol shoup rubin protocol 
modelling shoup rubin 
basics 
phase 
phase ii 
phase iii 
phase iv 
phase 
phase vi 
phase vii 
threats 
accidents 
verifying shoup rubin 
reliability shoup rubin model 
regularity 
authenticity 
unicity 
confidentiality 
authentication 
key distribution 
verifying upgraded shoup rubin 
summary 
statistics 

verifying kerberos iv proving issues property defining agents knowledge verifying shoup rubin bibliography xiv list figures example protocol 
tmn protocol 
attack tmn protocol csp notation 
woo lam protocol 
attack woo lam protocol 
public key needham schroeder protocol 
shared key needham schroeder protocol 
ban kerberos protocol 
formalising ban kerberos inductively 
kerberos iv layout 
kerberos iv protocol 
modelling kerberos iv basics 
modelling kerberos iv authentication phase 
modelling kerberos iv authorisation phase 
modelling kerberos iv service phase 
modelling kerberos iv accidents 
rule message reception 
updating ban kerberos model fragment 
otway rees protocol 
protocol otway rees fragment 
spy illegal operation case insecure means 
spy illegal operation case secure means 
pair rules output case secure means 
rules reception case insecure means 
shoup rubin protocol 
xv modelling shoup rubin basics 
modelling shoup rubin phase 
modelling shoup rubin phase ii 
modelling shoup rubin phase iii 
modelling shoup rubin phase iv 
modelling shoup rubin phase 
modelling shoup rubin phase vi 
modelling shoup rubin phase vii 
modelling shoup rubin threats messages 
modelling shoup rubin threats session keys 
modelling shoup rubin threats card outputs 
modelling shoup rubin accidents 
upgrading shoup rubin protocol 
xvi chapter communicating modern computer networks secure 
adjective secure typically embodies multiple properties 
example peer may wonder message just received exactly form sent 
message said enjoy integrity 
message received quotes certain peer creator may true 
case message said authentic 
important property message received intercepted understood peers creator receiver 
message confidential 
matter current research devise satisfactory list properties defining secure communication context modern computer networks properties implicitly assume existence malicious entity spy overhear communication create fake messages introduce traffic 
history tells security important issue ancient times considerable mounted decade relatively expensive hardware software resources 
cryptography may help 
massively world wars art coding information cryptographic key 
cleartext message transformed ciphertext key encryption 
best case cleartext retrieved ciphertext decryption key available 
consequence cleartext safe spy long know key 
contrary intended receiver message assumed know key 
cryptographic key encryption decryption cryptography said symmetric shared key des idea chapter 
asymmetric public key rsa luc 
sequel assume basic familiarity techniques 
steganography may secure communications 
art hiding message inside larger intelligible spy discern presence hidden message seeing larger 
example low order pixel bits digital image may changed message bits image suffering perceptible variations 
technique aiming confidentiality winnowing may viewed form steganography 
macs mac message authentication code message message computed original secret shared peers 
message sender authenticates message adding correct mac sends pair 
sender sends chaff different messages wrong macs 
intended receiver message knows mac correct knows secret key compute 
winnow received messages discard chaff select original message 
vast majority security protocols computer networks cryptography name cryptographic protocols 
sequences messages possibly encrypted exchanged pairs peers order subsequent communication secure 
messages include peer names cryptographic keys random numbers timestamps concatenations components ciphertexts obtained 
protocol attempts achieve certain goals time completion set properties define security 
peers belong larger set agents interpreted humans machines processes abadi needham point 
prefer interpretation 
example confidentiality guarantee available process running workstation necessarily available human owns process malicious break level workstation architecture 
dissertation word peer refers agent engaged execution protocol 
experience shows cryptographic protocols fail enforce goals claimed designers 
fact establishing protocol lives promises general daunting 
informal reasoning failed capture serious protocol failures formal reasoning address goals protocol models 
dissertation extends existing approach reasoning classical protocols analysis deployed protocols 
approach scales number protocol goals formally verified important 
informal vs formal protocol analysis principle prudent protocol design 
informal vs formal protocol analysis late cryptographic protocols analysed informal reasoning 
protocol claimed achieve goal confidentiality researchers studied protocol detail decided true 
process increasing utilisation cryptographic protocols local area networks internet granted rigour formal reasoning understood protocols bore high potential flaws 
reason protocol concurrent distributed program executed large population agents including spy 
spy entitled participate protocol agent act illegally interleaving number concurrent protocol sessions 
doing exploit session messages obtained 
vulnerability modern computer networks allows overhear messages exchanged agents 
cryptography appropriately enforcing protocol goals setting easy 
claim supported large number flaws reported 
affect known protocols subset classified 
affect publicly known banking protocols weaknesses exploited dishonest employees 
due specific implementation cryptographic primitives 
literature shows formal approaches significantly help detect protocol flaws yield general principles secure protocol design 
approaches lack expressiveness automation just complicated realistic protocols 
informal reasoning retains importance crucial grasp semantics protocol design bare representation sequence messages may find simple flaws minor weaknesses protocol quickly formal reasoning easier follow non experienced audience helps develop formal approaches 
complete understanding certain flaws guarantees trivial matter discuss chapter 
chapter 
induction theorem proving simple principle mathematical induction suffices model cryptographic protocols detail paulson intuition inductive approach 
aware entirely inductive approaches field 
inductive approach relies concept trace list events occurred network population agents running protocol 
traces defined inductively set traces admissible specific protocol 
set represents formal protocol model unbounded 
proofs may carried induction generic trace model establishing trace properties represent goals underlying protocol 
details may chapter 
interactive theorem prover isabelle supports inductive modelling protocol higher order logic nested quantification permitted functional symbols proofs developed user 
motivations research concerns verification realistic protocols inductive approach 
goals development young approach shows large potentialities verification protocol goals formally explored realistic setting investigation general principles protocol design 
section refers development state inductive approach early research began 
developing inductive approach testing approach applied classical cryptographic protocols 
general theory messages extendible formalisation spy provided 
great advantage entire treatment bound size models 
crucially population agents participate protocol potentially infinite model agents originate bijection natural numbers 
agent allowed interleave arbitrary number protocol sessions 

motivations convince practicality approach case studies necessary 
particular security community size existing case studies realistic 
decide new case studies deployed protocols 
deeper understanding informal criticism approach derives difficulties understanding concept trace commented low level view network traffic structure non existent reality 
took experimentation develop view trace possible history events occurred network 
interpretation subsequent conversation foundations approach 
proofs follow natural inductive style adopted humans verifying certain property preserved various protocol steps 
proofs widely viewed cryptic consequently results accepted 
imputed high level automation released proof scripts 
admittedly isabelle simplifier drastically reduces size subgoal difficult track rewriting rules applied order 
concern arises highly specific automatic tactics may implement proof steps aim tidying proof scripts 
possible solution conforming procedure demonstrative proofs simplifying subgoals manually certain extent applying crucial rewriting rule time ii avoiding automatic tactics linear application steps implement 
additional constituents protocols timestamps assure freshness important components session keys 
datatype messages built approach comprise timestamps 
necessary syntactical updates main issue reason freshness 
message reception modelled original release approach 
understanding theorem involves informal reasoning reception 
desirable entire reasoning formal 
raises issue complex updating existing analyses new events outcomes pay back 
important issue account commerce protocols chapter 
involve smart cards 
cards modelled 
functionalities interaction agents represented 
protocol analyses influenced 
verifying significant protocol goals existing guarantees general strategy proving goal confidentiality provided concept viewpoint mentioned initial literature 
fact guarantees expressed terms theorems useful recipients verify assumptions theorems hold 
example proof session key confidentiality available assumptions protocol initiator verify protocol achieves confidentiality initiator viewpoint 
proof conducted assumptions verifiable responder protocol necessarily attain confidentiality responder viewpoint 
existing guarantees pertain confidentiality authentication omit issues 
may contain assumptions impossible verify 
guarantee feature importance 
goal authentication merely formalised terms agents may presuppose far wider requirements subsequently discussed different approach 
new guarantees known goals integrity authenticity key distribution stronger forms authentication need treated 
example initiator informed session key confidentiality holds obvious responder shares session key means share initiator 
clear priori substantial extensions necessary formalise goals 
existing guarantees reinterpreted 
investigating principles protocol design best collection principles designing cryptographic protocols due abadi needham 
main principle supported various examples explicitness 
contents message say exactly message signifies crucially express sender 
contributions intended receiver 
principles include avoiding unnecessary encryption synchronising clocks network nodes small interval running protocol timestamps 
interesting investigate findings obtained inductive approach support principles clarify relevant goals protocol 
deep study protocol goals mentioned previous section additional principles 
contributions contributions address motivations research 
inductive approach inductive approach scales analysis real world protocols extensibility 
timestamps modelled discrete formalisation time exploits ordering elements trace 
history network global clock induced length corresponding trace 
trace equipped global clock yielding current time trace 
agents conform model avoids problems clock synchronisation 
message component fresh trace time interval creation component current time trace smaller equal lifetime allowed component 
session keys considered valid lifetime 
extensions allowed ban kerberos protocol timestamps larger deployed kerberos iv 
proof scripts fairly understandable proof automatic tactics reduced single case concerning spy operation 
new events modelled 
particular introducing message reception specifications readable proofs easier follow entire treatment intuitive 
updating existing scripts done pragmatically minor efforts 
message reception forced occur 
models network entirely controlled active spy intercept certain messages prevent delivery 
reception event allows formalisation agent knowledge just spy chapter 
new objects modelled new types language demonstrate smart cards 
interaction cards owners formalised additional events 
agents knowledge particular spy reviewed reasons long term secrets stored cards ii certain protocols smart cards assume spy listen card owner assume 
verify entire shoup rubin protocol faithful model obtained informal specification protocol description implementation 
protocol involves new long term secrets easily introduced definition agents knowledge 
result inductive approach equipped necessary features tackle modern protocols 
experiments carried known set protocol developed visa mastercard support claim 
general approach expressive bare statements theorems convey guarantees additional informal argument 
prose accompanies theorem reduced minimum 
protocol goals find argument protocol goal see section interpreted viewpoint peer 
practice double outcome providing better understanding protocol step peers guarantees practically applied 
realised assumption theorem proved shared key needham schroeder protocol fact superfluous see 
assumptions verified agent different spy necessary constitute minimal trust see 
paulson strategy proving confidentiality effective modelling timestamps 
specific lemmas necessary kerberos iv hierarchical distribution session keys 
important weakness protocol management timestamps lifetimes lets spy exploit certain session keys lifetime 
attack serious agent session keys legally granted longer network register irregularity 
treatment supports claim goals authenticity integrity equivalent see corresponding guarantees derived existing theorems 

contributions definition agents knowledge achieved modelling message reception allows formal verification goal key distribution 
argue case goal equivalent strong form authentication demonstrate ban kerberos see kerberos iv see 
verifying goals protocols smart cards requires minor modifications existing proof strategies 
set simplification rules proved deal new events new definition agents knowledge 
smart cards require guarantees protocol goals met 
messages shoup rubin protocol lack crucial explicitness peers knows session key associated 
confidentiality argument significantly weakened realistic setting spy exploit agents smart cards 
proofs suggest simple fix protocol yielding stronger guarantees 
proofs admittedly difficult 
kerberos iv shoup rubin certain proofs took weeks developed script isabelle commands long 
polishing original scripts shortens fifth original length necessary theorems installed isabelle automatic tactics 
clearly affects resulting intelligibility discussed 
fact theorem prover tailored far protocol analysis detail supports efficiency strategies isabelle 
informal conversations experienced users provers confirm 
principles protocol design research confirms essential importance explicitness 
messages explicit meaning force peers heuristic decisions turn extremely risky 
known affect classical protocols public key needham schroeder find affects protocols apparently stronger smart card shoup rubin 
interesting note message lacks explicitness carrying proofs requires quantifying existentially exact components sufficiently explicit 
argued mere expertise theorem proving lack competency area prudent protocol design 
verification kerberos iv confirms extra encryption chapter 
necessarily strengthen confidentiality 
despite double encryption responder session key key vulnerable attack mentioned 
state new principle protocol design goal availability holds protocol goals exist guarantees viewpoints protocol peers goal met 
encounter principle literature despite crucial importance 
attack kerberos iv fact due violation goal availability 
weakness shoup rubin arise violations principle explicitness 
precisely lack explicitness discovered verification goal availability 
light argue principle basic easier verify 
outline briefly outline chapters contents 
chapter reviews main formal approaches analysis cryptographic protocols focuses interpreting outcomes analyses 
difficulties obtaining related interpreting 
chapter outlines paulson inductive approach 
treatment possible informative 
basic constituents discussed details implementations avoided 
chapter discusses desirable goals cryptographic protocols addition confidentiality authenticity literature regarding inductive approach 
strategies proving developed suitable examples provided 
minimal trust put obtain results theorems explained 
important aim verification minimising trust 
principle goal availability stated 
chapter concerns extension inductive approach timestamps 
ban kerberos protocol mechanised suitable formalisation time provided 
protocol model refined temporal modelling session key accidental leaks realistically lowers minimal trust 
chapter contains mechanisation kerberos iv 
modelling time temporal modelling accidents session keys 
notation inherited preceding chapter 
protocol violates principle goal availability spy exploit mount attack 
attack prevented refining functioning trusted servers 
chapter introduces modelling agents knowledge different approaches 
demonstrated protocols previously mechanised verifying strong goal authentication goal key distribution impossible 
argument comparison refute claim ban logic 
chapter describes modelling smart cards 
protocols explicitly assume communication means cards owners reliable treatment develops options 
spy exploit unspecified set smart cards simple theft elaborate tampering 
chapter contains mechanisation shoup rubin protocol smart cards approach extended preceding chapter 
protocol discovered violate principle goal availability 
reveals protocol messages lack explicitness peer know associate received session key 
affects substantially goals confidentiality authentication key distribution fixing weakness reasonably easy inexpensive 
chapter concludes presentation 
research dissertation summarised discussed 
statistics proofs ideas conclude 
notation dissertation protocols standard notation 
protocol step essentially sends message step number sender intended recipient message message indicated 
messages indicated fat braces notation due paulson external braces omitted 
ciphertext obtained encrypting cleartext message cryptographic key indicated chapter 


example protocol invented example protocol serves demonstrate notation 
protocol consist steps 
step agent sends agent cleartext message second step agent replies ciphertext obtained encrypting concatenation message key discussion meaning needed stage 
protocols studied assuming worst conditions network spy intercept messages prevent delivery tamper 
network insecure general receiver message necessarily intended recipient 
chapter analysis cryptographic protocols formal approaches may help task analysing cryptographic protocols findings may straightforward interpret 
new millennium formal methods commonly accepted significant contribution analysis cryptographic protocols 
discuss main ones provide examples interpret findings 
belief logics give formal representation beliefs peers derive execution protocol fail capture protocol weaknesses 
state enumeration techniques model checking verify exhaustively protocol model limited size admits attacks 
provable security allows theoretical study confidentiality approaches attempt reasoning goal authentication usually lack mechanised support 
inductive approach discussed chapter embody desirable features reason variety protocol goals models unbounded size mechanised 
interpreting contributions protocol analysis straightforward 
examples findings easy obtain interpret tmn protocol fairly easy obtain fairly difficult interpret woo lam protocol difficult obtain easy interpret public key needham schroeder protocol difficult obtain interpret shared key needham schroeder protocol 
list attempt exhaustive merely highlight chapter 
analysis protocols issues concerning cryptographic protocols analysis necessarily straightforward may appear 
formal approaches section presents main formal approaches developed decade analysing cryptographic protocols 
treatment aims informative detailed exhaustive 
appropriate pointed 
belief logics belief logic due burrows attempt exceed limits informal reasoning 
idea formal approach representing beliefs agents running protocol derive various stages execution 
step protocol idealised initial logical formula set logical postulates provided 
formulae postulates derived initial ones formalise goals protocol 
typical formulae quote semantics entitled believe particular principal may act true denoted believes may shared key communicate 
key discovered principal principal trusted formula fresh sent message time current run protocol semantics provided authors turned unsatisfactory attempts repair problem 
example clear formula believe fact false 
ban logic claims correct protocols subsequently flawed variant otway rees protocol encrypt nonce issued protocol responder 
attack possible protocol initiator share session key spy completion protocol believing sharing intended responder 
violation authentication 
formal approaches confidentiality 
example public key needham schroeder protocol logic analyses detecting troubles lowe discovered years protocol suffers subtle failure authentication 
second formula considered ambiguous embodies goals confidentiality key distribution 
third formula crucial analyses 
example specify shared key needham schroeder protocol guarantee protocol responder received session key fresh 
fact denning sacco pointed spy fool responder accepting expired session key fresh 
major limitation approach reasoning confidentiality 
done informally top formulae derived calculus logic malicious entity modelled explicitly 
number extensions designed order enhance expressiveness logic account protocol goals tend sacrifice intuitive nature logic 
believe confidentiality received adequate treatment setting 
proofs belief logics typically short carried hand certain logics implemented theorem prover hol 
state enumeration model checking known process calculus csp vast applications field formal methods intuitive notions process channel 
setting easily scales analysis cryptographic protocols pioneered ryan 
approach mainly targeted detecting possible attacks spy 
peers modelled processes exchange messages encompassed protocol specific channels 
idealised specification accounts malicious entity certainly flawed tries mount attacks 
specification obtained introducing spy new process perform illegal operations 
specification equivalent idealised protocol claimed suffer attacks 
precisely specifications considered equivalent states reachable second reached 
checking pen long tedious model checker tailored enumerate reachable states 
lowe employs fdr 
process constrained intrinsic limitations model chapter 
analysis protocols checking finite systems reasonably small size tackled 
despite various techniques existing loosen limit possible model protocols small 
typically account agents including spy 
attacks discovered model checking techniques 
system limited size suffer attacks obvious system arbitrary size 
result proved pen specific protocol model checker nrl protocol analyzer allows mechanised proofs induction certain states reach 
protocol goals discussed detail confidentiality authentication see 
protocol attacked necessarily mean goals achieved 
model checkers achieved results field murphi smv spin 
step analyse public key needham schroeder protocol 
checkers temporal logic process calculus 
provable security provable security complexity theoretic study confidentiality 
originally developed bellare rogaway address problem agent authenticated key exchange notion extended authors cope agent setting trusted server helps achieve goal distributing session keys pair peers 
comment devoting entire efforts formal analysis establishing protocol suffers attacks unsatisfactory general consensus session key distribution goal adequately addressed giving protocol authors find attacks 
setting bellare rogaway formally define problem session key distribution design cryptographic protocol prove secure assuming existence family pseudo random functions prfs 
show assumption minimal prove secure session key distribution protocol exists way function exists apply existing result stating prf family exists way function exists 
protocol claimed secure terms properties 
key distribution signifying peers share session key 
formal approaches completion session 
second spy negligible advantage discovery key confidentiality key 
relevant proofs carried hand involve substantial formal complications 
treatment fine piece theory 
shoup rubin extend approach account smart cards design new protocol smart cards prove secure 
treatment suggests provable security express detailed crucial requisites goal confidentiality see chapter 
knowledge approach tested protocol designs 
shows limited flexibility sense actual protocol design adapted analysis raising risk verifying different design 
shoup rubin comment verifying protocol state modifications protocol necessary obtain proof security clear modifications protocol insecure 
implementors shoup rubin protocol point details shoup rubin fairly intricate part satisfy requirements underlying complexity theoretic framework 
approaches specific strategies verify goals confidentiality authentication 
main ones lack mechanised support 
spi calculus spi calculus extension popular calculus primitives representing cryptographic operations encryption decryption 
process calculi processes communicate channels 
channels may restricted sense certain processes may communicate 
calculus derived spi calculus allow scope restriction dynamically change computation 
process may decide send message restricted channel process outside scope restriction 
happens scope said 
intuitive restricted channels model confidentiality scope extrusion allow communication secrets 
spy modelled arbitrary environment protocol confidentiality message proved equivalence protocol specifications chapter 
analysis protocols featuring arbitrary idea proof presence influence reactions environment 
details may difficult grasp admitted authors get lost formal passages cleartext nearby may help hopefully informal explanations convey gist accomplished 
strand spaces approach rests notion strand records protocol history viewpoint single peer 
strand sequence events message sending receiving concerning peer protocol 
differs paulson notion trace see chapter records protocol history viewpoint observer see entire network 
strand space unspecified set strands agents network spy 
strands formalising spy illegal behaviour independent protocol specified protocol peers 
important sake verification notion bundle set traces sufficiently expressive formalise protocol session 
certain strands bundle send messages strands receive 
clear spy strands interfere desirable model real world scenarios spy prevent delivery messages 
notions fresh components elegantly modelled constraints construction strands 
example exists strand spy sends component prior reception 
proofs carried induction bundle philosophy reasonably easy grasp 
treatment entirely carried pen applied classical protocols needham schroeder otway rees yahalom 
applications protocols expected 
state machines gurevich state machines asms brief known evolving algebras born general purpose formalism flexible turing machine retain power 
asm thesis computable program represented 
interpreting findings suitable asm 
asm essentially order signature equipped program set rules 
interpretation signature provided static algebra originates initial state asm 
state updated rules program updating certain elements signature produce new algebra new state 
admissible functions include oracles interpretation influenced asm program provided environment state 
consequence resulting asm computational model linear graph structure 
approach benchmarked large variety real world applications distributed variant agent independently run program 
tailored variant analysis cryptographic protocols 
initially modelled kerberos iv protocol stepwise refinements presence spy 
confidentiality detailed level investigated simulation 
formal specification semantical aspects protocol obtained substantial informal documentation provided designers 
significantly simplified modelling phase mechanisation theorem proving see chapter 
developed general theory messages demonstrated public key needham schroeder protocol 
proofs conducted induction pen 
integration mechanised tools model checker theorem prover reached advanced level development may investigate protocol goals 
interpreting findings examples findings obtained analysis wellknown protocols 
concerning woo lam protocol arise informal reasoning confirms importance approach 
originate formal approaches model checking theorem proving 
corresponding notation quoted explanation sake demonstration 
tmn consider tmn protocol aims distributing session keys mobile communications 
chapter 
analysis protocols 
ka 

kb 
ka kb tmn protocol identifiers ka kb respectively represent protocol initiator responder keys choose trusted server unary constant denotes standard encryption function server able invert binary constant stands bit wise exclusive encryption 
protects messages intercepting spy read modify components 
protocol enforce agent authentication 
spy may send server fake instance message key chosen complete protocol taken part session server believe opposite true completion session 
precisely rely key kb communicating fake msg encrypt kc comm msg comm msg encrypt kb intercept msg kc kb resp fake session kb attack tmn protocol csp notation scenario attack spotted reasoning informally fairly easy interpret 
formalisation list csp events encompasses spy sends message channel fake second third messages issued legally travel channel comm 
spy prevents delivery fourth message channel intercept erroneously concludes shares key kb similarly spy may intercept second message replace identity third include key chosen attack 
result server believe took part session erroneously think key 
interpreting findings invented spy shared woo lam woo lam protocol aims authenticating initiator responder 
standard notation ka general indicates long term key shared server nb stands nonce issued authentication means mere presence network 


nb 
nb ka 
nb ka kb 
nb kb woo lam protocol receives encrypted nonce issued forwards server quoting identity 
server extracts nonce ultimately shared key returns signifies nonce encrypted key implies presence 
protocol attempt convince meant communicate stronger guarantee see 


nb nb 
nb kc nb kc 
nb kc kb nb kc kb 
nb kb nb kb attack woo lam protocol abadi needham point attack spy chapter 
analysis protocols communicating reasoning seen flawed 
spy indicated may interleave sessions uses identity acts behalf second session distinguished primes 
session spy cheats third step nonce nb addressed server reply session contains new nonce nb reply second session contain nb 
misled believing communicated may wonder puzzled receiving session nonce issued session 
stressed agent distinguish sessions received messages belong contents messages state 
receiving nonce previously issued gives required evidence presence wrong 
public key needham schroeder lowe middle person attack public key needham schroeder protocol subtle 
took half decades discovered 
protocol exchanges nonces na nb order mutually authenticate receives second step 
na kb 
nb na ka 
nb kb public key needham schroeder protocol nonce encrypted public key alive 
reception nonce third step draws lowe employs model checking techniques show spy exploit interleaved runs interpose peers believes peer fact spy 
details attack omitted known 
violate authentication terms true alive believes stronger form authentication weak agreement see assured intends communicate 
appears formal methods may way detect subtle consequences session interleaving 
showing attack avoided simply including identity second step lowe points 
interpreting findings importance explicitness investigated deeply abadi needham 
paulson formally verifies sends second message sends instance third assured sent instance message 
conveys viewpoint convey weak agreement peers viewpoints crucial investigating positive guarantees see establish beliefs peers rely 
shared key needham schroeder needham schroeder proposed key distribution protocol 
symmetric encryption protocol presupposes agent shares long term key trusted server 

na 
na kab kab kb ka 
kab kb 
nb kab 
nb kab shared key needham schroeder protocol replay attack protocol known 
spy may intercept cipher sent third step replay understanding contents 
result may fooled accepting old session key fresh 
paulson verifies induction protocol guarantees confidentiality session key issued server provided peers shared keys safe spy 
formally main assumption theorem requires event says server crypt shrk na agent key kab occurs 
theorem interpreted 
peers intended session key take advantage 
general agent verify events concerning agents take place points network 
theorem applicable server super agent sees occurring events 
applicable inspect server activity chapter 
analysis protocols establish suitable lemmas assumptions verify 
particular prove shared key safe spy certificate crypt shrk na agent key kab appears traffic event occurred 
kab confidential application previous theorem 
resulting theorem applied receives instance second message message traffic 
similarly confidentiality argument useful lemma 
shared key safe spy certificate crypt shrk key kab agent appears traffic event occurred na 
consequently receives instance third message considers session key inside confidential 
considerations emphasise peers running protocol need guarantees protocol goals met 
leads principle goal availability see 
formal reasoning devoted finding suitable evidence peers terms assumptions verify enforces goals 
model checking techniques typically exhibit protocol version suffers attack strengthened clear version guarantee available peers reasoning account 
chapter inductive approach detailed analysis security protocols performed means inductive approach support interactive theorem prover isabelle 
informal way establishing protocol property verify preserved protocol steps 
complex se process tends reach unmanageable size protocol distributed concurrent program executed indefinitely large population agents 
aim preserving property various steps inspired paulson idea proving property formally structural induction unbounded protocol model 
paulson considers security protocol unlimited population agents 
particular agents include spy monitors entire network knows long term secrets unspecified set compromised agents 
network traffic develops actions performed agents executing agent interleave unlimited number protocol sessions 
history network traffic may represented list events occurred trace 
paulson proposes set possible finite infinite traces operational model network executed 
generally abuse terminology referred formal protocol model set defined inductively specific rules drawn events occur firing rules 
rule forced fire event forced occur 
induction analysing security protocols features meadows combines state enumeration system limited size inductive proofs system reaches infinite sets states 
paulson inductive approach entirely inductive induction chapter 
inductive approach employed define protocol model operators provides strategy prove properties model 
approach mechanised interactive theorem prover isabelle supports inductively defined sets provides simplification conditional rewrite rules performs automatic case splits expressions chapter introduces main features inductive approach prior extensions basic formal structures formalisation spy knowledge operators traces principles constructing formal protocol model 
basics free type key introduced represent cryptographic keys 
isabelle datatype definition provides compact easily extensible way define type constructors injective disjoint ranges 
paulson uses define types agent msg event providing basic structures model security protocols 
symmetric key setting agent endowed long term key shared server shrk agent key functions defined respectively private public keys agent omitted encryption asymmetric 
setting cryptographic key shared key belong range function shrk session key 
unspecified set bad compromised agents revealed respective shared keys spy protocol 
agreed reveal notes taken protocol sessions 
remainder section show actual isabelle syntax basic types 
agents finite population agents running security protocol real world indefinitely large 
modelling limited population prevent protocol model capturing potentially realistic scenarios 
infinite population easily modelled establishing bijection set natural numbers 
number friend corresponding agent 
malicious agent modelled nullary 
basics constructor spy serve investigate protocol robustness illegal activity 
symmetric key protocols rely trusted third party server abbreviated access agents longterm secrets 
datatype agent server friend nat spy particular kerberos iv trusted parties datatype extended accordingly see 
abuse terminology agents spy addressed friendly 
recall view agents processes 
messages original datatype messages included constructors subsequently extended numbers model timestamps see 
basic constructors allow agent names nonces cryptographic keys 
datatype msg agent agent nonce nat key key msg msg hash msg crypt key msg recursive ones introduce compound messages hashed messages ciphers 
xn xn abbreviated 
xn xn 
encryption assumed perfect rule extract crypt kx available 
encryption assumed introduce redundancy collision free 
obviously hold certain encryption schemes exclusive attempts allow required alternative formalisations datatype 
events events model allow message sending message noting 
agents need note portions messages receive see analysis tls spy learns session key agent inaccuracy 
datatype event says agent agent msg notes agent msg introduce third event model message reception derive formalisation agents knowledge 
additional events necessary chapter 
inductive approach modelling protocols smart cards 
list events trace records events occurred certain history network 
traces parameter construction protocol model verification properties 
spy knowledge modelling spy knowledge inductively requires devising initial knowledge 
purpose paulson introduces function initstate agent msg set models agents different spy initial knowledge useful rest treatment 
server initial knowledge consists agents shared keys long term secrets 
initstate server key shrk friendly agents initial knowledge consists respective shared keys 
initstate friend key shrk friend spy initial knowledge consists compromised agents shared keys 
initstate spy key shrk bad knowledge spy obtains traces expressed function defined follows 

spy knows initial state 
spies initstate spy spies event list msg set 
spy knows messages sent trace 
spies says evs spies evs 
spy knows compromised agents notes 
spies evs bad spies notes evs spies evs note spies evs contains entire network traffic occurred history recorded evs 
consequence abuse terminology spies evs referred traffic evs 

operators operators operators introduced manipulate sets messages parts analz synth msg set msg set formal definition omitted 
set messages parts contains messages recursively extracted messages projection decryption 
similar definition builds analz decryption performed corresponding key recursively available 
brief operator assumes readable ciphers 
message trace evs parts spies evs signifies appears traffic evs possibly component larger message analz spies evs expresses spy able extract keys knows messages evs 
means confidential evs 
definition analz somewhat restrictive parts 
follows analz parts traffic trace theorem signifies components available spy subset entire traffic 
set messages known spy forward elements build compound messages ciphers sealed keys adding agent names publicly known 
messages constitute set synth operator conveys notion freshness trace event list msg set message considered fresh trace appears component agent initial state message recorded trace 
defined follows parts initstate says evs parts evs notes evs parts evs chapter 
inductive approach protocol model formal protocol model set lists events set traces 
defined inductively unbounded isabelle lists 
base case definition states empty trace belongs set 
rules formalise inductive steps 
states extend trace set possible events protocol sends new message traffic 
example protocol steps inductive rules see 
rule fake lets spy send messages fake 
evs trace set concatenation says spy evs trace set drawn synth analz spies evs 
modelling key distribution protocols rule oops typically allow accidental loss session keys spy 
rule introduces event referred oops event spy notes session key 
possible investigate local breaches security affect global security 
properties inductively defined set established corresponding induction principle 
property verified rules define set 
generates long case analyses isabelle efficiently 
chapter verifying protocol goals main goals cryptographic protocols part security system discussed strategies proving inductive approach 
security protocols cover large spectrum applications ranging banking services mail ultimately commerce intended achieve number goals depending specific application 
security simple boolean predicate 
analogy may think security conjunctive normal form formula 
conjuncts represent protocol goals remaining ones embody properties entire system security protocol runs 
devising security formula specific application matter open research 
obvious conjuncts security formula 
example lans suffered breaches security badly configured firewalls users saving important keys workstations despite fact keys protected wellestablished security protocols officially exposed external world 
external attackers merely overcome firewalls read workstation memories 
demonstrates security concept spreads multiple vertices communication architecture multiple levels vertex 
furthermore verifying conjunct security formula holds may challenging task 
particular representing goals security protocols studied formal methods decade 
example agent may need evidence received message reliable components integrity session key received different messages unicity chapter 
verifying protocol goals peer meaning communicate authentication 
inductive approach allows study properties 
chapter comments verify reliability protocol model means suitable theorems introduces regularity lemmas pioneered paulson 
discusses goals authenticity stressing correlation integrity unicity confidentiality authentication key distribution explaining strategies proving isabelle reporting limitations original approach 
minimal trust required proved guarantees explained principle goal availability 
reliability protocol model problem close model system represent intrinsically limits formal verification 
model theorem proving suitable reliability theorems highlight suffers discrepancies real system behaves expected 
major outcome increasing significance subsequent theorems proved model real world 
develop new reliability theorems establishing properties hold certain event takes place trace 
purpose define function sequel section 
verifying security protocols reliability theorems address protocol goals directly 
theorems fall category enumerated exhaustively new ones may arise specific protocols analyse 
results proved paulson theories messages events shared key protocols regarded reliability theorems 
example spy obtained set messages observation traffic may extract message components decomposing compound messages decrypting ciphers sealed known keys 
process iterated compound messages intelligible ciphers 
real world stage spy acquire new knowledge repeating previous process 
model conforms analz operator performs message analysis proved idempotent analz analz analz important reliability result states cryptographic key 
reliability protocol model fresh trace certainly long term shared key 
assures fresh key generated clash agent shared key 
probability happening real world negligible 
possibility property states protocol model contains traces event formalising step real protocol occurs 
considered reliability theorem signifies model allows completion protocol 
theorems class state friendly agent including server sends certain message protocol components message specified 
matter fact real world agents spy act known legal rules 
example paulson proves server shared key needham schroeder protocol sends formed messages 
evs trace protocol model containing says server crypt na agent key kab shrk kab range shrk crypt shrk key kab agent full proof consists isabelle commands event assumption premise inductive formula second applies induction third simplifies subgoals 
theorem guarantee server operation entirely reliable 
example clear session key fresh sent 
investigate declare function event event list event list ev evs yields subtrace events occur trace evs event ev 
traces extended reverse head trace contains events 
scan reversed evs collect elements ev ev evs takewhile ev rev evs assumptions previous theorem proved session key fresh server issues key kab says server crypt na agent key kab evs chapter 
verifying protocol goals completes argument reliability model server 
proof requires general subsidiary lemmas stating set elements trace set elements reversed trace stating element subtrace trace subtrace derived 
verifying protocols smart cards prove friendly agents server smart card provided stolen spy 
contrast spy card set compromised cards 
reliability theorems 
proving theorem class difficult 
idempotence analz easily derived definition possibility property proved joining protocol rules order showing preconditions met 
remaining theorems strictly depending specific protocol verified necessitate induction protocol rules 
simplifier terminates subgoals alternatively highlights structure remaining ones 
occasions isabelle automatic tactic combines simplification classical reasoning concludes proof 
regularity paulson regards regularity lemmas laws proved assumption message appears traffic 
concretely trace evs protocol model parts spies evs conditions proved evs 
broad definition theorems proved protocol model regarded regularity lemmas 
particular class includes theorems assessing originator certificate traffic formalise goals authenticity authentication see 
basic regularity lemma stated kind long term key 
shared key protocol requires agents send shared keys traffic trace evs protocol model agent key appearing traffic evs implies agent compromised 
proof applies induction shows key appear traffic fake case spy uses key owner compromised 
definition initstate spies parts 
authenticity result holds opposite direction regardless protocol analysed 
combining implications basic regularity lemma shared keys obtained key shrk parts spies evs bad major relevance theorem arises expressed terms analz key shrk analz spies evs bad left right implication holds analz parts regularity lemma opposite holds definition initstate spies analz 
abuse terminology address result regularity lemma sequel 
importance lies translating condition agent certainly able verify spy learning key analysis traffic able verify compromised see 
words lemma says spy knows shared key analysing traffic induced protocol knows initially 
example consider certificate ka meant sealed shared key 
want prove properties certificate spy 
turn requires key available spy regularity lemma equivalent compromised 
regularity lemma concerns private keys case evs trace model public key protocol 
authenticity message appears originated certain agent originate agent message enjoys authenticity 
iso security architecture framework distinguishes authenticity integrity holds message proved received form generated 
researchers consider source message essential part message 
verifying message unaltered received integrity confirms originator authenticity 
conversely discovering originator message received confirms message unaltered 
extent properties may considered equivalent 
private conversation dieter gollmann 
chapter 
verifying protocol goals proofs support viewpoint 
example consider ticket shared key needham schroeder protocol kab kb created server 
integrity ticket equivalent preventing spy knowing kb regularity lemma compromised 
assumption paulson proves ticket originated server authenticity 
ticket integrity implies authenticity 
converse holds 
trying prove ticket authenticity permitting spy know kb leaves subgoal arises case fake ns shared crypt shrk key kab agent parts spies crypt shrk key kab agent synth analz spies na 
says server crypt shrk na agent key kab crypt shrk key kab agent set second third assumptions signify ticket appear traffic spy synthesise analysis traffic 
symbolic evaluation synth states cases general possible 
spy merely forwards ticket obtains analysis traffic ticket belongs analz spies spy handle components necessary fake ticket 
impossible contradicts second assumption subgoal analz parts 
case simplification regularity lemma transform third assumption pair key kab analz spies bad resulting subgoal falsified assumes non contradictory scenario agent session key compromised spy 
able forge corresponding ticket kab kb server issues legally 
scenario ticket appears traffic necessarily authentic 
light considerations regard authenticity integrity single concept denoted term 
proving message authenticity general assumptions appear prevent spy faking message attempt enforce event corresponding protocol step creates message 
dealing certificate sealed long term key application 
unicity corresponding regularity lemma suffice assume key owner compromised 
assumptions may required investigate authenticity specific message components pairkey shoup rubin protocol see 
message reception allow realistic formalisation authenticity theorems agents viewpoints 
unicity security protocols involve creation fresh components nonces session keys 
component created fresh uniquely bound message origin 
observations inspired unicity theorems establishing events containing certain component occur events identical 
investigate argument deeper detail proving certain events occur 
achieve aim defining predicate unique 
yahalom protocol example requires server issue fresh session key kab peers 
evs trace yahalom model containing events says server crypt shrk agent key kab na nb says server crypt shrk agent key kab na nb na na nb nb initiator public key needham schroeder protocol issue fresh nonce na include message 
nonce available spy evs trace protocol model crypt pubk nonce na agent parts spies evs crypt pubk nonce na agent parts spies evs na available spy certificates theorem created spy 
alternatively assumed compromised order apply corresponding regularity lemma 
chapter 
verifying protocol goals proving theorems merely requires inductive analysis protocol steps simplification arising subgoals 
critical case step fresh component created 
different component introduced simplification terminates subgoal component introduced freshness assumption concludes proof 
unicity theorem useful server may useful non compromised friendly agent reception certificates na kb na kb modelling scenario formally requires message reception model see 
received certificates differ theorem violated 
suspect lies outside model happened ranging failure underlying transport protocol brute force 
observe form unicity theorem permits server send identical messages 
violate freshness assumption session key impossible 
investigate matter declare predicate takes parameter event trace unique event event list scans trace event skipped checks event occur remaining part trace unique ev evs ev set tl dropwhile ev evs predicate holds event ev trace evs ev occurs evs 
expected prove trace evs yahalom model unique says server crypt shrk agent key kab na nb evs equivalent result routinely proved induction simplification protocols analysed far 
definition predicate rewrite rule simplifier 
analysis protocols smart cards see gain new theorem case protocols assume secure means agents cards 
agents receive assurances cards functioning 

confidentiality confidentiality protocol enforces confidentiality disclose spy 
paulson session key secrecy theorem formalises session key confidentiality 
example compromised evs belongs otway rees model contains says server na crypt shrk na key kab crypt shrk nb key kab contain oops event kab involving nonces notes spy na nb key kab key kab analz spies evs proving theorem requires evaluating assertion possible extensions evs protocol model 
cases spies extracts new message say leaving expressions form key kab analz spies evs symbolic evaluation rules analz inspect pull components keys leaving expressions form key kab analz key spies evs session key subgoal corresponding oops case message containing non fresh session key introduced 
symbolic evaluation proceed general may encrypt kab message evs 
protocol prevents 
proving result session key compromise theorem provides necessary rewriting rule key analz key spies evs key analz spies evs session key 
result confirms otway rees uses session keys encrypt keys spy exploit stolen session key learn 
simplification compromise theorem oops subgoal secrecy theorem terminates unicity theorem enforcing server chapter 
verifying protocol goals issued kab nonces na nb 
subgoal corresponding third step protocol server issues session key solved freshness session key remaining ones routinely 
session key secrecy theorem constitutes main confidentiality result directly applicable agents 
lemmas necessary purpose 
confidentiality crucial nonces 
example tls protocol pre master secret pms nonce fundamental importance compute nonces session keys macs 
confidentiality pms proved conventionally addition new rewriting rule analz 
compromised evs trace tls model containing notes agent nonce pms nonce pms analz spies evs theorem signifies non compromised agent notes pms remains secure spy 
explained preceding result proof requires suitable rewriting rule analz nonce analz key spies evs nonce analz spies evs session key stating session keys exploited learn nonces 
strategies section vary message reception smart cards model 
authentication despite fact agent authentication main claimed goal security protocols exists significant potential confusion interpretation term 
taxonomy due lowe may elucidate matter identifying levels authentication 
suppose initiator completes protocol session responder 
signifies running protocol 

weak agreement signifies running protocol 
authentication 
non injective agreement signifies weak agreement agents agreed set message components 

injective agreement signifies non injective agreement respond session note level subsumes previous 
particular injective agreement establishes injective relation runs protocol runs existing authentication arguments carried inductive approach set findings taxonomy 
authentication typically interpreted find guarantees convey weak agreement 
investigating non injective agreement requires extending approach explain 
inductive approach allows agents respond received message provided expected form protocol models meant permissive possible 
strongest form authentication wish prove non injective agreement 
generic rule protocol model takes trace evs model insists events occur establishes concatenation specific event ev evs trace model 
constraining agents single reply done adding generic rule extra assumption stating ev occur evs 
leaving existing proofs unaltered possible investigate injective agreement 
lowe simply says property may important example financial protocols aware real world protocols claimed explicitly goal 
find original inductive approach requires extensions formalise non injective agreement 
key distribution protocols example non injective agreement session key relevant form authentication 
paulson proves compromised evs trace model shared key needham schroeder protocol containing says crypt kab nonce nb crypt shrk key kab agent parts spies evs crypt kab nonce nb nonce nb parts spies evs chapter 
verifying protocol goals containing oops event kab notes spy key kab evs contains says crypt kab nonce nb nonce nb message nb kab formalised crypt kab nonce nb nonce nb model spy add subtract spoof nonces assertion means step protocol taken place 
reviewing theorem discovered assumption superfluous 
general strategy theorems form appeals authenticity derives confidentiality session key 
certificate crypt kab nonce nb nonce nb appears traffic integral induction proves originated proof required assuming sent certificate fact proved corollary 
theorem establish non injective agreement kab 
reception mentioned certificates assumptions compromised kab leaked accident minimal trust see informed sent cipher sealed kab 
learns kab certificates merely sending cipher express knowledge key seals informed agrees kab 
general just forwarding unintelligible message previously received 
lowe definitions theorem establishes weak agreement protocol inspection highlights fact true creator cipher knows key seal 
chapter prove insight formally means different strategies 
key distribution key distribution main goal protocols 
met peers complete protocol session gain evidence share session key 
weaker interpretations goal protocol meets key distribution just distributes keys giving corresponding evidence peers 
case goal certainly available peers definition give section 
bellare rogaway state key distribution different agent authentication 

minimal trust goal availability reason entity authentication rarely useful absence associated key distribution key distribution useful appreciably entity authentication occurs side 
time entity authentication irrelevant 
believe key distribution agent authentication strictly related 
observe mutual non injective agreement session key fact stronger goal key distribution implies 
proofs establish key distribution authentication argument 
possible strategy key distribution protocols analysed far supports claim goals equivalent 
example recall second third steps shared key needham schroeder protocol 
na kab kab kb ka 
kab kb reception certificate kab kb strategy show knows kab deriving certificate originated reception second message protocol delivered kab 
establishes non injective agreement session key 
formalising message reception required express reasoning formally 
minimal trust goal availability previous sections stressed formal guarantees applied agent agent verify assumptions 
concept necessitates consideration 
recall session key secrecy theorem 
peers compromised order prevent spy knowing shared keys decrypting ciphers deliver session key 
spy learned key exploiting peer oops event 
assumptions form minimal trust verified agent indispensable highly permissive modelling 
guarantees appeal confidentiality argument constrained minimal trust 
reinterpreting concept specific agent viewpoint observe agent minimal trust includes agent peer compromised leaked key 
agent long term key stored workstation spy may able get chapter 
verifying protocol goals hold agent participates protocol 
depending static protection workstations terms firewalls agent minimal trust may include compromised 
modelling timestamps restricting protocol model leak session keys expired weaken assumption oops event lower minimal trust see 
modelling smart cards modify minimal trust include certain cards compromised see 
say guarantee applicable agent established theorem assumptions minimal trust verified agent 
exist guarantees certain goal protocol applicable respectively protocol peers available peers 
state principle goal availability protocol goals available peers 
investigating principle reveals attack kerberos iv see important weaknesses shoup rubin see 
chapter modelling timestamps inductive approach extended treatment timestamps timestamp protocol ban kerberos modelled verified 
original inductive approach include timestamps formalised message components fact benchmarked nonce protocols otway rees yahalom 
denning sacco pioneered timestamps field security protocols avoid replay attacks 
timestamps numbers marking specific instance time employed protocols ban kerberos kerberos iv 
extend inductive approach treatment timestamps order analyse new class protocols 
single operational difference nonces timestamps guessed spy 
model timestamps numbers include allowed message components 
price paid limited introducing new message constructor proving technical lemmas doing minor updates existing ones 
approach significantly general 
new message component model extra information real world protocols pass inside messages general available spy 
case example session identifier fields model tls protocol 
benchmark choose extended approach ban kerberos protocol known analysis ban logic provides significant opportunity comparison 
ban analysis concludes completed session protocol aware chapter 
modelling timestamps meant communicate session key kab equivalent guarantee offered kab kab logic omits investigating agreement injective may viewed mutual non injective agreement session key 
findings confirm goal extensions approach see strengthen deeper investigation authenticity confidentiality 
proofs partially adapted existing ones shared key needham schroeder protocol suggest refining treatment accidental losses session keys 
protocol model accounts temporal checks performed agents step helps understanding protocol functions mere sequencing messages 
kerberos project started mit mid decade generated variants protocol design 
ban kerberos natural modification shared key needham schroeder addition timestamps 
interesting compare temporal requisites protocols add goal authentication 
achieved inductive approach suitably extended 
chapter presents formalisation numbers introduces ban kerberos protocol modelled verified 
modelling numbers process modelling numbers consists phases 
isabelle datatype msg extended new constructor number takes parameter natural number 
timestamp represented model message component number inductive definition synth updated rule allows spy synthesise number number synth main operators need suitable rewriting rules symbolic evaluations involve new component parts number number parts analz number number analz 
ban kerberos protocol minor updates necessary existing lemmas omitted 
ban kerberos protocol ban kerberos key distribution protocol aims distributing session keys peers 


tk kab tk kab kb ka ticket 
tk kab kb ta kab 
ticket ta kab authenticator ban kerberos protocol design closely resembles shared key needham schroeder protocol rests different procedure mutual authentication see particular steps 
protocol associates lifetime session keys authenticators 
lifetimes represent time intervals corresponding components considered valid 
lifetimes passed messages omit presentation assuming known 
initial request establish session server issues fresh session key includes timestamp marks time issue inside message sealed shared key 
message contains ticket sealed shared key turn contains duplicate session key timestamp 
message sent removes external encryption learns session key kab issued time tk meant session checks tk expired establish session key valid 
builds authenticator new timestamp ta sends ticket reception message decrypts ticket learns session key session timestamp tk 
tk expired uses session key decipher authenticator 
give evidence alive able session key time ta 
guarantee certificate sends final step protocol 
chapter 
modelling timestamps modelling ban kerberos protocol uses notion time ways issues timestamps current time checks timestamps current time 
specific instants considered discrete sampling continuous time suffices modelling 
assume exists global secure clock agents rely 
equip trace clock yielding current time network history modelled trace 
traces grow linearly 
event ev located event ev trace ev real world occurred unspecified time ev 
exists injective function set traces set samplings time 
sampling corresponds trace value sampling represents time event trace took place second value represents time second event 
function clearly bijection may exist different traces corresponding sampling 
empty trace corresponds empty sampling 
time sampling normalised terms natural numbers exists injective function set discrete samplings time set segments natural numbers including zero 
empty sampling corresponds set 
sampling containing value corresponds set sampling containing values corresponds set 
current time trace highest value corresponding time sampling normalisation process current time trace length declare function define ct event list nat ct evs length evs recall trace length represents history network events taken place 
believe intuitive think current time trace declare natural numbers formalise respectively lifetime session keys authenticators 
agents check timestamps discard messages containing expired timestamps 
formalise checks declare binary predicates nat event list trace model assumes events occur simultaneously 
relaxed defining trace list sets events 

verifying ban kerberos define tk evs ct evs tk ta evs ct evs ta example tk evs holds longer time elapsed tk moment history registered evs examined 
session key associated tk longer valid evs practice long 
association tk session key established structure second protocol message need explicit formalisation 
constant bankerberos declared set lists events represents formal protocol model defined induction 
empty trace formalises initial scenario protocol session taken place 
rule base settles base induction stating empty trace admissible protocol model 
rules represent inductive steps detail extend trace model 
rule fake models spy illegal activity includes forging timestamps 
rule bk lets agent protocol session time 
rule bk models server operation subordinate agent having sent message protocol 
message cleartext spy may easily fake times overload server 
session key accompanied timestamp drawn current time 
rule bk states agent initiated protocol session may proceed third step protocol sent message non expired session key timestamp 
rule bk agent completes protocol sent specific intelligible message containing non expired timestamps 
note model need increment timestamp protocol step message structurally different 
rule oops allows accidental leaks session keys time 
note rules bk bk model agents behaviour legal ban kerberos 
example visible correct timestamps inserted 
verifying ban kerberos main guarantees proved ban kerberos section evs generic trace set bankerberos 
authentication goals subsequently strengthened extension approach 
chapter 
modelling timestamps base bankerberos fake evs bankerberos synth analz spies evs says spy evs bankerberos bk evs bankerberos says server agent agent evs bankerberos bk evs bankerberos key evs says server agent agent set evs says server crypt shrk number ct evs agent key crypt shrk number ct evs agent key evs bankerberos bk evs bankerberos says server agent agent set evs says crypt shrk number ts agent key ticket set evs ts evs says ticket crypt agent number ct evs evs bankerberos bk evs bankerberos says crypt shrk number ts agent key crypt agent number ta set evs ts evs ta evs says crypt number ta evs bankerberos oops evs bankerberos says server crypt shrk number ts agent key ticket set evs notes spy number ts key evs bankerberos formalising ban kerberos inductively reliability ban kerberos model relevant reliability theorem states model server reliable theorem 
cipher addressed server encrypts 
verifying ban kerberos shared key inserts session key ticket meant peer cryptographic keys long term keys session keys kab merely shown long term server issues fresh 
timestamp chosen current time subtrace key issued 
theorem 
evs contains ev says server crypt number tk agent key kab ticket shrk kab range shrk ticket crypt shrk number tk agent key kab key kab ev evs tk ct ev evs proving conjunct assertion requires extending existing strategy lemmas symbolic evaluation length subtrace 
regularity protocol employs single kind long term key sends traffic basic regularity lemma provable 
agent shared key appears traffic agent compromised lemma 
lemma 
key shrk analz spies evs bad 
subsequent guarantees certificates sealed shared key appeal lemma guarantee integrity 
authenticity second message ticket contained inside represent crucial certificates protocol meant deliver session key respectively 
encrypted shared keys 
applying regularity lemma assures spy handle keys encrypt certificates spoof 
consider certificate assume agent compromised order apply regularity lemma 
receives chapter 
modelling timestamps certificate inspects realises component certificate delivering session key 
theorem proves certificate created entity legally entitled issue session keys server authentic theorem 
theorem 
compromised evs crypt shrk number tk agent key kab ticket parts spies evs evs contains says server crypt shrk number tk agent key kab ticket compromised certificate regularity lemma integral 
learns session key issued time tk 
checking timestamp current time prevents accepting old key fresh 
similar guarantee holds certificate na kab shared key needham schroeder protocol 
nonce na previously issued received session key inside integral certificate infers session key nonce 
analogous guarantee established certificate theorem 
theorem 
compromised evs crypt shrk number tk agent key kab parts spies evs evs contains says server crypt number tk agent key kab crypt shrk number tk agent key kab agent guaranteed session key issued time tk verify freshness 
corresponding guarantee shared key needham schroeder protocol relies certificate kb time decide accepting old session key fresh raises known chance replay attack 

verifying ban kerberos unicity server issues fresh session keys key issued twice 
paulson strategy enforce session key appears message contexts contexts theorem 
theorem 
evs contains says server crypt shrk number tk agent key kab ticket says server crypt shrk number tk agent key kab ticket tk tk ticket ticket result proving theorems assume event issues session key 
oops rule protocol model introduces event form derived identical case contain session key 
similar result enforced tickets containing confidential session key appear traffic 
theorem allows server send identical messages prove impossible theorem 
stronger guarantee states server issues session key peers timestamp ticket 
theorem 
evs contains says server crypt shrk number tk agent key kab ticket unique says server crypt shrk number tk agent key kab ticket evs confidentiality proof session key compromise theorem provides crucial rewriting rule analz operator conventional ban kerberos session keys encrypt keys 
peers shared keys compromised protocol step reveals spy session key server issues 
key leaked accident proved confidential theorem 
chapter 
modelling timestamps theorem 
compromised evs contains says server crypt shrk number tk agent key kab ticket contain notes spy number key kab key kab analz spies evs application authenticity theorem result useful minimal trust imposed assumptions oops event theorem 
theorem 
compromised evs crypt shrk number tk agent key kab ticket parts spies evs contain notes spy number key kab key kab analz spies evs likewise session key confidentiality proved viewpoint theorem application authenticity theorem confidentiality theorem 
theorem 
compromised evs crypt shrk number tk agent key kab parts spies evs contain notes spy number key kab key kab analz spies evs authentication aims ban kerberos enforce mutual agent authentication 
authenticator third message authenticate fourth message authenticate proofs suggest goal met minimal trust 
section shows protocol establishes mutual weak agreement extensions approach show establishes mutual non injective agreement session key important timestamp see 
tracing back originator authenticator requires session key seals confidential 
assumptions confidentiality theorem allowed reasoning viewpoint 
circumstances authenticator proved originated third step protocol theorem 

verifying ban kerberos theorem 
compromised evs crypt shrk number tk agent key kab parts spies evs crypt kab agent number ta parts spies evs contain notes spy number key kab contains says crypt shrk number tk agent key kab crypt kab agent number ta receives ticket extracts session key receives authenticator sealed infers alive meant communicate 
theorem express knowledge kab ta 
strategy proves cipher form fourth message protocol created fourth step theorem 
necessary condition cipher sealed confidential session key conveyed appeal confidentiality theorem 
theorem 
compromised evs crypt shrk number tk agent key kab ticket parts spies evs crypt kab number ta parts spies evs contain notes spy number key kab contains says crypt kab number ta gets hold suitable certificates infers alive meant communicate 
theorem express knowledge kab ta 
key distribution want establish protocol session peers evidence share session key major goal protocol 
order decrypt authenticator ta kab learn kab ticket tk kab kb minimal trust considers kab chapter 
modelling timestamps confidential 
authenticator faked sent third step protocol 
authentication theorem establishes formally 
true creator authenticator know session key seal 
notion captured formally current approach general event says occurs may just forwarding having knowledge contents 
overcome problem extend inductive approach chapter capture notion agent true creator message 
modelling message reception provide alternative reasoning receives ticket authenticator previously received instance second message learnt session key 
authentication theorem allows considerations viewpoint 
certificate ta kab proved sent proving knowledge session key requires mentioned modelling 
temporal modelling accidents minimal trust confidentiality authentication theorems raised necessity checking oops event occurred 
general possible friendly agent viewpoint see raises concern allowing leaking session key time model permissive 
observe longer message component traffic higher risk spy may get hold 
particular probability session key compromised increases time 
light considerations assume protocol session key leaked long lifetime expired key leaked long valid 
restricting model accordingly requires adding condition tk evs oops rule 
session key leaks may happen histories evolved longer time issue session key 
new model confidentiality authentication theorems rest assumption tk evs evs contain notes spy number key kab 
agent check new temporal assumption verifying current time 
temporal modelling accidents differ timestamp allowed lifetime 
minimal trust required theorem lower 
temporal modelling accidents analysis kerberos iv see chapter 
chapter 
modelling timestamps chapter verifying deployed protocol kerberos iv protocol verified extended inductive approach weakness discovered protocol management timestamps 
commonly deployed variant kerberos protocol version iv 
kerberos iv password system authentication authorisation local area networks 
developed late aim user authenticates network machine process obtaining authorisation access network service completely transparent 
user certainly prompted password request authorisation phase 
enter password authentication phase 
kerberos iv pursues aim delivering certain credentials login process user authentication phase 
credentials suitable trusted server subsequent authorisation phase 
receiving storing credentials invisible user 
model trusted server authentication phase authorisation phase 
issues session key specific lifetime 
session key issued server encrypt issued second server 
feature greatly complicates verification confidentiality goals technique modelling association message components reused analysis yahalom protocol 
temporal modelling accidents investigate authenticity unicity confidentiality authentication chapter 
verifying deployed protocol key distribution goals 
verification principle goal availability discover weakness management timestamps leads attack spy may access network service session key belongs user longer network 
proofs suggest simple fix formally verified effective 
knowledge mechanised modelling complete protocol 
previously analysed protocol asms formalising actions unbounded population agents means detailed algebraic model 
formal specification starting point informal significantly simplifies inductive definition protocol model 
mitchell model check highly simplified version protocol derives kohl 
timestamps included model multiple runs allowed 
find attacks system size consisting initiator kerberos servers responder redirection attack system size including responders full kerberos iv prevents explicitness see section 
chapter describes phases kerberos iv modelling verification 
kerberos iv protocol kerberos iv essentially key distribution protocol 
relies kerberos system comprises trusted servers database containing users passwords sealed standard unix way encryption algorithm 
overview user types identifier password login process encrypts password unix algorithm 
process agent initiates protocol recall view agents processes 
full protocol consists phases compulsory 
phase authentication comprises protocol steps serves authenticate initiator kerberos system specifically kerberos authentication server kas short 
user registered agents share sealed password long term secret constitutes initiator shared key initiator computed kas looked database 
secret kas issues authorisation 
kerberos iv protocol kerberos iv layout credentials initiator second phase authorisation comprises third fourth protocol steps 
phase occurs initiator currently running workstation requires network service 
previously obtained authorisation credentials initiator contacts kerberos system specifically ticket granting server tgs brief 
initiator obtains service credentials final phase service order access requested service 
note kas long term key tgs agents shared kas 
details complete protocol 
authentication phase initiator queries kas identity tgs timestamp kas issues session key looks shared key database 
replies message sealed shared key containing session key timestamp ta tgs ticket 
session key ticket credentials subsequent authorisation phase address authkey respectively 
sealed tgs shared key contains copy authkey timestamp peers 
lifetime authkey hours 
older ta respect lifetime assured kas reply prompt 
check affirmative may start authorisation phase 
sends tgs component message including authenticator sealed authkey containing chapter 
verifying deployed protocol authentication 
kas tgs 
kas authk tgs ta tgs authk ta ka authorisation 
tgs tgs authk ta authk authenticator 
tgs servk ts servk ts kb authk servticket service 
servk ts kb servk servticket authenticator 
servk kerberos iv protocol identity new timestamp identity 
lifetime authenticator minutes 
reception message tgs decrypts extracts authkey checks validity timestamp ta ta old respect lifetime authkeys 
tgs decrypts authenticator authkey checks validity respect lifetime authenticators 
tgs issues new session key looks shared key database 
replies message sealed authkey containing new session key timestamp ts ticket 
session key ticket credentials subsequent service phase address servkey servticket respectively 
servticket sealed shared key contains copy servkey timestamp peers 
lifetime servkey minutes 
older ts respect lifetime assured tgs reply prompt 
may start service phase 
sends component message including servticket authenticator sealed servkey containing identity new timestamp reception message decrypts servticket 
modelling kerberos iv extracts servkey checks validity timestamp ts 
decrypts authenticator servkey checks validity increments seals servkey sends back simplified version protocol fourth message include occurrences identity 
spy mount mentioned redirection attack changes identity compromised third message intercepts fifth message decrypts servticket extracts servkey decrypts authenticator extracts timestamp sixth message 
believes completed protocol session fact redirected participated 
complete kerberos iv clearly suffer attack 
modelling kerberos iv modelling trusted servers requires modifying isabelle datatype agents datatype agent kas tgs friend spy definition initstate updated allow trusted servers know agents shared keys 
kas tgs assumed compromised 
protocol reliance time identical ban kerberos adopt discrete formalisation current time trace 
define natural numbers formalising respectively lifetimes authkey servkey authenticator 
intuitive binary predicates nat event list check respective validity validity timestamps associated ta evs ct evs ta ts evs ct evs ts evs ct evs predicates holds timestamp trace say timestamp expired corresponding key authenticator expired trace 
chapter 
verifying deployed protocol lifetime indicates validity interval trusted server replies 
suitable binary predicate checks timestamp issued lifetime timestamp valid wrt agents discard late servers replies may due servers temporary malfunction network latency operating check 
replies arriving lifetime highly reliable 
constant kerberos declared set lists events represents formal protocol model defined induction 
basics inductive definition kerberos contains basic rules 
sets base induction base introducing empty trace protocol model 
second models spy illegal activity fake allowing spy send fake message obtained active analysis traffic agent 
base kerberos fake evs kerberos synth analz spies evs says spy evs kerberos modelling kerberos iv basics authentication phase protocol initiator go authentication phase kas 
trace including empty extended event formalising message protocol 
faithful real world agent including spy may decide initiate protocol session 
model kas reply subject previous occurrence suitable request agent 
real world kas receive request operating approach include message reception see 

modelling kerberos iv evs kerberos says kas agent agent tgs number ct evs evs kerberos evs kerberos key authk evs says kas agent agent number set evs says kas crypt shrk key authk agent tgs number ct evs crypt shrk tgs agent agent tgs key authk number ct evs evs kerberos modelling kerberos iv authentication phase authorisation phase initiator may require authorisation network service 
contacting tgs checks agent issued message con evs kerberos says kas agent agent tgs number set evs says kas crypt shrk key authk agent tgs number ta set evs ta evs valid ta wrt says tgs crypt authk agent number ct evs agent evs kerberos evs kerberos key servk evs tgs says tgs crypt shrk tgs agent agent tgs key authk number ta crypt authk agent number agent set evs ta evs evs says tgs crypt authk key servk agent number ct evs crypt shrk agent agent key servk number ct evs evs kerberos modelling kerberos iv authorisation phase chapter 
verifying deployed protocol taining authorisation credentials 
message specific form sender spy 
reception message implicit 
note checks authkey expired issued validity interval request 
trace records query expected form tgs may issue reply provided authkey authenticator expired 
service phase phase modelled layout authorisation 
initiator contact requested service trace records issue servkey validity interval request 
servkey expired 
acknowledging request checks servkey authenticator expired 
need model incremented timestamp step contribute goals protocol see 
message different sent protocol 
evs kerberos says tgs crypt authk agent number agent set evs says tgs crypt authk key servk agent number ts servticket set evs ts evs valid ts wrt says servticket crypt servk agent number ct evs evs kerberos evs kerberos says crypt shrk agent agent key servk number ts crypt servk agent number set evs ts evs evs says crypt servk number evs kerberos modelling kerberos iv service phase 
verifying kerberos iv accidents authkeys operationally different session keys 
chiefly types keys associated timestamps turn associated different lifetimes 
authkeys issued kas meant tgs issued tgs meant network services 
furthermore authkey expires corresponding user logged workstation processes killed 
contrary servkey expires intended network service accept initiator undertake new authorisation phase 
allow accidental leaks session keys adopting temporal modelling accidents seen 
authkey noted spy timestamp peers provided expired servkey 
interesting investigate spy exploit expired session keys get hold non expired ones 
major success model allows reuse session key lifetime real world 
kerberos says kas crypt shrk key authk agent tgs number ta set ta notes spy agent agent tgs number ta key authk kerberos kerberos says tgs crypt authk key servk agent number ts servticket set ts notes spy agent agent number ts key servk kerberos modelling kerberos iv accidents verifying kerberos iv kerberos iv session keys peculiar way tgs employs authkey encrypt servkey fourth message 
feature chapter 
verifying deployed protocol greatly complicates verification confidentiality goals 
proofs show synchronising issue types keys crucial 
synchronisation implemented protocol responder network service gets weak confidentiality guarantee spy may exploit validity interval 
introducing suitable abbreviations distinguish types session keys express association authkeys section presents goals verified kerberos iv 
evs generic trace set kerberos 
reliability kerberos iv model address authkeys formally define function authkeys event list key set authkeys evs yields session keys kas issues trace evs ignoring eventual repetitions authkeys evs authk ts says kas crypt shrk key authk agent tgs number ts crypt shrk tgs agent agent tgs key authk number ts set evs lemmas needed symbolic evaluation function 
example states formally authkeys appear empty trace lemma signifies kas introduce authkey lemma 
lemma 
authkeys 
lemma 
authkeys says kas crypt shrk key authk agent tgs number ta evs authk authkeys evs trace evs formalised keys belong range shrk session keys authkeys evs authkeys 

verifying kerberos iv model kas proved reliable theorem 
addressing message agent kas seals shared key includes session key authkey formed 
function defined establish authkey fresh issued timestamp chosen current time moment 
theorem 
evs contains ev says kas crypt key authk agent tgs number ta shrk authk range shrk authk authkeys evs crypt shrk tgs agent agent tgs key authk number ta key authk ev evs ta ct ev evs analogous guarantee enforces reliability model tgs theorem 
authkey seal message includes fresh servkey servticket quotes 
theorem 
evs contains ev says tgs crypt authk key servk agent number ts servticket authk range shrk authk authkeys evs servk range shrk servk authkeys evs servticket crypt shrk agent agent key servk number ts key servk ev evs ts ct ev evs expected obtain results general strategy proving reliability theorems upgraded frequent appeals lemmas 
chapter 
verifying deployed protocol regularity kerberos iv sends shared keys network shared key available spy owner compromised 
corresponding regularity lemma usual formulation lemma 
lemma 
key shrk analz spies evs bad 
authenticity protocol intends deliver authkey tgs servkey determining originator certificate contains session key confirm authenticity certificate key 
usual analysis performed agent viewpoint proofs carried strategies described 
instance second message sealed shared key carries authkey meant appeal regularity lemma guarantees certificate tamper proof induction proves originated kas theorem 
recall theorem useful reception certificate 
theorem 
compromised evs crypt shrk key authk agent tgs number ta parts spies evs evs contains says kas crypt shrk key authk agent tgs number ta guarantee enforced certificate delivers authkey tgs theorem 
recall tgs compromised 
theorem 
evs crypt shrk tgs agent agent tgs key authk number ta parts spies evs evs contains says kas crypt shrk key authk agent tgs number ta crypt shrk tgs agent agent tgs key authk number ta 
verifying kerberos iv investigate authenticity servkey 
fourth message delivers sealed authkey 
clearly authkey order message intelligible authkey shared key regularity lemma help authkey explicitly assumed confidential 
second fourth messages structure 
theorem pinpoints second message explicitly assuming quotes tgs 
fourth message quotes different agent tgs assumption investigate authenticity theorem 
version theorem useful confidentiality assumption authkey relaxed confidentiality argument see 
theorem 
tgs evs crypt authk key servk agent number ts servticket parts spies evs key authk analz spies evs exists evs contains says tgs crypt authk key servk agent number ts servticket servticket structure sealed shared key belonging agent different tgs 
regularity lemma applied investigate authenticity servticket 
prove theorem tgs sent servticket encrypted session key originated kas 
theorem 
compromised tgs evs crypt shrk agent agent key servk number ts parts spies evs exist authk ta evs contains says tgs crypt authk key servk agent number ts crypt shrk agent agent key servk number ts says kas crypt shrk key authk agent tgs number ta crypt shrk tgs agent agent tgs key authk number ta chapter 
verifying deployed protocol unicity kas issues fresh authkeys classical unicity theorem state authkey appear different messages 
theorem rests unique predicate state kas sends authkey 
guarantees hold fresh issued tgs 
servticket structure contain fresh session key establish useful unicity result applies ticket assumption session key confidential theorem 
relaxing assumption confidentiality argument see theorem useful tgs theorem 
evs analz spies evs crypt shrk agent agent key parts spies evs crypt shrk agent agent key parts spies evs confidentiality authkey encrypt agent authenticated request service 
expect compromise authkey may cascade 
conversely encrypt keys compromise servkey affect keys 
observations proved formally providing significant session key compromise theorems 
fundamental rewrite rules analz operator proving session key secrecy theorems actual confidentiality goals protocol 
session key compromise proof scripts theorems discussed section may appendix association authkeys kerberos iv resembles association session keys nonces yahalom protocol 
relations formalised similar fashion 
define predicate akcryptsk key key event list 
verifying kerberos iv holds trace contains event associates authkey servkey akcryptsk authk servk evs ts says tgs crypt authk key servk agent number ts crypt shrk agent agent key servk number ts set evs lemmas proved predicate 
chiefly keys encrypt authkey shared key lemma single authkey encrypts servkey lemma servkey encrypt keys lemma 
lemma 
evs authkeys evs range shrk akcryptsk evs 
lemma 
evs akcryptsk authk servk evs different authk akcryptsk servk evs 
lemma 
evs servk authkeys evs servk range shrk akcryptsk servk evs 
session key associated key predicate akcryptsk key encrypt compromise increase spy chances discover expressing formally provides essential lemma lemma 
proof long complicated simplification takes quarters total computational time case analyses required 
assumptions theorem example authkey servkey provided encrypt lemma 
range shrk evs akcryptsk evs key analz key spies evs key analz spies evs chapter 
verifying deployed protocol session key compromise theorem concerns authkeys shared keys proved unaffected accidental loss session key theorem 
proof follows applying lemma lemma 
recall authkeys particularly valuable secrets long lifetime 
theorem 
evs authkeys evs range shrk range shrk key analz key spies evs key analz spies evs theorem concerns authkey associated servkey authkey help spy discover servkey theorem 
proof follows applying lemma lemma 
theorem 
evs akcryptsk authk servk evs different authk key servk analz key spies evs servk key servk analz spies evs cryptographic key affected loss servkey theorem 
note assumptions bind proof follows application lemma lemma 
theorem 
evs servk authkeys evs servk range shrk key analz key servk spies evs servk key analz spies evs 
verifying kerberos iv session key secrecy session key secrecy theorems express confidentiality session keys 
general strategy verify property viewpoints servers refine findings authenticity theorems 
authkey expired lost accident rule 
adding peer compromised assures key travels safely inside second message protocol 
assumptions key confidentiality enforced viewpoint kas theorem frequent appeals theorems 
theorem 
compromised evs contains says kas crypt shrk key authk agent tgs number ta ta evs key authk analz spies evs refining result authenticity theorem produces confidentiality guarantee authkey 
analogous result enforces confidentiality servkey tgs viewpoint assumption key expired authkey associated confidential theorem 
frequent appeals theorems necessary proof 
assumption authkey confidentiality clearly indispensable fourth message protocol falsify theorem 
assumption relaxed theorem producing guarantee applicable tgs kas tgs inspect functioning 
compromised servticket spy observes fifth message reveal servkey 
theorem 
compromised evs contains says tgs crypt authk key servk agent number ts servticket key authk analz spies evs ts evs key servk analz spies evs chapter 
verifying deployed protocol servkey confidentiality useful theorem existing authenticity confidentiality theorems 
step applying theorem theorem derive authkey confidentiality 
theorem gives servkey originated tgs theorem concludes 
theorem 
compromised evs crypt shrk key authk agent tgs number ta parts spies evs crypt authk key servk agent number ts servticket parts spies evs ta evs ts evs key servk analz spies evs investigating servkey confidentiality viewpoint provides opportunity deeper insight protocol theorem revealing violation principle goal availability 
proof develops forward style 
elaborates history servk deriving confidentiality authk theorems 
theorem states authk session key belong range shrk necessary apply theorem derive origin servk certainly different tgs theorems derive servk authkey theorem states 
stage theorem introduces possible history servk unicity argument tgs unifies histories 
appeal theorem concludes 
theorem 
compromised evs crypt shrk agent agent key servk number ts parts spies evs crypt authk key servk agent number ts servticket parts spies evs crypt shrk key authk agent tgs number ta parts spies evs ta evs ts evs 
verifying kerberos iv key servk analz spies evs closer look proof just described shows applying theorems servticket servk ts kb derived theorem 
parts closed message decomposition assumption theorem technically unnecessary 
formulation highlights verify trust 
real world witness reception servticket verifying fifth assumptions theorem 
certainly able verify second third fourth pertain authentication authorisation phases participate 
assumptions necessary 
signify authkey encrypts servkey confidentiality studied expired 
indispensable application theorems enforces authkey confidentiality indispensable derive servkey confidentiality due form fourth message 
attack assumptions verify theorem applied theorem reveals reception servticket trust preceding phases compromised authkey consequently servkey 
obtains weak guarantee servkey confidentiality 
note observations arise checking protocol conforms principle goal availability 
matter fact admitting session keys leaked accident expired model attack possible 
authkey belonging expires spy gets hold killed owner logged workstation spy extracts associated authkey messages previously intercepted exploits expired spoof fifth message needs update timestamp authenticator access corresponding network service believes communicating fact exist anymore 
owner longer connected register irregularities 
lifetime spy obtain access services fact granted protocol initiator 
chapter 
verifying deployed protocol fixing attack unsafe allow remain valid authkey associated expires 
preventing fixes attack 
aim achieved constraining tgs operation suitable temporal check add rule ct evs ta note ta timestamp marks issue authkey check prescribes expiry time servkey latest equals authkey 
strengthened protocol model theorem longer needs second third fourth assumptions applicable obtains strong confidentiality guarantee 
shorter old proof new requires arithmetic 
explicitly assumed different tgs servticket servk ts kb misinterpreted 
theorem updated enforce condition derives history servk ts evs condition derive ta evs 
theorems conclude proof 
note unicity argument required reasoning develops single history servk authentication authentication main goals kerberos iv 
protocol aim mutual authentication initiator network service initiator tgs 
sake completeness observe message cleartext authenticate initiator kas 
spy may overload server fake requests way ban kerberos 
authenticity theorem authenticates kas initiator providing guarantee weak agreement 
authenticator authk third message aims authenticating tgs 
tgs merely receiving authenticator enforce goal tgs receive corresponding tgs authk ta learn authk able decipher authenticator 
authk confidential scenario sent certificates instance fourth message theorem 
relaxing 
verifying kerberos iv assumption confidentiality theorem results guarantee tgs 
note regularity lemma guarantees integrity tgs compromised confidentiality authk establishes authenticator 
theorem formalises weak agreement tgs express true creator authenticator give evidence tgs knows authk alive time prove formally stronger goal met see 
theorem 
evs crypt authk agent number parts spies evs crypt shrk tgs agent agent tgs key authk number ta parts spies evs key authk analz spies evs exists evs contains says tgs crypt shrk tgs agent agent tgs key authk number ta crypt authk agent number agent proof relies integrity certificates requires substantial simplification deal long inductive formula 
significant subgoal arises rule introduces event form asserted theorem 
events contain different authkeys inductive formula terminates proof appeal unicity theorem required 
authenticity theorem guarantees weak agreement tgs strategy proves weak agreement theorem 
theorem relies certificates form previous 
assuming tgs establishes contain servticket 
expected assumed compromised order servticket integral 
theorem strengthened state formally knows servk alive time see 
theorem 
tgs compromised evs crypt servk agent number parts spies evs crypt shrk agent agent key servk number ts parts spies evs key servk analz spies evs chapter 
verifying deployed protocol evs contains says crypt shrk agent agent key servk number ts crypt servk agent number proving weak agreement theorem little complicated message protocol fails state identity 
fortunately lack explicitness overcome additional checks side 
theorem state formally knows servk alive see 
theorem 
compromised evs crypt servk number parts spies evs crypt authk key servk agent number ts servticket parts spies evs crypt shrk key authk agent tgs number ta parts spies evs key authk analz spies evs key servk analz spies evs evs contains says crypt servk number understand theorem recall message protocol certificate sealed servkey 
key confidential certificate spoof 
reception certificate derive servkey meant recalling association established instance fourth message 
sealed confidential authkey meant order association reliable invented spy 
key distribution current potential inductive approach inadequate reason key distribution observed analysis ban kerberos 
chapter introduce necessary extensions verify goal 
chapter modelling agents knowledge messages agents knowledge messages defined possession messages 
approaches formalise notion inductive approach demonstrated compared 
reasoning formally security protocols invites confusion belief knowledge 
abstracting context may help clarify difference 
alice knows everyday life sufficient evidence true 
believes necessarily evidence 
ban logic captures notion belief misinterpreted knowledge 
predicate believes signifies entitled believe may act true 
subsequent research extends logic proper concept knowledge meertens introduce predicate rightly believes holds believes fact holds 
demonstrated previous chapters inductive approach provides meta formalisation agents beliefs knowledge means theorems 
stated agent viewpoint express agent knowledge case agent verify assumptions 
conversely agent obtain evidence truth values assumptions theorems express agent beliefs 
assumptions constitute minimal trust beliefs knowledge 
chapter provides formal definition agents knowledge message components messages knowledge certain events occurred 
crucial verify main goal chapter 
modelling agents knowledge protocols formalised key distribution 
peers session key receive guarantees peer knows key 
definition prepares inductive approach analysing new hierarchies protocols 
example non repudiation protocols aim non repudiation reception requires proving agents knowledge specific components reception 
ecommerce protocols delivery goods merchant obtains assurances bank knows components correspond exact payment 
protocols group key agreement aim distributing key agents group providing agent evidence goal met 
express knowledge component possession component 
notion formalised ability actively component turn verifiable inspecting history network 
alternatively reception component expresses possession requires introducing corresponding event 
improves readability analyses 
outcomes approaches detail ban kerberos kerberos iv 
chapter continues comparison approaches discusses outcomes timestamps nonces protocol design 
agents knowledge trace inspection agent creates message certainly knows components message including cryptographic key eventually seals message 
unfortunately says event inadequate express creation observed may occur agent merely forwarding unintelligible message 
require message appeared larger message event says occurs true creator established inspecting history precedes event 
history recorded trace enforcing property simply requires trace inspection 
declare predicate issues agent agent msg event list issues evs holds creates message trace evs 
events may occur events appended head traces 
detecting occurrence time 
agents knowledge trace inspection event ev trace evs requires scanning evs reverse tail head 
traces lists isabelle provides numerous functions reasoning lists 
unary rev reverses list binary takewhile takes predicate list scans list returns elements list verify predicate 
functions defining issues known 
issues evs says set evs parts parts spies takewhile says rev evs seen predicate requires sent possibly inside larger message appears traffic preceding event 
basic lemmas technical lemmas necessary reason reversed lists 
provable induction relevant trace 
example traffic trace element says event amounts traffic subtrace event plus message introduced event lemma 
recall isabelle symbol list concatenation operator 
lemma 
spies evs says spies evs 
analogous law concerning notes event omitted lemma serves establish obvious result formally traffic reversed trace original trace lemma 
lemma 
spies evs spies rev evs 
technically important result states traffic subtrace obtained takewhile function subset traffic set lemma 
lemma 
spies evs spies evs 
proving knowledge general strategy devised prove significant guarantees terms issues predicate 
chapter 
modelling agents knowledge suppose message component larger message event says occurs trace evs 
true creator prove issues evs holds 
assumptions necessary ensure spy forge creates compound message assume spy analyse components traffic synthesise ciphertext assume confidentiality key seals 
assumed spy acts legally protocol 
assumptions may required see depending protocol 
proof develops strategy 
simplify main subgoal definition issues 
isolate conjuncts definition issues proceeding backward style resolving rules existential quantification conjunction 
prove conjunct says assumption second conjunct parts symbolic evaluation parts operator 
apply structural induction protocol model verify steps protocol definition preserve property occurrence event says trace implies appears trace event 
simplify subgoals 
prove subgoal corresponding protocol step event says takes place applying lemmas trivial ones lemma introducing event says available assumptions see 
theorem limited importance merely says agent knows components messages sends particularly useful refine theorems enforce event says example strategy investigated goals agreement key distribution protocols analysed far demonstrated ban kerberos kerberos iv 

agents knowledge message reception agents knowledge message reception extensions inductive approach mentioned section released distribution isabelle 
primitive modelling message reception introduced extending isabelle datatype events follows datatype event says agent agent msg notes agent msg gets agent msg real world message received previously sent 
reception invariant easily enforced protocol model see 
technically speaking notes event replaced gets event imagining agent notes message agent received network 
compromise reception invariant 
keeping events separate allows reasoning turns readable faithful reality ultimately simpler 
example reception invariant messages received need enrich set components trace 
definition extended rule gets evs evs spy knowledge agents knowledge major outcome introducing message reception realistic formalisation agents knowledge 
rudimentary version available initially inductive approach soon enhanced express knowledge single agent spy means function spies 
previous chapters demonstrated function allows reasoning confidentiality key distribution 
generalise spies binary function captures agent knowledge knows agent event list msg set additional parameter represents agent knowledge defined 
entire range function initstate relevant rest treatment 
definition knows generalises spies base case inductive steps corresponding existing events 
third inductive step necessary account gets event 
chapter 
modelling agents knowledge 
agent knows initial state 
knows initstate 
agent knows sends trace particular spy knows messages sent 
knows says evs knows evs spy knows evs 
agent knows notes trace spy knows compromised agents notes 
knows notes evs knows evs spy bad knows evs 
agent spy knows receives trace 
spy knowledge extended received messages spy knows case reception invariant 
knows gets evs knows evs spy knows evs initial definition agents knowledge agent see message sent somebody ensure delivered reception event allows faithful treatment matter step definition knows 
recall function analz applied set messages recursively extracts components compound messages bodies messages encrypted keys known 
real world agent knows message protocol model contains trace evs knows evs need decryption get hold analz knows evs retrieve larger message set knows evs 
friendly agents may need apply function analz circumstances 

agents knowledge message reception updating existing models prot formal protocol model 
reception invariant message received sent enforced adding inductive rule definition protocol 
rule called reception allows extending trace prot contains event says event gets reception prot says set gets prot rule message reception note rules forced fire trace gets event forced take place 
guarantee established message sent received intended recipient realistic setting spy prevent message delivery 
furthermore rule fire message received fire wrong order order messages sent necessarily preserved reception 
note agents discard sender label reception reliable insecure network 
protocol model needs updates 
event says appears premises rule appear event replaced gets old model acted undefined agent sent agent spy monitor events performed agents condition directly verifiable received 
new model expresses behaviour closely 
shows fragment updated model ban kerberos derived 
note fake rule contains knows spy spies occurrences spies existing theories updated similarly 
basic lemmas prot protocol model definition includes reception rule 
evs generic trace prot 
induction easily proves prot satisfies reception invariant lemma 
chapter 
modelling agents knowledge fake evs bankerberos synth analz knows spy evs says spy evs bankerberos bk evs bankerberos key evs gets server agent agent set evs says server crypt shrk number ct evs agent key crypt shrk number ct evs agent key evs bankerberos bk evs bankerberos says server agent agent set evs gets crypt shrk number ts agent key ticket set evs ts evs says ticket crypt agent number ct evs evs bankerberos updating ban kerberos model fragment lemma 
evs contains gets exists evs contains says applying lemma existing omitted stating spy knows messages sent prove knows messages received lemma 
lemma 
evs contains gets knows spy evs 
reading lemma spy derive spy knows messages receives 
case definition knows allows result generalised agent knows receives lemma 
lemma 
evs contains gets knows evs 
resolving lemma lemma parts obtain messages received appear traffic lemma 
lemma 
evs contains gets parts knows spy evs 
updating existing theorems lemma allows significant modifications theorems proved protocols analysed far 

agents knowledge message reception consequence theorems available definition agents 
example unicity theorem ban kerberos available agents compromised theorem 
proof rests double application lemma double application authenticity theorem introduces necessary assumptions apply unicity theorem 
theorem 
compromised evs belonging bankerberos contains gets crypt shrk number tk agent key kab ticket gets crypt shrk number tk agent key kab ticket tk tk ticket ticket agent compromised receive session key different messages suspect gone wrong unknown formalisation 
unique predicate proved hold reception event message received 
theorems readable faithful reality 
example authentication kerberos iv established reception suitable message theorem 
proof applies lemma stating parts closed message decomposition existing authentication theorem 
theorem 
tgs compromised evs belonging kerberos contains gets crypt shrk agent agent key kab number ts crypt kab agent number kab analz knows spy evs evs contains says crypt shrk agent agent key kab number ts crypt kab agent number chapter 
modelling agents knowledge proving knowledge crucial fact agents knowledge lemma agent knows receives 
applying analz derive agent knows components received messages decrypt 
designing guarantees agent inform knowledge components proving event gets took place 
proving event occurred depends protocol analysis 
examples show prove goal key distribution ban kerberos see kerberos iv see 
revisiting guarantees ban kerberos tested approaches agents knowledge existing protocol analyses 
section presents outcome verification ban kerberos concentrating goals authentication key distribution receive significant benefits 
outcomes mentioned 
sake readability statement confidential evs replace analz knows spy evs 
trace inspection general strategy described may applied prove friendly agent sends instance third message ban kerberos agent created message theorem 
proof script may appendix theorem 
spy evs belonging bankerberos contains says ticket crypt kab agent number ta kab confidential evs issues crypt kab agent number ta evs anticipated general strategy difficult subgoal prove arises case formalising third step protocol quote 

revisiting guarantees ban kerberos spy evs bankerberos says crypt shrk number tk agent key kab ticket set evs says server agent agent set evs key kab analz spies evs says ticket crypt kab agent number ct evs set evs crypt kab agent number ct evs parts spies takewhile says ticket crypt kab agent number ct evs rev evs false resolve monotonicity law parts lemma obtain lemma assumption subgoal resolved producing crypt kab agent number ct evs parts spies monotonicity law parts lemma give authenticator belongs parts spies evs appears traffic 
stage proof terminate application authentication theorem assumptions available 
try fetch 
third assumption subgoal derive crypt shrk number tk agent key kab ticket analz spies evs referred condition certainly compromised kab confidential 
theorem agent mentioned third assumption fact server 
theorem derives ticket intelligible form traffic evs assumption missing applying theorem compromised 
subgoal give sufficient information derive fact 
initial level proof tree 
backtrack level derive ticket analz spies evs ticket appears compound message 
friendly agent prove induction form ticket sending fourth message established server 
ticket crypt shrk number tk agent key kab chapter 
modelling agents knowledge tk 
conditions follows compromised kab confidential follow condition compromised 
proof proceeds mentioned subgoal terminate indicated 
authentication theorem resolved assumption theorem 
enhance readability version theorem confidentiality assumption session key relaxed theorem 
obtain guarantee available conveying knowledge kab non injective agreement kab theorem 
theorem assumes friendly acts legally 
implies alive time ta 
theorem 
spy compromised evs belonging bankerberos crypt shrk number tk agent key kab parts spies evs crypt kab agent number ta parts spies evs kab confidential evs issues crypt kab agent number ta evs procedure relies authentication theorem prove analogous guarantee theorem 
theorem informs knows kab establishes non injective agreement kab 
theorem 
compromised spy evs belonging bankerberos crypt shrk number tk agent key kab ticket parts spies evs crypt kab number ta parts spies evs kab confidential evs issues crypt kab number ta evs unfortunately protocol requires reply incremented ta understands alive ta 
words ta nonce 
inserted current time place ta informed exact instant alive desirable outcome timestamps 
theorems formally prove ban kerberos achieves goal key distribution 
section shall see goal verified message reception 

revisiting guarantees ban kerberos message reception seen proving goal key distribution protocol signifies proving agent obtained session key protocol peer knows session key 
approach message reception reasoning agents knowledge aim proving peers received session key assumptions peer verify 
ban kerberos allows proofs achieving goal key distribution 
suppose agent compromised receives instance third message protocol quotes agent spy 
assuming session key confidential session key known theorem 
theorem 
spy compromised evs belonging bankerberos contains gets crypt shrk number tk agent key kab crypt kab agent number ta kab confidential evs key kab analz knows evs proof simple 
theorem authenticates updated guidelines established assumptions theorem 
compromised 
having sends instance third message friendly agent derive induction received instance second message containing kab extract key definition knows updated version theorem theorem establishes non injective agreement kab 
strategy authentication theorem prove knowledge session key assumptions verifiable theorem 
theorems establish non injective agreement kab 
theorem 
compromised spy evs belonging bankerberos contains gets crypt kab number ta gets crypt shrk number tk agent key kab ticket chapter 
modelling agents knowledge kab confidential evs key kab analz knows evs theorems signify ban kerberos achieves goal key distribution 
revisiting guarantees kerberos iv approaches agents knowledge scale proving non injective agreement key distribution kerberos iv 
proofs expected longer ban kerberos distinguishing kinds session keys tickets requires case analyses 
sake readability statement confidential evs replace analz knows spy evs 
trace inspection previously mentioned authenticity theorem establishes weak agreement kas general strategy may establish kas sends instance second message kas issuing message appeared 
resolving assumption result theorem provide evidence kas knows authkey mentioned message 
theorem omitted establishes non injective agreement kas authkey 
friendly agent sending instance third message prove creator authenticator message contains 
note kas certainly spy injections created isabelle datatype messages generic agent explicitly assumed friendly order result hold 
combining authentication theorem obtain guarantee non injective agreement tgs authkey authk theorem 
relaxing confidentiality assumption authk theorem guarantee applied tgs minimal trust compromised 
theorem informs tgs alive time theorem 
spy evs belonging kerberos crypt authk agent number parts spies evs 
revisiting guarantees kerberos iv crypt shrk tgs agent agent tgs key authk number ta parts spies evs authk confidential evs issues tgs crypt authk agent number evs kas tgs acts legally 
prove tgs sends instance fourth message message new 
result combined theorem expressed weak agreement tgs yields guarantee non injective agreement tgs keys authk servk theorem 
guarantee tells tgs alive time ts 
theorem 
tgs evs belonging kerberos crypt authk key servk agent number ts servticket parts spies evs authk confidential evs tgs issues crypt authk key servk agent number ts servticket evs prove friendly agent sends instance fourth message create authenticator included message 
resolving theorem main assumption stated result derive non injective agreement servkey servk theorem 
guarantee tells alive time theorem 
spy tgs compromised evs belonging kerberos crypt servk agent number parts spies evs crypt shrk agent agent key servk number ts parts spies evs servk confidential evs issues crypt servk agent number evs chapter 
modelling agents knowledge friendly agent sends instance message sealed confidential servkey message proved new 
result refine theorem expressing non injective agreement servkey servk theorem 
cheat assumed friendly 
observed ban kerberos learns alive ta get stronger information replaced ta fresh timestamp 
theorem 
compromised spy evs belonging kerberos crypt servk number parts spies evs crypt authk key servk agent number ts servticket parts spies evs crypt shrk key authk agent tgs number ta parts spies evs authk servk confidential evs issues crypt servk number evs theorems signify kerberos iv guarantees key distribution 
goal concerns servkey peers 
addition theorems signify key distribution met protocol initiator tgs authkey 
section shall see study goals message reception 
message reception entire hierarchy theorems rests unique philosophy authenticity authentication theorems updated suitable reception events provide guarantees weak agreement 
definition knows prove specific agents knowledge specific session keys 
combining guarantees derive non injective agreement session keys 
agent compromised receives instance second message sealed shared key appeal lemma derives necessary assumptions apply theorem 
resulting theorem stating kas sent message received agent establishes weak agreement kas kas knows shared keys extract learn authkey contained message 
theorems formal 
revisiting guarantees kerberos iv statement omitted guarantee non injective agreement kas authkey 
updated authentication theorem states reception tgs instance third message includes confidential authkey agent mentioned authenticator sent message 
agent 
friendly induction proves sends third message reception second extract authkey 
tgs assured knows authkey theorem 
updated version assert non injective agreement tgs authk theorem 
spy evs belonging kerberos contains gets tgs crypt shrk tgs agent agent tgs key authk number ta crypt authk agent number agent authk confidential evs key authk analz knows evs authenticity theorem proved assuming protocol initiator reception instance fourth message 
initiator guarantee conveys weak agreement tgs states tgs sent message tgs received suitable instance third message learning authkey 
definition knows tgs knows servkey associated authkey 
agent informed tgs knows session keys theorem 
established non injective agreement tgs authk servk theorem 
tgs evs belonging kerberos contains gets crypt authk key servk agent number ts servticket authk confidential evs key authk analz knows tgs evs key servk analz knows tgs evs theorem expressing weak agreement updated version theorem 
friendly sends instance fifth message reception suitable instance fourth extract servkey 
informed knows servkey theorem 
theorems establish non injective agreement servk chapter 
modelling agents knowledge theorem 
spy tgs compromised evs belonging kerberos contains gets crypt shrk agent agent key servk number ts crypt servk agent number servk confidential evs key servk analz knows evs theorem updated terms reception messages mentions 
friendly agent sends message protocol reception 
extract servkey received servticket 
strategy informs initiator servkey received known responder theorem 
consequence protocol non injective agreement servk theorem 
compromised spy evs belonging kerberos contains gets crypt authk key servk agent number ts servticket crypt servk number gets crypt shrk key authk agent tgs number ta authk servk confidential evs key servk analz knows evs theorems show kerberos iv achieves goal key distribution protocol initiator tgs authkey 
theorems guarantee goal key distribution initiator responder servkey 
comparing approaches main aim formalising agents knowledge investigate goals non injective agreement key distribution 
verified classical protocols analysed far needham schroeder yahalom otway rees woo lam approaches knowledge 
approaches compared respect goals 

comparing approaches analysis ban kerberos supports claim approaches equivalent 
theorems obtained trace inspection appear convey guarantees theorems respectively obtained message reception 
approach trace inspection rely formalisation instant reception refer earlier time messages considered appear traffic 
light approach argued stronger enforce guarantees earlier time approach message reception 
theorem practical relevance assumptions verifiable 
guarantees proved approach applicable time reception suitable messages 
kerberos iv confirms equivalence theorems appear equivalent theorems respectively 
demonstrated guarantees obtained trace inspection protocols timestamps add temporal requisite goal authentication establishing friendly agent creates message containing current time timestamp expresses agent alive 
approach message reception clearly express approach compare temporal requisites timestamps nonces add protocol design see 
note versions kerberos require peers session key create new messages 
contrary consider protocol delivers session key peer requiring peer 
approach trace inspection expresses knowledge message components ability create message certainly prove significant property case 
contrast approach message reception express peer knowledge session key reception allowing investigation key distribution agreement 
delivery session key step protocol goal key distribution met see depending protocol design 
definition goal certainly achieved events occurring protocol execution implies agent received message contains session key 
fact agent knows key known agent peer 
otway rees otway rees protocol offers term comparison 
chapter 
modelling agents knowledge responder obtains session key server forwards initiator message protocol 

na ka 
na ka nb kb 
na kab ka nb kab kb 
na kab ka otway rees protocol key distribution achieved receives session key gets evidence peer knows gets evidence 
definition otway rees meet goal key distribution delivers session key message 
delivery key event occurring protocol may wonder protocol enforces half key distribution reception session key get evidence knows 
approach agents knowledge trace inspection help answer question simply forwarding certificate containing session key traffic 
certainly issue certificate 
analysis protocol ban logic came interesting note protocol kab encryption key principal know key known 
refute claim showing exists protocol similar otway rees session key encryption key informs agent peer know session key 
ban logic fact fails capture knowledge messages received approach agents knowledge trace inspection 
formal account message reception lets discover reason otway rees fails guarantee shares session key fact lack message integrity 
consider protocol differs otway rees messages shown 
new protocol dissimilar original otway rees 
example third message informs nb kab na fourth merely forwards precisely ban logic infer usual formula kab 
comparing approaches 
na kab ka nb kab kb 
na kab ka protocol otway rees fragment certificate main difference new third message enjoys integrity cipher old compound 
new fourth message integral irrelevant reasoning 
particular message compound quoting certificate na kab ka 
integrity third message crucial allows keep track activity compromised 
server sends message trace evs certificate contains visible spy message integrity 
precisely belong analz knows spy evs 
contrary certificate visible spy acted 
leading philosophy theorem 
integral formal model protocol 
theorem 
compromised evs belonging integral crypt shrk agent nonce nonce na key kab analz knows spy evs evs contains says crypt shrk agent nonce nonce na key kab result proved original otway rees assumption holds acted 
incidentally result hold replacing analz parts certificate appears component traffic acted new protocol 
proof straightforward requires new rewriting rule analz operator 
particular subgoal arising formalisation fourth step protocol requires evaluating assumption crypt shrk agent nonce nonce na key kab analz key knows spy evs symbolic evaluation trivial 
prove rewriting rule inform simplifier session key encrypt cipher protocol lemma 
chapter 
modelling agents knowledge lemma 
session key evs belongs integral confidential evs crypt kx analz key knows spy evs crypt kx analz knows spy evs proof developed conventional strategy session key compromise theorem 
requires subsidiary results authenticity messages issued server hold original otway rees 
conclusive portion reasoning asserts agent compromised sends message protocol reception integral suitable instance theorem 
theorem 
compromised evs belonging integral contains says crypt shrk agent nonce nonce na key kab nb evs contains gets crypt shrk agent nonce crypt shrk agent nonce nonce na key kab nonce nb key kab merely friendly agent prove sends message reception suitable seen similar steps ban kerberos kerberos iv 
extracts message sends larger message sealed shared key 
compromised message integral ensures contains occurrences session key 
fragments reasoning 
reception message protocol concludes certificate available spy lemma analz decomposition analz message compound 
theorem derive acted 
received intelligible message quoting session key received stated theorem extract key 
protocol informs session key receives known peer theorem 
theorem 
compromised evs belonging integral contains 
timestamps vs nonces design gets crypt shrk agent nonce nonce na key kab key kab analz knows evs new protocol differs original otway rees integrity message issued server 
otway rees protocol kab encryption key inform knows session key 
new protocol meets goal half key distribution public key protocols testing approaches agents knowledge public key needham schroeder protocol limitation message reception 
example consider step protocol suppose takes place history modelled trace evs 
evs contains event says crypt pubk agent nonce na agent issues nonce na sends inside cipher sealed public key 
know private key necessary decrypt cipher establish na belongs analz knows evs 
fact knows na just created 
trace inspection attraction case prove creates entire cipher knows components 
know na reception cipher requires reasoning message reception 
combination approaches easily implemented yield best results analysing public key protocols 
timestamps vs nonces design experiments support claim protocol design timestamps add stronger temporal requisites nonces goals protocol 
timestamps linear order agent may check freshness message containing timestamp point having participated protocol 
agents need know specific chapter 
modelling agents knowledge lifetime timestamp lifetimes general secret 
agents run synchronisation protocol synchronise clocks 
argued threats protocol offset gains obtained timestamps cryptographic protocol lies outside scope research 
contrast protocol nonces agent wanting check freshness message participated earlier protocol issued nonce 
agent inserted nonce message 
ban kerberos may viewed shared key needham schroeder modified addition timestamps 
find significant compare temporal requisites goals authenticity authentication achieved protocols goals independent time 
recall protocols figures 
model servers proved function reliably create components send 
approach agents knowledge message reception suffices express reasoning formal statements omitted 
authenticity argument ban kerberos theorem assures non compromised protocol initiator message tk kab ticket ka originated server 
server reliable guarantee informs message session key contains created time tk 
setting paulson proves message na kab ticket ka needham schroeder protocol originated server 
nonce na nonce assured message time issued na 
requisite applies session key kab 
identical guarantees may considered practically equivalent 
non compromised protocol responder assured ticket tk kab kb ban kerberos protocol originated server 
presence timestamp derives ticket session key created time tk 
guarantee available setting running needham schroeder ticket form kab kb 
timestamps vs nonces design obtains information kab concerning goal authentication theorem assures alive time ta 
analogous guarantee theorem proved needham schroeder conveys similar requisite 
fact informed alive created nonce nb 
note ns shared denotes formal protocol model double concatenation nb formalises message protocol 
theorem 
spy compromised evs belonging ns shared crypt shrk key kab agent parts spies evs crypt kab nonce nb nonce nb parts spies evs kab confidential evs issues crypt kab nonce nb nonce nb evs theorem assures alive time ta issued ta update ta viewed nonce message 
analogous guarantee theorem proved needham schroeder shows authentication goal enjoys similar requisite 
theorem 
compromised spy evs belonging ns shared crypt shrk nonce na agent key kab ticket parts spies evs crypt kab nonce nb parts spies evs kab confidential evs issues crypt kab nonce nb evs fact simply informed creates message containing nonce nb 
nb issued deduce temporal requisite presence 
note approaches agents knowledge conduct reasoning 
despite obtained design timestamps nonces exist protocols complicated nonces 
example authentication goals achieved peers yahalom protocol nonces enjoy significant temporal requisites 
chapter 
modelling agents knowledge chapter modelling smart cards inductive approach tailored analysis protocols smart cards 
spy chance cloning agents cards exploiting computational resources 
protection long term secrets main reason smart cards 
researchers believe smart card completely tamper resistant modern cards offer high level physical security 
cheap integrated circuit memory card may store kilobytes provide strong shell important information 
additionally integrated circuit microprocessor card embeds bit microprocessor perform relatively simple operations des encryption decryption 
consequently existing security protocols extended smart cards new ones designed purpose 
refer protocols smart cards smart card protocols opposed traditional protocols 
microprocessor cards operating systems allow execution user chosen java programs cutting costs applications pay tv mobile public phones credit cards 
forrester research estimates commerce attract clients usa years new millennium 
smart card readers inexpensive pieces hardware home computers running smart card middleware 
smart cards strengthen goals protocols exists increasing demand formal guarantees target reached 
knowledge attempts chapter 
modelling smart cards establishing guarantees 
abadi pioneer smart cards establish mutual authentication agents workstations 
treatment develops different functionalities smart cards employed facing limited technology time belief logic simple extension ban logic 
calculus logic prove mutual authentication delegation goals protocols impose different requirements cards 
confidentiality issues considered belief logics notoriously inadequate purpose 
shoup rubin design protocol smart cards analyse provable security 
treatment show chapter 
motivated insufficient research done field extend inductive approach verification smart card protocols 
model cards associated new type formal language interact respective owners receiving sending messages 
card stores basic set long term secrets may depend specific protocol 
example card key distribution protocols store specific keys card commerce protocols may store number representing owner balance 
cards forced perform computations may skip repeat 
spy stolen unspecified set cards discover pins pin operated able 
furthermore cloned set cards discovering internal secrets 
spy act illegally set cards belong agents card 
smart card protocols assumption secure means signifying spy interpose agents cards 
messages exchanged clear agent knowledge long term secrets reduces 
account opposite alternative simple variations definition spy knowledge 
text secure means abbreviate assumption secure means hold insecure means abbreviate assumption hold 
chapter begins formalisation smart cards inductive approach 
presents extensions necessary datatype events definition agents knowledge 
spy illegal operations exploit certain smart cards legally protocol model may require extensions account 
extended approach demonstrated chapter 

smart cards smart cards aim representing operational aspects smart cards introduce new free type card associated functions 
exists bijective correspondence agents smart cards card agent card real world cards cpus provide certain limited resources card produce specific output fed correct input 
example card compute session key input card necessarily fed order obtain formal protocol model easily account 
allow outputs encompassed protocol condition cards fed corresponding specific inputs 
construct outputs cloned cards see section 
consequence exists card give spy unlimited power 
card vulnerabilities model cards suffer number realistic vulnerabilities due theft cloning internal failures 
theft small dimensions smart cards confer portability raise risk loss theft 
worst case smart cards lost owners stolen spy hands 
cards longer owners modelled set stolen stolen card 
cloning spy necessarily able stolen card actively knows pin 
able modern techniques break physical security card access eeprom long term secrets stored worst case reverse engineer card chip 
stage spy able build clone card 
process succeeds card belongs set cloned model cloned card 
electrically programmable read memory 
chapter 
modelling smart cards cloning apparent theft cloning techniques currently known invasive sense spoil original card 
chip card frame suitable chemicals layout modified laser cutter 
alterations irreversible 
spy steal card build clones return card owner suspect 
alternatively spy able tailor non invasive techniques fault generation exploiting power clock supply lines cloning near return original card owner building clone 
modelling opportunities simply requires stating relation sets stolen cloned card cloned stolen 
card legal owner spy granting identical computational resources 
data bus failure cards data buses corrupted travelling messages forgotten due electronic decay permuted fed cpu repeatedly due simple layout modifications 
smart card omit computations repeat 
worst case spy caused cards deteriorate fashion delivered respective owners leaving visible trace tampering 
model events occur firing inductive rules formal protocol model rules forced fire preconditions met 
rules may fire order fire possibilities recorded trace 
global internal failure smart cards may suffer unexpected failures working point 
formal protocol model reflects scenario including traces involve cards event 
card usability agents spy conduct legal operations spy act legally illegally 
card stolen allowing message alteration leakage level give spy excessive power protocols explicitly rely secure means agents smart cards 

smart cards owner legally 
spy handle non stolen card 
definition 
card card stolen 
assumption secure means hold spy listen agent smart card electronic access cards knows pins 
pins sent agents cards agents spy learn certain traces 
contrary cards pin operated illegally usable 
definition 
assumption secure means hold spy knows pin evs cards pin operated card evs true cards pin operated informal predicate spy knows pin evs refined formal definition agents knowledge see 
case assumption secure means hold spy needs gain physical access cards addition knowledge pins 
monitor events involving smart cards chance discovering pins events 
know initially see definition illegal usability depend trace 
cards pin operated need characterise physical access card 
definition 
assumption secure means hold card cloned card stolen spy knows pin card cards pin operated card cloned card stolen cards pin operated informal predicate spy knows pin refined 
spy able card legally opportunity act legally 
need smart card pin operated accepts communication activated means pin 
chapter 
modelling smart cards card illegally acquire additional knowledge 
assume card spy stolen cloned assumption card belongs server 
stress certain cards may cloned time stolen may exist cards legally illegally usable 
agent able verify card stolen checking holds 
assumptions agent card agent peer card belong minimal trust 
card secrets smart card typically contains long term symmetric keys pin activate functionality card key 
pin agent key card key functions equivalently defined cards agents 
card key serves limit data stored card ram 
suppose card required issue fresh nonce outputs nonce encrypted key 
cipher may assess nonce authenticity card card store nonce assuming card key secure 
case key distribution protocols card stores owner long term key known agent contrast traditional protocols 
keep original definition shrk agent key note model operational notion smart cards storing secrets need formalised explicitly 
need define secrets circumstances known 
increases flexibility approach 
smart cards store additional secrets certain applications secrets formalised suitable functions definition agents knowledge updated 
assume collision keys impossible functions declared injective ranges disjoint 

events events suppose assumption secure means hold 
message sent card owner vice versa reception guaranteed 
events formalised 
upgrade isabelle datatype events follows 
datatype event says agent agent msg notes agent msg gets agent msg inputs agent card msg gets card msg outputs card agent msg gets agent msg known network events sending noting receiving message extended new card events 
agents may send inputs cards inputs cards may receive gets similarly cards may send outputs agents outputs agents may receive gets 
agent distinguish messages received network received smart card reader arrive separate channels provide different events 
cases messages forged spy 
extending reception invariant protocol model allows cards receive gets event messages sent inputs event agents receive gets event messages sent outputs event see 
assumption secure means hold events gets gets omitted 
matter fact card certainly receives owner inputs agent certainly receives card outputs 
consequently smart card verify event inputs occurred agent verify event outputs occurred impossible insecure means 
formal definition function extended cope new events inputs evs parts evs gets evs evs outputs evs parts evs gets evs evs cases concerning gets gets extend set components corresponding events take place messages chapter 
modelling smart cards accounted reception invariant 
assumption secure means holds cases omitted 
agents knowledge function initstate formalising agents initial knowledge redefined account secrets stored smart cards 
quote fairly general definition smart card protocols pin operated cards 
original datatype agents employed 
server initial knowledge consists long term secrets 
initstate key pin key key shrk friendly agents initial knowledge consists respective pins 
initstate friend key pin friend spy initial knowledge consists compromised agents initial knowledge secrets contained cloned cards cards store secrets blinded encrypted form spy may discover worst case 
initstate spy key pin bad card cloned key cloned key shrk card cloned note definition influenced assumption secure means formalises situation protocol sessions taken place 
knowledge agents extract traces defined function knows extended account card events 

agent knows inputs card trace particular spy knows messages input 
knows inputs evs knows evs spy knows evs 
agent including spy extend knowledge messages received smart card trace 
spy message originators know case 
agents knowledge reception invariant 
knows gets evs knows evs 
agent knows cards outputs trace means insecure spy knows controls means 
knows outputs evs knows evs spy knows evs 
agent spy knows receives card trace 
spy knows messages received smart card case due reception invariant 
knows gets evs knows evs spy knows evs stage definition refined 
recall function analz extracts message components set messages keys recursively available 
definition assumption secure means hold key pin analz knows spy evs cards pin operated card evs true cards pin operated particular cloned card card owner compromised illegally usable trace definition initstate base case knows definition analz 
expected illegal usability card insecure means necessarily imply spy physical access card 
assumption secure means hold definition knows simplifies implementation may appendix 
base case corresponding network events remain unchanged 
cases pruned corresponding events longer defined 
agent sends input card card sends back output messages certainly received spy listen 
cases amended accordingly 
chapter 
modelling smart cards agent including spy knows inputs card trace 
knows inputs evs knows evs knows evs agent including spy knows output card trace 
knows outputs evs knows evs knows evs desired cases forbid spy learning card events 
knows pin knows initially 
definition initstate base case knows definition refined 
definition assumption secure means hold card cloned card stolen bad cards pin operated card card cloned card stolen cards pin operated definition insists spy physical access illegally usable cards secure means 
cards pin operated secure means hold card illegally usable legally usable 
hold general converse 
function knows extended smart cards reasoning cards knowledge may little significance due limited ram 
spy illegal behaviour demonstrated chapters spy illegal behaviour traditional protocols typically specified single inductive rule extends protocol model 
model tls protocol contains second rule allows spy construct session key algorithm public 

spy illegal behaviour modelling smart card protocols spy allowed exploit illegally usable smart cards 
assumption secure means hold spy send fake messages inputs illegally usable cards send fake outputs agents pretending card produce 
done addition sending fake messages network receiving message card reader network may induce agent different reactions 
fake rule amended outlined 
note condition illegal usability insecure means stated card 
fake smart insecure card evs synth analz knows spy says spy inputs spy card outputs card spy smart insecure spy illegal operation case insecure means assumption secure means holds spy send fake card outputs agents 
presents corresponding new fake rule 
note condition illegal usability secure means stated card 
fake smart secure card synth analz knows spy says spy inputs spy card smart secure spy illegal operation case secure means scenario definition knows spy gains knowledge card events concern 
ensure illegally usable card outputs spy owner 
realistic insecure means illegally usable cards lie spy hands 
suppose card outputs fed formal protocol model contain rule name requires card legally usable 
rule name fake added allow card output spy case card illegally usable input spy 
spy learns firing rule 
extra assumptions name kept chapter 
modelling smart cards name smart secure card inputs card set outputs card smart secure name fake smart secure card inputs spy card set outputs card spy smart secure pair rules output case secure means name fake 
card legally illegally usable rules enabled fire 
rule name fake unnecessary insecure means spy monitors card events 
formal protocol model formal model smart card protocol requires additional features assumption secure means hold 
smart cards allowed receive inputs sent agents likewise agents allowed receive outputs sent cards 
purposes introduce rules reception reception respectively inspired reception rule allows reception messages sent network 
rules forced fire kind reception network agent smart card means guaranteed case world spy controls means 
reception smart insecure inputs card set gets card smart insecure reception smart insecure outputs card set gets smart insecure rules reception case insecure means assumption secure means hold reception card means guaranteed rules needed 
chapter verifying smart card protocol provably secure shoup rubin protocol smart cards mechanised 
weaknesses due lack explicitness affect goals confidentiality authentication key distribution 
shoup rubin take account existing session key distribution protocol due leighton micali prove secure bellare rogaway framework 
develop new protocol design leighton micali session key distribution agent setting agent endowed smart card compute prfs 
extend bellare rogaway approach account smart cards argue new protocol enjoys properties 
pair agents running protocol share session key protocol session spy prevent delivery relevant messages 
proof property may obvious readers unfamiliar formalism 
second adversary shown mathematical proof negligible advantage signifying session key remains confidential 
reasoning performed kind mechanised support 
applied extended inductive approach described previous chapter shoup rubin protocol verified goals authenticity unicity confidentiality authentication key distribution 
argue confidentiality stated protocol terms provable security highly theoretical 
discovered confidentiality theorems hold protocol model applied peers chapter 
verifying smart card protocol protocol lacks goal availability 
due lack explicitness crucial protocol steps 
inspecting corresponding proofs suggests simple fix verified effective 
knowledge represents mechanisation full protocol smart cards 
chapter presents shoup rubin protocol modelling verification 
verification extended upgraded version protocol achieves stronger goals 
shoup rubin protocol version protocol obtained designers implementors presentations 
denote agent longterm key shared server kp smart card cp smart card long term key 
protocol relies concept pairkey due leighton micali establish long term secret smart cards pair agents 
pairkey historically referred pair agents agents ab kb ka bit wise operator 
card compute ka ab kb ab card compute ab directly 
cards share long term secret ab call pair full protocol develops phases 
ones take place network numbered ones cover communication agents smart cards 
phase initiator tells trusted server wants initiate session responder receives return pairkey ab certificate encrypted long term key 
phase ii 
queries card receives fresh nonce certificate encrypted card long term key 
form query specified designers implementors choice message arbitrary 
phase iii 
contacts sending identity nonce na 
phase iv 
queries card data received obtains new nonce nb session key kab certificate na nb certificate nb kab constructed function nb ab 

shoup rubin protocol 

ab ab ka ii 
ca 
ca na na iii 
na iv 
cb na 
cb nb kab na nb ab nb ab 
nb na nb ab vi 
ca na nb ab ab ka na nb ab na 
ca kab nb ab vii 
nb ab shoup rubin protocol phase forwards nonce nb certificate na nb phase vi 
feeds card name nonces just received nb pairkey certificate certificates nonces card computes ab ab uses nonce nb compute session key kab card outputs kab certificate nb encrypted ab phase vii 
forwards certificate nb protocol assumption secure means spy listen agents respective cards 
cards output session keys clear 
feature may unrealistic vast scale general adds robustness protocol reducing agent knowledge pin activate card 
current version shoup rubin fact employs smart cards pin operated agent knows long term secrets 
explicitly stated designers implementors pa chapter 
verifying smart card protocol features may 
protocol reveals nonce spy step step 
informal account consequences hardly 
formally verify session key computed nonce knowledge nonce help spy discover session key long cards 
modelling shoup rubin protocol uses pairkey cryptographic key merely means establish corresponding pair 
pairkey remains secret long spy observe compute 
model treats nonces 
pairkey agent agent nat contrary pair proper cryptographic key 
session key constructed nonce pair 
pairk agent agent key sesk nat key key operational level need explore implementation details components contrast interested properties 
function pairkey declared collision free represents application exclusive operator 
expected influence corresponding confidentiality argument 
assuming collision keys impossible functions declared collision free ranges disjoint 
respectively disjoint ranges functions formalising long term keys pair differs card key forth 
definition initstate updated implementation may appendix 
protocol relies cards occurrences function pin may omitted 
server initial knowledge comprise pair initstate key key shrk key pairk nonce pairkey friendly agents initial knowledge empty able reveal secrets spy 
pers peter honeyman implementors kindly clarified private conversation 

modelling shoup rubin initstate friend recall definition pairkey pair previous section 
spy initial knowledge extended pair pair agents case card second agent cloned spy knows agent shared key 
pairkey included corresponding cards cloned 
initstate spy key cloned key shrk card cloned key pairk card cloned nonce pairkey card cloned card cloned formalisations smart cards events spy inherited general treatment previous chapter 
server uses smart card protocol 
declare constant shouprubin set lists events 
designates formal protocol model defined rest section means inductive rules 
protocol assumes secure means cards pin operated definition illegal usability applies 
basics basic rules formal protocol model 
empty trace formalises initial scenario protocol session taken place 
rule base settles base induction stating base shouprubin reception shouprubin says set gets shouprubin modelling shoup rubin basics empty trace admissible protocol model 
rules represent inductive steps detail extend trace model 
particular rule reception allows messages sent network received respective intended recipients 
rule fake treated see 
chapter 
verifying smart card protocol phase rules modelling phase protocol 
agent server may initiate protocol session time corresponding event may extend trace model sr 
sr evs shouprubin says server agent agent evs shouprubin sr evs shouprubin gets server agent agent set evs says server nonce pairkey crypt shrk nonce pairkey agent evs shouprubin modelling shoup rubin phase reception message quoting agent names initiator responder session server computes pairkey sends certificate initiator sr 
pairkey sent clear reveal peers 
information carried certificate explicitly creates association pairkey peers 
phase ii rules modelling phase ii protocol 
initiator protocol session may query smart card provided received message containing nonce certificate sr 
sr evs shouprubin card says server agent agent set evs gets nonce pk cert set evs inputs card agent evs shouprubin sr evs shouprubin card nonce na evs inputs card agent set evs outputs card nonce na crypt card nonce na evs shouprubin modelling shoup rubin phase ii 
modelling shoup rubin initiator gets assurance nonce fact pairkey intended responder certificate specific pairkey 
message traversed network clear spy tampered 
sensible agent forwarded entire message smart card able decrypt certificate verify integrity authenticity pairkey 
protocol specification encompass analysing protocol simpler input message containing initiator name 
input card issues fresh nonce certificate sr 
card keeps record nonce order conserve memory 
certificate subsequently show card authenticity nonce 
steps rest legally usable smart card express legal operations card owner 
phase iii rules modelling phase iii protocol 
initiator obtains nonce certificate smart card may forward nonce identity intended responder sr 
phase responder obtains message sr evs shouprubin says server agent agent set evs outputs card nonce na cert set evs cert says agent nonce na evs shouprubin modelling shoup rubin phase iii form different certificate perform different events 
stage responder initiate protocol session third agent decide behave phase iii phase checks certificate 
component cipher phase iii follows compound message phase follows 
alternatives may discerned practice length certificate 
mutually exclusive treatment phase iii simply requires certificate compound message 
designers implementors protocol omit state check introduces ambiguity specification 
incidentally recall certificate cipher agent check internal structure chapter 
verifying smart card protocol encryption key known smart card 
phase iv rules modelling phase iv protocol 
phase sees responder forward clear text message received network smart card provided card legally usable sr 
smart card issues fresh nonce computes pair initiator sr evs shouprubin card gets agent nonce na set evs inputs card agent nonce na evs shouprubin sr evs shouprubin card nonce nb evs key sesk nb pairk evs inputs card agent nonce na set evs outputs card nonce nb key sesk nb pairk crypt pairk nonce na nonce nb crypt pairk nonce nb evs shouprubin modelling shoup rubin phase iv responder uses components produce session key 
nonce fresh session key fresh 
card outputs nonce session key certificates sr 
certificate establishes association initiator nonce responder inspected initiator card phase vi 
certificate retained responder certain obtaining network final phase 
phase rules modelling phase protocol 
responder obtains card nonce followed key certificates prepares sending nonce certificate initiator sr 
recall having previously quoted initiator identity card trusting card output refer specific input 
note components nonce card output seen unique certificate inviting ambiguity discussed 

modelling shoup rubin sr evs shouprubin inputs card agent nonce na set evs outputs card nonce nb key cert cert set evs says nonce nb cert evs shouprubin phase vi modelling shoup rubin phase rules modelling phase vi protocol 
scenario returns initiator 
queries legally usable card verifies taken hold messages containing nonce certificate 
takes trust nonce pk pairkey sr evs shouprubin card says server agent agent set evs gets nonce pk cert set evs outputs card nonce na cert set evs gets nonce nb cert set evs cert inputs card agent nonce na nonce nb nonce pk cert cert cert evs shouprubin sr evs shouprubin card inputs card agent nonce na nonce nb nonce pairkey crypt shrk nonce pairkey agent crypt pairkey nonce na nonce nb crypt card nonce na set evs outputs card key sesk nb pairk crypt pairk nonce nb evs shouprubin modelling shoup rubin phase vi cert certificate 
recalls having obtained smart card nonce na certificate compound message signifies nonce issued acting initiator 
treats nb responder nonce cert certificate na nb 
feeds components smart card sr 
card checks received components correct form chapter 
verifying smart card protocol computes pair pairkey produces session key certificate responder nonce sr 
phase vii rules modelling phase vii protocol 
reception cryptographic key certificate smart card initiator forwards certificate responder 
sr evs shouprubin says server agent agent set evs outputs card key cert set evs says cert evs shouprubin threats modelling shoup rubin phase vii addition legal behaviour described spy may act illegally 
observes traffic trace extracts message components builds possible fake messages send network input illegally usable cards 
modelled rule fake drawn 
fake shouprubin card synth analz knows spy says spy inputs spy card shouprubin modelling shoup rubin threats messages assume algorithm cards compute session keys publicly known 
spy know relevant components session key able compute key 
allow paulson strategy tls protocol extending definition synth complicate mechanisation process 
spy obtains nonce pair note corresponding session key rule forge acquiring knowledge 
pair sent network merely encryption keys known initially definition initstate 

modelling shoup rubin forge shouprubin nonce nb analz knows spy key pairk knows spy notes spy key sesk nb pairk shouprubin modelling shoup rubin threats session keys means agents smart cards assumed secure model extended allow spy obtain outputs illegally usable cards 
template introduce rule card output 
rule sr fake built sr analogous rules sr fake built sr sr fake built sr needed omitted 
sr fake evs shouprubin card nonce na evs inputs spy card agent set evs outputs card spy nonce na crypt card nonce na evs shouprubin modelling shoup rubin threats card outputs accidents complete model allowing accidents breaches security session keys 
typically done single rule seen ban kerberos rules leaking different kinds session keys shouprubin outputs card nonce nb key cert crypt pairk nonce nb set notes spy key nonce nb agent agent shouprubin shouprubin outputs card key crypt pairk nonce nb set notes spy key nonce nb agent agent shouprubin modelling shoup rubin accidents chapter 
verifying smart card protocol seen kerberos iv 
shoup rubin requires peers handle session key respectively phases iv vi 
spy chance discover session key 
worst case discover nonce compute key identity peers 
spy learn pair accident agent sees 
definition initstate know initially exploiting relevant cloned cards 
verifying shoup rubin guarantees proved smart card protocol may general expressed viewpoint smart cards helping optimise hardware software design 
section discusses established shoup rubin 
note guarantee requires inspecting form certificate may useful cards useful agents decipher certificates know long term keys 
minimal trust includes certain cards usable spy 
reliability theorems show model expected smart cards messages crucially lack explicitness 
suitable regularity lemmas expressed kinds long term keys employed protocol 
authenticity argument yields single guarantee card belongs protocol initiator unicity argument provide guarantees initiator responder 
confidentiality weakened mentioned lack explicitness goals authentication key distribution 
reliability shoup rubin model model server functions reliably theorem 
theorem useful theorem theorem 
authenticity argument message nonce pk cert extremely weak 
receive message guaranteed instance message server sent message compound inspect form certificate 
theorem 
evs contains says server nonce pk cert 
verifying shoup rubin exists pk pairkey cert crypt shrk nonce pairkey agent guarantees concern smart cards allowed protocol outputs produce inputs friendly agents send 
smart cards friendly agent queries smart card receives message card belong agent legally usable theorem 
signifies friendly agent card legally required 
theorem 
spy evs contains inputs outputs card card spy act legally illegally 
fact spy uses smart card card spy card legally usable agent card illegally usable theorem 
spy card illegally usable agent mentioned theorem certainly differs spy 
theorem 
evs contains inputs spy outputs spy card spy card spy card card chapter 
verifying smart card protocol outputs smart cards establish model smart cards reliably categories guarantees proved outputs events 
category states cards give correct outputs fed expected inputs cards spy unlimited resources 
case step protocol theorem steps similar omitted 
theorem 
evs contains outputs card key sesk nb pairk crypt pairk nonce nb exists na evs contains inputs card agent nonce na nonce nb nonce pairkey crypt shrk nonce pairkey agent crypt pairk nonce na nonce nb crypt card nonce na category reliability theorems states cards cpus correctly 
specific output form component tracked 
guarantee established instance message theorem 
length certificate checked protocol ambiguity encountered 
recall event outputs models reception theorem applicable theorem 
evs contains outputs card nonce na cert cert compound cert crypt card nonce na analogous considerations apply message 
reception output guarantee form peer nonce na theorem 
existential form assertion tells receives session key message inform peer key 
violates known explicitness principle unknown time design message say 
verifying shoup rubin means 
interpretation message depend content 
underlying transport protocol reveal peer identity 
uses session key wrong peer consequences disastrous provided key remains confidential 
lack explicitness weaken confidentiality authentication key distribution guarantees accomplished protocol discussed sequel 
theorem 
evs contains outputs card nonce nb key kab cert cert exist na kab sesk nb pairk cert crypt pairk nonce na nonce nb cert crypt pairk nonce nb cards cpus reliable producing instance message theorem 
existential form assertion reveals lack explicitness protocol design 
receives session key infer context identity peer key 
task entirely heuristic card give outputs wrong order 
likewise nonce associated key explicit message 
theorem 
evs contains outputs card key kab cert exist nb kab sesk nb pairk cert crypt pairk nonce nb theorem shows step binds form session key card creates associates session key certificate 
inspectable structure derived corollary vice versa 
corollary 
evs contains outputs card key sesk nb pairk cert cert crypt pairk nonce nb chapter 
verifying smart card protocol inputs smart cards analogous categories guarantees established inputs events 
friendly agents legally usable smart cards legal manner 
friendly agents produce inputs origin documented 
example assume agent queries card step protocol theorem card belongs quoting agent prove initiated session received components query network card means suitable events theorem 
theorem 
spy evs contains inputs agent nonce na nonce nb nonce pk cert cert cert evs contains says server agent agent gets nonce pk cert gets nonce nb cert outputs nonce na cert event highlights intention communicate remaining events mentions assured feeding card components meant session gets events mentioned identity reliable spy tamper compound messages coming network 
outputs event mention reliably takes place secure means fails 
theorem get output card uses correct components input 
similar theorems regard queries smart cards respectively steps protocol 
form inputs created steps protocol 
step complicated 
input exposed network risks certificate produced earlier card form derived theorem signifying agents card correctly 
theorem 
evs contains 
verifying shoup rubin inputs card agent nonce na nonce nb nonce pk cert cert cert cert crypt card nonce na note guarantee applies spy card 
reception message card determine instance message looking cleartext part 
card inspect carefully second third certificates fake 
form fact provable model 
having proved integrity third certificate may suggest superfluous design card avoid checking 
agent insert fake nonce second component message inspecting third certificate detect 
model friendly agents act legally 
regularity protocol sends long term keys network spy knows protocol begins 
spy discover card key card owner key cloning card see definition initstate 
key compute pair meant card owner 
lemma 
lemma 
lemma 
key shrk analz knows spy evs card cloned key analz knows spy evs cloned key pairk analz knows spy evs card cloned authenticity proof scripts theorems discussed section may appendix shoup rubin certificates sealed long term keys agents get authenticity guarantees 
chapter 
verifying smart card protocol long term keys stored smart cards general authenticity argument directed smart cards possibly helping optimise design 
shoup rubin inputs smart card encrypted certificates step 
develop corresponding authenticity argument subsidiary authenticity lemmas directly applicable agents cards 
incidentally assumption secure means follows card receives certificate part input trace evs definition knows imply certificate network traffic parts knows spy evs 
pairkey server issues certificate verifies 
certificate traffic prove originated server regularity lemma applicable 
peer card cloned certificate authentic lemma 
stage form pairkey may specified theorem 
lemma 
card cloned evs crypt shrk nonce pk agent parts knows spy evs evs contains says server nonce pk crypt shrk nonce pk agent verify formally certificate associates nonces built step lemma 
certificate sealed corresponding pair investigating origin requires appeal regularity lemma prescribes card cloned 
stronger assumption needed card solve case sr fake card illegally usable output spy 
lemma 
card illegally usable evs crypt pairk nonce na nonce nb parts knows spy evs evs contains outputs card nonce nb key sesk nb pairk crypt pairk nonce na nonce nb crypt pairk nonce nb message ends certificate verifies nonce nb ab prove theorem omitted identical theorem 
verifying shoup rubin certificate considered assertion scope existentially quantified nonce na 
certificate output card message 
proving result lemma requires spy order solve case sr corresponding event introduce certificate traffic card illegally usable solve case sr fake 
lemma 
spy cards illegally usable evs crypt pairk nonce nb parts knows spy evs evs contains outputs card key sesk nb pairk crypt pairk nonce nb authenticity lemmas serve prove authenticity theorem applicable card theorem 
theorem include assumptions agents cards required lemmas 
reception message card inspect certificates advised theorem 
certificate expected form theorem lemma prove event assertion message received components appeared traffic 
similarly second certificate expected theorem lemma prove second event 
third certificate need inspected provable integrity theorem justifies third event assertion 
reasoning isabelle command applies theorem necessary authenticity lemma 
theorem 
spy card cloned card illegally usable evs contains inputs card agent nonce na nonce nb nonce pk crypt shrk nonce pk agent crypt pairk nonce na nonce nb cert evs contains says server nonce pk crypt shrk nonce pk agent outputs card nonce nb key sesk nb pairk crypt pairk nonce na nonce nb crypt pairk nonce nb outputs card nonce na cert chapter 
verifying smart card protocol authenticity crucial message components investigated fashion certificates 
consider authenticity 
server entitled issue pairkey belong initial knowledge spy card cloned 
example suppose card cloned 
apparently enforce pairkey traffic issued server 
attempting prove evs cert evs contains pairkey parts knows spy evs says server nonce pairkey cert leaves subgoal arising case base card cloned pairkey pairkey card cloned card cloned false derive pairkey implemented terms exclusive operator collision free 
subgoal fact falsified may exist pairs distinct agents satisfy premises 
proof attempt teaches spy exploit collisions suffered exclusive operator forge pairkey knowing original components 
probability happening influenced redundancy introduced encryption function length ciphers 
examine authenticity session key 
crucial message component sent cards agents network 
despite spy forge forge obtain card peers sr sr learn illegally usable cards sr fake sr fake 
assumptions prevent circumstances 
example responder card illegally usable cloned session key forged lemma 
session key appears traffic peers necessarily leaked accident trace recorded corresponding oops event lemma 
fact authenticity emphasises conditions session key traffic authentic spy fact introduced 
fundamental assess form session key confidentiality 

verifying shoup rubin lemma 
spy cards illegally usable evs key sesk nb pairk parts knows spy evs evs contains notes spy key sesk nb pairk nonce nb agent agent proving authenticity lemmas requires common strategy simpler paulson authenticity theorems traditional protocols 
strategy shoup rubin generalised straightforwardly smart card protocol 

apply induction 

lemma concerns certificate sealed shared key simplify case fake lemma certificate sealed card key simplify case fake lemma certificate sealed pair simplify case fake lemma session key apply parts case forge simplify lemma 

solve case fake standard tactic 

apply theorems assessing reliability cards functioning follows theorem case sr theorem cases sr theorem case sr variant theorem binds form certificate form session key case 

simplify remaining cases 
unicity shoup rubin requires card build fresh session key message 
key bound uniquely remaining components message theorem 
proving result induction simplification subgoals remain sr sr fake 
chapter 
verifying smart card protocol easily solvable forces spy card illegally impossible 
case solved freshness session key appear 
message contains fresh nonce variant theorem may proved nonce pivot 
theorem 
evs contains outputs card nonce nb key kab cert cert outputs card nonce nb key kab cert cert nb nb cert cert cert cert similar theorem omitted holds output step exploiting freshness nonce 
surprisingly holds output message theorem card uses fresh components occasion 
corollary supplies 
specific session key appears form corresponding certificate assessed key stand different certificates 
strategy solves subgoal sr sr fake terminated routinely 
theorem 
evs contains outputs card key kab cert outputs card key kab cert cert cert unicity theorems may teach agents lot 
example real world receives session key different instances message may suspect wrong happened 
having violated theorem scenario due problems lie outside model ranging malfunction card spy break agent card 
theorem provides equivalent information happens receive session key message theorem violated 
scenario model alarm cards cpus function correctly card compute fresh key 

verifying shoup rubin matter fact guarantee may designed assist circumstance 
reception output commencing nonce assured corresponding event unique theorem 
expanding definition predicate cases sr sr solved freshness nonce 
result applies output card step 
similar theorem established step involve fresh components 
theorem 
evs contains outputs card nonce nb rest unique outputs card nonce nb rest evs confidentiality confidentiality easily obtained 
specific pairkey issued server components forged pairkey proved confidential weakness discovered authenticity argument 
straightforward notice messages nonce remain confidential 
contrary regularity lemmas may viewed non trivial confidentiality guarantees 
applying analz parts authenticity theorem obtain guarantee session key confidentiality 
session key forged leaked accident confidential theorem 
unfortunately theorem useful agents structure session key inspected 
theorem 
spy cards illegally usable evs contain notes spy key sesk nb pairk nonce nb agent agent key sesk nb pairk analz knows spy evs result strengthened sufficiently discovered theorems session key confidentiality applied peers minimal trust due lack explicitness affects chapter 
verifying smart card protocol protocol steps 
follows shoup rubin protocol weak confidentiality guarantees peers design slightly modified see 
guarantees applied smart cards minimal trust general significant outcome smart card protocol 
follow paulson general strategy verifying confidentiality 
proof scripts resulting theorems may appendix necessary simplification law analz session key compromise theorem fairly easy obtain shoup rubin sends session keys network 
confidentiality argument protocol responder develop event verify card sending message contains session key step protocol 
event formalising step outputs card nonce nb key kab cert cert includes certificates cert cert inspect sealed specific long term keys agent knows long term keys 
attempted prove kab confidential trace evs contains oops event leaking kab contain mentioned event 
card assumed cloned spy know pairk agent able forge session key rule forge 
proof leaves subgoals unsolved respectively arising cases sr sr fake 
inspection teaches peer spy obtain copy kab smart card 
subgoal shows peer card illegally usable regardless identity peer spy able card compute kab 
protocol requires card issue new session key step peer fact computes copy key available components step 
assumptions necessary peer card message obtained state identity peer 
signifies obtain explicit information peer session key violates known explicitness principle due abadi needham identity principal essential meaning message prudent mention principal name explicitly message 
inspect certificates peer explicit relevant assumptions stated theorem proved 

verifying shoup rubin theorem 
spy card illegally usable card cloned evs contains outputs card nonce nb key kab cert crypt pairk nonce nb contain notes spy key kab nonce nb agent agent key kab analz knows spy evs viewpoint trusting peer malicious card malicious entity indispensable 
trusting key leaked accident 
assumptions constitute minimal trust 
important verify main event theorem occurs inspect certificate 
apply theorem 
shoup rubin analysis provable security asserts analogous property requiring peers cards may interpreted cloned approach 
treatment highlight lack explicitness failing investigate property fact useful peers 
similar considerations arise reasoning viewpoint attempt prove confidentiality assumption event formalising step outputs card key kab cert occurs leaving subgoals arising sr sr fake unsolved 
highlight communicating spy agent card illegally usable 
matter fact step fails express peer 
previous theorem proved form cert explicit resulting guarantee applied card theorem 
theorem 
spy cards illegally usable evs contains outputs card key kab crypt pairk nonce nb contain chapter 
verifying smart card protocol notes spy key kab nonce nb agent agent key kab analz knows spy evs analysis provable security account weakness 
stress theorems applicable smart cards reveal lack explicitness verification principle goal availability 
authentication lack explicitness affects messages weakens goals authentication 
card obtains useful guarantee detect certain components wrong peer 
phase terminates role protocol 
peer obtains session key message identity remains unspecified certificate inspected 
certificate fake induction proves appeared instance message concerns theorem 
appeal theorem significant card inspect certificate 
card issues session key guaranteed card network card pair participating session proof observes event assumption implies certificate na nb appears ab traffic na applies lemma 
theorem 
card illegally usable evs contains outputs card key kab crypt pairk nonce nb na evs contains outputs card nonce nb key kab crypt pairk nonce na nonce nb crypt pairk nonce nb result may interpreted weak agreement card cards certainly know components outputs result may viewed non injective agreement card kab 
expressing formally requires extending function knows 
verifying shoup rubin smart cards may little significance due limited memory cards 
relevant authentication guarantee establish active creates session key 
protocol may receive network certificate nonce 
provided lemma applicable card proved sent suitable instance message establishes card presence card intention communicate theorem 
theorem 
spy cards illegally usable evs contains gets crypt pairk nonce nb evs contains outputs card key sesk nb pairk crypt pairk nonce nb theorem useful 
answer agent inspect encrypted certificate 
practice obtains information sender certificate peer remains unknown 
observing certificate originally created message help message state peer see theorem 
possible solution verified concluding protocol additional steps forwarding certificate card card responding identity 
card right pair decrypt certificate identifying adding explicitness message simpler fix demonstrated making guarantee available card necessarily requires additional steps 
key distribution shoup rubin protocol achieve goal key distribution sense peer obtains evidence shares session key 
due mentioned lack explicitness 
card informed session key known applying definition knows theorem yields card computes session key key known theorem profit result 
note guarantee prevent spy 
chapter 
verifying smart card protocol theorem 
card illegally usable evs contains outputs card key kab crypt pairk nonce nb key kab analz knows evs attempt design corresponding guarantee session key obtained message 
theorem receives message protocol infers obtained session key 
events correlated order assure peers hold key 
done inspecting certificates message explicit 
theorem specifies form session key output card theorem 
theorem 
spy cards illegally usable evs contains outputs card nonce nb key kab cert crypt pairk nonce nb gets crypt pairk nonce nb key kab analz knows evs stronger result envisaged exists protocol message binds session key peers 
inspect certificates message card inspect message 
answers negative theorem turns applicable card poor outcome protocol 
verifying upgraded shoup rubin omitting name message public key needham schroeder protocol led known lowe attack 
public key cryptography attempted enforce confidentiality nonces spy intercept messages interleaving sessions learn important nonce violate authentication initiator responder 
shoup rubin secure contexts agents smart cards prevent 
cards data buses reliable 
verifying upgraded shoup rubin lack explicitness affects cards outputs agents distinguish protocol session single output belongs 
abadi needham demonstrate lack explicitness may crucially affect interpretation message names relevant message deduced data encryption keys applied 
information deduced omission blunder serious consequences 
mentioned message shoup rubin inform identity session key state peers ciphers decrypted agents 
message inform identity 
message quotes nonce nb build session key message fails 
components learnt underlying transport protocol 
reception instance message agent derive complete form instance message sent session 
messages quote identity respective intended peer 
argued cards data buses reliable calling agent store identity peer card returned associate session key just received peer 
messages violate explicitness principles mentioned chapter 
shown weaken protocol goals extra assumption reliable cards data buses 
considerations suggest upgrading messages components underlined leaving rest protocol unaltered 
straightforward upgrade formal protocol model accordingly 

cb nb kab na nb ab nb ab 
ca nb kab nb ab upgrading shoup rubin protocol new model theorems discussed obtain slightly modified assertions crucially assumptions inspect ciphers 
assumptions verifiable agents signifying upgraded protocol guarantees available 
example theorem enforced event outputs card agent nonce nb key kab cert chapter 
verifying smart card protocol assertion theorem stripped existential learns peer session key theorem 
existential constrains form certificates knowledge significantly affected 
theorem evs contains outputs card nonce nb agent key kab cert cert kab sesk nb pairk cert crypt pairk nonce nb exists na cert crypt pairk nonce na nonce nb similarly proving theorem event outputs card agent nonce nb key kab cert avoids existential quantifiers assertion nb bound 
second event enforced theorem obtains extra component rest authenticity argument remains unaltered 
unicity results continue hold 
example theorem cope additional components theorem 
theorem evs contains outputs card agent nonce nb key kab cert outputs card agent nonce nb key kab cert nb nb cert cert theorem gets simpler main assumption outputs card nonce nb agent key kab cert cert verifiable theorem rests outputs card agent nonce nb key kab cert 
verifying upgraded shoup rubin consequence peers able decide minimal level trust session key obtain confidential 
authentication theorems strengthened 
agent informed card network card intended communicate theorem 
agent verify receiving card message components agent name nonce key cipher 
theorem specific form cert enrich knowledge substantially 
theorem card illegally usable evs contains outputs card agent nonce nb key kab cert cert evs contains outputs card nonce nb agent key kab cert cert result may interpreted non injective agreement card card kab 
theorem theorem reformulated theorem applicable check reception network cipher previously obtained card 
theorem spy cards illegally usable evs contains outputs card nonce nb agent key kab cert cert gets cert evs contains outputs card agent nonce nb key kab cert note result applicable card 
expresses non injective agreement card kab 
theorem enforced assumptions theorem applicable theorem 
theorem card illegally usable evs contains outputs card agent nonce nb key kab cert key kab analz knows evs similarly assertion theorem proved assumptions theorem useful resulting theorem theorem signify upgraded protocol achieves goal key distribution 
chapter 
verifying smart card protocol chapter summary research dissertation drawn discussed 
treatment concludes statistics ideas 
establishing secure communication sessions remote computers vital 
security context may signify variety goals depend application domain 
enforcing daunting 
practical experience informal claims protocol security formal ones 
consequence computer practitioners highly reluctant entering personal data network cryptographic protocol provided 
main argument dissertation formal methods may substantially help verify protocol achieves goals authenticity unicity confidentiality authentication key distribution 
conduct argument extending paulson inductive approach way scales real world protocols 
achieve full mechanisation protocols ban kerberos kerberos iv shoup rubin 
requires modelling timestamps second necessitates distinction different kinds session keys third necessary account smart cards 
treatment confirms strengthens importance explicitness designing protocols supports new principle goal availability met exist suitable guarantees assuring peers protocol achieves goals 
violating principle raises risk attacks case kerberos iv crucial confidentiality guarantee available initiator responder 
argued explicitness principles con chapter 

example identity principal essential meaning message contrast investigating goal availability simple requires viewing existing formal guarantees account agents knowledge 
believe general checking goal availability may pinpoint unknown lack explicitness demonstrated shoup rubin protocol 
summary chapter presents state art reasoning cryptographic protocols 
complexity formal approaches obtain guarantee influence relevance guarantee 
contrary complex approach reduce importance eventual guarantee making obscure 
guarantees easy grasp may necessitate careful interpretation 
chapter outlines original inductive approach verifying cryptographic protocols due paulson 
accounting informally malicious entity belief logics approach clearly defines abilities model spy 
paulson approach responds unbounded models limited size protocol models analysed state enumeration techniques 
approach mechanised generic theorem prover isabelle verifies proof steps performed humans opposed provable security approach theoretical reasoning solely carried 
modifications extensions developed inductive approach described subsequent chapters outcomes 
chapter discusses protocol goals prove formally related proof strategies 
design reliability theorems assessing formal protocol represents real protocol faithfully 
develop stronger unicity theorems existing ones state certain events occur 
existing theorems useful show goals integrity authenticity equivalent 
goal confidentiality reviewed 
furthermore explain treat goals authentication key distribution approach 
build machinery reason goals chapter show strong form authentication equivalent key distribution 

summary concept minimal trust principle goal availability explained 
guarantees enforcing protocol goal established assumptions protocol peers verify minimal trust say protocol goal available peers protocol conforms principle goal availability regard goal 
chapter describes extend inductive approach timestamps 
formalisation time carried simple fashion exploiting order elements trace 
discrete view time current time trace may length 
presupposes events occur time protocol model extends traces single event time 
extensions ban kerberos protocol timestamps mechanised 
proven goals compared obtained ban logic confidentiality key distribution 
chapter contains full mechanisation kerberos iv 
protocol model quickly obtained existing formal specification asms obtained original informal specification protocol 
interesting feature kerberos iv authkeys session keys issued phase protocol encrypt session keys issued second phase 
check protocol conforms principle goal availability 
designing confidentiality guarantee protocol responder discover trust certain conditions pertaining protocol phase taken part 
basis observation point attack spy exploits certain lifetime agent issued realising 
prove adding simple temporal check functioning trusted servers prevent attack 
considerations unknown existing analyses protocol 
chapter concentrates knowledge agents derive handling protocol messages 
fundamental reason formally authentication key distribution 
develop approaches 
rests inspection trace pinpoint messages agent creates 
creation message implies knowledge components 
chapter 
approach released distribution isabelle introduces event message reception defines agents knowledge terms messages agent sends receives 
definition agents knowledge extends replaces existing notion spy knowledge 
approaches demonstrated proving authentication key distribution ban kerberos kerberos iv accomplish equivalent results 
approach message reception successfully verify key distribution variant otway rees protocol 
trace inspection attraction investigating temporal requisites goal authentication indispensable compare outcomes timestamps nonces 
deduce combination approaches yield best results argue message reception elegant readable account realistic scenarios 
chapter tailors inductive approach analysis protocols smart cards 
protocols explicitly assume means agent card secure rest 
account cases simple variations definition agents knowledge introduce suitable events formalise interaction agents cards 
formalise set smart cards spy got hold discovering pins 
set smart cards formalises managed clone discovering internal secrets 
allow spy exploit cards 
purpose rule protocol model formalising spy illegal operations extended 
case means agents cards assumed secure new rule added time smart card sends output 
new rules allow spy obtain outputs cards illegally necessarily complicate proofs 
chapter demonstrates approach developed previous chapter shoup rubin protocol smart cards 
protocol significant case study designers analysed provable security approach subsequently implemented 
treatment protocol designers difficult derive compact view protocol 
case implementors helps significantly general long informal specifications major obstacles formal analysis face example 
statistics modelling set protocol 
proofs highlight protocol steps lack explicitness peer knows associate session key received card 
weakens goals confidentiality authentication key distribution achieved protocol 
agents smart cards decipher exchanged ciphers 
consequence viewpoint smart cards mentioned lack explicitness affect protocol goals cards apply corresponding guarantees 
process verifying protocol conforms principle goal availability lack explicitness 
statistics runtimes reported measured mhz intel pentium iii 
full proof script ban kerberos executes seconds approach agents knowledge trace inspection 
runtime decreases seconds model allows message reception corresponding formalisation agents knowledge 
proof runtime kerberos iv seconds performing trace inspection seconds including message reception 
runtimes remain refine operation second trusted server order prevent attack 
runtime full proof script shoup rubin seconds 
remains practically upgrade protocol adding explicitness 
proof scripts different protocols compared long contain guarantees considered analogous 
scripts ban kerberos kerberos iv shoup rubin feature 
kerberos iv complex protocol ban kerberos 
considering scripts protocols appears complex protocol analysis significant advantages terms runtime deriving simpler modelling agents knowledge 
shoup rubin employs messages objects smart cards events kerberos iv 
expected proof script longer 
turned wrong complete script kerberos iv exceeds lines third longer shoup rubin chapter 
requires approximately minute execute 
confidentiality argument complex kerberos iv due protocol encryption 
complexity verification protocol due complexity ciphers encompassed protocol translates complex reasoning analz operator features 
mainly focuses verifying new hierarchies protocols new protocol goals 
non repudiation protocols considered 
aim solving disputes peers pretend sent received certain messages 
expect approach extended message reception easily scale proving goals non repudiation origin non repudiation receipt 
delegation important issue modern 
agents may want delegate rights perform certain tasks somebody may want delegate responsibility tasks 
operational standpoint proving form delegation requires showing recipient delegation received certain credentials 
commerce protocols aim new goals anonymity accountability 
anonymity achieved agent completes protocol session identity disclosed 
order prove goal agent names longer requires simple modification definition function synth show initiator identity belong knowledge agent derive observation traffic 
proofs expected complicated involve frequent evaluations analz operator 
accountability may viewed form non repudiation involves establishing completion protocol sessions certain events representing important steps financial transaction taken place 
non denial service met protocol initiator assured certain services granted 
operational point view 
goal corresponds establishing certain events take place basis 
inductive definition protocol constrain rules fire force events occur expect verifying goal require substantial modifications basics approach 
chapter 
appendix verifying kerberos iv scripts session key compromise theorems proven kerberos iv 
script lemma 
reli reliability theorem 
goal authkeys evs un range shrk evs kerberos 
akcryptsk evs asm full simp tac simpset akcryptsk def blast tac claset addds reli qed akcryptsk script lemma 
uniq tgs unicity guarantee issued tgs 
goal akcryptsk authk servk evs authk evs kerberos akcryptsk servk evs asm full simp tac simpset akcryptsk def blast tac claset addds uniq tgs qed akcryptsk script lemma 
reli reliability theorem 
goal servk authkeys evs servk range shrk evs kerberos akcryptsk servk evs asm full simp tac simpset akcryptsk def blast tac claset addds reli qed akcryptsk appendix verifying kerberos iv script lemma 
obtained lemma holds sets keys analz insert set key rewrite analz simpset specialised simpset evaluation expressions containing analz 
goal evs kerberos range shrk akcryptsk evs key analz insert key spies evs key analz spies evs asm full simp tac analz simpset analz insert set key rewrite qed analz insert key rewrite script lemma analz insert set key rewrite 
applied theorems omitted 
goal evs kerberos kk 
kk compl range shrk kk 
akcryptsk evs key analz key kk un spies evs kk key analz spies evs kerberos induct forward tac oops range spies forward tac oops range spies analz sees tac repeat alli repeat analz rewrite lemma rs impi asm simp tac analz simpset akcryptsk says shrk akcryptsk fresh authk akcryptsk fresh servk akcryptsk akcryptsk spy analz shrk fake spy analz tac blast tac blast tac claset spies authk akcryptsk br impi case tac key servk analz spies evs asm simp tac simpset analz insert eq un upper rs analz mono case tac akcryptsk servk evs asm simp tac analz image ss blast tac claset servk akcryptsk rsn rev note spies alle level case tac key servk analz spies forward tac analz mono kk assume tac assume tac asm simp tac clarify tac forward tac analz cut assume tac blast tac claset addds analz cut analz mono inst tac spec inst tac insert servk kk spec forward tac reli assume tac clarify tac forward tac says imp spies rs parts inj rs parts body rs parts snd rs parts snd rs parts snd inst tac servk akcryptsk assume tac assume tac assume tac asm full simp tac blast tac claset addds analz mono level inst tac spec inst tac insert authk kk spec asm full simp tac case tac akcryptsk authk blast tac claset akcryptsk analz insert blast tac claset addds analz mono qed spec mp analz insert set key rewrite appendix verifying kerberos iv script theorem 
goal authkeys evs un range shrk range shrk evs kerberos key analz insert key spies evs key analz spies evs forward tac akcryptsk assume tac asm full simp tac analz simpset analz insert key rewrite qed sesk compromise script theorem 
goal akcryptsk authk servk evs authk evs kerberos key servk analz insert key spies evs servk key servk analz spies evs forward tac akcryptsk assume tac asm full simp tac analz simpset analz insert key rewrite qed sesk compromise script theorem 
goal servk authkeys evs servk range shrk evs kerberos key analz insert key servk spies evs servkey key analz spies evs forward tac akcryptsk assume tac asm full simp tac analz simpset analz insert key rewrite qed sesk compromise appendix proving issues property scripts obtaining theorem conveys agreement session key 
script theorem 
script bk help bk auth authenticity theorem auth version authentication theorem confidentiality assumption relaxed theorem see 
goal says ticket crypt agent number ta set evs key analz spies evs spy evs bankerberos issues crypt agent number ta evs case tac bad forward tac bk help assume tac assume tac assume tac bd says imp spies rs analz inj rs analz fst fast tac claset addds analz simpset bad simp tac simpset issues def br exi br ba appendix proving issues property simp tac rev mp rev mp bankerberos induct forward tac bk parts spies repeat analz mono contra tac asm simp tac simpset conj distrib bk clarify tac asm full simp tac simpset takewhile tail bad tac blast tac claset addds bk auth parts spies takewhile mono parts spies evs auth spies qed issues bk script kb help bk auth authenticity theorem reli reliability theorem 
goal says ticket crypt agent number ta set evs key analz spies evs spy evs bankerberos ex tk 
ticket crypt shrk number tk agent key rev mp rev mp bankerberos induct forward tac bk parts spies repeat analz mono contra tac asm simp tac simpset conj distrib kb clarify tac bad tac blast tac claset addds bk auth rs reli spies qed kb help script theorem 
goal crypt shrk number tk agent key parts spies evs crypt agent number ta parts spies evs key analz spies evs spy bad evs bankerberos issued crypt agent number ta evs blast tac claset addds auth issues bk script auth bk auth authenticity theorem 
goal crypt agent number ta parts spies evs crypt shrk number tk agent key parts spies evs key analz spies evs bad evs bankerberos says crypt shrk number tk agent key crypt agent number ta set evs blast tac claset bk auth auth lemma qed auth script auth lemma reli variant theorem unicity theorem 
goal bad evs bankerberos key analz spies evs says server crypt shrk number tk agent key set evs crypt agent number ta parts spies evs says crypt agent number ta set evs appendix proving issues property bankerberos induct forward tac reli assume tac forward tac bk parts spies forward tac oops parts spies repeat analz mono contra tac asm simp tac simpset conj distrib fake blast tac bk clarify tac crypt imp asm full simp tac bk clarify tac bad tac blast tac claset addds bk auth qed auth lemma appendix defining agents knowledge inductive definition agents knowledge smart card protocol assumes secure means agents smart cards 
initial knowledge shoup rubin 
primrec server knows long term secrets initstate server initstate server key range shrk un range un range pin un range pairk un nonce range pairkey friendly agents know secrets initstate friend initstate friend spy knows long term secrets deriving cloned cards initstate spy initstate spy key cloned un shrk card cloned un pairk 
card cloned un nonce pairkey 
card cloned card cloned appendix defining agents knowledge primrec knows nil knows initstate knows cons knows ev evs case ev says spy insert knows evs knows evs notes spy bad insert knows evs knows evs gets spy insert knows evs knows evs inputs insert knows evs knows evs outputs insert knows evs knows evs appendix verifying shoup rubin scripts arguments authenticity confidentiality shoup rubin 
tactics applying relevant reliability theorems reli theorem reli theorem reli theorem corollary theorem binds form session key form certificate known reli 
theorem gets imp knows spy rs parts inj rs parts snd says component message received network second component traffic 
val prepare tac sr forward tac reli sr reli sr forward tac reli val parts prepare tac prepare tac sr gets imp knows spy rs parts inj rs parts snd gets imp knows spy rs parts inj rs parts snd reli reli base force tac appendix verifying shoup rubin val analz prepare tac prepare tac sr gets imp knows spy rs analz inj rs analz snd gets imp knows spy rs analz inj rs analz snd repeat eresolve tac asm rl orelse hyp subst tac script authenticity lemma 
goal crypt shrk nonce pk agent parts knows spy evs card cloned evs shouprubin says server nonce pk crypt shrk nonce pk agent set evs rev mp shouprubin induct parts prepare tac asm simp tac fake fake parts insert tac sr fast tac claset simpset sr fast tac claset simpset qed sr cert auth script authenticity lemma 
goal crypt pairk nonce na nonce nb parts knows spy evs card evs shouprubin card nonce nb key sesk nb pairk crypt pairk nonce na nonce nb crypt pairk nonce nb set evs rev mp shouprubin induct parts prepare tac asm simp tac fake fake parts insert tac sr fake clarify tac sr fast tac claset simpset sr fast tac claset simpset qed sr cert auth script authenticity lemma resembles preceding concerns certificate nonce 
goal crypt pairk nonce nb parts knows spy evs card evs shouprubin ex na 
card nonce nb key sesk nb pairk crypt pairk nonce na nonce nb crypt pairk nonce nb set evs rev mp shouprubin induct parts prepare tac asm simp tac fake fake parts insert tac sr blast tac sr fake blast tac sr fast tac claset simpset sr blast tac claset addds sr cert auth inputs imp knows spy rs parts inj knows spy sr fake blast tac claset addds sr cert auth inputs imp knows spy rs parts inj knows spy appendix verifying shoup rubin sr clarify tac asm full simp tac blast tac claset addds sr cert auth sr cert qed sr cert auth script lemma sr cert inp reli reliability theorem 
goal card key crypt pairk nonce nb set evs evs shouprubin ex na 
crypt pairk nonce na nonce nb parts knows spy evs rev mp shouprubin induct parts prepare tac asm simp tac fake fake parts insert tac sr force tac sr fake force tac sr fast tac claset simpset sr blast tac claset addds inputs imp knows spy parts inj inp reli gets imp knows spy knows spy sr fake blast tac claset addds inputs imp knows spy parts inj inp reli gets imp knows spy knows spy sr fast tac claset simpset qed sr cert script authenticity lemma 
goal crypt pairk nonce nb parts knows spy evs card card spy evs shouprubin card key sesk nb pairk crypt pairk nonce nb set evs rev mp shouprubin induct parts prepare tac asm simp tac fake fake parts insert tac sr clarify tac sr fake clarify tac sr fast tac claset simpset sr level clarify tac sr fast tac claset simpset qed sr cert auth script authenticity theorem 
goal inputs card agent nonce na nonce nb nonce pk crypt shrk nonce pk agent crypt pairk nonce na nonce nb cert set evs card cloned card spy evs shouprubin says server nonce pk crypt shrk nonce pk agent set evs card nonce nb key sesk nb pairk crypt pairk nonce na nonce nb appendix verifying shoup rubin crypt pairk nonce nb set evs card nonce na cert set evs blast tac claset addds inp reli gets imp knows spy rs parts inj rs parts snd sr cert auth sr cert auth script authenticity lemma 
goal key sesk nb pairk parts knows spy evs card card spy spy evs shouprubin notes spy key sesk nb pairk nonce nb agent agent set evs rev mp shouprubin induct parts prepare tac asm simp tac fake fake parts insert tac forge fast tac claset addds analz inj simpset sr clarify tac sr fake clarify tac sr fast tac claset addds reli simpset sr clarify tac sr fake clarify tac sr fast tac claset simpset asm full simp tac qed sesk counter auth script confidentiality theorem goal card nonce nb key verifier crypt pairk nonce nb set evs notes spy key nonce nb agent agent set evs card card cloned spy spy evs shouprubin key analz knows spy evs rev mp rev mp shouprubin induct analz prepare tac asm simp tac simpset analz insert eq analz insert pushes split ifs fake spy analz tac forge blast tac claset addds reli parts inj sr blast tac claset reli analz subset parts sr fake fast tac claset addds parts simpset sr fast tac claset addds reli simpset split ifs sr fast tac claset addds reli simpset sr fake clarify tac reli assume tac asm full simp tac sr appendix verifying shoup rubin fast tac claset simpset split ifs blast tac claset reli blast tac claset reli reli qed sesk conf script confidentiality theorem 
goal card key crypt pairk nonce nb set evs notes spy key nonce nb agent agent set evs card card spy spy evs shouprubin key analz knows spy evs rev mp rev mp shouprubin induct analz prepare tac asm simp tac simpset analz insert eq analz insert pushes split ifs fake spy analz tac forge blast tac claset addds reli parts inj sr blast tac claset reli sr fake fast tac claset addds parts simpset sr fast tac claset addds reli simpset split ifs sr br blast tac claset addds reli blast tac claset addds gets imp knows spy rs parts inj inp reli sr cert auth sesk conf knows spy sr fake blast tac claset addds reli sr fast tac claset simpset split ifs blast tac claset reli reli blast tac claset addds qed sesk conf appendix verifying shoup rubin bibliography abadi burrows kaufman lampson 
authentication delegation smart cards 
research report digital systems research center 
abadi gordon 
calculus cryptographic protocols spi calculus 
research report university cambridge computer laboratory 
abadi gordon 
reasoning cryptographic protocols spi calculus 
mazurkiewicz editors proceedings th international conference concurrency theory concur volume lecture notes computer science pages 
springer verlag 
abadi needham 
prudent engineering practice cryptographic protocols 
ieee transactions software engineering january 
martin abadi mark tuttle 
semantics logic authentication 
proceedings th acm symposium principles distributed computing podc pages 
anderson 
cryptosystems fail 
proceedings st acm conference communications computer security ccs pages 
acm press addison wesley 
anderson needham 
programming satan computer 
van leeuwen editor computer science today trends developments volume lecture notes computer science pages 
springer verlag 
anderson kuhn 
low cost attacks tamper resistant devices 
lomas editor proceedings th bibliography international workshop security protocols volume lecture notes computer science pages 
springer verlag 
ateniese steiner tsudik 
authenticated group key agreement friends 
proceedings th acm conference computer communication security ccs pages 
acm press addison wesley 
shiu kai faust rosenthal stillman zhou 
analysis implementation secure electronic mail protocols 
meadows editors proceedings workshop design formal verification security protocols dimacs 
bella 
message reception inductive approach 
research report university cambridge computer laboratory 
bella 
modelling agents knowledge inductively 
proceedings th international workshop security protocols volume lecture notes computer science 
springer verlag 
bella 
modelling security protocols smart cards 
blum lee editors proceedings international workshop cryptographic techniques commerce pages 
city university hong kong 
bella 
inductive verification smart card protocols 
submitted journal computer security 
bella 
lack explicitness strikes back 
proceedings th international workshop security protocols lecture notes computer science 
springer verlag 
press 
bella massacci paulson 
making sense specifications formalization set 
proceedings th international workshop security protocols lecture notes computer science 
springer verlag 
press 
bella paulson 
isabelle prove properties kerberos authentication system 
meadows editors proceedings workshop design formal verification security protocols dimacs 
bibliography bella paulson 
timestamps worth effort 
formal treatment 
research report university cambridge computer laboratory 
bella paulson 
kerberos version iv inductive analysis secrecy goals 

quisquater meadows gollmann editors proceedings th european symposium research computer security esorics volume lecture notes computer science pages 
springer verlag 
bella paulson 
ban kerberos inductive method 
hu vardi editors proceedings international conference computer aided verification cav volume lecture notes computer science pages 
springer verlag 
bella 
formal analysis kerberos authentication system 
journal universal computer science 
bella 
realistic environment crypto protocol analyses asms 
gl editor proceedings th international workshop state machines informatik pages 
bellare rogaway 
entity authentication key distribution 
stinson editor proceedings advances cryptography crypto volume lecture notes computer science 
springer verlag 
bellare rogaway 
provably secure session key distribution party case 
proceedings th acm sigact symposium theory computing stoc pages 
acm press addison wesley 
bird gopal herzberg janson kutten molva jung 
family light weight protocols authentication key distribution 
ieee acm transactions networking february 
meertens 
semantics ban logic 
meadows editors proceedings workshop design formal verification security protocols dimacs 
bibliography rger 
annotated bibliography evolving algebras 
rger editor specification validation methods pages 
oxford university press 
rger 
integrating asms software development life cycle 
journal universal computer science 

hol extension automatically cryptographic protocols 
proceedings th ieee computer security foundations workshop 
ieee computer society press 

automatic formal analyses large commercial protocols 
meadows editors proceedings workshop design formal verification security protocols dimacs 
burrows abadi needham 
logic authentication 
proceedings royal society london 

il boom di internet la di 
della sera page th january 
italian newspaper 
clarke jha 
state space exploration natural deduction style message derivation engine verify security protocols 
gries de roever editors proceedings ifip working conference programming concepts methods 
hall 

delegation responsibilities 
christianson harbison roe editors proceedings th international workshop security protocols volume lecture notes computer science pages 
springer verlag 
dang kemmerer 
astral model checker cryptographic protocol analysis 
meadows editors proceedings workshop design formal verification security protocols dimacs 
denning sacco timestamps key distribution protocols 
communications acm 
dill 
murphi description language verifier 
verify stanford edu dill murphi html 
bibliography 
algebraic properties binary xor verification authentication protocols 
technical report university cambridge computer laboratory 
preparation 
herzog guttman 
strand spaces 
research report mitre 
herzog guttman 
strand spaces security protocol correct 
proceedings th ieee symposium security privacy 
ieee computer society press 
forrester research 
www forrester com 

encoding state machines pvs 
proceedings asm workshop lecture notes computer science 
springer verlag 
press 
gollmann 
mean entity authentication 
proceedings th ieee symposium security privacy pages 
ieee computer society press 
li gong roger needham raphael yahalom 
reasoning belief cryptographic protocols 
proceedings th ieee symposium security privacy pages 
ieee computer society press 
gordon melham 
hol 
cambridge university press 
gurevich 
evolving algebras guide 
rger editor specification validation methods pages 
oxford university press 
harbison 
delegating trust 
christianson harbison roe editors proceedings th international workshop security protocols volume lecture notes computer science pages 
springer verlag 
hastad impagliazzo levin luby 
construction pseudo random generator way function 
manuscript 
earlier version symposium theory computing stoc 
bibliography hoare 
communicating sequential processes 
prentice hall englewood cliffs new jersey 
international organization standardization 
information processing systems open systems interconnection basic model part security architecture 
iso 
honeyman 
smartcard integration kerberos 
proceedings usenix workshop smartcard technology 
honeyman coffman rees wheeler 
implementation provably secure smartcard key distribution protocol 

quisquater schneier editors proceedings rd smart card research advanced application conference 
kahn 

macmillan 

reasoning accountability protocols electronic commerce 
proceedings th ieee symposium security privacy pages 
ieee computer society press 
petitcolas editors 
information hiding techniques steganography digital watermarking 
artech house 
kemmerer meadows millen 
systems cryptographic protocol analyses 
journal cryptology 
kohl neuman 
kerberos network authentication service version 
internet request comment rfc september 
kohl neuman ts evolution kerberos authentication system 
distributed open system pages 
ieee computer society press 
kuhn 
design principles tamper resistant smartcard processors 
proceedings usenix workshop smartcard technology 
leighton micali 
secret key agreement public key cryptography 
stinson editor proceedings advances bibliography cryptography crypto volume lecture notes computer science pages 
springer verlag 
lipmaa 
idea cipher multimedia architectures 
meijer editors proceedings th workshop selected areas cryptography sac volume lecture notes computer science pages 
springer verlag 
lowe 
attack needham schroeder public key authentication protocol 
information processing letters 
lowe 
breaking fixing needham schroeder public key protocol csp fdr 
margaria steffen editors tools algorithms construction analysis systems volume lecture notes computer science pages 
springer verlag 
lowe 
new attacks security protocols 
proceedings th ieee computer security foundations workshop 
ieee computer society press 
lowe 
hierarchy authentication specifications 
proceedings th ieee computer security foundations workshop pages 
ieee computer society press 
lowe 
completeness result model checking security protocols 
proceedings th ieee computer security foundations workshop pages 
ieee computer society press 
lowe roscoe 
csp detect errors tmn protocol 
ieee transactions software engineering 
maher 
fault induction attacks tamper resistance hostile reverse engineering perspective 
editor proceedings financial cryptography volume lecture notes computer science pages 
springer verlag 
mao boyd 
formal analysis security protocols 
proceedings th ieee computer security foundations workshop pages 
ieee computer society press 
bibliography mastercard visa 
set secure electronic transaction specification business description may 
www org set specifications html 
mastercard visa 
set secure electronic transaction specification programmer guide may 
www org set specifications html 
mastercard visa 
set secure electronic transaction specification protocol definition may 
www org set specifications html 
mcmillan 
symbolic model checking 
kluwer academic publisher 
meadows 
formal verification cryptographic protocols survey 
advances cryptology asiacrypt volume lecture notes computer science pages 
springer verlag 
meadows 
nrl protocol analyzer overview 
journal logic programming 
neuman design practical electronic currency internet 
proceedings st acm conference communications computer security ccs pages 
acm press addison wesley 
miller neuman schiller saltzer 
kerberos authentication authorisation system 
technical plan sec 
mit project athena 
milner 
communicating mobile systems calculus 
cambridge university press 
mitchell mitchell stern 
automated analysis cryptographic protocols murphi 
proceedings th ieee symposium security privacy 
ieee computer society press 
molva tsudik van 
authentication key distribution system 
quisquater editors proceedings nd european symposium research computer security esorics bibliography volume lecture notes computer science pages 
springer verlag 
national bureau standards 
data encryption standard january 
federal information processing standards publications fips pub 

needham 
denial service 
proceedings st acm conference communications computer security ccs pages 
acm press addison wesley 
needham schroeder encryption authentication large networks computers 
communications acm 
paulson 
theory shared key needham schroeder protocol 
www informatik tu muenchen de isabelle library hol auth ns shared html 
paulson 
isabelle generic theorem prover volume lecture notes computer science 
springer verlag 
paulson 
mechanized proofs recursive authentication protocol 
proceedings th ieee computer security foundations workshop pages 
ieee computer society press 
paulson 
proving properties security protocols induction 
proceedings th ieee computer security foundations workshop pages 
ieee computer society press 
paulson 
inductive approach verifying cryptographic protocols 
journal computer security 
paulson 
inductive analysis internet protocol tls 
acm transactions computer system security 
press 
paulson 
relations secrets formal analyses yahalom protocol 
journal computer security 
press 
perrig 
efficient collaborative key management protocols secure autonomous group communication 
blum lee editors proceedings international workshop cryptographic techniques commerce pages 
city university hong kong 
bibliography rivest 
winnowing confidentiality encryption 
cryptobytes rsa laboratories 
theory lcs mit edu rivest txt 
rivest shamir adleman 
method obtaining digital signatures public key cryptosystems 
communications acm 
roscoe 
model checking csp 
classical mind essays honour hoare 
ryan 
modelling analysis security protocols 
research proposal defence research agency 
ryan schneider 
attack recursive authentication protocol cautionary tale 
information processing letters 
elsevier science publishers north holland amsterdam 
schneider 
verifying authentication protocols csp 
proceedings th ieee computer security foundations workshop pages 
ieee computer society press 
shoup rubin 
session key distribution smart cards 
maurer editor advances cryptology eurocrypt volume lecture notes computer science pages 
springer verlag 
smith 
luc public key encryption 
dr dobb journal january 
syverson 
taxonomy replay attacks 
proceedings th ieee computer security foundations workshop pages 
ieee computer society press 
jr neuman 
key distribution protocol digital mobile communication systems 
brassard editor proceedings advances cryptography crypto volume lecture notes computer science pages 
springer verlag 
winter 
methodology model checking asm lessons learned flash case study 
proceedings asm bibliography shop lecture notes computer science 
springer verlag 
press 
woo lam 
authentication distributed systems 
computer 

model checking needham schroeder protocol 
rodin stanford edu case studies security 
zhou deng bao 
evolution fair non repudiation ttp 
proceedings th australasian conference information security privacy volume lecture notes computer science pages 
springer verlag 
zhou gollmann 
fair non repudiation protocol 
proceedings th ieee symposium security privacy pages 
ieee computer society press 
