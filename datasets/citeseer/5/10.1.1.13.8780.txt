monad independent dynamic logic hascasl lutz schr oder till mossakowski dept math 
comput 
sci universit bremen germany contact lutz schr oder dept computer science bremen box bremen germany phone fax mail informatik uni bremen de monads recognized moggi elegant device dealing stateful computation functional programming languages :10.1.1.42.1853:10.1.1.42.1853:10.1.1.35.4051
previous introduced hoare calculus partial correctness monadic programs 
done entirely monad independent way 
extend monad independent dynamic logic assuming moderate amount additional infrastructure monad 
dynamic logic expressive hoare calculus particular allows reasoning termination total correctness 
background formalism concepts logic hascasl higher order language functional speci cation programming 
example application develop monad independent hoare total correctness dynamic logic illustrate calculus termination proof dijkstra non deterministic implementation euclid algorithm 
keywords dynamic logic monads algebraic speci cation functional programming casl central concepts modern functional programming encapsulation side ects monads seminal :10.1.1.41.840:10.1.1.41.840
particular state monads emulate imperative programming style functional programming language haskell :10.1.1.42.1853:10.1.1.35.4051
monads particular notion computation model wide range computational ects stateful computations non determinism partiality exceptions input output viewed monadic computations various combinations concepts non deterministic stateful computations 
moggi suggested hoare calculus state monad state interpreted global store :10.1.1.41.840:10.1.1.41.840
generalized monad independent hoare calculus :10.1.1.42.1853
hoare logic general concerned partial correctness allow reasoning termination total correctness 
right framework studying dynamic logic introduced :10.1.1.41.840:10.1.1.41.840
examine infrastructure needed order develop dynamic logic monad independent way show sense instantiated usual monads mentioned 
provide extended example logic program veri cation 
formalism embedded logic hascasl higher order language functional speci cation programming rst order algebraic speci cation language casl 
hascasl internal logic intuitionistic intuitionistic version dynamic logic 
hascasl allows expressing programs expected properties language obtain uni ed interpretation dynamic logic formulas consist programs logical expressions 
extended version :10.1.1.42.1853
related includes pitts evaluation logic di erent semantics de ned pitts moggi respectively :10.1.1.42.1853:10.1.1.35.4051
pitts introduces local semantics terms brations moggi chooses global semantics entirely terms strong monads 
term dynamic logic emphasize approach local give semantics arbitrary monad sense reconciling approaches :10.1.1.42.1853:10.1.1.35.4051
hascasl language hascasl introduced higher order extension casl partial calculus :10.1.1.42.1853:10.1.1.41.840
give brief summary basic hascasl speci cations written mean 
details syntax semantics see :10.1.1.42.1853:10.1.1.41.840
hascasl speci cation determines essentially things signature consisting classes types operations associated axioms operations required satisfy 
basic types introduced means keyword type 
types may parameterized type arguments may write var type type list obtain unary type constructor list built type constructors hascasl xed interpretations product types :10.1.1.42.1853
partial total function types respectively pred predicate types unit type unit particular function types haskell really partial function types 
operator constant type declared op type 
types may contain type variables operators polymorphic style ml 
operators may form higher order terms usual way term variable application tuple abstraction 
terms may axioms formulated shall call external logic 
external logic ers usual logical connectives conjunction negation universal existential quanti ers outermost universal quanti cations may type variables strong existential equality denoted respectively de nedness assertions def feature distinction various equalities related partial functions cf 
detailed discussion 
notation examples largely self explanatory shall refrain listing syntactic details 
important note formulas external logic including external equations regarded terms program abstracted 
partial functions haskell required strict non strict functions emulated means procedural lifting method suitable syntactical sugar provided 
semantics hascasl speci cation class set theoretic intensional henkin models function type need contain set theoretic functions functions yield value input need equal see discussion rationale :10.1.1.42.1853:10.1.1.41.840
desired extensionality models may forced means axiom expressible language 
consequence intensional semantics presence intuitionistic internal logic lives terms 
specify internal equality symbol built syntactical sugar terms allows specifying full set logical operations quanti ers intuitionistic logic carried detail :10.1.1.42.1853:10.1.1.41.840
built syntactical sugar internal logic invoked means keyword internal signi es formulas block understood formulas internal logic 
particular features hascasl internal logic development projections binary products denoted fst snd respectively 
type truth values 
type partial functions unit type truth corresponding de nedness 
projections allow coding conditional terms formula partial term res term de ned equal de ned holds res fst unique element unit type 
means internal logic specify class complete partial orders xed point recursion style holcf :10.1.1.42.1853:10.1.1.35.4051
top syntactical sugar provided allows recursive function de nitions style functional programming indicated keyword program 
similarly junk confusion axioms associated datatypes implicitly coded means internal logic 
monads computations hascasl supports type classes :10.1.1.42.1853
declared form class understood subsets syntactical universe types 
types type variables restricted belong assigned class writing type particular axioms operators may polymorphic classes 
classes may subclasses may generic instances 
attaching polymorphic operators axioms class achieves similar ect haskell type classes 
similar vein add constructor classes hascasl 
interpreted predicates syntactical universe abstracted type expressions called type 
list type classes constructor subclasses types operators axioms may polymorphic constructor classes polymorphism semantically coded collections instances 
typical example constructor class class monads see 
summary hascasl language allows property oriented speci cation functional programming executable hascasl speci cations may easily translated haskell programs 
monads computations basis seminal monads encapsulating side ects modern functional programming languages particular idea central concepts haskell :10.1.1.15.5722:10.1.1.42.1853:10.1.1.41.840:10.1.1.41.840
intuitively monad associates type type ta computations type function side ects takes inputs type returns values type just function type tb 
approach abstracts away particular notions computation store non determinism non termination surprisingly large amount reasoning fact carried independently choice notion 
formally monad category de ned kleisli triple function unit family morphisms ta assigns morphism tb morphism ta tb id ta description equivalent familiar endofunctor unit multiplication 
monad gives rise kleisli category objects functions side ects tb morphisms composite functions just composite denoted order support language nitary operations multi variable contexts see needs technical requirement monad called strong monads computations equipped natural transformation tb called tensorial strength subject certain coherence conditions see equivalent enrichment monad see discussion :10.1.1.42.1853:10.1.1.41.840:10.1.1.41.840
example computationally relevant monads set strength equivalent enrichment monads set strong include stateful computations possible non termination ta :10.1.1.41.840:10.1.1.41.840
xed set states 
denotes partial function type nite non determinism ta denotes nite power set exceptions ta xed set exceptions interactive input ta smallest xed point 
set input values non deterministic stateful computations ta xed set states continuations ta type results 
typical examples monads list monad ta type lists free abelian group monad ta consists expressions form monads sense arbitrary topos natural numbers object suciently strong setting recursive datatypes essentially ambient intuitionistic higher order type theory cf :10.1.1.42.1853
:10.1.1.41.840
topos required partial function types exist see example :10.1.1.41.840
shows speci cation monads hascasl 
example instance type class speci cation state monad shown :10.1.1.42.1853
operations monad functions model monads speci ed automatically strong strength equivalent enrichment 
notation identical haskell unit denoted ret operator denotes notation function 

speci cation basis built sugaring form haskell style notation monadic expressions abbreviates details discussed :10.1.1.42.1853
slight complication concerning axiomatization arises fact partial functions involved 
note second unit law replaced axioms stating said equation holds domain stating possibly having larger domain de nition behaves binding 
ensures standard monads monads computations state monad usual de nition total function cf :10.1.1.42.1853
discussion subsumed leaving essence proposed calculus untouched :10.1.1.42.1853
sake simplicity treatment included mono requirement stating ret injective speci cation 
spec monad class monad type type vars monad type ops 
ret internal forall def ret ret ret ret ret constructor class monads spec state monad type instance st monad vars type internal types st 
forall st st ret speci cation state monad reasoning category equipped strong monad greatly facilitated fact proofs conducted meta language introduced adapt deal partial functions :10.1.1.42.1853:10.1.1.41.840:10.1.1.41.840
priori category require working details speci cation monads induces monad classifying category constructed meta language applicable simply logic obtained axioms :10.1.1.18.7716
crucial features language type operator terms type ta called valued programs computations polymorphic operator ret ta corresponding unit generic approach side effects state binding construct denote haskell style terms form interpreted means tensorial strength kleisli composition see details :10.1.1.41.840:10.1.1.41.840
essentially equivalent notation introduced 
intuitively computes passes results binding associative contain denote nested expressions repeated nestings xn pn somewhat inaccurately denoted form term fragments form called program sequences 
variables appear may omitted notation 
course terms di er names bound variables equal equivalence 
associative law mentioned unit laws stating ret ret de ned ret second laws implies particular ret de ned terms generally formed context xn variables assigned types 
top monad generically de ne control structures loop 
de nitions require general recursion realized hascasl means xed point recursion cpos 
restrict monads allow lifting cpo structure cpo structure type ta computations way monad operations continuous 
laid detail :10.1.1.42.1853
generic approach side ects state discuss monad independent notions program properties side ect freeness determinism logical aspects boolean valued programs ects 
concepts obtain monad independent notion state forms foundation interpretation box diamond operators dynamic logic introduced section 
notions deterministic ect freeness validity formulas ects introduced concepts termination state state new :10.1.1.42.1853
phrase de nitions terms meta language monads xed notation monad associated type constructor 
generic approach side effects state de nition program called side ect free ret ret shorthand context unique element unit type :10.1.1.42.1853
note implies de ned 
side ect free programs expected properties lemma side ect free program provided term de ned 
proof unit law cf 
preceding section ret ret ret proves rst claim 
second claim follows fact side ect freeness amounts ret variable type ret example program side ect free state monad terminates change state non determinism monad possible outcome exception monad terminates normally interactive input monad reads input non deterministic state monad change state possible outcome gets stuck 
program called stateless factors ret just value inserted monad 
example state monad means program changes reads state stateless exists sense :10.1.1.41.840:10.1.1.41.840
stateless programs side ect free vice versa 
want regard programs return truth values formulas side ects modal logic setting 
basic notion need formulas global validity denote explicitly global box de nition term type denotes type internal truth values abbreviates ret read formula internal logic 
generic approach side effects state mp eq app fv pre ret ctr fv fv auxiliary calculus side ect free simpli es ret formula ensures right hand side side ect :10.1.1.42.1853:10.1.1.42.1853:10.1.1.35.4051
note equality symbol de nition formula strong equality 
particular classical case true unde ned 
example monads example satisfaction amounts state monad successful execution initial state yields non determinism monad yields value exception monad yields terminates normally :10.1.1.42.1853:10.1.1.35.4051
interactive input monad value eventually produced combination inputs non deterministic state monad execution initial state yields value order perform proofs logic introduced require auxiliary calculus judgements form intuitively state holds actual formula internal logic idea formulas state dependence outside usual logical rules apply remaining part 
formally abbreviates slightly deviating ret ret degenerate case mono requirement equivalent :10.1.1.42.1853
word warning order equivalent precisely properly weaker 
generic approach side effects state intuition de nition cases semantically equivalent ret monads equivalence holds called simple 
monad rank set signature equations simple equation sides contain variables covers exception monad non determinism monad list monad 
usual state monads simple known equational presentation satisfy variable requirement :10.1.1.18.7716
general ret properly weaker 
free abelian group monad ret 
similarly continuation monad fails simple 
meaning close global semantics moggi modal operators evaluation logic semantics de ned :10.1.1.42.1853:10.1.1.35.4051
compare theorem :10.1.1.42.1853
double lines indicate rule works directions 
set free variables denoted fv 
rule pre subject usual variable condition occur freely undischarged assumptions 
calculus sound theorem deducible rules holds internal logic 
proof theorem lemmas convenient lemma program context includes proof assume empty program sequence :10.1.1.42.1853
ret fst snd ret fst snd ret fst snd 
rst step uses unit law cf 
section third step applies assumption :10.1.1.42.1853
lemma program context includes generic approach side effects state proof preceding lemma res res res :10.1.1.42.1853
cf :10.1.1.42.1853
section explanation restriction operator res 
converse preceding lemma holds stateless terms ret ret easily seen imply note condition simpli es ret ret proof theorem prove rules lemmas internal logic apply lemma term ret mp rst premise implies equal truth values :10.1.1.42.1853
obtain lemma ret ret ret ret ret proving :10.1.1.42.1853
eq lemma ret ret ret ret second premise second step :10.1.1.42.1853
app lemma ret ret just :10.1.1.42.1853
pre lemma premise implies ret ret generic approach side effects state tau rp derived rules auxiliary calculus substitution obtain ret ret :10.1.1.42.1853
unit laws formula particular ret ret ret lemma implies soundness upwards direction rule :10.1.1.42.1853
converse direction follows ret ret ret lemma :10.1.1.42.1853
ctr lemma associativity binding :10.1.1.42.1853
refer proofs rules mp propositional reasoning 
proposition simple monads converse rule ctr ctr sound 
auxiliary calculus admits number derived rules shown 
proposition rules derivable rules 
proof tau specialization pre 
rp tau obtain follows eq :10.1.1.42.1853
ctr lemma rp 
rule gives rise strengthening notion side ect freeness generic approach side effects state de nition program called strongly side ect free satis es converse rule implies program sequences formula :10.1.1.42.1853
degree di erence side ect freeness strong side ect freeness varies 
hand proposition 
proposition simple monads side ect free programs strongly ect free :10.1.1.42.1853:10.1.1.35.4051
monads explicit notion state including exception monad non determinism monad free abelian group monad converse holds programs cases side ect free programs strongly side ect free 
hand strong side ect freeness considerably stronger side ect freeness continuation monad 
rate rule proposition stateless programs strongly side ect free :10.1.1.18.7716
syntax introduced express determinacy side ect free programs de nition strongly side ect free program deterministically side ect free shorthand stateless programs deterministically side ect free :10.1.1.42.1853
running examples side ect free programs deterministically side ect free unsurprising exception monads non determinism involved 
cases side ect free program deterministically side ect free deterministic 
subtype ta formed deterministically side ect free computations denoted da 
deterministically side ect free subterms programs handled notationally relaxed way 
basis lemma lemma program :10.1.1.42.1853
ii proof de nition lemma left hand side equals equal right hand side side ect freeness 
ii de nition obtain strong side ect freeness generic approach side effects state side ect freeness lemma term equal right hand side claim equivalence 
lemma obtain immediately contraction rule interchange rule corollary structural rules formula :10.1.1.42.1853
ii strong side ect freeness amounts context weakening safely allow terms formulas deterministically side ect free terms type da occur places term type expected 
precisely xn list variables types admit terms substituted terms da term just abbreviation de nedness guaranteed lemma :10.1.1.42.1853
similarly abbreviates de nedness guaranteed corollary :10.1.1.42.1853
abstraction concerns termination programs de nition program terminates implies program sequence :10.1.1.42.1853
non determinism monad terminates 
state monad 
terminates total 
lemma side ect free programs terminate :10.1.1.42.1853
proof rule auxiliary calculus 
material collected far allows give monad independent de nition state de nition state element terminates exists deterministically side ect free program da due termination necessarily unique element ret state called forcible terminating program generic approach side effects state example running examples notions state forcible state explicate follows states state monad constant state transformers states forcible :10.1.1.42.1853
course set constant state transformers isomorphic set de nition capture original states 
situation essentially non deterministic state monad states constant deterministic state transformers exception monad non determinism monad state running unique terminating element exception monad non determinism monad 
cases state forcible 
states interactive input monad elements branching trees trivially labelled leaves 
states forcible accordance intuition unread input 
henceforth denote type forcible states 
thought de ned subtype means formula internal logic ts de ned subtype tt formula :10.1.1.42.1853
main result section structure theorem concerning type da deterministically side ect free programs 
theorem applied case deterministically side ect free formulas section 
result depends existence program gives away state 
existence needed amount breaking encapsulation 
de nition deterministically side ect free program ds called state side ect free equal ret stateless :10.1.1.42.1853:10.1.1.18.7716
example monads forcible state non determinism monad exception monad trivially state shape term ret state monad may identify set forcible states originally set states cf :10.1.1.42.1853:10.1.1.42.1853:10.1.1.35.4051
example element ds state :10.1.1.42.1853
works analogously non deterministic state monad 
sense notion state lookup operator mentioned :10.1.1.42.1853
interactive input monad state ts empty 
relationship forcible states state con rmed statement lemma state forcible state ret generic approach side effects state proof state exists forcible state ret forcible ret state lemma proves claim :10.1.1.42.1853
nal prerequisite known comprehension axiom holds hascasl models cf :10.1.1.42.1853:10.1.1.35.4051
:10.1.1.42.1853
unique description operator internal language purposes meta reasoning conservative term denote element satis es unique element exists unde ned 
announced structure theorem con rms intuition deterministically side ect free computations essentially state dependent values theorem state type da isomorphism maps da ret inverse maps ret proof rst maps yield element total function follows de nition state 
term de ning second map deterministically side ect free ret 
remains shown maps inverses 
da ret ret ret ret ret ret ret ret interpreting dynamic logic side ect freeness second step lemma applied deterministic side ect freeness fourth step just de nition 
conversely show ret ret de ning property left hand side ret ret follows immediately lemma :10.1.1.42.1853
example theorem applies running example monads interactive input monad state structure theorem fails hold forcible states :10.1.1.42.1853:10.1.1.42.1853:10.1.1.35.4051
theorem state unique exists element ds mapped identity isomorphism ds 
interpreting dynamic logic approach hoare logic pursued partly driven concept interpreting formulas programs framework hascasl internal logic respectively meta language arbitrary monad :10.1.1.42.1853
required giving semantics hoare triples purpose notion global validity sucient 
contrast formulas dynamic logic allow nesting modal operators nature execution usual connectives rst order logic 
means informally state changed ect scope modal operator restored outside scope 
dynamic logic formula subformulas evaluated modi ed states evaluated state 
means semantics side ect free may side ects ect 
expect formula evaluates deterministic truth value may non deterministic 
reasonable require formulas interpreted deterministically side valued programs 
state explicitly de nition formula dynamic logic term recall notation subterms introduced corollary :10.1.1.42.1853
question structure allow interpretation diamond box operators hpi dynamic logic 
interpretation interpreting dynamic logic introduced axiomatically straightforward manner 
observe partial order putting antisymmetry proved lemma noting truth values equivalence equality 
crucial requirement dynamic logic existence lower upper deterministically side ect free approximations program sequences de nition say admits propositional dynamic logic exist program sequence formula formula program sequence containing dually formula qi qi admits quanti ed dynamic logic additionally complete lattice 
case joins meets denoted respectively 
internal logic general intuitionistic de ne qi 
course variable de nition equivalently replaced stateless formula contain formulas dually qi uniquely determined contrast modalities part interpretation structure lemma admits dynamic logic greatest formula ordering introduced proof claim de nition implies :10.1.1.35.4051
displayed property follows de nition 
theorem applicable order isomorphic equipped pointwise order complete lattice joins meets formed pointwise 
follows exist program sequence unique formulas qi satisfy properties lemma 
weak additional assumptions hoped dispensed prove case admits dynamic logic 
de nition state called logically splitting program sequences formula implies interpreting dynamic logic note converse implication holds universally lemma :10.1.1.42.1853:10.1.1.35.4051
running examples forcible states logically splitting conjecture case 
de nition monad logically regular internal logic classical truth values case distinction holds shows monads logically regular 
conjecture holds intuitionistic case 
immediate lemma logically regular implies converse implication deducible auxiliary calculus 
theorem logically regular state forcible states logically splitting admits quanti ed dynamic logic :10.1.1.42.1853:10.1.1.35.4051
proof program sequence theorem de ne function state 
equivalences state logically splitting logical regularity translating formula correspondence described theorem obtain required 
existence qi follows theorem :10.1.1.42.1853
example running example monads forcible state qi just truth values 
exception monad true throws exception returns value satis es hy qi true returns value satis es 
nondeterminism monad holds values satisfy hy qi holds contains value satis es 
various state monads qi depend state 
non deterministic state monad holds state values obtained execution satisfy hy qi holds possible return value satis es 
interpreting dynamic logic interactive input monad admit quanti ed dynamic logic state :10.1.1.18.7716
fact unclear monads fail admit dynamic logic candidate counterexample continuation monad 
subject research 
simple base dynamic logic modal operators presentation equivalent correspondingly :10.1.1.42.1853
case de ne dually qi :10.1.1.42.1853
admits dynamic logic usual syntax dynamic logic modal operators basic de nition logical connectives de ned substitution terms explained corollary :10.1.1.42.1853
actual truth values terms type appearing dynamic logic formulas implicitly cast ret easy see compatible interpretation logical connectives lead confusion 
admits quanti es dynamic logic interpret universal existential quanti cation putting note monad independent hoare logic admit program sequences inside modal operators order accommodate reasoning intermediate results :10.1.1.42.1853:10.1.1.42.1853:10.1.1.35.4051
side bene comparison possibility expressing natural axioms concerning composite sequences axioms seq seq :10.1.1.42.1853:10.1.1.35.4051
quanti ed dynamic logic modal operators interrelated way analogous quanti ers intuitionistic logic theorem admits quanti ed dynamic logic qi expressible proof show displayed formula implied qi suces de nitions qi verify equivalent holds lemma applied :10.1.1.42.1853:10.1.1.42.1853:10.1.1.35.4051
prove converse implication suces show qi qi interpreting dynamic logic rules nec mp axioms pi pi ret ret hpi ret ret pi pi pi pi seq seq qi pi hy qi ctr fv ctr hx qi hy fv hx pi tm hpi terminates hpi hpi strongly generic proof calculus propositional dynamic logic dual lemma qi de nition obtain implies :10.1.1.42.1853
validity formulas dynamic logic usual modal logics de ned global box de nition formula valid holds ret 
formulas dynamic logic appears rst sight notational con ict validity de ned abbreviated notation deterministically side ect free subterms introduced section 
notations easily seen compatible precisely due deterministic side ect freeness equivalent interpreting dynamic logic shows generic proof calculus propositional dynamic logic shall concerned deduction quanti ed dynamic logic :10.1.1.42.1853
due con ict local nature subformulas global nature validity presentation hilbert style feasibility sequent style natural deduction systems investigation 
rules necessitation modus ponens remainder calculus form axioms precisely axiom schemes 
necessitation rule subject usual constraints variables rst axioms standard axioms fragment intuitionistic modal logic slight variation third axiom usual form hpi :10.1.1.42.1853
special case second dual forms 
intuitionistic propositional tautologies implicitly included 
axioms concerning sequential composition program sequences 
axioms concern programs enjoy particular properties de ned properties side conditions expected discharged outside calculus 
axioms applicable stateless programs ret ado generic program constructors sequential composition return covered 
case generic hoare rules axioms deal program constructs necessarily missing typical examples include nondeterministic choice iteration constructs standard dynamic logic :10.1.1.42.1853
speci formulas come speci cations particular monads fact turn choice actual axioms speci cation 
examples section axioms dealing generic user de ned control structures discussed 
proof calculus sound theorem admit dynamic logic 
formula deduced formulas means rules validity implies validity completeness calculus subject research 
proof show rules preserve validity axioms valid 
validity intuitionistic tautologies follows propositional reasoning auxiliary calculus 
rule nec assume show 
substitution assumption formula reduces 
show de nition amounts proving trivial formula 
rule mp proved propositional reasoning auxiliary calculus 
axiom de nition show follows auxiliary calculus fact de nitions interpreting dynamic logic axiom de nition pi suces show pi derived auxiliary calculus pi axiom ret ret lemma implies axiom :10.1.1.42.1853
axiom dual :10.1.1.42.1853
axiom de nition pi show pi pi follows auxiliary calculus pi pi axiom de nition show pi obtained pi axiom seq lemma right hand side greatest de nition equivalent greatest property lemma left hand side axiom :10.1.1.42.1853
axiom seq dual 
axioms ctr ctr rule ctr auxiliary calculus lemma :10.1.1.42.1853
axioms immediate de nition :10.1.1.42.1853
axiom tm de nition hpi hpi holds arbitrary terminates equation ret hpi ret coded formula allows deduce hpi 
axioms rule lemma :10.1.1.42.1853
axiom de nition strong side ect freeness lemma 
hoare calculus total correctness rst application calculus show program validity hpi implies termination sense de ned section :10.1.1.42.1853
rephrasing de nition show hpi ret derivable ret 
seq deduction rules suces prove hpi ret ret noting ret ret ret hpi hpi ret claim proved propositional reasoning :10.1.1.42.1853
logically regular prove axioms eq eq hx pi hx qi :10.1.1.42.1853
prove eq show lemma ret rule auxiliary calculus logical regularity follows immediately lemma equational reasoning :10.1.1.42.1853
simple converses axioms ctr ctr hold :10.1.1.42.1853:10.1.1.42.1853:10.1.1.35.4051
hoare calculus total correctness classically monad independent setting dynamic logic subsumes hoare logic monad independent hoare triples introduced expressed dynamic logic obvious expressive advantage dynamic logic hoare logic local nature formulas hold locally state :10.1.1.42.1853
contrast hoare triples provide global axiomatizations formula separately quanti ed states 
crucial feature dynamic logic ability express termination 
hoare calculus non termination expressed stating postcondition holds 
hoare logic weak express termination formula hpi hoare calculus total correctness dynamic logic states terminates monad independent sense de ned expected meaning concrete monads :10.1.1.42.1853
give meaning hoare triples total correctness interpreting partial correctness plus termination hpi implication hpi called termination part implication called partial correctness part hoare triple 
calculus hoare triples fig 
:10.1.1.42.1853:10.1.1.35.4051
rules iter need additional infrastructure meaningful 
valued type bool booleans needed polymorphic function bool satisfying usual laws 
just amounts stating bool coproduct 
furthermore bool embedded bool image embedding behaves classically 
rule embedding implicitly truth valued programs treated formulas values type iteration construct iter rule control structure de ned top monad provided general recursion realized hascasl means xed point recursion cpos :10.1.1.42.1853
restrict monads allow lifting cpo structure cpo structure type ta computations way monad operations continuous 
example constructor subclass corresponding speci cation cpo monads shown 
function types indicated indicate types continuous functions :10.1.1.42.1853:10.1.1.41.840
relevant examples including ones belong subclass 
spec recursion monad class monad vars cpo type cpo ops 
return constructor subclass cpo monads iteration construct introduced generalization loop return value loop programmed haskell prelude returns unit value fed iteration case body loop executed default return value provided argument 
advantage construct sense stateless monads hoare calculus total correctness iteration non determinism monad results function values outcomes reached repeatedly applying original function condition holds :10.1.1.42.1853
executable speci cation iteration construct shown 
note loop just iteration ignoring return value 
spec iteration bool vars cpo op iter bool 
program iter test test iter test return op bool unit unit iter iteration control structure iteration rule adjusted cope total correctness lines stands shorthand rules carried hoare calculus partial correctness :10.1.1.42.1853:10.1.1.42.1853:10.1.1.41.840:10.1.1.35.4051
iteration rule specializes simpler rule db founded ret ret hoare calculus total correctness sound theorem admit dynamic logic 
rules hoare calculus total correctness derived calculus dynamic logic rules iter depend logically regular 
proof leave propositional reasoning applications mp implicit 
side ect free show hqi 
follows tm side ect free programs terminate lemma :10.1.1.42.1853
ret show ret hpi ret 
termination part follows premise rule partial correctness part axiom :10.1.1.42.1853
deterministically side ect free need show hpi termination part follows tm lemma :10.1.1.42.1853
partial correctness part follows :10.1.1.42.1853
seq show rule pi qi qi hoare calculus total correctness valid :10.1.1.42.1853
proceed partial correctness part rst 
second premise rule weakened partial correctness part obtain nec seq :10.1.1.42.1853
rst premise arrive concerning termination part second premise rule weakened termination part nec seq get pi qi :10.1.1.42.1853
combining pi pi obtained get pi qi combined rst premise order arrive qi ctr immediate ctr ctr :10.1.1.42.1853
need show validity rule hx pi hx qi hx qi de nition easily obtains logically regular eq eq :10.1.1.42.1853
premises imply hx qi hx qi bool classical follows 
wk follows nec 
conj follows nec 
disj immediate 
immediate 
iter show founded induction premises imply iter inductive assumption formula replaced iter expands iter ret example reasoning dynamic ret ret ret ret :10.1.1.42.1853:10.1.1.18.7716
ctr fv fv iter db founded iter wk seq conj disj generic hoare calculus total correctness rule reduces showing ret iter follows tm follows rule seq premise inductive assumption allow squeeze assertion statements :10.1.1.42.1853:10.1.1.42.1853:10.1.1.35.4051
example reasoning dynamic apply general machinery developed far slightly extended domain classical hoare calculus states consisting destructively updatable note just example state monad extended non determinism 
monad uses type constructor ref ref set values type type computations monad comes operations reading writing usual monad operations see 
note di erence ret equality stateless formula ret equality contents stateful formula 
recall ret inserted implicitly needed 
example reasoning dynamic axiomatization provides really necessary order reason need rely particular implementation rule states reading deterministically side ect free :10.1.1.42.1853:10.1.1.42.1853:10.1.1.35.4051
read write says writing read value 
contrast writing change values read write 
note said nature integers 
example nondeterminism monad 
monad independent hoare calculus instance axiomatized non determinism follows fail xg xg xg fail join dynamic logic ne grained speci cation non determinism possible hp qi hpi hqi fail second axiom easily get hoare rule join get rst axiom implies terminates terminates :10.1.1.42.1853
expressible hoare logic partial correctness 
behaves di erently partial correctness termination leads complicated hoare rule join gx pf xg gx qf xg correctness rule seen follows concerning termination rst premise gives hpi rst property hp qi :10.1.1.42.1853
similarly third premise gives hp qi altogether hp qi 
concerning partial correctness rst premises lead remaining lead combining second property yields contrast fail rule remains expressed partial correctness fail fail advantage looseness speci cations introduced far combine speci cation nondeterminism get speci cation nondeterministic computations :10.1.1.42.1853
example prove termination dijkstra nondeterministic version euclid algorithm computing greatest common divisor monad shown partial correctness :10.1.1.42.1853
assume speci cation natural numbers arithmetic including operation max computing maximum natural numbers predicates going example reasoning dynamic spec var cpo types ref ops ref ref unit forall ref read read write read write speci cation monad bool comparison natural numbers :10.1.1.42.1853
shorthand monad nondeterministic applied naturals 
euclid program sequence ret ret fail ret fail try prove euclid terminates provided distinct euclid proceed follows 
seq ret conj show max max arithmetic reasoning wk obtain max max read write read write ret conj show max max arithmetic reasoning wk get max max example reasoning dynamic seq noting shorthand get max max wk max fail max max ret fail max :10.1.1.42.1853
noting total implies partial correctness max rg max zg fail max rg fail max zg rule hoare calculus partial correctness get max sg ret fail max zg entirely analogous way get max ret fail max max rg ret fail max zg join get max ret fail ret fail max go bool behave classically :10.1.1.42.1853
wk max ret fail ret fail max noting founded prepared apply getting ret ret fail ret fail wk get desired result ret fail ret fail building results monad independent reasoning program properties developed designed monad independent dynamic logic representation logic internal logic hascasl essentially intuitionistic partial higher order logic :10.1.1.42.1853
main problem provide monad independent semantics dynamic modal operators 
solution introduced axiomatic method imposes additional constraints monad 
method complemented results suitable conditions allow extraction states monad giving rise structure theorem dynamic truth values guarantees interpretability modal operators 
structure theorem independent interest basis research question monad generally decomposed aspects input output state 
ambient logic intuitionistic dealing variant intuitionistic modal logic 
turned setting diamond operator intuitionistically expressible box operator theorem principle may interest intuitionistic modal logic general :10.1.1.42.1853
semantics modal operators introduced generic proof system dynamic logic arbitrary monad rules axioms proved lemmas encoding 
ended logic allows dynamic reasoning computations side ects leaving actual nature side ects open 
practice aim performing large amount veri cation generic setting switch instantiations calculus particular monads detailed analysis 
example laid operations non determinism monad axiomatized means dynamic logic formulas :10.1.1.42.1853
library monad de nitions hascasl extensive axiomatization principle compositionality axiomatizations monad combination subject research 
crucial features dynamic logic able express termination programs 
example application shown obtain termination rule generic iteration construct illustrated calculus termination proof dijkstra non deterministic version euclid algorithm partial correctness total correctness lends monad independent reasoning 
corroborates moggi claim logic monads right setting reasoning computations ects :10.1.1.41.840:10.1.1.41.840
forms part dfg funded project hascasl kr :10.1.1.18.7716
authors wish christoph useful comments discussions 
barr wells :10.1.1.41.840
toposes triples theories 
springer :10.1.1.42.1853:10.1.1.18.7716:10.1.1.35.4051
cofi :10.1.1.42.1853
common framework initiative algebraic speci cation development electronic archives 
www brics dk projects cofi 
cofi language design task group :10.1.1.13.8780
casl cofi algebraic speci cation language summary version 
documents casl summary july :10.1.1.42.1853:10.1.1.18.7716
dijkstra 
discipline programming 
prentice hall :10.1.1.18.7716
haskell mailing list 
www haskell org html :10.1.1.42.1853
jones hughes augustsson barton boutel burton fasel hammond hinze hudak johnsson jones launchbury meijer peterson reid runciman wadler :10.1.1.15.5722
haskell non strict purely functional language :10.1.1.42.1853:10.1.1.35.4051
:10.1.1.18.7716
www haskell org 
lambek scott :10.1.1.41.840
higher order categorical logic 
cambridge :10.1.1.42.1853:10.1.1.18.7716:10.1.1.35.4051
:10.1.1.42.1853:10.1.1.41.840:10.1.1.35.4051
foundations program veri cation 
wiley :10.1.1.42.1853:10.1.1.18.7716:10.1.1.35.4051
mac lane 
categories working mathematician 
springer :10.1.1.18.7716
moerdijk 
wellfounded trees categories 
ann 
pure appl 
logic :10.1.1.42.1853:10.1.1.42.1853:10.1.1.35.4051
moggi :10.1.1.41.840:10.1.1.41.840
notions computation monads 
inform 
comput :10.1.1.42.1853:10.1.1.18.7716
moggi :10.1.1.42.1853
semantics evaluation logic 
fund 
inform :10.1.1.42.1853:10.1.1.18.7716
mosses 
casl guided tour design 
workshop datatypes volume lncs pages :10.1.1.42.1853:10.1.1.42.1853:10.1.1.35.4051
springer :10.1.1.18.7716
pitts :10.1.1.35.4051
evaluation logic 
higher order workshop workshops computing pages :10.1.1.42.1853:10.1.1.42.1853:10.1.1.35.4051
springer :10.1.1.18.7716
plotkin power :10.1.1.18.7716
notions computation determine monads 
foundations software science computation structures volume lncs pages :10.1.1.42.1853
springer :10.1.1.42.1853
plotkin stirling 
framework intuitionistic modal logic 
theoretical aspects reasoning knowledge 
morgan kaufmann :10.1.1.42.1853:10.1.1.18.7716:10.1.1.35.4051
pratt :10.1.1.41.840:10.1.1.41.840
semantical considerations floyd hoare logic 
foundations science pages :10.1.1.42.1853
ieee :10.1.1.18.7716
:10.1.1.42.1853:10.1.1.35.4051
holcf higher order logic computable functions 
theorem proving higher order logics volume lncs pages :10.1.1.42.1853:10.1.1.18.7716
schr oder :10.1.1.18.7716
classifying categories partial equational logic 
category theory computer science volume entcs :10.1.1.42.1853
schr oder mossakowski :10.1.1.42.1853
monad independent dynamic logic hascasl 
wadt submitted publication :10.1.1.42.1853
schr oder mossakowski :10.1.1.42.1853:10.1.1.41.840
hascasl integrated speci cation development functional programs 
algebraic methodology software technology volume lncs pages :10.1.1.42.1853
springer :10.1.1.42.1853
schr oder mossakowski :10.1.1.42.1853
monad independent computational reasoning hascasl 
fundamental aspects software engineering lncs :10.1.1.42.1853
appear 
scott :10.1.1.42.1853
relating theories calculus 
curry essays combinatory logic lambda calculus formalisms pages 
academic press :10.1.1.42.1853:10.1.1.18.7716:10.1.1.35.4051
simpson :10.1.1.42.1853
proof theory semantics intuitionistic modal logic 
phd thesis university edinburgh :10.1.1.18.7716
philip wadler :10.1.1.42.1853:10.1.1.35.4051
declare imperative 
acm computing surveys :10.1.1.42.1853:10.1.1.18.7716
