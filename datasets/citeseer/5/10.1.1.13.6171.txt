efficient pda synchronization david ari agarwal modern personal digital assistant pda architectures utilize wholesale data transfer protocol known slow sync synchronizing pdas personal computers pcs 
approach markedly inefficient respect bandwidth usage latency energy consumption pda pc typically share common records 
propose analyze implement novel pda synchronization scheme cpisync predicated information theoretic research 
salient property scheme communication complexity depends number differences pda pc essentially independent number records 
implementation shows computational complexity energy consumption cpisync practical latency typically smaller slow sync alternative synchronization approaches bloom filters 
cpisync potential significantly improving synchronization protocols pdas generally heterogeneous networks machines 
keywords personal digital assistant mobile computing data synchronization earlier version appeared infocom 
corresponding author david 
authors department electrical computer engineering boston university boston ma 
supported part national science foundation nsf career ani ccr 
popularity mobile computing devices pdas attributed ability deliver information users seamless basis 
particular key feature new comput ing paradigm ability access modify data mobile device synchronize updates back office network 
feature plays essential role vision pervasive computing mobile device ultimately able access synchronize networked data 
current pda synchronization architectures simple inefficient 
exceptions generally utilize protocol known slow sync employs wholesale transfer pda data pc order determine differing records 
approach turns particularly inefficient respect bandwidth usage latency actual number differences smaller total number records stored pda 
typical case handheld devices desktops regularly synchronize changes synchronizations 
consider application near optimal synchronization methodology research advances fast set reconciliation order minimize waste network re sources 
broadly speaking pda pc data sets new scheme synchronize hosts message direction length essentially independent size data sets 
data sets millions entries differ set synchronized message size entries 
key proposed synchronization algorithm translation data certain type polynomial known characteristic polynomial 
simply put reconciling host pda pc maintains characteristic polynomial 
synchronizing pda sends sampled values characteristic polynomial pc number samples number differences hosts 
pc discovers values differing entries interpolating corresponding rational function received samples 
generic term hosts refer pc pda 
step 
evaluation characteristic polynomial sample points pda step 
transmission evaluations pc pda step 
transmission synchronization information pda step 
reconciliation cpisync algorithm pc pc fig 

mode operation cpisync algorithm 
procedure completes pc sending updates palm needed 
worst case computation complexity scheme roughly cubic number differences 
schematic implementation call cpisync characteristic polynomial interpolation synchronization fig 

implemented cpisync palm pilot popular representative pda 
experimental results show cpisync perform significantly better order magnitudes slow sync alternative synchronization approaches bloom filters terms latency bandwidth usage :10.1.1.153.5656:10.1.1.20.2080
experimental evidence shows savings translate corresponding efficiency energy consumption 
hand number differences hosts increase computational complexity cpisync significant 
hosts differ significantly bloom filters wholesale data transfer may faster methods synchronization 
threshold number differences cpisync loses advantage protocols typically quite large making cpisync protocol choice synchronization applications 
complication cpisync requires priori bound number differences synchronizing sets 
propose implement prob technique testing correctness guessed upper bound 
guess turns incorrect guess modified second attempted synchronization forth 
error probabilistic technique arbitrarily small 
show communication time scheme maintained small multiplicative con stant communication time needed optimal case number differences hosts known 
organization section review synchronization techniques currently palm os computing platform 
indicate limitations techniques seemingly reasonable alternatives 
section describes related literature 
section iii establish foundations cpisync theoret ical results 
section iv provides technical details specific implementation cpisync palm pilot 
experimental results bandwidth latency energy usage case tight bound number differences known priori pro vide comparisons implementations slow sync bloom filters 
section describe evaluate performance probabilistic technique tight bound number differences known priori 
provide section vi 
ii 
background order clearly concretely explain types performance issues addressed describe data synchronization implemented palm os architecture leading state art mobile computing platforms 
implementation clearly designed narrow usage model scalable network size data storage 
provide seemingly reasonable alternatives palm synchronization protocol discuss related presenting section iii chosen solution characteristic polynomial interpolation 
palm synchronization protocol palm synchronization protocol known relies metadata maintained handheld device desktop 
metadata consist databases palm dbs contain information data records 
palm db separately implemented applica tion palm db date book data records data records forth 
data record palm db maintains unique record identifier pointer record memory location status flags 
status flags remain clear data record modified synchronization event 
status flags indicate new status record modified deleted 
palm protocol operates modes fast sync slow sync 
pda device synchronizes desktop fast sync mode selected 
case device uploads desktop records palm db status flags set 
desktop uses synchronization logic reconcile device changes 
synchronization logic may differ application implemented called conduits 
synchronization process concludes resetting status flags device desktop 
copy local database saved backup case synchronization performed slow sync mode 
fast sync conditions met slow sync performed 
slow sync performed handheld device synchronized different desktop happen alternates synchronization computer home 
cases status flags reliably convey differences synchronizing systems handheld device sends data records desktop 
backup copy desktop determines data records added changed deleted completes synchronization fast sync case 
illustration fast sync slow sync operation modes fig 

slow sync mode amounts wholesale transfer significantly efficient fast sync 
particular latency amount communication energy required slow sync increase linearly number records stored device independently actual pda pda database metadata data modified buy food change register change pin change 
database metadata data modified buy food change register change pin change slow sync fast sync fig 

modes palm protocol 
slow sync mode data transferred 
fast sync mode modified entries transferred databases 
number differing records 
palm synchronization model generally works simple settings users possess single handheld device synchronizes time desktop 
model fails increasingly common scenario large amounts data synchronized multiple pdas laptops desktops 
timestamps plausible synchronization solution timestamps version control aid discovering data elements host missing 
hosts synchronizing happens pda synchronized just home computer timestamps effectively 
cases synchronization accomplished simple exchange items modified previous synchronization done fast sync operation mode 
unfortunately case complicated synchronizing machines pda home machine machine 
case timestamps result inefficient communication cost synchronization depicted fig 

addition network scenario envisioned initiative timestamp protocols require host maintain information host network scale multiple hosts adapts poorly dynamic network hosts enter leave pc pc fig 

inefficiency timestamps 
hosts synchronize item left 
hosts synchronize host noting addition items 
hosts synchronize modification records require transmission differences marked bold fact 
unpredictably 
bloom filter possible technique synchronization bloom filter hashes data element bits array :10.1.1.153.5656:10.1.1.153.5656:10.1.1.20.2080
array known bloom filter set represent set concisely 
test specific element set need check appropriate bits bloom filter set certainly set said existence set 
case possible hosts incorrectly synchronize hosts false positive indication hosts fact host 
probability false positive depends length bloom filter number elements original data set number hash functions compute bloom filter 
false positive probability asymptotically large values rewrite inequality determined inspecting derivative 
order maintain constant false positive probability length bloom filter increased linearly size data set 
linear length bloom filters respect set size potentially high false positive rate attractive practical set reconciliation problems shall see section iv 
fact existing data compression schemes lossless lossy compress data constant fraction compressed signature length linear original set size 
related general problem data synchronization studied different perspectives literature 
database perspective concept disconnected operation hosts indepen dently operate subsequently synchronize established coda file system 
general model proposed similar models current mobile computing systems including pdas 
management replicated distributed databases requires development sophisticated algorithms guaranteeing data consistency resolving conflicting updates 
ar bayou roam deno proposed address important problems 
consider cpisync complementary architectures 
cpisync methodology permits efficient determination differences databases mentioned architectures resolve data keep update differences known 
analysis pda synchronization protocols perspective scalability communi cations considered relatively new area research 
closely related literature edison architecture proposed 
architec ture relies centralized shared server hosts synchronize 
server maintains incremental log updates hosts fast sync slow sync 
cpisync architecture designed general case device may synchro device peer peer basis 
general distributed architecture peer peer synchronization provides better network performance terms robustness scalability centralized architecture 
highlights trade offs considerations context mobile device synchronization 
information theoretic perspective synchronization modeled traditional error correction problem 
case synchronizing hosts differ place corruptions insertions deletions error correcting codes correct differences 
results show classical error correcting code set reconciliation 
reed solomon codes general form bch codes provide particularly application fixed finite field decoding time depends number errors transmitted vector 
transferred parlance set reconciliation means decoding time depends number differences sets sizes sets 
solution provided reed solomon codes related cpisync provides means data synchronization 
iii 
characteristic polynomial interpolation synchronization key challenge efficient pda synchronization synchronization protocol com munication complexity depends number differences synchronizing systems conditions fast sync hold 
section family protocols characteristic polynomial interpolation synchronization cpisync 
formalize problem synchronizing hosts data follows pair hosts set bit integers host determine symmetric difference sets integers held minimal amount communication 
context elements sets important relative positions set 
note integer sets synchronized generically encode types data 
formalization called set reconciliation problem 
natural examples set reconciliation include synchronization bibliographic data resource availability data gossip protocols memos address books 
hand synchronization edited text clear cut example set reconciliation structure data file encodes information example file containing string abc containing string 
set reconciliation problem intimately linked design questions coding theory graph theory solutions exist 
solution implemented pda described section iv requires nearly minimal communication complexity operates reasonable computational complexity 
deterministic scheme known upper bound key set reconciliation algorithm minsky translation data sets polynomials designed specifically efficient reconciliation 
characteristic polynomial set defined define sets missing integers symmetrically equality holds common factors cancel 
degrees may large degrees numerator denominator reduced rational function may quite small 
relatively small number sample points completely de termine rational function size may kept small bounded performing arithmetic appropriately sized finite field 
approach may reduced conceptually fundamental steps described protocol 
protocol assumes upper bound number differences hosts known priori hosts 
section iii describes efficient probabilistic solution case tight bound known 
straightforward implementation algorithm requires expected computational time cubic size bound linear size sets 
practice efficient implementation amortize computational complexity insertions deletions sets maintaining characteristic polynomial evaluations incrementally 
protocol set reconciliation known upper bound number differences 
hosts evaluate respectively sample points 
host sends host evaluations 
evaluation combined host compute value sample points 
points interpolated solving generalized vandermonde system equations reconstruct coefficients rational function zeroes determined precisely elements respectively 
algorithm communicates computed samples host order reconcile differences sets complete reconciliation host sends back computed differences giving total communication integers 
contrast information theoretic minimum amount communication needed reconciling sets bit integers intersection size bits corresponds sending roughly integers 
note part communication complexity protocol depends set size representation integer 
hosts millions integers symmetric difference sets samples transmitted direction perform reconciliation millions integers transmitted trivial set transfer 
furthermore protocol require interactivity meaning example host computed sample points available web determine set simply downloading computed values requiring computation 
example demonstrates protocol specific sets 
example simple example interpolation synchronization protocol 
consider sets stored bit integers hosts respectively 
treat members members sufficiently large finite field case constrain size characteristic polynomial evaluations 
assume upper bound size symmetric difference 
characteristic polynomials table shows evaluation points corresponding characteristic polynomial val ues ratio values 
calculations done host sends evaluations host interpolate rational function evaluated sample points zeros numerator denominator respectively exactly equal 
determining upper bound cpisync protocol described previous section requires knowledge tight upper bound number differing entries 
simple method possibly obtaining bound involves having host host count number modifications data sets common synchronization 
time host host synchronize host sends host message containing number modifications denoted 
host computes corresponding value form upper bound total number differences hosts 
clearly bound tight hosts performed mutually exclusive modifications 
may completely hosts performed exactly modifications respective databases 
may happen prior synchronization hosts synchronized third host asin fig 

problem method requires maintaining separate information host synchronization performed may reasonable large networks 
simple method just described inefficient applications 
section describe probabilistic scheme determine high prob ability tighter value 
result fundamental importance allows cpisync achieve performance equivalent fast sync general setting 
probabilistic scheme unknown upper bound general setting knowledge upper bound provided impossible reconcile sets theoretical certainty performing equivalence slow sync 
fortunately probabilistic scheme synchronize arbitrarily low probability error efficiently deterministic optimum slow sync 
specifically scheme suggests guessing bound subsequently verifying guess correct 
guessed value turns wrong improved iteratively correct value reached 
case may scheme synchronize hosts guess upper bound perform protocol bound resulting host computing rational function function corresponds differences host sets computing zeroes determine precisely mutual difference sets 
check equation holds host chooses random sample points sends example example reconciliation bound known number differences sets 
consider incorrect bound example 
case host receives evaluation host compares evaluation interpolate polynomial guess differences hosts 
check validity host requests evaluations polynomial random points host sends corresponding values divides evaluations get verification points 
guessed function agree verification points host knows initial bound incorrect 
host may update bound repeat process 
evaluations host uses values compute evaluations comparing host assess equation satisfied 
equation satisfied procedure repeated different bound 
example demonstrates procedure 
general hosts keep guessing resulting polynomials agree random sample points 
precise probabilistic analysis shows agreement corre sponds probability error assuming integer bit binary representation 
manipulating equation trivial upper bound see needs agreement samples get probability error protocol 
example reconciling host sets bit integers error probability require agreement random samples 
show section verification protocol requires transmission samples random number seed generating random sample points reconcile sets value determined desired probability error equation 
verification protocol require rounds communication synchronization deterministic protocol require transmission significantly bits com munication 
show section computational overhead probabilistic protocol large 
iv 
pda implementation demonstrate practicality effectiveness synchronization approach implemented cpisync algorithm introduced previous sections real handheld device palm pilot personal digital assistant 
program emulates operation memo pad provides convenient testbed evalu ating new synchronization protocol 
successful implementation protocol computationally limited palm device suggests done complicated heterogeneous networks machines 
section describe implementation provide experimental results specific case number differences pda pc databases known tightly bounded priori 
general tightness bound guaranteed efficient employ probabilistic scheme described sec tion iii 
detail implementation general scheme section show performance close performance protocol knows priori 
experimental environment platform experiments performed palm pilot bit motorola drag processor mb ram 
palm connected serial link pentium iii class machine mb ram 
model specific implementation cpisync emulates memo pad application 
data entered palm evaluations characteristic polynomial described section iii updated designated sample points 
request synchronization palm sends evaluations desktop corresponding presumed maximum number differences data machines 
desktop compares evaluations eval determines differences machines described protocol 
section iv compare cpisync emulation slow sync synchronization sends palm data desktop uses information determine differences 
compare cpisync bloom filter implementation section iv 
enable fair comparison implementation perfect xor hashes chosen simple implementation computationally limited pda 
addition hash computations set elements computed stored line 
bloom filter synchronization run executed follows pc pda exchange bloom filters 
pda uses pc bloom filter hash values data set calculate data elements pc missing 
pda sends missing elements pc 
likewise pc uses pda bloom filter calculate transmit data elements pda missing 
address issues specific data keep synchronization cycle techniques database literature may adapted 
practice hashing operation needs performed entry time entry added data set complexity hashing bottleneck synchronization 
restrict entries bits avoid issues multiple precision arithmetic palm efficiently implemented known techniques 
finite field arithmetic performed victor shoup number theory library data transferred palm database file pdb format 
data converted data readable palm program prc tools 
noted pdb format stores data raw pda fig 

simple circuit measuring pda energy usage 
constant voltage source text digit integer stored byte long characters presumably avoid computational expense packing unpacking data 
maintain format testing insure fairness comparisons store bit numbers bytes 
metrics measurements major metrics comparing cpisync approaches communication time energy 
communication represents number bytes sent protocol link 
metric shown analytically cpisync upload entries pda slow sync require transfer palm entries 
communication complexity bloom filters linearly related data set size shown equation 
link pc pda protocols transmit updates 
time required synchronization complete latency probably important metric user point view 
slow sync dominant component latency data transfer time cpisync bloom filters computation time generally dominates 
experiments compute compare latencies cpisync slow sync bloom filters various scenarios 
synchronization latency measured time palm begins send data pc time pc determines differences databases 
results sections represent averages identical experiments 
third metric interest energy 
minimizing amount energy consumed syn events paramount importance extending battery life time mobile de vices 
total energy expended synchronization categorized follows cpu energy energy associated processing costs computing writing mem ory characteristic polynomial evaluations cpisync communication energy energy associated communications devices including processing costs encoding decoding transmitted data 
ideally energy consumption measured integrating product instantaneous current voltage values time represents total synchronization time 
fortunately experimental data shows palm pilot generally draws constant current constant voltage source different synchronization operations 
instance current intensity constantly ma data transmissions ma characteristic polynomial evaluations ma idle state 
able determine energy usage fairly accurately setup fig 
simply multiplying fixed current voltage values synchronization operation time taken operation 
comparison slow sync fig 
depicts superior scalability cpisync slow sync 
plotted time synchronization scheme function data set size fixed number differences data sets 
clear resulting graphs slow sync markedly non scalable time taken slow sync increases linearly size data sets 
cpisync hand independent data set sizes 
observe qualitative behavior cpisync similar fast sync 
remarkable property cpisync employed synchronization scenario regardless context fast sync employed previous synchronization took place pc pda 
fig 
compare performance cpisync slow sync data sets fixed sizes increasing number differences 
expected cpisync performs significantly better slow sync reconciling sets differ 
number differences sets grows computational complexity cpisync significant 
time seconds slow sy nc cpisync cpisync vs slow sync scalability database size records fig 

comparison cpisync slow sync demonstrating superiority cpisync growing sets data fixed number differences 
data set size differences table threshold values cpisync requires amount time slow sync 
exists threshold wholesale data transfer slow sync faster method synchronization threshold function data set sizes number differences data sets 
records depicted threshold corresponds roughly differences 
preparing graphs fig 
various different set sizes able produce sion coefficient determination analytically models performance time seconds cpisync slow sync cpisync vs slow sync time mutual differences records fig 

comparison cpisync slow sync sets having number differences sets 
elements 
synchronization time plotted function slow sync cpisync resulting threshold values listed table regression slow sync obtained fitting data linear function depends data set size cpisync regression obtained fitting data cubic polynomial depends number differences 
analytical models determine threshold set size number differences hosts 
palm pda application address book memo changes concurrent synchronizations typically involve small number records case cpisync usually faster slow sync 
predictably slow sync expends energy synchronize cpisync growing linearly database size seen fig 

particular database size records differences slow sync consume mah energy close times cpisync 
considering typical amount energy stored new battery mah observe cpisync provide significant energy savings respect slow sync 
hand cpisync time set cost depends database size shown fig 

cost due computation characteristic polynomial evaluations entire database uploaded pda time 
note databases smaller records cost operation smaller slow sync 
energy mah energy consumed synchronization cpisync database size records fig 

comparison energy consumed synchronization cpisync slow sync fixed number differences 
energy mah energy consumed cpisync setup database size records fig 

energy expended time setup cpisync including calculation characteristic polynomial evaluations 
comparison bloom filters section compare performance cpisync synchronizing kb long bloom filter described section ii 
number hash functions set reasonable compromise computational efficiency dictates small possible optimal number hashes needed minimize probability false positives 
synchronization latencies cpisync bloom filters depicted fig 
case machines records increasing number differences 
note bloom filters fixed latency component independent number differences 
latency component due computations performed pda pc bloom time seconds cpisync vs bloom filter time bloom filter cpisync mutual differences records fig 

comparison synchronization latency bloom filters cpisync records 
probability synchronization failure synchronization failure bloom filters mutual differences records fig 

probability bloom filter synchronization fail completely synchronize record databases increasing numbers differences 
filter order find pda elements pc missing 
computation time grows linearly size database presence absence element needs verified 
case slow sync observe existence threshold cpisync provides smaller synchronization latency bloom filters perform better 
fig 
threshold corresponds differences 
high cpisync perform better bloom filters majority practical pda synchronization cases 
discussed section ii important practical limitation bloom filters possibility synchronization failure due false positives 
problem false positive communication kilobytes communication synchronization slow sync bloom filter cpisync database size records fig 

comparison communication complexities number bytes transmitted slow sync bloom filter cpisync function data set size differing entries 
pda mistakenly believes pc certain data element hash function values corresponding data element pc bloom filter vice versa 
false positives consequently lead synchronization failures pda pc different databases highly undesirable situation users 
fig 
depicts probability synchronization failure function number dif ferences pc pda databases 
expected probability increases number differences differing data elements may lead false positives 
observe differences probability synchronization failure non negligible 
probability reduced increasing size bloom filter come additional communication computation cost 
note bloom filters may quite large memory requirements due need storing hash evaluations 
implementation supporting memory bloom synchronization took kb memory record database pda cpisync required kb metadata storage 
communication complexities slow sync cpisync bloom filters compared fig 
varying database sizes fixed number differences 
database size size bloom filter obtained values probability false positive number hashes 
expected fig 
shows communication complexity cpisync depend database size 
bloom filters synchronization achieves significant compression gain compared slow sync communication complexity grows linearly database size 
example records pc pda bloom filters require transfer kb cpisync requires slightly kb communication 
evaluation probabilistic scheme probabilistic scheme introduced section iii implemented various ways de pending metric interest 
section propose implementations optimization different metrics communication latency 
communication optimization may consider optimizing implementation probabilistic scheme respect amount communication needed synchronization 
case synchronize pda pc differ entries sending characteristic polynomial evaluations small constant determines probability error scheme see section iii 
scheme implemented follows pda sends pc evaluations characteristic polynomial small number pre determined sample points ad ditional pseudo random sample points chosen shared transmitted seed 
points interpolate rational function corresponding guess differ ences machines points verify correctness guess 
verification succeeds synchronization complete 
hand verification fails pc collects sample points seen far guess differ ences machines time requesting additional pseudo random evaluations pda confirm new guess 
procedure iterated verification succeeds point synchronization complete 
evaluations necessarily completely determine differences verification necessarily succeed evaluations 
time seconds cpisync completion time differences records fig 

model approach optimize latency synchronization bound known number differences data sets 
latency optimization may alternatively consider optimizing latency schemes time needed synchronization 
section show simple modification scheme section iii provide general probabilistic scheme completion time worst constant times larger time needed synchronize hosts number differences known priori 
modified scheme retains essential properties deterministic counterpart synchronization latency depends chiefly number differences hosts 
prove optimal bound scheme show achieve 
approach optimization part data fig 
reproduced fig 

fit data polynomial regression interpolates latency cpisync function number differences hosts 
exact value known start pda pc start initial guess upper bound 
fig 
initial guess corresponds value corresponds verification time seconds 
verification fails guess update bound value corresponds verification time times larger differences 
case fig 
chosen giving seconds 
iteration guess bound corresponds verification time continue verification succeeds guessed bound requiring verification time claim latency optimizing probabilistic scheme takes times longer deterministic scheme priori knowledge actual number differences 
proof denote synchronization latency known priori synchronization latency required probabilistic scheme 
furthermore denote time needed th verification round differences guessed hosts 
suppose correct upper bound obtained th iteration total synchronization time required probabilistic scheme simply sum geometric progression note assumed correct upper bound 
obtain easy check right hand side maximized meaning examining derivative respect finds function attains mini mum value leading optimal worst case ratio 
best policy scheme double verification time iteration 
fig 
illustrates performance probabilistic scheme compared deter scheme 
note probabilistic results remain guaranteed factor corresponding deterministic results 
vi 
shown current performance pda synchronization schemes tremendously improved sophisticated existing computational meth time seconds probablistic scheme vs deterministic scheme probabilistic deterministic lower bound deterministic upper bound differences records fig 

comparison probabilistic scheme known bound deterministic scheme value 
ods 
described analyzed novel implementation termed cpisync fast efficient pda synchronization 
implementation demonstrated possible syn remote systems scalable manner perspective communication bandwidth latency energy 
cpisync hosts deterministically reconcile data real environment communication complexity essentially depending number differences provided bound number differences 
demonstrated probabilistic scheme cases bound available 
scheme arbitrarily small probability error communication complexity additive constant deterministic scheme supplied exact number differences host sets 
analytical modeling shown latency probabilistic scheme designed factor latency deterministic scheme 
knowing number differences hosts reconcile communication latency depends number differences 
exper evidence phenomenon demonstrating reasonable scenarios cpisync substantially faster energy efficient current reconciliation scheme implemented palm pda 
cpisync outperform fast synchronization approaches bloom filters communication latency shown depend linearly data sets size 
cpisync algorithm described suitable specific application pdas general class problems difference data sets reconciled relatively small compared size data sets 
believe scalable architecture essential maintaining consistency large networks 
acknowledgments authors grateful yaron minsky stimulating discussions statistical advice 
palm developer line documentation palmos dev tech docs 
minsky set reconciliation nearly optimal communication complexity tech 
rep tr tr tr cornell university 
minsky set reconciliation nearly optimal communication complexity international symposium information theory june 
burton bloom space time trade offs hash coding allowable errors communications acm vol 
pp 
july 
li fan pei cao almeida andrei broder summary cache scalable wide area web cache sharing protocol ieee acm transactions networking vol 
pp 

agarwal scalability data synchronization protocols pdas mobile devices ieee network vol 
july 
www org 
kistler satyanarayanan disconnected operation coda file system acm transactions computer systems vol 
pp 

terry theimer petersen demers spreitzer hauser managing update conflicts bayou weakly connected replicated storage system proceedings th symposium operating systems principles copper mountain resort colorado december acm number pp 

ratner popek reiher guy peer replication selective control mda international conference mobile data access hong kong december 
cetintemel keleher franklin support speculative update propagation mobility deno nd international conference distributed computing systems 
denny wells edison enhanced data interchange services networks may class project uc berkeley 
abdel abbadi optimal strategy comparing file copies ieee transactions parallel distributed systems vol 
pp 
january 
data verification reconciliation generalized error control codes ieee trans 
info 
theory submitted 
minsky set reconciliation nearly optimal communication complexity ieee trans 
info 
theory submitted 
golding weak consistency group communication membership ph thesis uc santa cruz december published technical report ucsc crl 
harchol balter leighton lewin resource discovery distributed networks th annual acm sigact sigops symposium principles distributed computing atlanta ga may 
van renesse captain cook scalable navigation service preparation 
van renesse minsky hayden gossip style failure detection service middleware ifip international conference distributed systems platforms open distributed processing nigel davies kerry raymond jochen seitz eds 
pp 
springer verlag 
guo hayden van renesse vogels birman efficient gossip style garbage collection scheme scalable reliable multicast tech 
rep cornell university december 
data verification reconciliation generalized error control codes th annual allerton conference communication control computing october 
yao complexity questions related distributive computing proceedings th annual acm symposium theory computing pp 

silberschatz korth sudarshan database system concepts mcgraw hill third edition 
gnu multi precision library www com gmp 
shoup library doing number theory shoup net 
pilot prc tools sourceforge net projects prc tools 
applied linear regression john wiley sons 
agarwal fast pda synchronization characteristic polynomial interpolation proc 
infocom june 

