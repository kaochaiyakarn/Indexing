vldb journal manuscript 
inserted editor xml query engine network bound data zachary ives alon halevy daniel weld department computer science engineering box university washington seattle wa mail alon weld cs washington edu received date revised version date xml lingua franca data exchange integration administrative enterprise boundaries 
nearly data providers adding xml import export capabilities standard xml schemas dtds promoted types data sharing 
ubiquity xml removed major obstacles integrating data widely disparate sources heterogeneity data formats 
general purpose integration data wide area requires query processor query data sources demand receive streamed xml data combine restructure data new xml output providing performance batch oriented ad hoc interactive queries 
goal tukwila data integration system system focuses network bound dynamic xml data sources 
contrast previous approaches read parse store entire xml objects querying tukwila return query results data streaming system 
tukwila built new system architecture extends adaptive query processing relational engine techniques xml realm facilitated pair operators incrementally evaluate query input path expressions data read 
describe tukwila architecture novel aspects experimentally demonstrate tukwila provides better query performance faster initial answers existing systems excellent scalability 
supported part ibm research fellowship 
address dept computer information science university pennsylvania philadelphia pa 
key words xml query processing data streams data integration web databases years wide variety domains ranging scientific research electronic commerce corporate information systems great need able integrate data disparate data sources different locations controlled different groups 
biggest obstacles heterogeneity sources data models query capabilities data formats 
basic data sources custom wrappers need developed data source data integration mediator simply translate mediator requests data source queries translate source data format mediator handle 
emergence xml common data format support simple web query capabilities provided related xml standards suddenly data integration practical cases 
xml solve problems heterogeneity instance sources may different tags terminologies data providers come agreement standard schemas cases established database techniques defining resolving mappings schemas 
result xml standard format data dissemination exchange integration 
nearly data management related application supports import export xml standard xml schemas dtds developed enterprises facilitate data sharing instances published biztalk oasis web sites 
language see www biztalk org www xml org 
zachary ives system independent protocols various web services standards microsoft net net initiative sun jxta peer peer protocols xml represent transactions data 
processing integrating xml data poses number challenges 
data integration applications xml merely wire format result view live dynamic non xml source 
fact source may expose subsets data xml query interface access restrictions source may return data matching selection value typical web form 
data controlled updated externally available part difficult impossible cache data 
data sources may located wide area network internet queries executed way resilient network delays 
sources may relatively large mb may require appreciable amount time transfer network parse 
refer types data sources network bound available network data obtained reading parsing typically finite stream xml data 
point integration network bound live xml data studied 
xml database community focused designing xml repositories warehouses aea tam gmw fk km bbm sgt exporting xml relational databases fts fms cfi adding information retrieval style indexing techniques databases fmk supporting query subscriptions continuous queries aea af provide new results documents change added 
clearly warehousing indexing useful storing archiving retrieving file xml data documents integration applications support queries dynamic external data sources essential 
requires query processor request data sources combine data additional requests data sources result 
best knowledge existing system provides combination capabilities 
web community developed class query tools restricted single documents scalable large documents 
database community web xml query engines niagara xyleme come closer meeting needs data integration oriented smaller documents may indexable give little consideration processing data slow sources xml larger memory 
query processing data integration poses number challenges data tightly controlled exclusively data integration system 
example query optimization difficult absence data source statistics 
subjects focus adaptive query processing research discussed rs wa hs uf hh iff uf ufa kd ah 
adaptive query processing research generally focused relational query processing xml 
major advantages offered relational query processing pipelined execution model new tuples read directly network fed query plan 
presents number significant benefits data integration enabling adaptivity single execution pipeline require materialization operations pre parsing preprocessing xml document initial answers returned quickly 
satisfies important desideratum interactive data integration applications 
single pipeline provides opportunities exploiting parallelism flexibly scheduling processing tuples 
enables techniques pipelined hash join rs wa hs uf hh iff eddies ah 
pipelining adaptive query processing techniques largely confined relational data model 
contributions new xml query processing architecture emphasizes pipelining xml data streaming system facilitates number adaptive query processing techniques 
described section xml queries operate combinations input bindings patterns matched input document pattern match binds input tree variable 
query processor iterates possible combinations assignments bindings query operators evaluated successive combination 
glance quite different tuple oriented execution model relational world closer examination reveals useful correspondence assign attribute tuple variable view legal combination variable assignments forming tuple binding values values xml trees content 
describe xml query processing architecture implemented tukwila system exploits correspondence relational xml processing models order provide adaptive xml query processing capabilities support efficient network bound querying presence xml query engine network bound data delays dynamic data source failures 
architecture includes novel features support efficient processing scalar structured xml content 
architecture maps scalar text node values tuple oriented execution model retains efficiencies standard relational query engine 
structured xml content mapped tree manager supports complex traversals paging disk comparison identity value 
pair streaming xml input operators scan web join enablers adaptive query processing architecture 
operators transforms incoming stream xml data internal format processed query operators 
scan matches query xpath expressions input xml stream outputs set tuples elements bindings subtrees xml data 
web join viewed combination scan dependent join takes values input source uses construct series dynamic requests internet sources joins results 
set physical level algebraic operators combining structuring xml content supporting core features xquery bcf world wide web consortium xml query language specification nearing completion 
describe tukwila architecture implementation detailed set experiments demonstrate tukwila xml query processing architecture provides superior performance existing xml query systems target domain network bound data 
tukwila produces initial results rapidly completes queries time previous systems scales better large xml documents 
result scalable query processor network bound live xml data 
validate tukwila performance comparing leading xslt data integration systems number different classes documents queries ranging document retrieval data integration show tukwila read process xml data rate roughly equivalent performance sql jdbc protocol network show tukwila performance scales complexity path expressions increased show tukwila scan operator scale large mbs graph structured data 
remainder structured follows 
section describes basics querying xml section begins describing standard techniques xml query processing finishes presenting tukwila architecture emphasizing differences 
describe xml query operators cost model section operators extended support graph data model section 
section provides experimental validation 
section discusses related conclude section 
querying xml past years numerous alternative query languages data models xml proposed including xml ql dff xslt xsl 
xslt single document language consisting rules rule matches particular path xml tree applies transformation underlying subtree 
xml ql data oriented query language adapted semistructured database community join data documents document oriented features 
world wide web consortium combine features languages xquery language specification bcf accompanying data model 
xquery data model defines xml document tree ordered nodes different content types element processing instruction comment text element nodes may unordered attributes 
example xml document modeled tree 
diagram represented elements labeled nodes text content leaf nodes attributes annotations element nodes special attributes dashed edges elements targets target element identified typed attribute name 
xquery language designed extract combine subtrees data model 
generally return structure commonly known flower expression clause provides series xpath expressions selecting input nodes clause similarly defines collection valued expressions clause defines selection join predicates return clause creates output xml structure 
xquery expressions nested areturn clause create hierarchical output oql language designed modular composable expressions 
furthermore xquery supports features sql oql arbitrary recursive functions 
xquery execution considered variable binding stage andlet xpath expressions evaluated traversals data model tree root 
tree matching zachary ives db book publisher mkp title readings database systems title editor stonebraker editor editor hellerstein editor isbn isbn book book publisher mkp title transaction processing title fig 
sample xml document representing book publisher data book publisher mkp db publisher mkp author bernstein author author newcomer author isbn isbn book id mkp name morgan kaufmann title city san mateo city state ca state db title editor editor isbn title book author author id mkp stonebraker readings hellerstein database principles systems transaction processing isbn city state bernstein newcomer name san mateo ca morgan kaufmann fig 
graph representation 
dashed edges illustrate relationships defined idrefs dotted edges point text nodes 
xpath bound clause variable 
xpath multiple matches clause iterate bind variable executing query return clause assignment 
clause return collection matches variable binding 
query typically numerous assignments legal combinations assignments created iterating various query expressions 
example xquery appears 
see variable assigned book subelement element xml assigned title book forth 
version xpath includes extensions allowing disjunction edge editor author kleene star operator shown 
example multiple match combinations possible variable binding process performed way 
variable bound 
variables bound order author subelements respectively 
possible pairing values binding evaluated separate iteration process repeated value observe process virtually identical relational query join books titles authors result document books xml db book title data editor author data return item person person pub pub item result fig 
xquery query finds names people published publications 
clause specifies xpath expressions describing traversals xml tree binds subtrees variables prefixed dollar signs 
tuple possible title editor author combination book 
significant difference terminology xquery iteration produces binding variable relational system tuple value attribute 
clause specifies tree structured xml constructor output iteration variables replaced bound values 
note variables xquery bound xml subtrees identified root nodes scalar values 
result example query appears 
element output possible combination bindings 
xml query engine network bound data result item person stonebraker person pub readings database systems pub item item person hellerstein person pub readings database systems pub item item person bernstein person pub transaction processing pub item item person newcomer person pub transaction processing pub item result fig 
result applying query xml data 
note xml data idref attributes represent links elements dashed lines 
idrefs allow xml encode graph structured tree structured data 
current xquery proposal limited support idref traversal offering traversal fixed number edges transitive closure 
interesting applications xml data investigate querying extended version xquery 
previous approaches xml processing discussed previous section xml data model xquery language considerably complex simple relational query processing reliance path expressions 
particular hierarchical nature xml typically means document normalized single relational table set tables parent child foreign key relationships 
people generally attempted handle xml processing problem methods focus techniques xml tables combining tables re joining results produce xml output modifications objectoriented semi structured databases inherently support hierarchy support xml top tree traversal strategy executing queries custom wrapper source retrieval necessary content 
describe tukwila architecture useful briefly examine previous approaches including relative strengths weaknesses 
relational databases variety research projects inria fk labs dfs fts fms ibm almaden cfi sks university wisconsin sgt focused problems mapping xml data relational databases 
today major relational dbms vendors build provide support form xml export 
general results suggest relational database generally ideal storing xml xml data originates relational tables slow change may acceptable solution 
significant benefits include scalability support value indexes drawbacks include expensive document load times expensive reconstruction xml results 
relational query optimizer improve performance significantly xml query maps simple sql frequently poor decisions complex queries optimize knowledge xml semantics 
object oriented semi structured databases major commercial oodbs including poet object store adapted form new xml databases 
provide benefits strictly relational engines locking indexing structures designed hierarchical data oo query optimizers generally relatively weak 
lore semistructured database gmw number special indexing structures adapted xml performance shown poor relative relational system storing xml fk 
native xml databases km bbm mam development 
systems focus issues relating efficiently storing traversing hierarchical objects indexing 
details please see discussion related section 
web oriented dom processors techniques mentioned focus storage retrieval xml content 
course xml expected format content transmission networks content transient nature need systems format query combine storing 
domain entirely different class query processors developed 
processors xt xalan xslt engines niagara system university wisconsin typically parsing xml document memory dom tree traverse tree xpath expressions extract specified content combine form new document 
transient data small size performs better zachary ives storing data disk querying limited available memory producing answers input document parsed 
large document slow internet connection may significant delay 
web oriented processors mix system university california san diego webbased pull lazy xml evaluation method query processor request specific regions data mediator required 
allows better scalability dom approach suffers potential problems 
requires custom wrapper source processes pull messages 
second major costs wide area communication round trip time pull method requires considerable communication data source consumer 
tukwila xml architecture intent designing tukwila system provide scalability query optimization full fledged database maintaining interactive performance characteristics web systems 
want able support naive producers xml content take advantage complex systems process queries portions queries directly 
tukwila project investigates query optimization execution integrating network bound xml data shall focus query execution architecture operators 
brief discussion query optimizer cost model appears section 
tukwila architecture observations 
basic execution model xquery similar relational databases xquery evaluates clauses possible combination input bindings combination bindings viewed tuple 

clauses bind input variables xpath expressions typically traversals xml parse tree structure occasionally selection join predicates 
majority xpath expressions traverse downward forwards direction matches order parser encounters xml elements reads input stream 

selection join predicates xquery involve scalar text node data complex xml hierarchies 
bindings hierarchical xml data commonly clause 

majority xml processors dom parsers construct entire xml parse tree query processing begins 
incremental parsing combined pipeline execution relational databases produce significant benefits 
reduce time answers results percolate query plan quickly 
second increased parallelism pipelined operators allows adaptive scheduling allows query processor overlap computation iff prioritize important uf 
observations designed architecture particularly efficient query execution 
tukwila execution engine core operations performed queries path matching selecting projecting joining grouping scalar data items 
engine support operations low overhead fact approach relational engine performance simple queries 
query execution engine emphasizes pipelined execution model tuple consists bindings xml content simple scalar attributes 
gives time tuple benefits cited previously benefit leveraging best techniques relational query processing 
high level view tukwila architecture illustrated 
query optimizer passes plan execution engine leaf nodes plan scan operators 
scan operators retrieve xml data data sources parse traverse xml data matching regular path expressions store selected xml subtrees xml tree manager output tuples containing scalar values subtrees 
tuples fed remaining operators query execution plan combined restructured 
flows operators near top query plan tuple annotated information describing content output xml content tagged structured 
xml generator processes tagged tuples returns xml result stream user 
sense middle portion architecture represented query operators box page manager resembles specialized object relational database core 
tuples contain attribute values note operators fairly large class queries answered pipelined operators 
xml query engine network bound data user application query query optimizer xml sources xml data xml data xml generator query plan scan operators tukwila xml engine partly tagged data query operators binding tuples sub val val val val sub xml tree manager page manager sub val val val val sub 
temp storage fig 
architecture tukwila query execution engine 
query plan arrives optimizer data read xml sources converted scan operators output tuples subtree bindings 
subtrees stored tree manager backed virtual page manager tuples contain trees 
query operators combine binding tuples add tagging information fed xml generator returns xml stream 
bound variables values scalar stored directly tuple xml structures similar character large objects database xml structures stored separately tuple xml tree manager virtual memory manager xml subtrees 
note attempt support object oriented types implement methods 
tuples pipelined query plan contain subtrees tree manager multiple variables bound xml tree data need duplicated 
query operators manipulate tree manager values embedded tuple object operations possible including grouping nesting aggregation 
xml subtrees counted garbage collected tuples referring processed system 
tukwila architecture allows leverage number components relational world basic memory management strategies operators straightforward adaptive query processing operators appropriate query semantics 
discuss tukwila query operators 
pipelining xml data virtues flat relational model extreme flexibility representation 
example relations order independent joins non order preserving algorithms 
techniques query decorrelation 
predicates evaluated early late depending selectivity 
hierarchical data model xml intuitive data consumer centers particular concept natural model execution breaking query levels hierarchy necessarily efficient 
restrictive hierarchy ordering default xquery procedural specifying order iteration bindings implicit order evaluating nested queries forth 
possible execution model xquery resemble nested relations fact recursive algebras nested relations operators operate level nesting data proposed implemented hsr col 
preference mapping xml hierarchical xml resembling flat relational model xml document gets converted relation attribute represents value variable binding position encoded counter byte offset information 
binding may contain arbitrary xml content nested relational model query may manipulate top level structure 
nested structure expanded manipulated 
architecture allows directly leverage relational query execution optimization techniques understood provide performance 
believe particularly case data integration get better performance execution model preserves structure flat query operators key reasons 
data integration scenarios require significant restructuring xml content anyway little sense spend overhead maintaining structure lost 
second unnesting operations inexpensive scan algorithm provides low overhead way unnest content insert additional metadata tuple easy re nest re order values 
third believe inherent overhead building algorithms preserve multiple levels hierarchy result feel risc philosophy appropriate 
zachary ives book name publisher pid pi pr element book name pid pi element pr pub publisher output pid pi element name pr pub output pid pub result book publisher 
pid pi pr scan scan db book pid publisher title books amazon name publisher pid pi pr name pid pi pr pid pi pr pub book item pub title pub source pi id pr price pub pub pub pi pr pub pi pr pub fig 
query plan includes pair scan operators compute input bindings join sources series output element operators copy desired variables output construct xml elements 
document books xml db book pid publisher title data pub document amazon xml book item pub title data pub source pi id pr pub price data pr pid pid return book name name publisher publisher book fig 
query returning titles publishers books priced amazon 
plan query shown 
example shows physical query plan tuple encoding simple xquery 
scan operators leaves convert xml streams tuples binding variables nodes matched regular path expressions 
general query operators selects joins performed tuples select priced join results books pub values 
appropriate binding values selected joined output xml tree generated variables content 
output operator responsible replicating subtree value binding query constructed output 
element operator constructs element tag specified number xml subtrees 
output subtree shown different stages construction output insert aname element output publisher element tag take subtrees place book element 
step stream tuples converted back stream actual xml 
subsequent sections describe detail tukwila encodes xml structural information including tags nested output structure order information 
encoding xml tags xquery single re turn clause builds tree inserts bindings tree 
tree essence template output binding tuple 
tukwila need encode tree structure attach tuple 
adding special attributes tuple describe structure left preorder form 
benefit encoding need pointers parent nodes children non leaf node specifies count xml query engine network bound data bindings constructed xml result tree lst fst nm ad fst lst name ad nm publisher book name book publisher lst fst nm ad fig 
encoding tree tuple query 
encoding done bottom fashion parent element needs specify number children 
arrows visualization 
tree leaves attributes containing bindings 
subtrees lie underneath decoding algorithm simply expands subtree recursively 
shows schematically tree right half encoded tuple left half 
leftmost entries tuple values variable bindings contain data values directly part xml document construction 
xml fragment represented tuple decoded follows start rightmost item tuple book represents book element children indicated output book tag 
traverse leftmost child element moving left attributes yields name children 
traverse left child instructed output fst attribute 
visit sibling lst output value 
course encoding mentioned assumes parent child relationships returned output element occurs combination input bindings 
common contain correlated nested subqueries embed results iteration outer query 
encoding nesting mentioned previously want capture hierarchical nesting xml results encode nested relations 
flatten results single parent tuple child tuples represented wide tuples parent child information 
xml hierarchy decoded grouping tuples parent content 
approach support proper bag semantics duplicate parents combined fairly costly parent attributes matched 
adopting approach insert additional attribute encodes parent sequence id group tuples id find children common parent 
note flattened encoding gives query processor opportunity arbitrarily re order tuples point potentially distributing consecutive data items tuple stream long performs sort 
worth noting tuple encoding approach similarities outer union encoding implemented cfi ssb microsoft sql server xml explicit mode encode branches subquery hierarchy xml data hierarchy 
result seldom null values tuple stream 
encoding order tukwila path matching algorithms insert attributes record position binding encoding byte offset xml stream ordering relative matches variable 
note distinct concepts especially 
adding ordinal attribute tukwila may preserving join operators maintain xquery ordered semantics simply sorts data outputting 
generating xml output converting tuple stream xml stream requires steps traverse xquery return clause constructor embedded tuple outputting appropriate structure retrieve embed referenced xml subtrees correctly output hierarchical xml structure may span multiple tuples 
step traversing tree structure embedded tuple consists starting rightmost output attribute recursively traversing tuple encoded tree described section 
time leaf node encountered second step performed referenced xml subtree retrieved tree manager replicated output 
steps values encoded tuple output necessarily case grouping nesting attributes zachary ives 
nested structure represented tuple consist data parent relation followed data child relation 
clearly parent data output entire group 
easily determined testing parent id attribute changed successive tuples 
groups grouped nested process scales arbitrary depth 
xquery semantics outer join possible publisher books 
case book attributes tuple set null values xml decoder simply outputs publisher attributes book content 
sections describe tukwila query operators tuple encoding 
operators produce tuple stream scan web join operators 
streaming xml input operators tukwila support streaming xml input differentiates xml query processors 
support provided different operators take input xml stream set xpath expressions return tuples trees representing combinations variable bindings match 
simpler operator scan performs xpath matching specified input document 
web join operator adds mechanisms supporting data dependent queries dependent join relational system provided stream independent tuples web query string generated inserting values current tuple query generating expression query request performed resulting xml document pattern matched xpath expressions 
matching bindings combined original independent tuple produce cartesian product 
scan querying static predetermined web sources web join allows tukwila dynamically query combine numerous sources 
intuition streaming xml input operators xpath expression greatly resembles regular expression alphabet consists element attribute labels simulated finite state machine 
tukwila uses event driven sax xml parser match input path expressions xml stream parsed variable binding created time state machine reaches accept state 
bindings combined form tuples pipelined system supporting output xml results data stream read 
finite state machine match xpath expressions natural algorithms supporting details xpath combining bindings supporting efficient execution quite complex 
best knowledge tukwila unique creating xml query results directly data stream finite state machines result shows significant performance scalability benefits systems 
systems niagara fetch parse entire input xml document construct complete dom representation memory match path expressions tree pass results query operators 
xslt processors xalan xt similar recursive pattern matching semantics set query operators 
xml query processors designed operate xml local warehouse 
interesting system query processor bears resemblance tukwila dbis system xfilter af operator dbis takes xml documents determines meet specific xpath expressions pushes subscribing users :10.1.1.29.2817
dbis performs document filtering query processing xfilter operator binary match non match return value differs substantially scan functionality 
xml toolkit builds xfilter proposes lazy approach building deterministic finite state machines nondeterministic path expressions 
details streaming xml input operators scan 
scan operator xml text stream set regular path expressions inputs scan incrementally outputs stream tuples assigning binding values variable 
binding value typically tree case tuple contains data tukwila xml tree manager scalar value value may inlined directly tuple 
depiction scan data structures appears xml stream processed event driven sax parser creates series event notifications 
xml data stored xml tree manager matched series finite state machines responsible xpath pattern matching 
state machines produce output binding values combined produce binding tuples 
fact xfilter scan operators developed concurrently 
xml query engine network bound data xml stream db book publisher 
title read 
editors name ston 
sax events element book attrib pub 
element name text 
xml tree manager db book publisher title read editors name ston 
state machines scan process db book editor author title state machines fig 
query bindings re 
st 

binding tuples st 
re 

re 
fig 
scan takes xml document maps xml tree manager simultaneously running state machines parse tree 
state machine creates variable bindings combined produce binding tuples 
solid arcs denote state transitions label dashed arcs denote dependencies machines 
basic xpath expressions restricted form regular path expressions scan converts xpath expression regular expression generates corresponding nondeterministic finite state machine converts deterministic machine reasons discussed section 
xpath expressions originating document root initialized active mode active machines states updated scan encounters subelements attributes document parsing 
shows state machines created example query 
initially top level machine example active 
machine reaches accepting state produces binding variable associated 
machine activates dependent state machines remain active scan scanning value binding 
example machines mn mt remain active scan children associated machine table binding values 
machine reaches accept state adds entry containing bound subtree value association entry parent binding shown dashed arrow parent child shall discuss additional non path oriented xpath features section implementation store subtrees value 
expository simplicity write nodes stored id attributes stored value 
example mb table just store values mn mt store author editor names titles respectively associated corresponding values 
final output essentially join entries maintained machines done matching parent child pairs done data driven iterator model pipelined hash join wa 
illustrate execution scan example data 
suppose mb initialized machine state takes xml root start position 
node virtual node representing entire document child db node 
follows edge node setting mb state 
scan follow outgoing edges book nodes 
chooses leftmost readings database systems causing set mb state 
mb accepting state scan writes current node table suspends mb activates mn mt editor element takes mn state accepting state mn 
scan writes stonebraker pointer current book 
follows arc element putting machine state accepting state 
tuple title book written mt table 
node non text children remain exploration scan pops stack backs state machines 
sets mb state continue explore second book node proceeding 
zachary ives point described scan performs simple path expression matching 
xpath supports capabilities mere path matching features provided scan 
querying order node indexing xpath expressions may restrict bindings ordering information constraint subelement index number nd paragraph subelement relative positions bindings 
scan supports capabilities scan state machines annotated counters keep track element indices output scan include binding index absolute position 
select operator filter tuples order 
selection predicates useful capability scan ability apply certain selection predicates variable bindings subtrees 
simple predicates values bind book titles value transaction processing similar predicates sac 
additionally supports existential path tests return books titles 
existential quantification path similar path expression binding returned 
forms existential quantification possible implemented correlated subqueries traditional relational techniques 
node test functions xpath expressions include node tests restrict type xml node selected text comment 
similarly xpath edge sign prefix represents attribute node 
conditions expressed scan state machines restrictions xml nodes matched 
traversing reverse current implementation scan evaluate xpath parent axis traverse backwards tree 
tukwila query optimizer rewrites path expressions parent operator splitting child binding 
conditions evaluated child met parent 
process may times efficient supporting true parent traversal expect parent axis uncommon 
efficiency enhancements scan include number optimizations boost xml parsing processing performance 
avoid processing xml content handling sax parser messages state machines inactive important avoid unnecessary copying handling string data 
additionally instant evident subtree satisfy xpath expression meet predicate missing attribute deactivate state machines subtree reached 
expected complexity state machines scan uses deterministic finite state machines exponentially larger nondeterministic machines derived xpath expressions tend short queries depth rare 
furthermore xpath supports restricted version regular path expressions kleene closure limited simpler wildcard descendent operations 
handling memory overflow typically scan needs little working space outputs stream binding tuples sets subtrees little state needs maintained production tuples 
cases may run memory 
xml data referenced may larger memory 
xml tree manager paged data structure segments data swapped disk needed 
course result large xml file produce thrashing swap file query processing 
experiments section suggest typically avoided attribute factors 
system supports inlining scalar values string integer small data items embedded directly tuple avoiding dereferencing operation 
typical query operations xquery done scalar complex data joining sorting frequently string values operations need data inlined 
large complex tree data typically required xml generation stage final results returned 
second mitigating factor xml queries tend access input document sequential order tree manager avoid re reading data paged 
purposes comparison point paged dom approach similar behavior scheme memory representation xml larger dom tree typically times larger dom heavyweight nature mapping xml relations xml typically requires significant amount materialization place incurs heavy costs needs perform joins recreate irregular structure 
xml query engine network bound data second memory overflow case may occur trees high fanout sibling bindings scan return combinations 
take query example authors alternative titles book scan return possible title author pairing book 
accomplish scan maintains current value plus tables bindings 
values added combined existing values process works similarly new values time new value encountered tables flushed process restarted 
extreme case tables may grow larger memory case handled manner similar pipelined hash join overflow strategies uf iff 
web join operator scan operator analogous sequential table scan relational databases wrapper fetch operation relational data integration allows query processor read xml document extract relevant content 
source sophisticated query capabilities certain operations may fact pushed scan query request 
distributed query processing beneficial dependent join operator traditional table scan join operators 
requesting data independently sources joining dependent join reads data source sends data source requests matching values combines data sources 
operation particularly useful cases join second source highly selective data transferred dependent join 
second source requires input values return answer source may online web forms interface requires author title equivalent notion binding patterns relational data integration kw 
web context query data source generally provided means request get post soap call form query xquery 
domains propose web join operator 
web join intuitively similar combination scan operator relational style dependent join receives input tuple stream query generating expression shown schematically lower left string underlined parame xpath expressions root subpath 
query request query generating data source expression site org val binding tuples scan xml query result input tuple joined output tuples fig 
web join operator takes input tuple substitutes values query generating expression 
expression web request queries data source results matched set xpath expressions operator 
resulting tuples joined original input tuple produce set results query processing 
ters reality string expression 
parameters query generating expression instantiated values input tuple stream resulting query string evaluated uri string post sequence soap envelope 
xml resulting request evaluated xpath expressions embedded operator 
resulting binding tuples joined original tuple output 
process repeats tuple original input stream 
web join important operator querying dynamic sources especially ones embedded uris 
allows query processor lazy evaluation tukwila request initial data execute filtering operations request additional content elements remain 
tukwila xml query operators optimization previous section query operators responsible mapping xml data stream stream tuples 
describe query operators process data 
logical query algebra usually designed expressive minimal 
contrast set physical query operators needs predictable performance optimizer cost model easier build efficient implementations specific contexts optimizer choose appropriate implementation 
constructed physical algebra tukwila focused providing efficient support zachary ives executing relatively expressive core xquery focus point supporting full language 
currently support recursion typechecking conditional assignments 
implemented small subset proposed xquery function library 
feel current implementation sufficient demonstrate queries executed quickly eventually extended include absent features 
complete list operators summarized table provide detail 
query operator classes streaming input scan web join streaming input operators discussed section 
path evaluation follow operator path traversal operator 
takes input binding tuple evaluates xpath may involve xlink originating bindings returns sequence binding tuples 
scan little overhead follow primarily useful graph structured document combination filter operators identical standard relational equivalents 
notable exception collector operator proposed iff starts reading data sources switch alternate sources depending availability performance 
additional operator assign adds new attribute binding tuple assigning result scalar expression 
expression may posed terms bindings string concatenation 
second order second order operators process sets bags tuples 
nonstandard operator aggregate takes stream tuples representing subquery content nested parent query content parent computes aggregate value children 
similar relational group operator exceptions grouping information result group operator discussed nested data group preserved discarded 
expect xlink traversal frequently operations defined implemented operator feature 
nesting operators second order separate special role xml encoding 
group operator hierarchically restructures tuples set tuples identical set grouping attribute values operator conceptually outputs single tuple grouping attributes plus embedded tuples non grouped attributes 
section described nested structure encoded flat tuples provide tuple group unique id identifier parent tuple non grouped attributes child tuple group primarily useful providing relational style groupby extracting common structure flat xml 
nested flwr query expressions basic idiom xquery handle case operator semantics similar relational left outer join 
takes parent child tuple stream plus correlation predicate 
parent tuple finds set child tuples meeting predicate groups parent tuple 
time groups parent xml subtree children xml subtrees 
note nested relational algebras derivatives include unary operator called nest closer nature group operator 
systems type algebra perform operations join nest achieve effect doing redundant 
join operator typically allowed output results order semantics require nested loops join ordering child values returned parent 
encode hierarchical tuple described section preserves information determine flat tuples contain parent tuple 
approach order preserving operators pipeline encoded structure way output result hashing sorting algorithm cluster tuple groups convert xml 
result operators responsible creating output xquery 
construct output xml tree applied postfix ordering 
output operator creates leaf node output simply outputs result binding string value 
attribute wraps result output node specified xml attribute name may literal value binding 
element constructs xml element nodes may result previous output attribute operations constant specified query xml query engine network bound data table physical query operators algorithms tukwila name class function scan streaming input match input path expression web join streaming input query bound vars 
follow path evaluation evaluate xpath binding select combination filter filter tuples predicate project combination filter discard bindings hybrid hash join combination filter equijoin pipelined hash join combination filter equijoin merge join combination filter ordered equijoin nested loops join combination filter order preserving join union combination filter relational style union collector combination filter union fail assign combination filter evaluate expression distinct nd order remove duplicates sort nd order reorder tuples aggregate nd order compute aggregate group nesting correlated nesting elements group nesting group restructure sets elements output result output binding xml element result create xml element attribute result create xml attribute attribute label may literal value binding 
optimization cost model complete description tukwila query optimizer scope provide better perspective query execution process briefly discuss optimizer cost model 
tukwila focuses ad hoc queries remote data sources source xml data arbitrary complexity query optimization component able initial statistics underlying sources 
developed technique called convergent query processing ive enable query processor incrementally execute plan re optimize gets improved statistics data sources expected number tuples produced scan operator particular source apparent actual selectivity join adapt query plan efficient having redo 
convergent query processing essentially optimizer cost model statistics match real world conditions performance optimizer pick better plan improve running times 
query optimizer system sac style dynamic programming optimizer optimizes physical level 
tukwila cost model looks relational dbms recursively builds cost cardinality estimates increasingly larger subtrees query plan starting leaves 
estimate periodically re estimate number tuples scan operator produce including fan step scan path expression 
cardinality scan perspective tuple processor optimizer 
rate tuple production estimated need re estimated frequently quickly change due variations xml structure congestion network 
cardinalities expected rates production leverage existing relational query optimizer cost estimation techniques remaining operators plan 
costs relational operators join estimated just original context remaining xml operators generally close equivalent relational world implemented join easily predictable cost element creates new tag input tuple 
initial query optimization tukwila typically done statistics case typically estimate xml element fan level successive level standard system heuristics selectivity estimation 
execution begins obtain accurate estimates selectivity cardinality values get better query plan 
detailed discussion tukwila query optimizer appears ive plan publish extensive evaluation optimizer 
note xml queries significantly zachary ives queries depend heavily query optimizer decisions query optimizer focuses ordering join nesting grouping operators queries selection single join minimally impacted optimizer decisions 
matters performance query operators particularly scan 
basic set operations described section tukwila execute core database subset xquery avoids conditionals recursive functions type information 
additionally xquery heavily tree oriented query language support graph structured data tukwila describe section 
supporting graph structured data tukwila point tukwila query processing system assumption data completely tree structured structure mirrored xml element attribute hierarchy 
xquery data model language support limited forms encoding graphs xml idref attributes document outside document 
section briefly describe issues involved supporting operations 
join traversal conventional way evaluate idref join operation example suppose allow single idref xpath 
evaluate expressions take separate pre idref traversal post idref traversal steps 
scan input document pre idref 
parallel scan document elements ids evaluate post idref 
join results idref scan matches originating id second scan 
similar techniques support xpath 
xquery support kleene closure query fixed number traversals technique 
join traversal method effective links situations potential drawbacks 
standard join algorithms short circuit idref matched target id know precisely match 
alternative means discuss move soon current matched fully pipelining results 
second join traversal works belong target document 
follow traversal second option supports tukwila follow operator 
idref follow xpath match memory xml document output prior scan returns set bindings 
idref traversal follow index id elements created scan operation 
index described 
follow intuitively scan operates tuples trees xml documents 
set path expressions input tuple stream xml trees follow adds new variable bindings input tuples evaluating path expressions trees tuple 
pattern matches multiple subtrees tuple set tuples returned possible binding combination 
operator essentially special case map operator object oriented algebras 
follow reasonable option evaluating 
link opens referenced document evaluates xlink path expression select desired xml data matches remainder query xpath document fragment manner similar scan web join 
graph traversal scan shall see experimental evaluation scan state machine infrastructure adds little overhead performing xpath matching xml tree 
xpath traversal document tree structure generally done scan level 
traversals done scan level shall see performs reasonably moderately sized documents contain large numbers 
discuss extensions necessary scan 
difference addition new data structures shown upper left corner id index records elements matching locations xml data 
facilitate resolution graph 
xml query engine network bound data id index id id 
xml stream db book publisher 
title read 
editors name ston 
unresolved idrefs id 
structural index sax events element book attrib pub 
element name text 
xml tree manager db book publisher title read editors name ston 
state machines bindings re 
st 

binding tuples st 
re 

re 
fig 
graph execution scan uses new data structures upper left 
index records positions xml data graph unresolved index maintains list idrefs resolved structural index physically encodes element attribute relationships 
unresolved id index maintains list seen resolved input 
structural index provides index xml graph corresponding data values leaves 
necessary speeds scan traversal graph memory 
scan processes graph structured xml generates structural index trie index xml graph structure subelement idref links 
index allows scan quickly traverse back xml structure evaluating 
addition explain construction structural index continues need suspend state machines 
index intended lifespan query built memory paged necessary 
expect scan generally traverse moderately sized graph data follow joins larger documents paging index seldom occur 
node index contains information element id offset original xml data file node source accessed quickly pointers subelements attributes idrefs element 
essentially index structure looks graph data values leaf pcdata nodes stored 
addition scan creates index records encountered far mapping id entry structural index unresolved id index records ids seen input lists 
scan general execution proceeds similarly tree structured case element encountered traversed regular path expression 
element parsed backward state machines run target structural index parsing continues 
forward occasion scan encounter edge points ahead node parsed 
scan hits forward pauses state machines adds entry list symbols specifying desired id value referrer address 
scan continues reading xml source building structural index 
target element parsed scan fills address structural index removes entry list awakens state machines proceeds 
approach causes scan output stall waits resolved empirical results shown help structural index scan recovers quickly 
worst case scan query processor dom builds structure memory quickly traversed dom implementations familiar scan execute structure paged disk exceeds virtual memory 
cycles order avoid cyclic traversals scan maintains history nodes visited automaton state path traversal 
scan uses deterministic automata machine re visits node encountered state path cycle aborted 
conceptually scan continue state machine operation target insert target return matches continue normal operation simplicity coding implementation 
zachary ives general guidelines traversal number ways supporting graph structured data tukwila system 
methods different capabilities performance results set guidelines optimizer choose best mechanism evaluating graph context 
noting scan operator efficient strictly tree structured data believe seldom sense join follow methods traverse idrefs 
query processor scan evaluate segment xpath traversal 
type evaluated important noted earlier join method evaluating 
scan implementation follow traversal quite expensive probably done leaf level operation 
follow operator option 
documents low number traversal approach works 
large number evaluated join follow alternatives look promising 
follow operator unary operator requires scan document traverses xml data may result thrashing document larger memory 
join operator cause thrashing combines tables completed single pass requires separate scans input document 
experimental results seen details tukwila query engine tree structured graph structured data move experimental validation system 
implementation written 
originally wrote system windows apache xerces xml parser core scan implementation 
migrated slightly slower linux machine james clark performed faster xml parsing 
experiments implementation comparing xml pattern matching experiments section relied windows machine memory scalability experiments faster memory 
system architecture client server model java client submits queries soap reads times xml results 
experiments measured performance tukwila engine mhz pentium iii machine gb ram allocate subset tukwila windows server mentioned studies xml pattern matching performance section ran tukwila mhz pentium iii mb ram red hat linux 
cases xml documents served web server dual pentium ii mhz system mb ram running windows iis 
web server query processing machine communicated mb fast ethernet machine separate subnet larger scale network 
experiments run warm repeated times error bars included queries confidence interval 
experimental data sets chosen encompass range different xml data classes listed table 
include real documents real semistructured data semistructured data generated xmark xml query benchmark swk synthetic data relational tables saved xml format 
synthetic data data set created designed random variation depth distribution idrefs 
data set generated process replicate core xml subtree specified number times randomly attach different points current document probability attaches root 
designated number edges added random pairs endpoints 
proposing new model query execution comparing tukwila performance systems traditional approaches 
look scalability performance tukwila database style operations including join examine hierarchically nesting xml content limits performance restricts order look tukwila scan algorithm support idref traversal graph structured data 
xml extraction queries clearly core operation heart xml processor pattern matching xml content extraction step fact tukwila approach differs implementations 
set experiments focuses comparing relative performance tukwila systems extracting xml content xpath expressions 
suite queries described table consists mix text xml query engine network bound data table data sets experiments 
name size description religion mb concatenation collection religious texts bible book xmark mb scale factor xmark auctions file xmark mb scale factor xmark auctions file xmark mb scale factor xmark auctions file dmoz mb open directory dmoz rdf hierarchy dblp proc kb dblp list conference proceedings dblp pubs mb dblp list conference publications dblp conf mb dblp complete conference information dblp cj mb dblp complete conference journal information customer mb tpc mb scale factor customer table xml orders mb tpc mb scale factor orders table xml lineitem mb tpc mb scale factor lineitem table xml customer mb tpc mb scale factor customer table xml orders mb tpc mb scale factor orders table xml lineitem mb tpc mb scale factor lineitem table xml synth mb data synthetic generator see text oriented path oriented queries different types hierarchical documents semistructured data 
examine performance regular xml data relational systems section 
see table details systems comparison tukwila main memory xml engines 
included popular xslt processors study apache xalan system james clark xt engine generally rated faster xslt engines xslt processor microsoft toolkit heavily optimized considered fastest parser xslt engine available 
wanted compare data integration systems included december version niagara system time latest version publicly available 
early development tukwila compared performance lore system gmw xml repository time tukwila significantly outperformed lore 
unfortunately lore longer distributed omit comparison unfair compare outdated version lore 
shows results queries graphs part shows time initial answers way measuring quick feedback user part shows query completion time 
note queries fewer answers identical timings 
observations results 
tukwila run slower machine mhz vs mhz memory mb vs gb systems nearly matched signifi table list queries comparing pattern matching performance 
nbr 
input query religion chapter medium trees religion chapters medium trees religion titles single result religion title large trees xmark xmark query person data xmark xmark query bidder bid increases dmoz return topic ids cantly outperformed engines documents entire suite queries 
microsoft processor lives reputation fast engine faster margin half second queries relatively document attribute additional overhead tukwila incurs optimize queries 
larger documents xmark document tukwila substantially faster especially faster query 
clearly demonstrates tukwila processor scale large xml data files system comfortably processed xml document mb machine quarter time needing gb ram experimental configuration 
systems able accommodate large document 
surprisingly suite queries relatively simple queries executed systems 
niagara support xml ql predicate index variables ex zachary ives table systems compared section 
name implemented domain description xalan doc apache xslt processor built xerces parser xt java doc james clark xslt processor doc microsoft parser xslt processor toolkit niagara java xml db university wisconsin xml integration system tukwila java xml db xml engine described press queries 
executed query incorrect results returning answers 
query processors failed xmark document generating appear spurious parse errors nearly failed large dmoz document running memory gb system 
scan support pipelined operation data streams results better time initial tuple general returning answers approximately seconds cases fewer answers returned fact incremental processing model improves execution time 
observe niagara system largely focused producing partial answers order return early results produce results finished loading parsing xml document niagara benefit significantly scan operator 
slow links experiment measured general query processing performance local area network wide area query processing focal points tukwila project 
second experiment repeats previous queries environment 
simulated conditions artificially adding ms delay initial request document representing slightly longer round trip time plus ms delay kb data sent limiting throughput connection 
delay sufficient inject msec delay mb data transferred giving mb second mbits second approximate transfer rate 
repeated queries previous section dmoz query judged huge want transfer situation 
performance results 
expected tukwila incremental output greatly improves time initial answers query completion time shows relative performance gain versus query processors 
tukwila filtering construction content parallel reading manages network delay times help compute answers contrast query engines idle delays process results parse complete 
scale point emphasis design tukwila architecture scalability large xml documents 
xml files web currently tens kb size xml matures querying integration data groups enterprises expected commonplace data considerably larger 
situations query processor may servicing outstanding requests simultaneously query run limited resources 
current query processors memory representations xml data substantially larger original xml data xt processor required mb memory load scan mb dblp xml file query previous subsection server gb memory handle queries simultaneously 
tukwila avoids pitfall supporting core execution 
aspects tukwila architecture external sorts grouping operators hash pipelined hash joins scale predictable ways understood components relational query engines 
observed section query operations take place scalar data values subtrees values inlined tuple page faults xml tree manager greatly affect performance 
main concern scalability scan operator data structures uses 
investigated performance scan simple path expressions complex ones bindings kleene star operator variety document sizes 
took queries previous section plus selection queries relational data plotted running times versus data sizes 
note interesting dichotomy emerges relational tables quite dense tuples xpath matches yield running times fall approximately line left plot 
likewise queries sparser semistructured data follow different line lower slope 
hope tukwila performance appearance appears scale approximately linearly xml query engine network bound data running time sec tukwila niagara xalan xt query tuples returned queries marked fewer tuples total 
running time sec tukwila niagara xalan xt query total query time fig 
experimental comparison xml queries shows tukwila equal better total running time better time tuples variety xml extraction queries 
slope determined number pattern matches occur 
shows performance range synthetic data generated described section 
observe time required process simple query grows rate slightly faster takes parse xml build dom tree approach taken previous systems scan statemachine operation tree manager overhead tukwila fairly low 
kleene query execution times grow significantly faster rate simple query query produces tuples con sists sibling kleene star path expressions cartesian product bindings returned common subtree 
increase execution times closely approximated growth rate number tuples produced 
database style operations major sources data course relational databases significant interest sharing relational data xml format 
important concern amount overhead incurred adding zachary ives running time sec running time sec tukwila niagara xalan xt tukwila niagara xalan xt query tuples query total query time fig 
wide area context tukwila architecture provides greater performance improvements compared systems 
xml loop lose great deal querying xml view traditional relational data 
answer question compared different means processing selection join queries sql sent sql selection join query database server db udb running mhz web server read data java jdbc sent tuples network mediator added xml tags tuples returned results client 
relational database fully indexed 
approach similar adopted silkroute fts cfi mediator layers wrap xml view interface relational systems translate queries 
relational mediator tuples tables simply read jdbc returned original tukwila system executed relational query converted data tagged xml 
tukwila took materialized xml views relational tables read xml query processing data techniques described 
illustrates tukwila relational mediator approaches tended comparable xml query engine network bound data running time sec relational data dense data size mb semistructured data sparse religion religion religion religion xmark xmark dmoz orders qty lineitem cust fig 
plot running times versus data sizes shows tukwila yields relatively consistent linear performance 
note queries relational data typically dense result higher slope sparse semi structured data 
execution time sec kleene completion simple completion dom parse document size kb fig 
scale results query completion time synthetic data simple path query kleene query dom parse 
time tuples seconds 
running times despite fact xml ified input tables considerably larger 
overhead inherent jdbc java socket fast mbps network appear substantial anticipated processing query server necessarily win 
expected selection queries significantly faster done database engine 
join queries execute slowly done inside relational engine 
attribute fact jdbc bottleneck experiments join results larger sum combined inputs result efficient read original tables separately join mediator 
likewise essentially efficient read process xml version data read data jdbc 
conclude choice push operation data source depends greatly communication link costs choosing querying data original relational form converting xml 
claim jdbc fastest means exchanging relational data acknowledge modern databases provide mechanisms exporting xml observe performance acceptable business scientific applications 
tukwila performs similarly equivalent queries believe scan xml data exchange provides sufficient performance real world applications 
tukwila xml engine pro zachary ives table queries database style selection join operations relational data mapped xml 
time tuples sec nbr 
class input query rel 
sel 
mb tpc orders customer rel 
sel mb tpc quantity rel 
join mb mb join tpc orders customer key customers rel 
join mb mb join tpc orders tukwila relational mediator sql tuples total query time fig 
experimental comparison relational queries shows tukwila performs nearly data mapped xml comparable relational model integration system 
sql execution included comparison better selection query joins 
running time sec nest proceedings complete nest proceedings proceedings complete proceedings size papers list mb fig 
comparison nest join operations combining dblp papers proceedings 
nest requires larger inner relation read longer time slower time optimal join 
vides greater interoperability combine relational non relational data 
nesting data observed section operation hierarchically nesting xml child elements parent element similar left outer join relational databases 
nesting total query time sec tukwila relational mediator sql operation important constraint elements appear contiguously clustered parent 
clearly maintaining grouping incurs overhead wanted examine significant 
general practice query optimization especially network data smaller join relation inner relation larger outer relation 
reduce memory overhead algorithms hash join produces initial results earlier assuming roughly equivalent transfer rates sources hash join block finished reading inner relation 
unfortunately nest operation create hierarchical relationship place larger join relation inner relation iterate parent tuple 
see result nest performs slowly hash join opposite configuration 
fact hash join completes execution amount time nest takes output tuples 
suggests performance interactive applications answers important considerably improved possible nest manner join maintain parent ordering constraints output tuples 
output results preserving order ultimately sort data get proper form 
experimenting user xml query engine network bound data interface final sort operation performed client side periodic basis frees query processor stream results order provide faster feedback user 
supporting graph structured data today xml queries traverse document tree potentially interesting uses xml representation semistructured graphs encoding edges elements 
scan operator number features designed querying graphs 
previous traversal typically done join follow approaches described section examine scan alternative 
scan traversal comparison strategies evaluating graph style suggested scan moderately sized documents low numbers 
see execution times scan synthetic documents different sizes 
different lines represent execution times ratio idrefs elements comparison include execution time typical tree traversing query build structural index mid sized ratio documents 
proportionately low numbers see overhead supporting graphs relatively low fairly high numbers running times reasonable especially initial results output quickly 
ratio elements tukwila takes seconds return leaf nodes mb synthetic graph 
contrast tree version query yields leaf nodes 
ratio idrefs gets higher shown graph xml graph begins approach full connectivity scan spends large amounts time doing repeated evaluations 
clearly situations join approach appropriate 
graph traversal limited memory examined detail performance characteristics particularly related paging data disk 
simple tree queries memory constraints typically issue tukwila needs maintain state subtrees limited amount time tuples referencing subtrees passed pipeline 
example queried mb open directory project topic hierarchy topic aliases query processing times approximately minutes seconds tukwila execution time sec elements elements elements traverse tree document size kb fig 
scale results kleene graph query synthetic data tree query shown 
mb memory mb 
results similar tree style queries data sets dblp 
additional experiments demonstrated performance bottleneck clearly areas network parsing saving locally cached copy input xml document disk separate thread added perceptible time overhead query 
final experiment measures performance scan graph traversal large xml data files amount memory available tree manager structural index constrained 
data sets graph include synthetic data sets mb mb element idref ratio dblp conference data set cross papers conferences idrefs experiments include data set referenced items relatively clustered dblp randomly distributed document synthetic data 
cases structural index ranged size times data set size 
separately adjusted size index memory allocation tree manager allocation see greatly affected performance 
general variations memory impact expect attribute fact query processor generally network bound free cpu disk cycles 
expected size index buffer affects performance size tree manager 
final observation expected dblp data set fairly strong locality basically impacted memory synthetic data randomized targets somewhat affected 
attempted open directory data file unable successfully clean document removing elements unacceptable xerces parser link integrity 
zachary ives execution time min sec mb mb indices mb indices mb indices mb mb mb mb mb dblp mb synth mb synth mb mb mb mb mb xml file size xml tree manager memory allotted fig 
query processing times restrictions xml tree memory axis index buffer memory bar shades 
index buffer size impacts performance tree memory 
related described earlier previous xml query processors fallen classes web oriented processors including xslt processors xt xalan niagara mix lpv data integration systems repository systems require data loaded local store processed fk sgt dfs gmw 
web oriented query processors shortcomings terms scalability ability incrementally parse produce answers 
compare tukwila repository systems note repository particular storage mapping may simplify certain path expressions set path expressions includes multiple data items mapped tuple table 
frequently indexing techniques join indices val access support relations km dataguides gw indices ms speed processing path expressions 
techniques typically ill suited network query domain autonomous data sources queries frequently repeated data invest great deal time mapping storing indexing data queried amortized multiple queries 
related repository systems xml query interfaces existing databases silkroute fts cfi support creation xml queries views relational systems ibm mb mb microsoft support xml export features products 
systems useful exporting data xml facilitate data integration clearly intended general purpose xml processors 
goal architecture support fully pipelined execution leverage sophisticated techniques developed relational query processing network developed data integration distributed databases kd ufa uf 
internal execution model bears similarities object relational database engines including potentially core large objects case xml subtrees 
approach bears similarities adt structured text described bcd 
physical algebra borrows hierarchical aspects nested relational algebra rks 
key operator responsible outputting pipelined tuples input document tukwila scan operator uses hierarchical set finite state machines traverse input streaming system 
repository system scan break xml document components requiring indexing reassembly existing main memory systems scales memory supports efficient traversal graph structured input 
scan pattern matching approach bears similarity knuth morris pratt substring matching algorithm uses finite state machines perform matches algorithm supports hierarchies bindings path expressions traverses graph structure avoids cycles 
scan similarities xfilter operator af developed simultaneously focusing filtering xml documents accord xml query engine network bound data ing xpath expression 
xfilter returns boolean value match non match tuple stream result differs considerably functionality implementation 
scan similar goals scan logical operator proposed cluet moerkotte tree structured data cm includes specific algorithm support graph structured data experimental evaluation 
technology trends networking data exchange increased need xml query processor data 
applications integration intranet internet data query transformation systems xml documents live data analysis tools electronic commerce require abilities ability query combine restructure content xml documents arbitrary size ability combine data multiple sources including data result dynamically computed queries support streaming pipelined query processing model produces results soon possible 
describes architecture tukwila xml data integration system xml processor satisfies requirements 
key contributions include architecture extends tuple oriented relational techniques pipelining developed adaptive query processing techniques network relational data efficiently xml key operators scan web join map xml data static dynamically queried sources tuples streaming fashion set basic operators combining restructuring tuples xml subtrees new xml content 
described set experiments demonstrate system provides superior performance existing xml query systems applied network bound data 
results suggest possible construct native query processor xml data rivals efficiency relational query engine 
architecture tukwila suggests directions research 
clearly step develop improved query optimization techniques xml context particularly context data integration statistics available 
process building new adaptive query processing framework version tukwila support multiple strategies continuous re optimization executing query 
additional important avenues research include investigation processing data particular support features skolem functions create graph structured query results performance implications ordered versus unordered execution 
authors phil bernstein daniela florescu hartmut david maier rachel pottinger dan suciu anonymous reviewers comments earlier versions 
greatly benefited suggestions 
aea serge abiteboul dynamic warehouse xml data web 
ieee data engineering bulletin june 
af mehmet michael franklin 
efficient filtering xml documents selective dissemination information 
vldb 
ah ron avnur joseph hellerstein 
eddies continuously adaptive query processing 
sig mod 
jagadish nick koudas divesh srivastava wu 
structural joins primitive efficient xml query pattern matching 
icde 
bbm barbosa alberto mendelzon george mihaila rodriguez 
tox toronto xml engine 
international workshop information integration web rio de janeiro 
bcd brown mariano consens ian davis chris palmer frank wm 
tompa 
structured text adt object relational databases 
volume pages 
bcf scott don chamberlin mary fernandez daniela florescu jonathan robie jerome simeon stefanescu 
xquery xml query language 
www org tr xquery april 
working draft 
baru gupta bertram lud scher richard yannis papakonstantinou pavel vincent chu 
xml information mediation mix 
sigmod pages 
banerjee krishnamurthy ravi murthy 
oracle xml enabled data management system 
icde pages 
zachary ives chen david dewitt feng tian yuan wang 
niagaracq scalable continuous query system internet databases 
sigmod 
cfi michael carey daniela florescu zachary ives ying lu shanmugasundaram eugene shekita subramanian 
publishing object relational data xml 
acm sigmod webdb workshop 
cm sophie cluet guido moerkotte 
query processing semistructured context 
unpublished manuscript 
col colby 
recursive algebra query optimization nested relations 
sigmod pages 
dff deutsch mary fernandez daniela florescu alon levy dan suciu 
query language xml 
eighth international world wide web conference 
dfs deutsch mary fernandez dan suciu 
storing semistructured data stored 
sigmod pages 
fk daniela florescu donald kossmann 
performance evaluation alternative mapping schemes storing xml data relational database 
technical report inria march 
fk daniela florescu donald kossmann 
storing querying xml data rdbms 
ieee data engineering bulletin september 
fmk daniela florescu ioana manolescu donald 
integrating keyword search xml query processing 
ninth international world wide web conference may 
mary fernandez jonathan marsh nagy 
xquery xpath data model 
www org tr query datamodel april 
working draft 
fms mary fernandez dan suciu 
efficient evaluation xml middleware queries 
sigmod may 
fms mary fernandez dan suciu 
efficient evaluation xml middleware queries 
sigmod 
fts mary fernandez weng tan dan suciu 
silkroute trading relations xml 
ninth international world wide web conference november 
todd green miklau makoto dan suciu 
processing xml streams deterministic automata stream indexes 
available www cs washington edu homes suciu files ps february 
gmw roy goldman jason mchugh jennifer widom 
semistructured data xml migrating lore data model query language 
acm sigmod webdb workshop pages 
gw roy goldman jennifer widom 
dataguides enabling query formulation optimization semistructured databases 
vldb pages 
hh peter haas joseph hellerstein 
ripple joins online aggregation 
sigmod pages 
hs hong stonebraker 
optimization parallel query execution plans xprs 
distributed parallel databases 
hsr tina harvey craig mark roth 
design nested relational database system 
sigmod record 
iff zachary ives daniela florescu marc friedman alon levy daniel weld 
adaptive query execution system data integration 
sigmod pages 
ive zachary ives 
efficient query processing data integration 
phd thesis university washington august 
project jxta protocol specification revision 
platform jxta org spec pdf june 
kd kabra david dewitt 
efficient re optimization sub optimal query execution plans 
sigmod pages 
km kemper guido moerkotte 
access support object bases 
sigmod pages 
km carl christian guido moerkotte 
efficient storage xml data 
icde page 
kw chung kwok daniel weld 
planning gather information 
aaai pages august 
lpv bertram lud scher yannis papakonstantinou pavel 
navigation driven evaluation virtual mediated views 
edbt pages 
alon levy anand rajaraman ordille 
querying heterogeneous information sources source descriptions 
vldb pages 
mam marian serge abiteboul laurent 
change centric management versions 
vldb 
ioana manolescu daniela florescu donald florian don 
xml relational live 
vldb september 
ms tova milo dan suciu 
index structures path expressions 
icdt pages 
xml query engine network bound data jeffrey naughton david dewitt david maier chen leonidas kang rajasekar krishnamurthy luo naveen prakash ravishankar shanmugasundaram feng tian kristin tufte yuan wang chun zhang bruce jackson anurag gupta chen 
niagara internet query system 
ieee data engineering bulletin june 
net xml web services 
www microsoft com net asp may 
rks mark roth henry korth abraham silberschatz 
extended algebra calculus nested relational databases 
tods 
rs raschid stanley su 
parallel processing strategy evaluating recursive queries 
vldb pages 
anand rajaraman yehoshua sagiv jeffrey ullman 
answering queries templates binding patterns 
pods pages 
michael 
bringing internet database xml build loosely coupled systems 
icde pages 
sac patricia selinger morton astrahan donald chamberlin raymond lorie thomas price 
access path selection relational database management system 
sigmod pages 
sgt shanmugasundaram gang kristin tufte chun zhang david dewitt jeffrey naughton 
relational databases querying xml documents limitations opportunities 
vldb pages 
sks shanmugasundaram jerry eugene shekita fan john 
querying xml views relational data 
vldb pages 
ssb shanmugasundaram eugene shekita barr michael carey berthold bruce lindsay hamid pirahesh 
efficiently publishing relational data xml documents 
vldb 
swk albrecht schmidt florian waas martin kersten michael carey ioana manolescu ralph busse 
xmark benchmark xml data management 
vldb 
tam technical description 
www com details htm 
igor tatarinov kevin beyer shanmugasundaram eugene shekita chun zhang 
storing querying ordered xml relational database system 
sig mod 
uf urhan michael franklin 
xjoin reactively scheduled pipelined join operator 
ieee data engineering bulletin june 
uf urhan michael franklin 
dynamic pipeline scheduling improving interactive performance online queries 
vldb september 
ufa urhan michael franklin laurent 
cost query scrambling initial delays 
sigmod pages 
val patrick valduriez 
join indices 
tods 
wa wilschut peter apers 
dataflow query execution parallel mainmemory environment 
proc 
international conference parallel distributed information systems pdis pages december 
platform 
www com platform index shtml 
xsl xsl transformations xslt version 
www org tr xslt november 
recommendation 
chun zhang jeffrey naughton david de witt luo guy lohman 
supporting containment queries relational database management systems 
sigmod 
