automated approach increasing robustness libraries reliance computers increases need robust software 
previous studies shown libraries exhibit robustness problems due exceptional inputs 
describes system uses automated approach increasing robustness libraries source code access 
system extracts type information shared library header files manual pages 
generates global function fault injector determine robust argument type argument 
information optionally manual editing system generates robustness wrapper performs careful argument checking invoking library functions 
robustness evaluation ballista tests shown wrapper prevent crash hang abort failures 
wrapper generation process highly automated easily adapt new library releases 

traditionally computer software optimized efficiency robustness secondary consideration 
past decades seen exponential increase processing power 
consequently expect efficiency issue systems developed safe languages java ml 
practice demand computing power emerging applications data mining increased rapidly 
strong demand efficient programming 
known efficient languages 
addition give programmers extensive control system resources particular memory 
compared languages support automatic memory management garbage collection permit appears proceedings ieee international con ference dependable systems networks dsn june 
christof fetzer zhen xiao labs research park avenue florham park nj christof xiao research att com savvy programmers optimize resource usage application knowledge 
explicit control memory supports memory mapped important system level programming 
fact safe languages necessary introduce extra functionality customized stubs 
large percentage existing software written efficient unsafe languages 
libraries optimized high performance expenses system robustness 
ballista team shown posix library functions brittle respect invalid inputs function invoked invalid inputs may cause calling process crash hang give erroneous results 
functions implicit assumptions arguments omit validity checks efficiency reasons 
example strcpy dst src function assumes location pointed writable space accommodate source string 
violating assumption may cause segmentation fault security vulnerability 
design prevents correct programs penalized unnecessary checks 
increasing reliance computers vital need tools increase robustness software 
emphasis efficiency explicit resource control difficult build robust secure libraries 
safe libraries increase robustness subset standard library substantial performance overhead 
describe system called enhanced robustness security attempt modify library 
uses automated approach generate robustness wrappers adaptive fault injection experiments 
fault injector library function calculates robust argument type argument called argument element computed robust argument type crash return error 
robustness wrapper checks argument passed function belongs specified robust argument type invoking function 
shared library function names header manual pages files fault injector generator header files function prototype fault function injector declaration manual modifications wrapper library wrapper generator 
architecture wrapper generation process 
wrapper returns error code indicating function called invalid argument 
advantage approach improve robustness security libraries available binaries 
rest organized follows 
introduce architecture system section 
sections show automated fault injection experiments determine kind argument checks robustness wrapper perform individual functions 
section describes heal ers creates robustness wrappers techniques argument checking 
evaluate robustness performance wrappers sections 
related described section 
section concludes 

architecture increase robustness applications running wrapper sits application shared libraries 
wrapper shared library priority libraries resolve undefined symbols application 
depicts wrapper generation process consists phases 
phase system extracts type information global functions shared library header files manual pages 
information generates global function fault injector compute robust argument type argument function 
generate function declarations fed wrapper generator 
function declarations may need manual editing prevent robustness violations 
task largely automated 
second phase wrapper generator generate variety wrappers suit needs individual applications 
focus generate robustness wrappers prevent crash hang failures dis robustness wrapper covered ballista test suite 
robustness wrappers system provide flexible trade efficiency robustness 
needed system developer decide functions wrapped processes run wrapper 
example process root privilege may wrapper detect buffer overflow attacks major cause security breaches modern operating systems 
contrast process owned ordinary user may minimal wrapper prevent system crashes performance overhead 
different wrappers life cycle application 
example wrapper debugging phase may abort execution application detection invalid input 
application deployed wrapper try keep application running log invalid inputs 
wrapper approach protect existing applications transparently having modify recompile applications libraries 
addition wrapper generation process highly automated easily adapt new library versions 
shown new library releases robust previous versions due bug fixes robust due bugs introduced new features 
automated approach greatly simplifies labor intensive error prone process hardening new release library 

function declaration generation function declaration describes certain properties function needed wrapper generator 
section describe structure function declarations explain derive declarations automated fashion 
function description includes addition information pre post conditions function name name version func tion 
interface semantics functions may evolve time modern libraries assign version number function define see 
allows dynamic link loader resolve symbol correct version function 
function type type arguments re turn value function 
robust argument types enforcing argument type specified prototype function usually sufficient prevent robustness failures 
robust argument type prevents function crash failures see example section precise definition 
error return code functions typically return unique error code indicate error occurred 
functions set variable errno specify reason error 
errno usually implemented function 
function attributes attributes generation robustness wrappers safe unsafe 
safe function checks arguments passed valid 
need additional argument checking wrapper 
contrast unsafe function may crash hang invoked invalid argument values needs protection wrapper 
depicts function declaration 
argument prototype library struct tm robust argument type determined fault injector null pointer pointer allocated readable block memory bytes 
remainder section explain extract item function declaration automatically libraries 

extracting function names utility extract name version global functions defined shared library 
libraries adopt convention function names starting underscore io denote internal functions applications 
typically sufficient wrap functions names start underscore lead note functions programmers setjmp macros mapped internal function 
avoid problem extract undefined functions application wrap functions resolved library 
function name name argument const struct tm robust type array null robust type argument return type char return type error value null error value errors errno errno errors attribute unsafe attribute function 
function declaration 
substantial reduction number functions wrapped 
example glibc global functions internal 
focus global functions external 

extracting function types extracting function type information functions libraries non trivial information stored shared libraries 
different libraries name type function encoded symbol name 
encoding introduced permit function overloading multiple object files 
allows easy extraction function type information 
address problem libraries parsing header files contain prototypes global functions 
turns typically exist welldefined set header files describe interface shared library 
addition functions defined multiple times different header files definitions functions spread multiple header files 
determine proper set header files contain full definition function type parse manual page describes function 
convention manual pages contain list header files need included program wants function 
experienced problems approach 
problem global functions manual page 
example glibc functions linux professional listed online manual 
addition small percentage manual pages list header files need included 
worse manual pages list wrong header files listed header files files included define prototype function 
manual pages higher chance success case function defined multiple header files 
function manual page manual page include proper header files search header files path locate prototype function 
approach able find header files glibc functions 
note function header file means function intended internal function deprecated 
locating header files function parse extract prototype function 
currently achieved cint interpreter 
advantage cint provides easy interface query extended run time type information functions declared 

determining error return code robustness wrapper detects robustness violation needs returns error return code notify application error 
determine error return code function adaptive fault injection experiments 
extracted function name type information described previously system creates fault injector function library 
fault injector generates sequence test cases argument types function similar ballista tests 
goal different ballista tests aim detect robustness violations function goal discover robust argument types function types prevent function crashing 
fault injector iterates sequence test cases determine results crash 
reduce number test cases adaptive testing technique test cases depend results previous tests see section details 
test case result crash record return code status 
information classify functions follows return code function return value return type returns type equal operator equal operator defined 
reasonable assumption programs typically equal operator check error 
consistent error return code function sets errno fault injection experiments returns value time errno set 
inconsistent error return code function re turns different values 
error return code function fault injection experiments 

determining function attributes addition determining error return code function fault injector determines function safe unsafe 
function unsafe test case causes function crash hang predefined timeout period 
wrapper generator creates robustness wrappers unsafe functions 
way avoids overhead unnecessary argument checks 

determining robust argument types section describes determine robust argument types function adaptive fault injection experiments 

fault injector generation system generates function specialized program 
fault injector calls function test sequence test cases 
sequence test cases cross product test cases individual argument 
test case generation adaptive sense function crashes fault injector attempts determine argument caused crash address segmentation fault occurred 
tries finite number times change input value violation disappears argument causes violation 
example order determine size array allocate array zero size 
hardware memory protection sure access element allocated element generates memory segmentation fault 
catching segmentation faults determine array enlarged 
array iteratively enlarged segmentation faults occur run memory 
fault injector generator see uses argument type select test case generator argument function 
test case generator produces finite sequence test cases 
test cases type 
able generator argument type type argument 
system generic test case generators basic types pointers structures 
permits generation fault functions 
permit addition new test case generators contain specific test cases certain types 
example generic pointer test case generator specific generator pointers structure 
generated fault injector iterates test cases done computes argument robust argument type 
fault injector robust 
perform call tested function fault injector spawns child process 
child sets signal handler segmentation faults calls function 
cases signal handler child intercept segmentation faults 
segmentation faults intercepted caused 
child process executes actual calls 
function causes segmentation fault child process queries test case generators provided arguments function address fault occurred belongs test case generator 
generators test true 
generator called adjust test case able adjust test case new child process retries function call 
testing continues test pattern 
adaptive testing behavior particularly useful determine exact amount memory needed argument massive number static test cases 

test case generators test case generators essential finding robust argument types function 
types sufficiently powerful compute robust argument types designed implemented extensible type system 
test case generator define set types relationship potentially types defined generators 
details important little formal subsection 
refer partially ordered set types defined test case generators 
element set type defines set values relation defines subtype supertype relation type subtype type value set strict subset type called supertype say supertype weaker subtypes value set contains elements 
similarly say subtype stronger supertypes 
kinds types fundamental types unified types 
intuition test case generator produces elements fundamental types 
wrapper library provides unified type necessarily fundamental type checking function tests value belongs value set value set unified type union value set strict subtypes require value sets fundamental types non overlapping fundamental type supertype 
practical note order define unified types overlapping value sets need define appropriate fundamental types 
example want define unified types non negative non positive numbers overlapping define fundamental types negative numbers positive numbers zero 
non negative numbers represented unified type fundamental types positive numbers zero 
separation non overlapping fundamental types essential property algorithm compute robust argument types 
sake argument consider ary function crash non negative argu ments 
non negative non positive types detect crashes non positive values value zero 
conclude robustness wrapper check argument non negative calling non positive numbers crash function 
splitting types fundamental types compute non positive test case crash belongs non negative numbers 
safe check numbers non negative 
test case generator defines finite sequence test cases note test case generation adaptive posteriori know sequence 
test cases generated test case generator type associate test case type computation robust argument types 
test case represented pair fundamental type note unified types exist test cases 
test case generator fixed size arrays concrete describe test case generator fixed size arrays file pointers 
tasks fixed size array test case generator determine pointer points fixed size array certain size test array readable writable 
generator defines fundamental types unified types 
type hierarchy fixed size arrays depicted 
value sets fundamental types fixed rw fixed fixed consists set pointers point memory region exactly bytes region read readable writable write respectively 
fundamental type null consists null pointer points inaccessible memory region 
fundamental type invalid consists non null pointers point inaccessible memory region 
unified types array rw array array consists set pointers point memory region bytes readable readable writeable writable respectively 
array null array fixed unified type unconstrained invalid rw array null null rw array array null array rw fixed fixed subtype supertype 
type hierarchy fixed size arrays 
unified types combined fundamental type null define unified types 
unified type un constrained set pointers 
test case generator file pointers file pointer test case generator defines fundamental types unified types 
value set fundamental types file rw file file consist pointers structures opened read read write write access respectively 
unified types file file file pointers readable writeable files respectively 
note types file file comparable intersection value sets strict non empty subset value sets 
intersection value set type rw file 
note value set type strict subset intersection value set supertypes 
unified type open file set file pointers opened access pattern open file null unified null pointer type 
define relation existing types newly defined types open file subtype rw array allocated size file structure 
note extension existing type hierarchy require previous fundamental types redefined alternatively replaced new unified type 
due definition file pointer hierarchy need restrict value set rw fixed size sure value set open file rw fixed size overlap 
robust argument type selection explain compute robust argument types functions single argument generalize technique functions multiple arguments 
null void rw array null rw array open file null size size open file file file file rw file file unified type subtype supertype size bytes file 
type hierarchy file pointer types 
single argument argument type const struct tm 
system uses test case generator fixed size arrays inject faults function 
test case generator starts empty array gradually increases size function crashes size small 
test cases performed fault injector tries compute robust argument type ideally chosen test cases value set causes function crash test case causes function crash 
type exists call safe argument type 
safe argument type exists robust argument type computed system safe 
example test cases fundamental types fixed rw fixed null succeed test cases fail 
fig ure indicates weakest supertype fundamental types null array safe argument type 
safe type may exist type hierarchy 
example consider implementation returns error code invoked pointer crashing 
case array null safe argument type include assume functions atomic function change system state returns error code robustness wrapper just return error code invalid pointers generalize notion safe argument type follows 
system finds weakest type test cases function returns successfully error supertype exists test case function crashes 
note contain values function crashes call argument type robust safe 
robust type exists type hierarchy due existence uncon strained types 
note safe argument type robust 
exists safe argument type robust argument type computed system safe 
experienced problems assuming functions atomic 
want conservative require robust argument type weakest type test cases function returns error supertype exists test case function crashes 
multiple arguments ary functions computation robust argument types generalized follows 
need define dimensional type vectors th element vector type th argument function 
partial order types defines partial order type vectors 
particular introduces notion subtypes supertypes type vectors 
function call fault injector consists test cases call test case vector uniquely define type vector consisting fundamental types 
value set type vector consists set value vectors uniquely defined value set types 
generalize definitions safe type robust type type vectors follows 
safe type vector function type vector test case vectors function crash test case vectors function crashes call th element safe type argument similarly define robust vector type function weakest type vector test case vectors function returns error supertype exists test case vector function crashes 
call th element robust type argument exists safe type vector robust type vector computed system safe 

robustness wrapper function declarations generated wrapper generator creates robustness wrapper substitutes unsafe function declarations safe version provides functionality performs careful error checking 
typical structure wrapped function consists prefix code call original function postfix code 
prefix code may check arguments passed function robust 
returns error return code sets errno appropriately executing original function 
wrapper generator additionally emit code logs error failure diagnosis 
similarly postfix code check function execution successful 
shows wrapper code generated 
prototype function generated function declarations 
stores address function 
code includes recursion detection flag avoid potential circular dependencies may occur function resolution process 
remainder section describe techniques check validity function arguments 
char const struct tm char ret flag return libc flag check array null errno ret char null goto postprocessing ret libc postprocessing flag return ret 
wrapper code generated function declaration 
validating memory robustness violations due memory access errors arise function calls 
example functions string library omit boundary checks destination buffers 
exploited malicious users launch buffer overflow attacks major cause security breaches modern operating systems 
important feature system keeps track memory allocation status heap 
program calls malloc allocate block memory wrapper intercepts call records address size allocated block internal table 
program calls library function write buffer heap wrapper consults table locate memory block contains buffer performs boundary checks invoking original function 
called stateful checking wrapper needs perform state keeping allocated blocks 
shown technique detect prevent heap buffer overflows successfully 
wrapper prevent stack smashing attacks mechanism 
buffer heap stack wrapper sets signal handler tests accessibility memory 
large buffers spread multiple memory pages byte page needs tested 
approach previously libraries 
stateless approach extra state information maintained 
validating data structure validating memory accessibility prevent robustness violations string library insufficient libraries may special data structures 
example functions libraries file pointers 
argument file pointer wrapper needs sure points memory region sufficient size readable writable 
needs verify content memory region correspond valid file structure 
wrapper extract file descriptor structure check validity file descriptor 
theory complete test structure may corrupted happens contain valid file descriptor 
practice sufficient cases 
advantage approach wrapper maintain extra state information keep track file pointers 
unfortunately libraries provide checking functions data types 
example expects argument dir pointer returned previous call 
posix define function verify pointer points valid directory structure 
address problem stateful approach similar memory tracking technique discussed previously 
specifically wrapper intercepts directory related function calls keeps track directory pointers internal table 
program calls wrapper consults internal table determine directory pointer valid 
stateful checking disadvantage switch wrappers potentially larger set functions order maintain state information functions may safe need wrapped 

robustness evaluation section evaluate effectiveness generated wrapper preventing robustness failures 
testing wrapper functions glibc concentrate posix functions previously suffer crash failures ballista test linux test cases unwrapped full auto wrapped errno set silent crash semi auto wrapped 
test results ballista tests functions 

downloaded test programs functions exhibit robustness violations ballista project web site rerun programs linux glibc 
results shown 
functions crash 
functions crashed test case 
system extract type information functions generated fault injector 
inspecting robust argument types derived fault injector discovered interesting things 
example sets input baud rate needs write access argument sets output baud rate needs read write access argument 
addition functions fopen crash mode string invalid cope invalid file names 
computed error return code functions fault injection experiments 
results shown table 
manually examined results returned generated fault 
particular interested functions error code 
system automatically detect error re turn code function sets errno 
functions supposed set errno 
functions set errno inconsistently valid file descriptor returned 
created robustness wrapper generated function declarations evaluated effectiveness ballista 
indicates automatically generated wrapper reduces crash failure rates significantly functions crashed wrapper versus wrapper 
failures remain undetected usually return code class number percentage return code consistent error return code inconsistent error return code error return code table 
test results error return code determination 
corrupted data structures accessible memory 
checking integrity data structures requires wrapper keep state information task system automate stage 
example function described previous section requires argument directory pointer returned previous call function 
step manually edited generated function declarations add robust argument types executable assertions track directory structures 
additional checks able eliminate crash failures ballista test shown 
necessarily mean resulting system crash practice ballista tests cover possible failure scenarios 
demonstrates effectiveness automated technique preventing broad range robustness violations 

performance overhead section evaluate performance overhead robustness wrapper utility programs tar gzip gcc ps pdf 
program compute percentage execution time spent argument checking 
compare execution time wrapper 
described earlier wrapper generator configured generate variety wrappers different purposes 
order better understand causes performance overhead generated measurement wrapper measures frequency function calls utility programs percentage execution times spent wrapped library 
results shown table 
seen table substantial difference behaviors programs 
example gcc spends far time wrapped function calls gzip 
consequently incurs higher execution overhead 
reason high overhead gcc creates processes incurs overhead loading wrapper multiple times 
extensive error checking performed believe overhead reasonably small 
improvements applications tar gzip gcc ps pdf wrapped func sec time library checking overhead execution overhead table 
execution overhead utility programs 
achieved caching techniques check validity pointer described 

related fault injection experiments previously ballista system evaluate robustness posix operating systems 
approach various combinations valid invalid input values generated automatically argument types fed functions see exceptional conditions handled correctly 
implementations libraries robust may crash hang due invalid inputs 
different implementations libraries completely diverse may exhibit common failures 
ballista automated fault injection experiments discover robustness problems libraries 
systems different significant ways 
ballista testing methodology requires input prototypes posix functions 
function discovers list function calls exhibit robustness violations 
contrast system extracts function prototypes automatically parsing header files manual pages 
constructs hierarchy types uses adaptive fault injection experiments compute robust argument types function enumerating test cases causes function crash 
generated function declarations manual editing produce robustness wrapper prevents crash hang failures ballista tests 
previously software wrappers faulttolerance exception handling 
software instrumentation tool handle exceptions library functions 
provides language write exception specifications certain functions convenient framework incorporate specifications application code 
advantage approach generation function type information exception specifications importantly avoid exceptions highly automated 
addition wrapper generator configured generate variety wrappers suite need application programmers 
invalid input handling capability functions libraries evaluated ballista system 
results show robust libraries sfio may fail due invalid file parameters corrupted data structures 
authors manually coded safe versions functions 
system function performs argument checking calling original function 
system tests memory accessibility signal handler system touches memory see generates memory access fault 
signal handler catch exception safe function return error code 
contrast system avoids usage signal handlers memory allocated heap stack 
advantage approach detect buffer overflows occur memory page 
overflows typically generate memory access fault detected signal handler 
may overwrite data structures buffer may impose security risks systems 

software robustness essential critical applications 
presents automated approach increase robustness libraries adaptive fault injection experiments 
system extracts function prototypes shared library header files manual pages 
generates fault injector carefully crafted type hierarchy test robust argument types global function 
information manual editing system generates robustness wrapper prevents crash hang failures ballista tests 
approach improve robustness security libraries available binaries 
provides transparent protection existing programs modification recompilation source code 
addition highly automated nature wrapper generation process easy adapt new library releases 
plan evaluate robustness system types fault injection techniques bit flips effectiveness respect real failure occurrences 
acknowledgments grateful trevor jim karin bob gruber joao gabriel silva helpful comments suggestions 
anonymous reviewers comments early draft 
singh timothy tsai 
transparent run time defense stack smashing attacks 
proceedings usenix annual technical conference june 
john philip koopman 
performance evaluation exception handling libraries 
proceedings international conference dependable systems networks july 
john philip koopman 
robust software 
proceedings international conference dependable systems networks june 
christof fetzer zhen xiao 
detecting heap smashing attacks fault containment wrappers 
proceedings th ieee symposium reliable distributed systems october 
goto 
cint interpreter available root cern ch root cint html 
philip koopman john 
exception handling effectiveness posix operating systems 
ieee transactions software engineering sep 
david korn phong vo 
sfio safe fast string file io 
proceedings usenix conference pages pp 
nathan philip koopman daniel siewiorek 
automated robustness testing theshelf software components 
proceedings th international symposium fault tolerant computing pages june 
sun microsystems 
linker libraries guide july 
frederic manuel rodriguez jean charles fabre jean 
fault containment wrappers 
proceedings th international symposium fault tolerant computing june 

vo 
wang chung huang 
software instrumentation method exception handling 
proceedings eighth international symposium software reliability engineering pages albuquerque nm usa nov 
