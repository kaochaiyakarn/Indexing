practical unification parsing natural language john andrew carroll computer laboratory university cambridge september phd thesis ted briscoe supervisor prompted write thesis 
ideas suggestions come large influence direction research developed 
comments drafts thesis invaluable 
claire grover person implementations algorithms described thesis prompt notification problems great help 
appreciated ease able communicate long periods electronic mail 
discussions ann copestake dick crouch great value 
antonio help training parsing system described chapter 
am grateful addition jones arturo moral support 
members alvey natural language tools anlt projects help practical issues years users anlt comments early versions spurred think optimising parser throughput karen sparck jones continued support interest steve pulman alshawi help advice practical comparison clare system 
appreciate helpful comments mark jan nederhof david weir 
wife clare support encouragement baby daughter amy provided effective diversion stresses involved 
research supported part gr uk serc serc dti ied project extensions alvey natural language tools 
summary thesis describes novel techniques algorithms practical parsing realistic natural language nl texts wide coverage unification grammar english 
thesis tackles major problems area firstly fact parsing realistic inputs grammars computationally expensive secondly observation analyses assigned input usually forms basis correct interpretation 
thesis starts presenting new unification algorithm justifies suited practical nl parsing describes bottom active chart parser employs unification algorithm novel processing optimisation techniques 
empirical results demonstrate implementation parser significantly better practical performance comparable state art unification parser 
techniques computing lr table large unification grammar described context free non deterministic lr parsing algorithm better time complexity previously reported approach unification version derived 
experiments performance implementation shown exceed chart parser efficient lr algorithm proposed 
building methods system parsing text taken corpus described uses probabilistic techniques identify plausible syntactic analyses input large number licensed grammar 
new techniques implemented include incremental approach semi supervised training context sensitive method scoring accurate manipulation probabilities parsing identification highest ranked analyses exhaustive search 
system attains similar success rate approaches context free grammar produces analyses suitable semantic processing 
thesis includes detailed analyses worst case space time complexities main algorithms described discusses practical impact theoretical complexity results 
contents 
goals research problems practical wide coverage natural language analysis primary frameworks methods research history research background research grammar formalisms unification grammar wide coverage nl grammars software support grammar writing phrase structure grammar parsing parse selection summary thesis advances reported thesis overview thesis 
anlt grammar formalism unification algorithm anlt formalism basic design brief description formalism anlt grammar object grammar formalism metagrammar compilation format object grammar unification anlt system definition term unification unification algorithm category copying subsumption extending anlt perform graph unification comparisons unification algorithms 
anlt chart parser parser works example basic algorithm dealing efficiently ambiguity complexity parser packing complexity time complexity cf variant parser time complexity unification parser practical performance parser experiments top predictive parsing 
lr parsing unification grammar framework lr parsing shift reduce context free lr parsing lr parse tables variants lr extended lookahead lr parsing creating lr parse tables unification grammars previous approaches constructing cf backbone building lr parse tables large nl grammars 
non deterministic lr parsing unification grammars non deterministic context free lr parsing lang algorithm tomita algorithm complexity tomita algorithm new efficient cf lr parsing algorithm basic algorithm modifications algorithm correctness efficiency complexity modified algorithm efficient non deterministic cf lr algorithms non deterministic unification lr parsing extending cf parsing algorithm unification schabes lr parser complexity unification versions lr schabes parsers performance comparison unification chart lr parsers 
probabilistic lr parsing probabilistic approaches parsing previous approaches problems probabilistic cfg language models decision procedures training interactive incremental lr parsing constructing disambiguated training corpus interactive lr parsing system deriving probabilities training data probabilistic lr parsing computing probabilistic parse forest probabilistic unpacking normalisation experiments parsing ldoce definitions experiments discussion experimental results 
maximising parser throughput parsing techniques algorithms parsing complexity parse selection tuning grammars corpora acquisition lexical entries word sense frequencies making collocational information dealing summary bibliography appendix appendix 
goals research thesis describes research techniques algorithms practical parsing realistic natural language texts wide coverage unification grammar english 
research proposes implements novel solutions important difficult problems area firstly fact parsing realistic inputs wide coverage grammars computationally expensive secondly observation grammars assign analyses typical input usually forms basis correct interpretation 
problems practical wide coverage natural language analysis substantial amount research natural language nl processing focussed task syntactically analysing substantial corpora naturally occurring text transcribed speech 
analysed corpora great benefit gathering statistical data regarding language example train speech recognition devices general linguistic research step robust wide coverage semantic interpretation 
corpus analysis literature contains descriptions variety different types analysis ranging part speech tagging assignment single detailed syntactic analysis 
able derive semantic interpretation semantically pragmatically appropriate syntactic analysis analysis represent syntactic relations hold constituents input 
addition analysis drawn pre defined formed set possible syntactic analyses defined generative grammar 
requirements met semantic interpretation resultant analyses guaranteed unambiguous semantic operations defined syntactic configurations guaranteed apply appropriate yield complete interpretation 
approaches compute lexical tags de rose syntactic analysis closest fit previously defined set possible analyses sampson haigh atwell inadequate absence additional apparatus 
approaches corpus analysis assumption computationally tractable generative grammars sufficiently general coverage developed see example papers garside leech sampson 
development wide coverage declarative grammars written computationally tractable linguistically adequate formalisms assumption questionable 
example alvey natural language tools anlt system wide coverage lexical morphological syntactic analysis system english briscoe 
taylor grover briscoe demonstrate version sentence grammar system capable assigning correct analysis corpus noun phrases extracted regard internal form variety corpora 
taylor show anlt grammar wide coverage away issues lexical forming equivalence classes noun phrases parse single token class 
address practical issues ensuring parser throughput face ambiguity long input strings selecting correct analysis particular input set licensed grammar tuning grammar particular corpus sublanguage providing reliable analyses input outside coverage grammar 
church patil demonstrate broad coverage grammar parsing realistic input thousands possible analyses 
useful practice parsing system employ designed processing techniques able cope number analyses 
system incorporate automatic methods filtering analyses return small set comprising semantically pragmatically plausible ones 
vocabulary idiom constructions say legal language word definitions dictionary differ terms range frequency words constructions employed practical system capable tuned particular corpus sublanguage consideration 
tuned generative grammar capable correctly analysing naturally occurring input system able detect input falls outside coverage grammar take action return appropriate analysis 
thesis describes implemented computer system tackles second third issues preliminary proposals concerning fourth problem 
primary frameworks methods research previous section argued nl text analysis system necessarily computationally tractable linguistically adequate formalism order support semantic interpretation 
proposed formalisms unification shieber satisfy conditions wide coverage grammars developed notable exceptions clare grammar core language engine cle alshawi alshawi alvey natural language tools anlt english 
research reported thesis system grammar formalism relevant aspects system discussed fully 
thesis describes novel unification algorithm suitable breadth parsing unification parsers detail bottom chart parser nondeterministic lr parser 
lr parser construction techniques surveyed detail particular utility large ambiguous grammars methodology deriving lr parser unification grammar 
parsing algorithms derived efficient non deterministic algorithms context free grammar premise unification versions algorithms form basis implementation parsers throughput 
optimisations unification parsers described considerably enhance performance implementations 
thesis analyses worstcase space time complexities main algorithms described basis results experiments comments practical impact theoretical complexity results 
approach tuning grammar particular corpus sublanguage semiautomatic training phase additions grammar manually statistical information concerning frequency grammar rules acquired context defined lr parsing technique 
statistical information modified grammar probabilistic lr parser constructed 
capable ranking possible parses identified grammar useful efficient manner 
unseen sentences correct analysis outside coverage grammar remain problem 
results preliminary experiments suggest system success rate region approaches context free cf grammar produces detailed analyses systems ones suitable subsequent semantic processing 
history research research described thesis grew initial implementation subsequent enhancement observed shortcomings anlt 
uk alvey programme originally funded parallel collaborating projects universities cambridge edinburgh lancaster provide tools nl processing research 
product anlt release 
project phillips thompson implemented unification parser second dictionary morphological analyser system 
third project developed large grammar english grover carroll briscoe support effort grammar development environment gde carroll briscoe grover 
grammar written unification formalism notation generalized phrase structure grammar gpsg gazdar 
subsequently fourth project september funded uk department trade industry science engineering research council support enhance anlt add semantic component consisting rule rule compositional translations grammar corresponding extensions gde software 
releases anlt projects fourth project anlt developed system morphological syntactic semantic analysis large subset english morphological component software integrates finite state grapheme morpheme transducer koskenniemi word grammar written unification formalism lexicon access module resulting general purpose morphological analyser ritchie 
give detailed description 
lexicon anlt analyser contains entries lexemes includes detailed subcategorisation information appropriate grammar built semi automatically longman dictionary contemporary english ldoce procter 
carroll grover describe lexicon techniques creation 
sentence grammar grover carroll briscoe consists compiled term unification grammar containing phrase structure rules semantic component comprising rule rule translations expressed lambda calculus corresponding software support described carroll briscoe grover 
anlt contains syntactic parsers bottom highly optimised chart parser nondeterministic lr parser described thesis chapters respectively 
part chapter reports joint research ted briscoe text chapter chapter papers carroll briscoe briscoe carroll 
joint described stated text 
alvey natural language tools system comprising common lisp source code software grammar lexicon english comprehensive documentation available modest fee research purposes substantial fee commercial exploitation 
enquiries obtaining anlt directed programs street cambridge cb qa uk fax 
date academic industrial research sites worldwide purchased copy 
thesis version grammar lexicon assumed third release december stated 
background research grammar formalisms unification grammar grammar formalisms number syntactic formalisms develop grammars practical nl processing systems 
widely woods augmented transition network atn formalism 
formalism grammar expressed set directed graphs 
parsing arcs graphs traversed arc set associated actions performed example consume word input build segment syntactic structure jump subsidiary network 
arc may contain arbitrary lisp expressions evaluated traversal 
atn formalism powerful draw full power general purpose programming language grammars difficult debug side effects proliferate difficult maintain extend 
due procedural order dependent nature formalism efficient parsing techniques 
example carroll demonstrates automated analysis dependencies complex shows parsing strategy apart strictly left right impractical large general purpose atn grammars 
cf grammar chomsky falls opposite extreme 
efficient parsing techniques exist formalism expressive reason form little practical nl processing systems 
systems variants cf grammar robinson jensen tomita rules augmented tests actions actions cases arbitrary procedures having similar power actions atn grammar 
systems flexible cf grammar realistic grammar substantial coverage probably just difficult debug maintain extend atn grammar due unconstrained nature actions shieber 
declarative theories emerged example lfg kaplan bresnan gpsg gazdar klein calder hpsg pollard sag detailed designs motivated theoretical linguistic computational considerations 
generation theories uses unification feature representations primitive operation shieber 
linguistically elegant theoretically appealing theories tend suited practical parsing large grammars assume minimal phrase structure components rely conceptually simultaneous application sets principles constraints function 
worst case complexity parsing grammars expressed formalisms intractable barton berwick 
inspired theories vehicles exploration properties relationships theories flexible formalisms patr shieber fug kay tfs zajac lkb copestake ale carpenter developed implement single specific theory 
formalisms simulate linguistic theories shieber 
projects build wide coverage unification grammars tended adopt relatively simple formalisms straightforward computational interpretations grammars draw linguistic insights theories mentioned 
reason simpler formalism stems fact aside theoretical worst case complexity implementing complex theory time achieving reasonable average case parsing performance large grammar extremely difficult 
reason direct implementation particular theory obsolete incapable incorporating new linguistic analyses relatively quickly boguraev 
flexible formalism patr able model wide range theoretical frameworks considered unsuitable major attempt building natural language grammars shieber due reasons efficiency encoding verbosity redundancy formal notation 
consequence reasons outlined efforts directed supporting development wide coverage unification grammars invented new formalisms express grammars higher level example patr remain uncommitted particular linguistic framework 
example core language engine cle alshawi employs phrase structure rule formalism employing compact high level notation compiled prolog terms built prolog mechanisms perform unification 
anlt uses expressively flexible powerful meta grammatical formalism automatically compiled strongly equivalent sense describes exactly language set structural descriptions object grammar syntactic variant definite clause grammar formalism pereira warren design object grammar allows fast phrase structure parser term unification employed 
unification unification operation takes feature representations consisting collection attributes features associated values value possibly collection combines information contained produce representation includes information 
contain incompatible information unification operation fails returning result 
parsing string grammar uses unification assemble pieces linguistic information derived various parts string analysis string control way information put 
main types unification graph unification term unification 
sets features appearing representations unified order features occur may differ features result successful unification union inputs 
unification succeed input representations categories contain exactly set features appearing order result contain just set order features 
unification operation built prolog clocksin mellish term unification 
wide coverage nl grammars diagram grammar robinson forming part sri team natural language interface grosz peg grammar critique project ibm jensen widely recognised widest coverage computational grammars written date developed nineteen seventies early eighties unification formalisms started proposed nl grammars 
involved considerable amounts human effort build formalisms comprising rule skeleton augmented procedural programming facilities associated rules 
robinson indicates diagram time contained constituent structure rules jensen 
state peg contained decoding rules representing central 
grammatical structures english 
part project nijmegen describes grammar designed analyse word corpus english written texts drawn wide variety sources 
grammar covers large subset english written formalism restricted form affix grammar koster briscoe conjectures variant affix grammar probably similar generative expressive capacity unification formalisms patr ii anlt formalism 
associated parsing system comprises stages assigning word input sentence unambiguous lexical category compatible grammar second assigning analyses unambiguous sequence lexical categories allowing correct analysis selected manually typically large set possible 
hindle fidditch system corpus oriented wide coverage parsing system 
fidditch deterministic approach marcus pursuing single path analysing sentence returning single analysis fragments complete analysis 
fidditch distinguishes atomic lexical categories contains pattern action rules match single incomplete node completed constituents held buffer build analyses disambiguate lexical categories 
de marcken describes system analyse large portions lob corpus garside leech sampson 
consists lexical tagger returning occasionally category word parser takes tags builds analyses phrases seeking analyse sentences completely 
parser uses relatively small set cf rules additionally combine neighbouring phrases binary structure deterministically discard certain phrases 
clare grammar alshawi general purpose wide coverage unification grammar developed cle framework see section 
general approach obtaining wide coverage clare common anlt grammar section 
size syntactic semantic coverage grammars broadly comparable clare capable deeper semantic contextually determined interpretation 
software support grammar writing grammar formalisms software systems natural language research software systems implementing particular linguistic theory formalism distinct tasks development linguistic theory ensure theory analyses remain consistent modified investigation theory help elucidate manner various aspects theory interact provide formalism encoding linguistic information uniform way order able compare evaluate alternative linguistic theories support development large wide coverage nl grammars 
examples types system include grammar writer workbench lfg program evans phillips thompson versions gpsg 
systems direct computational implementations particular versions respective linguistic theories compare alternative theories general grammar expressed theory encoded exactly way 
boguraev 
argue lack flexibility type system unsuitable task grammar development large scale 
applicability systems limited outside theoretical domain invaluable monitoring changes maintaining consistency single linguistic theory implement 
shieber developed patr formalism able model wide range theoretical devices analytical frameworks order experiment compare variety unification syntactic theories shieber patr karttunen cl patr shieber implementations formalism examples second type system 
patr universal formalism encoding linguistic theories particular suited constraint typed feature structure formalisms 
ud johnson implement expressive variant patr formalism incorporating language specifying constraints supporting typed feature structures 
ale carpenter tfs zajac systems directly implement types inheritance better suited experimenting theories devices hpsg 
discussed section formalisms type system far demonstrated suitable supporting development large grammars 
wide coverage grammars typically require person years build 
contain large numbers rules interact unpredictable ways generally acknowledged software support invaluable development 
third type system listed known grammar development environment designed support efforts 
examples systems include jensen metal shop module machine translation system metal white gde carroll briscoe grover nederhof 
analogy tools manage large computer programs software engineering provided interactive programming environments shrobe sandewall environments grammar development support tasks incremental input editing grammar line syntax checking browsing display selected parts grammar particular combinations attributes static analysis monitor interactions different parts grammar testing specialpurpose tools user driven generators check overgeneration tracing dynamic rule behaviour parsing assist debugging 
anlt grammar development environment grammar development environment gde forms part anlt second generation system drawing ideas implemented systems program patr 
designed easy portable machine independent enable achieve high productivity 
anlt uses meta grammatical formalism compiled object grammar parsing generation 
gde consists kernel performs compilation meta object grammar number integrated modules primary ones managing user interface grammar input modification generation interfacing parsers 
gde imposes constraints way parser operates certain types suitable grammar development 
design requirement high productivity means gde support rapid incremental style grammar development 
implementation metagrammar compilation optimised small modifications grammar usually result minimal amount processing new object grammar available parser parser able accept new object grammar ready parse immediately 
constraint means parser able operate extensive postprocessing object grammar constructing tables automata 
high productivity implies parser provide extensive support interactive grammar debugging example ability display partial constituents built course parse indicate sub analyses shared complete analysis 
facilities interactive traces instance useful parsing realistic inputs large grammars typically lead thousands steps performed 
limited amount postprocessing possible parser development large grammar practical performance limited speed parser restrict size grammar specifying certain portions time 
alternative slow grammar development 
parser paths nondeterministic produce possible parses input burdened deciding parts parser search space explored parse 
gde allows parser available time anlt contains parsers bottom chart parser intended grammar development lr parser 
user may switch parsers time 
parser interface contains module extracts semantic representations complete syntactic analyses 
input successfully analysed user display syntactic analyses formats differing amount detail show sub analyses shared syntactic category semantics individual nodes syntactic analysis metagrammar compilation gde incremental automatic see boguraev 
semantics beta reduction associated complete analysis 
additionally chart parser input successfully parsed user display selected subsets edges chart 
gde contains facilities automatically creating corpora sentences systematic batch testing grammar changes 
phrase structure grammar parsing phrase structure grammar consists set rules productions contains mother possibly empty ordered sequence daughters rule notated mother daughter daughter context free grammar phrase structure grammar consists elements set atomic symbols known terminals set non terminal symbols set phrase structure rules mother non terminal designation non terminals start symbol 
strings sequences terminals may derived start symbol successive expansion non terminals part language defined grammar 
parsing algorithms phrase structure grammar parsing recognition algorithms suitable nl processing proposed years algorithm relevance nowadays cocke kasami younger cky algorithm kasami younger 
purely bottom method analyses fully daughters rule constructing constituent mother 
algorithm uses tabular data structure record state parse case constituents far 
algorithm requires cf grammar expressed chomsky normal form cnf worst case time complexity length input earley describes cf parsing algorithm restricted cnf grammars cubic complexity 
leermakers shows achieves implicitly form version grammar parse time rule having daughters dotted rules section new non parser returns analysis set analyses grammatical input recogniser indicates input grammatical 
types algorithm related sense may possible convert see chapter example 
cnf rule contain single terminal daughter exactly daughters non terminals 
valiant shows computation performed cky recogniser reduced boolean matrix multiplication problem giving algorithm polynomial order 
valiant recogniser better worst case complexity currently known constant factors large theoretical interest lengths input encountered nl processing 
terminals 
reduce number operations performed general complexity information extracted grammar order predict top manner rules applied point parse eliminate consideration possibly form part complete analysis point analysed 
graham harrison ruzzo predictive recogniser derived earley fact state cky earley methods identical claim recogniser conceptually simpler 
graham describe versions recogniser theoretically run steps state versions useful practice overheads associated may large 
lr parsing knuth important predictive technique powerful sense precluding need non deterministic search largest set grammars automatic construction procedure known 
predictive techniques configured look ahead word words input constrain prediction 
lang shows earley technique adapted non deterministic push automaton npda retaining cubic complexity 
constructed powerful predictive methods lr generalised apply ambiguous cf grammars 
tomita describes intuitive method creating non deterministic lr parser time complexity parser certain kinds grammar worse proportional improvements tomita algorithm subsequently proposed chapter surveys area detail 
predictive parsers claimed better average case performance parsers schabes result top filtering applicable rules performed predictive component practical experiments implementations parsers unification ones bear claim cases discussion see sections moore dowding 
precompilation construct predictive component grammar parse time liable cpu intensive wright sharman briscoe carroll potentially rendering particular technique impractical conjunction grammar development large ambiguous grammars 
heering klint rekers note problem describe system parsing incrementally compiles lr predictive component 
system lookahead assumes grammar incorporates explicit cf component clear techniques successful usable line large unification grammars lookahead required 
predictive methods mentioned earley graham lr assume cf grammar 
applied grammar cf component additionally contains augmentations rules instance shieber uses restriction sets parse grammar containing feature categories subject unification 
method predictive left corner parsing merely requires computation table aho sethi ullman applied grammars context free ones written cle formalism categories feature rules may non initial sequences daughters specified single variable value list categories 
non predictive purely bottom parser precompilation index strategic parts grammar accessed efficient manner parse time see section 
augmented cf grammars usually parsed line algorithms augmentations associated rule applied soon rule constraining parsing process earliest possible opportunity 
situations interacting constraints may widely distributed input line algorithm version parser may appropriate 
algorithms consist phases parsing pure cf algorithm followed application constraints resulting analyses 
maxwell kaplan press evaluate strategies offer empirical comparison respect lfg grammar 
parsing algorithms necessarily uni directional due control structure data structures represent state parse algorithms process input left right unusually right left construct sub analyses needed input encountered far moving process word 
example tomita lr parsing algorithm uni directional shift reduce operations modify stack holding parse state synchronised respect input search guaranteed complete find possible analyses 
cle parser shift reduce procedure unidirectional pursuing single derivation possibility parser uses backtracking may process words left right order backtracks 
parser uses depth control strategy pursues single analysis derivation time recording possible alternatives processing return backtrack 
depth parser store formed substring table kuno constituents finds order prevent re analysed times exactly way consequent loss efficiency 
breadth parsers conceptually pursue possible derivations simultaneously storing constituent data structure datastructure contains analogue internal system state information required support backtracking information state parse point constituents 
example active chart parser kay additional information consists categories sought input certain point active edges sub analyses combined consistent manner earley deduction pereira warren information consists non unit definite clauses instantiated tomita lr algorithm consists lr table state numbers allow parser continue processing point left 
breadth algorithms tabular data structures general flexible processing strategies types algorithm 
cky parser may process words input fill table order long row left column table filled 
active chart parser mixed bottom top strategy rules triggered mothers daughters steel de long certain constraints satisfied ensure completeness 
agenda system instance thompson parameterised obtain top bottom behaviour system chart parsing earley deduction implement non uni directional strategies processing constituents head driven order kay constructing analyses starting lexical items identified relatively greatest certainty stock 
practical parsing part complete nl analysis system probably contain morphological analyser semantic pragmatic processing modules parser typically contribute upwards total processing time alshawi personal communication 
wide coverage grammars analysing realistic text time taken complete analysis single sentence current general purpose computer hardware order tens seconds 
processing times magnitude obviously place constraints tasks system called provide render impractical types line application enquiry systems analysing complex uncertain speech data requiring analysis large volumes machine readable text automatic summarisation knowledge acquisition documents 
practical throughput parser important 
parsing algorithm termed efficient time complexity polynomial 
case straightforward implementation efficient algorithm result practical parsing system 
attention paid computational techniques earley augmentations rules dealt operations unification easily dominate parse times 
practical wide coverage nl analysis systems formalisms computationally tractable parsing algorithms known 
system area employed unmodified implementation gpsg shown barton berwick exp poly complexity recognition lfg barton show np hard id lp format gazdar sharman shown barton np complete 
tag best parsing algorithm currently known worse cubic complexity fact joshi systems 
parse selection parser forming part complete nl analysis system incorporate mechanism identifying plausible analysis analyses particular input large set licensed grammar 
essentially approaches problem applying preference heuristics encode observed tendencies certain types syntactic structure predominate corpora scoring alternative semantic analyses basis numerical weights assigned particular semantic configurations ranking syntactic analyses probabilities associated syntactic rules derived rules frequency occurrence parsed training corpus 
approach investigated particularly respect resolution prepositional phrase pp attachment ambiguities 
example kimball observes pps attach low adjacent constituent left wilks huang fass indicate temporal pps may preference attaching events temporal qualities previous entities discourse may certain cases effect hirst 
data naturally occurring dialogues ferrara empirically compare heuristics put forward literature propose improved deterministic procedure parse selection 
procedure common approaches type applicable single specific source ambiguity pp attachment general purpose technique 
second approach alternative semantic analyses ranked combining numerical weights previously assigned semantic configurations 
newman presents principled search technique identifying highest scoring analysis set complete analyses weightings assigned associations word senses semantic relations 
variant approach schubert competing analysis hypotheses ranked course parse weights assigned considerations including attachment preference sentential position salience 
small number sub analyses retained stage control combinatorial problem 
clare system alshawi assigns preference measures structural properties semantic head collocations particular resolutions anaphora scoping permutations quasi logical form representations intermediate stages semantic processing 
collecting data semantic collocations type approach open ended usually subjective labour intensive manual process may possible derive limited types relevant data semi automatically example machine readable dictionaries alshawi copestake 
theoretically motivated approaches parse selection problem fujisaki sharman jelinek mercer pereira schabes probabilistic techniques pioneered field speech recognition 
techniques associate probabilistic information syntactic rules parse configurations assumption probabilities model semantic pragmatic constraints particular corpus analysed 
area surveyed chapter 
summary thesis advances reported thesis research reported thesis includes new results techniques areas unification practical nl parsing new unification algorithm certain types system argued better suited practical nl parsing existing alternatives 
optimising bottom chart parsing optimisations bottom chart parser described considerably enhance performance 
experimental results showing parser implementation significantly better practical performance comparable state art unification system 
constructing lr parse tables large unification grammars novel methodology constructing lr parsers unification grammars described various approaches lr parse table construction compared respect suitability large nl grammars compact computational representation tables ambiguous grammars described 
non deterministic lr parsing context free non deterministic lr parsing algorithm better worst case time complexity previously reported literature approach unification version algorithm derived 
experiments performance implementation parser shown exceed chart parser implementation lr algorithm proposed 
probabilistic parsing probabilistic system described parsing text taken specific corpus 
new techniques implemented system include incremental approach semi supervised training method probabilistically scoring sub analyses sensitive context accurate manipulation probabilities course lr parse identification highest ranked analyses unification parse forest full exploration search space 
overview thesis chapter starts summary anlt formalism brief description anlt grammar specification object grammar formalism unification operation defined 
algorithm implements operation described suitability nl parsing compared unification algorithms literature 
chapter anlt chart parser 
algorithm described analysis theoretical worst case time space complexities parser gives appear unpromising results 
experiment comparing practical performance anlt grammar cle clare grammar parser performs 
experiments augment parser left corner information direct search indicate performance improvements possible area 
chapter lr parsing technique introduced main types parse table drive lr parsers described 
technique computing lr table drive lr parser unification grammar application anlt grammar discussed 
practicality various approaches computing parse tables large grammars compared applying anlt grammar 
chapter concerned non deterministic lr parsing algorithms complexity 
best known context free non deterministic lr parsing algorithm due tomita means example results giving exponential lower bounds worstcase complexity summarised 
parser implements algorithm specified detail improved give time complexity 
algorithm extended parse unification grammars implementation compared proposed cubic complexity lr parser anlt grammar 
chapter builds results techniques previous chapters describing probabilistic lr parsing system 
system consists interactive incremental lr parser training specific corpus probabilistic lr parser ranks order plausibility typically large number analyses assigned anlt grammar statistics gathered training phase 
experiments parsing corpus noun definitions drawn ldoce reported results comparable systems described literature obtained basis relatively little manual effort smaller training corpus 
research described thesis summarised chapter directions discussed 

anlt grammar formalism unification algorithm alvey natural language tools anlt computer system morphological syntactic semantic analysis large subset english 
chapter gives outline system 
components anlt concerned syntactic analysis wide coverage sentence grammar english grammar compiler unification chart parser 
form starting point research reported chapters original aspects design implementation components described chapter 
anlt formalism basic design anlt designed computationally tractable implementation gpsg 
gpsg system different types rule interact license local trees trees mother daughters categories trees containing fully instantiated sets feature name value pairs 
projection immediate dominance id rules fully instantiated local trees features subject free instantiation various rule types assumed act simultaneously 
process conceptually complex presents implementational difficulties leads time space complexity results suggest process potentially impractical barton berwick 
shieber suggests complex description grammatical theory embodied gpsg formalism obtained procedural mapping gpsg grammars simpler unification formalism 
anlt follows approach generating fully instantiated local trees metagrammar compiled set partially instantiated phrase structure rules 
object grammar syntactic variant definite clause grammar formalism pereira warren designed parsing term unification 
approach computationally tractable theory practice sections 
anlt formalism designed expressively powerful 
gpsg contains formally precise prescriptive theory natural language syntax puts strict constraints techniques linguist writing grammar 
developing wide coverage grammar gpsg grammatical theory type difficult theories intended substantive claims behaviour natural language wide coverage grammar development requires formalism maximally expressive remaining declarative computationally tractable 
anlt restrictions gpsg places grammars relaxed principles example stating feature values propagate mothers daughters built theory replaced flexible mechanisms modify required 
leads expressive variant gpsg formalism thought programming language specialised writing grammars syntactic theory shieber 
dual attributes expressive power computational tractability offered anlt derive separation metagrammar object grammar 
separation allows designed allow implementation compromise fast parser time formalism attractive 
complexity metagrammar formalism disappears compilation object grammar leaving defined computationally tractable object grammar deployed parse time 
interpretation rules procedure expansion semantics resulting object grammar interpretation thought declarative terms 
grammar development environment gde carroll briscoe grover software system supports task writing grammar anlt formalism 
gde large mature system containing facilities input metagrammar rules declarations checking formedness interactive grammar browsing editing monitoring consistency various components metagrammar user driven generator helping identify overgeneration grammar development 
gde contains metagrammar compiler rules declarations input producing object grammar parser gde generator directly 
compiler incremental sense affected parts metagrammar recompiled changes lazy recompilation takes place automatically strictly required subsequent operations 
boguraev 
describe aspects gde fully 
brief description formalism thirteen rule declaration types anlt formalism feature set alias category extension top declarations immediate dominance id phrase structure rules propagation default rules metarules linear precedence rules lexical entries 
feature declarations define feature system grammar 
declaration enumerates values specified feature may 
feature system supported gde similar assumed contemporary grammatical theories extends gpsg allowing features take variable value 
variable value ranges set actual values declared variable notated name starts 
feature may defined having category value features may variable value ordinary atomic value 
features form categories category unordered collection features feature category having value 
feature value pairs separated commas category enclosed square brackets bar set declarations define groups features behave manner respect feature value defaulting feature value propagation forth 
rules metagrammar perform functions name set may readable way referring collection features plu case 
alias declarations define names considered equivalent categories feature complexes 
names rules declarations avoid having write full feature value pairs category 
example alias declarations bar plu plu allow category bar plu written plu category declarations define category conforms pattern consisting particular set features 
category declarations flesh fully specified categories partially specified categories typically appear id rules lexical entries 
category declaration applicable category forming part id rule lexical entry features category declaration rule entry added variable value 
example category declaration nominal ensure categories contained features set extension declarations specify certain features slash gpsg part basic category way instance feature nominal categories 
extension features appear category declaration extension declarations affect form object grammar act mainly convenient reminder feature usage grammar writer 
top declarations indicate parser returns set parses sentence phrase parses top node extension categories declarations retained rest ignored top declaration specifies extensions sentences noun phrases types constituent recognised valid parses 
immediate dominance rules encode permissible dominance relations phrase structure rules 
orderings rule daughters possible determined set linear precedence rules see metagrammar 
example id rule states verb phrase may consist verb np noun phrase 
associated rule optional semantic translation gde uses construct semantic representation successfully parsed input 
representation beta reduced composition semantics rule non terminal node lexical entry terminal node direct correspondence structure syntactic parse tree 
second rule contains optional prepositional phrase third daughters marked kleene plus able dominate contiguous sequence constituents appropriate category 
vp takes np vp subcat np lambda lambda 
vp ssr vp subcat ssr vp 
coord plu coord conj null conj similar way kleene plus daughters marked kleene star may dominate contiguous sequence zero constituents 
head constituent rule assumed contain feature value 
daughter category containing feature null value treated parsing empty phonologically null category referred gap 
phrase structure ps rules similar id rules typically employed wished bypass linear precedence rules example rule encoding heavy np movement english heavy np shift vp subcat np pp heavy 
grammar contains linear precedence rules encoding general rule precede rule example ps rule id rule 
propagation rules define features propagate mother daughter categories daughter categories id ps rules 
effect propagation rules bind variables instantiate values features add new features variable values rules object grammar 
propagation rules encode particular feature propagation principles various versions head feature convention proposed gpsg 
propagation rules stated terms id ps rule patterns may contain variables categories example rule states mother inherits features head noun daughter id rule nominal contains head may optionally contain daughters type nominal 
default rules allow grammar writer assign default values specified features particular id ps rule environment 
default rule effect specified features values assigned initially original id rule definition subsequently result application propagation rule default rule 
default rules replace feature specification defaults gpsg rules assign values features context id ps rule application accurately controlled need feature cooccurrence restrictions prevent construction illegal categories diminished 
accusative default states sister verbal prepositional lexical head accusative unspecified case value accusative 
case acc 
metarules principled way automatically systematically enlarging object grammar basis set id ps rules initially written 
metarule consists lhs pattern rhs skeleton new rule existing id ps rule matches metarule pattern new rule skeleton added object grammar 
general metarule applied id ps rule semantics rule changed 
gde allows formulae associated metarules specify relationship semantics input id rule semantics new rule created result applying metarule 
passive metarule adds new vp rule noun phrase direct object optional prepositional phrase basic vp rule non predicative daughter passive vp prd vp pas 
linear precedence lp rules specify permissible precedence relations daughter categories id rules 
lp rule saying id rule category specified feature subcat occur specified written lp subcat lexical entries may defined quick convenient way adding set words definitions returned morphological analyser 
lexical entry declaration consists word followed syntactic categories associated word 
semantic formulae may paired syntactic categories 
example lexical entry defined pro plu case nom subcat null pro sg male 
anlt grammar anlt contains wide coverage sentence grammar english grover carroll briscoe written anlt formalism 
earlier version grammar shown taylor grover briscoe capable assigning correct analysis corpus noun phrases extracted randomly manually analysed corpora 
grammar contains order features id ps rules default propagation rules metarules set alias top lp rule declarations 
basic feature system anlt grammar similar gpsg having major categories nominal verbal adjectival prepositional 
categories specified features nominal categories extensions verbal adjectival prepositional phrasal categories distinguished non phrasal ones value feature bar phrasal categories assigned value categories intermediate lexical phrasal having value lexical value feature subj distinguish sentential categories value verb phrases having value set bar categories 
minor categories instance determiners particles conjunctions features bar major category set head features appear instances category regardless bar feature value 
features may associated certain instances major category depending value bar feature occasions feature 
lexical entries specified feature subcat feature atomic valued approximately possible values 
quarter values identify lexical items belonging minor category example defined simply subcat 
remainder values index complementation patterns major class lexical items verbs having far largest number possible patterns 
value null indicate lexical item takes complements general convention value category names complements separated underscore character 
specific cases value may contain information semantic nature logical type especially verbs 
feature agr enforce agreement applicable constituents phrase structure rule 
agr declared category valued grammar features categories value come small set include category valued features 
unbounded dependency constructions analysed propagating constituent parse tree value slash feature category valued feature apart agr link gap appears constituent normal position 
non lexical major categories contain feature rules grammar propagating mother single daughter daughters marked slash indicating daughter gapped 
apart value grammar allows value slash restricted versions noun adjective prepositional phrase categories subset features may appear categories shows slash feature grammar analysis sentence abbot help 
example subset features constituent abbot slash category value vp daughter 
alternative treatment slash slash plu acc abbot vp vp help 
anlt analysis sentence abbot help 
particular feature system fully recursive slash agr appear category value 
scheme advantage category set finite section discusses implications parsing complexity cost ruling natural analyses certain types english constructions briscoe 
involving gap threading pereira shieber economical statement semantics associated id rules cumbersome 
anlt grammar employs different feature sets major categories ordination rules stated separately category 
analysis ordination broadly case illustrated 
feature conj appears conjuncts encodes type conjunction occurs conjunct 
example dog cat conjunct dog conj null contains conjunction whilst second conjunct cat conj contains conjunction 
conjuncts iterate mouse dog cat specified rule licenses kleene plus categories enabling occur indefinite number times 
object grammar formalism metagrammar compilation anlt metagrammar specifies set partially instantiated phrase structure rules fully instantiated local trees gpsg 
rules allowed contain variable values features variables instantiated parse time unification 
restrictions instantiation variables directly statement id ps rules introduced indirectly propagation rules apply id rules 
example anlt grammar propagation rules applying id rule noun phrases introduces determiner nominal phrase force agreement categories binding values plu feature categories conj conj dog conj conj cat speaks french writes table clever easy teach 
anlt analysis ordination 
det spec plu agr plu spec plu 
features irrelevant example shown 
agr value lexical entry determiner contains plu whilst agr value entry unspecified plu result unifying entry category instantiate variable entry instantiate unifying analysis boys daughter instantiate instances rule noun phrase boys accepted simultaneously instantiated 
object grammar produced metagrammar expanding aliases id ps rules applying propagation rules default rules category declarations order followed metarules specified applying rules predefined order 
metarule applied propagation default rules category declarations applied new id rules added original set application metarule 
resulting expanded set rules linearised lp rules linear metarules applied complete pool ps rules 
lexical entries compatible object grammar produced metagrammar lexical entries output anlt morphological analyser deleting entries feature value pairs feature member distinguished set set applying category declarations 
features null removed object grammar categories rules containing optional kleene star categories split having normal kleene plus categories 
metagrammar finite size having written explicitly metagrammar compilation procedure described object grammar finite 
assume object grammar contains rules worst case time complexity creation single object grammar rule attained rule created application single metarule 
compilation procedure effectively limits metarule apply derivation rule derivation bounded 
time expand aliases apply lp rules time apply propagation default rules category declarations time apply single metarule number metarules 
time complexity metagrammar compilation 
expressing complexity terms number object rules justified consider formalism essentially device allowing desired object grammar stated concisely form manipulated easily 
practice compiling anlt grammar scratch takes approximately seconds cpu time sun sparc elc workstation compiled subsequent recompilations changes usually take little time due caching gde performs 
format object grammar object grammar consists set phrase structure rules categories rules unification possibly containing variable values features variables instantiated parse time unification 
category grammar typed features comprise 
type represented small integer follows called category identifier motivations typing categories parsing object grammar uses term unification pair categories unified different features failure unification detected quickly category identifiers types equal 
motivation identifiers small integers static index grammar dynamically index current parsing state section indexing result dramatic improvement practical parsing performance 
research linguistic representations proposed typed feature structures multiple inheritance hpsg grammar formalism pollard sag 
schemes assign type feature structure similar way anlt object grammar additionally define partial order types 
contrast anlt categories may unify types identical theories feature structures may unify types related subsumption kaci carpenter pollard franz 
canonical ordering features feature value pairs object grammar categories arranged features follow order identifiers categories unification categories traverse category pair time features step guaranteed 
object grammar categories need contain feature values features long mapping identifiers features retained categories analyses parser expressed terms object grammar may translated back feature value pair format metagrammar 
anlt adopts approach order features declared metagrammar canonical ordering category identifiers allocated starting zero discrimination tree features translation metagrammar categories object grammar ones new branch added tree category new feature encountered 
table pairing identifier allocated list features maintained allow lookup reverse direction 
category implemented onedimensional array vector zeroth element identifier remainder elements feature values 
rule daughter consists category paired flag record daughter marked metagrammar null gap kleene plus 
example metagrammar id rule det quoted section compiled object grammar rule 
sketches elements identifier feature lookup table relevant example 
categories forming lexical entries compiled object grammar categories similar way rule categories 
variables object grammar categories unique lexical entry rule compiled replaced instances unnamed variable 
variables instantiated value restriction behave variable written prolog clocksin mellish 
variables appear name represented internally structured entities implementation quickly distinguish categories atomic values tagged efficiently information storing tag field inside entity 
det bar 
spec 
plu 
subcat qua 
agr 
bar 
plu 

object grammar rule part identifier feature lookup table 
ordering affect efficiency unification depending feature value discriminates categories ordering efficacy grammar indexing chart parser chapter 
unification anlt system definition term unification previous section described object grammar formalism glossed object grammar categories behave operations performed parser 
important operations unification 
section described basic types unification term graph 
anlt designed efficiently term unification general purpose nl toolkit contains option graph unification described section 
design anlt object grammar formalism term unification chosen graph unification enforces linguistic grammar writing discipline particularly important development large grammar allows categories typed giving benefits discussed previous section 
unification anlt uses approach binding lists binding list called variable table just table context unambiguous maps set variables current values consists list binding pairs variable value 
variable said bound binding list currently consideration contains binding unbound 
binding list value variable obtained dereferencing 
dereferencing operation looks binding variable table binding variable returned value binding variable result dereferencing variable returned value binding returned 
assigning new value variable accomplished adding new binding variable binding list effectively making bindings may invisible 
variable tagged indicate part object grammar category alternatively newly created parse time 
unification takes categories input associated binding list operation succeeds binding lists updated reflect new values variables categories assigned operation 
unification fails category identifiers categories different unification succeeds release anlt phillips thompson implemented unification module storing tables values variables tables interpreted different manner described unification algorithm completely different 
algorithm described implemented considerably efficiently corrects bugs 
value category unifies corresponding value category binding lists 
values unified variables dereferenced respect binding list category 
result unifying dereferenced values defined 
category may part object grammar allowed contain unnamed variable 
result unification guaranteed correct case variables category occur second category vice versa parser ensure copying categories necessary section 
points marked binding pairing variable value second category non variable value added second category variable table additionally variable part object grammar binding added category variable table 
conversely binding pairing value value added category table additionally variable value newly created parse time opposed object grammar created binding added second category table 
final distinct case involving creation new bindings dereferenced values variables 
situation binding value value added category table binding value value added second category table added binding values way exists table added order avoid creating circularity 
value value result success category category result unifying categories variable success see text failure variable category success variable success success category failure variable success success value value failure 
result unifying dereferenced values 
example clear bindings created points definition unification interact ensure consistency values variables 
bindings created similar way created apply exactly reverse situation 
second categories respectively object grammar variable variable tables category initially empty tables unifying pair values categories actions specified case 
binding denoted object form value 
unifying second pair values dereferencing respect second category table gives new tables result case 
unification third pair values fails dereferenced value third value category equal third value second category 
unification categories fails 
bottom parser unification algorithm passing category rule daughter object grammar second category constituent analysed simply lexical entry 
variable table associated category termed rule variable table associated constituent node variable table 
contain values variables appearing rule values assigned virtue appearing constituent propagated analysis tree 
similarly contain values propagated tree 
section expands topic shows tables action means example 
result term unification categories defined formally general category subsumption relationship 
denotes value associated feature category domain category dom set features contains shieber carpenter pollard franz type type dom paths 
atomic value subsumes subsumed distinct non variable value variable value subsumes values 
definition unification anlt system shown consistent formal definition 
firstly result unification anlt category identifier inputs satisfying stipulation types clause 
second clause ensures value feature result subsumed corresponding values inputs dealt behaviour set unification values 
third clause says values identical inputs identical result case marked deals 
unification algorithm section describes anlt term unification algorithm implements behaviour specified 
algorithm takes input categories variable tables table associated category second table second category 
result unification flag false unification failed flag true possibly updated versions input variable tables 
encounters variable unification algorithm dereference 
gives definition procedure dereference 
takes variable table returns dereferenced value variable respect table flag indicating variable bound 
searching table bindings variable procedure value wanted just binding table variable variable called value returns true dereference variable table variable value table variable value return dereference value table true return value true return variable false add binding variable value table return variable value table 
variable table procedures unification algorithm 
value variable 
defines procedure add binding unification algorithm add binding binding list 
algorithm list denoted enclosed square brackets item list list containing elements 
actual unification algorithm 
unify checks identifiers categories unified equal category assumed format values field dimensional array containing values features category 
equal successive pairs values categories unified unify values returns flag false indicating unification failure true new versions tables 
procedure tests variable tagged having created course parse part object grammar 
objects relevant processing denoted 
category copying subsumption category viewed feature structure rooted directed acyclic graph dag arcs labelled feature names 
arc points dag atomic value 
example shows category subcat null agr plu expressed graph notation 
variable category appears empty dag 
arcs point node re entrancy re entrancies occur leaf nodes represent atomic values variables nodes representing category values 
category re entrancy notated sharing variable values 
category copying definition unification operation section demands set variables category null intersection set second category 
satisfy condition parsing bottom analyses daughter nodes particular rule complete constituent built top node rule mother variables mother category renamed distinct object grammar 
rule probably written way feature values shared mother category daughters means variables bindings cyclic feature structures represented anlt object grammar formalism gpsg 
possible arrange construct course parse generally seldom particular gpsg theory algorithms described take account 
means occur check check unification attempted variable category containing variable required unification algorithm 
variables daughters picked unification lower level shared constituents incorporated new constituent built 
process variable renaming instantiation mother category performed copy category unify id vals id vals vt vt id id unify false unify vt vt unify values vals vals vt vt unify return false return true vt vt return false unify values vt vt variable dereference vt variable dereference vt return true vt vt return unify vt vt variable node variable vt add binding vt return true vt add binding vt return false variable node variable vt add binding vt return true add binding vt vt return false variable variable dereference vt vt add binding vt dereference vt vt add binding vt return true vt vt node variable vt add binding vt return true add binding vt vt variable node variable vt add binding vt return true vt add binding vt return false 
term unification algorithm 
null subcat agr 
category notated dag 
object grammar rule modified 
gives category copying algorithm anlt 
algorithm calls procedure new variable needs obtain new unique variable 
copy category creates new category identifier number values original category calls copy value old value installs new value returned new category returns category 
copy value value new value simply newly created variable category copied variable just returned 
variables local initially empty list bindings maintained keep track object grammar variables category copied unbound main variable table test updating list copy category id vals vt local id local copy value vals vt local return local copy value val vt local val return new variable local val return copy category val vt local variable val val local return local bound dereference val vt bound node variable val return val local new variable return val local return copy category vt local return local return val local 
category copying algorithm 
sure multiple occurrences variables renamed value new category re entrancies preserved involve sharing node feature structure graph value 
copying algorithm preserve re entrancies situation node value feature structure graph shared 
term unification re entrancy preserved difference feature structure graph value shared node category case difference affect success failure subsequent unifications precisely results achieved modulo non leaf re entrancies 
category value feature fixed instantiation value re entrancies identical effects values re entrancies 
account nonleaf re entrancies minimises space time overheads algorithm cost having copy shared category path 
anlt grammar contains re entrancies practice algorithm right trade 
grammars significantly probably benefit opposite approach 
cases copy performed time linear number nodes feature structure cost extra space record node source structure counterpart copy 
category subsumption theoretical practical performance parser improved packing constituents containing local ambiguity described chapter 
situation possible constituent top category specific subsumed top category constituent previously 
roughly category subsume identifier value category subsume corresponding value variable subsumes category value subsumption checked recursively atomic value subsumes atomic value equal 
see section formal definition 
situation complicated re entrancies exist potentially subsuming category 
consider case potentially subsuming second categories respectively category fact specific second part shown category instantiated instantiating values forced absence constraints values second 
category example subsume second 
re entrancies involving leaves feature structure graph affected complication unfolding non leaf category value re entrancies carried copy category affect situation 
allow fast implementation subsumption algorithm implemented take account leaf re entrancies algorithm assumes potentially subsuming category re entrancies check 
constructs category contains leaf re entrancies flags re entrant parser arrange avoid subsequently testing category subsumption 
pragmatic approach potentially expensive operation 
gives subsumption algorithm 
extending anlt perform graph unification addition providing support anlt grammar anlt intended general purpose toolkit experimenting types grammar contains option graph unification currently loaded metagrammar term unification 
object grammar formalism designed strong bias term unification 
categories represented vectors size fixed number features category 
feature structure resulting graph unification categories features top level input categories general subsume id vals id vals vt id id subsume values vals vals vt return false return true return false subsume values val val vt variable val dereference val vt variable val return true return false val val return subsume val val vt return false val val return true return false 
approximate category subsumption algorithm 
unification return new category categories completely explicit non sparse representation contain unused put potentially slots features category addition slots normally values features 
solution involving creation new category result unification fit technique binding lists means recording result successful unification 
reason anlt implements solution 
graph unification option selected object grammar categories constructed compilation assigned identifier allocated slot feature declared metagrammar 
slot feature category filled unique instance variable tagged optional 
unification algorithm augmented unifying optional variable non optional results binding created associating value effect filling slot holding optional variable extending category value 
action taken unifying optional variables 
change required category copying new optional variable generated time encountered category copied 
graph unification technique just described impractical metagrammar contains features category copying expensive 
traversing large categories containing optional values unification degrades performance 
implementation graph unification option quite practical experimenting small medium sized grammars 
comparisons unification algorithms representations copying efficient unification algorithms focus research concentrated graph unification 
states parsing systems type unification conjunction large wide coverage grammars spend total parse time performing unification 
essentially main approaches firstly representing feature structures skeletal dags unification results versions environments binding previously uninstantiated dag nodes values pereira secondly destructively updating incrementally constructed copies portions input feature structures produce results karttunen 
approach results copying dags pereira technique involves practical overheads see requires parser unification module perform chronological backtracking 
second approach prone inefficiency due unnecessary dag copying consuming time space 
ways happen early copying copies argument dags stage unification starts unification fails copying argument dags copied unnecessarily destructive operation 
algorithms avoid inefficiencies possible points approaches prone performing redundant copying result unification may share structure input dags possible case 
term unification algorithms attuned requirements parsing systems comparatively little studied 
algorithms form part implementations typed feature formalisms tfs zajac hpsg pollard sag analysis system japanese respectively 
appears exploit fact formalisms case term unification category contains fixed set features 
term unification basic mechanisms prolog programming language clocksin mellish parsers written prolog built implementation unification perform excessive amount copying restrict control strategy copy cases may strictly unnecessary 
particular parser copy category input unification early copying parser guaranteed backtrack previous point take copy result unification redundant copying result may required possible unification may backtracked 
representation feature structures term unification algorithm described chapter similarities pereira skeleton updates instantiate variables held environment 
way representation quite different 
pereira algorithm environments copied choice point derivation encountered 
virtual arrays explicit copying unnecessary clear overheads involved maintaining arrays negligible compared rest performed 
algorithm described environments extended non destructively need copied skeletons associated environments consolidated form new skeleton empty environment complete constituent 
algorithm suited parsing traditional gpsg formalisms phrase structure trees main device linguistic representation 
categories need copied new constituents built successful unifications rule daughters existing constituents merely update tables keeping track values variables 
contrast unification algorithms building new structure category results successful unification 
variable tables helps reduce parser space requirements common unification succeed new constituent successfully analysed 
space required maintain variable table smaller consumed copy category particularly table space cost amortised alternative derivations share portions 
unification technique somewhat similar proposal pereira warren suggest earley deduction derived unit clauses copied derived clauses represented implicitly variable binding environments manner boyer moore approach sharing term structures theorem proving 
algorithm formalisms theories klein calder lfg kaplan bresnan represent linguistic objects feature structures 
formalisms constituent typically represented single relatively large feature structure phrase structure tree comparatively small top category fully recursive copying operation builds new constituent inefficient 
conversely correctly gpsg formalisms main approaches mentioned section simulate phrase structure trees means feature structures explicitly storing mother daughter categories level 
wide coverage grammar depth arity feature structures typically larger normally case amount copying required instantiate deeply nested re entrancies excessive 
dichotomy types formalism dictate approach unification taken practical parsing system 
time complexity complexity unification algorithms linear martelli montanari jaffar describe algorithms attain ack complexity combined number nodes arcs terms unified ack slowly growing inverse ackermann function 
paterson wegman give truly linear algorithm entails large constant overhead due doubly linked list representation 
algorithms destructively update inputs way prolog built unification operation unmodified suffer drawbacks discussed regard prolog 
algorithm described chapter falls short optimal complexity 
potentially visits node input feature structures corresponding pair nodes inputs dereferences variables leaf nodes applicable performs computation time bounded constant 
feature structure containing nodes contain variables unification feature structures combined number nodes adds entries variable tables categories 
number unifications performed course deriving input feature structures bounded maximum number daughters rule grammar say size variable tables nr 
variable may head chain variable requiring multiple traversals table arrive value dereferenced chain may length equal size table cost dereferencing single variable 
summing nodes worst case time complexity complete algorithm 
sub optimal complexity stems deliberate space time trade purpose improve average case space behaviour algorithm minimising amount category copying discussed 
implementation algorithm forms part chart lr parsing systems described chapters 
section contains practical comparison speed chart parser respect parser employs different unification technique 

anlt chart parser anlt general purpose nl analysis toolkit includes main components paths parser 
parser unification grammar lexicon anlt formalism input returning syntactic analyses licensed grammar 
major constraint design parser expensive postprocessing necessary compile object grammar form suitable parser processing needed modification grammar slow grammar development objective parser space time requirements small possible performance large wide coverage grammars particular anlt grammar practice usable tool analysis realistic texts 
exclusion expensive postprocessing means techniques lr parsing related methods construct tables automata control steps taken parser aho sethi ullman 
extraction unification top prediction information wide coverage unification grammar moore dowding alshawi computationally expensive requiring transitive closure equivalent operation unification step applied rules grammar 
limited form prediction atomic category types proves little practice see section grammars 
simple top parsers go infinite loops grammars contain left recursive sets rules require grammar postprocessing overcome limitation 
left recursion grammar allowed bottom parser problems right left recursion required 
bottom active chart parser see kay forms part fourth release anlt demonstrates practical parser designed implemented satisfy objectives set chapter describes parser 
parser requires small amount object grammar postprocessing fast obviate need second production parser mode grammar subject postprocessing incremental processing grammar parse time render certain types compilation practical grammars written modern unification formalisms approaches assuming cf component heering klint rekers able construct component cheaply incrementally sets shieber see section discussion drawbacks technique 
rest thesis grammars assumed acyclic allowing infinite recursion stemming sets productions applied recursively consuming input contain infinite ambiguity example caused rules infinite sequences gaps 
feature systems may recursive number possible categories may unbounded assumed circular feature structures created 
grammar stable parsing performance important 
phillips describes bottom active chart parser early version included release anlt techniques common phillips parser described chapter rule indexing phillips approach simple recursive breadth control strategy agenda 
algorithms fourth release anlt parser described chapter substantially different parser uses techniques algorithms believed novel 
important techniques local ambiguity packing parse forest unpacking unification chart parsing framework efficient static rule indexing requiring minimal grammar postprocessing efficient rule invocation interleaving unification rule retrieval avoiding copying variable binding lists unification fails 
section presents parsing algorithm shows processing steps perform simple example goes describe ways critical parts algorithm refined optimised give greatly improved performance 
section theoretical complexity algorithm analysed possibly analysis bottom active chart parser reported 
section gives results experiments indicating parser meets practical performance goals outlined 
section describes investigation possible performance benefits integrating top prediction version parser discusses run counter reported researchers 
parser works parser takes input sequence words 
identifies positions input means vertices occurs word vertices numbered starting zero left input increasing word 
constituent formed sequence constituents course parsing stored datastructure called edge edge runs start vertex may active inactive inactive edge holds single constituent field 
active edge holds list constituents corresponding daughters rule successfully analysed field rest rule daughters fully analysed edge needed field rule mother edge result field 
needed field inactive edge empty result field 
edges contain lists variable bindings see section rule variable table containing values variables propagated analysis tree second node variable table values variables propagated tree 
summary edge form complete constituent represented node containing syntactic category constituent word node leaf list daughter nodes category node list word analysis consists node node variable table examples algorithms follow object grammar rule assumed format parser works word input order left right finding lexical entries word syntactic category creating node inactive edge node field 
soon inactive edge parser checks see covers input creates analysis record adds list analyses 
parser tries extend active edge ends vertex inactive edge starts unifying node category inactive edge field active edge needed category 
unification succeeds copy active edge inactive edge category added active edge list category active edge needed list removed vertex updated 
needed list empty edge turned inactive field containing new node category taken result field 
inactive edge parser finds rules daughters unify node category edge field creating active edge field list containing just node needed field list rule daughters removed result field rule mother category 
words processed parser returns list analyses 
example section illustrates operation parser small example parsing sentence john likes mary grammar contains just rules shown order clarify presentation rules simpler realistic nl grammar 
lexicon definitions words john mary likes shown 
john mary singular noun phrases likes plural noun likes dislikes verb requires singular subject 
shows steps parser goes parsing example sentence categories notated way appear metagrammar anlt object grammar categories np plu vp 
np plu det plu 
vp np plu 
john np plu 
mary np plu 
likes plu 

simple example grammar 
clarity 
objects relevant processing denoted lists enclosed square brackets 
note parser finds noun definition likes unable active edges needing noun constituent grammar rules noun daughter 
verb definition likes causes active edge created virtue rule daughter active edge empty needed list turned inactive edge field containing new node top category vp result copying category result field vp substituting variable values table parser finds analysis sentence carries finding case ones 
basic algorithm operation parser described informally precise definition basic algorithm needed point able go discuss refinements optimisations algorithm improve practical performance 
algorithm 
algorithm operator denotes append object list list contains elements 
algorithm takes input sequence words assumed non empty returns list analyses 
global data structures chart stores active edges created 
trace operations performed parsing john likes mary parse chart analyses insert traces chart return lexical entries node copy category process inactive node insert traces return analyses insert traces rules node copy category process inactive node process inactive start start analyses analyses chart start unify unify unify extend active ds rules unify unify unify ds start extend active extend active needed res start node node res start finish edge finish edge needed res needed copy category res process inactive chart chart 
anlt chart parsing algorithm basic version 
course parsing keyed vertex edges list analyses 
analyses list chart element initialised empty 
parsing consists invoking insert traces vertex allow type gap appear word retrieving lexical entries entry creating parse tree node holding entry syntactic category copied described section calling process inactive edge vertex starting previous vertex containing node 
list analyses returned 
stage word active edges previous vertex analyses processing immediately 
procedure insert traces called vertex rule daughters creates parse tree node containing copy rule mother category daughters 
procedure creates edge containing node starting vertex passes edge process inactive 
daughter rules practical performance parser suffer course theoretical worst case complexity affected 
process inactive takes inactive edge representing complete constituent edge spans input adds record constituent current node variable table edge list analyses 
edge represents complete analysis procedure tries extend active edges recorded chart vertex inactive edge starts 
attempting unify described section needed category active edge category constituent held inactive edge account values variables stored edges 
unification succeeds extend active called process extended version edge 
process inactive finds rules daughter unifies category inactive edge constituent passes extend active new active edge rule daughters needed list mother result 
extend active takes active edge constituent unifies needed category edge tables variable values produced unification vertex constituent 
creates passes finish edge new edge containing needed list active edge element removed list active edge constituent appended start vertex result active edge variable tables vertex passed procedure 
finish edge checks see edge passed categories remaining needed list complete constituent 
actual constituent parse node mother category edge result field copied variable values substituted rule variable table described section daughters edge list 
process inactive invoked edge 
hand edge passed finish edge needed categories edge added chart keyed vertex 
extensions cover full object grammar formalism ease exposition parsing algorithm simplified version deal complete object grammar formalism consider null null kleene plus categories rules 
minor changes algorithm required deal additional aspects formalism 
cater null categories grammar rules cases considered 
daughters rule null rules considered having daughters picked insert traces processed similar way ones daughters 
second case rule contains non null category categories null rules rule pattern process inactive extracts non null daughter strictly daughter 
test succeeds new edge created leading null categories rule list daughters omitted needed list gap nodes edge list 
third case rule contains null categories non null category null categories apparent extend active extending active edge new constituent 
category needed list null removed list gap node containing category added list edge 
process removal addition repeated needed category null 
kleene plus categories dealt ensuring active edge extended new constituent edge category filled kleene plus additional new active edge created kleene plus category remaining place needed list ready accept extending constituents 
inserted extend active 
kleene plus category needed node res start finish edge additional edge created similar created existing version extend active case needed categories original active edge carried unchanged 
object grammar indexing actual anlt chart parser contains number refinements optimisations substantially efficient straightforward implementation algorithm 
section describes techniques implemented improve efficiency access grammar techniques potentially applicable wide class parsers 
algorithm treats rules daughters completely different ways 
anlt implementation partitions object grammar rules sets distinction postprocessing stage parsing attempted 
parse time daughter rules considered insert traces conversely process inactive considers ones daughters 
algorithm requires category inactive edge constituent unified daughters rules process inactive rules grammar potentially applicable top information stage predict rules may applied 
smallest grammars attempting unification time rule individually time consuming inefficient great majority unifications fail failed unifications constitute wasted effort contribute output parser 
process optimised anlt chart parser indexing object grammar postprocessing stage keying index rule non null daughter 
index consists vector dimensional array th element vector giving access rules daughter category object grammar category identifier element vector discrimination tree charniak riesbeck mcdermott keyed feature values non null daughter leaves trees containing rules 
index cheap compute addition cached recomputed grammar modified 
example object grammar rule shown stored discrimination tree fragment shown rules similar daughters shown stored near 
vp vform fin neg 
subcat modal bse vform fin inv neg subcat vp vform bse fin 

metagrammar id rule corresponding object grammar rule 
large proportion unifications succeed situation imply constraints constituents start rhs rule 
bse modal bse modal inf 

fragment rule discrimination tree 
attempting retrieve set rules daughters unify inactive edge category step identify relevant vector element edge category identifier 
tree element searched starting top node collecting rules leaf nodes reached traversing sub branches value start node branch matches corresponding value category 
matching performed unification individual feature values account values variables previously bound tree 
result process set applicable rules rule paired set variable bindings result unification rule daughter inactive edge category 
rule discrimination tree inactive edge category corresponding metagrammar category subcat modal bse vform norm fin inv neg 
cause rules retrieved rules specifying variable bound norm making norm value vform rules daughters value inv feature inactive edge category bound rules rules 
example illustrates power interleaved unification discrimination tree traversal technique rule retrieval 
firstly grammar partitioned equivalence classes rules class having daughter category identifier 
rule class need considered inactive edge 
furthermore groups rules ruled basis single unification failure values example edge category subcat value modal bse means rules indexed modal inf forth need looked 
benefit technique retrieved rule shares common initial portion path tree rule returned result automatically share segments variable binding lists created unifications performed path traversed 
example retrieved rules share path modal bse additionally share subsequent path share 
segment variable binding specification returned stating variable bound norm shared results 
addition binding shared results results 
technique effectively feature daughter category object grammar variable value variable far possible case discrimination tree branch unnecessarily 
variables renamed appropriate construction object grammar meet condition insofar possible 
efficiency consideration concerning variables rules tree traversed consistency rule variable values need checked categories encoded particular tree re entrant possibility variable encountered 
retrieval process inhibits dereferencing rule variables searching trees encoding re entrant categories 
index anlt object grammar partitions rules quite finely total approximately rules maximum number occurring single leaf half leaves containing rules 
practical experiments parsing sentences grammar indicate retrieving rules performing full unification rule daughters having category identifier inactive edge slower discrimination tree method causes extra dynamic storage allocated 
category discrimination tree type described cheap construct requiring single pass rules object grammar order just second cpu time anlt grammar dec workstation 
possible eliminate need grammar postprocessing interleaving indexing unification parsing additional implementational complexity involved outweigh benefits 
indexing technique restricted applicability anlt chart parser parser component unification category information drive help control process rule invocation 
chart parse tree indexing optimisations parsing algorithm described maintains chart active edges form onedimensional array keyed vertex edges 
algorithm uses data recorded chart process inactive inactive edge wants find active edges inactive edge starts needed category unifies category inactive edge 
evidently unification fail category identifiers different avoid attempting unification anlt chart parser employs second index chart array category identifier needed category active edge practice results negligible increase space required extra array dimension gives speed 
able indexes dynamically way direct benefit category typing turn stems term unification 
gde contains option accept analyses top categories extensions set specified categories 
option force addition sequence words parser passed list category identifiers 
analyses returned top category identifier member list 
parser avoids unnecessary unpacking trees see section local ambiguity packing top category identifier means analysis returned unpacked 
dynamic storage optimisations algorithm joins lists situations 
situation algorithm builds list parse tree daughter nodes 
node appended individually current list operation relatively expensive list traversed copied time 
standard alternative method involving destructive modification list option daughter lists incorporated list modified unintentionally 
low level programming issues mean technique implementable efficiently computer languages 
prolog discrimination tree stored system database accessing involve implicit copying operation alternative passing predicates logical variable require explicit calls programmed avoid variables incorrectly bound alshawi personal communication 
implementation ignores lexical entries algorithm category identifier object grammar entries cause parser attempt access chart rule vector element subscript greater size array 
append operation unnecessary nodes added list time 
analyses reversed level space time efficient reverse lists nodes forming part successful analyses parsing finished append intermediate stage build lists 
second situation append operation called unification call just process inactive algorithm joins lists variable bindings 
operation point destructive unification fails space copy list created order append wasted 
wide coverage grammar unifications performed unification parser fail quotes significant amount space involved 
implementation produces results equivalent algorithm avoids wasted space 
saving pointer list destructively concatenating second list invoking unification 
unification pointer list restored undoing concatenation 
unification failed space wasted append operation 
unification succeeded new bindings produced copy list second list destructively concatenated approach minimising space consumed failed unifications similar spirit unification technique involving updating feature structures destructively 
algorithm cases add active edges chart chance incorporated complete analysis 
particular ones vertex daughter rules grammar ignored inactive edge possibly created extend 
shaper test kuno added rules chart chart complex forms shaper test account kleene plus daughters empty productions possible vertices near input string order avoid creating active edges form complete constituents input reached experiments show little gained area anlt implementation 
benefits cutting active edge creation extension way near sentence noticeable parsing short sentences words sentences length generally parsed quickly anyway 
refinements optimisations described significant practical impact parsing performance 
disabled rule access implemented naive tails original lists share structure technique circular binding list created passed unification procedure 
situation rare quick easy detect simple copying append 
reasonable manner partitioning object grammar rules daughters filtering rule application considering rules daughters correct category identifier experiments indicate parser slowed factor 
dealing efficiently ambiguity natural language sentence syntactically ambiguous giving rise multiple analyses structure analysis turns occur 
global local ambiguities result different types similarity analyses 
sentence contains global ambiguity constituents near leaves syntactic analyses lexical entries may analyses structure analyses higher levels 
example verb phrase saw man park globally ambiguous prepositional phrase pp park modify man event seeing 
pp lexical entries analyses result see 
important parser represent similarities compactly memory increase linearly number analyses rendering analysis realistic inputs impractical grammars lexicons assign hundreds thousands analyses 
compact way dealing global ambiguities represent constituents different trees single object 
tomita calls subtree sharing 
stands chart parser described previous section performs subtree sharing constituent represented single inactive chart edge 
case local ambiguity segment sentence assigned distinct sub analyses remainder sentence higher levels analyses receive vp vp saw man advp park vp saw man park 
analyses verb phrase saw man park 
structure 
example sentence containing compound nominal words winter holiday camp exhibits local ambiguity phrase analysed way 
subtree sharing represent compactly common parts analyses remainder sentence applicable higher levels analyses structure sub analyses represent local ambiguity distinct 
representational duplication result absent earley parsing algorithm commented tomita notes problem introduces explicit technique overcome called local ambiguity packing subtrees top category packed single tree node 
packed node incorporated single entity analysis sentence exactly way ordinary node 
technique single analysis encodes set unpacked analysis trees analogy parse tree tomita coins term parse forest collection analyses containing packed nodes subtree sharing 
tomita considers context free grammars unification test able pack nodes category equality 
categories feature structures atoms correct test packing category subsumption alshawi 
local ambiguity packing parser ability detect local ambiguity create packed nodes appropriate easily added chart parsing algorithm 
new constituent held new inactive edge just process inactive check see constituent subsumed previously spans vertices 
node holding new constituent packed node holding old processing edge immediately halted 
new edge recorded having stored array inactive edges process inactive continues 
able pack node inside third field added node structures list analysis records contains packed node associated node variable table 
part process inactive start ff fp start subsume ff fp fp return start start array inactive edges initialised empty parsing commences 
implementation category identifier constituent second index array vertex anlt grammar type sentences usually parsed words identifier turns discriminate edges better vertex 
consequently check vertices tally performed additional step subsumption test 
algorithm testing category subsumption section 
discussed reasons efficiency subsumption algorithm guaranteed correctly case potentially subsuming category contain leaf 
edges constituent stored inactive edge array order unavailable subsumption checking available packed 
constituent efficiently categorised re entrant copy category created fact recorded unused result field inactive edge containing 
parser finds constituent subsumes covering input new constituent packed old subsumption relationship way packing happen 
situation results sub optimal space time behaviour sense constituents happened encountered reverse order packed saving space processing second constituent halted 
case attempting sort packing halting processing second subsuming constituent render parser incomplete specific constituent rule analyses second specific allow 
ordering problem due fact unification category subsumption commutative operation problem encountered basic contextfree parsing packing driven atomic category equality commutative categories 
empirical observations anlt grammar test data section suggest categories candidates packing fact equal subsuming order significant practical impact parser throughput 
complication packing unification grammar parsing analyses implicitly encoded parse forest legal ones 
analysis parse forest gives rise single unpacked analysis containing nodes packed nodes points packing occur 
addition analysis unpacked analyses exhaustively enumerated choosing combinations subsumed nodes packed node 
combinations packed nodes form part valid analyses values features packed nodes inconsistent 
subtree packed parse forest ellipse encloses packed nodes 
respect feature values propagated tree 
example shows single subtree parse forest constituent incorporated forest position indicated packed node root category subtree may form part complete parse 
unpacking packed parse forests semantic interpretation stages processing syntactic parsing take parse forest input early versions cle alshawi 
simplify subsequent processing aware sub analyses implicit forest may fact form part complete analysis due non local inconsistencies feature values discussed chart parser default fully parse forests individual parse trees stage syntactic analysis sentence 
parse forest merely pruned remove sub analyses affected inconsistencies vijay shanker weir pruning spurious ambiguity parse forests combinatory categorial grammar sub analysis candidate pruning may form part complete analysis context 
unpacking algorithm traverses parse forest top starting root node recursively unpacking packed sub analyses encounters node returns list analyses node root 
root category packed sub analysis unified subsuming category node ensure consistency non local feature values 
unification fails sub analysis returned 
feature values percolating higher parse forest incorporated packed analyses simply adding variable table packed analysis bindings higher level variable table created analysis packed 
complexity parser packing complexity local ambiguity packing just technique saving space parsing 
arbitrary context free grammar computing analyses returning form set trees containing packed nodes exponential time space respect length input 
consider cf grammar 
grammar number analyses string length th catalan number church patil example string length analyses 
catalan numbers increase exponential manner 
analyses different top node analysis distinct subject subtree sharing analysis 
space required store analyses exponential length input 
able return analyses parser enumerate parser time complexity exponential 
arbitrary grammar worst case time space complexity parser perform form local ambiguity packing exponential 
computing parse forest unpacking give set trees results complexity exponential number parses unpacking 
considering complexity parsers usual measure time space complexity computation just point producing parse forest arbitrary grammar input length parser performs subtree sharing constituents different analyses represented single object 
grammar rules binary branching necessarily chomsky normal form cnf see chapter parser uses local ambiguity packing form subtree sharing represent arbitrary parse forest cubic space grammar parses lang symbols right hand side rules 
arbitrary grammar priori bound maximum number daughters single rule space complexity parser exponential 

ambiguous grammar 
constructing parse forest easier recognition cases complexity extracting parse forest considered 
cf grammars extracting parse earley parse forest linear case indexed grammars aho example parse forest constructed cubic time recognition exponential lang 
chart parser described chapter performs subtree sharing constituent represented single inactive chart edge 
sharing takes place addition sequences constituents shared analyses cases single active edge covering constituent derivation analyses 
shared sequences correspond leftmost daughters rules parser works left right similar type sharing take place rightmost daughters example right left chart parser non deterministic lr parser see chapter 
scheme grammar contains rules daughters lang grammar parses symbols right hand side rules 
constituent sub analyses sequence comprising considered single node sequence shared entity 
parser uses local ambiguity packing shares subtrees sequences subtrees worst case space complexity arbitrary grammar 
chart parser cubic space complexity 
unification grammar size corresponding grammar parses related number categories implicit grammar 
grammar uses fully recursive feature system section infinite 
briscoe 
point grammar restricts depth nesting features finite 
anlt grammar gpsg grammar gazdar 
obey restriction nesting features maximum depth category sets extremely large time complexity cf variant parser analyse time complexity anlt chart parser easiest consider variant algorithm accepts grammars context free atomic categories contain rules kleene plus categories 
variant upper bound number inactive edges pair vertices just number categories grammar nodes span segment input top category held packed node single inactive edge 
derive similar upper bound grammars features slash agr category valued features values contain embedded occurrences features 
barton berwick state gpsg distinct syntactic categories 
number active edges consider single rule daughters gives rise set active edges vertex 
active edges equivalent number ways partitioning line containing intervals number segments corresponding initial segment vertex zero edge start vertex segment start vertex covered rule daughter initial segment plus segment rule daughters multiplying number rules grammar upper bound total number active edges starting vertex vertex number rules grammar maximum number daughters rule grammar 
input length parsing algorithm iterates vertex zero vertex time taken algorithm split parts required extend existing active edges pack new constituents create new edges vertex having matched rule daughters new constituents 
vertex algorithm tries extend active edges vertices zero inactive edges starting active edges vertex number tests required extend active edges 
bounds numbers active inactive edges expressions 
test just atomic category equality unit time 
new constituent created lexical entry word rule just expands gap result filling final needed category active edge application sequence unary rules new constituent 
applying possible unary rules new constituent introduces factor equal number unary rules grammar words unary rule applied sequence unary rule applications infinite derivation result 
constituents created lexical entries gap rules vertex extending active edges applying unary rules forming new constituents dominant maximum number segments line daughter assigned segment edge inactive active 
segment allowed zero length case represents gap 
bound 
bound multiplied time extend active edges giving 
checking able pack new constituent takes unit time indexing scheme category start vertices complexity packing operations bound 
creating new edges having matched rule daughters bounded number rules grammar multiplied number new constituents giving 
summing times parts algorithm input length gives total time complexity 
considering grammars rule daughters grammars time complexity algorithm 
bound cky algorithm kasami younger uses bottom tabular approach 
cky restrictive just limit rule grammar having daughters requires grammar cnf 
cnf forces natural language grammars written unnatural way rules introducing gaps unary rules expanding non terminals convenient allowed 
possible translate arbitrary cf grammar cnf help additional dummy nonterminals chomsky 
guarantee particular grammar cnf version contain great rules original grammar 
rule daughters chart parsing algorithm time complexity respect input length cky cnf requirement cases suitable alternative 
restriction having daughters rule undesirable point view grammar writer 
lifting restriction results time bound worse cubic 
putting theoretical complexity issues aside clear conditions grammar containing rules daughters take longer parse sentences grammar transformed rules binary branching 
approximately rules anlt grammar unary binary branching 
investigating trade worst case complexity increase transformed grammar size useful area research 
time complexity unification parser analysis complexity context free variant parser holds atomic categories replaced unification categories 
packing new constituent assumed possible unit time check see constituent may packed may require tests subsumption checking unification categories indexed completely equality tests atomic categories need single array access boolean test 
assuming unification accomplished bounded time bound independent input length see section unification grammar time complexity 
similar way unification space result dependency number categories parsing algorithm appear intractable 
complexity results parser derived take account rules contain kleene plus categories 
rule potentially consume sequence limited number length input expected number active edges rule kleene plus daughters give rise exceed bound non kleene rules expression 
case deriving upper bound number active edges rules difficult non kleene rules 
deriving bound observe legal grammar contain kleene plus category able consume constituent containing just gap invocation rule containing category terminate able dominate infinite sequence gaps 
method similar derive expression number active edges rule daughters kleene plus give rise vertex sum number ways partitioning line containing intervals segments segments length strictly greater zero sub sequences segments excluding allocated possible ways number daughters rule 
algebraic manipulation sum approximates 

intermediate results derivable way total time complexity unification parser full anlt formalism 
allowing grammar contain rules kleene plus daughters changed theoretical worst case behaviour algorithm polynomial exponential 
retain polynomial time bound grammars containing kleene rules transformed ones kleene categories addition extra rules set produce recursive tree structures iterated flat tree structure created kleene categories 
technique described chapter connection unification lr parsing 
applying technique anlt grammar slows chart parser 
appears way kleene categories grammar little impact performance parser fact increased overheads rule invocation structure building associated new rules introduced remove kleene categories slow 
anlt grammar large rules size category set large practice performance chart parsing implementation really quite see section relatively long sentences 
grammars natural languages bring algorithm near worstcase complexity 
practical performance parser discussed chapter complete nl analysis system contains just parser may contribute order total processing time 
wide coverage grammars realistic text syntactic analysis single sentence moderate length current computer hardware take seconds briscoe carroll time necessarily increases linearly length sentence 
anlt chart parser designed implemented practical performance large grammars high priority assess parser meets goal performance compares state art unification parsing experiment carried measure performance anlt parser cle parser version forms part clare system alshawi alshawi 
corpus approximately sentences produced linguist developed anlt grammar supplied part anlt implicitly defining types construction grammar intended cover 
corpus check adverse effects coverage grammar modified grammar development 
experiment initial sample representative sentences extracted corpus 
experiment consisted parsing set sentences sample firstly clare parser grammar lexicon secondly anlt parser grammar lexicon thirdly cle parser having replaced built grammar lexicon versions anlt object grammar anlt lexical entries words sample translated cle formalism 
reverse configuration clare grammar loaded anlt system possible central rules grammar contain sequences daughters specified single list variable 
aspect cle formalism counterpart anlt object grammar formalism simulated 
main vocabulary sample matches clare lexicon fairly small number lexical entries needed added purposes experiment 
standard clare parser facility scoring constituents obtain final ranking analyses version parser avoids associated overhead timings parser recorded phrasal analysis stage addition subsequent main syntactic analysis stage 
cle parser returns analyses form packed forest purposes experiment anlt system modified omitting normal unpacking stage 
running cle anlt object grammar grammar compiled features slash inv comp declared prediction filter features declarations pure bottom parsing approximately twice slow 
clare parser grammar preliminary tests unexpectedly indicated standard clare parser twice slow 
initial sentences clare grammar failed parse cases punctuation strictly required missing corpus 
anlt grammar failed parse plus additional 
sentences removed sample leaving sets comprising declarative sentences forming set called decl wh questions sentences gaps wh slash passives passive sentences containing ordination conj 
sample contains total words mean sentence length words 
appendix contains list sentences 
table shows parse times configurations set sentences sample 
figures include garbage collection time phrasal appropriate processing 
table gives total numbers syntactic analyses sentences 
thought straightforward comparison cle anlt parsers anlt grammar fact problematic 
experiment configuration clare parser times slower anlt parser alshawi personal communication points tuned grammars containing large numbers rules anlt grammar contains clare parser anlt chart parser clare parser clare grammar anlt grammar anlt grammar phrasal syntactic decl wh slash passive conj totals table 
parse times cpu seconds sun sparc elc workstation set sentences sample 
alshawi pointed facility ran sample version clare disabled 
clare parser anlt chart parser clare parser clare grammar anlt grammar anlt grammar 
analyses table 
total numbers analyses sentences sample 
times rules non phrasal part clare grammar 
large number rules indexing cle uses store compiled prediction rule table appears perform badly 
anlt grammar entries table contain rules time entry table accessed system effect copy rules 
contrast anlt parser access large numbers rules described section highly optimised 
comparing parsers configurations uses grammar originally written anlt parser factor faster cle parser sample grammars broadly similar wide coverage return remarkably similar numbers syntactic analyses inputs remaining major differences parsing systems parsing algorithm programming language implemented common lisp steele anlt prolog cle 
current prolog lisp compiler run time support technologies quite advanced fact cle parser takes advantage prolog built unification operation coded efficiently 
different programming languages wholly account difference factor favour anlt may concluded parsing unification algorithms associated optimisations allow anlt parser perform practice 
sentences experiment running sun sparc elc workstation anlt parser processes words rate eleven second 
course due suspected bug clare parser involving local ambiguity packing fact kleene plus categories anlt grammar translated single ordinary categories clare meaning parses containing ordinated phrases 
time taken analysis creation logical forms included anlt system approximately times faster clare 
possibly case difference partly due processing strategies types algorithm programming language leads implementor parser adopt prolog supporting backtracking search system database intermediate results need cached lisp breadth search accumulation alternative results lists 
experiments top predictive parsing chart parsing algorithm described chapter purely bottom 
topdown information constituents expected particular point input basis preceding left context 
earley parsing algorithm cf grammars uses top information chapter describes implementation improved earley parser unification grammar 
information improve complexity chart parser result practical space time improvements 
example pratt reports incorporating top information purely bottom cky parser prevent constituents bottom form part complete analysis portions rules partially instantiated resulted reduction factor number constituents built set test data 
moore dowding describe unification chart parser similar techniques lead practical improvement parse times factor earlier bottom version parser 
cle alshawi employs top prediction framework backtracking left corner unification parser avoid considering applying rule daughter mother form part complete analysis 
parsers rely precompilation grammar construct left corner reachability table 
non terminal unification grammar category table gives set possible categories constituent category start left corner 
parsing table consulted constituent built check possible left corner rule daughter previous daughters 
constituent discarded possible left corner 
successful top prediction parsers suggest worthwhile add chart parser improve practical performance 
parsing algorithm changed addition active edge chart vertex prediction edge needed category starting vertex 
new lexical entry encountered check left corner predicted categories point inactive edge matched daughter rule rule mother checked see left corner predicted category 
version parser created incorporating changes experiments carried assess effectiveness 
experiments reachability table dimensional array indexed category identifiers predicted left corner categories 
versions table conventional table entry list predicted possible pairs unification categories second bit array entries category identifier equal entry predicted index left corner category identifier equal left corner index zero 
versions table created filling mother daughter relationships rule individually applying variants transitive closure operation complete table algorithm sedgewick 
stage algorithm uses information table entries update entry 
case unification category table updating consists adding new predicted possible left corner pairs taken combinations pairs input entries left corner category pair unifies predicted category second pair 
adding new pair entry involves generalisation operation current contents bit array version table completed simply series inclusive vector operations slices array 
creating unification category version reachability table anlt grammar rules computationally expensive minutes cpu time dec workstation 
bit array version cheap create approximately seconds 
table summarises performance set sentences relative bottom parser top predictive version parser types left corner reachability information 
top predictive parser type reachability table slower bottom parser unification category table slower factor 
optimisations predictive parser definitely possible allow overtake bottom inactive edges filtered 
fact primary purpose table left context information limit places gaps occur moore dowding maximum reduction number inactive edges built anlt grammar average average reduction rules introducing gaps removed results decrease parse time similar 
bit array version reachability table turned parser 
inactive edges cpu time bottom parser top predictive parser unification category table bit array table table 
performance top predictive version parser 
process repeated quiescence bound depth embedding subsequent generalisation parts embedded feature structures grammar contains sets rules mothers daughters applied indefinite numbers times applications build recursive feature structures rule applied 
little 
results somewhat disappointing run counter reported moore dowding parser effective left context information practice runs significantly faster bottom parser described chapter 

lr parsing unification grammar framework classes unambiguous grammars depending exact parsing technique predictive parser constructed account analysed unambiguously determine action performed 
case ambiguous grammars may actions possible stage predictive techniques adapted generalised deal grammars 
contrast bottom chart parser described chapter predictive parser uses information context rules may applied successfully attempting apply rules point 
action possibility distinguished unambiguously predictive parser parse text time linear length string 
chapter discusses techniques constructing generalised predictive parser unification nl grammar 
popular predictive parsing techniques ll parsing lr parsing 
lr powerful sense construct conflict free parsers larger set unambiguous grammars 
example left recursion grammar causes ll technique produce parser containing action conflicts lr 
reason lr technique considered 
lr parsing lr parsing knuth aho sethi ullman chapman table driven parsing technique simple driver program takes input builds analysis guided lr parse table constructed grammar indicating parser stage 
originally developed syntax analysis phase programming language compilers grammar language designed unambiguous allow driver program standard deterministic shift reduce parser possible apply lr technique ambiguous grammars nl grammars 
lang describes technique efficiently driving pseudo parallel certain classes nondeterministic push automaton npda aho sethi ullman lr parse table construction methods ambiguous cf grammars derive 
tomita describes intuitive approach non deterministic lr parsing generalising parsing operate breadth graph structured stack 
lr tables constructed parsers allowed contain conflicting actions points correspond ambiguities grammar alternative derivations table distinguish current context 
non deterministic lr parsing offers prospect fast paths parsing lr parse table ensures rule invocation constrained possible currently known automatic grammar precompilation techniques 
attraction technique stems fact real takes place precompilation phase run time behaviour resulting parser relatively simple directed 
approach extended probabilistic cf grammar pcfg see chapter 
chapter presents efficient novel lr parsing algorithm discusses lr lr non deterministic parsing algorithms compares theoretical complexity practical comparisons implementations 
briscoe carroll investigated lr parse tables form basis context dependent language model probabilistic parsing 
contrast individual pcfg rule action lr parse table implicitly encodes information left right context state parse applicable 
deriving probabilities relative parse context allows probabilistic parser distinguish situations identical rules reapply different ways different derivations apply differing probabilities different contexts 
chapter describes techniques employed investigations results experiments evaluating approach 
lr parser applied input parse table grammar constructed 
computationally expensive arguably complex aspect lr parsing 
chapter describes form lr table drives simple shift reduce parser discusses alternative methods generating lr parsers unification grammars special steps taken able construct table large grammar anlt 
shift reduce context free lr parsing simple context free grammar shown 
start symbol grammar grammar ambiguous allows right left branching analyses pp attachment noun compounds 
gives lr parse table 
table consists parts action table goto table 
rows table represent parse states columns represent terminal non terminal symbols grammar 
table contains action conflicts states corresponding noun compound ambiguity pp attachment ambiguity 
np det np vp np np pp vp vt np vp vi pp np np 
simple context free grammar 
easiest way understand table function examine simple derivation table drives standard shift reduce parser aho sethi ullman 
gives derivation sentence loves consisting pronoun transitive verb vt second pronoun 
ambiguity sentence derivation represented single stack top element right 
parse table set expect know terminal category word input stage parse called lookahead symbol 
words processed lookahead item symbol parser begins state zero empty stack lookahead item terminal symbol associated word input 
parse table entry state zero lookahead instructs parser shift move state 
shift causes pushed parse stack followed new state number lookahead item set terminal symbol associated word input 
state lookahead vt table instructs parser reduce rule np current state popped topmost category replaced mother category rule 
parser consults goto part table discover state move state zero non terminal np goto table instructs parser move state state pushed stack 
shift actions occur exactly symbol lookahead item 
step second pronoun reduced np time goto table instructs parser move state state 
state reduction called rule vp vt np time terminals stack popped replaced vp rule daughters 
reductions bring parser accept action parse halts successfully 
lr parse tables lr parser uses left right scan input lr constructs rightmost derivation reverse 
number input symbols lookahead action state det vi vt acc goto state np pp vp 
lr parse table grammar 
stack input lookahead symbol loves loves vt np loves vt np loves vt np vt np vt np vt np np vt np np vp np vp 
parse derivation loves 
making decisions action perform appended name technique omitted 
consider derivation generation string start symbol grammar step choices nonterminal expand rule expand 
rightmost derivation rightmost nonterminal expanded step 
parsing bottom input string parse tree constructed starting leaves working top start symbol 
stage parse appropriate rule applied correct point reducing substring corresponding daughters rule mother parser constructs rightmost derivation reverse 
lr precompilation process results parser control mechanism enables parser able identify handle appropriate substring input reduce rule grammar perform reduction order construct rightmost derivation 
grammar ambiguous alternative derivations distinguished current context may handle string 
shift reduce lr parser state top stack encodes information control mechanism needs able identify current handle set handles 
goto part lr table essentially finite state automaton state currently top stack grammar symbol incorporated current derivation identify handle set 
intuitively state corresponds parsing process having consumed input spans initial portion rules grammar 
rule represented lr item consisting rule dot position right hand side 
case lr parsing information required 
example items stemming rule np vp np vp np vp np vp item indicates string derivable np vp expected second string derivable np just seen input vp expected 
lr item lr item contains terminal symbol second component lookahead item example np vp 
lookaheads items may length greater lr parsing case greater 
action part lr table encodes finite state automaton recognises viable prefixes prefixes string continue past rightmost handle string 
states automaton identified goto automaton state formed set items 
set formed closure operation item ab possibly empty sequences terminals nonterminals set grammar rule item added set 
forming item sets starts computation closure set containing initially just aa member set value function goto set items formed closure aab 
goto automaton constructed function argument restricted nonterminal values 
closures computed set forms state contains item dot daughter rule handle current point input string reduction rule called 
item form aab terminal goto gives rise action specifying shift state grammars programming languages give rise deterministic automata possible generalise lr technique apply ambiguous cf grammars describing natural languages building non deterministic automata states contain action conflicts arising single string licensed grammar having alternative handles 
action conflict may types shift reduce actions reduce actions calling reductions distinct rules 
shift shift conflicts occur 
parse table contains conflicts 
blank entries table correspond illegal configurations stack input buffer point parse parser reaches entries input ungrammatical 
variants lr table construction method outlined previous section produces lr parser collection sets items constructed termed canonical lr collection 
grammar conflict free lr parse table constructed called lr grammar 
lr parser quite weak programming languages lr 
lr parse table grammar contain action conflicts example transitive verb followed noun phrase recognised parse table able say verb phrase constructed immediately constituents symbol shifted start form prepositional phrase modify noun phrase 
looking evident options applicable sentence reached second word sentence preposition 
word lookahead needed able distinguish cases 
slr simple lr parser simplest type lookahead lr parser 
slr parse table derived canonical lr collection item sets way lr table single exception item results reduction rule lookahead symbol member set follow 
follow defined nonterminal set terminals appear immediately right derivation string 
grammar conflict mentioned reducing transitive verb noun phrase verb phrase vp shifting symbol resolved looking symbol follow vp reduction take place shift performed 
follow vp reduction correctly called case lookahead symbol sentence 
case determiner noun recognised slr technique powerful discriminate choice reducing constituents noun phrase shifting terminal form part compound nominal 
canonical lr powerful lr parsing technique 
canonical lr parse table constructed analogous way lr lr items lr items 
closure operation item set involves adding response existing item ab rule ba string derived ba 
goto function computed similar way lr goto items form aab 
creating action table item sets item result reduction rule lookahead symbol grammar canonical lr table contains states action conflicts corresponds point structural ambiguity grammar potentially unlimited amount lookahead needed correct choice action 
slr table contain action conflicts certain types grammatical phenomena canonical lr table discriminate alternative actions 
third technique lalr lookahead lr intermediate power slr full lr advantage parse table grammar smaller having number states slr lr tables 
shows lalr table grammar 
table contains states opposed canonical lr table action conflicts 
larger grammars example programming languages aho sethi ullman canonical lr tables order magnitude larger corresponding lalr table 
reason lalr usually powerful programming language grammars parser generators programming languages lalr johnson klein martin lr technique appears rarely practice 
literature contains number different approaches lalr table construction 
section discusses suitability various construction methods creating tables large ambiguous nl grammars 
extended lookahead lr parsing standard approaches lr parsing fixed number lookahead symbols order choose conflicting actions 
number symbols lookahead invariably taken control size parse table chapman 
presents technique called lar constructs lr parsers unambiguous cf grammars lr parser effectively augmented set lookahead automata able perform unlimited amount lookahead 
automata skip sections input containing local ambiguities eventually resolved deterministically choose action performed lr parser current point 
adapts lar technique construct tables ambiguous nl grammars reduce non determinism resulting local ambiguity possible 
lar table construction computationally expensive action conflicts lr table process simulates complete non deterministic parsing possible input strings resolution local ambiguity 
basis results experiments small ambiguous grammar concludes analysis lar technique performs extend lookahead way relevant phenomena occur nl technique inefficient applied realistic nl grammars current computer hardware 
result indicates foreseeable little hope automatic table construction techniques successfully applied grammars expressed general frameworks lr regular cohen 
creating lr parse tables unification grammars previous approaches tomita describes system non deterministic lr parsing context free grammars consisting atomic categories cf production may augmented set tests perform similar types operations available unification grammar 
parse time sequence constituents reduced higher level constituent production augmentation associated production invoked check syntactic semantic constraints agreement pass attribute values constituents construct representation higher level constituent 
standard approach parsing attribute grammars 
parser driven lr parse table table constructed solely cf portion grammar extra information embodied augmentations taken account construction 
predictive power parser select appropriate rule specific parse history limited cf portion grammar defined manually grammar writer 
requirement places greater load grammar writer inconsistent unification grammar formalisms represent grammatical categories entirely feature bundles gazdar pollard sag klein calder 
addition violates principle grammatical formalisms declarative defined independently parsing procedure different definitions cf portion grammar affect efficiency resulting parser principle lead non termination certain inputs manner similar described shieber 
example consider anlt metagrammar ps rule analyses sentence noun phrase followed verb phrase 
bar subj plu plu vform vf bar plu plu case nom bar subj plu plu vform vf 
able rule tomita lr parsing framework rule manually split form firstly cf rule chosen set feature value pairs category represented atomic symbol secondly augmentation category contains respective residue features 
feature set creation cf rule chosen categories cf rule residue follows 
cf vb nn vb 
residue bar subj plu plu vform vf bar plu plu case nom bar subj plu plu vform vf obvious set features forming cf rules example bar additionally subj verbal categories case nominal category candidates features fully specified values 
difficult grammar writer substitutions consistent way difficult optimal way purposes lr parsing steps involve manual comparison categories appearing rule grammar 
constructing lr parse table directly automatically unification grammar avoid drawbacks 
case lr parse table complex categories unification complex categories place equality atomic ones standard lr parse table construction algorithm osborne 
approach computationally prohibitively expensive osborne reports system implemented hewlett packard common lisp hp workstation takes hours construct lr states unification grammar just productions 
general case procedure guaranteed terminate 
shieber describes technique restriction filtering information contained category dag increase efficiency induce termination parsers applications unification grammars 
theory technique approaches just described induce statically cf grammar unification grammar creating terminal non terminal categories disjoint sets equivalence classes dags dag restriction speed guarantee termination directly constructing parse table unification grammar shieber 
case large grammars restriction reduce time taken computation orders magnitude necessary cases manual definition effective difficult requiring detailed knowledge dynamic runtime behaviour grammar 
constructing cf backbone approaches lr parsing unification grammars involving direct construction parse tables initial manual derivation cf grammar unsatisfactory 
section describes alternative novel approach task computationally tractable realistic sized grammars safe inconsistency 
starting point anlt object grammar techniques involved generalise unification formalisms 
object grammar cf backbone rules containing categories atomic names associated residue feature name value pairs automatically constructed 
backbone grammar rule generally direct correspondence single object unification grammar rule 
lr parse table constructed cf backbone grammar 
parser driven table addition reducing sequence constituents parser performs unifications specified relevant unification grammar rule form category representing higher level constituent derivation fails unifications fails 
parser similar tomita performs unifications invoking cf rule augmentations main difference approach described tomita way cf grammar drives parser comes 
approach results line parser 
line strategy general possible automatic backbone generation process create cf grammar sufficiently constrained termination guaranteed 
general context strategies variants maxwell kaplan press interleaved pruning employed 
line strategy employing approach outlined behaviour identical parser just original unification grammar 
unification grammar best equivalent large worst features employed recursive cyclic ways possibly infinite set atomic category cf productions practice technique described produced lr parsers perform backbone grammars containing productions original unification grammar 
construction method produces optimal cf grammar sense alternative consistent cf grammar captures information unification grammar rule mapping 
construction method guarantees resulting lr parser terminate predictive source grammar principle allows 
method produce identical constrained backbone induced restriction see previous section optimal information part category just restriction category 
building backbone grammar stage process compute largest maximally specific set terms subsumption disjoint categories covering grammar assign category distinct atomic category name 
disjoint categories merge disjoint unifies merge disjoint disjoint specific category merge subsumes disjoint disjoint merge assign distinct name category disjoint unification grammar rule create backbone grammar rule containing atomic categories atomic category name assigned category disjoint category set unifies corresponding category unification grammar rule backbone cn rules bn bi name assigned single category disjoint unifies ci backbone backbone example object grammar rules compiled anlt metagrammar ps rules analyse sentence noun phrase followed verb phrase noun phrase determiner followed verb phrase intransitive verb transitive verb followed noun phrase step create set disjoint shown 
note value case nominal categories grammar collapsed variable lexical verbal categories remain distinct 
shows backbone rules built step 
algorithms creating lr parse tables assume terminal vocabulary grammar distinct non terminal procedure described deal properly unification grammar rule mother category assumed grammar lexical category 
case procedure modified associate categories different atomic categories terminal non terminal augment backbone grammar unary rule expanding non terminal category terminal 
aspects anlt object grammar formalism require minor elaborations basic algorithm 
firstly rule may introduce gap including feature bar subj plu plu vform vf bar plu plu case nom bar subj plu plu vform vf 
bar plu plu case case subcat det bar plu plu case case 
vi bar subj plu plu vform vf bar plu plu vform vf subcat 
vt bar subj plu plu vform vf bar plu plu vform vf subcat trans bar plu plu case acc 

anlt metagrammar ps rules 
bar subj plu vform np bar plu case vp bar subj plu vform det subcat det bar plu case bar plu vform subcat bar plu vform subcat trans 
categories disjoint 
np vp 
np det 
vp 
vp np 

backbone grammar 
specification null gapped daughter daughter extra rule added backbone grammar expanding gap category null string 
secondly rules containing kleene plus daughters new non terminal category created daughter extra rules added backbone grammar 
unary rule expands new category original category binary rule expands new category original category followed new 
modifications engender right branching binary tree structure intended flat sequence categories parser easily modified flatten tree structure processing 
example rule conj conj 
licensing noun phrases form kim lee sandy second daughter may repeated indefinite number times 
corresponding unification grammar rule backbone grammar rules forming noun phrase structure shown 
grammars written lower level unification grammar formalisms patr shieber commonly employ treatments type just described deal phenomena gapping coordination compounding 
processing techniques described permit grammar writer continue write grammars full facilities formalism allow algorithmic derivation appropriate backbone grammar support lr parsing 
major task backbone grammar encode sufficient information atomic cf rules unification grammar constrain application rules parse time 
nearly mapping unification grammar rules backbone grammar rules described works quite applied anlt grammar couple exceptions create spurious shift reduce conflicts parsing resulting unacceptable degradation performance 
phenomena concerned coordination unbounded dependency constructions 
anlt grammar uses general rules form nominal adjectival prepositional phrases conjunction categories rules lead disjoint categories conjuncts merged giving rise set overly general backbone grammar rules 
example rule anlt metagrammar forming noun phrase conjunct introduced conjunction lee sandy kim 
backbone parse tree kim lee sandy conj conj con subcat con 
variable value conj feature mother means categories specified feature conj conj null generalised category 
results backbone rules parsing kim lee helps unable forming conj constituent kim discriminate alternatives preparing iterate constituent phrase kim lee sandy helps kim conj null shifting word start new constituent 
system problem solved declaring conj feature may variable value element disjoint category set 
directs system expand unification grammar rule category containing feature variable value number rules fully specified feature create backbone rules 
possible values conj grammar general rule forming nominal conjunct example ends represented set specialised backbone grammar rules 
anlt grammar unbounded dependency constructions analysed propagating constituent parse tree non lexical major categories value slash feature section 
category specified slash usually appear grammar variable value feature backbone grammar contain information possible instantiations slash categories lose information unification grammar gaps allowed occur significantly degrading performance parser 
carry information backbone declaration ensures slash occurs variable value value expanded values notional value unifying 
experiments smaller grammar employing gap threading pereira shieber techniques expanding inference values case atomic features threading gaps able produce backbone grammar parse table constraining power respect gaps original grammar 
sufficiently constraining backbone grammar built previous release anlt grammar grover analysed gaps different way 
construction cf backbones grammars written formalisms minimal components completely general categories hpsg pollard sag klein calder require extensive inference patterns possible unification nested categories appropriate expanding categories concerned enable lr parser effectively 
areas complexity unification formalisms need investigation system claimed capable producing useful cf backbone unification grammar 
particular declaring certain category valued features take variable values may lead non termination backbone construction grammars 
possible restrict set features considered category valued features analogous way shieber earley algorithm parse table constructed 
building lr parse tables large nl grammars constructing lr parse table anlt backbone grammar generated anlt grammar large contains distinct categories productions 
programming language grammars typically categories productions give rise canonical lr tables containing states aho sethi ullman lalr tables contain 
spector argues lr tables larger slr lalr ones standard construction methods outlined knuth method splits lr states propagation lookaheads produce canonical lr tables canonical tables larger strictly necessary 
spector explains construct minimal state tables full lr claims comparable size produced lalr technique 
spector construction technique computes lr states full lr lookahead sets item call reduce action 
states conflicting reduce reduce actions single lookahead split minimum number states required ensure lr automaton path shifts states predecessor states branched 
technique remove shift reduce conflicts observes lr lr essentially respect grammar minimal lr table contains number states lr lalr tables canonical lr table reduce reduce conflicts 
minimal lr table anlt backbone grammar contain unmanageable number states single state reduce reduce conflicts random turns reducing phrase ends standard constituent immediate predecessor states turn order immediate lr table grammar contain shift reduce conflicts lr table strategy resolving conflicts shift performed preference reduce pattern shifts reduces formed input 
predecessors 
splitting states predecessor paths result massive increase number states 
large ambiguous nl grammar appears minimal state lr table construction impractical 
lalr powerful standard lr technique 
algorithms constructing lalr parse tables put forward literature approaches take grouped categories 
canonical lr item sets constructed sets common cores items lookaheads disregarded merged anderson eve horning ff aho sethi ullman ff 
lalr table constructed resulting sets way canonical lr table described section 
lr sets items computed items augmented lookahead symbols 
parse table constructed item sets way previous approach noting lookaheads required kernel items item start symbol grammar items symbol left dot 
add lookaheads anderson eve horning ff aho sethi ullman ff johnson give algorithm computes lr closure lr kernel item dummy lookahead symbol order determine lookaheads generated spontaneously propagate items algorithm repeated passes items propagating lookaheads quiescence reached 
lalonde lee horning alternative algorithm computes lookaheads lr item performing single recursive traversal item sets 
similar efficient version algorithm kristensen madsen 
indirect approach 
transform parse table construction problem set known directed graph problems turn solvable efficient algorithms 
ancona 
construct minimal set inadequate states containing action conflicts augment state set lookahead states resolve conflicts 
state graph algorithm grammars lr ancona technique fails lookahead state inadequate case non lr grammar 
ambiguous grammars fall class obvious way extending techniques cope approaches sort anlt backbone grammar 
approach involves attempt compute canonical lr table discussed construction minimal state table impractical anlt grammar 
initial implementation approach cut version anlt backbone grammar technique anderson demonstrated lr closure operation single dummy lookahead expensive practicable number size lr states full grammar schemes caching lr closures non kernel items constructed intermediate stages computation 
technique unnecessary compute lalr lookahead non kernel kernel items 
kristensen madsen algorithm avoids performing lr closure operation computing lookaheads kernel item single traversal lr item sets 
extension basic algorithm kristensen madsen ff marks items sets visited traversal allowing computation tell calculation lookahead set particular item completed underway started 
enables partially computed lookahead sets cached computation done explicitly marked items lookahead sets subsume able just copy results subsumed sets 
implementation basic algorithm able compute lookaheads anlt backbone reasonable amount time incorporation careful implementation extension computation practical 
anlt backbone grammar gives rise lr item sets 
kernel items computed set non kernel items cached retrieved needed 
able partition items way especially useful anlt grammar mean number kernel items lr set approximately mean number non kernel items state 
representing lr parse table large ambiguous grammar keep size parse table reasonable bounds appropriate data structures represent 
important issue practical parsing system indicates full version system ends running swap space associated performance penalties lr table consumes memory 
table anlt backbone grammar contains approximately goto entries nonterminal state pairs shift actions terminal state pairs reduce actions terminal rule number pairs goto entries distinct shift actions distinct states contain just reduce just shift actions state different rules involved reduce actions advantage characteristics distribution state system represents common lisp steele set goto entries list non terminal state sorted canonical order list elements tails lists shared possible states set shift actions list containing single large integer list shared possible states state shifts state lookahead element indexed auxiliary array contain number bit binary representation integer set reduce actions rule involved cons second element rule number bit vector shared possible states nth bit reduce occur nth terminal lookahead accept action cons element lookahead symbol 
parse table anlt grammar occupies approximately kilobytes space disc kilobytes loaded memory represents action shift reduce goto average bits 
current computer hardware table occupying amount space little impact parsing system size easily main memory avoiding performance costs swap space 
anlt grammar representation achieves similar order space saving comb vector representation suggested aho sethi ullman ff unambiguous grammars see klein martin survey representation techniques 
contrast conventional techniques parse table represented absolutely faithfully error entries replaced convenient non error ones order save extra space 
parsers driven table able detect failures soon theoretically possible lalr technique 
important property non deterministic parsing ambiguous grammars chapter alternative analysis possibilities may consideration stage ultimately fail earliest opportunity consume resources unnecessarily 
addition parsing interactively tables chapter early failure labour saving feature 
table compares size lalr parse table anlt grammar percent states contain action conflict 
shift reduce conflicts reduce reduce conflicts fairly uniformly distributed terminal lookahead symbols 
thirds conflicts rules involved identical number daughters 
implication finding approach conflict resolution shieber reduce reduce conflicts resolved favour longer reduction may suffice select unique analysis realistic nl grammars 
grammar number cf number number total number rules categories lr states kernel items actions pascal modula wright tomita japanese 
anlt ps rules table 
sizes grammar lalr parse tables 
reported literature 
figures anlt grammar twice size tomita combined morphological syntactic grammar japanese tomita 
grammar order magnitude bigger typical programming language lalr parse table terms number actions orders magnitude bigger 
tomita anticipates lr parsing techniques applied large nl grammars written formalisms gpsg sizes parse tables grammars grow rapidly predicts 
unambiguous computer languages purdom states space requirements lr tables tend grow linear function grammar size 
large realistic nl grammars anlt table size manageable despite johnson worst case complexity result number lr states exponential grammar size expected table illustrates parse table construction large grammars cpu intensive 
rough guide quotes lalr table construction grammar modula seconds scaling orders magnitude timings table construction anlt grammar fall expected region 
grammar backbone lr state lookahead parse table computation construction computation construction anlt table 
timings lalr parse table construction seconds cpu time sun running sun common lisp 
figures klein martin 
grammar spector optionality expanded statistics taken parse table constructed system described 
figures wright sharman 
figures tomita 
schabes describes variant lr parse tables number states guaranteed polynomial worst case 
chapter discusses implementation variant presents anlt grammar 

non deterministic lr parsing unification grammars chapter discusses algorithms proposed non deterministic cf parsing driven lr lr parse tables presents novel efficient cf lr parsing algorithm 
goes describe implementations unification table driven parsers empirical comparisons basis practical performance 
section discusses briefly lang non deterministic parsing framework goes describe tomita lr parsing algorithm means example summarises results show algorithm exponential worst case time complexity 
section describes parsing algorithm non deterministic lr recogniser elegant reformulation tomita algorithm 
modifications parsing algorithm improve complexity exponential polynomial 
section algorithm extended unification grammar methodology constructing unification lr parsers proposed chapter implementation described 
section goes describe implementation second unification parser lr algorithm schabes 
complexities unification parsers analysed practical performance compared bottom chart parser described chapter 
non deterministic context free lr parsing lang algorithm lang describes technique efficiently driving pseudo parallel certain classes non deterministic push automaton npda aho sethi ullman lr parse table construction methods ambiguous cf grammars derive 
resulting parser time space complexity 
parsing algorithm earley constructs item sets input length item consists tuple indicates input symbols successfully analysed current state top stack input symbol top stack state input symbol 
npda transition function takes current pushdown state symbol currently top stack symbol input string popping pushing single symbol stack possibly moving input symbol entering new state 
terminating successfully item sets form type packed parse forest parses extracted 
constituting general theoretical framework non deterministic parsing formulation lang complicated difficult understand probably reason appears little studied subsequently researchers 
certainly warrants investigation possible technique implementing predictive parsers obtain practical performance 
tomita algorithm tomita describes intuitively appealing parsing algorithm cf grammar lr parse table drive shift reduce parser represents state parse graph structured stack generalisation standard linear stack section 
graph structured stack similar chart gazdar mellish data structure distinct sub analysis represented 
algorithm lr table allowed contain multiple entries action conflicts caused ambiguities grammar 
parser reaches state action conflict stack divides branches corresponding analyses actions pursued conceptually parallel 
conversely separate analyses state point input string branches stack corresponding analyses joined state subsequent actions applied single merged analysis branch separately 
graph structured stack directed acyclic graph consisting vertices connected arcs vertex labelled state number arc contains single analysis analysis encode distinct ones means local ambiguity packing section 
situation packing possible due fact distinct analyses associated single arc top category rule subsequently applied arc form higher level constituent expects single category arc corresponding daughter rule 
cf grammar categories atomic test applicable packing category equality analyses single top level analysis 
reduce action rule daughters applied vertex locates ancestor vertices distance arcs ancestor action builds new packed analysis containing rule mother sequence sub analyses path arcs puts necessary newly created arc vertex labelled state specified goto table 
parsing halts successfully analysis single arc graph structured stack packed parse forest encoding possible analyses input string 
forest incorporate subtree sharing section reduce action new analysis built contains just pointers copies sub analyses arcs 
operation algorithm illustrated example grammar section shown lalr parse table section parsing sentence saw man park telescope 
algorithm commences creating single vertex labelled start state parse table zero 
state zero lookahead word table specifies action shift state 
shows stack shift 
arcs represented straight lines vertices circles analyses structures form packed analyses 
state lookahead vt table specifies reduce action np start vertex ancestor arc distant arc created vertex labelled state np goto state zero 
word saw shifted resulting situation 
parse deterministic park reduced np shown internal structure analyses indicated parentheses 
state lookahead action conflict performing reduction pp np shifting preposition enter state 
parser performs actions proviso reductions done shifts 
reduction park pp constituent put arc state followed reduction np np pp ancestor vertex labelled state goto state shift state word action conflict shift state state takes place 
situation point depicted 
note shifts state resulted previously divergent analyses merged subtrees analysing man park shared analyses sharing indicated curved lines parts analyses 
words telescope shifted reduced np arc state 
state lookahead table specifies reduction pp np 
time ancestor vertices arcs distant ones labelled states start arcs containing node 
states gotos state pp rule mother arcs result covering telescope starting ancestor vertices single vertex labelled state 
reductions pp np take place man park telescope ends analysed np different ways due ambiguity prepositional phrase attachment 
analyses lookahead vt 
stack shifting word lookahead det 
shifting word saw 
lookahead 
reducing park noun phrase 
lookahead det 
shifting word arc state packed 
reductions vp vt np np vp take place resulting stack single arc state zero 
table specifies accept action state lookahead parse halts successfully arc contains complete parse forest 
complexity tomita algorithm time complexity tomita comments parsing input length grammar exhibiting dense ambiguity example grammar generates set strings form algorithm may require time 
johnson follows expands describing sequence grammars member generates set strings sufficiently long inputs algorithm performs operations 
shown abbreviates sequence length 
result follows fact number different sequences daughter nodes topmost node licensed third rule grammar input string 
tomita algorithm construct sequences explicitly final reduce action rule algorithm performs operations 
particular parsing man park telescope 
stack reducing object noun phrase 

tomita densely ambiguous grammar 

johnson grammar grammar third rule contains daughters algorithm time complexity 
presents stronger result analysing actual algorithm detail showing time complexity number daughters longest production grammar 
traversal arcs graph structured stack reduce action order find ancestor vertices dominant factor complexity 
tomita algorithm modified improve complexity section presents novel version algorithm worst case 
looking complexity tomita algorithm respect grammar size johnson shows grammars total number operations performed exponential function size grammar 
result follows fact certain pathological grammars example generating set strings number lr states exponentially related grammar size inputs cause exponential number distinct states visited course parse 

johnson grammar space complexity argues space requirement recogniser tomita parsing algorithm proportional worst case 
argument fact space requirements dominated requirements graph structured stack major datastructure number vertices stack position input string bounded constant 
take account fact pointed johnson see number vertices position dependent number states grammar lr machine grammars inputs number vertices may exponentially related size grammar 
space bound recogniser aside dependency grammar arbitrary grammar worst case bound exponentially related size grammar 
tomita parsing algorithm requires space graph structured stack parse forest constructs result 
ignoring grammar dependencies tomita states parse forest representation takes space natural language grammars take grammars dense ambiguity 
example grammar takes space 
claims earley parse forest representation takes space arbitrary grammar representation incorrect 
schabes personal communication argues earley parse forest representation fact correct conjectures tomita misconception stems incorrect implementation earley parser 
potential source sub optimal space usage tomita algorithm arcs cover input contain analyses top category grammar symbol distinct start states 
correspond sets analyses applying different syntactic contexts 
case analyses arcs packed algorithm distinguish context analyses packed saving space time subsequent computation 
lang observe phenomenon parsing lr table leading parse times grammars significantly worse lr table equivalently slr lalr number states 
happens packing observed decrease density compared lr ambiguity input increases ambiguous left context unnecessarily represented explicitly 
results space utilisation experiments reported section suggest type sub optimal behaviour problem lalr parsing anlt grammar 
new efficient cf lr parsing algorithm basic algorithm analyse time complexity tomita parsing algorithm discussed previous section reformulates algorithm presenting elegant nondeterministic lr recogniser cf grammars shows process popping states graph structured stack reduce action results time bound exponential length input 
goes describe modified version algorithm certain types intermediate result cached order state popping process efficient 
modified algorithm polynomial time complexity aside dependency grammar size 
section novel non deterministic cf lr parser described modified version recogniser retaining recogniser time complexity bound 
parser uses graph structured stack way tomita algorithm algorithm parser performs sub analysis sharing trees common sub analysis sub analysis represented local ambiguity packing sub analyses top node cover input top nodes merged treated higher level structures single sub analysis 
parser polynomial time complexity improving exponential worst case complexity tomita 
algorithm implemented unification nondeterministic lr parser 
parser described section forms basis probabilistic non deterministic parser chapter 
preliminary version cf parsing algorithm described time complexity tomita algorithm unmodified reformulation caching 
section demonstrates version algorithm circumstances produce spurious duplicate analyses describes modification remedies problem 
algorithm modified cache intermediate results reducing complexity 
algorithm formally takes input sequence words assumed non empty returns list analyses complete constituent covering input forming packed parse forest 
global data structures list analyses vector holding graph structured stack ith element list graph vertices incoming arcs representing constituents position input string 
vertex represented structure containing fields position string incoming arcs lr state number list arcs arc structure components start vertex analysis analysis 
simplify description algorithm analysis represented node structure word packed analyses cf version 
unification version algorithm described section chart parser described chapter analysis consists node node variable table 
rule represented daughter category list algorithm initialises zeroth stack element list containing single vertex position field zero state field start state lr table arc list empty 
rest stack elements initialised empty list analyses 
parsing consists word input position retrieving lexical entries word list categories initialising list done processing reduce actions empty performing shift reduce accept actions vertices stack position 
result vertices created stack position analyses processing stops immediately 
input reached shift process repeated lexical entry list containing single atom 
list analyses returned 
shift reduce accept process consists stages 
firstly vertex stack position vertex added done list reduce accept reduce action production specified lr parse table vertex state lexical entries current word reduce called vertex production accept action specified analyses incoming arcs appended list analyses 
reduce accept repeated new vertices reduce adds stack position quiescence 
secondly vertex stack position category list lexical entries current word lr parse table state vertex specifies shift action shift called vertex state shifted partial analysis node structure containing category word 
vertex state partial analysis shift puts analysis arc starts vertex finishes second vertex state position input 
checking see arc vertices analysis top category arc packed form single analysis 
second vertex stack new arc containing analysis constructed vertices 
second vertex created added stack joined vertex new arc containing analysis 
reduce takes vertex production calls ancestors finds ancestors vertex distance equal number daughters production path ancestor creating arc starting ancestor containing analysis top category production mother daughters analyses arcs forming path 
reduce iterates new arcs adding stack vertex position input state entry mother goto table ancestor state 
add arc stack reduce checks vertex exists 
vertex created arc added incoming arcs list 
arc ancestor analysis new arc simply packed analysis existing arc arc new arc added list running ancestor vertex additionally vertex done list arc may missed reductions performed vertex clone variant vertex just new arc single incoming arc passed reduce accept adding new arc ancestor vertex check see arc running variant ancestor vertex 
arc added variant cloned form ancestor 
case vertex processed arc may missed reductions clone vertex just new arc single incoming arc passed reduce accept formal definition algorithm just described object list list contains elements returns number elements list objects relevant processing denoted lists enclosed square brackets sets braces 
modifications algorithm correctness efficiency correctness modifications processing steps parsing algorithm described previous section correspond closely recogniser algorithm incorrect point 
arc created finishes vertex list done vertex cloned arc single incoming arc reduce accept invoked 
vertex currently processed vertex added done reductions done performed twice arc incoming arc incoming arc clone vertex 
may result spurious duplication analyses 
fix problem arc immediately inserted stack currently processed 
insertion delayed processing finished 
modifications detailed algorithm accomplish 
parse analyses done lexical entries new vertices new done done reduce accept shift actions shift return return analyses reduce accept reduce actions reduce acc actions analyses analyses shift reduce ds arc ancestors ds goto reduce accept arc arc done reduce accept arc arc ancestors alts return alts return ancestors alts 
non deterministic cf lr parsing algorithm preliminary version 
replace line new done done reduce accept replace line done arc arc 
correctness modifications preliminary parsing algorithm 
modified version vertex added done arc added list initialised empty vertex processed processing complete arc added incoming arc vertex arc exists analysis arc packed 
efficiency modifications shows time complexity recognition algorithm arbitrary grammar 
complexity dominated number steps taken reduce function virtue invocation ancestors worst case current position input string maximum number daughters production 
parsing algorithm may analysed similar way shown complexity 
goes describe recogniser ancestors turned effectively table look function changing complexity recogniser section describes novel realisation technique conjunction change representation analyses applied parsing algorithm previous section produce new algorithm complexity parsing algorithm ancestors applied vertex course reduce action function returns arc path vertex reached ancestor number daughters reducing production arcs distant 
arc contains analysis top category mother production daughters list analyses arcs forming path 
number paths bounded number ways partitioning input symbols occurring ancestor vertex positions symbols right hand side production 
ancestor position number paths equivalently arcs bounded 
summing expression zero gives result reduce processes arcs separately worst case complexity invocation function bad just modifying ancestors perform table look improve complexity algorithm bound number arcs returned ancestors improved 
achieved changing representation node list nodes second component node contains list node sequence alternatives node sequence defined empty list list element node rest elements alternative node sequences 
change ancestors need return arc distinct ancestor vertex distance possible sequences nodes lying alternative paths ancestor encoded single list node sequence alternatives held arc gives example result call ancestors reducing verb phrase saw man park telescope production vp np pp 
note arc returned paths vertex course new representation nodes final parse forest created parser represented differently new old representations completely equivalent 
ancestors returns single arc ancestor vertex result making total arcs reduce executes steps excluding time ancestors saw man park telescope np np pp pp ancestors vp pp np pp np 
node sequence alternatives arcs returned ancestors ancestors time bound invocation follows paths ancestors process potentially recursing particular segment path 
eliminate redundancy second modification introduce cache constant time access update properties keyed firstly vertices graph structured stack secondly integers cache entry keyed contains list arcs representing possible node sequence alternatives start vertex distance constituents stack vertex cache elements initially empty 
modified version algorithm procedure arc added invoked update cache held cache processing takes place time algorithm adds new arc existing list arcs creates new vertex incoming arc 
happens places shift reduce arc added takes vertex arc finishes arc start vertex 
adds existing elements cache keyed version arc analysis form list node sequence alternatives 
function updates cache elements integer values considering cache entries extending analysis new arc incorporate analysis cache arc added checks entry start vertex entry extended entry node sequence alternatives augmented sequence consisting entry extended arc added arc cache cache alts cache alts cache alts alts alts cache alts cache ancestors return return alts alts cache 
efficiency modifications preliminary parsing algorithm 
cache implemented straightforwardly dimensional array indices vertex state vertex string position integers addition new arc analysis new entry added sequence alternative 
cache date entries affected addition deletion arcs stack analyses packed existing ones algorithm deletes arcs arc added invoked update cache immediately addition arc node packed cache packing occurs cache updated automatically side effect 
cache contains correct lists ancestor vertices associated node sequence alternatives distance vertex new version ancestors needs little table lookup longer recursive need take third argument alts 
equal zero cache consulted function returning set containing single arc starting analysis top node production mother single node sequence alternative consisting empty list 
greater zero copies cache entries keyed returned assigned top node analysis 
practice grammar containing unary binary branching rules overheads associated introducing caching may negate gains accruing longer having traverse long paths construct lists ancestors 
question caching improves parsing performance particular grammar investigated empirically 
complexity modified algorithm time complexity modifications described previous section preliminary version parsing algorithm serve reduce time complexity general case 
section derives complexity result 
important observations form basis complexity analysis number vertices bounded number states parse table number parents vertex proportional observations hold parser 
parse function word input shift called bounded number times upper limit result multiplying number lexical entries word number vertices 
number vertices bounded shift executes bounded number steps calling arc added 
parse calls reduce accept vertex number calls bounded 
word number top level calls reduce bounded number lexical entries word multiplied number productions grammar 
recursive call reduce reduce accept performed times reduce accept called parent vertex call reduce ancestors called returning arcs reduce iterates 
iteration invokes arc added twice give rise single recursive call reduce clone vertex 
recursive call iteration clone ancestors recursion possible furthermore new vertices created stack normally created exist processing vertex clone variant 
packing existing analyses occur arc added invoked recursion 
arc added takes time proportional arc start vertex position input entries cache location 
time bound assumes arcs cache indexed start vertex test arc added performed unit time 
merely performs table lookup ancestors executes time called vertex position worst case time bound dominated time taken reduce function called bounded number times top level call vertex position takes time function recurses clone vertex 
summing zero gives time bound proportional algorithm space complexity modified parsing algorithm graph structured stack takes space proportional worst case reasoning section aside grammar dependencies 
parse forest incorporates subtree sharing local ambiguity packing addition sequences constituents shared analyses cases reduction takes place single vertex graph structured stack paths ancestor vertices split 
shared constituent sequences exactly node sequence alternatives introduced section corresponding rightmost daughters rules compare leftmost daughter sharing chart parser discussed section 
similar argument section invoking lang grammar parses space complexity parse forest arbitrary grammar 
note caching obviates requirement completely enumerate possible node sequences reduce action sequences effectively packed 
complete enumeration sequences tomita algorithm leads johnson lower bound operations grammar see section 
parse forest complexity analysis ignores situation analyses top category spanning segment input string normally packed fact appear distinct arcs due states involved encoding contextual distinctions lang 
frequency situation occur related number places parse table rule recognised amount ambiguity grammar table construction method 
clear worsens space complexity parse forest complexity unaffected dense ambiguity way tomita algorithm 
tomita algorithm space taken graph structured stack dominant term algorithm grammar dependencies taken account 
efficient non deterministic cf lr algorithms leermakers describes deterministic lr recognition algorithm expressed terms finite state automaton represents state canonical lr collection executable procedure 
course parse procedures currently run held main execution stack serves purpose stack explicitly maintained shift reduce parser 
applying algorithm non lr ambiguous grammars results exponential time complexity procedures implemented memo functions complexity respect input length reduced 
memo function procedure called arguments previous invocation returns previous result recomputing 
technique attain cubic complexity parsing algorithm chapter closely related employs caching avoid ancestors procedure having repeatedly compute lists arcs 
techniques share property exponential grammar size due lr state collection 
nederhof casts left corner lc parsing similar framework tomita generalised lr technique 
graph structured stack parser works breadth output packed parse forest containing additional subtree sharing sequences constituents shared analyses algorithm described chapter 
nederhof parser cubic time space complexity arbitrary cf grammar advantages lr important fact size parse table required quadratic size grammar generated relatively quickly efficiently 
technique suitable grammar development lr 
parse forests created compact possible contrast lr technique space utilisation non optimal discussed section 
lr technique powerful produces predictive parse tables reason generalised lr parsing efficient generalised lc parsing nederhof 
empirical comparison performance parsers techniques interesting 
schabes describes algorithm constructing predictive parsing table cf grammar algorithm non deterministic chart parser driven table 
table compiles predictive component earley parser cubic time complexity 
schabes technique discussed section evaluated empirically section 
non deterministic unification lr parsing section approach lr parsing unification grammar outlined involving initial automatic derivation atomic cf backbone grammar construction lr parse table backbone 
parser driven table reductions additionally perform unifications specified unification grammar rules form feature categories representing higher level constituents abandon parts derivations unifications concerned fail 
section describes algorithm non deterministic cf lr parser may adapted augmented form non deterministic unification lr parser 
section discusses issues raised implementation adapted algorithm analyses complexity empirical comparison performance relative implementation unification version second predictive lr parser proposed literature alternative type efficient parser 
extending cf parsing algorithm unification non deterministic unification lr parser described extension preliminary version cf lr parsing algorithm including correctness modifications section 
efficiency modifications incorporated unification parser reasons explained section 
implementation parser forms part alvey natural language tools chapter 
appears nondeterministic unification lr parser previously described literature comparable implementation exists 
basic control structure unification parser identical cf parser parser driven way lr parse table table constructed backbone grammar 
differences cf unification algorithms due having perform unifications reduce action equivalent operation needed cf algorithm constituent top categories sequence reduced constituents production guaranteed equal production daughters feature category subsumption section required check packing equivalent operation needed cf algorithm analyses arc automatically atomic top category 
cf lr algorithm arc contains fields start vertex analysis 
analysis field may implicitly contain distinct analyses encoded single analysis packing 
unification version arc able contain explicit list analyses possible check packing necessary see top nodes constituents arc nodes correspond atomic category related subsumption 
parser arcs structures form analysis list algorithm modified accordingly iterate second field appropriate shift reduce ancestors variables algorithm called representing single analysis better named list analyses unification version 
reduce accept accept action result list constituents appended list analyses 
analysis needs variable table associated section analysis longer simply node record analysis record 
parse set backbone grammar categories corresponding lexical entry feature category determined 
set usually contains element general may contain lexical entry generalises backbone grammar categories 
implementation task performed efficiently vector discrimination nets feature values similarly way rule retrieval handled chart parser 
additional complication caused able pack analyses arc new analysis added arc analysis packed analysis may reductions vertex arc processed vertex member done care taken case vertex currently processed ensure reductions done performed twice arc similar situation dealt correctness modification section 
shows modification algorithm gives correct behaviour 
operator denotes append 
function pack analyses invoked takes lists analyses packs analysis second list list returns ones packed 
pack analyses invoked shift modification points perform packing 
tomita system value attribute cf rule augmentation may uniquely determined leading need unpack analyses construction parse forest 
system described suffer potential source inefficiency unification category feature unique value category atomic value unbound variable 
reduce action parser perform unifications required unification grammar rule corresponds backbone rule involved create new constituents categories instantiated versions unification rule mother 
parser carries tasks ancestors function 
arc traversed function creates new set alternative partial analyses constituent held arc extending partial analysis current set result unifying top category constituent category corresponding daughter unification grammar rule unification algorithm described section 
partial analysis consists list constituents pair variable tables holding values variables rule categories variables analyses arcs 
unification fails constituent concerned added partial analyses unifications constituents arc fail arcs traversed set partial analyses concerned discarded 
ancestors distance equal number daughters rule reached new arc created starting ancestor arc analysis lists new analysis structures created partial analyses 
node field analysis filled node category result copy category section applied rule mother rule category variable table node list field replace line nas pack analyses nas done nas nas done reduce accept nas 
packing test reduce unification algorithm 
list arc categories partial analysis 
partial analysis category variable table value variable table field analysis structure 
efficiency modifications cf algorithm applied unification version rely observation analyses arcs top categories returned ancestors call function vertex production having particular number daughters 
unification system daughters unified sub analyses stack general categories variable tables different call 
results different time 
initial implementation unification lr parser described turned slower expected 
investigation showed case unifications performed repeatedly course single reduce action 
duplication happening cases distinct arcs stack contained identical feature categories arcs traversed ancestors course reduction single unification grammar rule 
cases due fact backbone grammar constraining unification grammar unification grammar rules map backbone rule 
caching lists partial analyses unification results keyed arc analysis backbone rule daughter variable tables ensuring fast access cache entries wasted effort eliminated speed parser improved factor little space cost 
practical performance parser discussed section 
schabes lr parser schabes describes algorithm constructing predictive parsing table cf grammar algorithm left right non deterministic parser driven table 
table compiles predictive component earley parser schabes demonstrates parser takes fewer steps earley time complexity 
table construction method ensures number states parse table linearly related size grammar resulting number operations performed parser worst polynomial function grammar size 
space complexity parser uses earley representation parse forests 
schabes claims experiment carried tomita results heavily favour cf parser implementation earley parser shows conclusive outcome replicated 
schabes attributes statement modified version recogniser lead practical parser statement refers 
basis claims demonstrated time complexity techniques schabes describes deserve practical investigation parser implemented adapted unification parsing 
parser described 
sections theoretical practical aspects parser compared lr parser previous section 
construction unification parser schabes techniques follows methodology developed unification lr parsing described chapter section table computed cf backbone parser augmented unification feature subsumption operations driven table 
states parse table built schabes parser differ standard lr collection state contains exactly kernel item lr state contain goto function split functions goto state goto nk state distinguish transitions symbols kernel non kernel items state 
schabes describes method constructing states parse table unification parsing system implements method 
order allow parser compared fairly described previous section symbol lookahead added table applying kristensen madsen lalr construction technique see section description technique modified slightly take goto state sets union sets kernel non kernel goto transition states 
parse table results anlt grammar occupy large amount storage actions represented appropriate data structures hold lalr tables built system uses variant technique described section compactly representing standard lr tables ambiguous grammars 
schabes describes algorithm non deterministic chart shift reduce cf recogniser driven parse table explains turned parser constructing earley parse forest representation shift action including pointer item added chart caused shift take place reduce action item added chart case items causing 
representation identical produced node sequence alternatives nondeterministic cf lr parsing algorithm section 
shift reduce actions implemented efficiently parser time bound attained possible retrieve unit time items chart having state start position input string 
implementation parser item chart fields state set node successful application technique supports schabes assertion methods lr slr constructing parsing tables 
schabes parse table anlt grammar contains approximately states total shift reduce goto actions 
sequence alternatives start position 
parser works similarly cf version schabes describes reduction item backbone production daughters unification rule corresponds unified alternative sequence constituents item 
analysis results possible packed computed previously 
representing chart dimensional array indexed state start positions guarantee constant time access items required theoretical cubic time bound 
say word sentence anlt grammar array contain half entries typical computer hardware consume order megabytes memory empty 
reason implementation trades large reduction space requirements moderate increase cpu time employing sparse representation store array practice small proportion possible entries filled 
parser sort duplication unifications occurs lr parser lists partial analyses unification results cached way 
parser works quite successfully section gives evaluation practical performance demonstrating methodology building unification parsers backbone cf grammar compiling parse table backbone performing unifications parse time generally applicable restricted just standard lr techniques 
complexity unification versions lr schabes parsers time complexity lr cf parser section lr parser described schabes aside dependency grammar 
unification versions lr lr parsers turn time bounds greater worst case 
phenomenon analogous increase complexity bottom chart parser chapter extended context free unification grammar 
lr schabes lr parsers reduce action daughters rule involved unified possible alternative sequence sub analyses consumed rule 
analogous operation necessary cf parser 
rule contains daughters sub analyses span words input string sequences number ways partitioning line containing intervals segments worst case bound number unification operations necessary single reduction 
lr parser reduce called bounded number times position input string summing zero zero gives bound total number unifications 
lr parser reduction operation may applied bounded number times item chart spanning positions 
leads summation giving bound parser 
intuitively think unification versions parsers effect expanding flattening packed sequences sub analyses reduction useful efficiency properties representation 
parsers cache results unifications give improvement constant factor cached results serve decrease amount processing performed second subsequent reductions segment input complexity bounds stand just single reduction performed segment 
worst case time complexity lr lr unification parsers exponential sentence length 
theoretical bound suggest parsing performance severely degraded long sentences borne practice anlt grammar lr parser implementation able compute parse forests sentences words length having thousands analyses 
performance comparison unification chart lr parsers lr parsing advocated suitable technology implementing natural language parsers order obtain practical performance tomita wright sharman 
assess lr parsing meets goal parsing unification grammars experiment carried anlt grammar compare performance predictive lr parsers described chapter anlt bottom chart parser shown chapter attain state art performance 
performing experiment implementations parsers checked carefully ensure similar high standard similar implementation techniques parsers addition parsers share unification module profiled tools optimised similar extent 
predictive parsers employ symbol lookahead incorporated parsing tables lalr technique 
experiment sentences test sets chapter total sentences mean length words 
parsers cpu time storage allocated parsing sets sentences added 
table gives summary results 
time chart parser double corresponding section experiment run sun sparc elc workstation tomita experiments relative qualities implementations non deterministic lr parser version earley parser open question light schabes comments experiments duplicated results support tomita 
cpu time storage allocated bottom chart parser lalr parser schabes type parser table 
parse times cpu seconds dec workstation storage allocated megabytes test sentences chapter 
relatively slow dec 
total numbers unifications performed thought useful statistic aid comparison unification basic operation parsers meaningful count chart parser due rule retrieval optimisations number unifications factored time space figures overheads inseparable part parsing strategy case 
statistics indicate non deterministic lalr parser approximately faster chart parser allocates storage 
argued chapter parse time important factor practical parsing long ambiguous texts parsimonious storage significant consideration reduced storage requirements lalr parser compared chart parser addition better parse times suitable tasks 
taken context enthusiastic non deterministic cf lr parsing researchers see start section performance figures unification lalr parser appear somewhat disappointing 
scope experimenting backbone grammars expand different unification grammar features manually tuning resulting grammars attempt improve parsing performance 
whilst efforts probably limited amount success dramatic gains accrue 
subsequent modifications unification grammar invalidate tuning efforts sort 
modest performance advantage lalr parser chart parser helps confirm negative result top processing experiments anlt grammar described section 
experiments decrease number inactive edges observed modified version chart parser left corner reachability table fact decrease possible gaps predicted occurred 
empirical results reported section demonstrate performance gains unmodified chart parser achieved anlt grammar precomputing context free predictive lr component drive parser 
grammar sophisticated precompilation techniques applied directly unification grammar give performance improvement chart parser 
techniques described chapter bottom chart parsing competitive technology unification parsing 
parsers experiment exhibit exponential factors worst case time complexities 
relationship length sentence parse times anlt grammar sentences tested appears merely lie linear quadratic 
probably reasons performance better complexity results suggest important may rules grammar daughters rules license left right recursion instance sort typically analyse noun compounding 
looking performance schabes type parser figures show twice slow lalr parser slower chart parser 
intermediate terms storage allocated 
space difference difference speed lalr parser due fact performs unifications 
expected corresponding finite state automaton fsa avoid theoretical exponential time complexity grammar size pays price run time dynamic programming simulation non determinism essentially algorithm fsa weir personal communication 
appears remaining difference speed due space time trade necessary order able represent chart reasonable amount memory 
practical aspect analysis complexity identify 
part schabes motivation developing parsing algorithm eliminate theoretical exponential time complexity tomita algorithm grammar size 
schabes ensuring number states parse tables algorithm merely linear function size grammar exponential lr tables 
case anlt grammar despite fact fewer actions schabes type parse table lalr table total see section statistics size schabes table contains states suggests considering complexity parsers issue parse table size minor importance real world nl grammars long implementation represents table compactly improvements complexity results respect grammar size interesting theoretical standpoint may little practical relevance processing natural language 
table contains state kernel dotted item implicit grammar 
schabes suggests selected portions table decrease non determinism finite state control resulting table contain states original table 

probabilistic lr parsing realistic wide coverage nl grammars anlt grammar described chapter produce large numbers analyses syntactically legitimate inputs 
chapter describes practical parsing system capable returning probabilistically highly ranked analyses material drawn specific corpus basis minimal supervised training manual modification 
system tested definitions machine readable dictionary results experiments corpus reported probabilistic approaches parsing previous approaches field speech recognition statistical techniques hidden markov modelling established sufficiently described textbooks example holmes 
main algorithms utilised viterbi algorithm baum welch algorithm baum 
provides polynomial solution task finding probable derivation input stochastic regular grammar polynomial method performing iterative re estimation parameters hidden stochastic regular grammar considering possible derivations corpus inputs 
baker demonstrates baum welch re estimation extended context free grammars cfgs chomsky normal form cnf 
typically applications markov modelling speech recognition derivation analyse input interest sought best model input 
application similar techniques parsing derivation selected prime interest 
baum proves baum welch re estimation converge local optimum sense initial probabilities modified increase likelihood corpus grammar stabilise threshold number iterations training corpus 
guarantee global optimum priori initial probabilities chosen critical convergence useful probabilities lari young 
main application techniques text robust lexical tagging corpora part speech labels garside leech sampson research reported chapter stems extensive discussions ted briscoe 
disambiguation method section technique associating probabilities lr tables section normalisation calculation described section represent joint 
de rose meteer schwartz weischedel cutting 
fujisaki 
describe corpus analysis experiment probabilistic cfg greibach normal form containing rules corpus sentences 
unsupervised training process involved automatically assigning probabilities cf rule basis frequency occurrence possible analyses sentence corpus 
probabilities iteratively re estimated variant baum welch algorithm viterbi algorithm conjunction cky parsing algorithm kasami younger efficiently select probable analysis training 
model restricted possible parameters rules defined category set initially set zero training estimate new probabilities set predefined rules 
fujisaki suggest stable probabilities model semantic pragmatic constraints corpus correlate frequency rules correct analyses noise training data created incorrect parses effectively factored 
depends number false positive examples incorrect analyses degree heterogeneity training corpus forth 
experiments reported fujisaki corpus originally training sentences examined probable analysis correct analysis 
remainder false positives receive correct parse whilst marked probable 
success rate sentence 
sharman jelinek mercer conducted similar experiment grammar id lp format gazdar sharman 
id lp grammars separate types information encoded cf rules immediate dominance immediate precedence rule types define cfg 
allows probabilities concerning dominance associated id rules factored concerning precedence associated lp rules 
experiment supervised training regime employed 
grammar containing terminals non terminals initial probabilities frequency id lp relations extracted manually parsed corpus words text 
resulting probabilistic id lp grammar parse sentences drawn corpus 
addition lexical syntactic probabilities integrated probability id lp relations rank parses 
experiment sentences words drawn training corpus parses identical original manual analyses whilst similar yielding success rate 
pereira schabes report experiment baum welch re estimation infer grammar associated rule probabilities category set containing non terminals greibach normal form similar cnf production contains terminal category leftmost daughter 
terminals corresponding penn treebank lexical tagset santorini 
training data sentences represented tag sequences drawn treebank 
system trained unsupervised mode semi supervised mode manually parsed version corpus constrain set analyses re estimation 
supervised training analyses accepted produced bracketings consistent necessarily identical assigned manually 
supervised mode training converged faster resulted grammar probable analysis compatible manually assigned analysis test sentences drawn treebank greater percentage cases opposed 
result indicates clearly importance supervised training particularly context grammar inferred addition probability individual rules 
sampson haigh atwell describe parser order assign analysis uses statistically defined measure closest fit set hand assigned analyses contained training data taken lob treebank sampson 
approach simulated annealing attempts ensure analyses new data conform closely possible existing ones 
sampson express results experiments technique terms tree similarity measure respect correct analyses assigned hand 
sentence sample mean similarity measure input received fully correct analysis 
results suggest technique current form reliable practical nl analysis 
analyses assigned lob treebank scheme syntactically determinate example syntactic relations unbounded dependency constructions represented 
problems probabilistic cfg experimental results reported probabilistic parsing systems mentioned quite impressive inherent problems probabilistic cfg including id lp systems 
firstly cfg adequate model majority constructions occurring natural language gazdar mellish clear cfgs need large lead difficulties manual development consistent grammars possibly computational intractability parse time particularly computationally expensive training phase 
secondly apparatus analyses returned grammars linguistically relatively unsophisticated formalism cfg id lp version derived analogy manual analyses training corpus formed respect generative grammar sampson system detailed support subsequent semantic interpretation 
thirdly associating probabilities cf rules means information probability rule applying particular point parse derivation lost 
leads complications distinguishing probability different derivations rule applied times way 
gives example probabilistic cfg pcfg grammar section production associated probability probabilities rules expanding non terminal category sum 
pcfg probability particular parse product probabilities rule derivation 
probability parse 
parse identical probability rule applied twice case 
similarly probabilities identical essentially reason 
rules concerned natural treatments noun compounding prepositional phrase attachment english different derivations correlate different interpretations 
example appropriate analysis toy coffee whilst appropriate cat food tin yields possible interpretations noun phrase man park telescope ideally structural configurations kept probabilistically distinct case structurally conditioned differences frequency occurrence predicted example theory parsing strategies frazier 
fujisaki 
propose inelegant solution noun compound case involves creating instances identical rules classes word forms distinct bracketing behaviour noun noun compounds 
technique enlarges grammar excessively merges probabilistic lexical information probabilistic structural information multiplies parameters probabilistic model 
pcfgs model context dependence rule example noun phrase expanded pronoun subject position magerman marcus global probability associated relevant cf production 
pcfg model predicts incorrectly probability occurrence 
considerations suggests need technique employs np det np vp np np pp vp vt np vp vi pp np np 
probabilistic version 
np np np pp np pp np det vp vt np np np pp np np pp np vp vt np det 
context free derivations 
adequate grammatical formalism cfg context dependent probabilistic model 
researchers wright wright ng tomita wright sharman proposed lr technique practical method parsing pcfg 
approaches lr parse table derived cf component grammar standard way addition rule probabilities distributed sets actions lr parse table 
distribution performed way ensure product probabilities attached lr actions taken derivation analysis identical probability assigned analysis original pcfg 
sections describe novel approach probabilistic parsing lr parsing technique way obtain finite state representation non finite state grammar incorporating information parse context demonstrate lr parse tables provide appropriate amount contextual information solve problems described 
approach cf backbone grammar lr parse table computed anlt grammar techniques described chapter probabilities associated directly parse table associated rules grammar pcfg equivalently mapped pcfg lr parse table 
lr parse state encodes information left right context current parse 
system probabilities assigned transitions lalr table process supervised training computing frequency transitions traversed disambiguated corpus parse histories constructed user driven interactive lr parser 
deriving probabilities relative parse context allows probabilistic parser pcfg distinguish derivations differ terms order application set cf backbone rules context defined lalr table situations identical rules apply differing probabilities different contexts 
probabilistic lr parser remains stochastic order finite state model lalr table defines non deterministic finite state machine total probability analysis computed sequence transitions taken construct 
language models decision procedures approach outlined result language model pcfg probability sentence sum probabilities possible derivations 
approach constitutes decision procedure language models trained baum welch re estimation maximise sum probabilities sentences corpus grammar 
debatable property required task select single plausible derivation analysis sentence clear connection probability derivation sentence 
task appropriate maximise probability correct derivation sentence training corpus 
particular implications re estimation process interpretation probabilities contained language model counterintuitive 
example consider pcfgs grammar probability string string derivation involves instance rule instances rule 
second grammar assigned probability 
string length receives higher probability cases rule higher probability string length turns length unary rule higher probability 
clear language models suitable task parse selection 
researchers noticed problems language models pcfg described approaches parsing idea context sensitive derivation 
probabilistic cf grammars 
ted briscoe pointed example 
note grammars generate normalised probabilistic languages case sum probabilities sentences generated sum wright 
probabilities 
example pearl magerman marcus magerman weir decision procedures estimate probability derivation geometric mean product conditional probabilities cfg rule appearing derivation non terminal trigram context dominating rule part speech trigram point 
grishman describe context dependent probabilistic model probability possible expanding production non terminal appearing right hand side rule recorded separately report decrease incorrect analyses previous standard pcfg 
approaches distinguish structures resulting noun compound ambiguities example 
achieving promising results limited domain systems cfg produce analyses detailed support semantic interpretation 
framework implemented system described rest chapter intended constitute principled linguistically adequate approach 
section describes disambiguated training corpus system uses constructed probabilities derived section describes probabilistic parser reports results corpus parsing experiment probabilistic lr system 
training interactive incremental lr parsing constructing disambiguated training corpus major problem attempting employ disambiguated training corpus find way constructing corpus error free resource efficient fashion 
manual assignment lexical categories tagging slow labour intensive error prone 
greater complexity constructing complete parse totally manual approach unattractive impractical 
sampson reports took person years produce lob treebank words 
furthermore project attempt ensure analyses formed respect generative grammar 
attempting manually construct analyses consistent grammar size sophistication place enormous additional load analyst 
leech garside discuss problems arise manual parsing corpora concerning accuracy consistency analyses time analyst labour intensive nature producing detailed analyses forth 
advocate approach simple skeleton parses produced hand previously tagged material checking consistency analysts 
skeleton analyses augmented automatically information implicit lexical tags 
whilst approach may best achieved fully manual techniques unsatisfactory 
firstly analyses crude clear train existing grammar unrelated analyses 
secondly quality grammar obtained automatically parsed corpus poor lack rigorous checks form skeleton parses 
grammar principle trained parsed corpus mismatches actual analysis assigned manually assigned automatically 
training problems overcome employing method produces training corpus grammar ultimately trained guaranteeing analysis assigned member set defined grammar 
similar type technique employed construction substantial lexicon anlt grammar unreliable indeterminate data carroll grover disambiguated training corpus created semi automatically manual interaction restricted selection alternatives defined anlt grammar 
briscoe demonstrates structure search space parse derivations allows left right incremental mode parse selection effective 
example noun compounds analysed recursive rule number analyses correlates catalan series church patil see section 
briscoe shows simple bounded context parser word lookahead set request help parse indeterminacy arises possible select analyses word compound maximum interactions analyses word compound interactions 
general resolution indeterminacy input rule approximately half potential analyses resolution half remaining ones 
worst case cf ambiguities approach parse selection appears empirically involve numbers interactions increase little linear rate respect length input 
possible exploit insight ways 
method compute possible analyses represented packed parse forest ask user select competing incorporated successful analysis input 
way genuine global syntactic ambiguities need considered user 
disadvantage approach relies prior cpu intensive line computation full set analyses 
second method involves user interacting incremental parser guide search space possibilities 
advantage guaranteed computationally tractable potential disadvantage requiring user resolve local syntactic ambiguities incorporated successful analysis 
lr augmented lookahead techniques problem minimised time consuming line computations avoided interacting user system uses incremental method 
interactive lr parsing system interactive incremental parsing system asks user decision choice point parse 
usable practice system avoid far possible presenting user choices ruled left context looking words parsed 
approach implemented goes way addressing points parser predictive backbone grammar lr technique allow lalr parse table allows word lookahead resolve ambiguities course resolution local ambiguity may potentially involve unlimited amount lookahead 
lr parser faces indeterminacy enters state possible action current lookahead 
particular state shift actions state reduce actions specifying reduction different rule addition shift action 
parsing shift reduce alternative necessarily lead distinct analysis indeterminacy represents point syntactic ambiguity may correspond genuinely global syntactic ambiguity input account limited amount lookahead 
anlt grammar lexicon lexical ambiguity pervasive structural ambiguity 
naive implementation interactive lr parser ask user correct category ambiguous word shifted open class words assigned upwards lexical categories anlt lexicon relatively fine distinctions strategy completely impracticable 
avoid asking user lexical ambiguity parser uses technique delaying shieber assignment atomic category lexical item choice forced particular production reduce action 
shifting ambiguous lexical item parser enters state corresponding union states entered shifting individual lexical categories 
union states practice small imply current context completely failing constrain input 
general unification grammar categories single word may subsumed single atomic category shieber technique extended deal grammar containing feature categories associating just set alternative feature analyses state letting choice forced reduce actions just atomic categories 
order overload user unnecessary choices concerning local ambiguities parser request help immediately reaches parse action conflict 
parser pursues option limited breadth fashion requests help analysis paths remain active 
system type lookahead limited ahead 
practice checking cheap terms machine resources effective cutting number choice points user forced consider average number options 
table gives example reduction user interaction achieved increasing amount lookahead system 
computation backbone grammar generates extra rules described section expand values certain features reasons correspond directly single unification grammar rules 
choice points reductions involving rules user system applies reductions automatically proceeding shift action choice point reached including options point user 
final set measures taken reduce amount interaction required user ask string parsed contains gaps instances coordination presenting choices involving phenomena blocking consideration rules basis presence particular feature value pairs 
shows system parsing string choice lookahead 
resulting parse tree displayed category aliases substituted actual complex categories 
requests manual selection analysis path displayed analyst terse manner possible require knowledge grammar lexicon resolved effectively 
summarises amount interaction required experiment reported section set noun definitions longman dictionary contemporary english procter parsed version anlt grammar date largest number interactions observed single input string word definition youth usu young people walking country areas holiday pay small amounts money youth association international action conflict number mean number options lookahead choices choice choice choices choices choices table 
amount user interaction parsing act putting anlt grammar different amounts action conflict lookahead 
version third release anlt grammar minor modifications allow parse definitions nouns longman dictionary contemporary english parse act putting gaps phrase 
ambiguity state putting remaining buffer 
analysis far act 
shift word stack 
reduce analyses rule giving category 
choice abort finish 
msec cpu unifications failures parse act vp putting 
interactive parse user input bold 
number interactions number definitions 
frequencies particular numbers interactions 
phrase achieving correct analysis interactively took user minutes including addition lexical entries 
inputs length hundreds thousands parses computing parse forest takes order hours cpu time dec workstation 
general corpus written material average sentence length words input illustrates clearly problems approach post hoc line selection correct parse 
incremental approach semi automatic parsing correct analysis demonstrably forest training material means line computation 
deriving probabilities training data associating probabilities lr parse table sequences shift reduce accept actions lalr parse table performed interactive parsing system training phase automatically stored frequencies parse table transitions represent create probabilistic version parse table non deterministic probabilistic parser section 
straightforward technique associating probabilities parse table assign probability action action part table wright ng tomita 
approach probabilities taken pcfg distributed sets actions way ensure analysis licensed grammar product scores lr actions derivation identical probability assigned analysis pcfg 
constraint relaxed probabilities associated directly individual actions parse table derived pcfg resulting probabilistic model sensitive parse context 
example derivation sentence loves grammar chapter steps reducing pronoun second pronoun sentence np rule np cases distinguished different lookahead items paired reduce actions relating rule state parse table case lookahead item vi second 
sensitive parse context certain extent approach maximal context encoded parse table possible devise situations reduction pronoun subject position indistinguishable terms lookahead example framework appropriate rules adverbs added adv lookahead reductions pronouns subject object positions inputs probably loves 
slightly complex approach subdivide reduce actions state reached reduce action applied 
state resultant non terminal define state transition goto part parse table 
technique corresponds associating probabilities transitions automaton defined parse table actions action part table 
example reduction pronoun np subject position parse table results parser returning state zero goto table deterministically prescribes transition state nonterminal np 
reduction np pronoun object position results parser returning state 
training corpus subject non subject pronominal np result probabilistic preference reductions return pre subject states post subject lookaheads 
course mean impossible devise grammars reductions kept distinct principle different frequencies occurrence 
approach appears natural stochastic probabilistic model emerges lr table 
sensitivity context require sensitivity patterns larger sections parse derivation defined terms table 
deriving lr parse table transition probabilities stage process creating probabilistic version parse table identify action stored training history transition parse table taken 
task trivial due delaying techniques described previous section time interactive parser union states lookahead consisting set containing atomic terminal category 
action added parse history recorded occurring context set states set lookaheads 
uniquely identify transition corresponding action state lookahead possibilities 
system replays actions backwards reduce action pushing daughters rule involved stack shift action encountered action lookahead lookahead subsequent reduce actions shift terminal currently top item stack immediately popped 
lookahead action determined actions replayed forward parse table order state sets 
second stage process compute frequency transition utilised training phase normalise frequencies obtained transition state probabilities sum 
probabilities stored separately lr parse table ensure sharable transitions table section represented compactly probabilities differ 
probabilities held logarithms allow multiplied quickly parsing 
shows probabilistic lalr parse table derived simple partial artificial training phase 
probabilities associated transitions actions transition corresponding single reduce action separate probability depending state reached action example state lookahead probability reducing rule state reached state reached 
actions associated probabilities correspond transitions utilised training phase assigned smoothed probability reciprocal result adding total number observations transitions taken state 
reason explicit probabilities row table sum 
unseen events assigned differential probabilities manner analogous type smoothing performed turing technique 
goto part table shown deterministic probabilities associated entries 
lr transition probabilities difference approach described pcfg brought considering parse derivations probabilistic parse table 
assuming probabilities simply rank parses total probability analysis computed product probabilities transition taken derivation 
shows possible complete derivations sentence winter holiday camp closed consisting determiner nouns intransitive verb 
ambiguity concerns noun compound left right branching discussed section pcfg distinguish derivations 
probability step read action table shown lookahead item derivations 
step shift reduce conflict occurs stack splits left analyses noun compound constructed 
branch corresponds right branching derivation product probabilities whilst product left branching derivation table constructed parse histories preponderance left branching structures desired result 
practice technique able distinguish train accurately possible structures state det vi vt acc 
probabilistic version parse table 
det det det det det det det det det vi det det vi det det vi det vi det vi det vi det vi det vi det vi det vi det vi np vi np vi np vi np vp np vp 
parse derivations winter holiday camp closed 
word noun noun compound inaccurately prefers completely left branching analysis structures form moving noun noun compounds performance degrades 
level performance structural configurations adequate correct resolution ambiguity constructions dominated actual lexical items occur individual texts 
systematic structural tendencies evident corpora example frazier parsing strategies predict preference left branching analyses compounds probabilistic model sensitive discriminate 
probabilistic lr parsing probabilistic parser uses lr table transition probabilities derived training phase described previous section return set highest ranked analyses input 
parser consists processing stages takes input computes probabilistic packed parse forest second extracts highest ranked analyses forest 
computing probabilistic parse forest stage probabilistic lr parser non deterministic unification lr parser described chapter briefly generalisation unification grammar cf lr recogniser 
stage constructs packed parse forest representation set analyses licensed grammar input 
representation identical sub analyses shared differing superordinate analyses sub analyses covering portion input packed root categories related subsumption 
ng tomita describe lr parser pcfg associates probabilities nodes graph structured stack 
branches stack merged due shift state goto action existing vertex vertex probability updated sum products action parent vertex probabilities 
addition operation involved calculation inconvenient perform probabilities represented logarithms multiplication fast ng tomita propose approximate maximum likelihood approach addition replaced maximisation 
splitting stack reduction popping merged vertex probabilities parent vertices recovered requiring quite complicated arithmetical manipulation 
general splitting single reduce action arithmetic involved tricky ng tomita leading propose reverting simpler type tree structured stack 
probabilistic lr parser overcomes problems associating probabilities partial analyses input nodes graph structured stack 
node forest holds probability sub analysis rooted node distinct probability maintained packed sub analysis node 
shift action creates new parse forest node containing just transition probability node created reduce action contains product transition probability probabilities nodes reduced 
parser able merge split stack configurations cases maintain full record probabilities computed point 
ideally input computation probable analysis best analyses defined probabilistic lr parser involve construction complete parse forest exhaustive search space syntactically legitimate analyses defined grammar 
possible introduce viterbi style optimisation computation local maximal paths probabilistic nondeterministic fsm defined parse table point derivation maximal path may receive probability zero unification failure rendering hitherto non maximal local path maximal 
unfortunately effects feature propagation localised respect computation probable sub analyses whilst attempt incorporate featural information probabilistic component grammar result intractably large grammar model free parameters 
parser computes complete parse forest 
probabilistic unpacking normalisation wright sharman describe viterbi algorithm find best analyses probabilistic parse forest sub analysis probabilities product probabilities lexical items spanned pcfg rules involved sub analysis derivation 
algorithm involves evaluating competing analyses portion input pruning lowest scoring ones 
competing sub analyses stage contain differing numbers rule applications wright restrict grammar cnf notation guarantee analyses covering input contain number rules system develop bias favour analyses involving fewer rules equivalently smaller trees regardless training material magerman marcus observe problem experiments perform propose analysis probabilities normalised computing geometric mean rule probabilities compared 
geometric means opposed products achieves crude form normalisation respect number rules analysis 
form normalisation integrated wright unpacking algorithm compromising algorithm soundness sub analyses normalised pruning possible sub analysis lower scoring normalisation contains rules competing pruned position reversed sub analyses integrated higher level analysis 
hand sub analyses normalised analyses involving smaller numbers rules pruned ultimately form high scoring complete analyses final normalisation step 
addition wright approach applied stands unification systems unpacking forest remaining unifications involving different featural extensions packed nodes superordinate subordinate nodes linked lead failure derivation encoded parse forest case unpacking cfg parse forests 
straightforward way extracting best normalised analyses approach training version baum welch re estimation applied non cnf grammars trellis algorithm kupiec maximising likelihood corpus grammar incorrectly rank analyses individual sentences due bias smaller trees 
unification probabilistic parse forest exhaustively unpack forest retrieve analysis normalise probability return highest scoring analyses 
method impractical large forests anlt grammar longest string parse forest successfully fully unpacked words long 
heuristic correct technique best non exhaustive search parse forest developed practice recovery probable analyses efficient allowing analysis input strings containing words 
technique identify best analyses forest probabilistically guided search simultaneously normalising scores partial analyses identical portions input 
best complete analyses identified unpacked forest process involving small number unifications 
analyses unifications succeed returned 
number analyses returned wanted process repeated larger value practice approach leads considerable practical improvement time taken produce best analyses 
algorithm remains worst case exponential sentence length need search fraction packed parse forest recover best analyses case pathological grammars 
addition separating probabilistic computation creation parse forest problems induced non local nature feature propagation avoided 
identifying best partial analyses probabilistically guided search find best analyses probabilistic packed parse forest involves maximising normalised score nodes parse forest successive positions input similar manner viterbi algorithm 
method starts left edge forest string position zero just word successive step normalising described section probabilities assigned partial analyses spanning string positions zero node forest extending just highest scoring partial analyses node reach position 
process halts pruning lowest scoring analyses equal length input point analyses complete root node forest 
analyses returned best set 
partial analysis taken highest node dominates lexical node right edge analysis dominate lexical node right alternatively root node words input 
example partial analyses string position zero packed forest shown boxed nodes labelled comp shows analyses represented forest 
parser processes input left right uses shift reduce strategy constructs right derivations 
partial analysis consists subtrees heights decrease remain increase left right 
node forest contains number product lr parse table transitions taken point analysis subtree dominated node 
extending partial analysis new subtree transition count product figures new extended analysis depend relationship heights nodes roots subtrees currently making partial analysis height new extending subtree 
root node new subtree closer root forest current ones dominates figures extended analysis new node combined appropriate nodes partial analysis preceded dominated nodes 
disjoint subtree added right edge partial analysis figures new node combined current nodes 
packed nodes dealt specially figures node take account nodes packed 
fact suffices keep track differences figures node root subtree packed point subtree incorporated partial analysis factor differences figures node subsequently required 
implementation parse tree corresponding partial analysis represented comp comp comp ellipses enclose packed nodes 
boxes mark nodes partial analyses position 

packed parse forest 
comp comp comp comp 
analyses represented forest 
fact stored sum logarithms transitions 
implicitly set packed nodes contains probabilistic search parse forest finished actual tree unpacked forest efficient depth traversal 
nodes packing packed nodes set incorporated tree 
packed nodes members set incorporated performing unification required check consistent rest analysis built far traversal continues inside packed subtree 
despite fact current implementation probabilistic unpacking quite crude speeded significantly sample word input strings analyses experiment reported section time implementation takes return highest ranked analyses parse forests order factor exhaustive unpacking forest 
course searching best analyses average nodes forests visited 
longer inputs difference marked 
current implementation able return best analyses string parser manages create parse forest longest string words length 
due space time constraints parser unable compute full set analyses string calculations indicate analyses 
experiments carried far forest searched highest scoring analyses appears great majority unifications take place unpacking successful 
experiment reported section setting pruning partial analyses discard best stage number final analyses returned input required cases analyses total 
normalising partial analyses partial analyses spanning vertices may derived differing numbers lr state transitions scores competing analyses normalised respect derivation length compared best ones identified 
scores competing partial analyses node forest normalised length longest derivation analyses derivation shorter say transitions score multiplied geometric mean score raised power example stage longest derivation length derivations length transition scores multiplied factors geometric mean figures squared geometric mean figures give normalised scores 
computation performed quickly transition scores held logarithms 
need normalisation step reflects fact model sensitive context pcfg means perfect probabilistic model nl example stochastic nature model fact entire left context parse derivation encoded lr state information means probabilistic model take account say pattern resolution earlier conflicts current derivation 
respect model approximate probabilities associated contextfree backbone unification grammar 
successful unification features parse time affect probability partial analysis whilst unification failure effect sets probability analysis zero 
long probabilistic model rank successful analyses particularly problematic 
mentioned parser control regimes attempting form best search probabilistic information associated transitions return incorrect results property 
experiments parsing ldoce definitions experiments order test techniques ideas described sections experiment carried test corpus subset noun definitions taken longman dictionary contemporary english ldoce procter corpus chosen vocabulary employed restricted approximately morphemes average definition length words maximum definition independent allowing phenomena ellipsis ignored 
addition language definitions represents recognisable sublanguage allowing task tuning general purpose grammar investigated 
purposes experiment corpus approximately noun definitions created ldoce extracting definition fields normalising definitions remove punctuation font control information forth lexicon created corpus extracting appropriate lemmas matching entries anlt lexicon 
resultant entries loaded anlt marcus magerman argue reasonable geometric mean computing probability sub analyses independence assumptions motivate products hold approximate model 
machine readable version ldoce kind permission longman group corpus contains unique headwords distinct word forms definitions 
perplexity pp measures bigram trigram word models estimate infinite model pp pp pp inf sharman 
morphological system ritchie full anlt grammar formed starting point training process 
total definitions selected regard syntactic form parsed semiautomatically interactive lr parsing system described section process rules lexical entries created definitions failed parse 
successfully parsed lexical entries rules added 
rules required reflected general inadequacies anlt grammar example rules added deal new prepositional phrase verb complementation 
rules cover relatively idiosyncratic properties definition sublanguage example pronouns relative clause prepositional phrase definitions 
parenthetical phrases headed adverbs period esp period coordinations explicit conjunctions forth 
special rules required deal parentheses cover lexicographic conventions man monk woman lives ignored test 
number new rules required great need identified early training process 
lexical entries problematic little evidence number new entries required tail training material encountered 
entries required reflect systematic inadequacies anlt lexicon idiosyncrasies corpus 
took approximately person month produce training corpus 
rough guide single interaction parser takes average seconds 
time parse takes lengthened incorrect choices consequent need back manually process adding lexical entries occasional rules 
resultant parse histories construct probabilistic parser described previous section 
parser training corpus highly ranked analyses automatically compared original parse histories definitions parsed manually able breadth fashion 
words long 
definitions word length trivially receive correct analyses 
definitions words length inclusive mean length 
cases correct analysis defined training corpus highly ranked 
remaining cases correct analysis second third highly ranked analysis 
looking cases detail inappropriate structural preference low local attachment see kimball inappropriate preference compounds remaining ann copestake created corpus extracted relevant lexical entries full anlt lexicon 
antonio ted briscoe jointly performed training 
results reported latest versions anlt grammar lr parsing system 
briscoe carroll report earlier versions experiment different versions grammar parser results differed minor ways 
cases highest ranked result contains single constituent words length 
results interpreted terms goodness fit measure sampson haigh atwell measure better 
correct parse sentence measure result 
definitions longer words tails mainly due statistically induced structural attachment preferences 
correct analysis returned definition words length 
summarises results 
ldoce noun definitions drawn training corpus parsed containing words mean length 
cases correct parse highly ranked cases second third highly ranked remaining cases analyses 
yields correct parse sentence measure 
examination failures reveals preference local attachment postmodifiers accounts cases preference compounds single constituent 
caused lack lexical entries appropriate subcat features 
shows analysis unseen definition parses highly ranked correct 
shows highest ranked analysis assigned definition aid 
example false positive case caused lack lexical entry support intransitive verb 
consequently parser finds ranks highest analysis supports helps treated transitive verbs forming verb phrases object noun st ranked analysis correct nd ranked analysis correct rd ranked analysis correct correct analysis ranked st nd rd number definitions definition length 
correctness results definitions respect length 
feeling manner vp vp 
parse tree feeling manner phrase gaps supports helps zero relative clause analysed prenominal subject compare person thing supports helps 
difficult fault analysis true false positives observed date 
false positives biggest challenge type system 
hopeful sign analyses assigned examples appear low probabilities relative probable correct analyses examples 
considerably data required possible decide trend robust provide basis automatic identification false positives 
appendix contains definitions training corpus words long test corpus 
number parses definition indication correct analysis probable 
person thing vp vp supports vp helps 
parse tree person thing supports helps 
discussion experimental results fujisaki 
report success rate sentence average length words training corpus impressive difficult evaluate properly absence full details concerning nature corpus 
example corpus contains simple similar constructions unsupervised training perform converge quickly useful set probabilities 
fujisaki appear treat lexemes terminal categories grammar greibach normal form represents substantial amount lexical information 
example possible productions vp believe vp believe np associating differential probabilities rules allow probabilistic model represent relative probability believe sentential complement object noun phrase 
sharman jelinek mercer experiments yield success rate tree similarity metric sentences drawn training corpus 
pereira schabes experiments test corpus probable analyses consistent respect bracketing manually assigned analyses 
noticeable experiments results appear better fujisaki despite supervised training sophisticated grammatical models 
differences derive corpus material training testing lack detailed lexical information results reported fujisaki achieved corpora 
preliminary experiments anlt grammar ldoce definitions sublanguage reported results comparable systems achieved basis quite modest amount manual effort smaller training corpus 
manually disambiguated parse histories contain little noise usefully reflect semantically pragmatically appropriate analysis training corpus number failures coverage reduced extent ability add rules specifically motivated corpus supervised training 
fujisaki sharman system integrate information lexemes rule probabilities information concerning probability lexeme occurring specific lexical syntactic category 
results achieved solely basis statistics concerning conditional probability syntactic rules syntactically defined lr parse context significant number errors involve incorrect attachment prepositional phrases analyses compounds coordinations forth lexical semantic information plays major role 
cases correct analysis highest ranked analyses structural preference local attachment exhibited system overruled appropriate contexts lexeme better word sense information taken account 
slightly worse results relative mean definition length obtained unseen data appear caused non existence correct analysis number cases significant decline usefulness rule probabilities 

thesis practical parsing realistic nl texts wide coverage grammar 
thesis proposes novel solutions problems ensuring parser throughput face ambiguity long input strings selecting correct analysis particular input set licensed grammar tuning grammar particular corpus sublanguage 
techniques described tested implemented computer system experiments carried assess effectiveness practice 
thesis tackle related problem providing reliable analyses input outside coverage grammar possible approaches build framework outlined section 
chapter summarises novel techniques described thesis comments results experiments reported presents general suggests directions 
maximising parser throughput parsing techniques algorithms parsing systems described thesis designed framework alvey nl tools anlt grammar associated grammatical formalism 
thesis presents novel unification algorithm argued suitable practical nl parsing formalism related ones existing alternatives 
algorithm employed bottom active chart parser 
optimisations include statically indexing strategic parts grammar dynamically indexing certain run time data structures methods minimising dynamic storage techniques straightforwardly implementable fairly generally applicable parsers 
parser result speed gain factor 
experiments corpus parser anlt grammar shown significantly better practical performance clare system alshawi alshawi comparable state art unification analysis system 
surprising outcome experiments anlt grammar clare system parser throughput poor 
explicit formal process tuning parsers grammars perform carried systems parallel development software grammars occurred appears caused happen automatically 
plausible marked difference occur systems formalisms merely context free unification formally powerful expressive type formalism types difference occur 
instance context ale carpenter research integrate constraint grammar chart parsing produce parser control strategy specific hpsg penn personal communication grammars written formalism diverging particular theory perform 
experiments chart parser integration top prediction means left corner reachability table results improvement practical performance 
somewhat unexpected runs counter limited number results reported literature systems 
parsing systems described thesis produce parse forests exhaustively enumerated sets parse trees portions sub analyses required extend shared possible systems unable process inputs words long reasonable time space bounds 
realistic nl texts contain sentences significantly longer 
text expected ready lexical access punctuation removed 
aspects punctuation reflect syntactic distinctions nunberg appropriate general 
text preprocessor required package smaller units sentences parsing individually encounters parentheticals sub sentential constituents example related discourse relations elaboration syntactic relations 
practical restriction length input string impact 
thesis presents novel methodology constructing lr lr parsers unification grammars automatic construction cf backbone grammar appropriate table constructed drive parser 
unifications performed reduce action parsing 
suitability various types lr parse table compared realistically sized ambiguous nl grammars tractable approach computing lalr tables grammars outlined scheme representing tables compactly 
backbone grammar computation automatic constraining power improved manual intervention 
investigate issues systematically software tools need built backbone grammar reliably tuned respect particular phenomena occur unification grammar 
process analogous ingria personal communication efficiency modifications delphi system involving manual compilation combinations categories features new categories able efficiently processed 
maxwell kaplan press describe manual process type driven statistics collected automatically functional constraints lfg grammar converted equivalent phrasal constraints splitting rules specialised versions information constraints frequently caused constituents locally unsatisfiable parsing 
novel efficient non deterministic lr parsing algorithm cf grammar better worst case time complexity algorithm previously reported literature shift reduce parsing graph structured stack 
space complexity better grammar dependencies ignored 
unification implementation version parser described practical throughput empirically compared chart parser implementation efficient lr algorithm proposed literature 
results show lr parser approximately faster chart parser twice fast lr parser 
difference due smaller overheads deterministic parse table 
adaption cf algorithm unification grammar algorithm augmented cache results unifications performance significantly degraded solution pleasing respect algorithm specifically designed unification grammar satisfactory 
parsing complexity thesis presents worst case time complexity results parsing algorithms described 
cf version unification chart parser case grammar contain rules daughters iterate complexity length input string number categories grammar number rules maximum number daughters rule 
grammars rules factor dependent length input worse cky algorithm chart parser accepts arbitrary cf grammar restricted grammars expressed chomsky normal form cnf case cky 
chart parser complexity cf version rule daughter iterate input length factor worsens exponential 
anlt grammar contains rules type analysis ordination constructions exponential theoretical complexity problem practice sentences containing ordination 
potential problem suggested complexity result related square number categories grammar number large realistic unification grammar 
practical problem 
similar type grammar dependency evident time complexity non deterministic lr parsing algorithm complexity exponential size grammar total number daughters rules number lr states exponentially related grammar size johnson 
empirical results show parse table anlt grammar large requires special techniques represent reasonable amount space parser throughput 
schabes presents lr parse table cf grammar predictive parsing algorithm complexity linearly dependent grammar size 
algorithm intended solve problem non deterministic lr parser theoretically behaving worst case exponential time respect grammar size ambiguous grammars inputs 
schabes claims problem particularly acute natural language processing context input length typically small words grammar size large hundreds thousands rules symbols 
experiments reported thesis indicate wide coverage nl grammar inputs length parsed quite quickly especially lr parser longer inputs words length occur relatively frequently written text problem 
grammar size takes proportionately significance longer inputs appears fact major problems lie area grammar size input length 
analysis complexity may useful identifying potential inefficiencies nl formalisms algorithms proposals improvement informed empirical data derived realistic implementations 
parse selection tuning grammars corpora wide coverage nl grammar license hundreds thousands analyses single sentence 
thesis describes probabilistic system parsing text taken specific corpus sentence returning set highest scoring syntactic analyses 
system lr parsing technique incorporates novel resource efficient incremental approach semi supervised training grammar tuned corpus 
new techniques include method probabilistically scoring sub analyses sensitive context accurate manipulation probabilities course lr parse identification highest ranked analyses unification parse forest full exploration search space 
preliminary experiment carried corpus definitions longman dictionary contemporary english procter evaluate system accuracy selecting correct analysis 
system identified correct analysis definitions training data words length inclusive definitions correct analysis highest ranked 
results unseen definitions similar 
probabilistic framework adopted system constitutes decision procedure language model see section discussion distinction respect parse selection 
system currently contains syntactic knowledge framework allow sources knowledge lexical semantic integrated relatively straightforwardly see sections 
factoring different kinds knowledge language model difficult 
type reestimation training language models benefit system parsing unseen input paths parsing takes place re estimation process generates data points corpus tends smooth probabilities 
area warrants study experimentation 
acquisition lexical entries word sense frequencies probabilistic system described thesis take account differing frequencies occurrence lexical entries example lob corpus verb believe occurs finite sentential complement citations grammatical patterns complementation briscoe personal communication 
type lexical information vary sublanguages integrated practical system 
straightforward system probabilities associated distinct lexical entry lexeme carried forward computation likelihood parse 
acquiring statistical information probabilities may derived difficult 
existing lexical taggers unable assign tags reliably encode subcategorisation information 
automatic acquisition information await successful techniques robust parsing phrases corpora experiment reported syntactic peculiarities corpus surfaced quite rapidly manual addition rules grammar training phase practical forming part tuning process 
lexical idiosyncrasies far exhausted training suggesting necessary develop automatic method dealing 
promising approach problem apply probabilistic techniques brent claims able recognise subcategorisation patterns large quantities untagged text 
described thesis grammar sequences lexical tags word strings form robust phrasal parser 
lexical entries needed resulting analyses necessarily detailed full anlt grammar support subsequent semantic interpretation 
analyses help construct reliable exhaustive lexicon full grammar 
describes system type consisting relatively simple unification grammar designed parse tag sequences drawn spoken english corpus taylor knowles produce analyses reasonably accurate phrasal level attachment ambiguity reduced single canonical binary branching possibility 
system achieves success rate respect correctness rule application approximately unseen data 
example tag sequence returns correct phrasal analysis personal communication government nn vbz comprised io mc io multitude nn io ethnic jj cross ethnic jj cc political jj parties nn 
system anlt lexicon analyse sentence successfully occurred unseen data probably lexical entry cross ethnic type phrasal analysis corpus allow adequate corpus specific lexicon bootstrapped 
making collocational information system described thesis provides partial solution parse selection task 
results preliminary experiment show system able rank highly semantically pragmatically correct analysis just exploiting frequency occurrence syntactic rules training data syntactic contexts appear 
approach succeed cases example experiment system appears develop preference local attachment prepositional phrases pps inappropriate significant number cases 
surprising probabilities solely syntax capable resolving type ambiguity input john saw man monday temporal interpretation monday favours adverbial interpretation non local attachment 
inputs syntactically identical ones john saw man bus mild preference local attachment 
selecting correct analysis cases involve integrating information concerning word sense collocations probabilistic analysis 
case applicable collocations head pp complement preposition head phrase 
words general adjacent approaches church hanks 
hindle rooth report results mutual information measure collocation applied structurally defined context approach system described 
way integrating structural collocational information system semantic component anlt grammar 
component pairs distinct syntactic analysis set logical forms represent things predicate argument structure input 
resolution pp attachment similar ambiguities collocation level representation appears relevant 
principle integrating probabilistic ranking resultant logical forms probabilistic ranking distinct syntactic analyses presents problems 
acquisition relevant statistical information difficult requiring considerable quantities analysed text training material 
way ameliorate problem reduce size vocabulary statistics need gathered replacing lexical items superordinate terms disjunction terms case ambiguity 
copestake describes program capable deriving hierarchical taxonomies word senses machine readable dictionary 
taxonomies form replace pp complement heads heads corpus data smaller number superordinate concepts 
statistical data concerning trigrams head preposition head sparse gale church easier gather corpus 
possible gather data syntactically analysed material 
dealing missing rules identified interactive training phase probabilistic framework set thesis completely solve problem gaps coverage remaining unseen corpus material analysed 
large part problem detecting automatically input covered grammar 
inputs receive analysis easy spot 
receive incorrect analyses automatically ranked probable identified manually basis relative 
jensen 
describe approach parsing inputs parse fitting rule relaxation deal ill formed input 
approach type inputs receive parse help identification receive incorrect 
addition involves annotating grammar rule relaxed requires semantic interpretation able extended fitted partial parses 
technique similar potential robustness described section infer pcfg baum welch re estimation training corpus predefined category set lari young pereira schabes 
approach advantage resulting grammar defines defined set analyses rules compositional interpretation developed 
technique limited main ways firstly grammars restricted small maximum non terminal cnf pcfgs computational cost iterative re estimation algorithm polynomial sentence length non terminal category size secondly form supervised training essential analyses assigned grammar linguistically motivated 
immediate prospects applying techniques realistic nl grammars promising anlt backbone grammar discussed chapter contains categories 
briscoe describe experiment firstly baum welch re estimation conjunction linguistically motivated constraints class grammars inferred secondly initial probabilities heavily biased favour manually coded linguistically highly plausible rules 
approach resulted simple tag sequence grammar able assign coherent semantically pragmatically plausible analyses tag sequences drawn spoken english corpus 
alternative approach framework described thesis considered converse briscoe start entirely hand crafted core grammar anlt cases parse fails comparatively rare comprehensive lexicon automatically construct add grammar new rules consistent extant allow analysis built lr technique course parse inability form complete analysis input string detected soon possibly non deterministic lr parser type described chapter states top graph structured stack conjunction lookahead symbol provide constraining environment conjecture new rule 
addition probabilities attached lr transitions give information relative probabilities valid transitions 
example grammar contain rule analyse heavy np movement english anlt framework phrase structure rule heavy np shift vp subcat np pp pp np 
instance construction encountered corpus parser finding approach related stochastic error correcting parsing techniques described tanaka fu fu 
head verb verb phrase np followed pp unexpectedly encounter preposition lookahead 
point transitions table lookahead taken marker having placed stack indicate new rule cover discontinuity required 
parse continue reduction attempted pop marker stack new rule conjectured analyse constituents 
additional source constraint form new rule provided grammatical principles example shape propagation default rules metagrammar section case feature percolation consistent rest grammar 
new rules posited single failure ranked respect probabilities assigned complete analyses appeared 
false positives dealt similar way new rule transition taken unusually low probability 
new rules added system fly incrementally updating parse table heering klint rekers making available immediately analysis subsequent sentences 
form grammar learning incremental operates exactly point parse gone wrong repair limited particular context possibilities lie similarly constrained space berwick approach 
alternative post hoc approach operating parse forest chart mellish technique possible complete parses fragments chart built bottom constrained 
probabilities continue updated dynamically training probabilistic framework provides natural mechanism determining new rule kept eventually discarded systematic extension acquire higher probability retain low initial probability 
summary section reports general arising research described thesis 
research concentrates important issues practical parsing nl wide coverage unification grammars parser throughput disambiguation 
trying maximise parser throughput purely bottom parser appropriate unification algorithm techniques minimising processing overheads perform significantly better practice comparable parsers employing simple types top information 
standard lr technique applied area provide incremental parse table updating grammars size consideration prove intractable 
improved performance precomputed earley parser returns worse performance 
exponential worst case complexity length input string prevent sentences realistic text words length parsed reasonable time conventional computer hardware 
exponential complexity grammar size lr case appear important factor 
statistical methods successfully applied task syntactic disambiguation select analyses semantic pragmatically plausible interpretations straightforwardly derived 
approach associating probabilities transitions lr parse table encode information syntactic context rules applied efficiently implementable 
limited scale experiment involving supervised training system approach achieves accuracy comparable results reported probabilistic cf grammar basis smaller training corpus returning analyses suitable subsequent semantic interpretation 
bibliography aho 
indexed grammars extension context free grammars 
journal acm 
aho sethi ullman compilers principles techniques tools reading ma addison wesley 
kaci 
lattice theoretic approach computation calculus partially ordered types 
ph thesis university pennsylvania pa alshawi 
analysing dictionary definitions 
boguraev briscoe eds computational lexicography natural language processing harlow uk longman 
alshawi 
ed 
core language engine cambridge ma mit press 
alshawi carter crouch pulman rayner smith clare contextual reasoning cooperative response framework core language engine 
sri international cambridge uk 

taxonomy english nouns verbs 
proceedings th meeting association computational linguistics stanford ca 
ancona efficient construction lr states tables 
acm transactions programming languages systems 
anderson eve horning efficient lr parsers 
acta informatica 
baker 
trainable grammars speech recognition 
klatt wolf eds speech communication papers th meeting acoustical society america asa 
shrobe sandewall interactive programming environments 
new york ny mcgraw hill 
barton berwick computational complexity natural language 
cambridge ma mit press 
baum 
inequality associated maximization technique statistical estimation probabilistic functions markov processes 
inequalities iii 

unifying model lookahead lr parsing 
computer languages 
berwick 
acquisition syntactic knowledge 
cambridge ma mit press 
lang structure shared forests ambiguous parsing 
proceedings th meeting association computational linguistics vancouver canada 
boguraev carroll briscoe grover software support practical grammar development 
proceedings th conference computational linguistics coling budapest hungary 
chow haas ingria scha stallard vilain integration speech natural language final report 
bbn systems technologies cambridge ma report 
boyer moore sharing structure theorem proving programs 
eds machine intelligence new york ny wiley 
brent 
automatic acquisition subcategorization frames untagged text 
proceedings th annual meeting association computational linguistics berkeley ca 
briscoe 
modelling human speech comprehension computational approach 
chichester uk ellis horwood new york ny wiley 
briscoe 
review 
computational linguistics 
briscoe grover boguraev carroll formalism environment development large grammar english 
proceedings th international joint conference artificial intelligence milan italy 
briscoe grover boguraev carroll feature defaults propagation 
klein van benthem eds categories polymorphism unification centre cognitive science edinburgh university uk 
briscoe carroll generalised probabilistic lr parsing natural language corpora unification grammars computer laboratory cambridge university uk technical report 
briscoe carroll generalised probabilistic lr parsing natural language corpora unification grammars 
computational linguistics 
briscoe robust stochastic parsing inside outside algorithm 
proceedings aaai workshop statistically nlp techniques san jose ca 
constructive view gpsg 
proceedings th conference computational linguistics coling budapest hungary 
carpenter 
logic typed feature structures applications unification grammars logic programs constraint resolution 
cambridge tracts theoretical computer science cambridge uk cambridge university press 
carpenter pollard franz specification implementation constraint unification grammars 
proceedings nd international workshop parsing technologies cancun mexico 
carroll 
island parsing interpreter full augmented transition network formalism 
proceedings st conference european chapter association computational linguistics pisa italy 
carroll briscoe probabilistic normalisation unpacking packed parse forests unification grammars 
proceedings aaai fall symposium probabilistic approaches natural language cambridge ma 
carroll briscoe grover development environment large natural language grammars 
computer laboratory cambridge university uk technical report 
carroll grover derivation large computational lexicon english ldoce 
boguraev briscoe eds computational lexicography natural language processing harlow uk longman 
chapman 
lr parsing theory practice 
cambridge uk cambridge university press 
charniak riesbeck mcdermott artificial intelligence programming 
hillsdale nj lawrence erlbaum associates 
grishman statistical parsing messages 
proceedings darpa speech natural language workshop hidden valley pa 
chomsky 
certain formal properties grammars 
information control 
church hanks word association norms mutual information lexicography 
proceedings th meeting association computational linguistics vancouver canada 
church patil coping syntactic ambiguity put block box table 
computational linguistics 
clocksin mellish programming prolog 
berlin germany springer verlag 
copestake 
approach building hierarchical element lexical knowledge base machine readable dictionary 
proceedings international workshop inheritance natural language processing tilburg netherlands 
copestake 
lkb representation issues semi automatic acquisition large lexicons 
proceedings rd acl conference applied natural language processing trento italy 
ii cohen lr regular grammars extension lr grammars 
journal computer system sciences 
cutting kupiec pedersen sibun practical part speech tagger 
proceedings rd acl conference applied natural language processing trento italy 
de marcken 
parsing lob corpus 
proceedings th annual meeting association computational linguistics pittsburgh pa 
efficient computation lalr look ahead sets 
acm transactions programming languages systems 
de rose 
grammatical category disambiguation statistical optimization 
computational linguistics 
earley 
efficient context free parsing algorithm 
communications acm 

unification lazy non redundant copying 
proceedings th annual meeting association computational linguistics berkeley ca 

user manual issco geneva switzerland technical report 
evans 
program development tool gpsg grammars 
linguistics 

probabilistic phrasal parsing natural language corpora 
unpublished phil 
dissertation computer laboratory cambridge university uk 
frazier 
grammar language processing 
ed linguistics cambridge survey cambridge uk cambridge university press 
fu 
error correcting parsing string languages 
syntactic pattern recognition applications london uk prentice hall 
fujisaki jelinek cocke black probabilistic method sentence disambiguation 
proceedings st international workshop parsing technologies pittsburgh pa 
gale church poor estimates context worse 
proceedings darpa speech natural language workshop hidden valley pa 
garside leech sampson eds 
computational analysis english corpus approach 
harlow uk longman 
gazdar klein sag generalized phrase structure grammar 
oxford uk blackwell 
gazdar mellish natural language processing lisp 
wokingham uk addison wesley 

lazy unification 
proceedings th annual meeting association computational linguistics pittsburgh pa 

population frequencies species estimation population parameters 

graham harrison ruzzo improved context free recognizer 
acm transactions programming languages systems 

lalr generator efficient parsers 
software practice experience 
grosz appelt douglas pereira team experiment design transportable natural language interfaces 
artificial intelligence 
grover briscoe carroll boguraev alvey natural language tools grammar second release computer laboratory cambridge university uk technical report 
grover carroll briscoe alvey natural language tools grammar th release 
computer laboratory cambridge university uk technical report 
heering klint rekers incremental generation parsers 
proceedings acm sigplan conference programming language design implementation portland 

lar processing natural language grammars 
unpublished phil 
dissertation computer laboratory cambridge university uk 
hindle 
acquiring disambiguation rules text 
proceedings th meeting association computational linguistics vancouver canada 
hindle rooth structural ambiguity lexical relations 
proceedings th annual meeting association computational linguistics berkeley ca 
hirst 
semantic interpretation resolution ambiguity 
cambridge uk cambridge university press 
holmes 
speech synthesis recognition wokingham uk van nostrand reinhold 
jaffar 
efficient unification infinite terms 
new generation computing 
jensen heidorn miller ravin parse fitting prose fixing getting hold ill formedness 
computational linguistics 
jensen heidorn richardson haas peg critique contributions computing humanities 
ibm yorktown heights ny research report rc 
johnson 
computational complexity tomita algorithm 
proceedings st international workshop parsing technologies pittsburgh pa 
johnson evaluating complex constraints linguistic formalisms 
proceedings workshop th european conference artificial intelligence coping linguistic ambiguity typed feature formalisms vienna austria 
johnson 
yacc compiler compiler bell telephone laboratories murray hill nj computer science technical report 
kaplan bresnan lexical functional grammar formal system grammatical representation 
bresnan ed mental representation grammatical relations cambridge ma mit press 
karttunen 
patr development environment unification grammars 
proceedings th international congress computational linguistics coling bonn germany 
kasami 
efficient recognition syntax analysis algorithm context free languages 
air force cambridge research laboratory bedford ma report 
kay 
parsing functional unification grammar 
dowty karttunen eds natural language parsing cambridge uk cambridge university press 
kay 
algorithm schemata data structures syntactic parsing 
grosz sparck jones webber eds readings natural language processing los altos ca morgan kaufmann 
kay 
head driven parsing 
proceedings st international workshop parsing technologies pittsburgh pa 

category restrictions elimination metarules 
proceedings th conference computational linguistics coling bonn germany 
kimball 
principles surface structure parsing natural language 
cognition 

lfg manual 
xerox palo alto research center palo alto ca ms 
analysis tomita algorithm general context free parsing 
proceedings st international workshop parsing technologies pittsburgh pa 
klein martin parser generating system pgs 
software practice experience 
knuth 
translation languages left right 
information control 

strategic lazy incremental copy graph unification 
proceedings th conference computational linguistics coling helsinki finland 
koskenniemi 
level model morphological analysis 
proceedings th international joint conference artificial intelligence karlsruhe germany 
koster 
affix grammars natural languages 
attribute grammars applications systems lecture notes computer science berlin germany springer verlag 
kristensen madsen methods computing lalr lookahead 
acm transactions programming languages systems 
kuno 
predictive analyzer path elimination technique 
communications acm 
kupiec 
trellis algorithm estimating parameters hidden stochastic context free grammar 
proceedings darpa speech natural language workshop asilomar ca 
lalonde lee horning lalr parser generator 
proceedings ifip congress new york ny elsevier 
lang 
deterministic techniques efficient non deterministic parsers 
ed automata languages programming lecture notes computer science berlin germany springer verlag 
lang 
recognition harder parsing 
proceedings nd international workshop tree adjoining grammars philadelphia pa appear computational intelligence 

empirical comparison generalized lr tables 
nijholt sikkel eds proceedings st twente workshop language technology 
lari young estimation stochastic context free grammars inside outside algorithm 
computer speech language processing 
leech garside running grammar factory production syntactically analysed corpora treebanks johansson eds english computer corpora selected papers research guide berlin germany mouton de gruyter 
leermakers 
cover grammar 
proceedings th meeting association computational linguistics vancouver canada 
leermakers 
recursive ascent parsing 
nijholt sikkel eds proceedings st twente workshop language technology 
magerman marcus pearl probabilistic chart parser 
proceedings nd international workshop parsing technologies cancun mexico 
magerman weir efficiency robustness accuracy chart parsing 
proceedings th annual meeting association computational linguistics newark delaware 
marcus 
theory syntactic recognition natural language 
cambridge ma mit press 
martelli montanari 
efficient unification algorithm 
acm transactions programming languages systems 
maxwell iii kaplan press interface phrasal functional constraints 
appear computational linguistics 
mellish 
chart techniques parsing ill formed input 
proceedings th meeting association computational linguistics vancouver canada 
meteer schwartz weischedel post probabilities language processing 
proceedings th international joint conference artificial intelligence sydney australia 
moore dowding efficient bottom parsing 
proceedings darpa speech natural language workshop asilomar ca 

extended lr parsing algorithm grammars feature syntactic categories 
proceedings th european conference association computational linguistics berlin germany 
nederhof 
generalized left corner parsing 
katholieke universiteit nijmegen department informatics technical report 
nederhof koster dekkers van grammar workbench step engineering 
ter stal nijholt op den eds proceedings nd twente workshop language technology 
newman 
combinatorial disambiguation 
proceedings nd acl conference applied natural language processing austin tx 
ng 
tomita probabilistic parsing general context free grammars 
proceedings nd international workshop parsing technologies cancun mexico 
nunberg 
linguistics punctuation 
chicago il university chicago press 

corpus linguistics automatic analysis english amsterdam netherlands rodopi 
osborne 
corpus parsing unpublished phil 
dissertation computer laboratory cambridge university uk 
paterson wegman linear unification 
journal computer system sciences 
pereira 
structure sharing representation unification grammar formalisms 
proceedings rd meeting association computational linguistics chicago il 
pereira schabes inside outside re estimation partially bracketed corpora 
proceedings th annual meeting association computational linguistics newark delaware 
pereira shieber prolog natural language analysis 
chicago il university chicago press 
pereira warren definite clause grammars language analysis survey formalism comparison augmented transition networks 
artificial intelligence 
pereira warren parsing deduction 
proceedings st meeting association computational linguistics cambridge ma 

shift reduce conflicts lr parsers 
acm sigplan notices 
phillips 
simple efficient parser phrase structure grammars 
aisb quarterly 
phillips thompson parser generalized phrase structure grammars 
linguistics 
phillips thompson parser appropriate computational representation gpsg 
klein eds edinburgh working papers cognitive science categorial grammar unification grammar parsing centre cognitive science edinburgh university uk 
pollard sag information syntax semantics volume fundamentals 
chicago il university chicago press 
pratt 
progress report 
proceedings th international joint conference artificial intelligence ussr 
procter 
ed 
longman dictionary contemporary english 
harlow uk longman 
purdom 
size lalr parsers 
bit 
ritchie pulman russell black computational framework lexical description 
computational linguistics 
ritchie russell black pulman computational morphology cambridge ma mit press 
robinson 
diagram grammar dialogues 
communications acm 
sampson 
grammatical database parsing scheme 
garside leech sampson eds computational analysis english corpus approach harlow uk longman 
sampson haigh atwell natural language analysis stochastic optimization progress report project april 
journal experimental theoretical artificial intelligence 
santorini 
penn treebank tagging parsing manual cis department university pennsylvania ms schabes 
polynomial time space shift reduce parsing arbitrary context free grammars 
proceedings th annual meeting association computational linguistics berkeley ca 
schubert 
preference trade offs attachment decisions 
proceedings th national conference artificial intelligence aiai philadelphia pa 
sedgewick 
algorithms 
wokingham uk addison wesley 
sharman 
probabilistic id lp grammars english 
ibm uk scientific centre uk report 
sharman 
language modelling 
ibm uk scientific centre uk ms sharman jelinek mercer generating grammar statistical training 
proceedings darpa speech natural language workshop hidden valley pa 
shieber 
disambiguation shift reduce parsing technique 
proceedings st annual meeting association computational linguistics cambridge ma 
shieber 
design computer language linguistic information 
proceedings th international conference computational linguistics coling stanford ca 
shieber 
restriction extend parsing algorithms complex feature formalisms 
proceedings rd annual meeting association computational linguistics chicago il 
shieber 
unification approaches grammar 
csli stanford ca lecture notes number chicago il university chicago press 
shieber 
simple reconstruction gpsg 
proceedings th international conference computational linguistics coling bonn germany 
shieber 
separating linguistic analyses linguistic theories 
wood somers johnson bennet eds linguistic theory computer applications london uk academic press 
shieber 
cl patr user manual 
sri menlo park ca ms spector 
lexing parsing modula 
acm sigplan notices 
spector 
efficient full lr parser generation 
acm sigplan notices 
steel de bi directional chart parsing 
mellish hallam eds advances artificial intelligence proceedings aisb chichester uk wiley 
steele 
common lisp language bedford ma digital press 
stock island parsing bidirectional charts 
proceedings th conference computational linguistics coling budapest hungary 
tanaka 
fu error correcting parsers formal languages 
ieee transactions computers 
taylor grover briscoe syntactic regularity english noun phrases 
proceedings th european meeting association computational linguistics manchester uk 
taylor knowles manual information accompany sec corpus machine readable corpus spoken english university lancaster uk ms thompson 
flexible modular chart parsing framework 
proceedings national conference artificial intelligence aiai washington dc 

quasi destructive graph unification 
proceedings th annual meeting association computational linguistics berkeley ca 
tomita 
parsers natural languages 
proceedings th international conference computational linguistics coling stanford ca 
tomita 
efficient context free parsing algorithm natural languages 
proceedings th international joint conference artificial intelligence los angeles ca 
tomita 
efficient parsing natural language 
boston ma kluwer 
tomita 
efficient augmented context free parsing algorithm 
computational linguistics 
valiant 
general context free recognition cubic time 
journal computing systems science 
vijay shanker joshi computational properties tree adjoining grammars 
proceedings rd meeting association computational linguistics chicago il 
vijay shanker weir polynomial time parsing combinatory categorial grammars 
proceedings th annual meeting association computational linguistics pittsburgh pa 
viterbi 
error bounds convolutional codes asymptotically optimum decoding algorithm 
ieee transactions information theory 
white 
research environment metal project 
nirenburg ed machine translation theoretical methodological issues cambridge uk cambridge university press 
ferrara empirical study predictive powers simple attachment schemes post modifier prepositional phrases 
proceedings th annual meeting association computational linguistics pittsburgh pa 
wilks huang fass syntax preference right attachment 
proceedings th international joint conference artificial intelligence los angeles ca 
woods 
transition network grammars natural language analysis 
communications acm 
wright 
lr parsing probabilistic grammars input uncertainty speech recognition 
computer speech language 
wright 
probabilistic grammars 
proceedings workshop sublanguage grammar lexicon acquisition speech language processing hcrc university edinburgh uk 
wright probabilistic lr parsing speech recognition 
proceedings st international workshop parsing technologies pittsburgh pa 
wright sharman adaptive probabilistic generalized lr parsing 
proceedings nd international workshop parsing technologies cancun mexico 

graph unification 
proceedings th national conference artificial intelligence aaai seattle wa 
younger 
recognition parsing context free languages time information control 
zajac 
inheritance constraint grammar formalisms 
computational linguistics 
klein calder unification categorial grammar 
klein eds edinburgh working papers cognitive science categorial grammar unification grammar parsing centre cognitive science edinburgh university uk 
appendix sets sentences experiments reported chapters 
decl doesn help 
confidently accepted conditions 
don help 

help accepted conditions confidently 
helped abbot 
helped abbot 
anxious mood helped abbot 
helped abbot anxious mood 
anxiety helped abbot 
helped abbot anxiety 
doubt helped abbot 
helped abbot doubt 
helped abbot doubt anxiety 
helped 
mood lee characteristic 
couldn help hearing admission abbot 
anticipates help 
anticipates help 
appears knows 
appears knows 
didn help mattered 
mattered didn help 
mattered didn help 
promised help 
promised help 

agrees help 
lee helps matters 
busy mood 
busy mood 
abbot 
abbot gives message 
agreed 
helps 
helps 
helps 
helping 
helps abandon 
help 
abacus 

abbot see 
abbot doubts aware 
wh slash abbot doubts 
abbot agree lee doubts 
abbot doubts 
doubts crazy don help desire help 
characteristic desire help 
confident 
eager help 
eager help 
clear wouldn apologize 
certain help 
busy helping 
abandoned 
know crazy 
anticipate doing 
anticipate helping 
hear 
see help abbot 
see accepted 


crazy 

helped 
helped 
agrees 
appearing 
appearing 
help 
easily 
see 
easily abandoned 
help won help 
abbot lee knows kim doesn know 
abbot lee know kim doesn know 
abbot see 
desire 
scared 
abbot see 
lee see hear 
passive abandoned 
abandoned 
back abacus 
back abacus kim 
allowed 
allowed 
allowed 
promised help 
promised help 
promised help 
bet abacus 
bet abacus 
asked 
asked 
asked help 
asked help 
asked 
asked 
asked help 
asked help 
conj lee won help allow kim help 
lee won help kim won apologize 
kim helps lee helps 
crazy anxious 
crazy anxious 
crazy 
kim lee 
kim lee sandy 
kim lee sandy 
kim sandy 
kim lee 
abbot host 
abbot host 
lee 
lee 
hosts 
hosts 
abbot host 
host 
host 
hosts 
abbot host 
crazy doubt anxiety helping 
crazy doubts helping 
appendix full results experiment reported chapter ldoce noun definition corpus 
column ranking correct parse correct parse ranked top column total number analyses 
definitions length words training corpus freedom control group people living building alphabet taught children sudden example act washing oneself australian place lives act putting great nasty thing act example accident intention person esp doctor intentionally causes abortion complete change opposite position direction opinion loss surface act making shorter state away loss attention doing person stays away regular absence cause esp duty bitter green strong alcoholic drink glass shortened form statement speech idea quality separate object great quantity wrong great hole appears bottom member academy school training special art skill act increasing speed act accepting accepted business agreement pay means entering way act coming position office state added addition agreement demand strong expressions approval praise loud shouts welcome honour upward slope strong praise approval room flat house hotel room helps action easier usually person plays musical accompaniment person helps wrong act finishing completely successfully completely successfully done lady art agreement countries businesses matter material come grown box apparatus electrical power stored quality accurate person highest class skill speech temper manner example chemical acid continuous pain quality acid esp liquid acid taste gun fire gun statement letter saying received highest greatest point development ability success person helps priest perform religious attendant medicine plants state feelings actions uncontrolled group people living building act making shorter powers skills esp mind lowest temperature thought possible wood tree animals joined bar power control simple foolish country man yellow central part egg long time type short dog fairly long hair young people considered group young animals young person esp boy early life young men women considered group long loud cry binds people things parses unseen definitions needing action happening behaviour natural manner feeling manner causes suffering person africa power force causes result periods life long time thinking way person thing supports helps act directing weapon dog rough coat type large act allowing fresh air room letter sent air large passenger aircraft letters parcels sent air system sending things air speed aircraft travels air sky space ground gentle wind attack military aircraft case example female animal plant lacks typical colouring white part egg person studied practised drinks containing false name name god style story poem union families marriage share money space money provided special purpose person helps supports attracts quantity sum total quantity sum sexual relationship esp secret large amount state act action producing state person believes absence government control absence order person skilled anatomy place ships may anchor money charged anchor harbour means making firm old man person helps machine measuring strength wind 
