xduce statically typed xml processing language haruo hosoya kyoto university kyoto ac jp benjamin pierce university pennsylvania cis upenn edu xduce statically typed programming language xml processing 
basic data values xml documents types called regular expression types directly correspond document schemas 
xduce provides flexible form regular expression pattern matching integrating conditional branching tag checking subtree extraction dynamic typechecking 
survey principles xduce design develop examples illustrating key features describe foundations theory regular tree automata complete formal definition core proof type safety 
categories subject descriptors programming languages language constructs features data types structures general terms languages theory additional key words phrases type systems xml tree automata 
xml simple generic format structured data standardized world wide web consortium bray 
data documents xml ordered labeled tree structures 
core xml standard imposes restrictions labels appear context document may accompanied document type schema describing structure 
schema languages proposed 
original specification xml defines schema language called dtd document type definition bray 
schema languages include xml schema fallside relax ng clark murata dsd klarlund authors addresses hosoya research institute mathematical sciences kyoto university cho ku kyoto japan 
pierce department computer information science university pennsylvania south rd st philadelphia pa usa 
permission digital hard copy part material fee personal classroom provided copies distributed profit commercial advantage acm copyright server notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
yy acm yy acm toit vol 

month yy pages 
hosoya pierce common schemas programs manipulate xml dynamic typechecking 
applications schema validators ensure input documents conform expectations double check outputs 
ambitious approach drawn attention researchers static typechecking document schemas basis compile time analyses capable ensuring invalid documents arise outputs intermediate states xml processing code cluet sim wallace runciman sun microsystems meijer shields fern ndez murata milo papakonstantinou vianu hosoya pierce 
describe statically typed xml processing language called xduce officially pronounced 
xduce functional language primitive data structures represent xml documents types called regular expression types correspond document schemas 
motivating principle design simple clean powerful type system xml processing directly theory regular tree automata 
tree automata finite state machines accept trees just ordinary regular automata accept strings 
mathematical underpinnings tree automata understood comon particular problem deciding language accepted automaton included accepted corresponds familiar operation subtyping programming languages known decidable intersection difference tree automata turn useful pattern matching describe 
hand tree automata full generality quite powerful worst case complexity fundamental operations correspondingly high particular language inclusion checking take exponential time size automata seidl 
important choice xduce design accept worst case complexity return clean powerful language design imposing language restrictions reduce 
choice entails significant implementation develop algorithms efficient practical results area described companion articles hosoya hosoya pierce hosoya 
novel feature xduce powerful form pattern matching derived directly type system called regular expression pattern matching 
regular expression patterns combine conditional branching tag checking subtree extraction 
related pattern matching constructs functional languages extend constructs ability write recursive patterns precisely describe trees arbitrary size arbitrary type expressions may appear inside patterns essentially incorporating dynamic tree structures pattern matching mechanism 
prototype implementation xduce sophistication lies algorithms typechecking analysis patterns back simple terribly fast interpreter 
prototype develop number small xml processing applications 
development 
word schema generically 
acm toit vol 

month yy 
xduce typed xml processing language typechecker discovered subtle programming mistakes quite troublesome find hand 
example xhtml table tag required tr table row tag table empty table tag exist 
easy write code violates rules static type system helpful detecting mistakes early 
source code implementation publically available interested readers invited visit xduce home page xduce sourceforge net 
earlier hosoya hosoya pierce hosoya studied features xduce isolation concentrating semantic algorithmic issues 
focus article language design 
illustrate key features type system pattern matching primitives discuss considerations motivating design sections formal definition complete core language proof type soundness section discuss range related section sketch ongoing extensions section 

basic concepts section introduces basic features xduce language values types pattern matching functions 
values run time values xduce fragments xml documents 
fragments built scratch combining smaller fragments result existing values pattern matching 
example consider xml document 
addrbook person name haruo hosoya name email kyoto email email upenn email person person name benjamin pierce name email upenn email tel tel person addrbook node written pair open tag label corresponding closing tag label 
children node appear tags order children node significant 
document described tree root node labeled addrbook contains nodes label person 
person contains name emails similarly second person contains name 
name email node contains string 
precise value xduce sequence nodes 
document singleton sequence sequence children node forms single value 
xduce provides operations constructing supporting xml attributes xduce ongoing 
see section related discussion 
acm toit vol 

month yy 
hosoya pierce sequences 
example fragment program code produces document shown 
addrbook person name haruo hosoya email kyoto email upenn person name benjamin pierce email upenn tel expression form constructs singleton sequence label containing sequence resulted evaluating expression comma binary operator concatenates sequences 
note comma associative produce sequence drop parentheses expressions 
string literals written 
addition operations constructor creating empty sequence 
types types descriptions sets structurally similar values 
example type person name string email string tel string describes values consisting single label person containing sequence name email labels containing string 
slightly complicate type 
person name string email string tel string 
difference type previous zero emails follow name label indicated tel label may omitted indicated 
xduce types called regular expression types closely resemble ordinary string regular expressions difference describe sequences tree nodes string regular expressions describe sequences characters 
atoms labeled types label denotes set sequences containing single subtree labeled label base types string empty sequence type 
types composed concatenation comma zero times repetition times repetition optionality alternation called union 
type expressions names xduce programs type definitions 
example xduce implementation supports ways creating values sequence constructors load external xml document file system 
case perform validation check incorporated document intended type 
xduce implementation supports ways declaring types type definitions xduce native syntax import existing dtds external environment 
note types general dtd allow label different contents depending context 
see section related discussion 
note type definitions declare type names labels 
labels declared record labels lisp atomic symbols 
acm toit vol 

month yy 
type person person name email tel 
type name name string type email email string type tel tel string xduce typed xml processing language type named person defined abbreviation type person name email tel uses name email associated names 
type definitions convenient avoiding repetition large type expressions programs 
importantly may mutually recursive discuss possibility section 
typechecking xduce uses types various purposes 
important checking values may consumed produced function definition consistent explicitly declared argument result types 
example consider function definition 
fun person val nm string val str string person person name nm looks str tel str email str line declares function person takes parameters nm str type string returns value type person 
val keyword function header signal identifier bound variable 
body create tree labeled person contains subtrees 
labeled name contains string nm 
second labeled tel email depending argument str looks telephone number email function looks defined 
typechecking function proceeds follows 
type string variables nm str easily compute type expression body 
labeled expression labeled type concatenation expression concatenation types subexpressions expression union types branches 
result type body person name string email string tel string check type subtype annotated result type person 
question types subtype relation 
standard answer involve giving collection subtyping laws corresponding intuitive notion inclusion sets members 
types regular expressions yield algebraic laws including associativity concatenation union commutativity union distributivity union concatenation labelling play crucial roles xml processing described previous hosoya enumerating laws rules specification complicated 
adopt direct strategy define values belong type details straightforward see section 
say type subtype acm toit vol 

month yy 
hosoya pierce exactly denotes subset 
semantic definition yields subtyping relation intuitive powerful 
example consider type example just person type previous section 
types syntactically quite different 
easily check fall subtype relation email followed tel tel preceded zero emails cases described second type 
remaining question efficiently check subtyping 
know theory finite tree automata decision problem takes exponential time general case 
choosing appropriate representations applying domain specific heuristics obtain algorithm speed quite acceptable practice 
algorithm described detail hosoya 
example subtype checker invoked verify actual type function body subtype programmer declared result type 
subtyping checking type argument function call parameter type programmer 
example function definition fun print fields val fs name tel email apply argument type name email tel 
note syntactically quite different argument type parameter type subtype relation ordering constraint argument type lost parameter type yielding strictly larger set 
pattern matching far focused building values 
turn attention decomposing existing values pattern matching 
simple example consider pattern match expression creating url string value labeled protocol name 
binary operator string concatenation 
match www val string email val string mailto ftp val string ftp pattern match branches depending top label www email input value evaluates corresponding body expression prepends note somewhat special fact xduce type system direct construction attractive 
xduce order language functions passed arguments functions type system need deal arrow types functional languages 
absence arrow types greatly simplifies semantics types xduce 
frisch castagna benzaken shown semantic construction extended include arrow types frisch :10.1.1.19.4474
acm toit vol 

month yy 
xduce typed xml processing language appropriate string variable bound content label input value general pattern match expression takes input value set clauses form pattern expression input value pattern matcher finds clause pattern matches value 
extracts subtrees corresponding bound variables pattern evaluates corresponding body expression environment enriched bindings 
patterns nested test simultaneous presence multiple labels extract multiple 
example pattern person name val string email val string matches person label content name label followed email label 
logical expressed union operator 
email val string tel val string xduce patterns exactly form type expressions may include variable binders form val pattern matches input value pattern binding variable value 
demand input value pattern yields exactly binding variable call condition linearity see section precise definition 
pattern email val string tel val string email val string forbidden 
patterns just types decorated variable binders patterns perform dynamic typechecking 
example pattern person name email tel matches subset elements person contain value type name followed values type email values type tel 
capability expressiveness pattern matching facilities conventional functional languages ml haskell 
xduce pattern matching match semantics 
pattern match expression tries clauses top bottom fires matching 
semantics particularly useful write default cases 
example pattern match expression match person name val string email tel 
person name val string clause matches input person value contains emails second clause matches 
type matches values 
see section overlapping patterns permitted rewrite second pattern negate quite cumbersome 
acm toit vol 

month yy 
hosoya pierce clauses match 
xduce performs static exhaustiveness check failure arise 
section discuss detail various static checks patterns including exhaustiveness value matched clause clause match value clause body reachable non ambiguity pattern yields unique binding value matches 
complete example look small complete program 
task program create address book document telephone book document extracting just entries telephone numbers 
show type definitions input documents partly repeated type addrbook addrbook person type person person name email tel 
type name name string type email email string type tel tel string output documents 
type type person name tel thing load address book document file validate type addrbook 
assume loaded documents conform type 
val doc load xml xml val valid doc validate doc addrbook extract content top label addrbook send function tel book defined 
enclose result label save file 
val doc match valid doc addrbook val persons person tel book persons save xml output xml doc function tel book takes value ps type person returns value type 
fun tel book val ps person match ps person name val string email tel val string val rest person person name tel tel book rest person name val string email val rest person tel book rest acm toit vol 

month yy 
xduce typed xml processing language body function uses pattern match analyze ps 
case input sequence person label contains tel label pick name tel components person construct new person label recursively call tel book process remainder sequence 
second case input sequence person label contain tel label simply ignore person label recursively call tel book 
case input sequence empty return empty sequence 

types section gives examples interesting uses xduce types 
recursive types programming languages xduce supports recursive types describing arbitrarily nested structures 
consider definitions 
type fld rcd type rcd name string folder fld name string url string broken form label short hand label empty sequence type 
mutually recursive types fld folder rcd record define simple template storing structured lists bookmarks web browser folder list records record named folder named url plus broken tag indicating link broken 
write pair types type type name string folder name string url string identical fld rcd links 
note subtype fld describes values structure stronger constraints 
label classes labeled types seen far form describe singleton sequences labeled exactly xduce generalizes types allow complex forms called label class represent sets possible labels 
idea xml type systems relax ng clark murata 
form label class representing singleton set 
label class represents set labels 
define type denotes set values type int float string value repetition label containing value base value 
moment xduce supports int float base types 
added base types modify definition accordingly 
acm toit vol 

month yy 
hosoya pierce allow label class form ln representing choice labels 
label classes useful describing labeled type multiple possible labels content type 
example html headings may labeled content type inline type heading inline allow negation label classes form ln represent set labels ln 
example label classes way match inline val inline extract content label value ignoring labels prior 
union types functionality similar union types provided schema languages xml 
schema languages restrictions types joined union leading significant differences expressiveness 
example xml schema fallside xml query algebra fern ndez require types unioned disjoint sets top level labels 
hand xduce relax ng clark murata impose restriction 
main advantage having restriction express dependencies subtrees 
consider example suggested murata 
suppose designing schema latex documents 
want express division structures chapter section subsection requirements 
chapter contain sections section contain subsections 
chapters sections appear top level 
obvious way implementing division structures directly labels chapter section type definitions 
type top chapter section text type chapter chapter section text type section section subsection text type subsection subsection 
text represents normal texts assumed defined 
cases may prefer label div represent divisions programming convenience 
distinguish different kinds divisions add field kind containing discriminating tag type top chapter section text type chapter div kind chapter section text difference corresponds different kinds tree automata 
types label disjointness restriction correspond deterministic top tree automata restriction correspond general nondeterministic top tree automata 
see comon details 
acm toit vol 

month yy 
type section div kind section subsection text type subsection div kind subsection 
xduce typed xml processing language notice div label appearing top level chapter section content kind label chapter section section text subsection text interdependent 
chapter kind value type subsection time example 
dependency expressed type systems adopt label disjointness restriction mentioned 
programming set type definitions may wish process division uniformly forgetting dependency just discussed 
xduce subtyping facility useful 
type top dependency subtype type type top div kind chapter section section subsection text collapses dependency 
useful want perform exactly operation top level div chapter section counting maximum depth divisions 

pattern matching xduce performs number static analyses pattern matches exhaustiveness ambiguity checks local type inference 
section illustrate analyses example 
exhaustiveness checks typechecking xduce checks pattern match expression exhaustiveness sure possible input value matched clause 
example suppose variable type person defined person name email tel consider pattern match match person name email tel 
person name email tel 
clause matches person values email second matches person values tel 
pattern match exhaustive cover case input person value contains email tel 
xduce typechecker rejects pattern match 
order exhaustive add clause person name 
related check pattern matches 
xduce rejects pattern match expression clause pattern able match input value 
example consider pattern match 
match person name email tel 
person name email tel 
acm toit vol 

month yy 
hosoya pierce pattern match redundant values matched second clause covered clause 
report error pattern match 
may appear checks particularly important situation clause completely covered preceding ones happens infrequently 
checks valuable detecting common kinds mistakes 
misspelling labels usually clause match input value 
misunderstanding structure labels switching order email tel types example tends clause redundant 
cases detected exhaustiveness check values intended matched clause covered 
exhaustiveness check useless pattern match contains default case 
example consider match name email tel 
label misspelling 
exhaustiveness check find error pattern match vacuously exhaustive check detect clause matches 
exhaustiveness checks theory finite tree automata plays important role 
exhaustiveness check done examining set values input type included set values matched patterns patterns essentially types just subtype check 
similarly checked examining set values input type matched pattern included set values matched preceding patterns rely fact may calculate intersection tree automata 
detailed discussion required algorithms companion hosoya pierce 
xml query algebra fern ndez provides case expressions performing matching input values series patterns similar patterns somewhat simpler 
xml query algebra supports exhaustiveness checks 
exhaustiveness check sense setting case expressions syntactically required default case 
hand checks style xduce sense setting 
ambiguity checking say pattern ambiguous yields multiple possible parses input value 
input value pattern pattern matching assigns label value correspondingly labeled subpattern 
assignment called parse 
example consider pattern match input type 
match val 
acm toit vol 

month yy 
xduce typed xml processing language behavior pattern skip consecutive labels input sequence bind variable label ignore remaining sequence 
parse yielded pattern matching assigns skipped labels leftmost pattern label pattern middle labels rightmost pattern labels rightmost pattern 
pattern unambiguous 
pattern ambiguous may yield multiple parses input value 
example ambiguous 
match val 
take input value 
parses value 
assigns leftmost pattern second middle pattern 
parse assigns middle pattern second rightmost pattern 
note pattern match shown possible parse input value second 
formal definition ambiguity section 
usually ambiguous pattern signals programming error 
cases writing ambiguous patterns reasonable 
typical case application program knows implicit assumptions expressed types possible parse 
example suppose simple book database type book type book book key string title string author string assume book entry key field value 
extract book specified key database writing pattern match 
match db book book key pierce title val string author val string book 
note assumption keys guarantees entry yielded pattern match unique 
writing pattern complicated requiring disambiguation situations heavy burden user 
pattern replace occurrence book type representing books pierce 
cumbersome keys complex structure 
decided yield warning ambiguity error 
case user writes ambiguous pattern ignores warning semantics pattern matching choose arbitrary parse multiple possibilities nondeterministic semantics 
previously xduce match policy resolve ambiguity single pattern acm toit vol 

month yy 
hosoya pierce type inference patterns type annotations pattern variables normally redundant 
example pattern match values type person match ps person name val string email tel val rest person 
type string variable type person variable rest deduced input type shape patterns 
xduce supports mechanism automatically infers type annotations 
type inference scheme local locally precise 
type pattern variable inferred input type pattern 
consider long distance dependencies constraints pattern variables arising expressions bodies match branches 
locally precise mean match values input type pattern inferred type pattern variable precisely represents set values variable bound 
note semantic definition specification type inference depends dynamic semantics pattern matching 
type inference example rewritten follows 
match ps person name val email tel val rest 
examples seen appear pattern contains binding form val inferred type 
case type inference may compute precise type formally syntactic form val abbreviation val continue require type annotations pattern variables allow larger necessary 
actual types variables inferred combining types programmer types discovered propagating input type pattern 
example pattern match val head val tail binds head labeled value input sequence tail rest sequence 
types inferred head tail depend input type 
example input type email tel infer email tel head email tel tail 
input type email tel infer clause hosoya pierce 
decided throw idea away patterns behave quite unintuitive way large second guaranteeing match semantics implementation complicated 
see hosoya details 
acm toit vol 

month yy 
xduce typed xml processing language email tel head email tel 
tail 
combination declared inferred structure useful concise write rough pattern pattern precise 
addition input type changed may change pattern type inference recompute appropriate types variables 
pattern match multiple clauses type inference scheme takes match semantics account 
inferring types pattern variables clause values captured preceding clauses excluded 
example pattern match input type person match person name val email tel val 
person val infer type name email variable persons taken clause persons tel reach second clause 
handling form exclusion type inference computes difference set input values set values matched preceding patterns 
exploit closure property closure difference finite tree automata 
see hosoya pierce hosoya details 

formal definition core xduce language section presents complete formal definition core features xduce types patterns terms typechecking pattern matching evaluation establishes basic soundness theorems 
assuming familiarity basic notations techniques type systems operational semantics background topics may example pierce 
labels label classes assume possibly infinite set labels ranged define label classes follows specific label wildcard label union difference power type inference scheme improved described previous hosoya pierce 
previous scheme able infer precise types variables tail positions 
example pattern match val head val tail infer precise type tail head simply extracted type directly pattern precise 
due inference algorithm time 
developed new algorithm overcomes limitation incorporated current xduce hosoya 
acm toit vol 

month yy 
hosoya pierce semantics label classes defined denotation function mapping label classes sets labels 
write 
values brevity omit base values strings 
changes required add straightforward 
value just sequence labeled values labeled value pair label value 
write empty sequence labeled value concatenation values 
types syntax 
assume countably infinite set type names ranged types defined follows type name empty sequence concatenation labeling union repetition interpretations type names single global set type definitions form 
type body definition may mention defined type names particular definitions may recursive 
regard mapping type names bodies write right hand side definition ensure types correspond regular tree automata contextfree grammars impose syntactic restriction disallows recursion top level definitions 
type define set reachable top level smallest set satisfying 

require set type definitions satisfies dom 
additional regular expression operators obtained syntactic sugar 
acm toit vol 

month yy 
xduce typed xml processing language semantics 
semantics types relation read value type smallest relation closed set rules 
emp vi vn var lab cat rep subtyping 
subtype type written implies intersection difference 
intersection types written imply vice versa 
intersection types describe set values 
similarly type difference types imply vice versa pattern language syntax 
assume countably infinite set pattern names ranged countably infinite set variables ranged pattern expressions defined follows 
pattern name val variable binder label empty sequence concatenation choice repetition bindings pattern names patterns fixed global mutually recursive set pattern definitions form 
acm toit vol 

month yy 
hosoya pierce pat technical convenience assume includes type definitions regarding type expressions appearing pattern expressions obvious way 
conversely assume includes pattern definitions variable binders erased 
write type obtained erasing variable binders pattern definitions obey formedness restriction type definitions 
allow abbreviations regular expression operators 
val mean val assume fixed type definition type linearity 
reach set variable bindings reachable smallest set satisfying reach bv reach fn bv set variables bound fn set pattern names appearing say pattern linear iff reachable subphrase conditions hold 
reach ifp val 
reach reach 
reach reach ifp 
reach 
assume patterns linear 
semantics 
describe semantics patterns defining relation read matched yielding environment finite mapping variables values written xn vn 
concatenation environments binding distinct variables written comma 
val ep ep emp ep var ep lab include base types formalization need definition section 
acm toit vol 

month yy 
xduce typed xml processing language vi vi vn vn ep cat ep ep ep rep note linearity ensures environments concatenated rules ep ep cat ep rep different domains dom holds rule ep 
exhaustiveness 
definitions exhaustiveness non ambiguity type inference pattern match expressions respect input type describing set values may expression run time 
list pn patterns exhaustive respect written pn exhaustive iff implies pi pi 
list pn patterns irredundant respect written pn irredundant iff pi value pj andv pi non ambiguity 
define non ambiguity terms parsing relation intuitively means parses uniquely unique derivation relation 
parsing relation defined rules 
val eup eup emp unique eup var eup lab eup cat acm toit vol 

month yy 
hosoya pierce vn unique vn vi eup eup eup rep rules similar matching relation environments eup cat eup rep ensure input sequence split uniquely concatenation repetition patterns eup eup ensure input matched exactly choices 
pattern non ambiguous respect type written iff definition non ambiguity similar strong non ambiguity string regular expressions soininen treat sequences trees strings consider non ambiguity restricted set input values input values 
soininen reduce non ambiguity problem regular expressions lr property context free grammars 
direct algorithm product construction hosoya 
discussions various kinds ambiguity regular expressions relationship br klein 
pattern type inference 
goal pattern type inference compute range pattern defined follows 
type environment describes range pattern respect type written iff wehave iff exists value term language program comprises set type definitions set pattern definitions set function definitions term evaluation starts 
type pattern definitions described previous section 
section introduces functions terms 
syntax 
assume countably infinite set function names ranged definitions functions fixed global mutually recursive set function definitions form 
fun design space definitions non ambiguity large explored fully tentative simple specification 
acm toit vol 

month yy 
xduce typed xml processing language brevity treat argument functions extension functions routine 
note argument pattern provides names types bound variables result type explicitly 
syntax terms defined grammar 
variable label empty sequence concatenation application match pattern match write abbreviation ary form allow shorthands 
pn en 
match match true false simplicity assume variables bound patterns distinct 
course convert arbitrary program satisfy condition 
typing rules 
typing relation pronounced type environment defined rules 
te var te emp fun pn exhaustive pn irredundant pi pi pi ei ti match tn te lab te cat te app te match acm toit vol 

month yy 
hosoya pierce discussed section performing type inference clause pi difference operation exclude values matched preceding patterns input type check ambiguity clause respect difference type definition ambiguity consider values pattern match 
single rule judging definition function typed written fun fun tf evaluation rules 
semantics terms defined big step evaluation relation rules evaluation relation standard interesting case rule pattern matching uses semantics patterns defined 
ee var ee emp fun pi pi ei match ee lab ee cat ee app ee match note assumption bound variables distinct concatenated environments ensured different domains 
type soundness conclude treatment core xduce sketching proof type soundness 
usual parts proof subject reduction typed term evaluates value inhabiting expected type progress typed term get stuck 
acm toit vol 

month yy 
xduce typed xml processing language theorem subject reduction suppose fun function definitions 
note statement subject reduction involves typing relations defined earlier syntactic expression typing relation semantic value typing relation 
proof 
prove stronger statement means dom dom andv dom 
proof proceeds induction derivation 
show just interesting cases ones function application pattern matching 
cases follow straightforward induction hypothesis 
case fun te app obtain induction hypothesis 
byte app definition subtyping 
tf definition type inference tf induction hypothesis subtyping yields case match pi pi ei te match induction hypothesis 
pi te match definition difference implies pi te match definition type inference yields te match gives ei ti induction hypothesis 
result follows ti tn 
chosen big step semantics need little careful means term get stuck 
naively simply say stuck case amounts saying stuck finite derivation quite want finite derivation may fail exist gets stuck diverges 
precisely capture notion gets stuck finite number steps define stuck evaluation relation inductively follows 


match pi acm toit vol 

month yy 
hosoya pierce pi pi ei 
notice base cases second case function applications second case match expression input value match pattern 
theorem progress suppose fun function definitions implies 
proof 
obtain result proving stronger statement proof statement goes induction derivation 
show just interesting cases rest proceed straightforward induction hypothesis 
case fun suppose contradiction te app 
subject reduction 
addition assumption fun implies andv implies induction hypothesis contradiction 
case match pi suppose te match pn exhaustive 
subject reduction definition exhaustiveness implies pi contradicts assumption 
case match pi pi ei suppose te match subject reduction pj pi 
te match tells pi pi pi furthermore te match wehave ei induction hypothesis ei contradiction 

related static typing programs xml processing approached different angles 
popular idea embed schema language xml existing typed language translating document types class hierarchies object oriented language algebraic datatypes functional language embeddings called data bindings 
examples data binding acm toit vol 

month yy 
xduce typed xml processing language approach include wallace runciman sun microsystems 
large number software products implementing similar ideas comprehensive list 
advantage approach carried entirely existing language 
cost xml values corresponding schemas translated value type spaces host language usually involves adding layers tagging original xml documents inhibits subtyping programming somewhat flexible 
xml processing language xm designed meijer shields basically followed approach major improvement flexibility introducing type indexed rows meijer shields shields meijer 
type system union type dtd represented sum type summand tagged type systems mapping approach uses fixed label determined order appears name top level tags 
union xm commutative just xduce 
mechanism validate useful subtyping laws associativity distributivity unions xduce 
hand ml row polymorphism achieves additional flexibility different direction 
example write polymorphic function type 
function changes specific label leaves rest elements unchanged conveys typing constraint type unioned input exactly type unioned output 
typing constraints represented just subtyping 
query language yat cluet sim kuper sim includes type system similar regular expression types 
xduce yat offers notion subtyping flexibility 
adopt somewhat restrictive subtyping relation allow subtype allow way 
choice determined design goal attaining efficient layout large xml databases 
initial publication xduce influenced number proposals researchers 
fernandez sim wadler proposed xml query algebra basis xml query processing optimization regular expression types type system subtyping algorithm early implementation fern ndez 
currently working standardized language xquery early proposal 
reports approach combine named structural subtyping sim wadler 
frisch castagna benzaken significant extension xduce xml processing language frisch :10.1.1.19.4474
particular type system treats higher order functions intersection complementation type operators 
regular expression types stimulated schema language designs 
particular clark schema language trex clark adopted large part definition types carried iso standard schema language relax ng clark murata 
acm toit vol 

month yy 
hosoya pierce theoretical level number proposals typechecking algorithms various xml processing languages 
milo suciu vianu studied typechecking problem general framework called pebble tree transducers capture wide range query languages xml milo 
related vein papakonstantinou vianu typechecking algorithm query language ql extensions dtds papakonstantinou vianu 
murata developed typechecking algorithm document transformation language powerful pattern matching murata 
pursued typechecking technique subset xslt 
types techniques papers tree automata conceptually identical xduce 
hand type checking algorithms papers semantically complete program input type output type algorithm returns exactly documents produced program input type output type xduce xduce turing complete demanding level precision problem undecidable 
investigation regular expression types originally motivated observation buneman pierce buneman pierce untagged union types correspond naturally forms variation semistructured databases 
main differences study unordered record types ordered sequences treat recursive types 
pattern matching wide variety languages variety styles 
axis categorization bindings pattern match yields 
matches style pattern match yields set bindings corresponding possible matches 
style query languages deutsch abiteboul cluet sim cardelli ghelli neven schwentick fankhauser document processing languages clark neumann seidl murata :10.1.1.45.8397
single match style successful match yields just binding 
style commonly functional programming languages milner leroy peyton jones followed xduce 
experimenting aspect language hope incorporate form match patterns successor xtatic 
axis comparing pattern matching primitives expressiveness underlying logic papers proposed extension ml pattern matching recursion hndrich boyland queinnec essentially expressiveness 
query languages document processing languages pattern matching mechanisms tree automata neumann seidl murata monadic second order logic strong connection tree automata neven schwentick similar expressiveness pattern matching 
tql cardelli ghelli powerful pattern matching facility ambient logic cardelli gordon 
ambient logic allows arbitrary logical operators union intersection complementation suggests expressiveness similar tree automata 
exact comparison difficult underlying data model unordered trees 
hand acm toit vol 

month yy 
xduce typed xml processing language pattern matching regular path expressions popular query languages semistructured data deutsch abiteboul cluet sim expressive tree automata :10.1.1.45.8397
instance patterns express constraints match subtrees contain exactly labels tree automata regular path expressions express extraction data arbitrarily nested tree structure single match style usefulness deep matching questionable related discussion previous pattern matching hosoya pierce 
thiemann proposed technique encode dtds haskell type classes statically ensure validity dynamically generated xml documents thiemann 
technique implemented pure haskell library requiring language extension 
hand proposal limited generating documents provides facility analyze input xml documents 
christensen brabrand ller schwartzbach designed domain specific language bigwig programming interactive web services brabrand successor christensen 
employ interprocedural flow analysis statically validating xml documents produced programs brabrand 
analysis capable checking programs type annotations 
unique programming feature called templates documents gaps allow fill document fragments templates 
currently support processing input documents propose mechanism called turns input document gaps template christensen 

xduce typed programming language takes xml documents sequences nodes primitive values 
provides constructors pattern matching sequences uses regular expression types describing structure statically 
correspondence types finite tree automata gives language powerful mathematical foundation leading simple clean flexible design 
regard xduce step direction native programming language support xml 
number significant issues remain considered innovations offered mainstream xml programmers 
xduce type system needs extended handle common features real world schema languages 
support xml attributes 
different styles treatments adopt relax ng approach clark murata symmetrically handles constraints elements attributes 
murata author just figured imposed algorithmic issues hosoya murata 
issue addressed typing unordered data useful representing records example 
clean solution introduce called shuffle interleave operator relax ng 
open question test inclusion compute intersection difference reasonable efficiency 
second writing programs substantial trivial xml transformations acm toit vol 

month yy 
hosoya pierce need kinds data structures sequences hash tables arrays 
pursuing direction existing popular programming language java mixing type system regular expression types 
way avoid re inventing existing language features libraries easily invite people working xml languages 
third mixed type system need advanced typing features 
parametric polymorphism 
currently java supports planning deal 
typing imperative operations xml data 
currently xduce disallows modification values rigid programmers 
technically parametric polymorphism destructive operations non trivial 
working design successor xduce named xtatic aims address issues context extension regular expression types pattern matching 
appendix abiteboul quass mchugh widom wiener 
lorel query language semistructured data 
international journal digital libraries 


www net jp dp asm java tools index html 

xml data binding resources 
www com xml htm 
brabrand ller schwartzbach 
static validation dynamically generated html 
workshop program analysis software tools engineering paste 
brabrand ller schwartzbach 
bigwig project 
acm transactions internet technology toit 
bray paoli sperberg mcqueen maler 
extensible markup language 
www org xml 
br klein 
regular expressions finite automata 
theoretical computer science 
buneman pierce 
union types semistructured data 
internet programming languages 
lecture notes computer science vol 

springer verlag 
proceedings international database programming languages workshop 
cardelli ghelli 
query language semistructured data ambient logic 
manuscript 
cardelli gordon 
anytime 
modal logics mobile ambients 
proceedings th acm symposium principles programming languages 

christensen ller schwartzbach 
extending java high level web service construction 
acm transactions internet technology toit 
christensen ller schwartzbach 
static analysis dynamic xml 
plan programming language technologies xml 
clark 
xsl transformations xslt 
www org tr xslt 
clark 
trex tree regular expressions xml 
www com trex 
clark murata 
relax ng 
www org 
acm toit vol 

month yy 
xduce typed xml processing language cluet sim 
yat build web server 
intl 
workshop web databases webdb 
comon dauchet gilleron tison 
tree automata techniques applications 
draft book available electronically www grappa univ lille fr tata 
deutsch fernandez florescu levy suciu 
xml ql query language xml 
www org tr note xml ql 
hndrich boyland 
statically checkable pattern abstractions 
proceedings international conference functional programming icfp 

fallside 
xml schema part primer recommendation 
www org tr xmlschema 
fankhauser fern ndez malhotra sim wadler 
xquery formal semantics 
www org tr query semantics 
fern ndez sim wadler 
semi monad semi structured data 
proceedings th international conference database theory icdt den bussche vianu eds 
lecture notes computer science vol 

springer 
frisch castagna benzaken 
semantic subtyping 
seventeenth annual ieee symposium logic computer science 
hosoya 
regular expression pattern matching simpler design 
tech 
rep rims kyoto university 
hosoya murata 
validation boolean operations attribute element constraints 
programming languages technologies xml plan 

hosoya pierce 
xduce typed xml processing language preliminary report 
proceedings third international workshop web databases webdb 
lecture notes computer science vol 


hosoya pierce 
regular expression pattern matching xml 
th annual acm sigplan sigact symposium principles programming languages 

hosoya vouillon 
regular expression types xml 
proceedings international conference functional programming icfp 

full version submission toplas 
klarlund ller schwartzbach 
dsd schema language xml 
www brics dk dsd 
kuper 
subsumption xml types 
international conference database theory icdt 
london 
leroy vouillon doligez 
objective caml system 
software documentation available web pauillac inria fr ocaml 
meijer shields 
xm functional programming language constructing manipulating xml documents 
submitted usenix technical conference 
milner tofte harper 
definition standard ml 

milo suciu vianu 
typechecking xml transformers 
proceedings nineteenth acm sigmod sigact sigart symposium principles database systems 
acm 
murata 
transformation documents schemas patterns contextual conditions 
principles document processing 
lecture notes computer science vol 

springer verlag 
neumann seidl 
locating matches tree patterns forests 
th 
lncs vol 


neven schwentick 
expressive efficient pattern languages treestructured data 
proceedings nineteenth acm sigmod sigact sigart symposium principles database systems 
acm 
acm toit vol 

month yy 
hosoya pierce papakonstantinou vianu 
dtd inference views xml data 
proceedings nineteenth acm sigmod sigact sigart symposium principles database systems 
dallas texas 
peyton jones hall hammond partain wadler 
glasgow haskell compiler technical overview 
proc 
uk joint framework information technology technical conference 
pierce 
types programming languages 
mit press 
queinnec 
compilation non linear second order patterns expressions 
programming language implementation logic programming nd international workshop plilp 
lecture notes computer science 
springer verlag 
seidl 
deciding equivalence finite tree automata 
siam journal computing june 
shields meijer 
type indexed rows 
th annual acm sigplan sigact symposium principles programming languages 
london 
sim wadler 
essence xml 
acm sigplan sigact symposium principles programming languages 
soininen 
parsing theory 
eatcs monographs theoretical computer science 
vol 

springer 
sun microsystems 
java architecture xml binding 
java sun com xml 
thiemann 
typed representation html xml documents haskell 
appear journal functional programming 

static type inference xslt 
proceedings acm symposium document engineering 
wallace runciman 
haskell xml generic combinators type translation 
proceedings fourth acm sigplan international conference functional programming icfp 
acm sigplan notices vol 

acm press 
acknowledgments main collaborator xduce project vouillon contributed number ideas design xduce implementation 
grateful xduce team members peter buneman vladimir michael levin phil wadler 
learned great deal discussions db group pl club penn members professor yonezawa group tokyo 
supported japan society promotion science hosoya national science foundation nsf career ccr pierce gift microsoft 
acm toit vol 

month yy 
