java bytecode verification algorithms formalizations xavier leroy xavier leroy inria fr inria rocquencourt trusted logic 
bytecode verification crucial security component java applets web embedded devices smart cards 
reviews various bytecode verification algorithms proposed common framework dataflow analysis surveys proof assistants specify bytecode verification prove correctness 
keywords bytecode verification java virtual machine dataflow analysis interpretation subroutines 
web applets popularized idea downloading executing untrusted compiled code personal computer running web browser user approval intervention 
obviously raises major security issues appropriate security measures malicious applet mount variety attacks local computer destroying data reformatting disk modifying sensitive data registering bank transfer software personal information network modifying programs trojan attacks 
web services applet model transferred high security embedded devices smart cards java card architecture allows post issuance downloading applets smart cards 
smart cards security tokens sensitive application areas payment mobile telephony authentication 
security issues applets acute 
solution put forward java programming environment execute applets called sandbox insulation layer preventing direct access hardware resources implementing suitable access control policy 
security sandbox model relies components 
applets compiled machine executable code bytecode virtual machine 
virtual machine manipulates higher level secure abstractions data kluwer academic publishers 
printed netherlands 
bv tex hardware processor object memory addresses 

applets direct access hardware resources serial port carefully designed set api classes methods perform suitable access control performing interactions outside world behalf applet 

downloading bytecode applet subject static analysis called bytecode verification purpose sure code applet typed attempt bypass protections performing ill typed operations run time forging object integers illegal casting object class calling directly private methods api jumping middle api method jumping data code 
bytecode verification crucial security component java sandbox model bug verifier causing ill typed applet accepted potentially enable security attack 
time bytecode verification complex process involving elaborate program analyses 
consequently considerable research efforts expended specify goals bytecode verification formalize bytecode verification algorithms prove correctness 
purpose survey bytecode verification 
explain bytecode verification describe various algorithms proposed outline main problems faced give machine assisted proofs correctness 
remainder organized follows 
section gives quick overview java virtual machine bytecode verification 
section presents basic bytecode verification algorithm dataflow analysis 
sections concentrate delicate verification issues checking object initialization dealing jvm subroutines 
section presents polyvariant verification algorithms address subroutine issue 
issues specific low resources embedded systems discussed section followed perspectives section 
overview jvm bytecode verification java virtual machine jvm conventional stack machine 
instructions pop arguments stack bv tex source java code static int factorial int int res res res res return res corresponding jvm bytecode method static int factorial int registers stack slots iconst push integer constant istore store register res variable iload push register parameter negative null go pc iload push register res iload push register multiply integers top stack istore pop result store register decrement register goto go pc iload load register res ireturn return value caller 
example jvm bytecode push back results stack 
addition set registers called local variables provided accessed load store instructions push value register stack store top stack register respectively 
architecture mandate java compilers registers store values source level local variables method parameters stack hold temporary results evaluation expressions 
stack registers part activation record method 
preserved method calls 
entry point method specifies number registers stack slots method allowing activation record right size allocated method entry 
control handled variety intra method branch instructions unconditional branch goto conditional branches branch top stack multi way branches corresponding switch java construct 
exception handlers specified table pc pc quadruples meaning exception class subclass bv tex raised instruction locations pc pc control transferred instruction exception handler 
instructions supported including arithmetic operations comparisons object creation field accesses method invocations 
example give general flavor jvm bytecode 
important feature jvm instructions typed 
instance iadd instruction integer addition requires stack initially contains elements elements type int pushes back result type int 
similarly getfield instruction access instance field type declared class requires top stack contains instance class sub classes instance integer correspond attempt forge object unsafe cast pops pushes back value type value field 
generally proper operation jvm guaranteed code meets conditions type correctness arguments instruction types expected instruction 
stack overflow underflow instruction pops argument empty stack pushes result full stack size equal maximal stack size declared method 
code containment program counter point code method valid instruction encoding falling method code branches middle instruction encoding 
register initialization load register follow store register terms registers correspond method parameters initialized method entrance error load uninitialized register 
object initialization instance class created initialization methods class corresponding constructors class invoked class instance 
way guarantee conditions check dynamically executing bytecode 
called defensive jvm approach literature 
checking conditions bv tex run time expensive slows execution significantly 
purpose bytecode verification check conditions static analysis bytecode loading time 
bytecode passes verification executed faster omitting dynamic checks conditions 
emphasized bytecode verification guarantee secure execution code crucial properties code need checked dynamically instance array bounds checks null pointer checks virtual machine access control checks api 
purpose bytecode verification shift verifications listed run time loading time 

basic verification dataflow analysis jvm bytecode verification algorithm due gosling yellin sun 
existing bytecode verifiers implement algorithm 
summarized dataflow analysis applied type level interpretation virtual machine 
advanced aspects algorithm go standard dataflow analysis described sections 
section describe basic ingredients algorithm type level interpreter dataflow framework 

type level interpreter heart bytecode verification algorithms described interpreter jvm instruction set executes jvm instructions defensive jvm including type tests stack underflow overflow tests operates types values 
interpreter manipulates stack types sequence types register type tuple types associating type register number 
simulates execution instructions level types 
instance iadd instruction integer addition checks stack types contains elements top elements type int 
pops top elements pushes back type int corresponding result addition 
defines formally interpreter number representative jvm instructions 
interpreter transition relation instruction stack type register type executing instruction stack type register type bv tex iconst int int int iadd int int int iload int int istore int int null null aload object astore object getfield putfield invokestatic 


invokevirtual 



selected rules type level interpreter 
maximal stack size maximal number registers 
executing instruction 
errors type mismatches arguments stack underflow stack overflow denoted absence transition 
instance transition iadd empty stack 
notice method invocations invokestatic invokevirtual instructions treated branching code invoked method concrete jvm simply assume effect method invocation stack described method signature invoke instruction 
bytecode verification algorithms described proceed method method assuming methods typed verifying code method 
simple coinductive argument shows case program collection methods typed 
types manipulated interpreter similar source level types java language 
include primitive types int long float double array types object types represented fully qualified names corresponding classes 
bv tex int object float int float object object null 
type expressions verifier subtyping relation 
user defined classes extending types shown 
boolean byte short char types java identified int 
extra types introduced null represent type null represent absence value unreachable instructions represent contents uninitialized registers value 
load instructions explicitly check accessed register type detecting accesses uninitialized registers 
types equipped subtyping relation written essentially identical subtyping relation java language assignment compatibility predicate 
illustrates subtyping relation 
precise definitions omitted 
purposes article require subtyping relation property property 
founded semi lattice 
set types ordered relation semi lattice pair types upper bound 
ordering founded exist infinite strictly increasing sequences types 
relation types extended pointwise register types stack types 
stack types relation size 
easy see relation register types stack types founded 
type level interpreter satisfy formal properties 
foremost correctness respect dynamic semantics defensive jvm interpreter transition concrete states bv tex matching defensive jvm started state run time type violation loop transition state matches 
correctness property formalized proved authors including isabelle hol prover coglio specware goldberg qian standard mathematics :10.1.1.49.6751
properties interpreter essential ensure correctness termination bytecode verification algorithms reviewed determinacy transitions monotonicity respect subtyping relation 
property 
determinacy 
transitions interpreter define partial function 
property 
monotonicity 
stack types register types exists stack type register type 
dataflow analysis verifying method body straight line piece code branches easy simply iterate transition function interpreter instructions stack type register type preceding instruction stack type register type instruction 
initial stack register types reflect state jvm method entrance stack type empty types registers 
corresponding method parameters set types corresponding parameters method signature registers 
corresponding uninitialized local variables type 
interpreter gets stuck transition intermediate states verification fails code rejected 
verification succeeds interpreter correct approximation defensive jvm certain defensive jvm get stuck executing code 
code correct executed safely regular non defensive jvm 
branches exception handlers introduce forks joins control flow method 
instruction predecessors different stack register types predecessor instructions 
sun bytecode verifier deals situation bv tex 
handling joins control flow lub manner customary data flow analysis state stack type register type instruction taken upper bound states predecessors instruction 
instance assume classes extend analyze conditional construct stores value type register arm value type arm 
see 
arms meet register assumed type upper bound smallest common supertype precisely write instr instruction program point state instruction state instruction verification algorithm sets forward dataflow equations instr lub predecessor valid program point plus 
pn 
entry point pk types method parameters 
equations solved standard fixpoint iteration kildall worklist algorithm section program point taken worklist state determined state interpreter replace lub successor enter successors changed worklist 
fixpoint reached worklist empty case verification succeeds 
verification fails state transition encountered upper bounds undefined 
trivial optimization algorithm dataflow equations set level extended basic blocks individual instructions 
terms suffices keep working memory states extended basic block branch target states recomputed fly needed 
bv tex upper bound states taken pointwise stack types register types 
undefined stack types different heights causes verification fail 
situation corresponds program point run time stack different heights depending path point reached code proved correct framework described section rejected 
see section alternate verification algorithm handle situation 
upper bound types register stack slot causing register type merged state 
corresponds situation register holds values incompatible types arms conditional int arm object treated uninitialized loads register merge point 
formalizations proofs machine bytecode verification algorithm described published 
nipkow klein development hol closest dataflow presentation gave 
formalizations correctness proofs dataflow approach include qian coglio st rk :10.1.1.49.6751
bytecode verification specified proved sound type systems framework forward dataflow analysis algorithm described viewed type inference algorithm type systems :10.1.1.57.9634
hartel moreau survey approaches 

interfaces upper bounds dataflow framework requires type algebra ordered subtyping relation constitutes semi lattice 
pair types possesses smallest common supertype upper bound 
unfortunately property hold take verifier type algebra java source level type algebra extended null subtyping relation java source level assignment compatibility relation 
problem interfaces types just classes class implement interfaces 
consider classes interface 
interface 
class implements 
class implements 
subtyping relation induced declarations bv tex object obviously semi lattice types common super types comparable subtype 
ways address issue 
approach manipulate sets types verification single types described earlier 
sets types interpreted conjunctive types set conjunctive type represents values types suitable upper bound types example 
approach followed :10.1.1.49.6751
approach complete class interface hierarchy program lattice performing verification 
instance general mathematical construction known dedekind completion poset 
example completion add point lattice types subtype supertype 
obtain semi lattice object additional type plays role type set approach described 
difference completion class interface hierarchy performed verification manipulates simple types sets types 
keeps verification simple fast 
simplest solution interface problem sun implementation jdk bytecode verifier 
approach documented easily inferred experimentation 
bytecode verification ignores interfaces treating interface types class type object 
type algebra verifier contains proper classes interfaces subtyping proper classes simply inheritance relation bv tex 
java single inheritance class implement interfaces inherit class subtyping relation tree shaped trivially forms semi lattice upper bound classes simply closest common ancestor inheritance tree 
downside sun approach compared set completion approach verifier guarantee statically object implements interface 
particular invokeinterface instruction invokes method interface object guaranteed receive runtime object implements guarantee provided sun verifier receives argument type object object 
invokeinterface instruction check dynamically object implements raise exception 

verifying object initialization object creation java virtual machine step process instruction new creates new object instance class instance fields filled default values numerical fields null fields second initialization methods class methods named init resulting compilation constructors class invoked newly created object 
initialization methods just source level counterpart constructors typically initialize instance fields non default values perform nearly arbitrary computations 
jvm specification requires step object initialization protocol respected 
object instance created new instruction considered uninitialized regular object operations store object data structure return method result access fields invoke methods allowed uninitialized object 
initialization methods class invoked new object returns normally new object considered fully initialized usable object 
additional restrictions discuss imposed initialization methods see :10.1.1.57.9634:10.1.1.52.8631
register initialization property object initialization property crucial ensure type safety run time new instruction initializes instance fields new object correct values types type safety broken resulting object right away having called initializer bv tex method 
object initialization property important ensure invariants instance fields established constructor class hold objects class 
static verification object initialization complex fact initialization methods operate side effect uninitialized object returning initialized object simply take uninitialized object update fields return 
code generated java compilers source level statement new arg generally form new create uninitialized instance dup duplicate instance code compute arg invokespecial init call initializer astore store initialized object uninitialized instance held stack 
topmost consumed invocation init 
initializer returns second top stack properly initialized object stored register allocated tricky point initializer method applied object stack object contained stack happens object status goes uninitialized fully initialized process 
demonstrated static verification object initialization requires form alias analysis precisely alias analysis determine object current state guaranteed refer uninitialized object passed argument initializer method 
alias analysis sun verifier uses fairly simple analysis uninitialized object identified position program counter value new instruction created 
precisely type algebra enriched types cp denoting uninitialized instance class created new instruction pc invocation initializer method init checks argument method type cp pops arguments stack type usual finds occurrences type cp interpreter state stack type register types replaces example shows works nested initialization corresponding java expression new new null new stack type dup new bv tex dup null null invokespecial init invokespecial init 
particular invokespecial initializes instance created pc created pc 
approach correct time machine state contains uninitialized object created pc 
verifier prevent situations distinct objects created instruction new flight type cp initializing cause verifier assume incorrectly initialized 
potentially happen new instruction executed repeatedly part loop example involving subroutines 
avoid problem sun verifier requires uninitialized object type appear machine state backward branch taken 
freund mitchell formalize simpler equally effective restriction propose verifying new instruction location occurrence type cp stack type register type bertot proves correctness approach coq theorem prover extracts verification algorithm proof 
bertot algorithm standard dataflow analysis features additional pass constraint solving 
sun restriction freund mitchell restriction monotone sense raising type register stack location cp transform state transitions possible state transition possible 
terms property hold causes difficulties dataflow analysis 
address issue modified formulation freund mitchell restriction introduced new instruction location fail occurrences type cp stack register types sets entries resulting state 
suffices enforce non aliasing objects types set initialized respecting monotonicity property 
subroutines described section complicate verification object initialization 
discovered freund mitchell new instruction inside subroutine result distinct uninitialized objects having static type cp fooling sun verifier believing initialized invoking initialization method 
solution prohibit set bv tex registers stack locations type cp subroutine call 
coglio observes sun restriction backward branches freund mitchell restriction new unnecessary bytecode verifier monovariant dataflow analysis 
precisely section shows absence subroutines register stack location type cp just program point containing new instruction 
program points uninitialized object types stack types register types prohibited turned subroutine calls 

subroutines subroutines jvm code fragments called points inside code method 
jvm provides instructions jsr branches label method code pushes return address instruction ret recovers return address register branches corresponding instruction 
subroutines compile certain exception handling constructs general code sharing device 
difference subroutine call method invocation body subroutine executes activation record caller access modify registers caller 

verification problem subroutines subroutines complicate significantly bytecode verification dataflow analysis 
obvious determine successors ret instruction return address class value 
approximation say ret instruction branch instruction follows jsr method code 
approximation coarse practice describe better approximations 
second subroutine entry point acts merge point control flow graph causing register types points call subroutine merged 
lead excessive loss precision register types inferred example shows 
jsr successor 
register type type int 
register type upper bound int 
subroutine body modify register type 
ret successors instructions jsr 
register type bv tex register uninitialized jsr call subroutine 
iconst istore register type int jsr call subroutine iload load integer register ireturn return caller 
subroutine astore store return address register 
execute code register ret return caller 
example subroutine integer instructions 
code rejected 
behavior counter intuitive 
calling subroutine register modify run time value register expect modify verification time type register 
subroutine body expanded inline jsr sites bytecode verification succeed expected 
subroutine compilation scheme try 
construct produces code register uninitialized call site subroutine holding value preserved subroutine call site 
crucial similar code passes bytecode verification 
remainder section section refinements verification algorithm achieve goal 

sun solution describe approach implemented sun jdk verifier 
described informally section formalized various degrees completeness faithfulness sun implementation 
approach implements intuition call subroutine change types registers subroutine body 
need precise subroutine body jvm bytecode unstructured subroutines syntactically delimited code subroutine entry points easily detected targets jsr instructions immediately apparent bv tex instructions reached subroutine entry point 
dataflow analysis performed parallel main type analysis 
outcome analysis consistent labeling instruction entry point subroutine logically belongs 
labeling determine subroutine entry point return instruction ret subroutine set registers read written instructions belonging subroutine 
dataflow equation subroutine calls follows 
instruction jsr instruction immediately state jsr ret state ret terminates subroutine 
terms state instruction jsr identical state ret types registers subroutine taken state jsr 
example ret register 
type register instruction instruction jsr equal type instruction jsr int type register ret 
effective practice sun approach subroutine verification raises challenging issue determining subroutine structure difficult 
subroutines syntactically delimited return addresses stored general purpose registers subroutine specific stack tracking return addresses matching ret jsr pairs difficult 
facilitate determination subroutine structure jvm specification states number restrictions correct jvm code different subroutines merge execution single ret instruction section 
restrictions ad hoc specific particular subroutine labeling algorithm sun verifier uses 
description subroutine labeling jvm specification informal incomplete 
rational reconstructions formalizations part sun verifier published 
presentations closest sun implementation due qian st rk :10.1.1.49.6751
characteristic feature sun implementation correctly captured presentations subroutine structure sets determined prior setting solving dataflow equations bv tex suggested types sets inferred simultaneously dataflow analysis 
simultaneous computation types sets complicates analysis shown qian transfer function dataflow analysis longer monotonous special iteration strategies required reach fixpoint 

approaches verification subroutines alternatives sun verification subroutine proposed literature context small subsets jvm leading algorithms simpler elegant scale jvm 
formal subroutine verification due abadi stata relies separate analysis performed type verification proper labels bytecode instructions names subroutines belong reconstructing subroutine structure 
sets computed subroutine injected dataflow equations described section 
hagiya relies prior determination subroutine structure expresses flow types subroutines different way special types refer type register caller subroutine 
types behave type variables type system featuring parametric polymorphism 
terms subroutine type polymorphic types local variables 
works shed considerable light issue subroutines carried context small subset jvm excludes exceptions object initialization particular 
delicate interactions subroutines object initialization discussed section 
exceptions exception handling complicates significantly determination subroutine structure 
examination bytecode produced java compiler shows possible situations exception handler covers range instructions entirely contained subroutine case code exception handler considered part subroutine branch back ret instruction terminates subroutine exception handler covers instructions belonging subroutine non subroutine instructions case code handler considered outside subroutine 
problem second case branch exception handler subroutine instruction non subroutine instruction branch bv tex ret instruction situation allowed abadi stata subroutine labeling system 
desirable develop subroutine verification strategies rely prior determination subroutine structure discover structure verification 
polyvariant verification algorithms discuss section satisfy requirement 
callahan proposes different approach continuation types type assigned return address contains complete stack register type expected program point jsr instruction 
callahan gives type checking rules effective type inference algorithm 

polyvariant bytecode verification far bytecode verification monovariant flow analysis program point state register type stack type considered 
polyvariant flow analyses called context sensitive analyses section lift restriction states allowed program point 
show section polyvariant bytecode verification provides alternate solution subroutine problem section polyvariant analysis allows instructions inside subroutine bodies analyzed times call site subroutine merging corresponding states monovariant analysis section 

polyvariant verification contours polyvariant bytecode verification analysis describe contours java card card verifier 
contour polyvariant flow analysis distinct states maintained program point indexed contours usually approximate control flow path led state 
case bytecode verification contours subroutine call stacks lists return addresses sequence jsr instructions led corresponding state 
absence subroutines bytecode method analyzed empty contour 
state associated instruction analysis degenerates monovariant dataflow analysis section 
jsr instruction encountered current contour treated branch instruction augmented contour similarly ret instruction treated branch restricts current context popping return addresses determined type register 
bv tex example jsr instructions analyzed empty context 
causes states associated instruction contour assigns type register contains retaddr top stack state contour assigns type int register contains retaddr top stack 
instructions 
analyzed twice contours 
contour ret treated branch register type 
contour ret treated branch register having type int 
analyzing subroutine body polyvariant way different contours avoided merging types int register subroutine entry point obtained desired type propagation behavior register jsr int jsr 
formally polyvariant dataflow equation jsr instruction followed instruction retaddr ret instruction equation type register state retaddr context obtained popping return addresses instructions jsr ret equation simply instruction triggers change contour 
way view polyvariant verification exactly equivalent performing monovariant verification expanded version bytecode subroutine call replaced distinct copy subroutine body 
copies subroutine body analyze times different contours 
course duplicating subroutine bodies monovariant verification practical requires prior knowledge subroutine structure determine instructions part subroutine body shown section subroutine structure hard determine exactly 
beauty polyvariant type retaddr represents return address instruction subtype 
bv tex true invokestatic try jsr goto astore exception handler continue jsr aload astore subroutine goto exception table 
problem contour polyvariant verification left java source code right corresponding jvm bytecode analysis determines subroutine structure way computations contours performed dataflow analysis 
determination takes advantage typing information retaddr ra types determine certainty point ret instruction branches case early return nested subroutines 
advantage polyvariant verification handles code reachable subroutine bodies main program exception handlers mentioned section deciding exception handlers part subroutine polyvariant analysis simply analyzes times empty contour times subroutine contours 
downside polyvariant verification computationally expensive sun approach 
particular subroutines nested depth subroutine called times instructions innermost subroutine analyzed times sun algorithm 
typical java code low nesting subroutines methods 
extra cost polyvariant verification entirely acceptable practice 
serious drawback approach contour polyvariant verification fail accept valid jvm code subroutine structure infers construction contours infinite 
consider java method shown corresponding jvm code 
subroutine terminate ret instruction goto branches back non bv tex subroutine part method code 
branch corresponds continue statement source code 
polyvariant verification starts analyzing instructions empty contour 
jsr causes instructions analyzed contour 
goto affect contour ret instruction causing instructions re analyzed contour 
iterating process analyzing instructions infinite number contexts 
verification terminate 
alternatively termination ensured requiring contours contain twice subroutine label jsr contour containing rejected accordance jvm specification states subroutines recursive 
java card verifier 
case rejecting valid piece jvm bytecode generated compilation valid albeit artificial java program 
demonstrated example data independent contours direct polyvariant verification cause infinitely different states kept program point states exactly identical 
example states point contours identical 
describe alternate approach polyvariant verification contours avoids issues 

model checking interpretations folk lore dataflow analyses viewed model checking interpretations 
large part bytecode verification obviously interpretation defensive jvm type level natural look remaining parts model checking perspective 
posegga vogt 
outline algorithm takes bytecode method generates temporal logic formula holds bytecode safe 
shelf model checker determine validity formula 
application uses small part power generality temporal logic model checker approach sounds interesting establishing finer properties bytecode go basic safety properties bytecode verification see section 
article basin volume explores model checking approach bytecode verification great details 
independently coglio extract essence model checking approach idea exploring reachable states bv tex interpreter 
consider transition relation obtained combining transition relation type level interpreter successor relation instructions 
relation form meaning interpreter started pc stack type register type abstractly execute instruction arrive pc stack type register type additional transitions err introduce reflect states interpreter stuck transition check failed 
instr successor err instr bc coglio verification algorithm simply explores states reachable repeated applications extended transition relation starting initial state 
pn 
corresponding method entry 
terms writing 
step closure set states bc algorithm computes fixpoint iteration smallest set containing closed err error state reachable bytecode rejected 
bytecode passes verification 
case err reachable correctness interpretation proved guarantees concrete defensive jvm interpreter fail safety check execution method code bytecode safe 
algorithm terminates number distinct states finite albeit large finite number distinct types program height stack bounded number registers fixed 
problem subroutines described section completely disappears approach 
suffices transitions jsr ret instructions retaddr instr jsr instr ret retaddr err instr ret retaddr fact bc algorithm merges types inferred execution paths leading instruction guarantees subroutine bodies analyzed times necessary propagate type information correctly subroutine calls 
bv tex consider twice stack register types point guaranteeing termination avoiding problem 
instance example accepted contour polyvariant verification correctly accepted instructions verified exactly twice assumption assumption retaddr 
interest approach allows reconsider design decisions explained sections 
particular bc algorithm computes upper bounds types simply checks subtyping relations types 
applied founded subtyping relation just relations form semi lattice 
keep track interface types verify invokeinterface instructions accurately having deal sets types lattice completion 
similarly possible verify code stack size paths leading instruction 
formalized proved correctness approach coq proof assistant extracted ml code bytecode verifier proof 
klein prove correctness approach isabelle hol 
proof builds generic dataflow analysis framework reusable variants bc algorithm discussed section 
coglio argues bc verification algorithm precise reasonable verification algorithms sense accepts bytecode crash defensive virtual machine follow execution paths conditional jumps regardless value condition 
correct bytecode rejected bc algorithm bytecode correctness depends additional knowledge values just types booleans integers object manipulated code 

widening model checking approach bc verification algorithm model checking described section impractical runs time exponential number conditional way branches method 
consider control flow joint depicted left part 
algorithms verify instructions join point assumption lub bc algorithm verifies twice assumption assumption consider control flow graph shown right part 
comprises conditional constructs bv tex register types 


control flow joins model checking approach rn rn sequence assigning different type registers 
rn 
causes instructions conditional verified times different register types 
way improve efficiency bc algorithm reduce number states need explored judicious application widening steps transitions pc pc replaced pc pc error state err reachable bytecode remains safe 
widening step reduces total number states explored judiciously choose widened state pc reachable 
formally define subtyping relation states err states widening scheme function sets states sets states state exists state note property implies err err 
bytecode verification widened model checking computes fixpoint iteration smallest state set containing initial state bytecode passes verification err easy show bytecode accepted widened model checking algorithm accepted bc model checking algorithm type safe runtime 
proof appendix proposed construct interesting examples widening functions equivalence relation determining states merged single state merging function sets equivalent states states 
bv tex widening function defined 

partition equivalence classes relation 
function defined widening function writing equivalence class 
monovariant dataflow analysis section trivial instance widened model checking widening function merges stack register types associated program point upper bound 
precisely widening function constructed described equivalence relations merging functions 
equivalence relation defined err err 
merging function defined err err 
sn rn lub 
sn lub 
rn 
sn 
sn rn err interesting widening function described 
similar ideas implemented frey coglio 
propose merge stack register types program point types agree return addresses contain retaddr types registers stack slots may differ non retaddr types 
precisely say types agree return addresses equal retaddr type 
register types agree return addresses types assign register agree 
stack types agree return addresses size types contain agree pointwise 
define equivalence relation err err agree return addresses agree return addresses 
merging function defined err err 
sn rn lub 
sn lub 
rn construction stack types different heights 
coglio frey verification algorithm corresponds widened model checking widening function induced relation merging function 
bv tex bytecode contains subroutines stack register types contain return address types agree return addresses case algorithm essentially reduces standard efficient monovariant dataflow analysis presence subroutines sufficient ensured return address types prevent type merging inside subroutines 
example analysis jsr causes states pc explored retaddr top stack type type register retaddr top stack type int type register 
states disagree return addresses top element stack type merged 
causes astore analyzed twice resulting states mergeable retaddr register retaddr register 
instructions subroutine body independent sets stack register types needed verify subroutine calls sufficient precision 
appendix prove algorithm accepts exactly bytecode bc algorithm 
terms turns additional merging type information performed algorithm degrade precision analysis 
consequence continuity property type level interpreter respect upper bounds 
property 
continuity 
assume stack types agree return addresses register types agree return addresses 
assume 
lub lub lub lub 

bytecode verification small computers java virtual machines run personal computers workstations variety embedded computers personal digital assistants mobile phones smart cards 
extending java minor difference monovariant dataflow analysis fails stack height differs paths reach program point algorithm fail immediately case analyzes join point successors polyvariant manner different stack height 
rate subroutine free bytecode passes monovariant verification passes algorithm state considered program point 
bv tex model safe post issuance code downloading devices requires bytecode verification performed embedded system 
bytecode verification expensive process exceed resources processing power working memory space small embedded systems 
instance typical java card java enabled smart card bytes working memory kilobytes persistent memory bit microprocessor approximately times slower personal computer 
small computing devices conventional bytecode verification algorithm sun polyvariant verifiers described run working memory amount ram available small store stack register types inferred bytecode verification 
avenue persistent memory ram hold data structures verifier 
long believed solution impractical data structures change rapidly bytecode verification resulting excessive writing times wear persistent memory 
deville develops specially designed encodings types memory representations verification data alleviate issue suggests approach feasible 
avenue fitting bytecode verifier small computing device design new verification algorithms run tiny amounts working memory 
discuss algorithms 

lightweight bytecode verification certificates inspired necula lee proof carrying code rose rose propose split bytecode verification phases code producer computes stack register types branch targets transmit called certificates bytecode embedded system simply checks code typed respect types certificates inferring types :10.1.1.106.647
terms embedded system longer solves iteratively dataflow equations characterizing correct bytecode simply checks single linear pass bytecode types provided code certificates solution equations 
benefits approach twofold 
checking solution faster inferring avoid cost fixpoint iter persistent memory eeprom flash distinct working memory ram writes take times longer writes 
persistent memory allows limited number writes memory location 
bv tex ation 
speeds verification extent second certificates read modified verification 
stored persistent memory risking wear memory space repeated rewriting data verification 
practical limitation approach certificates relatively large size code annotate 
certificates stored persistent memory exceed available memory space 
rose addresses issue certificate size noticing type information certain branch targets omitted certificate long type information correctly computed verification algorithm linear scan bytecode 
hybrid verification strategy reduces size certificate cost increased working memory requirements store inferred type information branch targets described certificate 
lightweight bytecode verification kvm sun embedded variants jvm 
formalized proved sound complete klein nipkow isabelle hol prover 
presentations differ treatment subroutines 
rose presentation deals monovariant verification handle subroutines 
kvm implementation follows approach relies subroutine expansion verification part certificate generation phase 
klein nipkow formalization applicable monovariant verification verification algorithm expressed dataflow equations including polyvariant algorithms section 

card verification card code transformation java card bytecode verifier described attacks memory problem angle 
standard bytecode verifiers solves dataflow equations fixpoint iteration 
reduce memory requirements global register type shared control points method 
terms solution infers register type method 
similar reasons requires expression stack empty branch instruction branch target instruction 
speedup important expect experiments show fixpoint usually reached examining instruction twice 
bv tex extra restrictions bytecode verification done space sun algorithm number branch targets 
practice memory requirements small data structures fit comfortably ram smart card 
drawback approach register initialization longer checked statically replaced run time initialization registers safe value typically value null method entry 
drawback extra restrictions imposed card verifier cause perfectly legal bytecode passes sun verifier rejected 
address issue verifier relies card transformation performed bytecode applet transforms legal bytecode passes sun verifier equivalent bytecode passes card verifier 
card transformations include stack normalizations branches register reallocation graph coloring described 
transformations increase size code number registers method 
experience shows increases minimal typical java card code increase code size increase registers negligible 
card code transformation phase plays role similar adding certificates rose rose approach card processing adds information applet facilitate card verification 
card code transformer embeds directly information inside code code transformations storing separate certificates 
size extra information smaller vs 

perspectives java bytecode verification researched technique 
considerable body formal reviewed led precise understanding bytecode verification guarantees number new verification algorithms sun original implementation cover large part precision cost spectrum 
largely open question bytecode verification go basic type safety initialization properties statically establish advanced properties applets resource usage bounding amount memory allocated reactiveness bounding running time applet interactions bv tex outside world 
controlling resource usage especially important java card applets java card guarantee presence garbage collector applets supposed allocate objects need installation time run constant space 
properties interest include access control information flow 
currently java security manager performs access control checks dynamically stack inspection 
various static analyses program transformations proposed perform checks statically 
java card world inter applet communications shared objects raises delicate security issues applies model checking technology problem 
information flow applet leak confidential information access property essentially impossible check dynamically type systems proposed enforce statically 
security sandbox model relies bytecode verification proper implementation api applet 
majority known applet attacks exploit bugs api type safe way breaking type safety bugs verifier 
verification api promising area application formal methods 
alessandro coglio anonymous referees helpful comments suggestions improvements 

abadi banerjee heintze riecke core calculus dependency 
th symposium principles programming languages 
pp 


basin friedrich bytecode verification model checking 
journal automated reasoning 
special issue bytecode verification issue 

bertot formalizing jvml verifier initialization theorem prover 
proc 
computer aided verification cav vol 
lecture notes computer science 
pp 


vers un de bytecode java 
seminar ecole normale sup rieure paris october nd 

hostile activex control demonstrated 
risks forum 

chen java card technology smart cards architecture programmer guide java series 
addison wesley 
bv tex 
ake model checking java card applications 
smart card research advanced applications conference 

coglio simple verification technique complex java bytecode subroutines 
th ecoop workshop formal techniques java programs 
extended version available kestrel institute technical report 

coglio improving official specification java bytecode verification 
concurrency computation practice experience 

coglio goldberg qian provably correct implementation jvm bytecode verifier 
oopsla workshop formal underpinnings java 

cohen defensive java virtual machine specification 
technical report computational logic 
deville building impossible verifier java card 
usenix workshop industrial experiences systems software 

freund mitchell type system java bytecode language verifier 
journal automated reasoning 
special issue bytecode verification issue 

freund mitchell formal framework java bytecode language verifier 
object oriented programming systems languages applications 
pp 


freund mitchell type system object initialization java bytecode language 
acm transactions programming languages systems 

frey terminal verifier jeff files 
personal communication 

goldberg specification java loading bytecode verification 
acm conference computer communications security 
pp 


gong inside java platform security architecture api design implementation java series 
addison wesley 

gosling java intermediate bytecodes 
proc 
acm sigplan workshop intermediate representations 
pp 


hagiya new method dataflow analysis java virtual machine subroutines 
levi ed sas vol 
lecture notes computer science 
pp 


hartel moreau formalizing safety java java virtual machine java card 
acm computing surveys 

heintze riecke slam calculus programming secrecy integrity 
th symposium principles programming languages 
pp 


framework bytecode verifiers application intra procedural continuations 
research report inria 

huisman jacobs van den berg case study class library verification java vector class 
software tools technology transfer 

jensen le tayer thorn verification control flow security properties 
ieee symposium security privacy 

klein verified java bytecode verification 
ph thesis technische universit nchen 
bv tex 
klein nipkow verified lightweight bytecode verification 
concurrency computation practice experience 

klein nipkow verified bytecode verifiers 
theoretical computer science appear 

klein verified bytecode subroutines 
journal automated reasoning 
special issue bytecode verification issue 

knoblock rehof type elaboration subtype completion java bytecode 
th symposium principles programming languages 
pp 


leroy bytecode verification java smart card 
software practice experience 

leroy security properties typed applets 
vitek jensen eds secure internet programming security issues mobile distributed objects vol 
lecture notes computer science 
springer verlag pp 


lindholm yellin java virtual machine specification java series 
addison wesley 
second edition 

mcgraw felten securing java 
john wiley sons 

muchnick advanced compiler design implementation 
morgan kaufmann 

necula proof carrying code 
th symposium principles programming languages 
pp 


nielson nielson hankin principles program analysis 
springer verlag 

nipkow verified bytecode verifiers 
foundations software science computation structures fossacs vol 
lecture notes computer science 
pp 


callahan simple comprehensive type system java bytecode subroutines 
th symposium principles programming languages 
pp 


posegga vogt java bytecode verification model checking 
workshop fundamental underpinnings java 

pottier simonet information flow inference ml 
th symposium principles programming languages 
pp 


pottier smith systematic approach static access control 
sands ed proceedings th european symposium programming esop vol 
lecture notes computer science 
pp 


proving soundness java bytecode verifier specification isabelle hol 
cleaveland ed tacas vol 
lecture notes computer science 
pp 


qian formal specification java virtual machine instructions objects methods subroutines 
alves foss ed formal syntax semantics java vol 
lecture notes computer science 
springer verlag 

qian standard fixpoint iteration java bytecode verification 
acm transactions programming languages systems 

rose de code octet de la machine java formalisation implantation 
ph thesis university paris 

rose rose lightweight bytecode verification 
oopsla workshop formal underpinnings java 
bv tex 
schmidt data flow analysis model checking interpretations 
th symposium principles programming languages 
pp 


st rk schmid rger java java virtual machine 
springer verlag 

st rk schmid completeness bytecode verifier certifying java jvm compiler 
journal automated reasoning 
special issue bytecode verification issue 

stata abadi type system java bytecode subroutines 
acm transactions programming languages systems 

sun microsystems java platform micro edition technology creating mobile devices 
white java sun com products wp pdf 

trusted logic card bytecode verifier java card 
distributed part sun java card development kit 

vigna 
ed mobile agents security vol 
lecture notes computer science 
springer verlag 

volpano smith type approach program security 
proceedings tapsoft colloquium formal approaches software engineering vol 
lecture notes computer science 
pp 


volpano smith irvine sound type system secure flow analysis 
journal computer security 

walker type system expressive security policies 
th symposium principles programming languages 
pp 


yellin low level security java 
proceedings fourth international world wide web conference 
pp 

appendix correctness widened model checking appendix formally prove bytecode accepted widened model checking algorithm section accepted bc model checking algorithm section type safe runtime 
stands arbitrary widening function 
lemma 
states assume err err 
exists proof 
show err 
assume way contra diction err 
means pc type level interpreter transition instruction instr pc 
hypotheses err pc 
monotonicity property interpreter guarantees bv tex transition instr pc 
err contradiction 
err definition relations implies err err 
write properties hold instr hypothesis err interpreter transition instr state 
result transition 
monotonicity determinacy properties type define level interpreter guarantee 
conclude proof remains show instr suffices show valid successor instruction state 
hypothesis know valid successor instruction state 
instruction ret instruction successors independent stack register types instruction instruction ret retaddr 
err case retaddr type 

entails retaddr 
successor instruction state 
expected result follows 
write mean exists lemma 
sets states err 

proof 
relation transitive hypothesis widening function 
suffices show 
choose 
definition cases holds 
exists follows subtype element 

element hypothesis err err err 
applying lemma obtain obtained transition element bv tex result holds expected result follows 
theorem 
smallest set closed containing smallest set closed containing 
err implies err terms bytecode passes widened model checking algorithm passes bc model checking algorithm 
proof 
write nc nw 
show induction base case trivial 
inductive case follows lemma noticing err implies err follows assume way contradiction err exists err 
definition relation states implies err contradicts hypothesis err err claimed 
relative completeness algorithm appendix prove verification algorithm defined section instance widened model checking complete respect bc model checking algorithm programs accepted algorithm accepted 
combined theorem result shows algorithm accepts exactly programs bc algorithm 
recall definitions describe algorithm equivalence relation defined err err iff agree return addresses agree return addresses 
merging function defined err err 
sn rn lub 
sn lub 
rn 
widening function defined 

partition equivalence classes 
key lemma shows type level machine performs parallel transitions set equivalent states single state obtained merging equivalent states 
particular err reachable equivalent states reachable merged state 
write states reachable transition state 

bv tex lemma 
non empty set equivalent states err err 

proof 
write 
sn rn si agree return addresses ri agree return addresses 
err exists instr si ri 
continuity property instr lub 
sn lub 
rn lub 
lub 

determinacy property transitions initial states 
consider successors instruction instr ret instruction successors 
pk depend instr independent stack register types 
instr ret instruction successor instruction determined retaddr type register type instruction 
register types considered proof 
rn lub 
rn agree return addresses 
means assign retaddr type register successor ret instruction register types just case non ret instruction follows discussion successors set states reachable transition exactly cartesian product set possible successors 
pk set stack register types 
similarly pi 

pi lub 
lub 

notice stack register types 

agree return addresses instr jsr instruction retaddr type state comes matching retaddr type state instr jsr instruction state contains additional retaddr type top stack type stack types 
pi lub 
lub 


follows expected 
prove number algebraic properties functions 
lemma 
non empty set equivalent states 
equivalent 
bv tex proof 
show types agree return addresses lub agrees return addresses 
case lub result obvious retaddr types case lub retaddr type agrees 
previous result extends trivially upper bound stack types register types 
non empty set equivalent states 
err 
sn rn 
case err expected result obviously holds 
case lub 
sn lub 
rn 
lub 
sn si agree return addresses lub 
rn ri agree return addresses 

lemma 

non empty sets states states 
equivalent 



proof 
cases consider 
case err 
case expected equality trivially holds 
second case err belong write si ri 
si ni ri ni si ri 
si ri hypothesis elements equivalent elements lemma equivalent elements equivalent elements transitivity follows 
holds 
si ri 
expected result follows associativity commutativity lub operation 
lemma 


sets states 
proof 

ak partition equivalence classes 
aj 
aj partition equivalence classes 

aj 

aj bv tex consider elements set aj aj 
lemma equivalent element aj element aj 

ak disjoint equivalence classes 
aj aj equivalence classes relation sets bj aj 
aj 
lemma bj aj 
aj aj follows 

bk expected result 

ak 
lemma 
set states err 

proof 

partition equivalence classes 
definition 


applying lemma obtain 


follows hypothesis err err err 
lemma 
follows 



partition equivalence classes 

expected result follows 
theorem 
smallest set closed containing smallest set closed containing 
err implies err terms bytecode passes bc algorithm passes algorithm 
bv tex proof 
write nc nw 
assume err implies err show induction 
base case trivial identity function singleton sets 
inductive case assume 

note err applying lemma follows desired 
construction widening function set states err err 
err err follows err bv tex 
