object oriented composition klaus ostermann siemens ag corporate technology se munich germany klaus ostermann siemens de object oriented languages come pre defined composition mechanisms inheritance object composition delegation characterized certain set composition properties individually exist abstractions language level 
non standard composition semantics needed mixture composition properties provided standard composition mechanisms 
non standard semantics simulated complicated architectures sensitive requirement changes easily adapted invalidating existing clients 
propose compound new abstraction object allows provide explicit linguistic means expressing combining individual composition properties demand 
model statically typed allows programmer express seamless spectrum composition semantics interval object composition inheritance 
resulting programs better understandable due explicitly expressed design decisions sensitive requirement changes 

basic composition mechanisms object oriented languages inheritance object composition different concepts characterized different set properties 
properties inheritance discussed works 
relationship inheritance object composition carefully studied 
mixture composition properties supported mechanism fixed language implementation individual properties exist abstractions language level 
non standard composition semantics needed mixture properties appear proceedings oopsla 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copyrights components owned acm honored 
abstracting credit permitted 
copy republish post servers redistribute lists requires prior specific permission fee 
mira mezini darmstadt university technology darmstadt germany mezini informatik tu darmstadt de provided standard techniques 
indicate absence linguistic means expressing combining individual composition properties ondemand non standard semantics simulated complicated architectures sensitive requirement changes easily adapted invalidating existing clients 
need combine properties inheritance object composition driving force families non standard approaches object oriented composition 
side delegation enriches object composition inheritance properties 
please note contrast frequent term delegation synonym forwarding semantics stands dynamic object inheritance 
pure delegation models objects created cloning prototype objects objects may inherit objects called parents 
models object composition delegation class inheritance 
prominent programming language family self 
delegation techniques integrated statically typed class languages provide classbased inheritance delegation object composition 
side mixin models approach goal combining inheritance object composition properties opposite direction enriching inheritance object composition properties ability statically dynamically apply subclass base classes :10.1.1.156.4510:10.1.1.23.8118
standard composition mechanisms approaches provide abstractions explicitly expressing individual composition properties allow combine properties demand 
distinguish properties describe relation holds modules classes objects composed denotes base module denotes modification module denotes composition 

overriding ability modification override methods defined base 
definitions hide definitions name 
ignore redefinitions 
transparent redirection ability overriding redirection acquisition subtyping polymorphic inheritance object composition dynamically delegation dynamically mixin inheritance statically table composition properties supported standard mechanisms redirect denote composition 

acquisition ability definitions local methods transparent forwarding services 

subtyping promise fulfills contract specified expected 

polymorphism ability dynamically statically apply subtype table shows set properties discuss row indexes 
columns indexed existing objectoriented composition mechanisms 
key idea approach separation independent applicability notions providing explicit linguistic means express 
allows programmer build seamless spectrum composition semantics interval object composition inheritance depending requirements hand making object oriented programs understandable due explicitly expressed design decisions sensitive requirement changes due seamless transition composition semantics 
remainder organized follows 
sec 
discusses examples non standard combinations composition properties desirable 
sec 
presents basic concepts model 
model evaluated sec 

sec 
discusses advanced issues related static type safety 
related discussed sec 

sec 
summarizes suggests areas 

motivation section consider composition scenarios non standard combinations composition properties sense 
cases discuss various designs achieve desired composition semantics 
please note section proposing ultimate designs scenarios 
reader eventually come equivalent superior designs scenarios 
essential purpose chapter main message person account src account sop dest class diagram account example want convey cases sophisticated design needed explicitly state important conceptual relationships involved abstractions different designs needed different combinations composition properties 
composition scenario account example consider application banking domain persons companies accounts standing orders 
relation persons companies accounts usually 
example want account dedicated role owner 
example want dedicated pay account dedicated rental account 
possible choose appropriate account specific transfers automatically 
simplified example person main account rental pay account 
different kinds accounts exist accounts subject frequent changes runtime 
particular account may shared persons may account pay account rental account may identical 
class sop standing order processing registration execution standing orders 
execution multiple standing orders identical source target accounts summarized single transfer 
class diagram problem shown fig 

information pay order gets account objects involved person creates registers sop 
design simple easy understand 
problem account person changes previously registered standing order executed respect outdated account 
design fig 
update account person manually 
definitely undesirable 
person object ideally want account compound indirect account passed sop account 
words want kind redirect semantics meaning account write int write int ba int ba length write ba outputstream write int write int stream write int stream write write int ba stream write ba write int write int write int write int decorator design output streams late bound current context object referred account gets evaluated 
due lack compound standard objectoriented languages change architecture design simulate 
possible solutions discussed 
decorator contains account object forwards calls passed sop account object 
base object decorator account changed need manual updates 
identity test sop fails persons share account sop compares non identical decorators base object 
subtleties architecture uses decorator pattern composition highlighted scenario 
second approach change sop class accepts account objects interface single method 
person implement interface 
difficult case different accounts 
reason create separate subclass complexity main drawback approach modify class desirable possible case class purchased part banking component library 
limitation proposal works level redirection 
example want register standing order transfers money account person current spouse spouses subject frequent changes days 
common approach avoid coupling java classes probably implemented inner classes 
write outputstream int write outputstream int ba int ba length write ba outputstream write outputstream int write outputstream int stream write outputstream int stream write write outputstream int ba stream write ba write outputstream int write outputstream int write outputstream int write outputstream int simulation transparent redirection sender request receiver chain responsibility pattern 
applied example mean account optional successor account new accounts appended previous account 
calls account forwarded current account chain 
considerable complexity approach compatible sharing accounts 
possible solution sop class observer persons companies notified account exchanged 
easy see result design complicated previous ones 
composition scenario stream example streams exist multiple variations different stream features typically implemented decorators basic stream class see java package set desired features stream instance choosen dynamically 
typical decorator design output streams shown fig 

decorator compose basic outputstream functionality optional filtering features want achieve composition properties subtyping resulting composition base component acquisition base behavior filtering functionality dynamic polymorphism certain filtering applicable subtype outputstream overriding methods changed extended functionality 
decorator pattern realizes dynamic polymorphism composition means object composition subtype polymorphism 
acquisition overriding achieved implementing base component interface means forwarding methods resp 
decorator specific methods 
decorator subtype component inheritance 
simulation composition properties number shortcomings textjustifier simple doc aggregate tree doall void void boolean current object void void test boolean action void action test action structure text tree iterator implementation decorator class tedious error prone due manual simulation acquisition feature 
addition suffers syntactic fragile base class problem interface base component changes corresponding forwarding methods added deleted 
transparent redirection 
means method calls base component dispatched overridden methods decorators local implementations 
consequence base object passes objects passes decorator 
situations opposite effect desirable 
anomaly known self problem broken delegation 
manual simulation transparent redirection complex leads design different original decorator pattern base object needs way knowing decorators 
alternative store back decorator base prohibit multiple decorators base object 
solution different design pass decorator base object method call 
corresponding design illustrated fig 

base class may define state 
decorators inherit state unnecessary heavy 
merely subtype relationship decorator base component needed decorator enforced inherit state due inheritance subtyping 
usually problem usage base decorators anticipated writing time 
predefined library class decorated may problem 
composition scenario textjustifier example envisage textjustifier command class text processing system justifies paragraphs document paragraphs 
document elements justified stored recursive object structure shown diagram left hand side fig 
realistic situation apply visitor pattern connect textjustifier textjustifier action void test boolean simple doc aggregate tree doall void void boolean current object void void test boolean action void usage iterator inheritance performing document justification text needs iterate document structure 
assume implemented tree iterator class shown right hand side fig 

class encodes breadth iteration strategy recursive object structures 
overriding action test methods specific purpose 
iterator class provides number iteration mechanisms applying action elements satisfy test doall satisfy test 
assume design shown fig 
text justification iteration functionality composed means inheritance just satisfying requirements system early stage development process 
iteration stage realize inheritance composition semantics want 
want textjustifier subtype anymore textjustifier special kind iterator 
addition acquisition semantics comes inheritance desired anymore methods pollute interface textjustifier complex anyway development 
second initial requirements slightly changed possible determine iteration strategy textjustifier runtime 
purpose subclasses preorder postorder implemented refine default breadth semantics overriding methods 
question compose text fig 
iteration hierarchy set composition properties satisfied 
feasible solution schematically fig 

textjustifier instance variable type assigned instance 
defined subclasses corresponding library classes redundantly implement test action methods justification purposes 
quite reasonable assume test action performed step iteration needs infor ment hierarchy 
sake simplicity assume case example 
problems discuss apply visitor design 
design assume implements tree textjustifier void simple doc 
current 
context context action test aggregate tree doall void void boolean current object void void test boolean action void action preorder postorder action test test action action test initial design dynamic composition mation text object provided context textjustifier 
obviously design fig 
different predecessor design fig 

different mixtures features composing pieces functionality realized different designs 
furthermore design complex design fig 
reflect conceptual relationships entities 
additional classes associations introduced classes contain duplicated implementations action test 
point clear initial iterator design unsatisfactory leads code duplication fig 

better choose sophisticated design iterator classes right start iterators command class shown fig 

solve problem need complex design fig 
conceptual relationship textjustifier simple initial design fig 
design fig sufficient dynamic composition configure relation textjustifier properties tab 

problem statement summary far 
cases desired composition semantics achieved 
result highly unsatisfactory 

severe problem architectures ended completely different depending desired mixture composition properties 
second design gets complex soon composition required deviates semantics standard composition mechanisms directly supported linguistic means 
illustrated composition scenario different programmers may come different architectures textjustifier void doc simple document action object test object context action object test object step aggregate doall current preorder postorder step action current current test step action current current sophisticated design dynamic composition composition semantics 
change composition features require switching architecture 
tough challenge programmer 
affects understandability maintenance object oriented programs important knowledge encoded composition semantics explicitly expressed designs simulate non standard semantics 
general obvious separate part architecture directly involved encoding application logic part architecture serves infrastructure encoding non standard composition semantics 
consequence hard guess looking design architectures different merely encode different composition semantics different architectures implement application logic differ way encode composition semantics 
frequency changes composition features documented refactorings replace delegation inheritance replace inheritance delegation hide delegate remove middle man 
terminology refactorings seen moving architecture certain mixture composition properties mixture composition features better fits requirements current state development process 
refactoring recognizes transformations trivial aims aiding programmers performing describing process systematic way partly automating means refactoring browsers 
highly positive echo refactoring object oriented community especially practice everyday programming supports claim need different architectures express different composition semantics programmer life harder 
fowler uses term delegation sense forwarding follow path approaching problem motivated observation identifying describing common refactorings solve core problem change fact different architectures different composition semantics needed needs switch architecture order react requirement changes 
consequently put emphasis tackling problem roots language design 
claim identifying describing refactorings strive language mechanisms refactorings obsolete explicit language 
requirement relevant component setting refactoring steps adjust clients call new server longer feasible 

compound model section introduces basic notions model extension java programming language 
concepts easily applicable statically typed oo languages 
introduced feature corresponds row table represents step forward seamless transition object inheritance composition semantics 
field methods overriding explain operational semantics model notion field methods 
field method method pertains specific field 
syntactically affiliation method field expressed prefixing method name field name separator 
class field type thought implicitly containing method named public method method named signature visibility identical visibility default implementation simply forwards object referred denoted implementation special pseudo variable field 
similar pseudo variable super denoting overridden method overriding method 
invocation object referred thought dispatched corresponding implicit field method 
illustration recall iterator example sec 

implicit field methods written code textjustifier look fig 
call doall justify thought calling implicitly available field method named doall 
know field methods implementation class impact semantics class 
textjustifier implementation fig 
semantically equivalent implementation contain implicit field method 
decisive point implicit methods replaced explicitly context section reader think methods implemented empty 
class textjustifier private public void justify doall 
implicitly available field methods private void doall field doall private void field private void field private void action item field action private boolean test item return field test implicitly available field methods implicit field methods textjustifier class textjustifier private private void doall 
public void justify doall explicit field methods textjustifier available methods 
example order implement action undertaken doall called textjustifier programmer textjustifier implement explicit field method called doall encoding desired behavior shown fig 

please note fig 
illustration explicit field methods final solution textjustifier problem 
leaving section reader recall introduced implicit methods means describe operational semantics model independently specific implementation 
field redirection compound central mechanism model notion compound cr 
contrast primitive binding cr object absolute relative 
gain insight usefulness crs reconsider account example sec 

solve problem discussed able express person account meaning account context person passed standing order processing unit 
crs come play 
cr instvar class created means instvar 
illustrate semantics consider class fig 
method returns compound account please note java object typed instance variables 
class person account account account return account account return account void account account class client public static void main string args person jack 
account new account ubs account new account deutsche bank jack account jack account jack refer ubs account jack refers ubs account refers db account illustration compound stance variable person returns primitive account instance variable person 
effect cr returned refers current value account person object 
call statement client main fig 
changes jack account refer jack current deutsche bank account refer old ubs account 
fig 
fig 
schematically show state changing jack account 
just object methods differ functions sense different calls may return different values depending state method owner receiver cr different primitive sense evaluation cr result different values depending state cr owner object 
crs different pointers pointers pointers pointer explicitly specifies dimension indirection number 
pointer different dimensions example account account compatible substitutable crs hand transparent replacement usual generally known cr levels indirection hidden cr 
way crs similar symbolic links unix file system 
conversion possible example semantics different indirection changed assignment points previous account 
symbolic link may refer file symbolic link 
objects directories create symbolic account link sop directory refers account link jack directory 
cr defined relatively primitive recursively cr 
cr may general induce path object 
example class person return cr spouse person 
method cr called obtain new cr path spouse account 
general cr oid sequence field names vn 
cr vn induces corresponding path objects oi oi vi details subtleties creating object path cr discussed section 
path created directly incrementally result creating cr cr 
regard usual special case cr length 
relative element oi call oi predecessor oi successor 
furthermore head tail cr 
please note cr immutable corresponding object path may change course time due changing instance variable path 
just statically typed language cr type compared crs methods invoked 
define static type cr static type tail 
straightforward equally define dynamic type cr 
decided call dynamic type tail temporary type cr type may change side effect field update 
downcasts temporary type cr disallowed model typed temporary type may invalid field update 
issue discussed section 
consider identity semantics context compound 
question conditions compound vn wm corresponding object paths pm considered identical 
possible answers head identity tail identity pm 
path identity oi pi head identity awkward considered identical general type static type cr static type tail 
example crs account resp 
address person considered identical 
path identity hand restrictive 
recall account example 
jack sally share main jack account ubs state changing jack account db account want jack account cr jack account identical sally account cr sally account 
tail identity reasonable identity semantics 
reason define crs identical tails identical defined 
consider method call semantics cr 
method implemented object called cr value implicit parameter cr execution method object passes object passes cr method called 
convenience add syntactic sugar method call abbreviated 
illustration reconsider textjustifier implementation fig 

truly incremental modification mean implement test action methods semantics specific context textjustifier 
question specific iteration step semantics implemented textjustifier action get integrated iteration process performed doall method called instance variable textjustifier 
interplay field methods crs relevant 
methods dispatched compound field methods override corresponding methods successive objects 
detail semantics follows 
vn cr object path method static type vn 
furthermore lowest index class oi contains field method vi vn normal method regarded field method empty prefix 
method call dispatched field method vi vn 
implementation fig 
illustrates interplay crs explicit field methods 
main jack account ubs state changing jack account class textjustifier private private void action object 
private boolean test object 
public void justify doall db explicit redirected field methods text textjustifier justify method doall called directly compound 
consequently subsequent calls action test control flow doall dispatched textjustifier action respectively textjustifier test 
implementation fig 
fact text uses customizes completely hidden clients subclasses text 
required overriding methods respect visibility overridden methods textjustifier subtype 
code modification possible choose iteration strategy runtime cf 
subsection simply assigning new iterator object 
implementation fig 
realizes composition textjustifier functionalities supports overriding transparent redirection dynamic polymorphism subtyping acquisition 
far compound aggregated object referred field explicitly created aggregating class containing method call cf 

scope composition features mentioned overriding transparent redirection dynamic polymorphism individual method call explicitly created cr different fields declared rf redirected field private void rf field non redirected field private void field field methods field redirection class textjustifier private redirect private void action 
private boolean test item 
public void justify doall textjustifier field redirection modifier redirect 
implicit field methods field annotated redirect keyword different semantics simply forwarding call field object implicitly create cr field call method created cr 
fig 
shows difference default implementation implicitly available methods redirected field rf non redirected field illustration version textjustifier declared redirect field fig 

field acquisition field acquisition step road object composition inheritance 
orthogonal modifiers acquire modifier annotate field declaration 
intuitive semantics features available field inherent part aggregating class 
class acquired field type implicitly contains method public method method retains signature declared visibility public 
semantics implicit field methods remains non acquired fields provided interface illustration consider example fig 

implement write int write int methods invoked efs instance due declaration instance variable stream acquired field 
acquired implicit methods replaced explicitly programmed methods signature 
sake uniformity order facilitate changing composition semantics means changing modifiers instance variable prefix notation explicitly overriding acquired methods 
illustration consider sample code fig 

class acquires write methods acquired field stream overrides add buffering 
note bos write array call client code fig 
displays buffering ints screen 
fact message buffering single int appears screen suggests class outputstream public void write int system println hello write int public void write int system println hello write int class acquire private outputstream stream new outputstream class client static public void main string args efs new int array efs write hello write int appears efs write array hello write int appears acquired fields overridden write int method implemented invoked point write int method underlying fout stream called times buffer full overridden field method called buffer int array passed parameter 
buffering single int displayed stream redirected field calls field write buffer field write compound stream 
calls write int field write 
escape override 
corresponds broken delegation problem discussed sec 

case desired semantics redirection desired 
buffer full want flush buffer content integers written immediately underlying data sink 
want escape buffering 
cases want calls occurring control flow call overridden acquired method object outer dispatched outer 
field acquisition combined field redirection obtain perfect solution composition requirement 
version fig 
stream declared acquired redirected suffices buffering write int method calls write int write int method automatically redirected buffering method 
important restriction imposed field acquisition allow class field acquisition 
take charge annoying multiple inheritance conflicts 
due class outputstream public void write int 
public void write int size write class acquire private outputstream stream int buffer int current public stream buffer 
public void stream write int system println buffering single int 
buffer buffer current field write buffer field write current public void stream write int system println buffering size ints buffer size current size system buffer current size current size field write buffer field write current class client static public void main string args fout new bos new fout int array bos write buffering single int 
appears screen 
assume buffer full point bos write array buffering ints 
appears screen overriding acquired fields class acquire redirect private outputstream stream public void stream write int buffering field write overriding redirecting acquired fields fact overriding redirection multiple fields combine multiple classes means organizing acquisition chain grave limitation 
second restriction need 
due subtype polymorphism instance subtype outputstream may assigned stream instance variable 
subtype may contain methods available outputstream 
methods overridden lead unexpected unsound results result unexpected author overriding method know existence semantics overridden methods 
result unsound overriding method may signature compatible signature overridden method different return type see 
reason restriction field method overrides method defined field type defined static type field type 
addition acquire feature model enriched range composition semantics classes programmer express 
isolation acquire enables transparently forward services needs order satisfy request external client 
hand combining redirect acquire yields mechanism incremental modification mimics code reuse provided inheritance delegation 
subtyping thing missing road inheritance delegation composition field acquisition imply subtyping 
class explicitly declare subtype number types clause 
declaring class subtype type requires implement methods defined 
contrast java implements clause model interfaces classes may appear right hand side clause declaring class subtype class means implements interface mean implementation automatically realization corresponding methods possible traditional inheritance extends 
class outputstream 
class extends outputstream 
class outputstream acquire redirect protected outputstream stream class extends public void stream write buffering 
field write class extends 
outputstream model automatically acquire state method implementations behavior defined desired declaring field type modifiers acquire redirect 
important step better separation types classes 
decoupling subtype declaration implementation reuse solves drawback decorator approach explained section 
illustration complete implementation stream example fig 
model fig 

compare simulation redirect semantics fig 

field navigation object referred field represents facet visible clients fact explicit declaration field relying presence appropriate getter methods 
serving purpose field navigable annotating navigable modifier 
example annotate account field person navigable shown 
allows clients directly navigate part object retrieving compound part 
illustrated having client person object retrieve cr account store technically declaration field navigable seen short cut corresponding getter methods discussed 
class person private navigable account account person 
account account note declaring field navigable imply clients directly change field 
possibility navigate field part class interface similar getter method returns current value field 
navigable composition semantic flavor discourages supports breaking encapsulation 
exporting cr instance variable external clients part interface class simulated declaring redirect field public 
breaks encapsulation clients freely change value 
possible navigable 
inverse navigation operation provided cr reduction operator access previous objects object path cr 
reduction atype compound vn creates new compound vn 
reduction succeeds type shortened compound static type vn variable subtype atype 
length source path primitive created 
statically known account compound person cr reduction checked runtime 
reduction operation way similar type downcasts languages java 
account example reduce compound account person person 
account account person person ok checked runtime true 
evaluation model having introduced individual steps road object composition inheritance time show problems discussed sec 
addressed model 
key addressing problems availability rich linguistic means express variety composition flavors simply decorating object composition properties 
support discussion fig 
introduces graphical notations relevant composition flavors classes expressed model please note notations address overriding model overriding available means field methods need explicitly turned 
start composition flavor middle road object composition inheritance 
composition flavor shares inheritance overriding late binding 
available object composition 
side flavor shares object composition dynamic polymorphism lack acquisition subtyping 
features inseparable inheritance delegation 
discussion textjustifier example sec 
indicated mixture features needed lack linguistic means express forces programmer object oriented language simulate semantics means complex unclear architectures fragile respect requirement changes 
previous section modeled composition scenario model 
implementation desired composition semantics textjustifier hierarchy simple code list intended cover possible combinations composition features relevant evaluating model respect issues discussed sec 

object composition object composition redirection object composition acquisition object composition acquisition redirection object composition acquisition redirection subtyping graphical notations different composition flavors fig 
design clear class diagram fig 
simple inheritance design fig 

contrast design cr solution iteration strategies chosen dynamically iteration functionality pollute interface implementation textjustifier conceptual view textjustifier special kind preserved 
features supported architecture object composition fig 

design share complexity designs fig 
fig 

complexity designs simulate non standard composition flavors problems identified sec 

second important problem different composition flavors modeled different architectures 
demonstrate problem avoided model reconsidering text stream example sec 

design fig 
encodes composition redirection overriding dynamic polymorphism 
assume want acquisition 
model simply add acquire modifier declaration 
class diagram fig 
remains replacing current link link fig 

contrary designs fig 
fig 
change textjustifier implement methods interface forwarding methods 
additionally want textjustifier subtype merely replace link link fig 

resulting design encode different composition flavor compared inheritance composition fig 
composition supports dynamic polymorphism textjustifier inherit state 
simple textjustifier test boolean action void doc aggregate tree doall void void boolean current object void void test boolean action void preorder postorder textjustifier compound similar seamless transition composition flavor observed modeled different flavors fig 
fig 
fig 

started flavor closer inheritance composition flavor spectrum object composition acquisition semantics 
added redirection subtyping separate steps 
important feature model superior standard composition models fact class simultaneously reuse adapt functionality classes suffering known multiple inheritance conflicts naming conflicts different methods name inherited 
repeated inheritance diamond inheritance class inherited twice indirectly example subclass subclasses single copy shared copies 
happens methods overridden case 
copy clients see case 
different mechanisms developed cope problems avoiding problem certainly better fixing 
due naming definition field methods prefixing name attribute naming conflicts 
problems related repeated inheritance occur compound induces unique path message dispatch 
question shared replicated parent boils assigning respectively different instances aggregated class corresponding attributes 
bring navigable fields evaluation foster spectrum relationships discussed far 
industrial component models com ccm notion independent interfaces facets component exposes retrieved special navigation methods 
design patterns extension interface extension object propose architectures allow class export multiple unrelated interfaces la com ccm employing inheritance subtyping 
acknowledged authors proposed patterns incur increased design implementation effort navigation infrastructure functional necessary retrieve facets increased client complexity 
critique vein discussion motivation section 
navigable fields elegant approach modeling classes export unrelated interfaces 
class exports interfaces navigable fields 
explicitly declared class interface 
export involves interface bloat interface contain methods exported interfaces 
contrast class java implementing different interfaces 
contrast extension interface extension object patterns feature exporting unrelated interfaces built language integrated static type checking 
relationship exported interfaces facets behavior exporting class explicit exporting class interface 
relationship explicit design extension interface extension object patterns indicated gamma 

advanced issues compound introduced informal way 
section provide details 
particular show model type safe 
type safety threatened subtle combinations compound subtype polymorphism 
section static temporary type cr defined 
argued type casts temporary type cr allowed temporary type may change course time 
enforcement invariant trivial explicit type casts program code 
situations cast cr temporary type consider class field type runtime instance subtype assigned call object 
method overridden 
means execute method actual value cr static type type type corresponding class features introduced called 
casts temporary type cause certain conditions naive algorithm creating object path cr vn oi oi vi fails 
fig 
shows different scenarios lead type errors naive algorithm employed 
scenario algorithm fails new object longer contains field method called 
second instance expects type new value instance scenario cr constitutes execution changed method call stack 
problems occur delegation systems different solutions proposed see overview 
approaches really fit model fields potential targets crs trivially type safe restrictions requiring new value field subtype dynamic type previous object practicable 
dispatch algorithm guarantees static type safety preserving unrestricted programming model 
main idea approach follows cast temporary type cr store current field value cr 
original value current value lead type error 
definition algorithm choose recursive representation cr cr primitive pair parent parent cr field name 
call cr casted temporary type supertype temporary type supertype static type critical cr 
critical cr triple parent stored field value 
please note due recursive construction parent may critical cr 
non critical cr converted critical cr storing current value field conversion think cr passed value takes place cr subject implicit downcast temporary type 
decision current stored field value additional parameter requested type reqt ype defines type expected actual context 
cr ref reqt ype declared type ref 
cv denotes class field defined 
noncritical cr object path created follows ath parent reqt ype ath parent cv tail parent reqt ype tail parent reqt ype tail parent cv additional reqt ype parameter algorithm equivalent non recursive description oi oi vi 
critical case reqt ype parameter comes play tail parent reqt ype tail parent cv instanceof reqt ype tail parent cv induction proof length cr shows algorithm preserves type safety 
suffices proof type object returned tail function subtype reqt ype 
crs length primitive claim holds base 
bs 

store 
store danger danger bs store bs bs bs bs danger 
bs 

bs store danger 

new 
bs 
scenario scenario scenario language cr assumed statically type safe 
ref cr length declared type ref may critical non critical cr 

ref non critical 
ref parent 
reqt ype supertype static type ref ref critical 
induction hypothesis type tail parent cv subtype cv field value ov safely retrieved 
subtyping guarantees object subtype declared type subtype reqt ype 

ref critical 
ref parent induction hypothesis type tail parent cv subtype cv field value ov safely retrieved 
statement guarantees ov returned instance reqt ype 
case returned show subtype reqt ype 
assured rule critical cr created initialized noncritical cr casted temporary type implies assignment ref subtype static type ref 
applied scenarios fig 
means scenario critical call danger dispatched original object path bs 
case scenario bs resp 
bs critical danger call dispatched original object path bs 
shown dispatch algorithm renders model statically type safe 
price paid happens special conditions undesirable complication model invariant calls cr dispatched current object corresponding field hold anymore 
think reason problems scenarios threaten type safety 

danger danger 
bs existence magic triangle type safety expressive power easy semantics 
proposal put emphasis got problems 

related delegation appeared untyped prototype languages 
prominent example category self 
shown table delegation includes composition properties simultaneously applying individual properties independently explicitly supported 
proposals proposed restrain extreme flexibility offered self number related proposals embedding delegation statically typed language 
darwin model combines delegation static inheritance statically typed language 
darwin incorporates limited variant composition property separation delegation inheritance darwin notion consultation terminology corresponds delegation redirection 
generic wrappers support restricted variant delegation assigned wrapper fixed 
terminology corresponds delegation semi dynamic polymorphism parent fixed runtime model expressed declaring corresponding attribute final 
chi emphasize importance able dynamically cast wrapper dynamic type transparency 
model achieved allowing explicit dynamic casts temporary type cr problematic attributes annotated final 
details aspect left scope 
gbeta number dynamic features related delegation 
generic wrappers parents gbeta fixed runtime 
gbeta allows dynamic behavior additions objects preserve object identity example statement anobject adds structure anobject 
approach described 
steyaert de propose variant delegation class anticipate possible extensions order avoid certain encapsulation problems 
compared approaches supporting delegation statically typed language delegation model comes special mixture composition properties possible mixtures 
addition model flexible contrast aforementioned approaches objects single special parent attribute 
model possible override redirect multiple arbitrary attributes 
predicate objects context relationship allow programmer express certain kinds context dependent facets object explicit linguistic means 
composition basic behavior object facets obeys delegation semantics form mixin inheritance 
model shares approaches support dimensional incremental modification vertically means inheritance model context relationship respectively means delegation predicate objects horizontally means advanced form delegation advanced form inheritance supports static dynamic polymorphism property means crs model 
composition flavors axes built individual composition properties explicitly available demand combination 
mixin inheritance enrichment normal inheritance static polymorphism feature tab :10.1.1.156.4510

contrast normal inheritance super pseudo variable subclass bound certain base class subclass defined 
composition stage super statically bound composition specific superclass 
way subclass mixin statically applied base classes 
inheritance enhanced static polymorphism composition flavor supported 
jigsaw improves modularity original inheritance providing suite language operators independently control roles classes play standard languages combination features modification encapsulation name resolution sharing 
class composition semantics core similar standard composition semantics 
motivation undertaking different 
main focus jigsaw fine grain control visibility features individual modules composition allow mixins multiple inheritance encapsulation strong typing combined cohesive manner 
flexible control method dispatch filters attached object complemented ability define different objects called internal external objects supported composition filters approach probably simulate flavors composition semantics expressed model 
important differences models 
composition filters approach lacks static type system 
second different flavors composition semantics need manually implemented different dispatch filters 
turn tedious error prone activity especially internals mixtures composition properties involved 
contrast specification desired semantics declarative model 
third obvious redirection semantics programmed dispatch filters 
notions field methods field navigation share commonality expressions point view notion multiple inheritance allow adapt combine multiple classes suffering multiple inheritance conflicts 
due object class composition approach flexible coping issues sharing duplicating features common parents typical approaches multiple inheritance 

summary showed traditional object oriented composition mechanisms object composition inheritance delegation frequently inappropriate model non standard composition scenarios 
non standard composition semantics simulated complicated architectures sensitive requirement changes easily adapted invalidating existing clients 
unsatisfactory situation due fact combination composition properties supported mechanism fixed language implementation individual properties exist abstractions language level 
proposed compound new powerful abstraction object 
basis able provide explicit linguistic means making individual composition properties available allow programmer express seamless spectrum composition semantics interval object composition inheritance 
model statically type safe object oriented programs understandable due explicitly expressed design decisions sensitive requirement changes 
issues worked omitted due space reasons follows known conflict delegation method header specialization 
second concept classes methods useful object overriding 
statically safe solutions problem proposed 
areas 
fine grained scale object composition inheritance renders common visibility modifiers public protected coarse sophisticated visibility concept desirable 
refined visibility concept may solve en problems described 
interesting area investigate space possible composition property combinations invalid combinations need rejected compile time 
interesting extension cr concept allow crs dictionary entries dictionary keys take roles field names corresponding values role field values 

acknowledgments frank buschmann lutz bernd freisleben stephan herrmann nter anonymous reviewers helpful comments 

aksit bosch bergmans yonezawa 
abstracting object interactions composition filters 
guerraoui nierstrasz editors object distributed programming 
springer 
ancona zucca 
jam smooth extension java mixins 
proceedings ecoop pages 
lncs springer 
arnold gosling 
java programming language 
addison wesley 
chi 
generic wrappers 
proceedings ecoop lncs pages 
springer 
beck fowler 
planning extreme programming 
addison wesley 
box 
essential com 
addison wesley 
bracha cook 
mixin inheritance 
proceedings oopsla ecoop acm sigplan notices pages 
bracha lindstrom 
modularity meets inheritance 
proceedings ieee computer society international conference computer languages pages washington dc april 
ieee computer society 
carr geib 
point view notion multiple inheritance 
proceedings oopsla ecoop pages 
acm sigplan notices vol 

chambers 
predicate classes 
editor proceedings lncs pages 
springer 
ernst 
gbeta language virtual attributes block structure propagating dynamic inheritance 
phd thesis department computer science university aarhus denmark 
flatt krishnamurthi felleisen 
classes mixins 
acm symp 
principles programming languages pages 
fowler 
refactoring improving existing code 
addison wesley 
gamma 
extension object 
martin riehle buschmann editors pattern languages program design pages 
addison wesley 
gamma helm johnson vlissides 
design patterns 
addison wesley 
harrison ossher tarr 
delegation software subject composition 
technical report rc ibm research division watson research center aug 
hauck 
inheritance modeled explicit bindings approach typed inheritance 
proceedings oopsla acm sigplan notices 

type safe delegation run time component adaptation 
guerraoui editor proceedings ecoop lncs 
springer 

dynamic object inheritance subtyping 
phd thesis university bonn institute computer science iii 

prototypical objects implement shared behavior object oriented systems 
proceedings oopsla acm sigplan notices 
mezini 
dynamic object evolution name collisions 
proceedings ecoop lncs pages 
springer 
mezini 
variational object oriented programming classes inheritance 
kluwer academic publisher 
object management group 
corba components final submission 
omg tc document orbos 
ostermann 
object oriented composition analysis proposal 
master thesis universit bonn institut informatik iii 

disciplined inheritance 
proceedings ecoop pages 
cambridge university press 
schmidt stal rohnert buschmann 
pattern oriented software architecture vol 

wiley 
palsberg lieberherr 
evolution object behavior context relations 
garlan editor proceedings th acm symposium foundations software engineering pages 
acm press 
software engineering notes 
steyaert 
marriage object inheritance unwanted children 
editor proceedings ecoop pages 
lncs springer 
sun microsystems 
java sdk documentation 
java sun com se docs index html 
szyperski 
component software object oriented programming 
addison wesley 
taivalsaari 
notion inheritance 
acm computing surveys 
ungar smith 
self power simplicity 
proceedings oopsla acm sigplan notices pages 
