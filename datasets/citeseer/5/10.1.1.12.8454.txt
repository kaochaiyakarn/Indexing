layered architecture uniform version management bernhard westfechtel aachen trondheim conradi trondheim version management key function software ration management scm 
big variety version models realized commercial systems research prototypes 
version models differ respect objects put version control files directories objects organization versions version graphs rs 
multi dimensional version spaces granularity versioning software products rs 
individual components emphasis states rs 
emphasis changes 
change versioning rules version selection uvm uniform version model support architecture scm 
unification approaches uml object oriented modeling assemble concepts having introduced previous systems 
define base model built small number concepts 
specific version models may expressed terms base model 
approach uniform version management distinguished underlying layered architecture 
main stream scm systems version engine completely orthogonal data model representing software objects relationships 
addition introduce version rules bottom layered architecture employ uniform mechanism expressing different version models 
contrasts main stream solution specific version model usually version graphs deeply built system version rules dependent model 
keywords version model version rules software configuration management software architecture software 
software configuration management scm de fined discipline controlling evolution com plex software systems 
lifetime software ob jects requirements definitions designs program source code test data evolve versions differing respect underlying operating system window system included bug fixes change requests 
version management plays central role scm 
versions recorded restored consistency relationships versions different detailed address department computer science iii aachen university technology aachen 
phone fax email bernhard informatik rwth aachen de 
detailed address gate trondheim norway tel fax email bjorn com 
detailed address norwegian university science technology ntnu trondheim norway 
phone fax email conradi idi ntnu objects maintained new versions created rule descriptions 
order support version management appropriate underlying version model required defines data usually objects versioned version tion organization operations retrieving existing versions constructing new versions 
big variety version models proposed 
seminal papers katz feller surveyed state art late 
conducted comprehensive dated survey version models realized commercial systems research prototypes 
study version models scm reveals mutual similarities virtually basic concepts appear 
triggered observation developed uniform version model uvm serves common base :10.1.1.12.7945
uvm realized version engine provides uniform version storage customized specific version mod els 
approach offers benefits supporting definition version models uniform framework uvm abstracts notational differences comparison version models easier 
unification approaches uml object oriented modeling uvm merely concepts having introduced previous systems 
uvm small number fundamental concepts terms wide spectrum version models may expressed 
reason call model uniform unified 
version engine acts reusable core component building scm systems 
respect follows lines extensible database management systems 
important feature uvm consists orthogonality version model data model 
version model independent data model representing software objects relationships 
version engine may equally applied file relational object oriented data 
conventional approaches define version model top data model version data model deeply entangled 
version engine supports rulebased construction configurations software systems 
serves deductive database system appli cation domain version management 
shown deductive capabilities scm systems severely restricted flexible construction consistent configurations rule descriptions urgently needed :10.1.1.45.5819
version engine building scm systems easier 
vendor building scm system may reuse version engine key component obviates necessity building entirely new 
vendor perform customization respect product space application file data version space version graphs 
user directly get touch underlying version engine operate level provide common base mechanisms 
high level layers offering user friendly interfaces placed top version storage 
building layers goes capabilities user 
assume provided vendor designers version engine may provide library predefined version models 
rest structured follows section ii summarize basic definitions rest 
terms definitions state requirements uniform version model section iii 
related compared section iv 
uniform version model uvm sections 
experiences gained uvm implementation described section viii 
brief discussion approach follows section ix 
short section ii 
basic definitions define notions rest 
notions summarized taxonomy 
detailed discussion reader referred 
deltas dimensions evolution directed deltas embedded deltas selective deltas revisions variants version description version space state versioning change versioning version graph grid version set version rules extensional versioning intensional versioning constraints preferences defaults granularity workspace component versioning total versioning product versioning physical virtual fig 

taxonomy version related terms versions versioned items configurations version represents state evolving item term item covers files usually textual file directories objects object oriented databases entities relationships attributes eer databases version characterized pair ps vs ps vs denote state product space point version space respectively 
product space contains items versioned version space arranges versions structures version graphs 
example ps vs may denote contents text file version number version graph respectively 
versioned item item evolves multiple versions maintained repository 
contrast state maintained unversioned item changes done overwriting 
configuration version complex object 
composed versions components 
example configuration software system composed versions requirements definition software architecture program source code deltas versions versioned item share common parts differ respect specific parts 
difference versions called delta 
directed deltas version constructed applying sequence changes base version 
alternatively versions stored overlapping manner common fragments sequences text lines shared 
version points fragments embedded deltas fragments decorated visibilities control expressions determining versions contained selective deltas 
revisions variants type evolution versions classified revisions variants 
sequential versions evolve time dimension called revisions 
created fix bugs perform enhancements 
parallel alternative versions coexisting time called variants 
new revisions supersede old ones variants replace 
concurrently alternative configurations configuration 
state change versioning version defined state evolving item 
version models focus states ver items called state 
case state versioning versions described terms sions variants 
changes provide alternative way characterizing versions 
change models version described terms changes applied possibly empty base line 
changes assigned change identifiers potentially attributes characterize reasons nature change 
way possible trace changes gone version 
version graphs grids represent version space versions item organized version graph 
example rcs clearcase version graphs composed branches variants consists sequence revisions 
alternatively grid may arrange versions dimensional space dimension corre sponds variant selection attribute typically ing boolean enumerated type 
example multidimensional variation may represented way concerning language user dialogues window system operating system dbms extensional intensional versioning versioned item container called version group set versions 
may defined explicitly enumerating members implicitly version predicate 
case version potential virtual item depending actual predicate see 
case extensional versioning defined enumerating members version management extensional versioning supports retrieval previously created versions storage new versions 
create new version external user retrieves checks version vi forms changes retrieved version submits checks changed version new version vi intensional versioning supports flexible automatic construction consistent versions large version space 
term potential versions emphasizes certain version may constructed explicitly 
intensional versioning version set defined legality deciding constraint con versions satisfying constraint con belong version set specific version described selection predicate evd user defined external version description condition holds evd con evd con defined expressions space versioning attributes ai called options uvm 
examples attributes os attribute determine operating system ls attribute denote window system supported 
version rules global constraints preferences defaults intensional versioning driven global version rules may stored versioned database submitted part query 
constraint mandatory rule satisfied 
violation constraint indicates inconsistency vax variant selected ously 
preference optional rule applied may satisfied released module versions preferred 
default weak preference 
default applied unique selection performed latest version main branch version graph may selected default 
preferences defaults may supplement user vd extra attribute bindings going external partially bound vd evd internal fully bound 
rule part versioned database check possibly elaborate initial evd cf 
capabilities deductive databases 
see version rules page :10.1.1.45.5819
granularity seen user versioned items minimal granularity 
user normally selects versions software objects 
coarse grained items treated atomic objects scm system respect identification version selection 
hand scm system may operate finer internal granularity text lines syntactical tokens effectively store compare construct versions software objects 
user point view external granularity distinguish component total product versioning case component versioning versions single components maintained assembled composite configurations 
example rcs maintains versions text files version graph 
relationships version graphs defined version rules selecting configurations 
case total versioning items versioned including composites components 
example clearcase maintains versions files directories 
item version space version graph clearcase 
relationships version spaces may defined rules component versioning versions composites referring versions components 
contrast product versioning establishes total view software product processes entire database 
done arranging versions items uniform global version space 
example global revision number software product rcs file revision numbers 
workspaces transactions perform development maintenance user establish uni version workspace versioned 
workspace provides data form usually files external tools operate editors compilers debuggers 
workspace may set explicit check commands copy data repository typically file system physical workspace 
alternatively scm system may offer virtual workspace virtual file system evd dynamically serves access filter repository accesses called transparent :10.1.1.45.5819
performed user group thereof may embedded transaction 
term transaction refer operative long lasting transactions may associated change requests change sets 
ignore classical short acid transactions completely acid stands consistency isolation durability see 
transaction owns contains part versioned database 
usually arranged trees graphs edges define cooperation paths transactions corresponding data exchange 
iii 
requirements design decisions taxonomy previous section derive set requirements uniform version model called uvm meet 
requirements generic leave degrees freedom designer scm system supporting uniform version model 
determine system archi tecture design decisions particular respect issues di relationship data model version model data model file relational objectoriented defines basic constructs expressing product data 
version model defines identification versions organization operations retrieving existing versions constructing new versions 
data model version model may related follows version model top data model 
case version management seen ordinary database application 
version model represented schema underlying data model aware versioning 
solution adopted pcte 
version model integrated data model 
data model offers constructs defining versioned object types 
furthermore query language aware version ing 
extra adele follow approach 
data model top version model 
case version model completely orthogonal data model combined data model eer object oriented simply files 
solution realized epos ice 
requirement generality uvm general respect product space version space put restrictions items versioned way version spaces organized 
requirement deltas uvm employ deltas store versions efficiently compare operations combine new versions operations 
requirement dimensions evolution uvm support revisions variants 
requirement version description uvm version describable state change way 
requirement version space representation version space versioned item may represented version graph grid 
requirement version set definition uvm support extensional intensional requirement version rules intensional versioning uvm offer version rules order represent internal constraints external version descriptions 
requirement selection granularity user point view version selection may performed different levels granularity products subsystems components 
requirement workspace management uvm provide means establish workspace users perform help external tools 
fig 

requirements uniform version model selection delta representation previous section introduced different kinds deltas directed embedded selective ones 
successfully di deltas rcs embedded deltas poem selective deltas dsee successor clearcase 
furthermore delta representation version model implemented top 
example change versioning implemented pie help directed deltas epos ice employ selective deltas 
definition basic versioning concepts term basic concepts refers fundamental elements version model grounded 
higher level concepts built top basic concepts 
choice basic concepts varies significantly system system 
example aide de camp single basic concept change 
contrast clearcase relies version graphs changes may realized top clearcase 
considers revisions variants orthogonal concepts represented version graphs clearcase 
relationship extensional intensional versioning extensional intensional versioning may combined follows intensional versioning top extensional versioning 
realized composition model inten defined configurations composed extensionally versioned components 
extensional versioning top intensional versioning 
alternatively may support intensional versioning bottom allowing construction conceivable version rule description level larity realized conditional compilation 
exten sional versioning may achieved remembering freezing designated version selections 
iv 
related big variety version models realized different scm systems 
take look systems commercial systems research prototypes perspective requirements design decisions introduced section iii 
systems included comparison selected demonstrate spectrum architectures result resolving de sign decisions 
reader referred comprehensive survey scm systems concepts 
discussion includes scm systems clearcase pcte adele ice 
systems described indi section iv 
subsequently compared section iv draw respect layered architecture uniform version man agement 
version models cm systems clearcase clearcase successor dsee developed mid 
cial scm system versions file data 
files directories versioned items total versioning version spaces represented version graphs 
selective deltas store versions efficiently 
versions files directories selected version graphs means version rules composition model 
applica tions access versioned repository virtual file system 
version filter set resolves item access version description sequence rules 
clearcase uses fast network dbms underlying data storage 
sample software system foo stored directory contains system model sys source files headers bodies 
version description defines version filter hides file contained selected configuration 
pcte defines public tool interface software engineering en 
description refer version control part pcte 
version description sys foe version filter sys fig 

clearcase pcte pcte standard open repositories pro vides interface implementing software engineering tools 
heart pcte object management system data model combines concepts eer model unix file system 
object may long attribute file operations provided 
links objects classified predefined categories including composition links representing complex objects 
pcte standard contains basic versioning facilities originally developed pact project 
version model defined top data model 
versioned items complex atomic objects total versioning 
version complex object composition links component versions composed 
clearcase versions arranged version graphs 
fig 

versions complex objects pcte versioning complex objects illustrated 
new version complex object created deep copy composition hierarchy underneath root ob ject conceptually performed 
ensures navigation composition links unique respect versioning 
versioning remains transparent existing applications navigate database having code added responsible version selection 
adele adele commercial scm system object oriented data model 
contrast pcte version model built data model 
schema definition language supports definition versioned object types 
furthermore versioning integrated note copy operation may implemented delegation see 
type interface object common system unix hp vms graphics xll open win modifiable belong conf bug reports set document immutable header file realization versioned realization fig 

definition versioned type adele query language offers version rules intensional ver sion selection 
contrast clearcase pcte adele explicitly distinguishes revisions variants 
versioned object type stands sequence revisions 
values common unversioned attributes shared revisions revision value specific versioned attribute 
directed deltas efficient storage long attributes text files 
variants represented set valued attributes implementation variants implementing interface 
gives example versioned object type definition 
single type definition suffices contrast defining version model top data model usu ally involves declaration pairs types versioned objects versions respectively see 
common attributes denote platform interface object available 
versioned attributes fur ther classified modifiable immutable ones 
example header file immutable set bug reports may grow gradually 
multiple realization variants interface revision 
ice ice research prototype applies de database technology scm 
data model orthogonal version model 
far ice implementation supports file data accessible virtual file system interface 
selective deltas base layer ice architecture 
version rules introduced top delta storage 
different version models may defined help version rules 
inverts approach followed clearcase version rules defined top version graphs 
version rules layer feature logic feature represents attribute 
example ws xl unix denotes version window system feature ws unix version operating system feature os :10.1.1.45.5819
feature terms may constructed operators intersection union negation intersection fails respective feature terms disagree common feature 
example xll os unix os dos 
users configuration management system familiar feature logic featured file system built hides feature terms users 
virtual workspace version rules version graphs selective deltas clearcase physical workspace version rules version model data model directed deltas adele physical workspace version model data model embedded deltas pcte virtual workspace version model version rules selective deltas ice fig 

layered architectures different scm systems internally fragments text lines decorated feature terms denoting visibilities 
clearcase version filter defined read write operations 
reading internal feature terms intersected version filter transformed conditional compilation expressions 
writing inverse transformation applied 
feature logic employed base mechanism top different version models may realized uniform version model 
feature logic realize check check model composition model long transaction model change set model introduced feiler 
comparison compare selected systems respect requirements design decisions introduced section iii 
table classifies considered systems taxonomy 
rows table correspond requirements 
table ii shows design decisions resolved selected systems 
displays resulting layered architectures 
note design alternatives introduced section covered 
particular clearcase adele offer version rules selecting versions extensionally versioned objects 
ice inverts approach version rules build different structures version space 
pcte version model realized top data model 
adele version model data model entangled 
ice version model orthogonal data model 
proceeding comparison emphasize points systems compared different validation levels 
clearcase adele commercial scm systems 
furthermore commercial pcte implementations requirement generality respect product space version space covered table reflected taxonomy 
clearcase pcte adele ice directed deltas embedded selective dimensions revisions evolution variants version state description change version space version graph representation grid version set extensional definition intensional version constraints rules preferences defaults selection product granularity total component workspace physical virtual table classification scm systems wrt 
requirements di data model delta representation basic concepts extensional version model intensional versioning clearcase integrated selective deltas selective deltas version intensional top extensional graphs version rules extensional versioning pcte version model top embedded deltas embedded deltas version intensional data model graphs versioning adele integrated directed deltas directed deltas revisions intensional top variants extensional versioning ice data model orthogonal selective deltas selective deltas version extensional top version model intensional rules intensional versioning table ii design decisions different gem systems available 
systems validated actual real customers 
hand ice research prototype lower validation level 
interested comparing internal architectures different systems 
architectures evaluated requirements uniform version model 
concerned external functional ity systems see evaluation functionality commercial scm systems 
selected scm systems ice designed goal offering uniform version model 
authors systems strive providing useful widely accepted version models go far ice respect unification version models 
clearcase established scm system provides sophisticated support version management 
proved useful practice 
clearcase supports revisions variants extensional intensional versioning 
clearcase offers state versioning change versioning implemented layer clearcase 
main restriction clearcase commits version graphs low level architecture 
version rules change versioning located top version graphs 
version graphs support multi dimensional variation adequate way 
introduce constraints intents change versioning goals versioning flexible application changes 
version graphs deltas committed specific points history moved freely 
rule version selection confined coarse grained level fine grained selections level text lines 
pcte included mainly demonstrate version model defined top data model 
version management services severely limited support extensional versioning version graphs 
developers adele gained long term practical experience scm 
developed system offering sophisticated data version model including powerful rules version selection 
adele supports revisions variants extensional intensional versioning version rules classified constraints preferences defaults 
building version model data model advantages efficient implementation elegant schema definition query language 
hand solution commits user specific version model 
furthermore adele address change versioning implemented top adele see remarks clearcase 
ice claims provide uniform version model 
fact meet requirement wide spectrum version structures constructed feature terms 
ice cover revisions variants extensional intensional versioning version graphs grids state change versioning 
hand ice research prototype practical experiences gained limited extent 
major problem ice efficiency decide consistency feature unification np complete 
reported naive application feature unification results check times grow limits number versions 
contrast systems rcs dsee clearcase rely version graphs implement check check efficiently 
systems provide intensional versioning fine grained level 
rcs scss adele clearcase employ call extensional deltas simple visibilities ice intensional deltas sophisticated visibilities 
system architecture satisfy requirements defined section iii developed layered system architecture shown 
layers aggregated groups version engine scm repository respectively 
layers described briefly bottom top 
indicate ways requirements met design decisions resolved 
version engine provides basic versioning capabilities constraining product space 
merely assumed versioned items item identifiers provided product space layers 
version model orthogonal data model implying version engine data model 
delta storage offers selective deltas 
versioned item set different fragments carries visibility interpreted version rules layer 
visibility logical expression applications scm repository version engine general software tools aided scm tools uni version workspace transaction support data model version model version rules delta storage fig 

layered uvm architecture variables called options 
option may true false unset 
version rules layer provides intensional version ing valued logic 
extensional versioning supported remembering freezing version selections 
addition visibilities rule base containing constraints preferences defaults 
selective deltas version rules constitute sole base mechanisms uvm 
respect product space version engine operates low level ab contents fragments regarded byte streams 
main difference storage systems consists deductive capabilities versioning 
example storage manager exodus ble database management system concerned byte streams 
exodus storage manager supports delta storage versions embedded deltas offer version rules 
version model layer desired version model may defined revisions variants state change versioning version graphs grids rs extensional intensional versioning 
achieved defining appropriate version rules 
example version graph built implications form meaning delta applied preceding delta applied 
uvm inverts traditional composition model version rules defined top version graphs 
uvm extensional versioning supported top versioning 
approach flexible composition model commits version graphs 
uvm desired version model just version graphs may defined help version rules 
version rules basic concept version graphs 
version engine cm repository provides layers data model transactions workspaces 
data model layer responsible offering data model object oriented eer simply files upper layers hides versioning 
clients layer may perform queries updates database unversioned 
transaction support provides cooperative long lasting transactions 
software development maintenance activity performed context transaction 
transaction confined subset product space version space 
particular transaction may operate level granularity respect product space 
workspace layer concerned interface software tools editors compilers debuggers case tools 
workspace layer provides uni version workspace help virtual file system simply check operations software tools shielded versioning 
workspace associated transaction 
layer structure described idealized ways 
example transaction handling dis tributed multiple layers 
data model layer depend specific version model relies general functions provided version engine 
spite considerations stick somewhat simplified layered architecture order convey key points clearly 
uvm architecture merely proposal 
great extent implemented epos research prototype software engineering environ ment supporting scm process management 
refer epos implementation various points sections 
presentation primarily revised implementation epos configuration management system ecm described initial implementation described 
uvm similar ice see section iv de veloped ecm implementation 
share fundamental design decisions 
uvm differs ice respect points uvm different kind logic propositional valued logic feature logic 
ecm visibilities implemented efficiently ice see section viii 
transaction support lies borderline configuration management process management considered seriously ice far 
data model layer addressed thoroughly ice 
far ice assumes text files directories 
vi 
version engine delta storage constitutes basic layer architecture 
uvm selective intensional deltas fragment governed visibility expression 
intensional versioning directly supported 
addition desired version model may realized deltas demonstrated section vi 
please note embedded deltas provide sharing offer intensional versioning 
directed sake clarity transaction handling discussed place section vii 
sin sketched long transactions ice simu lated means transaction features 
ty fragment item fig 

delta storage deltas useful implementing version graphs rcs change versioning pie 
suited variants imple mented naturally selective deltas ultimately derived conditional compilation 
versioned database consists collection fragments 
fragment parts lefthand side visibility version part fragment controls region version space fragment legal set versions included selected 
visibility may considered version identifier vid fragment usually covers large set potential versions 
item identifier indicates corresponding versioned object generally versioned item see section ii 
item identifier resembling object identifier oid provided product data model layer 
contents raw data corresponds product part fragment attribute value pair text line 
note shall see section transactions fragments associated transaction identifier tid may regarded appended part visibility 
large ellipsis right hand side illustrates version space versioned item space potential versions 
small ellipses corresponds fragment 
area covered ellipsis indicates set versions frag ment belongs 
sets mutually disjoint 
specific version corresponds single point version space 
version space collapses single point case unversioned data 
delta storage dumb leaves interpretation information upper layers 
particular know items versioned items identified visibilities contents interpreted 
delta storage provides low level functions storing fragments retrieving sequentially text file composed sequence match ing lines index object resolved 
epos delta storage realized index sequential files done 
ensured version rule layer see subsection vi 
fragment level version rules layer adds deductive capabilities delta storage 
evaluates writes visibilities fragments leaves parts untouched item identifier contents 
considers version space making assumptions respect product space apart existence unique item identifiers oids 
fact possible implement layer way unaware data model 
formal foundation propositional valued logic see version rules 
version rule logical expression global variables called options 
option defines property absent included version 
version space represented dimensional grid dimension corresponds option 
point version space denoted complete binding option bound true false 
binding called incomplete options remain unset 
complete binding denotes region version space dimensional cube number unset op tions 
logical expression constructed constants variables options operators 
expression evaluated binding true false unset bi denotes binding option bi unset means oi unset 
complete option unset 
logic valued valued 
binding expression evaluates true false unset 
example true unset unset true unset true function binding may represented conjunction bt 
bn bi oi oi true shown unset option oi binding represented bi true eliminated conjunction 
stick definition convenient definitions follow 
options identified name 
examples gut set true versions programs supply graphical user interface 
docu mentation 
set true program versions specially adapted run linux operating system 
speed pl indicates version optimized speed 
visibilities version filters visibilities fragments need evaluated reading database updated writing database 
reads writes go version filters 
read filter called choice determines single version user application 
choice complete option binding accessed product subspace fragments 
write filter called ambition defines set versions affected change 
ambition specified potentially incomplete option binding 
choice lie ambition choice ambition agree bound options 
ct ai true ai ci means choice implies ambition informally options remain unset ambition evaluates true versions affected change 
inversely option unset ambition choice coincide single version denoted changed 
distinction read write filter performed multi version editors edit advantages may edit multiple versions simultaneously bothered visibilities 
case visibilities hidden users 
reading simplified involve general unification logical expressions 
just evaluate visibilities complete option bindings 
note allowed general am general logical expressions 
increased generality result increased complexity see 
fragment visibility passes read filter choice iff visibility implied choice evaluates true option bindings choice ensure fragment item visible choice multi version editor capable displaying versions ously 
vi vj denote visibilities fragments versions item 
condition hold express fragment visibilities disjoint vi vj alternatively may rephrased follows si sj denote version sets mentioned fragments visible 
si sj corresponds set points version space point character ized complete option binding 
si sj disjoint illustrated earlier righthand side small ellipses represent different contents extent fragment set versions visible represented region covers 
respect write operations distinguish deletions insertions updates 
inserted fragment gets visibility entirely ambition insertion case deletion visibilities fragments fragments item identifier constrained selected current ambition vnew deletion update move operation reduced combined deletion insertion operation described 
additional adjusted fragment visibility vnew violated non overlap versions 
write operations touch actual fragment visibility remains unchanged vnew 
write operations maintain invariant visibilities different versions fragment mutually disjoint 
example ambition choice visibilities il concepts introduced simple example adapted :10.1.1.45.5819
sample database varies respect operating system unix dos window system xll 
variant repre sented corresponding option 
left hand side contents database update shown 
versioned fragments identified convenience fragment versions identi fied similarly identifiers implementation 
fragment version illustrated way visibility left slot 
please note assume changes performed certain order 
example unix variant introduced dos variant 
visibility fragment version narrowed dos dos change carried 
order carry change extends versions operating system window system define option fix simultaneously serves ambition 
perform change version just set choice carry preferred environment 
perform changes unix xll set corresponding options ambition true options false 
single version view middle modify add fragment clearly awkward 
user assisted setting default option bindings discussed viii 
database changed rules earlier top right fragments remain untouched unchanged 
middle right fragment split old version deleted context visibility fix new updated version assigned visibility fix ambition 
bottom right fix visibility attached inserted previously unknown fragment complexity complexity dealt different levels 
user level facing problem consistent legal selections large version space 
problem discussed section viii 
system level concerned efficiency 
section mentioned efficiency problems encountered ice 
problems due inefficient evaluation logical expressions intensional deltas 
classical systems sccs rcs adele confronted complex expression evaluation embedded directed deltas extensional deltas 
scm systems construct versions components explicitly checked explicit merging create new version combinations 
section viii demonstrate intensional deltas implemented efficiently 
meta database option definitions rule base uvm repository composed parts fully versioned contents database containing collection fragments semi versioned meta database containing option definitions global version rules 
databases attach permanent transaction identifiers tids stored information items primarily facilitate traceability change jobs database changes 
addition tids serve timestamps realize revision chain meta level evolution see section vii transactions 
meta database contains parts option definitions introduce named options may referred fragment visibilities ambitions choices fragment level version rules global version rules see point 
define high level version identifiers unix usually representing parts choice ambition 
options high level version identifiers version rules 
see section vi sec tion 
global version rules just version rules constraints options result poten tial choices ambitions may expected consistent legal relevant 
man age complexity legal version selection need rule base global version rules attached specific fragments 
complement choices choice read filter database change database change fix unix sos xll windows unix unix nt dos fl nt dos dos single version dos view windows hl true hl fix item identifier fi ambition write fig 

example evolution visibilities ambitions set version filters reading writing respectively 
user typically specify high level partially bound external version description evd 
extended low level bound internal ver sion description ambition choice help global version rules see section viii versioning assistant 
types global rules cf 
section ii general constraints usually dependencies dependencies options typically mean option bound explicitly true false ambition choice option bound true 
example options deciding layout graphical user interface sense gui selected place 
note option dependency merely stating feature requires feature feature sense talk feature 
option groups special constraints variants option groups express mutual exclusion variants resemble enumerated datatypes see section vi 
specify group options may bound true 
typical examples include options different hardware os natural languages user dialogs 
validity checks special constraints support baselines validities express certain versions frozen baselines updated adding op tions associated ambition see page 
preferences weak dependencies rule base may contain user project specific preferences fill usual trivial choices 
means high level version identifiers express releases covering bundle error fixes 
version identifiers translated group detailed option settings 
defaults rule base may contain default selections apply resolve ambiguous choices 
details see 
meta database evolving entity 
new options need defined represent logical changes support new platforms second version rules may added exclude combinations due bad experiences 
conversely may removed corrective performed set merge test transactions 
evolution meta database supported principle handle meta database way contents database adding metalevel meta options meta rules 
hard imagine manage incurred conceptual complexity multi level version selection 
believe simple tid time stamping support revisions meta database suffice 
lows re generation old versions configurations ing corresponding old option definitions rule base 
newer options visibilities consequently set false 
simple example 
example evolution meta database sume database evolved follows 
initially contents database unversioned visibilities set true options 

introduce option meta database perform change contents database am new fragments get visibility 
introduce option perform change ambition 
updated fragments previously decorated split visibilities respectively 

add constraint ensure en selected selected 
want fix bug version denoted step 
current version prohibits enforces selection enhancement may appropriate customer license agreement includes bug fixes 
perform change conceptually roll back meta database state step 
addition options introduced bound false old fragment versions correctly selected 
example case fragment split described step old version visibility selected new visibility 
version model top basic version rule layer desired version model defined 
note version model concerned version space prod uct space handled data product model layer section vii 
far assumed unique item identifiers rest data product model left unspecified 
version graphs grids revisions option space represented dimensional grid 
adding constraints may model version graphs 
mentioned earlier revision chain defined means implications 
intro duce delta options nb delta changes named ai implication rules delta predecessor version graph ai ai revision ri defined listing included excluded options respectively head tail sorted conjunction ri 
ai ai 
example version graph consider version graph :10.1.1.45.5819
rs fig 

version graph delta combinations note delta symbol represents change option physical change 
delta sequences represented equations revisions may described follows increasing number deltas included aaa aas aaa aas 
variants option groups shown model linear chains revisions 
variants represented option groups 
option group consists set mutually exclusive options 
global version rule xor operator indicate option group may selected bound true simultaneously 
example variants branch version graph represented follows assumes meaningfully combined case combined con straint course omitted typically merging completed 
similarly may option groups express variant attributes ranging enumeration type 
example introduced contents database varying respect operating system window system 
operating system variants may represented option group os os unix dos vms state change versioning obvious state change versioning supported uvm 
really sharp distinction 
state approaches differ respect constraints impose change combinations 
taken extreme may say change versioning enforces constraints deltas tied fixed locations version graphs case state versioning version graph implicitly defines constraints 
reality rarely find extremes 
versioning gets lost version space constraints 
classical state systems facilities merge changes text merge tools apply different locations version graph supported sccs 
addition delta composition model mentioned earlier allows combining changes rule selection component versions 
example merging assume want merge changes ae version graph 
perform change tion choice ae initially obtain version merged automatically 
result merge adjusted manually 
writing consolidated changes database establishes merged version trust 
example consider cut ver database fi gi denote versioned frag ments version groups individual fragment versions respectively fragment contents shown old fragment ld visibility aa ambition defined fragments selected 
user tests detects error requiring change fragments 
change database contains new fragment versions part adjusted revision got changed visibilities old fragment ld visibility aa fa aa aa aa example demonstrates merging stage process 
automatic raw merge 
user supplies version de scription choice options changes merged set true 
version engine selects fragment versions correspond actual choice 

manual adjustment merge 
user check result step delivers meaningful version satisfying requirements 
may involve compiling testing merged program version 
case errors user fix result automatic merge manually 
updates visibilities specific option combination ambition 
distinguish individual changes specific option merge changes specific combination 
instance sccs distinguish extra merge changes 
experiences commercial way merge tools indicate conflicting meaningless merges happen quite rarely 
merge process described practically feasible non uvm scm tools 
advantage uvm commercial approaches illegal combinations detected constraints assigned special raw state see page 
extensional intensional versioning validities uvm intensional versioning constitutes base top extensional versioning realized 
introduce external version identifiers identify versions conveniently reconstructed 
version identifier simply symbolic name stands choice group choices unix 
repeating long extensional lists option bindings user may refer compact intensional version identifier 
see section viii versioning assistant 
user able select version predefined property stable properties guide completing version choice 
implemented called validities validity disjunction validity terms 
validity term binding conjunction accord ing 
case complete option bindings denotes single version 
validity simply enumerates set versions extensional versioning 
addition versions share desirable property usually characterized value predefined set version states raw compiled inspected tested 
stable released 
instance new previously selected versions assigned raw state 
uvm consecutive transactions may ambition bundle changes split update products subsystems 
need define stable product baselines internal external releases protect desired versions changes 
purpose stable validity vs introduced 
sta ble validities cover validities stable released states 
furthermore added con straint global version rule new ambition overlap stable validity vs possibly adjusted ambition property stable validity validities restrict new ambition 
adding fur ther option bindings new options ambition eventually fall outside stable validity 
impossible ambition illegal 
example validities merge performed example assume stable validity vs containing revisions revisions immutable vs ro rt re ra name validity retained historic reasons 
change performed ambition see 
overlap vs ha false ambition need constrained vs change may extend stable validity included vs ro rs vii 
scm repository far discussed version engine located bottom uvm architecture 
subsections devoted repository layers sketched briefly 
layers bottom top product data model layer transaction support workspace support 
order 
lastly sketch scm toolkit functionality application layer 
product data model product data model layer adds data model missing far 
external interface layer database basically behaves conventional unversioned database consisting objects identified olds relationships decorated non versioned tributes 
versioning taken care low layer top 
essentially version selected operation proceeds un versioned database 
clear separation version selection queries selected database version 
uvm distinguish version space queries product space queries respectively 
version se lected precisely ambition choice user may issue product space queries bothered version selection 
example case relational data model standard sql queries may purpose 
contrast queries need consider product space version space version model data model entangled 
example software system configured transitive closure relationships respective query handle alternating product version space selections selected module version outgoing relationships traversed subsequently version selected module 
alternating product version space selections queries complicated 
contrast version selection factored uvm 
data model introduced top version model version model independent data model 
statement holds large extent opposite direction 
data model layer knows versioning takes place knows existence read write filters choices ambitions respectively 
filters just passed version engine going straight meaning understood data model layer 
data model layer turns fragments typed data 
particular determines versioning performed full objects single attributes lines textual attributes 
provides highlevel identifiers usually object identifiers 
defines missing sameness criterion lower layers raw item identifiers 
product data model layer knows item identifiers version fragments 
inversely lower layers provide identifiers purpose know interpreted utilized upper layers 
alternatives mapping data model elements fragments 
determining granularity fragments balance efficiency smaller fragments overhead paid storing evaluating visibilities 
hand small fragments combined large ones 
example composi tion model introduced realized clearcase treats text files fragments configuration built 
way changes level text lines combined 
adele supported predefined object model special interface body subsystem structure 
adele general object model chosen accommodate wider range software design objects 
epos binary eer model chosen offers single inheritance entity relationship types 
entities relationships attributes mapped fragments way entity represented fragment type root type hierarchy object oriented 
case item identifier composed object type identifier 
short attributes part fragment type attribute declared 
approach coarse grained long attributes restricted sequential files sized items treated special way instances special type 
text file represented sequential database file record fragment consists visibility text line 
text file written diff performed 
visibility deleted lines constrained inserted lines visible current ambition 
lines unique identifier possible represent multiple versions line 
lines updated update handled combined deletion insertion 
non versioned read attributes names creators logs may put separate database save space merged versioned attributes access 
separation normal objects 
relationship mapped fragment 
multiple versions fragment relationships unique identi product model application defined terms data model means database schema 
notice schema may versioned 
re sult version selection specific schema version obtained consisting set raw uni version fragments represent parts type definitions 
data model layer ensure consistency respect schema definition instances viewed schema version see details schema comply constraints data model 
example subtype may exist supertype exists relationship type may exist source target types exist similar instances comply selected schema version 
particular schema version determines extent visible information 
example entity may viewed instance visible types relationship visible source target type visible transaction support transactions coordinate cooperative versioned database 
triggered change request implemented trans actions 
transaction defines context devel perform 
context determines versions objects read written 
introduced single transaction layer simplified uvm architecture 
transac tions actively planned followed terminated workspace application layers top transaction layer 
mainly concentrate design issues concerning layered uvm architecture 
cooperative transactions carried epos see 
level delta storage fragment decorated unique transaction identifier tid 
fragment written database tagged tid transaction performs change 
changes performed transactions may traced 
means tids may provide functionality temporal database 
note transaction logs classic databases resemble deltas terminology 
tid high level visibility fragment selecting accessible transaction 
case cooperating transactions special propagation mechanisms policies 
transaction visibility achieved called transaction options effectively combining visibilities transaction identifiers 
transaction scope discuss technical reasons combination subtyping instances relationship types versioning complex 
partial overlap full overlap tl tax product space fig 
:10.1.1.45.5819
scopes transactions extra internal transaction option ot assigned automatically 
transaction internal ambition ai obtained constraining user specified external ambition ae ai ae 
commit ot automatically set true subsequent version selections 
layer version rules read filter choice write filter ambition associated transaction 
way cut version space defined transaction operating 
ambition includes transaction option mentioned defines visibilities attached fragments written database 
addition changes contents database collection fragments changes database traced 
achieved implementing meta database collection fragments tagged tid transaction written 
way revision chains meta database may realized tids effectively functioning time stamps 
described basic functions handling transactions provided lower layers uvm architecture 
describe added transaction support layer located top prod uct data model layer 
far transactions concerned version space 
product space needs considered 
order detect resolve conflicts transactions know objects users working 
possible set locks objects pessimistic concurrency control 
alternatively commit detect direct indirect update conflicts time stamps optimistic concurrency control gen eral involves interactive conflict resolution ing 
time stamps represented tids 
transaction operates versioned database 
version space defined ambition writing choice reading 
product space typically defined transitive closure root object main program set relationship types part depends 
illustrates conditions transactions come potential conflict :10.1.1.45.5819
shaded regions black points represent ambitions choices respectively 
transactions conflict overlap respect product space version space 
transactions tl affect versions disjoint respect product space conflict 
con tl refer objects operate disjoint version sets conflict 
may conflict partly overlap spaces 
choices lie common parts ambitions sees modifies vice versa 
lastly conflict identical version product spaces 
formally conflict may defined follows oi ai ci denote sets objects am choices transactions respectively 
transactions stand potential conflict condition holds ono false ci object sets ambitions overlap 
furthermore choices defined changes mutually visible 
transaction support layer responsible detecting preventing resolving conflicts 
addition provides mechanisms defining units assigning developers units defining executing rules regarding change notification propagation reconciliation 
upper layers vii instrument mechanisms part pro cess model high level policy 
transaction support layer prescribes flat acid hierarchical transaction struc tures fixed uvm architecture 
ap plies inter transaction cooperation commit possibly organized 
urge transactions workspaces considered class persistent objects stored accessed manipulated normal database queries 
final comment epos database transac tion layer originally versioning layer 
part redesign switched lay ers tm 
reversal lead orthogonal simple handling transactions versions turned versioning handled fundamental data model independent mechanism transac tions 
transactions establish context ver way 
uvm proposal transaction layer put higher prod uct data layer offer high level synchronization locking features 
workspace support abstraction achieved workspace support layer aims providing applications data 
applications case tool uml rose classical development tools editors compilers 
rn claims got idea shower 
workspace support done lines sccs rcs 
files held scm database checked file system manipulated applications 
proper caching observed adequate performance 
mentioned earlier alterna tive virtual file system avoids physical copy ing provides applications illusion working ordinary file system fact operating uni versioned slice versioned database 
various regimes maintaining consistency workspace envisaged busy full synchrony lazy demand reconcile commit check combinations depending object type elaborate large scale workspace management adele 
scm toolkit functionality uvm functionality really useful envisage scm toolkit part application layer possibly separate layer workspace layer application layer 
sophisticated product version models offered possibly combined graphical interface visualization facilities 
instance product version space certain subsystems clustered scope rules 
put high level version descriptions layer map low level representations version rule layer 
see versioning assistant viii elaborate system models architecture de scription language aml systems modeling language proteus ptl offered database schema defined un product data layer 
able explicitly model support parts cooperative scm process possibly hooks layers 
see stance unit description language epos similar adele clearcase 
modern scm tools offer myriad functionality falls outside scope 
viii 
experiences implemented uvm model epos research prototype software engineering environment supporting scm process management 
implementations uvm performed epos 
ini tial reported mainly refer revised implementation done phd thesis 
implementations problems evident efficiency ease 
version visibilities version selection initial epos implementation general purpose evaluators vlsi domain logical expressions applied 
apparent soon fig 

visibility tree general way go 
storing large logical expressions visibilities attached fragments causes unacceptable overhead 
evaluation expressions npcomplete standard algorithms expand logical expressions normal form slow orders magnitude 
revised epos implementation visibilities handled efficiently respect time space 
inspection equations calculating visibilities reveals visibility expressed conjunction positive negative ambitions az 
am nam 
please recall ambition conjunction option bindings 
visibilities stored equation expanded normal form 
furthermore fragments share visibility 
visibility field fragment contains pointer global data structure called visibility tree 
node contains positive negative ambition pointer parent visibility 
tree grows leaves insertions deletions updates performed 
example fragment deleted ambition new visibility vnew inserted tree node contains points old visibility 
way writes performed efficiently costly expansions transformations logical expressions need performed 
reads performed efficiently 
assume choice complete list option bindings 
fragment visibility decide holds 
process ambition term visibility bottom 
occurs positively option bindings agree negated option binding disagree 
current term evaluates false evaluation stops short cut evaluation 
term considered term process 
example visibility tree return example display visibility trees change carried ambition fix 
change ambition fix version fragment visibility true 
fragment updated introduce visibility nodes corresponding respectively 
visibility constrained pointer visibility node moved new node new fragment versions point node fragments share visibilities speed evaluation significantly introducing cache evaluated visibilities implemented hash table 
visibility need evaluated time value retrieved cache 
bottom visibility tree encounter evaluated visibility way partial evaluation 
maintain similar cache evaluated ambitions 
caches currently incremental demand evaluation unused term evaluated 
important large option product spaces 
summarize performance complexity implementation storage space 
fragment small constant overhead storing visibility id represented index visibility tree 
furthermore visibility tree grows linearly number visibilities increases number changes database 
tree growth usually extra ambition term visibility due shared sub expressions 
growth visibilities may linear number new visibilities created transaction depends number different visibilities fragments touched 
writes 
inserting deleting updating fragment performed constant time 
new leaf node may inserted visibility tree new pointer stored 
reads 
evaluation visibility choice linear number ambitions number option bind ings ambition linear total number option bindings 
visibility evalu ated cache partially due sharing 
possible non linear growth number visibilities serious problem difficult evaluate depends heavily pattern transactions ambitions 
affect storage space needed extent evaluation time 
aware empirical studies intensity locality changes single text files limited change oriented versioning 
hand optimizations available greatly reduce number new visibilities new fragment versions created transactions fragment visibilities split parts existence fragment affected insert delete common versions fragment variable visibility version affected updates 
reduces average size visibilities importantly reduces total number fragments share simpler visibilities 
database change versioned fragments pointer visibility pointer fragment version parent visibility node visibility node database change versioned fragments fig 

visibility tree example deleting updating fragment equa tion need update visibilities overlap ambition adding negated ambition doesn effect 
tion consists new option doesn help ambitions restricted 
sorting versions fragment new version update read making version engine understand positive ambition visibility implicitly negated versions fragment don update visibilities 
designed epos start idea hasn tested theory practice 
example efficiency epos implementation ch 
phd thesis experiment de scribed source code conditional compilation expressions converted stored epos version storage 
assumed represent variants product 
step gcc compiler source files parsed 
variants removed files checked client server special tool 
files versioned total options different visibilities 
tool deduced ambitions generate visibilities 
rcs represented single version text file 
total cpu time check seconds sun extra space compared original source 
cpu seconds check time kline potentially versioned source text 
check ins coupled automated workspace group check ins sharing ambition 
time usage rcs recorded 
second step upgrade gcc checking new revisions variants files 
files versioned totally new ambitions checked removed 
options including new revision different visibilities registered 
total cpu time check seconds space consumption original combination rcs conditional compilation 
check time file cpu second file 
check times recorded dominate 
note research prototype little performance optimization performed 
initial experiments shown head storage space moderate compete rcs combined conditional compilation 
compact format visibility id text files saving total size example 
compared ice accelerated reads writes evaluation logical expressions dominated time 
due growth visibility tree performance de grades increasing age database 
clean measurements described applied periodically reorganize database 
measurements designed reduce visibility tree searching identical overlapping ambitions visibilities removing visibilities evaluating false deleting fragments decorated visibilities conclude reduced complexity np completeness quite manageable 
compared ice approach benefits reads writes performed polynomial time 
contrast feature unification ice np complete 
deductive shortcuts implemented restricted classes feature terms perform better 
evaluation global version rules page top delta storage theory np complete :10.1.1.45.5819
rules evaluated transaction 
done ambition choice operating database 
contrast ice separately stored global version rules 
rules embedded source text conditional compilation 
assistant pleasure confronted raw version space 
user needs tool relieve selection details consider 
assistant considered part scm toolkit providing considerable leverage visualizing version space version graphs 
checking version descriptions consistency constraints stored rule base dependencies validities 
remembering previous version selections 
offering scoped product options 
offering menu selections derived global ver sion rules implement option groups variants 
deriving option bindings user needs supply partial version description preferences defaults 
items illustrated small example 
example versioning assistant assume soft ware system varies respect operating system window system 
furthermore fixes applied 
constraints exclude consistent version selections dos unix windows xll dos xll dos unix windows fix fix fix fix fix dos os os fix xll fix windows fix os os fix ws windows fix xll fix fig 

menu version selections menu version selection illustrated 
sequence actions arranged column wise left right see numbers boxes 
upper row shows states user selections current selection indicated arrow 
lower row shows corresponding states selections 
options set true false shown bold face light grey respectively 
hierarchical menu entry indicated 
selected hierarchical menu entry emphasized italic font 
version selection proceeds follows 
user selects option group os top level menu 
displayed offers alternatives dos unix 

user selected unix dos automatically disabled 

user selects ws window system top level menu 
offering available window systems windows disabled automatically cause selected unix 

user selected xll automatically disabled 

user selects fixes top level menu 
offering fixes fix disabled automatically assumes dos variant operating system selected 

user selected fix automatically included fix depends 
fix excluded fix fix applied 
going steps choice complete binds unix xll fix true options false 
database workspace issues built experimental tool top epos database called ecm provided cvs func tionality managing versioned text files checked workspaces sub workspaces corresponding transactions epos 
ecm knowledge product model check sub product associated files subdirectories 
ecm provided prolog interface check entities relationships user environment 
gcc source experiment done tool hadn implemented manage development source code stable 
ix 
discussion previous section covered crucial issues concerning uvm approach efficiency ease 
pointed issues dealt epos implementation uvm 
briefly discuss essential topics generality uvm approach database design respectively 
generality uvm approach uvm radically differs approaches versioning 
systems implement specific version model version model depends data model 
generality uvm particularly achieved design decisions version rules common base realize specific version models 
inverts approach followed clearcase scm systems version rules defined top version graphs 
clearcase version graphs deeply built system basic concept 
uvm version graphs basic concept 
graphs may introduced top uniform version storage mentioned scm toolkit 
version model orthogonal data model 
pcte version model defined top data model adele integrated data model 
cases version model depends data model 
contrast uvm may applied data model 
generality uvm allow version models simulated top uvm 
statement holds insofar revisions variants state change versioning version graphs grids extensional intensional versioning expressed uvm 
shown section vi kinds versioning may defined help version rules 
version rules global version space layers located product space layers 
consequence version rules refer specific product items subsystems introduced upper layers uvm architecture see discussion 
example model revision chains alternative variants employed adele 
express attributes shared revisions revision specific values 
requires handle updates common specific attributes different ways 
distinction version engine section vi 
accommodated splitting fragment versioned part unversioned part proposed :10.1.1.12.7945
may simulate version graphs employed clearcase uvm global virtual version graph version graph versioned item file directory 
consider ad vantage clearcase model difficult select consistent set versions multiple version graphs structured different ways 
principle version space may scoped introducing product specific options 
breaks orthogonality data model version model topmost scm toolkit offer clustering vii system modeling formalism 
toolkit versioning assistant viii responsible re solving mapping detailed product version information proper layers 
compare multi layer approaches modules object oriented classes prolog 
resolve non prolog name bindings basic inference engine start unification binding inferencing intertwined 
notes database design approach different offered virtual file systems clearcase 
file system catalogs replaced clearcase equivalent technically done api subroutine traps relinking file system libraries 
pro vides uni version view specified part versioned database appropriate version filter settings 
mentioned clearcase uses underlying dbms hidden application programs users 
course extra layering provides extra overhead performance satisfactory 
similarly scm tool uses ingres underlying dbms 
version internal selection attributes relationships inaccessible application level 
adele limited application access attributes relationships 
uvm proposal requires dbms internal frag ments buffers tuples equipped prefixing visibility serve supplementing transaction identifier 
visibility stripped low level select operation guided actual option settings 
fragments considered visibilities evaluate true interpretation operation performed fragment 
overhead judged slight terms space time 
hand version selection done lower levels buffer tuple management normal query level overhead may intolerable 
instance implementation ingres underlying dbms resulted significant performance degradation overhead dbms really wasn needed 
best solution probably apply dbm toolkit configure versioned unversioned dbms support 
assumes buffer sizes properly accommodate extra space visibilities 
mention kids dbms toolkit klaus group include versioning 
hand transaction management explicitly analyzed possible functionality generation 
says quite adequate generic architecture model dbmss known 
knowledge situation today 
research needed motivating 
best solution ignore versioning layer 
visibilities set true renders small overhead 
final versioning useful design development 
unrealistic equip major commercial full versioning default functionality 
main target group uvm researchers vendors design databases cad tools scm tools 
introduced uniform version model uvm support architecture software version management subset scm 
uvm differs previous approaches support architecture inverts ordering certain layers 
firstly version graphs version model realized top version rules vice versa 
secondly version model completely nal data model 
perspective database management uvm architecture constitutes attractive alternative main stream architectures define version model top integrated data model 
unified version storage highly reusable may combined data model 
customized version models may defined independently data model may provided high level libraries 
far practical experience uvm architecture limited 
convinced approach promising deserves studies 
hopefully triggers activities targeted design implementation evaluation uvm architecture parts 
partially carried research stay bernhard westfechtel ntnu march 
support university aachen ntnu gratefully acknowledged 
conradi bernhard westfechtel uniform version model software configuration management software configuration management icse scm workshop conradi ed boston massachusetts may lncs pp :10.1.1.12.7945
springer verlag 
walter tichy tools software configuration management winkler pp 

randy katz unified framework version mod eling engineering databases acm computing surveys vol 
pp 
dec 
peter feiler configuration management models commercial environments tech 
rep cmu sei tr software engineering institute carnegie mellon university pittsburgh pennsylvania mar 
conradi bernhard westfechtel version models software configuration management cm computing surveys vol 
pp 
june 
grady booch james rumbaugh ivar jacobson uni fied modeling language user guide addison wesley reading massachusetts 
michael carey exodus extensible dbms project overview readings object oriented database systems stanley zdonik david eds pp 

morgan kaufman san mateo california 
andreas klaus constructing database management systems acm sigmod record vol 
pp 
mar 
raghu ramakrishnan jeffrey ullman survey de database systems journal logic programming vol 
pp 
may 
ramamohanarao james harland tion deductive database languages systems vldb journal vol 
pp 
april 
conradi bernhard westfechtel configuring software products sommerville pp :10.1.1.45.5819

bj rn managing version space sommerville pp 
:10.1.1.45.5819
walter tichy rcs system version control software practice experience vol 
pp 
july 
david cm challenge configuration management works tichy pp 

bjorn software engineering database change oriented way ph thesis ntnu trondheim norway idt report 
lie conradi tor andr son change oriented versioning proceedings nd european software engineering conference ghezzi mcdermid eds coventry uk sept lncs pp 
springerverlag 
software maintenance development systems massachusetts aide de camp product overview 
christoph concepts techniques software version control software concepts tools vol 
pp 
july 
marc source code control system ieee transactions software engineering vol 
pp 
dec 
glenn fowler david korn herman rao dfs multiple dimensional file system tichy pp 

gail kaiser concurrency control advanced database applications acm computing surveys vol 
pp 
sept 
gail kaiser cooperative transactions multiuser envi ronments modern database systems won kim ed pp 

addison wesley reading massachusetts 
jim gray transaction concept virtues tions proceedings seventh international conference large databases cannes france sept pp 

mary shaw david garlan software architecture emerging discipline prentice hall englewood cliffs new jersey 
gallo minor ian thomas version management pact integrated software engineering environment proceedings nd european software engineering conference ghezzi mcdermid eds coventry uk sept lncs pp 
springer verlag 
project final report esprit project dec :10.1.1.45.5819
klaus peter database system software engineering environments proceedings international workshop advanced programming environments conradi tor dag eds trondheim june lncs pp 
springer verlag 
edward version configuration management object oriented data model vldb journal vol 
pp 
jan 
jacky estublier adele configuration manager tichy pp 

andreas zeller gregor snelting unified versioning feature logic acm transactions software engineering methodology vol 
pp 
oct 
yi jing lin steven reiss configuration management logical structures proceedings th international conference software engineering berlin mar pp 
ieee computer society press 
david gordon mclean configuration management large scale software development efforts proceedings workshop software engineering environments programming large massachusetts june pp 

ira goldstein daniel bobrow layered approach software design tech 
rep csl xerox parc palo alto california 
josephine geoffrey system activity configuration management sommerville pp 

christoph tool orthogonal version management estublier pp 

larry allen gary fernandez kenneth kane david debra john posner clearcase supporting geographically distributed software development estublier pp 

david robert chase computer aided soft ware engineering distributed workstation environment proceedings acm sigsoft sigplan software engi neering symposium practical software development environments peter henderson ed pittsburgh pennsylvania may acm sigplan notices pp 
:10.1.1.45.5819
david robert chase jr howard productivity parallel configuration manager winkler pp 

lois jonathan pcte standard open repositories prentice hall englewood cliffs new jersey 
jacky estublier dimensional versioning estublier pp 
:10.1.1.45.5819
andreas zeller gregor snelting handling version sets feature logic proceedings th european software engineering conference wilhelm schuler botella eds spain sept lncs pp 
springer verlag 
andreas zeller unified version model configuration man agement proceedings cm sigsoft symposium foundations software engineering washington oct acm software engineering notes pp 

william burrows pat ingram configuration management tools ovum london 
conradi epos object oriented cooperative process modelling software process modelling technology anthony finkelstein jeff kramer nuseibeh eds advanced software development series pp 

re search studies press john wiley sons chichester uk 
wang jens otto larsen conradi bj rn improving cooperation support epos cm system proceedings th european workshop software process technology volker ed uk sept lncs pp 
springer verlag 
lie versioning software engineering databases ph thesis division computer systems telematics norwegian institute technology trondheim norway jan idt report 
lie conradi tor andr karlsson change oriented versioning software engineering database proceedings nd international workshop software configuration management walter tichy ed princeton new jersey nov acm software engineering notes pp 

vincent kruskal managing multi version programs editor ibm journal research development vol 
pp 

bernstein kruskal creation maintenance multiple versions winkler pp 

bj rn gulla andr karlsson yeh change oriented version descriptions epos software engineering journal vol 
pp 
nov 
erik unified class evolution object oriented views proceedings th international conference entity relationship approach tjoa eds karlsruhe germany oct lncs springerverlag :10.1.1.45.5819
erik category classes flexible classification evolution object oriented databases advanced information systems engineering th international conference caise tony wasserman gerard ed utrecht netherlands june lncs pp :10.1.1.45.5819
springer verlag 
conradi liu marianne plan ning support cooperating transactions epos information systems vol 
pp 
dec 
richard snodgrass temporal databases theories methods temporal reasoning geographic space frank campari eds pisa italy sept lncs pp 
springer verlag 
bjorn gulla user support facilities software configura tion management ph thesis ntnu trondheim trondheim norway forthcoming 
jacky estublier distributed objects concurrent ing system configuration management scm symposium jacky estublier ed toulouse france sept lncs pp 
springer verlag 
bjorn gulla improved maintenance support multi version visualizations proceedings international conference software maintenance 
pp 
ieee computer society press 
ian sommerville thomson approach support software evolution computer journal vol 
pp 
dec 
bj rn gulla conradi modelling systems variability proteus configuration language estublier pp 
:10.1.1.45.5819
bjorn jens otto larsen bjorn gulla conradi andre karlsson uniform versioning model proceedings dth international workshop software configuration management preprint stuart feldman ed baltimore maryland may pp 

peter georges saab efficient object oriented pro gramming prolog logic programming formal methods practical applications chapter amsterdam studies computer science artificial intelligence pp :10.1.1.45.5819
elsevier science north holland 
andreas klaus strategies tech niques reusable artifacts construction database management systems proceedings th international conference advanced information systems engineering caise lyytinen ross eds finland june lncs pp 
springerverlag 
winkler ed proceedings international workshop software version configuration control germany 
teubner verlag 
ian sommerville ed software configuration management icse scm workshop lncs berlin germany mar :10.1.1.45.5819
springer verlag 
walter tichy ed configuration management vol 
trends software john wiley sons new york 
jacky estublier ed software configuration management lected papers scm scm lncs seattle washington apr 
springer verlag 
bjorn received dr ing phd gian institute technology developing version engine 
continued researcher developing working related project 
joined telenor software developer employed senior engineer systems development center trondheim designed implemented house testing tool parallel dbms 
