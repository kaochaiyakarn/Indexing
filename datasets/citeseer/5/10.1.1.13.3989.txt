causality tracking causal message logging protocols lorenzo alvisi university texas austin department computer sciences austin texas bhatia entropia la jolla california keith marzullo university california san diego department computer science engineering la jolla california casual message logging protocols attractive properties introduce blocking send additional messages sent application create orphans 
causal message logging require casual ects deliveries messages tracked 
information concerning causality tracking piggybacked application messages amount information large 
study cost tracking causality causal message logging protocols 
track causality accurately possible requires piggybacking considerable amount additional information 
reduce amount piggybacked information message reducing accuracy causality tracking 
causal message logging may piggyback reduced amount information messages 
specify di erent methods tracking causality representing natural choice speci cation causal message logging 
describe methods implemented compare terms large piggyback load impose 
load depends application causal message logging 
characterize applications agiven method smallest piggyback load study simulation size piggyback load di erent models applications 
message logging common technique build systems tolerate process crash failures 
protocols require process periodically record local state log messages received recording state 
process crashes new process created place new process appropriate recorded local state sent logged messages order originally received 
message logging protocols implement abstraction resilient process crash process translated intermittent unavailability process 
message logging protocols require state recovered process consistent states processes 
consistency requirement usually expressed terms orphan processes surviving processes state inconsistent recovered state crashed process 
message logging protocols guarantee careful logging somewhat complex recovery protocol recovery process orphan 
message logging protocols pessimistic example optimistic example causal :10.1.1.134.8089
pessimistic protocols causal protocols create orphans optimistic protocols log synchronously stable storage 
able piggybacking information ambient message tra causal message logging protocols track causal ects message deliveries 
number concurrent crash failures tolerated 
generic causal message logging protocol tracks causality determine information needed recovery delivered recorded independently failing processes 
study cost tracking causality causal message logging protocols 
easy problem address 
track causality accurately possible requires piggybacking application messages considerable amount additional information 
reduce amount piggybacked information message reducing accuracy causality tracking 
causal message logging may piggyback reduced amount information messages protocol may learn slowly recovery information replicated times 
understanding method piggybacks information situation important reasons 
interesting question tradeo complex temptation accurate possible little information possible track causality 
shows times best choice terms message size 
second environments embedded systems mobile systems bandwidth limited 
systems limiting size messages important 
third signi cant cost protocol assembling processing disassembling message 
piggybacking information messages way improve performance causal message logging protocol 
consider di erent methods tracking causality 
represent natural choices speci cation causal message logging 
published causal message logging protocols track causality methods 
describe methods implemented 
compare terms large piggyback load impose 
load application dependent characterize applications method smallest piggyback load study simulation size piggyback di erent models applications 
consider ect piggyback load processes periodically checkpoint states 
frequent checkpointing reduce piggyback load doesn need track causality events prior checkpoint 
frequent checkpointing imposes kind overhead 
results illustrative executions checkpointing relatively infrequent 
protocol run crashed process recovers 
protocols recovery protocol 
discussion recovery actual recovery protocol 
proceeds follows 
section model section specify causal message logging 
section develops causal message logging protocols identi es classes applications simplest protocol cient terms piggyback overhead 
section measure compare piggyback overheads application 
section concludes 
system model assume system processes communicate exchanging messages 
system asynchronous exists bound relative speeds processes bound message transmission delays global time source 
execution system represented arun irre exive partial ordering send events receive events local events ordered potential causality 
delivery events local events represent delivery received message application applications running process 
message process process delivers received delivers 
point time state process mapping program variables implicit variables program counters current values 
assume state process include state underlying communication system queue messages received delivered process 
states sp sq processes respectively say sp sq simply mutually consistent messages delivered execution sp sent execution sq vice versa 
collection states process consistent global state pairs states mutually consistent inconsistent 
assume processes piecewise deterministic nondeterminism process arises nondeterministic order messages received delivered 
natural think execution process partitioned intervals interval de ned initial state process delivery message 
interval called state interval 
rst state state interval message delivery de nes interval rest states interval uniquely determined process 
message delivered process receive sequence number denoted rsn represents order delivered rsn th message delivered 
state interval initiates delivery denoted equal rsn 
state interval de ned interval states initial state state immediately delivery rst message 
assume processes fail independently fail model xed set processes belong system known processes channels point point fifo fail intermittently losing messages 
speci cation causal message logging assumption processes piecewise deterministic non deterministic choices execution concern order messages delivered processes 
recover process state nondeterministic choices process recovery failing 
need represent order message deliveries 
message delivered run source ssn denote respectively identity process unique identi er assigned sender 
may example sequence number 
deliver dest denote event corresponds delivery message process dest 
tuple hm source ssn dest unequivocally determines order delivered dest 
refer tuple determinant event deliver dest depend denote set processes state re ects delivery message formally depend def dest delivered deliver dest deliver denotes happens relationship 
log denote set processes maintain copy address space particular process dest member log delivers showed property ensures su cient information available avoid creation orphans depend log temporal operator 
say stable denoted stable lost crashes 
property need hold messages determinant stable 
showed property ensures set crashed processes lead creation orphans stable depend log determinants kept stable memory stable holds write stable memory completes 
determinants kept volatile memory assume processes fail concurrently stable holds long processes copy volatile memory 
case property written jlog depend log property allows log grow arbitrarily larger depend allows protocols disseminate large number unnecessary copies number delivery events performed run increases extra copies may wasting signi cant portion address spaces processes system 
order address problem consider protocols implement strengthening property jlog depend log depend log temporal eventually operator 
characterization strongly couples logging causal dependency deliver events 
requires long jlog processes delivered application message sent causally delivery stored copy ofm determinant 
processes stored copy ofm determinant eventually deliver application message sent causally delivery call protocols implement property causal message logging protocols 
family logging family logging fbl logging technique implements property conceptually process maintains volatile storage set determinants dlp called determinant log de ned follows def dlp depend dlp contains determinant delivery events causally precede current state 
denote subset dlp know 
sends message process process piggybacks determinants log 
fundamental issue implementing fbl process determines log determinant received 
general may know exact values log jlog estimate values 
denote estimated values log jlog log jlog respectively 
estimating log jlog satisfy property overestimate log jlog underestimates jlog may needlessly piggyback determinants stable making messages average signi cantly larger 
exchanging information processes improve accuracy estimates avoid piggybacking useless data piggybacking extra information turn messages signi cantly larger 
basic piece information jlog gained process delivers message delivers knows log 
pieces information jlog piggybacked messages 
natural pieces information receives process safely infer log contains process dest original destination message process 
jlog receipt jlog safely infer jlog smaller jlog receives rst time safely infer jlog equal jlog counted jlog note scheme allows infer value jlog safely knowing identity processes log 
log receipt log process safely infer log equal union current log accordingly 
scheme process sends estimate log process providing union estimates relative computed processes causal path connects process dest process de ne protocol di erent information exchange schemes 
def log set determinants know 
send message protocols piggyback follows conceptually simple somewhat cumbersome generalize discussion fbl implements general version property uses general predicate stable jlog simplify exposition 
det process piggybacks determinants onm jlogj determinant process piggybacks jlog log determinant process piggybacks log furthermore protocols receives acknowledgment message adds log determinant piggybacked causal message logging protocol manetho essentially det manetho assumes total failures possible means determinant stable process piggybacks message copy know copy protocols de ned process piggybacks information determinants 
disseminate quickly determinant stable process piggyback additional information 
protocols analogous det jlog log piggyback information 
suppose sends message protocols piggyback asfollows det process piggybacks data det addition informs determinants dlp stable 
jlogj process piggybacks data jlogj 
addition jlog jp increased time piggybacked piggybacks jlog jp log process piggybacks data log 
addition log increased time piggybacked piggybacks log comparison protocols protocols piggyback di erent amounts information estimate log jlog di erently 
examine di erences 
accuracy log jlog execution shown illustrates di erences det jlog log respect accurately estimate log jlog deliver event executed process pi protocols show log pi jlog pi receipt message protocols yield estimates log jlog receives protocols compute di erent estimates log det receipt copy piggybacked message process concludes addition log include process source process dest 
process sets log fp 
equate stable jlog manetho message logging protocol determinant stable writing suitable implementation stable storage disk 
log pi jlog det jlogj log 
jlog previous case process sets log fp 
rst time receives log sent 
jlog infer jlog 
log process receives log addition concludes log include andp jlog 
comparison log log 
log provides accurate assessment log jlog log allow process conclude jlog 
bene ts extra information exchanged protocol log evident process receives message point log accurate determination jlog parallel solution synthetic aperture radar problem 
protocols det jlog log similar det jlog log provide better estimates log jlog example illustrating di erence log log 
assume 
determinant stable receives 
protocol log subsequently sends mis piggybacked message carry log protocol log piggybacks log stable 
protocol log message sent contain piggybacked value protocol log 
similar scenarios constructed pairs protocols 
consider execution shown 
long jlog small protocols estimates log 
suggests small values det piggybacks possible amount information message 
examine hypothesis section 
applications det performs log large values example shows application det log application parallel solution synthetic aperture radar problem sar radar echoes collected aircraft spacecraft construct terrain contours 
steps necessary producing high quality images sar data consist sequence computations dimensional discrete fourier transform binary convolution dimensional inverse discrete fourier transform intensity level normalization visualization 
purposes important property note data ows particular manner 
characterize applications det performs log represent application pattern communication channel graph 
application associated channel graph directed graph 
nodes represent processes sources application messages received environment destinations application messages sent environment edges represent direction application messages sent 
de nition channel graph shortcut free acyclic pairs nodes paths length 
channel graph shortcut free 
theorem characterizes set applications det performs log channel graph obtained assuming log estimates log pi better det theorem shortcut free channel graph run protocol det piggybacks message determinants protocol log proof antecedent property trivially true fbl protocol process piggyback determinant sending message depend log depend depend speci cs particular fbl protocol determined solely application messages 
prove theorem showing log det log log assume log log log piggybacks superset information piggybacked det log estimate log accurately det log det subset log log log det assume log det log hold log exist causal path node node carrying information 
path solely application messages channel graph contain cycle shortcut free 
dependency carried process third process furthermore det log di er acknowledgments estimate log assumption det log furthermore sent tor application message sent conclude order member log channel graph contain edge ii path iii edge shows channel graph 
show graph shortcut free observe paths di erent length connect rst consists edge second goes conclude shortcut free channel graphs det estimates log log piggyback overhead protocols det exchange information may dramatically underestimate log jlog possibly leading excessive piggybacking hand piggybacking information piggyback load message may smaller 
trade amount information carried message versus number unnecessary piggybacks 
trade complex depends application pattern communication network responsiveness delivering acknowledgments explore detail section 
simple qualitative analysis shows det jlog log amount piggybacked information proportional number determinants det jlog log information may worst case proportional number determinants dlp 
worst case bound total number delivery events causally precede sending extra information sent jlog jlog log worsen theoretical asymptotically worst case behavior fbl protocols 
practice large adding extra piggyback proportional jlog log result signi cant 
furthermore small large making det jlog log appear practical 
advantageous log represent extra information data structure size independent ofd protocol jlog easily modi ed achieve goal sorting determinants piggybacked jlog example piggyback anf element array number determinants jlog array run encoded sparse 
resulting version jlog piggybacks additional words det amount independent ofd 
drawback approach determinants sorted manner suitable compression techniques described dramatically reduce size piggyback 
furthermore approach applied jlog applied log log section introduce data structure called dependency matrix allows implement det jlog log incremental cost det independent ofd dependency tracking know property long jlog process ensures depend log 
process depend estimate log 
take advantage techniques tracking dependencies compute depend 
widely technique vector clocks 
vector clock element vector counts number relevant events causal past process de nition relevant 
vp vector clock associated process value vp counts number relevant events executed vp counts number relevant events knows executed 
relevant events ep process eq process ep eq vp ep vq eq vp ep vq eq vector clocks process execute ep eq respectively 
vector clocks easy implement 
process executes relevant event increments vp 
process executes vp set maximum previous value vp send top 
second rule requires sending process piggyback current value vector clock strom yemini rst vector clocks message logging introduced notion dependency vector 
dependency vector vector clock relevant events delivery events 
speci cally index state interval contains event receive sequence number message delivered execution highest index state interval process process depends execution event specializing equation dependency vectors get deliver deliver deliver deliver dependency vectors track arbitrary dependencies delivery events 
context fbl interested determining processes depend event deliver jlog de ne abstraction call weak dependency vector satis es weaker version condition deliver deliver jlog deliver deliver deliver deliver deliver deliver weak dependency vectors process respectively 
properties de nition depend fact depend log follows message determine depend current weak dependency vector 
particular conditions hold depend dest rsn dest rsn depend de ne useful vector clocks weaker weak dependency vectors 
example useful de ne vector clock pbc constructed set determinants piggybacked message vector clock satis es condition constructed follows pbc def largest value rsn determinants piggybacked dest determinant piggybacked dest element pbc may zero reasons messages depend messages messages knows log 
rst reason holds zero elements pbc dependency vector rst second reason hold zero elements pbc weak dependency vector 
dependency tracking proceeds follows 
process maintains dependency matrix dmatp de ned follows dmatp weak dependency vector process dmatp process estimate weak dependency vector process fpg dmatp denotes th row matrix dmatp 
process estimate weak dependency vector process lag actual weak dependency vector dmatp general able satisfy condition straightforward design update rules satisfy condition set rules 
process generates increments dmatp 
dmatp value receive sequence number vector clock update rule process executes relevant event 
sets dmatp component wise maximum current value dmatp pbc 
vector clock update rule process receives piggybacked vector clock 
pbc weak dependency vector resulting value dmatp weak dependency vector 
noted component pbc zero di erent reasons 
rst reasons hold component pbc dependency vector 
third reason holds piggybacked non zero value component weak dependency vector 
sets dmatp component wise maximum current value dmatp pbc 
doing ensures estimate dependency vector date 
pbc dependency vector resulting value dmatp dependency vector 
values sets dmatp maximum dmatp pbc 
done may learn process reaching state interval indirectly directly 
process receives acknowledgment message sets tobe component wise maximum current value 
condition simple estimate depend log log contains processes dmatp dest rsn 
process consider stable entries dmatp dest greater equal rsn 
set rules implements protocol det section describe sets rules implement det log jlog order events executed processor fact total order straightforward construct dependency matrix size np np np number processors system 
piggybacking dependency matrix turns simpler set rules implement det jlog log starting protocol working way backwards rst 
reason lies observation dependency matrix process compute log messages member depend 
implement dependency matrix message sends 
log simply piggyback implementing log update rules log follows 
process generates increments dmatp 
dmatp value receive sequence number 
sets dmatp component wise maximum current value dmatp 
values sets dmatp component wise maximum current value dmatp piggybacked 

process receives acknowledgment message sets tobe component wise maximum current value 
resulting protocol implements log piggybacks additional data det independent number determinants dlp 
implementing jlog second set update rules derive implementation jlog analogous jlog piggybacks additional data message 
consider data structure extracted dependency matrix stability matrix matrix integers 
processes highest receive sequence number message delivered jlog jp stability matrix compact way representing jlog jp speci cally rsn dest jlog jp dest rsn dest stability matrix computed directly dependency matrix 
consider column dmatp 
values column multi set receive sequence numbers messages delivered rst largest value multi set 
receive sequence number message knows delivered 
messages multi set set value may occur 
th largest value de ned recursively follows rst largest value largest value occurs th largest value st largest value multi set rst largest value removed 
rst second largest values third largest value 
delivered rsn jlog rsn jlog 

generalizing observation largest value dmatp 
protocol processes piggyback stability matrix dependency jlog matrix 
process compute accurate value 
set update rules 
process generates increments dmatp 
dmatp value receive sequence number 
consider determinant piggybacked rsn dmatp dest receiving rst time 
call determinant new determinant new log jlog set jlog 
process computes new value re ects fact 
speci cally rst sets 
determinant new lets jlog computed piggybacked stability matrix dest rsn dest 
process sets dest max dest rsn 
sets dmatp maximum current value dmatp 
sets dmatp component wise maximum current value dmatp pbc 
values sets dmatp component wise maximum current value dmatp 
brings estimate weak dependency vector date 
values sets dmatp maximum value dmatp 
sets larger current value th largest value dmatp 
rule generating stability matrix dependency matrix 
values sets component wise maximum modi ed version piggybacked obtained rule 

process receives acknowledgment message sets tobe component wise maximum current value 
implementing det protocol det requires process inform determinants stable 
recall process highest receive sequence number message delivered knows stable knows logged processes 
ful ll requirement simply piggybacking row stability matrix messages sends call vector corresponding process stability vector 
addition steps det protocol det takes steps process receives message values sets svp st largest value dmatp th column dependency matrix 
values sets svp component wise maximum current value svp piggybacked 
det management identical det det uses stability vector get accurate estimate determinants part 
determinant belong conditions hold fewer entries dmatp dest greater rsn just det rsn svp dest 
comparing piggyback overheads start comparison di erent protocols examining asymptotic piggyback overheads 
bounds expressed terms number determinants piggybacked message size determinant 
values independent larger log worst case large number receive events process execute 
additionally larger log determinant encodes source destination message hard imagine runs larger 
real implementation constant bits 
det determinants added overhead dw 
jlog piggybacked determinant message estimate jlog included 
express estimate log bits overhead log 
log piggybacked determinant message estimate log included 
estimate include process ids overhead log 
det stability vector piggybacked message 
stability vector contains elements element receive sequence number 
bits represent receive sequence number overhead 
stability matrix piggybacked message 
bits jlog represent receive sequence number overhead nf 
log dependency matrix piggybacked message 
bits represent receive sequence number overhead 
level abstraction tempted conclude example jlog better choice det tracks causality better piggybacking logarithmic number bits determinant 
huge protocols appear attractive additional number bits increase precision causal tracking det 
observations hold practice depends strongly communication pattern exhibited application 
understand relative performance di erent protocols developed synthetic application model call bbl application model 
model speci es bursty communication burstiness percentage total number processes process communicates slowly acknowledgments return latency 
construct synthetic applications di erent combinations parameters 
constructed application measure piggyback overhead protocol di erent values construct synthetic applications bbl model measure piggyback overhead fbl protocols 
applications communication structures resemble speci system structures 
bbl model bbl communication model similar models proposed example 
model assumes processes crash channels reliable maintain fifo ordering 
process alternates stages operation communication stage process sends messages computation stage process receives acknowledges messages 
communication stage process sends message process 
processes process sends messages run called neighbors run 
model parameterized tuple hn bu br li number processes system total number messages sent system 
value br determines size set neighbors 
run process assigned random set neighbors 
size set pulled restricted uniform distribution br 
example random variable br average process neighbors remaining processes 
value bu determines number messages process sends communication stage 
speci cally random variable indicates fraction neighbors process sends messages ith communication stage 
value pulled restricted uniform distribution bu 
example br average process send messages processes communications stage 
message recipients selected randomly replacement process neighbors 
value models speed underlying communication system 
parameter determines quickly average acknowledgment received sender 
time measured terms number events sender executes sending message receiving acknowledgment 
speci cally random variable determines number events processed receives acknowledgment ith message sent 
value random variable pulled restricted uniform distribution consider point dimensional space coordinates bu br communication graph run synthetic application represented partial ordering events processes generated stochastically distribution de ned tuple hn bu br li 
generating communication graphs di erent points space evaluate performance message logging protocols function parameters model 
xed number processes number messages 
larger values signi cantly change evaluation 
space reduced restricted uniform distribution uniform distribution expected value maximum value uniform distribution uniform distribution uniform distribution dimensional subspace original model axes bu br andl values range 
examine points subspace 
generated communication graphs points ran causal logging protocols values 
resulted runs 
performance protocols point space averaged communication graphs 
results accurate con dence 
small values real systems processes probability having failures small 
include allows recovery total failures 
table summarizes parameters bbl model 
parameter meaning values number processes number messages sent bu burstiness communication br communication communication latency exploring bbl space table parameters bbl model det jlogj 
questions regarding protocols log augment det jlogj log sending information stable deter 
information stable determinants reduce number piggybacked determinants 

reduction determinants lead reduction number bits piggybacked 
shows summary statistics protocol averaged sampled application space 
rst graph shows average number determinants piggybacked course run 
protocols det jlogj log send fewer determinants respectively corresponding standard protocol 
shows extra information protocols send useful 
shows cost sending extra information far exceed bene protocol det sends bits protocol det protocols jlogj log send bits corresponding standard protocol 
recall protocols det jlogj log add xed sized data structures message 
det data structure vector size jlogj matrix size log matrix size assuming bit words overhead bits 
messages sent run accumulated overhead bits 
value overhead log accounts average number bits sent 
overhead directly related clocks shown lower bound 
part bbl space consider jlogj log competitive 
det jlogj log number piggybacked determinants det jlogj log number piggybacked bits comparison performance standard vs plus protocols standard plus understand relative performance protocols compared follows point sampled bbl space counted number times protocol signi cantly outperformed 
protocol signi cantly outperformed piggybacked average fewer bits con dence intervals overlap 
table shows pairwise comparison protocols 
values table represent number points bbl space protocol column outperformed protocol row 
example value rst column second row number points protocol det piggybacked average signi cantly fewer bit protocol det det det jlogj jlogj log log det det jlogj jlogj log log table pairwise comparison relative performance protocols measured total number bits piggybacked 
results show jlogj log table shows space competitive protocols 
jlogj outperforms log expected log small 
competitive exclude protocols jlogj rest discussion concentrate performance remaining protocols 
protocol det table shows points sampled protocol piggybacks signi cantly fewer bits det suggests knowledge application characteristic known det choice 
det baseline protocol 
piggyback overhead det function normalized manetho piggyback overhead 
regression equation number bits piggybacked det number bits bu br cdet squared signi cance test regression 
regression equation suggests performance det dominated value protocol 
recall manetho essentially det instantiated di erence number piggybacked bits det piggybacks number bits manetho 
high sensitivity tof det appears piggyback fewer bits manetho small 
examines issue 
gure compare number piggybacked bits det manetho function gure shows protocol det sends fewer bits manetho 
performance gains decrease increases 
show section artifact relatively small det relative inaccuracy tracking causality take long determinant piggybacked substantial fraction processes 
regression equation shows det relatively insensitive latency underlying communication system moderately sensitive size communication neighborhood burst frequency 
sense intuitively 
neighborhood size small processes send messages recipients resulting tighter synchronization 
process sent determinant neighbor needs send neighbor 
size neighborhood small neighborhood quickly saturated determinant 
reasoning sensitivity similar 
parameter high processes broadcast messages high percentage neighbors saturating neighborhood 
write equation terms ranges independent variables 
cases process piggybacks determinant log bu br performance log protocol jlogj performance protocol jlogj statistically indistinguishable baseline det extra integer determinant piggybacked jlogj reduce number piggybacked determinants communication graph long linear paths 
sampled applications linear paths process sends messages round 
jlogj able send fewer determinants det reduce extra cost associated protocol 
fact argue table det slightly better jlogj points det signi cantly outperforms log points jlogj signi cantly outperforms log 
similarly det better comparison det jlogj 
protocol log shows extra information carried log reduces number piggybacked determinants compared det looking pairwise comparison log det see points log statistically indistinguishable det points log performs signi cantly worse det shows breakdown points log performs poorly function br bu latency 
gure shows performance log compared det linearly correlated br 
br increases cases log performs poorly 
addition log ected thevalue sampled points log performs worse det shows performance log independent latency indeterminate respect bu 
protocol det det indistinguishable det runs 
points det signi cantly worse det shows relative performance varies function dimensions 
protocol log det inversely sensitive br 
relatively better low values log client server model det perform bbl model processes communicate asynchronously bursty manner 
unusual scienti applications applications synchronous communications 
construct additional synthetic applications 
application uses processes 
cs application client server communication structure 
process chosen random replacement processes 
chosen process sends message bu br performance det process chosen randomly replacement 
message chain continues processes selected 
twentieth process sends reply message nineteenth process 
reply chain continues rst process receives reply message 
process generating request reply chains depth repeated times 
cs application client server communication structure 
generating chains length application generates ternary trees depth containing processes 
non leaf process sends messages processes chosen random replacement 
leaf process immediately sends reply parent non leaf process sends reply parent receives replies children 
application generates trees 
sg application group communication structure 
process chosen random replacement 
chosen process selects processes sends message waiting acknowledgments degree tree depth constructed 
process sends reply original process 
original process receives replies new tree randomly chosen process constructed 
application generates trees 
applications repeatedly generate trees trivially shortcut free 
simple pattern tempted conclude det best protocol 
figures show log performs signi cantly better protocols smallest values gure shows piggyback overhead protocols det jlogj log det function 
reason behavior communication graph fact tree process receives message iteration may iteration send message determinant may follow complex path saw bbl model situation log performs 
addition manetho performs relatively poorly comparison processes 
det det ectively piggybacks determinants sg log det poorly 
det jlogj det similar piggyback loads larger values fact piggyback load jlogj protocols reached piggyback load sg process root tree quickly learns determinants piggybacks logged di erent processes 
smaller values additional information provided jlogj helpful spreading fact determinant stable larger values determinants spread quickly system case det best 
bits bits det log log det piggyback overhead cs function det log log det piggyback overhead cs function bits discussion det log log det piggyback overhead sg function results simulations speci application models run 
general intuition help application programmers choose protocols 
plus protocols theoretically attractive convey information representation size independent number determinants piggybacked message 
results simulations indicate situations log appropriate 
jlogj protocol performs similarly jlogj det somewhat better average fanout messages low small 
known application fanout low log logical choice better case sensitive tof 
recommendations change larger values patterns communications 
issue worth studying results change frequency checkpointing 
frequent checkpointing occurs determinants stable checkpointing 
frequent checkpointing imposes overhead storage computation 
causal message logging protocols process tracks causality estimate number identities processes store copy determinant 
shown tradeo excess piggybacking due inaccurate causality tracking extra piggybacked information increase accuracy causality tracking complex application speci situations fbl protocols best choice respect piggyback overhead heuristics protocols 
choice comes simplest protocol det accurate protocols log 
piggyback overhead causal logging large understanding reduce piggyback overhead important 
reduction accomplished compressing information piggybacked see example 
don believe compression change relative rankings various fbl protocols 
considerable locality communications patterns large parts dependency matrix may change frequently compression dependency matrix di erence encoding log competitive 
question related concerning compression stability matrix best explored considering real synthetic applications 
piggyback overhead metric compare di erent fbl protocols 
example overhead processing individual determinants may protocols log advantageous 
detailed comparison depend speci environmental factors relative processor speed respect communication bandwidth overhead frequency checkpointing 
putting results broader context causal message logging protocols related causal multicast turn related global state detection 
protocols track causal dependencies implement level distributed knowledge execution history application 
example showed acausal message logging protocol derived starting causal multicast 
casual message logging ensures process stored locally nondeterministic choices causal past process 
simple extension causal message logging allow process locally important events causal past available debugging global state detection purposes 
tradeo explored useful studying protocols build causality tracking 
simulator data generated analysis available authors request 
acknowledgments bruce hoppe fred schneider help re ning ideas chiu alessandro detailed comments 
elnozahy comments earlier draft helping implementation details manetho 
anonymous referees careful reading constructive criticism original manuscript 
venkatesan 
optimal algorithm distributed snapshots causal message ordering 
information processing letters june 
alvisi 
understanding message logging paradigm masking process crashes 
phd thesis cornell university department computer science january 
alvisi hoppe marzullo 
nonblocking orphan free message logging protocols 
proceedings rd fault tolerant computing symposium pages june 
alvisi marzullo 
message logging pessimistic optimistic causal optimal 
ieee transactions software engineering february 
borg 
message system supporting fault tolerance 
proceedings symposium operating systems principles pages 
acm sigops october 
chandy lamport 
distributed snapshots determining global states distributed systems 
acm transactions computer systems february 
srinivasan vaidya das 
communications characterization methodology parallel applications 
proceedings third international symposium high performance computer architecture pages february 
elnozahy 
personal communication september 
elnozahy alvisi wang johnson 
survey rollback recovery protocols message passing systems 
technical report cmu cs carnegie mellon university 
elnozahy zwaenepoel 
manetho transparent rollback recovery low overhead limited rollback fast output commit 
ieee transactions computers may 
johnson zwaenepoel 
sender message logging 
digest papers th annual international symposium fault tolerant computing pages 
ieee computer society june 
johnson zwaenepoel 
recovery distributed systems optimistic message logging checkpointing 
journal algorithms 
lamport 
time clocks ordering events distributed system 
communications acm july 
marzullo 
detection global state predicates 
proceedings fifth international conference distributed algorithms pages october 
massonet 
synthetic aperture radar new processing concepts 
proceedings th international geoscience remote sensing symposium pages may 
mattern 
virtual time global states distributed systems 
cosnard editor parallel distributed algorithms pages 
elsevier science publishers 
powell presotto 
publishing reliable broadcast communication mechanism 
proceedings ninth symposium operating system principles pages 
acm sigops october 
rao alvisi vin 
cost recovery message logging protocols 
ieee transactions knowledge data engineering march april 
schneider 
byzantine generals action implementing fail processors 
acm transactions computer systems may 
schwarz mattern 
detecting causal relationships distributed computations search holy grail 
distributed computing 
singh rothberg gupta 
modelling communications parallel algorithms fruitful interaction theory systems 
proceedings sixth acm symposium parallel algorithms architectures pages june 
sistla welch 
cient distributed recovery message logging 
proceedings eighth symposium principles distributed computing pages 
acm sigact sigops august 
strom 
optimistic recovery distributed systems 
acm transactions computer systems april 
strom bacon yemini 
volatile logging fault tolerant distributed systems 
proceedings th annual international symposium fault tolerant computing pages 
van renesse 
bother catocs 
operating systems review january 
venkatesan juang 
cient algorithms optimistic crash recovery 
distributed computing june 

