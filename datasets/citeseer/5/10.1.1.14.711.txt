software practice experience vol 
april generic interpretation algorithms prolog optimization techniques experimental evaluation vincent le charlier didier roland university namur rue namur belgium pascal van hentenryck brown university box providence ri summary efficient implementation generic interpretation algorithms prolog reconsidered 
new optimization techniques proposed applied original algorithm dependency clause prefixes caching operations 
improvement avoids re evaluating clause prefix value depends updated 
second improvement consists caching operations substitutions reusing results possible 
algorithm optimization techniques implemented lines code tested large number prolog programs compared original implementation domain containing modes types sharing 
conjunction refinements domain algorithms produce average reduction cent computation time 
extensive experimental results programs including computation times memory consumption hit ratios caches number operations performed time distribution 
main result improved algorithms exhibit efficiency specific tools despite fact domain sophisticated accurate 
operations take cent computation time indicating overhead control limited 
results simpler domain show extremely basic domains benefit optimizations 
general purpose character optimizations discussed 
key words interpretation prolog fixpoint algorithm experimentation languages performance 
interpretation general methodology obtain systematic way tools analyse programs statically compile time 
basic idea interpretation approximate usually undecidable properties done vincent didier roland visiting brown university 
author correspondence directed 
received december john wiley sons revised december domain actual domain computation 
consequence program approximated meaning hopefully capturing interesting properties leaving irrelevant details possible 
interpretations prolog attracted researchers years 
motivation works stems need optimization prolog compilers high level languages large potential optimization semantic features logic languages amenable optimization 
mellish probably define interpretation framework prolog motivated early analysis tools prolog programs 
subsequently frameworks developed variety domains proposed cater various program analysis tools involving modes types occur check garbage collection static detection parallelism program specialization name 
relatively little attention devoted generic interpretation algorithms authors proposed precise sketches algorithms 
experimental results available assess practicability interpretation approach prolog 
rare papers topic describes efficiency accuracy analysis tools shows tools fact practical terms efficiency terms usefulness results 
unreasonable infer viability generic interpretation prolog programs tools analysed specialized targeted specific applications 
part research devoted demonstrating practicality area research 
starting point design generic interpretation algorithm complexity analysis 
algorithm initially motivated top algorithm focusing relevant parts fixpoint necessary answer user query 
polynomial worst case linear sizes domain prolog program interesting cases 
algorithm instantiation sophisticated domain derived containing modes types sharing aliasing implemented pascal run large number programs 
experimental results shown practical value algorithm indicated interpretation competitive specialized algorithms reported 
reconsider problem implementing efficiently generic interpretation algorithms prolog 
propose new optimization techniques original algorithm dependency clause prefixes caching operations 
improvement avoids re evaluating clause prefix value depends updated 
consequence generalizes dependency graph proposed avoids re evaluating clauses part clauses unnecessarily 
second improvement consists caching operations substitutions reusing results possible 
garbage collection performed substitutions longer 
improvement subsumes sense improvement computation time consumed operations 
executing clause prefixes cached operations requires negligible amount time 
caching allows sharing results independent computations albeit higher generic interpretation algorithms cost memory 
case finite domains implies number operations performed algorithm bounded number program points times number times associated operations executed worst case square domain size 
optimization techniques fact general purpose languages approaches 
algorithms original algorithm improvement implemented lines code 
tested large number prolog programs compared original implementation 
conjunction refinements operations implementation produce average reduction cent computation time 
extensive experimental results programs including computation times memory consumption hit ratios caches number operations time distribution 
main result improved algorithms exhibit efficiency specific tools warren debray hermenegildo despite fact domain including types sharing sophisticated accurate 
operations take cent computation time indicating overhead control small compared operations 
means algorithm close optimality computing semantics results simpler domain show extremely basic domains benefit optimizations 
rest organized way 
section gives overview original interpretation algorithm main domain experiments 
section presents clause prefix improvement section presents caching improvement 
section devoted experimental results algorithms 
section discusses apply optimizations contexts 
section contains research directions 

preliminaries 
normalized logic programs original generic interpretation algorithm underlying semantics defined normalized logic programs 
normalized logic programs suggested greatly simplifies semantics algorithm implementation 
presents normalized version classical list concatenation program generated implementation 
normalized programs built ordered set variables xn 
variables called program variables 
normalized program set clauses called head body 
clause contains variables variables necessarily head clause course demanding semantics imagined 

example normalized program append atom xi predicate symbol arity subgoals body clause form xi xim im distinct indices xi xi xi xi xim function arity im distinct indices 
form called procedure call 
second third forms called builtins enable unification achieved 
additional built predicates arithmetic primitives accommodated framework discussed simplicity 
difficult matter translate prolog program normalized version 
advantage normalized programs comes fact input output substitution goal expressed terms variables xn 
greatly simplifies traditional problems encountered renaming 

operations substitutions define semantics denote ud underlying domain program set pairs predicate symbol arity substitution variables xn 
substitutions variables xn elements complete partial order 
asd 
set variables 
need number operations substitutions 
operations defined informally 
contains precise specification operations terms concretization function see 
substitutions denoted greek letters 
call couple association substitution predicate symbol 

sat possibly subscripted superscripted represent sets tuples 
note substitutions represent sets concrete substitutions 
operations follows 
union substitutions operation returns substitution representing substitutions generic interpretation algorithms satisfying compute output procedure outputs clauses 

ai var substitution operation returns substitution obtained unifying variables 
goals form normalized programs 

ai func substitution function symbol arity operation returns substitution obtained unifying 
goals normalized programs 

substitution clause containing variables operation returns substitution obtained extending accommodate new free variables clause 
entry clause include variables body head 
logical terms operation operation achieves role existential quantifier 

substitution clause variables head variables clause operation returns substitution obtained projecting variables 
exit clause restrict substitution head variables 

substitution goal im im operation returns substitution obtained projecting xi xi obtaining expressing terms xm mapping xi xk 
execution goal body clause 
resulting substitution expressed terms way input output substitutions domain 

extg substitution variables clause appears goal im im im substitution representing result operation returns substitution obtained extending take account result goal execution goal propagate results goal substitution variables clause 

extend sat substitution predicate symbol set tuples sat contain domain returns set tuples sat containing domain 
value sat defined lub upper bound sat 

adjust sat represents new result computed pair returns sat sat updated new result 
precisely value sat equal lub sat values left unchanged 
algorithm slightly general version adjust addition new set tuples returns set pairs values updated 

goal dependencies operations necessary design algorithm 
main concerns design algorithm detection redundant computations 
redundant computations may occur variety situations 
instance value pair may reached definitive value value fixpoint subsequent considerations look value starting subcomputation 
important case especially logic programming mutually recursive programs 
programs algorithm reconsider pair elements depending updated 
words keeping track goal dependencies may substantially improve efficiency classes programs 
algorithm includes specific data structures maintain goal dependencies 
introduce basic notions 
definition dependency graph set tuples form lt lt set qn exists lt lt dp 
denote dp set lt lt dp exists 
denote dom dp set lt dp codom dp set exists tuple lt dp satisfying lt basic intuition dp represents point set pairs depends directly complete need define transitive closure dependencies 
definition dp dependency graph assume dom dp 
set trans dp dp smallest subset codom dp closed rules 
dp trans dp dp 

dp dom dp trans dp dp trans dp dp 
trans dp dp represents pairs updated require reconsidering 
reconsidered pairs updated 
position specify operations needed algorithm 
remove dp modified dp modified list pairs pn dp dependency graph removes dependency graph elements lt pi trans dp dp 

ext dp dp inserts element dp 

add dp dp simply updates dp include dependency 
execution dp 
algorithm sure elements need reconsidered dom dp 
generic interpretation algorithms 
generic interpretation algorithm position generic interpretation algorithm 
algorithm composed procedures shown 
top level procedure procedure solve input substitution predicate symbol returns set tuples sat containing belonging fixpoint final dependency graph 
results straightforward compute set pairs values fixpoint substitutions program point 
procedure solve call receives inputs substitution associated predicate symbol set suspended pairs sat dependency graph dp 
set suspended contains pairs subcomputation initiated completed 
procedure responsible considering reconsidering pair updating sat dp accordingly 
core procedure executed suspended domain dependency graph 
suspended subcomputation initiated 
domain dependency graph means elements depending updated 
new computation initiated 
subcomputation may extend sat time considered 
core procedure repeat loop computes best approximation elements suspended set 
local convergence attained domain dependency graph 
iteration loop amounts executing clauses defining computing union results 
result produced greater comparable current value set tuples updated dependency graph adjusted accordingly 
note call clauses done extended suspended set subcomputation started 
note executing clauses dependency graph updated include guaranteed domain dependency graph point 
removed domain dependency graph execution loop pair depending updated 
procedure solve clause executes single clause input pair returns substitution representing execution clause pair 
begins extending substitution variables clause executes body clause terminates restricting substitution variables head 
execution goal requires steps restriction current substitution ext variables giving aux execution goal aux producing int propagation result int ext 
goal concerned unification operations ai var ai func 
procedure solve call called result looked sat 
domain dependency graph necessary add new dependency 
means needs reconsidered anyway dependency recorded 

generic algorithm generic interpretation algorithms 
widening case infinite domains algorithm may terminate 
guarantee termination algorithm extended widening technique 
modification occurs procedure solve goal new instruction widen suspended inserted 
set suspended viewed stack version order elements important widening 
function widen defined follows function widen new suspended old get previous suspended widen old new function get previous returns substitution pair inserted stack suspended pair 
symbol widening operator 
definition poset 
widening operation function satisfying 
infinite sequence xi xk sequence yi increasing stationary yi yi xi 

widening operator domain independent domain dependent 
experimental results described simple domain independent operator upper bound substitutions 
domain dependent widening operators investigated preliminary results described 
important realize algorithm extended widening technique may compute fixpoint transformation may lead 
course perfectly acceptable context interpretation objective compute program meaning framework guarantees approximation 
result algorithm general narrowing techniques 
investigate point depth narrowing useful particular domain 
mainly operation extg achieves effect similar narrowing execution returns procedure call widening case extg implements called backward unification 
widening useful limit intelligent way number inputs considered 
benchmark programs widening achieves right generalizations gives better results priori restrictions granularity analysis 

overview domain section give brief overview domain experiments 
domain contains patterns subterm main arguments stored sharing value mode components 
domain sophisticated sharing domains instance mode domains instance 
best viewed abstraction domain bruynooghe janssens pattern component added 
domain fully described contains proofs monotonicity consistency 
note presentation generic instantiated variety applications 
presentation instantiation modes 
key concept representation substitutions domain notion subterm 
substitution set variables substitution associate information subterm mode gro var ground variable pattern specifies main functor subterms arguments possible sharing subterms 
note pattern optional 
omitted pattern said undefined 
addition information variable domain substitution associated subterms 
note information enables express arguments value variables bound 
identify subterms unambiguous way index associated 
subterms indices instance substitution subterms 
association indices instance mentioned previously index associated mode taken gro var gv example associations gro gro gro gro var gro pattern components possibly assigns index expression generic interpretation algorithms function symbol arity indices 
example pattern component associations sharing component specifies indices associated pattern may possibly share variables 
restrict attention indices pattern patterns express sharing information want introduce inconsistencies components 
actual sharing relation derived components 
particular example sharing couple expresses variable shares variable 
representation may difficult visualize appealing representation 
instance predicate factorize instantiated substitution represented factorize gro gro gro gro var gro sharing information 
representation argument associated mode index parenthesis subterm colon 
subterm uses representation 
execution algorithm domain append program shown 
clause prefix dependency turn optimization techniques original algorithm 
start clause prefix improvement 

motivation motivate improvement consider execution algorithm append program depicted 
iteration considers clauses 
clause produces result second clause calls recursively substitution 
current approximation result clause 
second iteration considers clauses updates approximation final value 
third iteration produce change sat algorithm terminates 
key points notice follows clause considered depend recursively call second clause reconsidered point new information may produced call solve goal comments remain valid clause call goal calling recursively append substitution 
algorithm clause prefix improvement produces exactly expected result 
original algorithm append generic interpretation algorithms depicted 
second clause considered second third iterations re execution starts recursive call 
exit prefix line simply shows substitution stage clause 
operations performed algorithm strictly necessary 
generally clause prefix improvement amounts reconsidering clauses element depend updated 
execution clause restarts goal element depends updated 
improvement avoids reconsidering prefix clause known give exactly result previous execution 
execution goal restarts clause element depends updated 
note prefix optimization independent program normalization process 
original algorithm adapted source programs normalized programs need perform head unifications subsequent iterations unifications avoided prefix algorithm 
addition optimization simply avoiding head unifications 
may entirely skip clauses prefixes clauses containing procedure calls 
consequence avoids costly operations union extg 

clause prefix algorithm append 
formalization key idea clause prefix improvement extend dependency graph clauses clause prefixes 
procedure calls produce different results execution consider clause prefixes atoms 
definition normalized clause gm successive goals body prefix clause say simply gi 
position integer goal clause denoted 
ease presentation take convention prefix say empty prefix position goal note convention prefix allows uniform definition procedure solve clause distinguish subsequent execution clause 
definition dependency graph set tuples form lt goal clause clause prefix lt set qn exists lt lt dp 
definitions previously generalized way deal clauses clause prefixes 
new operations notations defined simplify presentation algorithm 
operation add dp dp generalization add dp takes account clauses clause prefixes 
informally speaking operation updates dependency graph goal clause goal appears relevant clause prefix 
denote number procedure calls clause operation defined follows procedure add dp inout dp add dp dp add dp dp add dp dp operation ext dp replaced operations ext dp ext dp 
operation updates dependency goals clauses second operation updates dependency graph prefixes 
defined follows procedure ext dp inout dp ext dp dp generic interpretation algorithms cm clauses ext dp ci procedure ext dp inout dp ext dp note point definitions conceptual 
implementation level dependency set replaced pointers tuples tuples additional information distinguish goal clause prefix dependencies 
addition information clauses prefixes execute stored tuples 
re execution goal clauses element depend updated need reconsidered 
set clauses defined modified clauses dom dp clause 
avoid unnecessary union operations solutions possible 
solution amounts computing union re executed clauses 
requires union accumulative value function depends values arguments order computation change function applied times argument 
case domains discussed circumstances algorithm applied greatest fixpoint computation 
second solution general amounts memorizing successive values variable 
solutions implemented difference efficiency negligible captured precision clock function 
solution simplicity 
similarly execution clause starts goal updated 
index goal defined fp min dom dp avoid unnecessary computation successive values local variable ext need saved 
represent value ext execution 
operation extend generalizes operation extend initialize data structures properly procedure extend inout sat extend sat simplify algorithm function prefix defined prefix fp fp position define algorithm clause prefix improvement 
new versions procedures solve call solve clause shown 
procedure solve call modified execute clause clause belong dom dp elements depends updated 
contains generalized versions extend ext dp 
procedure solve clause modified find prefix updated associated substitution 
executes goals prefix 
procedure call encountered current value ext stored log 
addition call add dp replaced call add dp inserts dependencies goals clauses clause prefixes 
precise add implementation stores log intermediate values variable aux 
aux needs stored avoid operation goal prefix re execute 
allows gain cent execution time 
interesting point reconsider trace append shown 
iteration exactly standard algorithm 
second iteration interesting 
note clause avoided entirely contains procedure call 
second clause restarts execution immediately recursive call unifications re executed 
prefix just call shown trace restriction operation avoided 
iteration essentially similar second iteration 
note example built ins goal avoided 
general internal built ins built ins goals restrictions extensions avoided 
case simple programs qsort second subsequent iterations start recursive calls 
calls partition re executed importantly need look extension table recognize fact 
calls simply skipped 

caching operations 
motivation second improvement propose recognition operations substitutions fact time consuming operations avoided possible 
improvement extremely simple conceptually amounts caching results operations substitutions 
time operation executed program looks find operation encountered result possible 
optimization subsumes improvement previous section sense avoids computing operations redundant clauses clause prefixes addition caching enables results shared clauses practically really subsume improvement sense necessary reconsider clauses negligible cost 
generic interpretation algorithms 
algorithm clause prefix improvement substitutions represented canonical way 
immediate consequence case finite domains number operations performed algorithm bounded number program points times number times associated operations executed worst case square domain size course true substitutions fit memory simultaneously 
garbage collection automatically recover substitutions strictly necessary appearing sat 
depicts execution second improvement append program 
noticed operations clause operations recursive call second clause cached automatically reused algorithm 
particular case improvement brought caching improvement compared clause prefix optimization 
programs results shared 
important note caching technique remains useful programs normalized case prefix optimization 

caching algorithm append generic interpretation algorithms head unifications cached hit ratio lower cluster operations may unrelated 
addition operations extg union need performed unnormalized programs avoided caching optimization 
especially important extg union costly operations cost increase absence normalization 

implementation implementation caching algorithm requires main components 
memory manager substitutions 
number hashtables operation store results operations 
addition operations modified pointers substitutions guarantee inputs modified 
memory manager responsible allocating deallocating substitutions 
accessed number functions create new substitutions copy modify free 
allocation substitution occurs mainly result applying operation 
allocated substitution stored hash table subsequent requests substitution reuse 
asked allocation new substitution manager uses hash table find substitution exists case returns pointer existing substitution 
note testing entry hash table equal substitution extremely fast substitutions represented unique way 
syntactic equality operation 
garbage collection performed associating counter substitution releasing substitution longer referenced 
need garbage collection comes fact operations create temporary substitutions released 
hashing function substitution course domain specific 
current implementation includes components mode component pattern component value component 
components combined simple way multiplication exclusive 
function take account shape terms considers indices value component functors pattern component modes subterm 
experimental results shown function produces cent collisions relatively small tables entries 
including sharing component produce improvement included final implementation 
better hashing functions certainly possible probably need take account shape subterms 
current implementation collisions handled maintaining linked list substitutions entry 
operation extg unif func modified store results hash table operation performed look hash table operation performed 
hashing function simpler performed directly substitution pointers actual substitutions case memory manager 
uses multiplication pointers possibly integers 
similarly pointers substitutions need stored identify uniquely substitution 
operations worth caching 
addition operations compare substitutions compare smaller cached internal operations 
operation adjust cached owing fact internal operations cached 
task adjust find new result greater non comparable current result 
comparison cached result smaller equal needs done 
set tuples updated saving occur 
system caches operation extend special role held implementation operation 
fact operation responsible testing membership dom sat extending set tuples necessary cases returning pointer correct element set tuples 
course implies search set tuples represented hasse diagrams 
operations expressed terms pointer including operation adjust 
caching operation extend sure search avoided time time cached 

experimental evaluation section report experimental results optimization techniques 
denote respectively original original prefix caching op oc pr ca short original algorithm coded pascal original algorithm coded number optimizations domain implementation algorithm clause prefix improvement algorithm caching improvement 
section describes domain dependent optimizations performed moving pascal implementation 
section describes programs experiments section describes computation times algorithms section describes number operations substitutions performed algorithms hit ratios caches 
section depicts time distribution control operations time distribution various operations section reports memory consumption algorithms 
section gives results simple domain 

domain optimizations version algorithm contains number domain dependent optimizations 
important lazy computation representation sharing component produces cent improvement pascal version 
key idea exploit way sharing represented domain 
sharing subterms patterns undefined represented explicitly 
actual sharing relation computed combining sharing information pattern component implicitly contains sharing information 
pascal implementation actual sharing implementation represented explicitly computed operation 
consequence representation substitutions heavier increasing cost copying generic interpretation algorithms comparing substitutions cost operation 
version sharing subterms patterns undefined represented 
actual sharing computed need requested operation 
consequence representation compact operations cheaper 
improvement version low level primitives copy substitutions compare 
operations performed loops pascal version simple memory copying comparison algorithms operations revised data driven straightforward top implementations 
optimizations suggested profiling pascal version program indicate special care taken representing substitutions implementing unification 

programs programs hopefully representative pure logic programs dynamic predicates assert retract 
taken number authors various purposes compiler writing equation solvers combinatorial problems theorem proving 
representative large class programs 
order accommodate builtins provided prolog implementations supported current implementation programs extended clauses achieving effect built ins 
examples predicates achieve input output setof bagof arg functor 
clauses contain assert retract dropped program containing syntax error handling reader program 
program program plays game 
taken implements alpha beta search procedure 
program press equation solver program taken 
versions interesting program 
version standard version press second version press goal repeated program goal executed twice clause 
versions illustrate fact neglected interpretation 
precise domain requiring higher cost basic operations fact efficient fewer elements domain explored 
repetition goals press program allows simulate precise domain gain efficiency 
program cs cutting stock program taken 
program generate number configurations representing various ways cutting wood board small shelves 
program uses various ways non determinism prolog 
program disj taken generate test equivalent constraint program solve disjunctive scheduling problem 
program non determinism prolog 
program read tokenizer reader written keefe warren prolog 
mainly deterministic program mutually recursive procedures 
program pg program written older solve specific mathematical problem 
program gabriel browse program taken gabriel benchmark 
program plan pl short planning program taken 
program queens simple program solve queens table computation times algorithms percentages character version 
op oc pr ca denote respectively original algorithm pascal original algorithm prefix algorithm caching algorithm program op oc pr ca op oc op pr oc pr op ca oc ca append queens press press peep cs disj pg read gabriel plan qsort mean problem 
peep program written debray carry peephole optimization sb prolog compiler 
deterministic program 
traditional concatenation quicksort programs say append qsort difference lists 

computation times give versions computation times 
table depicts results sharing represented characters bytes table ii depicts results table ii 
computation times algorithms percentages bit version program op oc pr ca op oc op pr oc pr op ca oc ca append queens press press peep cs disj pg read gabriel plan qsort mean generic interpretation algorithms sharing represented bits 
columns computation times seconds columns improvements percentages denotes 
far character version concerned caching produces improvement cent compared original version pascal 
caching produces improvement cent compared original version programs read peep producing improvement cent disj produces best improvement cent 
times seconds press read take seconds 
prefix marginally faster caching 
produces average improvement cent original implementation cent improved implementation programs seconds prefix loses seconds big programs 
far bit version concerned caching produces improvement cent pascal implementation booleans coded bits pascal compiler cent improved implementation 
programs run seconds press read take seconds 
prefix slower average improvement cent pascal implementation average cent improved implementation 
results indicate costly operations attractive caching 
domain character implementation sharing fastest produces gain cent favour prefix bit implementation produces gain cent favour caching 
discuss result light results 
results compare specialized algorithms 
peep read pg best programs achieve respectively sun 
means algorithm respectively times faster sparc times faster 
algorithms execute sophisticated accurate domain 
particular domain includes sharing pattern information omitted 
table iii indicates gain characters bits original prefix caching sharing components 
improvement obtained fairly consistent algorithms general cent 
summary improvements produce substantial gains efficiency 
gain cent obtained implementation refining domain algorithms produce improvement cent 
depending implementation sharing component favour memory speed caching slower character version faster bit version prefix 
algorithm efficiency best specialized tools available tasks uses sophisticated domain provides accurate results see details 

number operations avoid considering specifics implementation give view efficiency algorithms number operations table iii 
percentage gained characters algorithms program original prefix caching queens press press peep cs disj pg read gabriel plan qsort mean substitutions performed various algorithms 
results summarized table iv depicted detail tables xiii appendix 
table iv contains operation benchmark programs number calls algorithms original prefix caching 
ca eval gives number calls caching really evaluated cached 
gives percentage operations saved improvements 
traditional operations extg results compare comparing substitutions returning equal smaller greater comparable smaller testing substitution smaller substitution ai test built arithmetic comparisons ai function prolog 
note operation extg performed procedure calls integrated operations unif func unif var built ins 
table iv 
number operations programs algorithms operation oc pr ca ca eval oc pr oc ca oc ca eval compare smaller extend ai test ai ai var ai func extg union generic interpretation algorithms ratio oc pr indicates percentage calls saved operations prefix original algorithm 
half operations ratio cent reaching peaks cent ai test ai time consuming operations unif var unif func extg dealing unification achieve improvements cent 
ratio oc ca eval indicates percentage executed calls saved caching 
ratios higher case prefix including peaks cent compare extend cent unification operations 
indicate confirm results previous section costly operations attractive caching 
unification instructions concerned unif var unif func extg considered caching produces cent improvement prefix cent improvement original 
overhead handling caches fits nicely results observed computation times 
ratio oc ca gives number calls operations spared caching 
caching basically calls operations original trivially performed caching case operations called inside operations 
true smaller compare number calls substantially reduced 
lowest improvement occurs extg expected instruction executed just goal 
time output tuple updated extg evaluated 
hand extend highest improvement surprising operation performed tuple considered 
important differences caching prefix appear operations union difference occurring 
result easily explained different clauses different number variables normalized versions 
result explained fact prefix fact little offer operations 
instance avoided clause reconsidered 
far individual tables concerned facts deserve mentioned 
read peculiar mainly due fact program highly mutually recursive domain particularly adequate program see discussion 
consequence requires iterations exhibits excellent ratios extend lower improvements general 
disj hand excellent ratios owing tail recursive nature substitution preserving property see 

time distribution section investigate distribution computation time various categories including time time spent operation control time total time time cache time time taken managing caches 
table describes time distribution caching 
tt total time ta time tc control time th cache time 
ta fact lower bound time operation re executed 
operations adjust extend included 
reason table distribution computation times caching 
tt ta tc th total time time spent operation time spent control time spent hashing respectively program tt ta tc th ta tt tc tt th tt queens press press peep cs disj pg read gabriel plan qsort hand operations contain suboperations included hand remaining time spent updating set tuples best considered control 
ratios ta tt tc tt th tt give percentage total time spent time control time cache time 
results indicate cent time spent operations 
pg cs demanding terms time easily explained manipulate large substitutions relatively iterations especially cs 
results indicate cache time takes significant part control time including cent press 
assuming cost implementation control part cent saved computation times 
indicates room left improvement limited 
table vi depicts results cache time original program 
indicates control time low reaching cent queens table vi 
distribution computation time original program tt ta tc ta tt tc tt queens press press peep cs disj pg read gabriel plan qsort generic interpretation algorithms table vii 
distribution computation time prefix program tt ta tc ta tt tc tt queens press press peep cs disj pg read gabriel plan qsort plan lower cent cases 
negligible times cs disj pg may explained fact programs demanding time 
comparing results caching observe control time caching grown significantly due cache time rest control time theoretically caching original 
table vii depicts results cache time prefix 
indicates expected control times smaller caching greater original 
control times closer original caching 
table viii depicts distribution time operations caching 
clearly indicates time consuming operations unif func extg confirming results previous section 
caching operations unif func extg take cent time queens cent 
operation union demanding operation far operations 
table viii 
percentage time distribution operations caching program smaller ai test ai ai var ai func extg union queens press press peep cs disj pg read gabriel plan qsort table ix 
percentage time distribution operations original program smaller ai test ai ai var ai func extg union queens press press peep cs disj pg read gabriel plan qsort table ix depicts distribution time operations original 
results indicate time consuming operations unif func extg 
results similar caching 
operations somewhat different ratios due fact unification takes time 

memory consumption tables xi depict memory consumption programs bits characters representing sharing component respectively 
field gives memory requirement interpretation includes data structures necessary parsing compiling prolog programs table memory consumption results bit representation sharing 
memory kb program original prefix caching pr oc ca oc ca pr max max max append queens press press peep cs disj pg read gabriel plan qsort mean generic interpretation algorithms table xi 
memory consumption results character representation sharing 
memory kb program original prefix caching oc pr oc ca pr ca max max max append queens press press peep cs disj pg read gabriel plan qsort mean sizes hash tables case caching 
max field gives maximum memory requirement execution program 
memory demanding program press 
requires kilobytes original prefix caching 
average prefix requires twice memory original reaches peaks times read press time consuming programs 
caching requires times memory original average reaches peak thirteen times read caching requires times memory prefix ratios lower demanding programs 
characters press requires kilobytes original prefix caching 
average prefix requires times memory original times read press 
caching requires times memory original average reaches peaks read caching requires times memory prefix times press read 
note percentage memory saved bits characters represent sharing component cent versions 

results simpler domain section report experimental results simpler domain mode domain reformulation domain 
domain viewed simplification domain discussed far pattern information omitted sharing simplified equivalence relation operations fact significantly different 
high ratios qsort queens significant initialization takes memory 
note average better initialization effect 
operations simpler loss accuracy significant 
efficiency results illustrate potential improvements unfavourable conditions 
table xii depicts efficiency results programs bit character representations sharing 
bit version prefix reduces computation cent compared original caching produces cent improvement 
improvements remain significant improvements prefix caching sophisticated domain cent respectively 
character version larger difference efficiency prefix caching 
prefix brings cent improvement caching improves original cent 
note computation times significantly reduced compared sophisticated domain times seconds 
results indicate potential improvements small simple domains 
gives confirmation simpler domain interesting prefix 

discussion research section discuss various issues possible extensions directions research 
discussion informal preliminary tentative points open issues possible solutions 

caching main advantages caching technique generality added easily interpretation algorithm fixpoint semantics 
useful analysis procedural functional parallel languages 
example caching re interpretation algorithm interleaves fixpoint computations dynamic 
caching taken panacea 
effectiveness depends factors 
control time algorithm negligible respect time spent operations 

percentage recomputed operation calls sufficiently high 

overhead due caching technique significantly lower gain due non recomputing operations 
experimental results mentioned caching appealing cost operations high 
true hit ratio caches remains reasonably high point 
interesting issue evaluate impact caching domain prop contains costly operations differs substantially domains 
cost operations small overhead caching may reduce interest point 
caching reduce control time contrary prefix point 
caching greedy memory prefix optimization 
drawback overcome designing sophisticated memory manager 
key idea generic interpretation algorithms table xii 
computation times percentages small domain 
bit character versions distinguished respectively program oc pr ca pr oc ca oc oc pr ca pr oc ca oc append queens press press peep cs disj pg read gabriel plan qsort mean release substitutions memory requirement high 
simple solution empty operation caches 
elaborate solution selective remove oldest substitutions closely ideas underlying virtual memory systems 

prefix second technique may specific prolog glance clause procedure concepts 
principle extended situations especially interpretation algorithm designed manually automatically 
manual design suppose semantics defined arbitrary algorithm computing functional transformation 
show algorithm generalized compute fixpoint transformation 
algorithm optimized inserting recovery points inside algorithm time algorithm called previously encountered input execution restarted recovery point information depend changes having occurred previous call 
clever specific improvements obtained analysing internal structure algorithm independent parts identified recomputed value depend improved 
partial method conceivable 
assuming semantics expressed high level language denotational style preliminary data flow analysis definition provide way decompose code transformation independent parts similar clauses prolog procedure 
providing mathematical properties operations pre analyser necessary 
note highly dynamic algorithms widening techniques substantially complicate prefix optimization 
particular computation states need saved may complicated needed algorithm 
instance non trivial clearly feasible generalize prefix optimization re execution algorithm 
open issue quantify difference caching prefix fixpoint algorithms 

combining prefix caching combination prefix caching studied experimental results inconclusive combined algorithm worse basic algorithms 
reason may prefix optimization combined caching version reduces control time generic interpretation algorithms low 
addition complicating dependency graph copying substitutions adding control time 
combination worth control time algorithm higher 

clause ordering variation algorithm consists updating set tuples clause analysis union results updating 
variant best combined clause reordering nonrecursive clauses handled 
clause reordering performed simple analysis 
combination ideas leads reduction number iterations control time algorithms really avoid operation added prefix caching algorithms 
preliminary experiments idea inconclusive gain loss efficiency negligible 
result explained fact prefix optimization viewed automatic dynamic reordering clauses prefixes re executed clause reordering remove operation 

granularity algorithm works fine granularity stores input output pairs predicate 
granularities proposed literature 
instance mellish proposes store single input output pair predicate nilsson framework preserves input output pair program point program goals 
impact granularity efficiency accuracy interpretation open issue various alternatives needs evaluated experimentally 
note coarser granularity necessarily lead better efficiency precision lost convergence fixpoint may slower 
see instance discussion topic 

reconsidered implementation generic interpretation algorithms prolog 
optimization techniques original algorithm clause prefix dependencies caching 
clause prefix dependencies amount generalizing dependency graph clauses clause prefixes caching amounts memorizing operations substitutions 
optimization techniques evaluated experimentally compared original implementation 
optimization techniques domain produce average speed cent initial implementation 
experimental results computation times number operations time distribution memory consumption algorithms compared original algorithm 
addition hit ratios caches comparisons implementations sharing component 
interesting result control part reduced cent caching indicating room left improvement 
results simpler domain indicate basic domains benefit optimization prefix improvement reduces computation times cent 
fully clear optimization techniques valuable practice 
clause prefix improvement advantage simplicity memory consumption 
caching algorithm reused easily contexts requires memory 
attempts combine improvements turned unsuccessful combined algorithm worse basic algorithms 
belief caching attractive sophisticated domains prefix simpler domains 
research experimentation domains help answering question identify peculiarities domains 
saumya debray leon sterling provided programs experiments 
research partly supported belgian national incentive program fundamental research artificial intelligence le charlier national science foundation number ccr office naval research arpa order 
pascal van hentenryck 

le charlier van hentenryck generic interpretation algorithm complexity analysis extended eighth international conference logic programming iclp paris france june 

le charlier van hentenryck experimental evaluation generic interpretation algorithm prolog fourth ieee international conference computer languages iccl san francisco ca april 

hermenegildo warren debray global flow analysis practical compilation tool journal logic programming 

warren debray practicality global flow analysis logic programs proc 
fifth international conference logic programming seattle wa august pp 


cousot cousot interpretation unified lattice model static analysis programs construction approximation fixpoints conf 
record fourth acm symposium popl los angeles ca pp 


mellish interpretation prolog programs ellis horwood chichester pp 


giacobazzi levi general framework semantics bottom interpretation logic programs appear acm transactions programming languages systems 

bruynooghe practical framework interpretation logic programs journal logic programming 

jones semantics framework interpretation prolog ellis horwood chichester pp 


marriott bottom interpretation logic programs proc 
fifth international conference logic programming seattle wa august pp 


marriott notes tutorial interpretation logic programs north american conference logic programming cleveland ohio 

nilsson systematic approach interpretation logic programs ph thesis department computer information science linkoping university linkoping sweden december 

winsborough minimal function graph semantics logic programs technical report tr computer science department university wisconsin madison august 
generic interpretation algorithms 
debray mishra denotational operational semantics prolog journal logic programming 

mellish automatic generation mode declarations prolog programs technical report dai report department artificial intelligence university edinburgh 

bruynooghe janssens instance interpretation integrating type mode inferencing proc 
fifth international conference logic programming seattle wa august pp 


application interpretation logic programs occur check reduction proc 
esop germany pp 


winsborough bruynooghe analysis shared data structures compile time garbage collection logic programs seventh international conference logic programming iclp jerusalem israel june 

hermenegildo determination variable dependence information interpretation proc 
north american conference logic programming cleveland ohio october 

winsborough multiple specialization minimal function graph semantics journal logic programming 

bruynooghe janssen interpretation global optimization prolog programs proc 
symposium logic programming san francisco ca august pp 


codish gallagher shapiro safe approximations fixed points analysis logic programs meta programming logic programming bristol uk 

interpretation concurrent logic languages proc 
north american conference logic programming austin tx october 

le charlier van hentenryck efficient accurate algorithms interpretation prolog programs research rp university namur august 

roland interpretation prolog programs optimizations implementation de licence ma en informatique june 

le charlier van hentenryck universal top fixpoint algorithm technical report cs cs department brown university 

jacobs accurate efficient approximation variable aliasing logic programs proc 
north american conference logic programming cleveland ohio october 

interpretation de programmes prolog ph thesis university namur belgium september 

sterling shapiro art prolog advanced programming techniques mit press cambridge ma 

van hentenryck constraint satisfaction logic programming logic programming series mit press cambridge ma 

dincbas simonis van hentenryck solving large combinatorial problems logic programming journal logic programming 

le charlier van hentenryck interpretation prolog proc 
international joint conference symposium logic programming jicslp washington dc november 

fil winsborough prop propositional formulas domain groundness analysis proc 
sixth annual ieee symposium logic computer science lics pp 


le charlier van hentenryck groundness analysis prolog implementation evaluation domain prop technical report cs cs department brown university october 

marriott interpretation logic programs denotational approach appear acm trans 
programming languages 
appendix results individual operations table xiii 
number operations compare program original prefix caching calls calls pr calls eval ratio eval append queens press press peep cs disj pg read gabriel plan qsort table xiv 
number operations smaller program original prefix caching calls calls pr calls eval ratio eval append queens press press peep cs disj pg read gabriel plan qsort generic interpretation algorithms table xv 
number operations extend program original prefix caching calls calls pr calls eval ratio eval append queens press press peep cs disj pg read gabriel plan qsort table xvi 
number operations ai test program original prefix caching calls calls pr calls eval ratio eval append queens press press peep cs disj pg read gabriel plan qsort table xvii 
number operations ai program original prefix caching calls calls pr calls eval ratio eval append queens press press peep cs disj pg read gabriel plan qsort table xviii 
number operations ai var program original prefix caching calls calls pr calls eval ratio eval append queens press press peep cs disj pg read gabriel plan qsort generic interpretation algorithms table xix 
number operations ai func program original prefix caching calls calls pr calls eval ratio eval append queens press press peep cs disj pg read gabriel plan qsort table xx 
number operations extg program original prefix caching calls calls pr calls eval ratio eval append queens press press peep cs disj pg read gabriel plan qsort table xxi 
number operations program original prefix caching calls calls pr calls eval ratio eval append queens press press peep cs disj pg read gabriel plan qsort table 
number operations program original prefix caching calls calls pr calls eval ratio eval append queens press press peep cs disj pg read gabriel plan qsort generic interpretation algorithms table xxiii 
number operations program original prefix caching calls calls pr calls eval ratio eval append queens press press peep cs disj pg read gabriel plan qsort table 
number operations union program original prefix caching calls calls pr calls eval ratio eval append queens press press peep cs disj pg read gabriel plan qsort 
