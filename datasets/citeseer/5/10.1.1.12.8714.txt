david harel dexter kozen jerzy tiuryn dynamic logic david harel dexter kozen jerzy tiuryn preface dynamic logic dl formal system reasoning programs 
traditionally meant formalizing correctness specifications proving rigorously specifications met particular program 
activities fall category determining equivalence programs comparing expressive power various programming constructs synthesizing programs specifications formal systems numerous mention proposed purposes peculiarities 
dl described blend complementary classical ingredients order predicate logic modal logic algebra regular events 
components merge form system remarkable unity theoretically rich practical 
name dynamic logic emphasizes principal feature distinguishing classical predicate logic 
truth static truth value formula determined valuation free variables structure 
valuation truth value induces regarded immutable formalism relating valuations truth values 
dynamic logic explicit syntactic constructs called programs main role change values variables changing truth values formulas 
example program natural numbers changes truth value formula 
changes occur metalogical level classical predicate logic 
example tarski definition truth formula fx valuation variables natural numbers formula defined true valuation iff exists formula true valuation agrees takes value definition involves metalogical operation produces possible values operation explicit dl form program called nondeterministic wildcard assignment 
unconventional program effective quite useful descriptive tool 
conventional way obtain square root exists program dl programs class objects par formulas complete collection operators forming compound programs inductively basis primitive programs 
discuss effect execution program truth formula dl uses modal construct intuitively states possible execute starting current state halt state satisfying dual construct intuitively states halts started current state state satisfying example order formula equivalent dl formula order instantiate quantifier effectively replace nondeterministic dynamic logic assignment inside program formulas equivalent 
apart obvious heavy reliance classical logic computability theory programming subject roots thiele late advance idea formulating investigating formal systems dealing properties programs setting 
research program verification researchers notably floyd hoare manna precise development dl system carried system called algorithmic logic 
similar system called monadic programming logic developed constable dynamic logic emphasizes modal nature program assertion interaction introduced pratt background material mathematical logic computability formal languages automata program verification shoenfield logic rogers recursion theory kozen formal languages automata computability keisler infinitary logic manna program verification harel lewis papadimitriou davis computability complexity 
introductory material pertains dl authors text harel number books survey papers treating logics programs program verification dynamic logic apt olderog backhouse harel harel parikh goldblatt goldblatt cousot emerson kozen tiuryn particular chapter abbreviated summary material authors text harel refer reader complete treatment 
full proofs theorems cited chapter extensive introductory material logic complexity numerous examples exercises 
david harel dexter kozen jerzy tiuryn reasoning programs programs program recipe written formal language computing desired output data input data 
example 
program implements euclidean algorithm calculating greatest common divisor gcd integers 
takes input pair integers variables outputs gcd variable mod value expression mod nonnegative remainder obtained dividing ordinary integer division 
programs normally variables hold input output values intermediate results 
variable assume values specific domain computation structure consisting set data values certain distinguished constants basic operations tests performed values classical order logic 
program domain integers basic operations including integer division remainder tests including 
contrast usual variables mathematics variable program normally assumes different values course computation 
value variable may change assignment performed left hand side 
order notions precise specify programming language semantics mathematically rigorous way 
section give brief languages role play program verification 
states executions mentioned program change values variables runs 
freeze time instant execution program presumably read values variables instant give instantaneous snapshot information need determine computation proceed point 
leads concept state intuitively instantaneous description reality 
formally define state function assigns value program variable 
value variable belong domain associated dynamic logic logic function called valuation 
instant time execution program thought state determined instantaneous values variables 
assignment statement executed say state changes new state new value values variables 
assume change takes place instantaneously note mathematical abstraction reality basic operations take time execute 
typical state gcd program say second third components sequence denote values assigned respectively 
ellipsis refers values variables care occur program 
program viewed transformation states 
initial input state program go series intermediate states eventually halting final output state 
sequence states occur execution program starting particular input state called trace 
typical example trace program consider initial state suppress ellipsis 
program goes sequence states value output state gcd 
binary relation consisting set pairs form input state output state occur execution program words set states traces called input output relation example pair member input output relation gcd program pair 
values variables changed program 
values output state input state 
example may think variables input variables output variable variable formally distinction variables including ones occurring program 
programming constructs subsequent sections consider number programming constructs 
section introduce constructs define general classes languages built 
general programs built inductively atomic programs tests various program operators 
david harel dexter kozen jerzy tiuryn programs popular choice programming language literature dl family deterministic programs 
language natural abstraction familiar imperative programming languages pascal different versions defined depending choice tests allowed nondeterminism permitted 
language programs defined inductively 
atomic programs atomic tests program constructs forming compound programs simpler ones 
propositional version dynamic logic pdl atomic programs simply letters alphabet 
pdl abstracts away nature domain computation studies pure interaction programs propositions 
order versions dl atomic programs simple assignments variable term 
addition nondeterministic wildcard assignment nondeterministic choice construct may allowed 
tests atomic tests propositional versions simply propositional letters order versions atomic formulas terms ary relation symbol vocabulary domain computation 
addition include constant tests 
boolean combinations atomic tests allowed adds expressive power 
versions dl called poor test 
complicated tests included 
versions dl called rich test 
rich test versions families programs tests defined mutual induction 
compound programs formed atomic programs tests induction composition conditional operators 
formally test programs programs necessary 
gcd program example example program 
semantics constructs defined correspond ordinary operational semantics familiar common programming languages 
regular programs regular programs general programs 
advantage regular programs reduce relatively complicated dynamic logic program operators simpler constructs 
deductive system comparatively simpler 
incorporate simple form nondeterminism 
set atomic programs tests set regular programs defined follows atomic program program ii test 
program iii programs program iv programs program program program 
constructs intuitive meaning atomic programs basic indivisible execute single step 
called atomic decomposed 
ii program 
tests property holds current state 
continues changing state 
blocks halting 
iii operator sequential composition operator 
program means 
iv operator nondeterministic choice operator 
program means nondeterministically choose execute 
operator iteration operator 
program means execute nondeterministically chosen finite number times 
keep mind descriptions meant intuitive aids 
formal semantics section programs interpreted binary input output relations programming constructs operators binary relations 
operators may familiar automata formal language theory see kozen interpreted operators sets strings finite alphabet 
language theoretic relation theoretic semantics share common fact equational theory shown kozen operators deterministic programs defined terms regular operators def 
def 
class programs equivalent subclass regular programs program operators constrained appear forms 
david harel dexter kozen jerzy tiuryn recursion recursion appear programming languages forms 
manifestations recursive calls stacks 
certain general conditions constructs simulate 
shown recursive programs programs equally expressive natural numbers arbitrary domains programs strictly weaker 
programs correspond called tail recursion iteration 
programs finite computation sequence program seq short finite length string atomic programs tests representing possible sequence atomic steps occur halting execution seqs denoted set seqs program denoted cs 
word possible loosely cs determined syntax 
tests evaluate false cs may contain seqs executed interpretation 
set cs subset set atomic programs tests occurring programs regular programs recursive programs define set cs formally induction syntax 
example regular programs cs def fag atomic program test cs skip def cs fail def cs def cs cs cs def cs cs cs def cs cs def skip def example atomic program atomic formula program seqs strings form 
dynamic logic 
note seq program program cs programs regular programs give rise regular sets seqs recursive programs give rise context free sets seqs 
step define program simply recursively enumerable set seqs 
general programming language consider context dl subsumes expressive power 
nondeterminism say words concept nondeterminism role study logics languages concept presents difficulty time encountered 
programming languages consider traces program need uniquely determined start states 
possible say program nondeterministic 
nondeterministic program divergent convergent traces starting input state programs sense say program halts certain input state loops certain input state may different computations starting input state 
concrete ways nondeterminism enter programs 
construct nondeterministic wildcard assignment 
intuitively operation assigns arbitrary element domain variable determined 
source nondeterminism unconstrained choice operator regular programs 
third source iteration operator regular programs 
fourth source programs just sets seqs initially seq execute chosen nondeterministically 
example program fx equivalent regular program nondeterministic programs provide explicit mechanism resolving nondeterminism 
way determine possible steps taken state 
hardly realistic 
study nondeterminism correspond operational 
answer nondeterminism valuable tool helps understand expressiveness programming language constructs 
useful situations construct called random assignment literature 
terminology misleading probability 
david harel dexter kozen jerzy tiuryn necessarily predict outcome particular choice may know range possibilities 
reality computations may depend information programmer control input user actions processes system 
nondeterminism useful modeling situations 
importance nondeterminism limited logics programs 
important open problem field computational complexity theory np problem formulated terms nondeterminism 
program verification dynamic logic program logics meant useful tools facilitating process producing correct programs 
need look buggy software understand dire need tools 
produce correct software need know means correct 
vague idea supposed happen program run observe running collection inputs 
order apply formal verification tools formal specification correctness verification tools 
general correctness specification formal description program supposed behave 
program correct respect correctness specification behavior fulfills specification 
gcd program example correctness specified informally assertion input values positive integers respectively output value gcd ii program halts 
course order formal verification system properties expressed formally language order logic 
assertion ii part correctness specification programs necessarily halt may produce infinite traces certain inputs 
finite trace example produced gcd program input state called halting terminating convergent 
infinite traces called looping divergent 
example program loops input state producing infinite trace dynamic logic reason behavior program manifested input output relation 
suited reasoning program behavior manifested intermediate states computation close dynamic logic relatives process logic temporal logic 
say interesting program behavior captured input output relation types behavior irrelevant uninteresting 
restriction input output relations reasonable programs supposed halt finite time yield output results 
approach adequate dealing programs normally supposed halt operating systems 
programs supposed halt correctness criteria traditionally form input output specification consisting formal relation input output states program supposed maintain description set input states program supposed halt 
input output relation program carries information necessary determine program correct relative specification 
dynamic logic suited type verification 
obvious correctness specification ought 
producing formal specification correctness difficult producing program written formal language 
specifications prone bugs programs 
bother 
just implement program vague specification mind 
reasons effort produce formal specifications 
implementing large program scratch programmer may vague idea finished product supposed 
especially true producing software technically inclined employer 
may rough informal description available minor details left programmer 
case large part programming process consists vaguely specified problem making precise 
process formulating problem precisely considered definition program supposed 
just programming practice clear idea want start doing 

process formulating specification unforeseen cases may apparent clear appropriate action program 
especially true error handling exceptional situations 
formulating specification define action program situations tie loose ends 

process formulating rigorous specification suggest ideas implementation forces isolate issues drive design decisions 
know ways data going accessed better position choose right data structures optimize tradeoffs efficiency generality 
david harel dexter kozen jerzy tiuryn 
specification expressed language quite different programming language 
specification functional tells program supposed opposed imperative 
easier specify desired functionality independent details implemented 
example quite easily express means number gcd order logic knowing compute 

verifying program meets specification kind sanity check 
allows give solutions problem functional specification algorithmic implementation lets verify compatible 
incompatibilities program specification bugs program bugs specification 
cycle refining specification modifying program meet specification process converges lead software confidence 
partial total correctness typically program designed implement functionality 
mentioned functionality expressed formally form input output specification 
concretely specification consists input condition precondition output condition postcondition properties input state output state respectively expressed formal language order language domain computation 
program supposed halt state satisfying output condition input state satisfies input condition 
say program partially correct respect input output specification program started state satisfying input condition halts state satisfying output condition definition partial correctness stipulate program halts mean partial 
program totally correct respect input output specification partially correct respect specification halts started state satisfying input condition 
input output specification imposes requirements input state satisfy input condition program loop infinitely erase memory 
garbage garbage philosophy 
really care program input states better rewrite input condition include say formally want happen cases 
example gcd program example output condition condition stating output value gcd input values dynamic logic express completely formally language order number theory 
may try start input specification true restrictions input state 
unfortunately initial value negative final value initial value negative 
expect positive wrong 
problematic situation arises initial values case gcd defined 
program written partially correct respect specification remedy situation providing input specification rules troublesome input values 
limit input states nonnegative zero input specification gcd program example partially correct respect specification totally correct program halts inputs satisfying want allow input zero 
case input specification 
program example partially correct respect amend program produce correct positive gcd negative inputs 
exogenous endogenous logics main approaches modal logics programs exogenous approach exemplified dynamic logic precursor hoare logic hoare endogenous approach exemplified temporal logic precursor invariant assertions method floyd logic exogenous programs explicit language 
syntactically dynamic logic program formed expression built inductively primitive programs small set program operators 
semantically program interpreted input output relation 
relation denoted compound program determined relations denoted parts 
aspect compositionality allows analysis structural induction 
importance compositionality discussed van emde boas temporal logic program fixed considered part structure logic interpreted 
current location program execution stored special variable purpose called program counter part state values program variables 
program operators temporal operators describe program variables including program counter change time 
temporal logic sacrifices compositionality restricted formalism 
discuss temporal logic section 
david harel dexter kozen jerzy tiuryn propositional dynamic logic pdl propositional dynamic logic pdl plays role dynamic logic classical propositional logic plays classical predicate logic 
describes properties interaction programs propositions independent domain computation 
pdl subsystem order dl sure properties pdl discuss section valid order dl 
domain computation pdl notion assignment variable 
primitive programs interpreted arbitrary binary relations set states likewise primitive assertions just atomic propositions interpreted arbitrary subsets special structure imposed 
level abstraction may appear general say interest 
contrary natural level abstraction fundamental relationships programs propositions observed 
example consider pdl formula left hand side asserts formula hold execution program right hand side asserts hold execution formula asserts statements equivalent 
implies verify conjunction postconditions suffices verify separately 
assertion holds universally regardless domain computation nature particular example consider left hand side asserts execution composite program hold 
right hand side asserts execution program hold turn says execution hold 
formula asserts logical equivalence statements 
holds regardless nature 
simplify verification complicated programs 
final example consider assertion primitive proposition symbol programs 
formula true interpretations equivalent sense behave identically respect property expressible pdl formal system containing pdl subsystem 
assertion dynamic logic hold substitution instance 
example programs equivalent sense 
syntax syntactically pdl blend classical ingredients propositional logic modal logic algebra regular expressions 
versions pdl depending choice program operators allowed 
section introduce basic version called regular pdl 
variations basic version considered sections 
language regular pdl expressions sorts propositions formulas programs countably atomic symbols sort 
atomic programs denoted set atomic programs denoted atomic propositions denoted set atomic propositions denoted set programs denoted set propositions denoted 
programs propositions built inductively atomic ones operators propositional operators implication falsity program operators composition choice iteration mixed operators necessity test definition programs propositions mutual induction 
atomic programs programs atomic propositions propositions 
propositions programs propositional implication propositional falsity program necessity david harel dexter kozen jerzy tiuryn propositions sequential composition nondeterministic choice iteration 
test programs 
formal terms define set programs set propositions smallest sets 
note inductive definitions programs propositions intertwined separated 
definition propositions depends definition programs construct definition programs depends definition propositions construct 
note allowed formulas tests 
rich test version pdl 
compound programs propositions intuitive meanings necessary executing true 
execute execute choose nondeterministically execute 
execute nondeterministically chosen finite number times zero 
test proceed true fail false 
avoid parentheses assigning precedence operators unary operators including bind tighter binary ones binds tighter 
expression read dynamic logic course parentheses enforce particular parse expression enhance readability 
semantics section operators turn associative may write ambiguity 
omit symbol write composition propositional operators defined usual way 
possibility operator modal dual necessity operator 
defined def propositions read box diamond respectively 
intuitive meaning computation terminates state satisfying important difference implies terminates 
formula asserts computation terminates formula true regardless addition define skip def 
fail def 

def 

od def 
def def od repeat def def programs skip fail program op failing program respectively 
ternary operator binary operator usual conditional loop constructs conventional programming languages 
constructs fi od alternative guarded command iterative guarded command constructs respectively 
construct hoare partial correctness assertion 
david harel dexter kozen jerzy tiuryn argue formal definitions operators correctly model intuitive behavior 
semantics semantics pdl comes semantics modal logic 
structures programs propositions pdl interpreted called kripke frames honor saul kripke inventor formal semantics modal logic 
kripke frame pair mk set elements called states mk meaning function assigning subset atomic proposition binary relation atomic program 
mk mk extend definition function mk induction give meaning elements mk mk intuitively think set mk set states satisfying proposition model think binary relation mk set input output pairs states program formally meanings mk mk defined mutual induction structure basis induction specifies meanings atomic symbols specification meanings compound propositions programs defined follows 
mk def mk mk mk def mk def mk mk fu mk mk mk def mk mk mk mk mk def mk mk mk def mk mk mk 
def mk dynamic logic operator relational composition 
occurrence iteration symbol pdl second reflexive transitive closure operator binary relations 
says program interpreted reflexive transitive closure mk 
write mk interchangeably say satisfies true state may omit write understood 
notation means satisfy words mk 
notation restate definition equivalently follows def implies def mk mk def mk mk mk def mk mk mk def un un mk mk 
def defined operators inherit meanings definitions mk def mk mk mk def mk mk mk def mk mk def fu mk mk mk mk mk def mk skip def mk identity relation mk fail def mk addition guarded commands inherit semantics definitions input output relations formal semantics capture intuitive operational meanings 
example relation associated program set pairs exist states un un mk mk un mk 
version pdl usually called regular pdl elements called regular programs primitive operators familiar regular expressions 
programs viewed regular expressions david harel dexter kozen jerzy tiuryn atomic programs tests 
fact shown atomic proposition symbol test free programs equivalent regular expressions represent regular set formula valid 
example 
atomic proposition atomic program mk kripke frame fu wg mk fu vg mk diagram illustrates structure state satisfies formula aa aa computation sequences program 
recall section finite computation sequence finite length string atomic programs tests representing possible sequence atomic steps occur halting execution strings called seqs denoted set sequences denoted cs 
word possible loosely cs determined syntax may contain strings executed interpretation 
formally set cs defined induction structure cs def fag atomic program cs 
def cs def cs cs cs def cs cs cs def cs dynamic logic skip example atomic program atomic formula program computation sequences strings form 



skip note finite computation sequence program program cs proposition difficult prove induction structure proposition 
mk cs mk satisfiability validity definitions satisfiability validity propositions come modal logic 
mk kripke frame proposition 
defined section means 
say satisfiable satisfiable say satisfiable 
write say valid kripke frames write say valid 
set propositions write 
proposition said logical consequence case write 
note saying 
say inference rule sound logical consequence satisfiability validity dual sense dual dual proposition valid negation satisfiable 
example 
atomic propositions atomic programs mk kripke frame fs vg mk fu vg mk ft vg mk mk illustrates david harel dexter kozen jerzy tiuryn formulas valid ab ba program aa bb ab ba aa bb ab ba thinking regular expression generates words alphabet fa bg number occurrences shown proposition proposition valid example 
formula aa aa valid 
sides assert different ways alternately true false paths execution atomic program basic properties theorem 
valid formulas pdl ii iii 
iv 
vi vii viii 
ix dynamic logic xi xii xiii xiv 
theorem 
sound rules inference pdl modal generalization gen ii monotonicity iii monotonicity converse operator program operator semantics mk mk mk intuitively converse operator allows run program backwards semantically input output relation program output input relation possible realize practice useful expressive tool 
example gives convenient way talk backtracking rolling back computation previous state 
theorem 
programs mk mk ii mk mk iii mk 
mk 
iv mk mk mk mk 
david harel dexter kozen jerzy tiuryn theorem 
valid formulas pdl ii iii iv 
iteration operator interpreted reflexive transitive closure operator binary relations 
means iteration coded pdl 
operator differs operators infinitary nature reflected semantics mk mk mk see section 
introduces level complexity pdl operators 
pdl compact set finitely satisfiable satisfiable 
infinitary behavior surprising pdl decidable finitary complete axiomatization 
properties operator pdl come directly properties reflexive transitive closure operator binary relations 
nutshell binary relation reflexive transitive relation containing theorem 
valid formulas pdl ii 
iii iv 
vi vii viii ix 
dynamic logic 
xi 
xii 
semantically reflexive transitive relation containing theorem captures 
reflexive captured ii transitive captured vi contains captured iv 
properties captured single property 
reflexive transitive closure induction prove properties iteration know reflexive transitive relation containing universal relation interesting 
need way capturing idea reflexive transitive relation containing equivalent ways done rtc reflexive transitive closure rule li loop invariance rule ind induction axiom box form ind induction axiom diamond form rule rtc called reflexive transitive closure rule 
importance best described terms relationship valid pdl formula theorem 
observe right left implication formula obtained substituting expression david harel dexter kozen jerzy tiuryn theorem implies solution valid substituted rule rtc says solution respect logical implication 
pdl definable set states substituted results valid formula 
dual propositions labeled ind jointly called pdl induction axiom 
intuitively box form ind says true initially number iterations program truth preserved iteration true number iterations diamond form ind says possible reach state satisfying number iterations true possible reach state false true iteration note box form ind bears strong resemblance induction axiom peano arithmetic basis induction induction step drawn 
pdl axiom ind basis induction step drawn 
encoding hoare logic hoare partial correctness assertion encoded pdl 
theorem says encoding dynamic logic subsumes hoare logic 
theorem 
rules hoare logic derivable pdl composition rule ii conditional rule iii rule iv weakening rule dynamic logic filtration decidability small model property pdl says satisfiable satisfied state kripke frame states number symbols 
result technique prove called filtration come directly modal logic 
immediately gives naive decision procedure satisfiability problem pdl determine satisfiable construct kripke frames states check satisfied state 
considering interpretations primitive formulas primitive programs appearing roughly models algorithm inefficient practical 
efficient algorithm described section 
fischer ladner closure proofs simpler modal systems induction founded subformula relation 
pdl situation complicated simultaneous inductive definitions programs propositions behavior operator induction proofs somewhat tricky 
founded subexpression relation inductive proofs 
expression program proposition 
subexpression mixed operators 
start defining functions fl fl simultaneous induction 
set fl called fischer ladner closure 
filtration construction pdl uses fischer ladner closure formula corresponding proof propositional modal logic set subformulas 
functions fl fl defined inductively follows fl def fpg atomic proposition fl def fl fl fl def fl def fl fl fl def atomic program fl def fl fl david harel dexter kozen jerzy tiuryn fl def fl fl fl def fl fl def fl 
definition apparently quite bit involved mere subexpressions 
fact glance may appear circular rule 
auxiliary function fl introduced express purpose avoiding circularity 
defined formulas form intuitively produces elements fl obtained breaking ignoring 
lemma 
fl fl 
ii 
fl fl 
iii fl fl fl 
iv fl fl fl 
fl fl 
convincing definition may clear size fl depends length 
right hand side rule involves formula larger formula left hand side 
shown induction subformulas relationship linear lemma 
formula fl 
ii formula fl filtration pdl proposition kripke frame mk define new frame fl fl fl called filtration fl follows 
define binary relation states def fl mk mk dynamic logic words collapse states distinguishable formula fl 
def fv ug fl def kg fl def mk atomic proposition fl def mk atomic program 
map fl extended inductively compound propositions programs described section 
key lemma relates fl 
difficulty lemma correct formulation induction hypotheses statement lemma 
done proof fairly straightforward induction founded subexpression relation 
lemma filtration lemma 
kripke frame states 
fl mk iff fl 
ii fl mk fl fl mk mk 
filtration lemma prove small model theorem easily 
theorem small model theorem 
satisfiable formula pdl 
satisfied kripke frame states 
proof 
satisfiable kripke frame state mk 
fl fischer ladner closure 
filtration lemma lemma fl 
fl states number truth assignments formulas fl lemma follows immediately satisfiability problem pdl decidable finitely possible kripke frames size check polynomial time algorithm check formula satisfied state kripke frame 
efficient algorithm exists see section 
completeness proof pdl filtration lemma lemma somewhat stronger form 
need know holds nonstandard kripke frames standard kripke frames defined section 
david harel dexter kozen jerzy tiuryn nonstandard kripke frame structure mn kripke frame sense section respect mn need reflexive transitive closure mn reflexive transitive binary relation containing mn satisfying pdl axioms axioms vii viii section 
lemma filtration nonstandard models 
nonstandard kripke frame states 
fl mn iff mn fl 
ii fl mn mn fl mn fl mn mn 
dynamic logic deductive completeness pdl deductive system list axioms rules constitutes sound complete deductive system pdl 
axiom system 
axioms propositional logic ii 
iii iv vi vii viii pdl converse include ix rules inference mp gen axioms ii iii rules inference particular pdl come modal logic 
rules mp gen called modus ponens modal generalization respectively 
axiom viii called pdl induction axiom 
intuitively viii says suppose true current state suppose number iterations true true iteration true number iterations words true initially truth preserved program true number iterations david harel dexter kozen jerzy tiuryn write proposition theorem system say consistent case 
set propositions consistent finite conjunctions elements consistent 
soundness axioms rules kripke frames established elementary arguments relational algebra semantics section 
write formula provable deductive system 
formula consistent case finite set formulas consistent conjunction consistent infinite set formulas consistent finite subset consistent 
axiom system complete valid formulas pdl theorems 
fact proved constructing nonstandard kripke frame maximal consistent sets formulas filtration lemma nonstandard models lemma collapse nonstandard model finite standard model 
theorem completeness pdl 

classical logics completeness theorem form theorem adapted handle relation logical consequence formulas deduction theorem says unfortunately deduction theorem fails pdl seen result allows theorem deterministic exponential time satisfiability algorithm described section extended handle logical consequence relation theorem 
pdl formulas 

atomic programs appearing allowing infinitary conjunctions set formulas finitely atomic programs appear 
atomic programs appearing dynamic logic complexity pdl small model theorem theorem gives naive deterministic algorithm satisfiability problem construct kripke frames states check satisfied state 
checking formula satisfied state kripke frame done quite efficiently naive satisfiability algorithm highly inefficient 
thing models constructed exponential size length formula 
naive satisfiability algorithm takes double exponential time worst case 
efficient algorithm pratt runs deterministic single exponential time 
expect improve significantly due corresponding lower bound 
theorem 
exponential time algorithm deciding formula pdl satisfiable 
theorem 
satisfiability problem pdl exptime complete 
corollary 
constant satisfiability problem pdl solvable deterministic time log size input formula 
exptime hardness established constructing formula pdl models encode computation linear space bounded tape alternating turing machine input length input alphabet 
membership problem alternating polynomial space machines exptime hard chandra satisfiability problem pdl 
interesting compare complexity satisfiability pdl complexity satisfiability propositional logic 
satisfiability np complete known complexity classes exptime np differ 
far current knowledge goes satisfiability problem easier worst case propositional logic far richer superset pdl 
seen current knowledge permit significant difference observed complexity satisfiability propositional logic pdl 
easily verified important behavioral difference propositional logic compact pdl 
compactness significant implications regarding relation logical consequence 
propositional formula consequence set propositional formulas consequence finite subset true pdl 
recall write say logical consequence satisfied state kripke frame states satisfy formulas 
alternative logical consequence equivalent david harel dexter kozen jerzy tiuryn kripke frame formula holds state satisfying formulas allowing infinite conjunctions write 
implies necessarily vice versa 
counterexample provided fpg contains finitely atomic programs reduce problem problem related shown theorem 
interpretation compactness fails theorem 
infinite set formulas formula proper subset case case 
shown theorem logical consequences finite difficult decide validity single formulas 
infinite 
compactness key factor 
set logic compact consequence problem check finite subsets effectively enumerated checking finite decidable problem 
compactness fails pdl observation known recursively enumerable 
result shows situation worse expect taken set substitution instances single formula pdl consequence problem highly undecidable 
striking manifestation pdl lack compactness 
formula 
set substitution instances set formulas obtained substituting formula atomic proposition appearing 
theorem 
problem deciding complete 
problem hard particular fixed 
dynamic logic nonregular pdl section enrich class regular programs pdl introducing programs control structure requires finite automaton 
example class context free programs requires pushdown automaton pda moving regular context free programs really going iterative programs ones parameterless recursive procedures 
questions arise enriching class programs pdl expressive power logic grows resulting logics decidable 
turns nonregular program increases pdl expressive power validity problem pdl context free programs undecidable 
bulk section devoted difficult problem trying characterize borderline decidable undecidable extensions 
hand validity pdl addition single extremely simple nonregular program complete hand add equally simple program problem remains decidable 
results pertain specific extensions discuss broad decidability results cover languages including context free 
similarly general undecidability results known address weaker issue nonregular extensions admit finite model property negative result covers cases 
nonregular programs consider self explanatory program number times program meant represent set computation sequences viewed language alphabet fa pg set regular programmed pdl 
represented parameterless recursive procedure proc call return set computation sequences program captured context free grammar av david harel dexter kozen jerzy tiuryn led idea allowing context free programs inside boxes diamonds pdl 
pragmatic point view amounts extending logic ability reason parameterless recursive procedures 
particular representation context free programs unimportant pushdown automata context free grammars recursive procedures formalism effectively translated 
rest section number specific programs interest employ special abbreviations 
example define ba 
def fa ba 
def fa 
def fb note really just nondeterministic version program simply control iteration 
fact written notation programming terms compare regular program ab nonregular observing purchase bread pay program captures process paying purchased captures process paying month 
turns enriching pdl single arbitrary nonregular program increases expressive power 
language atomic programs tests pdl defined exactly pdl additional syntax rule stating formula expression new formula 
semantics pdl pdl addition clause mk def mk note pdl allow formation rule new programs combined programs 
added programming language single new stand program 
pdl pdl extensions pdl say pdl expressive pdl formula pdl formula pdl pdl expressive pdl pdl expressive pdl say pdl strictly expressive pdl version pdl strictly expressive express express 
noteworthy results section depend nondeterminism 
example negative theorem holds deterministic version 
results section involve nonregular programs atomic programs generalized allow tests 
dynamic logic language test free subset seqs contain tests 
theorem 
nonregular test free language pdl strictly expressive pdl 
view decidability regular pdl showing reasoning iterative programs computable 
wish know true recursive procedures 
define context free pdl pdl extended context free programs context free program seqs form context free language 
precise syntax unimportant definiteness take programs set context free grammars atomic programs tests define mk def cs mk cs set computation sequences generated described section 
theorem 
validity problem context free pdl undecidable 
theorem leaves interesting questions unanswered 
level undecidability context free pdl 
happens want add small number specific nonregular programs 
questions arises fact equivalence problem context free languages complete complete arithmetic hierarchy 
theorem shows validity problem context free pdl hard fact worse 
second question far general 
interested reasoning deterministic linear context free programs interested special context free programs ba pdl remains decidable programs added 
general question determine borderline decidable undecidable comes enriching class programs allowed pdl 
interestingly wish consider simple nonregular extensions pdl ba pdl able prove undecidability technique context free pdl theorem standard problems undecidable context free languages equivalence inclusion decidable classes containing regular languages likes ba prove decidability technique pdl section logics pdl ba pdl enjoy finite model property 
want determine decidability status extensions harder 
theorem 
satisfiable formula pdl satisfied finite structure 
linear program seqs generated context free grammar nonterminal symbol right hand side rule 
corresponds family recursive procedures recursive call procedure 
david harel dexter kozen jerzy tiuryn pdl ba news worse mere undecidability theorem 
validity problem pdl ba complete 
result holds pdl extended programs easy show validity problem context free pdl entirety remains fact ba context free language yields answer question mentioned earlier context free pdl complete 
second question theorem shows high undecidability phenomenon starts occurring addition simple nonregular program 
turn nonregular programs single letter 
consider language powers def fa theorem 
validity problem pdl undecidable 
possible prove result powers fixed 
pdl addition language form fa fixed undecidable 
class letter extensions proven undecidable consists fibonacci sequences theorem 
arbitrary elements sequence generated recurrence 
def fa 
validity problem pdl undecidable 
theorems fact sequences programs grow exponentially crucial proofs 
know undecidability results letter extension lengths sequences grow 
particularly intriguing cases squares cubes def fa def fa pdl pdl undecidable 
decidability result slightly restricted version squares extension indicate full unrestricted version pdl decidable 
conjecture cubes problem undecidable 
interestingly classical open problems number theory reduce instances validity problem pdl example knows integer greater sum cubes formula valid answer dynamic logic fold fold iterations written full course 
pdl decidable compute answer simple manner principle 
decidable extensions turn positive results 
theorem states pdl finite model property 
theorem 
validity problem pdl decidable 
contrasted theorem decidability pdl surprising 
simplest nonregular languages ba extremely similar addition pdl yields high undecidability leaves logic decidable 
theorem proved originally showing pdl admit finite models admit finite pushdown models transitions labeled atomic programs push pop instructions particular kind stack 
close study proof relies heavily idiosyncrasies language suggests decidability undecidability manner automaton accepts languages involved 
example usual way accepting ba pushdown automaton pda reading carry push pop depending location input word 
standard way accepting pushed popped regardless location input symbol determines automaton 
set describe yielded general decidability result confirms intuition 
special interest due generality depend specific programs 
pda accepts empty stack 
say simple minded undefined 
context free language said simple minded simple minded cfl exists simple minded pda accepts 
words action simple minded automaton determined uniquely input symbol state stack symbol help determine machine halts rejecting input continues 
note automaton necessarily deterministic 
noteworthy simple minded pdas accept large fragment contextfree languages including balanced parenthesis languages dyck sets intersections regular languages 
theorem 
accepted simple minded pda pdl decidable 
obtain general decidability result involving languages accepted david harel dexter kozen jerzy tiuryn deterministic stack automata 
stack automaton way pda head travel stack reading contents changes top stack 
stack automata accept non context free languages generalizations variants thereof 
nice able prove decidability pdl augmented language accepted machine known 
proven word language preceded new symbol mark enriched pdl decidable theorem 
language accepted deterministic stack automaton 
el denote language lg pdl el decidable 
theorems general cover languages prove decidability pdl may considered simplest free extension pdl 
constructions proofs general results combined yield theorem 
pdl decidable 
explained know extension pdl polynomially growing language conjecture cubes extension undecidable 
decidability status extensions hard determine address weaker notion presence absence finite model property 
technique theorem show pdl violates finite model property letter alphabets 
state general result leading letter extensions violate finite model property 
particular theorem yield proposition squares cubes 
logics pdl pdl finite model property 
proposition polynomials 
polynomial form 
positive leading coefficient fp ng pdl sp finite model property 
proposition sums primes 
th prime define sop def pdl finite model property 
proposition factorials 
fac def fn 
ng 
pdl fac finite model property 
dynamic logic finite model property fails sufficiently fast growing integer linear recurrence just fibonacci sequence know extensions render pdl undecidable 
th order integer linear recurrence inductively defined sequence def 

proposition linear recurrences 
lr set defined inductively 
conditions equivalent lr nonregular ii pdl lr finite model property iii zero 
david harel dexter kozen jerzy tiuryn variants pdl deterministic programs nondeterminism arises pdl ways atomic programs interpreted structure necessarily binary relations states programming constructs involve nondeterministic choice 
modern programming languages facilities concurrency distributed computation certain aspects modeled nondeterminism 
majority programs written practice deterministic 
investigate effect eliminating sources nondeterminism pdl 
program said semantically deterministic kripke frame traces uniquely determined states 
atomic program equivalent requirement mk partial function mk deterministic kripke frame mk atomic semantically deterministic 
class deterministic programs denoted class programs operators may appear context conditional test loop skip fail tests conditional test loop purely propositional occurrence operators 
class nondeterministic programs denoted wp unconstrained nondeterministic choice construct allowed 
easily shown semantically deterministic restricting syntax semantics obtain logics deterministic pdl syntactically identical pdl interpreted deterministic structures strict pdl deterministic programs allowed strict deterministic pdl restrictions force 
validity satisfiability defined just pdl respect deterministic structures 
valid pdl valid conversely formula dynamic logic valid pdl 
strictly expressive pdl formula expressible shown halpern reif theorem 
axiom scheme added axiom system resulting system sound complete 
theorem 
validity deterministic exponential time complete 
turn atomic programs nondeterministic composed larger programs deterministic constructs 
theorem 
validity deterministic exponential time complete 
final version interest syntactic restrictions semantic ones adopted 
exponential time lower bound fails theorem 
validity problem complete polynomial space 
question relative power expression interest 
pdl 

questions inappropriate syntax languages interpreted different classes structures 
considering second theorem 
pdl 
summary diagram describing relations expressiveness logics 
solid arrows indicate added expressive power broken ones difference semantics 
validity problem complete pspace complete 
straightforward variants axiom system complete versions 
pdl representation automata pdl program represents regular set computation sequences 
regular set possibly represented exponentially succinctly finite david harel dexter kozen jerzy tiuryn automaton 
difference representations corresponds roughly difference programs flowcharts 
finite automata exponentially succinct general upper bound section conceivably fail finite automata allowed programs 
rework deductive system section 
turns completeness exponential time decidability results pdl sensitive representation go presence finite automata programs provided deductive system section techniques sections suitably modified shown pratt pratt harel sherman years automata theoretic approach logics programs yielded significant insight propositional logics powerful pdl substantial reductions complexity decision procedures 
especially enlightening connections automata infinite strings infinite trees 
viewing formula automaton model input automaton satisfiability problem formula emptiness problem automaton 
logical questions transformed purely automata theoretic questions 
assume nondeterministic finite automata form set states start final states respectively assigns subset 
pair states 
intuitively visiting state seeing symbol automaton may move state 
fact automata accept state loss generality 
arbitrary nondeterministic finite automaton accept states set accepted union sets accepted identical unique accept state desired formula written conjunction quadratic growth 
obtain new logic automata pdl defining inductively clauses section letting 
set automata form 
axioms iv vii replaced dynamic logic induction axiom viii 
similar changes prove theorem 
validity decidable exponential time 
theorem 
axiom system described complete 
converse converse operator program operator allows program run backwards mk def mk pdl converse called 
identities allow assume loss generality converse operator applied atomic programs 
converse operator strictly increases expressive power pdl formula expressible 
theorem 
pdl 
proof 
consider structure described structure 
hand shown induction structure formulas agree atomic formulas formula pdl distinguish 
interestingly presence converse operator implies operator continuous sense possibly infinite family formulas possessing join exists logically equivalent absence converse operator construct nonstandard models fails 
david harel dexter kozen jerzy tiuryn completeness exponential time decidability results sections extended provided axioms added filtration lemma lemma holds presence finite model property 
foundedness deterministic program formula asserts total correctness respect pre postconditions respectively 
nondeterministic programs formula express right notion total correctness 
asserts implies exists halting computation sequence yielding really assert implies computation sequences terminate yield denote property tc unfortunately expressible pdl 
problem intimately connected notion foundedness 
program said founded state exists infinite sequence states mk 
property expressible pdl see 
powerful logics proposed deal situation 
powerful propositional calculus essentially propositional modal logic augmented fixpoint operator 
operator express property formulated fixpoint monotone transformation sets states defined pdl operators 
example foundedness program expressed logic 
somewhat weaker ways capturing foundedness resorting full calculus studied 
add pdl explicit predicate wf foundedness mk wf def fs mk add explicit predicate halt asserts computations argument terminate 
predicate halt defined inductively wf dynamic logic follows halt def atomic program test halt def halt halt halt def halt halt halt def wf halt constructs investigated various names loop repeat 
predicates loop repeat just complements halt wf respectively loop def halt repeat def wf clause equivalent assertion loop def repeat loop asserts computation consists infinite sequence halting computations finite sequence halting computations followed computation denote logics obtained augmenting pdl wf halt predicates respectively 
follows preceding discussion pdl propositional calculus inclusions known strict 
logic powerful express total correctness nondeterministic programs 
total correctness respect precondition postcondition expressed tc def halt conversely halt expressed terms tc halt tc theorem 
pdl 
theorem 

possible extend theorem versions converse allowed addition wf halt 
proof theorem goes stands loop stands repeat 
retain names historical reasons 
david harel dexter kozen jerzy tiuryn expressible 
theorem goes converse versions 
obtain situation illustrated arrows indicate absence path logics means express properties 
pdl qk qk qk filtration lemma fails halt wf versions theorem 
satisfiable formulas calculus finite models 
finite model property shared 
theorem 
formula halt halt satisfiable finite model 
turns theorem prevent decidable 
dynamic logic theorem 
validity problems propositional calculus decidable deterministic exponential time 
obviously simpler logic simpler arguments needed show exponential time decidability 
years logics gradually shown decidable exponential time various authors various techniques 
point exponential time decidability propositional calculus forward backward modalities proved vardi seen easily follow 
proof vardi carried exhibiting exponential time decision procedure way alternating automata infinite trees 
mentioned possesses finite necessarily small collapsed model property 
theorem 
satisfiable formula propositional calculus finite model 
extensions pdl pdl theorems decidable despite lacking finite model property 
complete axiomatizations obtained embedding calculus see section 
concurrency interesting extension pdl concerns concurrent programs 
define intersection operator binary relation states corresponding program intersection binary relations corresponding viewed kind concurrency operator admits transitions states admitted 
consider different natural notion concurrency 
interpretation program binary relation states relates initial states possible final states relation states sets states 
mk relate start state collection sets states intuition starting state concurrent program run concurrent execution threads set final states basic concurrency operator denoted original concurrent dynamic logic peleg peleg peleg notation 
syntax concurrent pdl pdl addition clause 
program means intuitively execute parallel 
semantics concurrent pdl defined kripke frames mk pdl programs mk david harel dexter kozen jerzy tiuryn meaning collection reachability pairs form brief description concurrent pdl require structures assign atomic programs sequential non parallel meaning require mk 
true parallelism stem applying concurrency operator build larger sets reachability pairs compound programs 
details see peleg peleg relevant results logic theorem 
pdl concurrent pdl 
theorem 
validity problem concurrent pdl decidable deterministic exponential time 
axiom system augmented axiom shown complete concurrent pdl dynamic logic order dynamic logic dl section study order dynamic logic 
main difference order dl propositional version pdl discussed previous sections presence order structure called domain computation order quantification allowed 
states longer points valuations set variables carrier atomic programs dl longer binary relations assignment statements various forms assigning values variables computation 
basic example assignment simple assignment variable term 
atomic formulas dl generally taken atomic order formulas 
addition constructs pdl basic dl syntax contains individual variables ranging function predicate symbols distinguished functions predicates quantifiers ranging exactly classical order logic 
powerful versions logic contain array stack variables constructs primitive operations manipulating assignments changing values 
new construct increases expressive power effect complexity deciding satisfiability 
central goals research classify constructs terms relative expressive power complexity 
section lay groundwork defining various logical programming constructs shall need 
basic syntax language order dynamic logic built classical order logic 
underlying order vocabulary involves vocabulary function symbols predicate relation symbols 
top vocabulary define set programs set formulas 
sets interact means modal construct exactly propositional case 
programs formulas usually defined mutual induction 
ff finite order vocabulary 
denote typical function symbols denote typical relation symbols 
associated function relation symbol fixed arity number arguments represent arity explicitly 
assume contains equality symbol arity 
functions relations arity called nullary unary binary ternary ary respectively 
nullary functions called constants 
shall countable set individual variables fx assume contains function symbol positive arity 
vocabulary polyadic contains function symbol arity greater 
vocabularies function symbols unary called monadic 
david harel dexter kozen jerzy tiuryn vocabulary rich contains predicate symbol equality symbol sum arities function symbols 
examples rich vocabularies unary function symbols binary function symbol unary function symbol unary predicate symbol 
vocabulary rich poor 
poor vocabulary just unary function symbol possibly constants relation symbols equality 
main difference rich poor vocabularies admit exponentially pairwise non isomorphic structures finite cardinality admit polynomially 
say vocabulary mono unary contains function symbols single unary 
may contain constants predicate symbols 
definitions dl programs formulas depend vocabulary general shall dependence explicit specific reason doing 
atomic formulas programs versions dl consider atomic formulas atomic formulas order vocabulary formulas form ary relation symbol terms 
pdl programs defined inductively atomic programs various programming constructs 
meaning compound program inductively terms meanings constituent parts 
different classes programs obtained choosing different classes atomic programs programming constructs 
basic version dl atomic program simple assignment term 
intuitively program assigns value variable form assignment conventional programming languages 
powerful forms assignment stack array assignments nondeterministic wildcard assignments discussed 
precise choice atomic programs explicit needed term atomic program cover possibilities 
tests pdl dl contains test operator turns formula program 
versions dl shall discuss allow quantifier free firstorder formulas tests 
call versions poor test 
alternatively allow order formula test 
generally place restrictions form tests allowing dl formula whatsoever including contain programs containing tests versions dl labeled rich test section 
programs defined independently formulas poor test versions rich test versions require dynamic logic mutually inductive definition programs formulas 
atomic programs precise logic consider time depends choice tests allow 
explicit needed term test cover possibilities 
regular programs set atomic programs tests set regular programs defined pdl see section atomic program test program programs program programs program program program 
programs literature dl concerned class programs see section 
formally deterministic programs form subclass regular programs program operators constrained appear forms skip def 
fail def 
def def 
class nondeterministic programs allow unrestricted nondeterministic choice construct 
course unrestricted sequential composition operator allowed languages 
restrictions form atomic programs tests apply regular programs 
example allowing poor tests occurring programs quantifier free order formula 
class deterministic programs important captures basic programming constructs common real life imperative programming languages 
standard structure natural numbers deterministic programs powerful define partial recursive functions expressive regular programs 
similar result holds wide class models similar suitable definition partial recursive functions models 
true general programs nondeterministic ones universally expressive 
discuss results section 
david harel dexter kozen jerzy tiuryn formulas formula dl defined way similar pdl addition rule quantification 
equivalently say formula dl defined way similar order logic addition rule modality 
basic version dl defined regular programs false formula formula atomic formula formula formulas formula formula formula formula program formula 
missing rule definition syntax dl tests 
basic version free order formula 
test 
rich test version definitions programs formulas mutually dependent rule defining tests simply formula 
test 
notation propositional logic stands 
order logic order existential quantifier considered defined construct abbreviates 
similarly modal construct considered defined construct section modal dual 
propositional constructs defined section 
course parentheses necessary ensure unique readability 
note individual variables serve dual purpose program variables logical variables 
richer programs seqs programs classes programs conveniently defined certain sets seqs 
recall section seq program form 
assignment statement quantifier free order test 
regular program associated unique set seqs cs section 
definitions propositional context apply equally order case difference form atomic programs tests 
word broadest possible sense consider program arbitrary set seqs 
sense semantically dynamic logic assign input output relation set meaningful way programs hardly called executable 
require set seqs recursively enumerable effective procedure list possible executions program 
subtle issue arises notion 
consider set seqs fx ng set satisfies restriction hardly called program 
uses infinitely variables consequence change valuation infinitely places 
pathological example set seqs fx ng change valuation infinitely locations depends infinitely locations input valuation 
order avoid pathologies require program finitely variables 
gives rise definition programs general family programs consider 
specifically program turing machine enumerates set seqs finite set variables 
set seqs enumerated called cs 
fv denote finite set variables occur seqs cs 
important issue connected programs bounded memory 
assignment statements tests program may infinitely terms increasingly deep nesting function symbols discussed terms finitely variables require unbounded amount memory compute 
define set seqs bounded memory depth terms appearing bounded 
fact sacrificing computational power require terms form xn bounded memory set seqs 
arrays stacks interesting variants programming language dl arise allowing auxiliary data structures 
shall define versions arrays stacks version nondeterministic assignment statement called wildcard assignment 
imagine augmenting programs kinds constructs blocks declarations recursive procedures various parameter passing mechanisms higher order procedures concurrent processes easy arrive family consisting thousands programming languages giving rise thousands logics 
obviously restrict 
worth mentioning certain kinds recursive procedures captured stack operations explained 
david harel dexter kozen jerzy tiuryn arrays handle arrays include countable set array variables array ff array variable associated arity number arguments represent explicitly 
assume countably variables arity 
presence array variables equate set individual variables set nullary array variables array variables array arity range ary functions arguments values domain computation 
exposition elements domain computation play roles indices array values stored array 
equally introduce separate sort array indices conceptually simple complicate notation give new insight 
extend set order terms allow unrestricted occurrence array variables provided arities respected 
classes regular programs arrays deterministic nondeterministic programs arrays defined similarly classes allow array assignments addition simple assignments 
array assignments similar simple assignments left hand side allow term outermost symbol array variable ary array variable terms possibly involving array variables 
note reduces ordinary simple assignment 
recursion algebraic stack consider dl programs manipulate stack 
literature automata theory formal languages distinguishes stack pushdown store 
automaton allowed inspect contents stack changes top 
shall term stack denote common pushdown store inspection allowed top stack 
motivation extension able capture recursion 
known recursive procedures modeled stack various technical reasons prefer extend data manipulation capabilities programs introduce new control constructs 
encounters recursive call stack simulation recursion push return location values local variables parameters stack 
pop completion call 
lifo nature stack storage fits order control executes recursive calls 
dynamic logic handle stack stack version dl add new atomic programs push pop term intuitively push pushes current value top stack pop pops top value top stack assigns value variable stack empty pop operation change 
added test stack emptiness shown redundant 
formally stack simply finite string elements domain computation 
classes regular programs stack deterministic nondeterministic programs stack obtained augmenting respective classes programs push pop operations atomic programs addition simple assignments 
contrast case arrays single stack 
fact expressiveness changes dramatically stacks allowed 
order able simulate recursion domain distinct elements return addresses properly encoded stack 
way doing store return address unary element domain store occurrence second element delimiter symbol followed domain elements constituting current values parameters local variables 
kind stack described termed algebraic contains elements domain computation 
contrasted boolean stack described 
parameterless recursion boolean stack interesting special case stack contain distinct elements 
version programming language shown capture recursive procedures parameters local variables 
need store return addresses actual data items domain computation 
achieved values described 
arrive idea boolean stack 
handle stack version dl add new kinds atomic programs new test 
atomic programs push push pop test simply top 
intuitively push push push corresponding distinct boolean values stack pop removes top element test top 
evaluates true iff top element stack side effect 
test top 
explicit operator distinguishes stack top element empty stack 
defined operator realistic language certainly 
david harel dexter kozen jerzy tiuryn mathematically redundant simulated operators 
wildcard assignment nondeterministic assignment device arises study fairness see apt plotkin called random assignment literature randomness probability 
shall call wildcard assignment 
intuitively operates assigning nondeterministically chosen element domain computation variable construct modality similar order universal quantifier follow semantics formulas equivalent 
wildcard assignment may appear programs iterated 
semantics section assign meanings syntactic constructs described previous sections 
interpret programs formulas order structure variables range carrier structure 
take operational view program semantics programs change values variables sequences simple assignments assignments flow control determined truth values tests performed various times computation 
states valuations instantaneous snapshot relevant information moment computation determined values program variables 
states valuations variables carrier structure formal definition associate pair valuations program possible start valuation execute program halt valuation case call input output pair write ma 
result kripke frame exactly section 
ma order structure vocabulary 
call domain computation 
set called carrier ma meaning function ma ary function ma interpreting ary function symbol ma ary relation ma interpreting ary relation symbol 
equality symbol interpreted identity relation 
denote set ary functions convention take denote set finite length strings structure determines kripke frame denote follows 
valuation function assigning ary function dynamic logic ary array variable 
assigns meanings stacks follows 
shall unique variable names stk denote algebraic stack boolean stack respectively 
valuation assigns finite length string elements stk finite length string boolean values formally ary array variable stk convention assuming array individual variables nullary array variables assigned elements definition valuation extends uniquely terms induction 
ary function symbol ary array variable def ma def function patching operator defined follows sets function function defined def 
notation ways logical metalogical levels 
example valuation individual variable new valuation obtained changing value leaving values variables intact 
ary array variable new valuation assigns value stack variables array variables ary function expression denotes ary function agrees input takes value precisely 
david harel dexter kozen jerzy tiuryn call valuations finite variants finitely array variables tuples words differ finitely array variables differ functions differ finitely values 
relation finite variant equivalence relation valuations 
halting computation run finite amount time execute finitely assignments 
able cross equivalence class boundaries binary relation semantics pair input output pair program finite variant ready define states kripke frame 
valuation stacks empty array individual variables interpreted constant functions value 
state finite variant valuation set states denoted call state initial differs values individual variables 
meaningful useful contexts take states set valuations 
purpose restricting attention states defined prevent arrays initialized highly complex oracles compromise value relative expressiveness results section 
assignment statements section program associate binary relation ma called input output relation formula associate set ma sets ma ma defined mutual induction structure 
basis inductive definition give semantics assignment statements discussed earlier 
array assignment interpreted binary relation ma def words starting state array assignment effect changing value input leaving dynamic logic value inputs values variables intact 
definition reduces definition simple assignment ma def push operations push algebraic stack push push boolean stack interpreted binary relations ma push def stk 
stk ma push def 
ma push def 
respectively 
words push changes value algebraic stack variable stk stk string 
stk concatenation value string stk left intact 
effects push push similar special constants concatenated 
pop operations pop algebraic stack pop boolean stack interpreted binary relations ma pop def stk tail stk head stk ma pop def tail respectively tail 
def tail def head 
def head def empty string 
words stk operation changes value stk stk string obtained deleting element stk assigns element variable stk changed 
left intact 
boolean stack operation pop changes value additional changes 
include explicit constructs test stacks empty simulated 
need able refer value top element boolean stack include top 
test 
david harel dexter kozen jerzy tiuryn boolean test program top 
interpreted binary relation ma top 
def head words test changes allows control proceed iff top boolean stack contains 
wildcard assignment interpreted relation ma def ag result executing statement assigned arbitrary value carrier set values variables remain unchanged 
programs formulas meanings compound programs formulas defined mutual induction structure essentially propositional case see section 
include definitions completeness 
regular programs programs semantic definitions constructs regular programs 
ma def ma ma ma ma ma def ma ma ma def ma ma ma 
def ma semantics defined constructs obtained definitions exactly pdl 
seqs programs recall program turing machine enumerating set cs seqs 
program define ma def cs ma dynamic logic meaning defined union meanings seqs cs 
meaning ma seq determined meanings atomic programs tests sequential composition operator 
interesting point regarding translation programs programming constructs programs 
done arrays stacks booleans stacks programs bounded memory wildcard assignment 
book shall referring set seqs associated programs important able carry translation 
see done case arrays example consider algorithm simulating execution program generating ordinary assignments tests 
generate array assignment form remembers reaches assignment form aim generating 
requires care keep track changes variables inside incorporate generated assignments 
formulas semantic definitions constructs formulas dl 
semantics atomic order formulas standard semantics classical order logic 
ma def 
ma def fu ma ma ma def fu ma ma def fu ma ma equivalently define order quantifiers terms wildcard assignment note deterministic programs example obtained programming language regular programs disallowing wildcard assignments ma partial function states states state ma 
partiality function arises possibility may halt started certain states 
example ma skip empty relation 
general relation ma need single valued 
set syntactic constructs refer version dynamic logic programs built constructs dynamic logic simply dl 
dl dl array dl stk dl david harel dexter kozen jerzy tiuryn dl wild 
default logics poor test versions quantifier free order formulas may appear tests 
dl abbreviate dl reg dl dreg denote dl programs really deterministic regular programs 
programs poor tests 
combinations dl dreg wild allowed 
satisfiability validity concepts satisfiability validity defined pdl section order logic standard semantics 
ma structure state formula write ma say satisfies write understood 
say valid write say valid write say satisfiable set formulas 
write 

informally iff terminating computation starting state terminates state satisfying iff exists computation starting state terminating state satisfying 
pure order formula meaning order logic 
dynamic logic relationships static logics uninterpreted reasoning contrast propositional version pdl discussed sections dl formulas involve variables functions predicates quantifiers state mapping variables values domain atomic programs assignment statements 
give semantic meaning constructs requires order structure interpret function predicate symbols 
obliged assume special nature interpretations function predicate symbols dictated order semantics 
draw level reasoning valid possible interpretations 
uninterpreted reasoning refers style reasoning 
example formula true domain irrespective interpretations example valid formula note applied 
formula asserts assumption undoes computation consisting applying number times backtracked original applying number times result 
observe basic properties classical uninterpreted firstorder logic skolem theorem completeness compactness fail fairly weak versions dl 
lowenheim skolem theorem classical order logic states formula infinite model models infinite cardinalities 
theorem classical order logic define structure elementary arithmetic 
isomorphism 
order sentence true structure isomorphic done dl 
proposition 
exists formula dl dreg defines isomorphism 
lowenheim skolem theorem hold dl infinite model models isomorphic countable 
david harel dexter kozen jerzy tiuryn lowenheim skolem theorem compactness fails dl 
consider countable set formulas fp easy see satisfiable finitely satisfiable finite subset satisfiable 
worst completeness hold deductive system normally think finite effective system axioms schemes finitary inference rules 
set theorems system enumerated writing axioms systematically applying rules inference possible ways 
set valid statements dl recursively enumerable 
fact describe section exactly bad situation say say meaningful proofs deduction dl 
contrary wealth interesting practical results axiom systems dl cover section 
section investigate power dl relative classical static logics uninterpreted level 
particular rich test dl programs equivalent infinitary language ck 
consequences fact drawn sections 
introduce definition allows compare different variants dl 
recall section state initial differs constant state values individual variables 
dl dl variants dl vocabulary say dl expressive dl write dl dl formula dl formula dl structures initial states dl expressive dl dl expressive dl say dl strictly expressive dl write dl dl dl expressive dl dl expressive dl say dl dl equal expressive power simply equivalent write dl dl notions comparing versions dl static logics 
technical reason restriction initial states definition 
dl dl access different sets data types may trivially incomparable uninteresting reasons careful limit states compared 
shall see examples section 
definition dl section programming language explicit parameter 
particular order vocabulary dl considered treated parameter 
turns relative expressiveness versions dl sensitive 
second parameter ignored literature creating source potential misinterpretation results 
assume fixed order vocabulary 
dynamic logic rich test dynamic logic programs introduce general version dl consider 
logic called rich test dynamic logic programs denoted dl rich test 
programs dl rich test sets seqs defined section seqs may contain tests 
previously constructed formula 
formal definition inductive 
atomic programs programs atomic formulas formulas 
formulas programs set programs finite set variables free bound variable formulas programs 
set cs computation sequences rich test program defined usual 
language 
language formation rules order language 
countably infinite conjunctions disjunctions allowed 
addition ig recursively enumerable resulting language denoted ck called constructive 
proposition 
dl rich test ck 
programs defined section clearly special case general rich test programs follows dl rich test expressive dl 
fact expressive power 
theorem 
dl dl rich test 
henceforth shall assume order vocabulary contains function symbol positive arity 
assumption dl easily shown strictly expressive 
theorem 

dl 
corollary 

dl dl dl rich test ck david harel dexter kozen jerzy tiuryn situation intermediate versions dl dl stk dl dl wild interest 
deal relative expressive power section 
interpreted reasoning arithmetical structures detailed level consider 
closest actual process reasoning concrete fully specified programs 
syntactically programs formulas uninterpreted level assume fixed structure class structures 
framework study programs computational behavior depends deep properties particular structures interpreted 
fact task verifying correctness actual program falls heading interpreted reasoning 
specific structure look carefully natural numbers usual operations 
denote order definable operation subtraction gcd denote order definable operation giving greatest common divisor formula dl valid true states xy 
gcd program example regular program formula states correctness termination actual program computing greatest common divisor 
example consider formula denotes integer division relation tests argument 
order definable 
innocent looking formula asserts starting arbitrary positive integer repeating operations eventually reach number divide number odd triple add 
dynamic logic truth formula unknown constitutes problem number theory dubbed problem open years 
formula says slightly different way 
specific structure generalized resulting class arithmetical structures 
briefly structure arithmetical contains order definable copy order definable functions coding finite sequences elements single elements corresponding decoding 
arithmetical structures important structures arising naturally computer science discrete structures recursively defined data types arithmetical ii structure extended arithmetical adding appropriate encoding decoding capabilities 
results interpreted level terms hold arithmetical structure significance greater 
expressive power results corollary establishing 
dl dl dl rich test uninterpreted level structures taken account 
order logic regular dl dl rich test form sequence increasingly powerful logics interpreted uniformly structures 
happens fixes structure say 
differences expressive power hold 
address questions 
introduce notation comparing expressive power dl dl variants dl static logics 
defined vocabulary write dl dl dl dl define way analogous definition 
turns dl expressive order logic 
true finite test dl 
result stated true arithmetical structure 
theorem 

dl dl 
significance result principle carry reasoning programs interpreted order logic 
translating dl formula equivalent order formula 
translation effective 
theorem holds arithmetical structure containing requisite coding power 
mentioned earlier structure extended arithmetical 
david harel dexter kozen jerzy tiuryn translation theorem produces formulas having little resemblance original ones 
mechanism somewhat unnatural correspond closely type arguments find practical program verication 
section remedy provided process orderly 
observe dl rich test considerably power equivalent logics theorem 
true arithmetical structure 
theorem 
dl rich test defines precisely 
sets 
theorems say languages dl dl define arithmetic order definable sets dl rich test defines 
sets 
inclusion classes strict example order number theory arithmetic corollary 
dl dl rich test 
dynamic logic complexity dl section addresses complexity order dynamic logic 
versions dl subsume order logic truth satisfiability validity formula easier establish 
dl subsumed ck questions harder establish ck 
bounds hold uninterpreted interpreted levels reasoning 
uninterpreted level section discuss complexity validity problem dl 
remarks problem lower bound undecidable better recursively enumerable upper bound large gap interested determining precise complexity bounds dl variants 
interesting related question nontrivial fragment dl allow complete axiomatization 
consider questions full dl reg consider important subclasses formulas better upper bounds derivable partial correctness assertions form termination total correctness assertions form order formulas 
results stated regular programs remain true powerful programming languages 
hold deterministic programs 
state results mentioning underlying order vocabulary 
upper bounds irrelevant 
lower bounds assume contains unary function symbol ternary predicate symbols 
theorem 
validity problem dl hard formulas form regular program order 
theorem 
validity problem dl dl rich test intermediate versions complete 
soften negative flavor results observe special cases unquantified program dl formulas easier validity problems mentioned undecidable 
theorem 
validity problem sublanguage dl consisting formulas form order program complete 
nontrivial means containing 
allowing programs iteration 
reason requirement loop free programs add expressive power order logic 
david harel dexter kozen jerzy tiuryn easy see result holds formulas form order 
termination assertions nondeterministic programs order tests total correctness assertions deterministic programs uninterpreted level reasoning recursively enumerable axiomatizable 
shall give explicit axiomatization section 
turn partial correctness 
theorem 
validity problem sublanguage dl consisting formulas form order program complete 
completeness property holds restrict range deterministic programs 
theorem extends easily partial correctness assertions formulas form order 
obviously better noteworthy uninterpreted level reasoning truth simple correctness assertions simple programs finitary complete axiomatization validities 
interpreted level characterizations various versions dl terms classical static logics established section provide precise complexity validity problem theorem 
validity problem dl dreg dl rich test intermediate versions defined vocabulary arithmetic 
spectral complexity introduce spectral complexity programming language 
mentioned notion provides measure complexity halting problem programs finite interpretations 
recall state finite variant constant valuation see section state initial differs individual variables 
initial state uniquely defined specifying relevant portion values individual variables 
call initial state state state specified tuple values am represent values individual variables xm call state am herbrand set fa am generates element obtained value term state ready define notion spectrum programming language 
programming language 
th dynamic logic spectrum set spm def finite structure state spectrum set sp def ng observe structures fc mg viewed structures form aw certain structure state representation unique 
section establish complexity spectra complexity halting problem finite interpretations 
fix rich vocabulary new constants binary string form structure state restrict attention strings form 
def fc mg easy show language logspace vocabulary 
ready connect complexity classes spectra 
programming language family sets 
say sp captures denoted sp sp program spm example class sets recognizable polynomial time sp means halting problem finite interpretations programs decidable polynomial time polynomial time recognizable set codes finite interpretations spectrum program conclude section characterizing spectral complexity programming languages introduced section 
theorem 
rich vocabulary 
sp dreg logspace 
ii sp reg nlogspace david harel dexter kozen jerzy tiuryn mono unary sp dreg captures logspace sp reg captures nlogspace theorem 
rich vocabulary sp sp stk capture theorem 
rich vocabulary sp sp array capture pspace 
dynamic logic axiomatization dl uninterpreted reasoning recall section validity dl complete restricted simple termination assertions 
means termination total correctness programs deterministic fully axiomatized standard sense 
turn problem axiomatizing full dl 
validity problem termination assertions interest find nicely structured complete axiom system 
propose 
axiom system axiom schemes instances valid order formulas instances valid formulas pdl order formula 
inference rules modus ponens denote provability axiom system theorem 
dl formula form order program containing order tests high undecidability validity dl hope complete axiom system usual sense 
want provide orderly axiomatization valid dl formulas means give finitary nature standard axiom systems 
complete infinitary axiomatization dl includes inference rule infinitely premises 
doing get certain technical complication way 
able consider valid order formulas axiom schemes instantiated general formulas dl 
order formulas amenable order manipulation able sense notions free occurrence david harel dexter kozen jerzy tiuryn substitution 
example able axiom scheme predicate calculus contains programs 
problem arises dynamic nature semantics dl may cause single occurrence variable dl formula act free bound occurrence 
example formula occurrence expression acts free occurrence assignment bound occurrence subsequent assignments 
reasonable ways deal definiteness 
loss generality assume required programs appear special form xn tuples variables stands 
xn similarly appear new variables appearing relevant context outside program idea programs act local variables copying values freezing executing program restoring form easily obtained dl formula consistently changing variables program new ones adding appropriate assignments copy restore values 
clearly new formula equivalent old 
dl formula form bound occurrences variables occurrences subformula form occurrences subformula form note occur occurrences subformula form occurrence assignment occurrence variable bound free 
axiom system axiom enables free translation special form discussed sequel assume special form required example assignment axiom scheme 
example consider formula denoting implication just convention result dynamic logic replacing free occurrences transformed special form 
want formula considered legal instance assignment axiom scheme 
axiom system axiom schemes instances valid order formulas instances valid formulas pdl occurrence program replaced program appearing occurrences replaced inference rules modus ponens generalization infinitary convergence provability axiom system denoted usual concept systems infinitary rules inference deriving formula infinitary rule requires infinitely premises previously derived 
axiom system consists axiom assignment facilities propositional reasoning programs order reasoning programs programs possibly appearing instantiated order formulas infinitary rule 
dual construct taken care unfolding validity pdl theorem 
formula dl david harel dexter kozen jerzy tiuryn interpreted reasoning proving properties real programs involves reasoning interpreted level interested validity particular structure typical proof induction length computation establish invariant partial correctness exhibit decreasing value wellfounded set termination 
case problem reduced problem verifying domain dependent facts called verification conditions 
mathematically speaking kind activity really effective transformation assertions programs ones underlying structure 
dl transformation guided direct induction program structure axiom system complete relative arithmetical structure essential idea exploit existence dl formula order equivalent guaranteed theorem 
axiom systems construct dealing hardness validity problem infinitary rule take valid order formulas additional axioms 
relative set axioms proofs finite effective 
partial correctness assertions form firstorder containing order tests suffices show dl reduces order logic 
need natural numbers 
axiom system works finite structures 
axiom system complete system full dl explicit natural numbers 
follows theorem partial correctness formulas hope obtain completeness result similar proved theorem termination formulas 
way difficulty consider expressive structures 
structure order vocabulary said expressive programming language order formula exists order formula 
examples structures expressive programming languages finite structures arithmetical structures 
axiom system axiom schemes instances valid formulas pdl order 
inference rules dynamic logic modus ponens generalization note axiom system really axiom system pdl section addition assignment axiom 
dl formula structure denote provability system obtained axiom system adding set axioms valid order sentences 
theorem 
expressive structure formula dl form order involves order tests axiom system full dl 
similar spirit complete relative formulas valid structure consideration 
system works arithmetical structures 
tailored deal expressive structures notably finite ones requires natural numbers 
kind completeness result stated termed arithmetical 
section state results special structure omitting technicalities needed deal general arithmetical structures 
main difference variables knowing values natural numbers 
write example assuming standard interpretation 
working unspecified arithmetical structure precede usage appropriate predicates guarantee talking part domain isomorphic natural numbers 
example order formula call nat true precisely elements representing natural numbers exists definition arithmetical structure 
axiom system axiom schemes instances valid order formulas instances valid formulas pdl order 
david harel dexter kozen jerzy tiuryn inference rules modus ponens generalization convergence order variable appearing 
general arithmetical structures rule convergence denote suitable order definitions 
axiom system denote provability system obtained axiom system adding valid order sentences axioms 
theorem 
formula dl natural numbers device counting convergence rule axiom system relaxed 
fact founded set suitably expressible arithmetical structure suffices 
necessary require execution causes truth parameterized rule decrease exactly suffices decrease positive iteration 
closing note appropriately restricted versions axiom systems section complete dl dreg 
particular pointed section hoare rule results combining generalization rule induction test axioms pdl restricted appear context statement form 
dynamic logic expressiveness dl subject study section relative expressive power languages 
primarily interested comparing uninterpreted level expressive power various versions dl 
programming languages study dl dl holds 
recall section relation means formula dl formula dl structures initial states studying expressive power logics computational power programs allows compare example deterministic nondeterministic programming languages 
see answer fundamental question dl dl may depend crucially vocabulary consider logics programs 
reason clear theorems section assumptions vocabulary 
theorem 
rich vocabulary 
dl stk dl array 
ii dl stk dl array iff pspace holds deterministic regular programs algebraic stack deterministic regular programs arrays 
theorem 
monadic vocabulary nondeterministic regular programs boolean stack computational power nondeterministic regular programs algebraic stack 
investigate role nondeterminism plays expressive power logics programs 
shall see general programming language sufficient computational power nondeterminism increase expressive power logic 
start discussion role nondeterminism basic case regular programs 
recall dl ddl denote logics nondeterministic deterministic regular programs respectively 
state main result separates expressive power deterministic nondeterministic programs 
theorem 
vocabulary containing unary function symbols function symbol arity greater ddl strictly expressive dl ddl dl 
turns theorem extended vocabularies containing just unary function symbol solving known open problem complexity theory 
theorem 
rich mono unary vocabulary statement ddl strictly expressive dl equivalent logspace nlogspace david harel dexter kozen jerzy tiuryn turn attention discussion role nondeterminism plays expressive power regular programs boolean stack 
vocabulary containing unary function symbols nondeterminism increases expressive power dl regular programs boolean stack 
rest section vocabulary contain unary function symbols 
theorem 
vocabulary containing unary function symbols function symbol arity greater dl dl 
turns programming languages sufficiently strong data types nondeterminism increase expressive power dynamic logic 
theorem 
vocabulary dl dl stk ii dl dl array 
discuss role unbounded memory programs expressive power corresponding logic 
result depends assumptions vocabulary 
recall section program bounded memory set cs contains finitely distinct variables addition nesting function symbols terms occur seqs cs bounded 
restriction implies program simulated interpretations device uses fixed finite number registers say xn elementary steps consist performing test form ary relation symbol executing simple assignment forms general device may need powerful control turing machine decide elementary step take 
example programming language bounded memory class regular programs boolean stack 
boolean stack strengthens control structure regular program introducing extra registers storing algebraic elements 
shown difficulty regular programs boolean stack bounded memory 
hand regular programs algebraic stack arrays programming languages unbounded memory 
monadic vocabularies class nondeterministic regular programs boolean stack computationally equivalent class nondeterministic regular programs algebraic stack 
deterministic programs situation slightly different 
dynamic logic theorem 
vocabulary containing function symbol arity greater dl dl dl dl stk 
ii monadic vocabularies dl dl stk 
iii mono unary vocabularies dl dl 
iv monadic vocabularies containing function symbols dl dl 
regular programs boolean stack situated pure regular programs regular programs algebraic stack 
start discussion comparing expressive power regular programs boolean stack 
known definite answer problem result covers case deterministic programs 
theorem 
vocabulary rich mono unary 
dl dreg dl logspace ii vocabulary contains function symbol arity greater unary function symbols dl dreg dl 
known theorem ii holds nondeterministic programs statement known equivalent known open problems complexity theory 
contrast follows theorems iii rich mono unary vocabularies dl dreg dl logspace problem solved solving major open problems complexity theory 
wildcard assignment statement discussed section chooses element domain computation nondeterministically assigns device represents unbounded nondeterminism opposed binary nondeterminism nondeterministic choice construct 
programming language regular programs augmented wildcard assignment acceptable programming language wildcard assignment produce values outside substructure generated input 
result shows wildcard assignment increases expressive power quite substantial way simulated programs 
theorem 
vocabulary contain constants binary predicate symbol symbol equality function predicate symbols 
formula dl wild equivalent formula dl dl wild dl 
david harel dexter kozen jerzy tiuryn known logics unbounded memory reducible dl wild 
wildcard array assignments allowed possible define finiteness domain structure logics additions removed 
having memory nondeterminism unbounded provides power having bounded 
theorem 
vocabulary contain symbol equality 
formula dl array wild equivalent formula dl array dl wild 
dynamic logic variants dl section consider restrictions extensions dl 
interested mainly questions comparative expressive power uninterpreted level 
arithmetical structures questions usually trivial difficult go power order arithmetic allowing infinitely distinct tests programs see theorems 
regular dl luxury 
algorithmic logic algorithmic logic predecessor dynamic logic 
basic system defined generated extensive amount subsequent research carried group mathematicians working warsaw 
surveys years original version allowed deterministic programs formulas built constructs corresponding terminology 
respectively deterministic program quantifier free order formula 
extended allow nondeterministic programs constructs 
corresponding terminology halt respectively 
asserts traces finite terminate state satisfying 
feature dl set dynamic terms addition dynamic formulas 
order term deterministic program meaning expression value executing program halt meaning undefined 
terms systematically eliminated example replaced 
david harel dexter kozen jerzy tiuryn emphasis early research obtaining infinitary completeness results developing normal forms programs investigating recursive procedures parameters axiomatizing certain aspects programming formulas example algorithmic formula pop viewed axiom connected data structure stack 
investigate consequences axioms regarding properties corresponding data structures 
complete infinitary deductive systems order propositional versions infinitary completeness results usually proved algebraic methods sikorski constable constable donnell goldblatt logics similar dl reasoning deterministic programs 
foundedness section pdl consider adding dl assertions effect programs enter infinite computations 
shall interested ldl rdl versions halt wf respectively added inductively new formulas program mentioned connection common notation repeat loop names ldl rdl derive loop def halt repeat def wf state relevant results 
concerns addition halt theorem 
ldl dl 
contrast theorem 
ldl rdl 
turning validity problem extensions clearly harder decide dl complete 
result shows detecting absence infinite computations simple uninterpreted programs extremely hard 
theorem 
validity problems formulas form wf formulas form halt order regular complete 
constrained order tests wf case remains complete halt case complete 
dynamic logic just mention additions axiom system section obtain complete system rdl axiom 
wf inference rule wf order occurring probabilistic programs wide interest programs employ probabilistic moves coin tossing random number draws behavior described probabilistically example correct meant probability 
give known example taken miller rabin fast probabilistic algorithms checking primality numbers known fast nonprobabilistic ones 
synchronization problems including digital contract signing guaranteeing mutual exclusion solved probabilistic means 
interest prompted research formal informal methods reasoning probabilistic programs 
noted methods applicable reasoning probabilistically ordinary programs example average case complexity analysis program inputs regarded coming set probability distribution 
kozen provided formal semantics probabilistic order programs random assignment statement 
term random quite appropriate contrast section statement essentially picks element fixed distribution domain domain assumed appropriate set measurable subsets 
programs interpreted measurable functions certain measurable product space copies feldman harel probabilistic version order dynamic logic dl investigated interpreted level 
kozen semantics extended described semantics formulas closed boolean connectives quantification reals integers employ terms form order 
addition program nondeterministic assignments formula new formula 
semantics assumes domain say reals measure space consisting appropriate family measurable subsets states taken positive measures measure space 
terms interpreted functions states real numbers frequency simply measure 
frequency positive measures probability david harel dexter kozen jerzy tiuryn probability measures 
formula true true state measure result applying kozen semantics 
means construct analogous dl 
example dl write gf mean halts probability 
formula valid structures distribution random variable uniform distribution real interval 
axiom system dl proved feldman harel complete relative extension order analysis integer variables discrete probabilities order analysis integer variables shown suffice 
dynamic logic approaches discuss briefly topics closely related dynamic logic 
logic effective definitions logic effective definitions led introduced tiuryn intended study notions computability models provide universal framework study logics programs models 
consists order logic augmented new atomic formulas form effective definitional schemes notion due friedman quantifier free formulas terms bounded set variables function 
recursive 
formula defined true state terminate yield value terminates 
model theory infinitary completeness led treated tiuryn effective definitional schemes definition led replaced programming language giving rise various logical formalisms 
result relates led logics discussed proved meyer tiuryn meyer tiuryn theorem 
vocabulary led dl 
temporal logic temporal logic tl alternative application modal logic program specification verification 
proposed useful tool program verification pnueli developed authors various forms 
topic surveyed depth emerson gabbay tl differs dl chiefly endogenous programs explicit language 
application single program associated language may contain program specific statements meaning execution currently location program 
competing semantics giving rise different theories called linear time branching time tl 
model linear sequence program states representing execution sequence deterministic program possible execution sequence nondeterministic concurrent program 
model tree david harel dexter kozen jerzy tiuryn program states representing space possible traces nondeterministic concurrent program 
depending application semantics different syntactic constructs chosen 
relative advantages linear branching time semantics discussed lamport emerson halpern emerson lei vardi modal constructs tl include holds states holds state holds state exists strictly point satisfied points strictly current state satisfy linear time logic constructs expressing traces starting state trace starting state branching time logic 
temporal logic useful situations programs normally supposed halt operating systems particularly suited study concurrency 
classical program verification methods intermittent assertions method treated quite elegantly framework 
temporal logic successful providing tools proving properties concurrent finite state protocols solutions dining philosophers mutual exclusion problems popular versions synchronization resource management problems distributed systems 
induction principle tl takes form note similarity pdl induction axiom axiom viii classical program verification method known inductive invariant assertions 
operators defined terms vice versa 
shown kamp gabbay operator powerful express expressed order theory dynamic logic wolper simple predicates expressed example true multiple 
operator shown useful expressing properties programs properties input output relation process requests resource receive 
research tl concentrated providing useful methods proving kinds properties see manna pnueli gabbay 
concurrency nondeterminism dl tl applied programs normally supposed halt operating systems programs interpreted traces pairs states 
considered deterministic single process programs 
reason apply tl nondeterministic concurrent multiprocessor systems states unique 
computation longer single trace different traces possible 
assemble get computation tree node represents state accessible start state 
invariance property property form 
dual operator defined way really capture mean eventuality liveness properties 
able say possible trace computation tree state satisfying 
instance nondeterministic program total chance infinite trace start state trace satisfies halt 
dual defined really express 
says node tree useful statement 
way fix introduce branching time operator says traces tree sense linear tl applied trace quantified dual says exists trace tree order say computation tree starting current state satisfies safety invariance property write says traces current state satisfies say tree satisfies eventuality property write says traces current state satisfies occurs trace 
logic linear temporal operators david harel dexter kozen jerzy tiuryn augmented trace quantifiers known ctl see emerson emerson halpern emerson halpern emerson lei emerson sistla complexity deductive completeness useful axiomatization linear time tl operator axioms 
free rules compare axioms pdl axioms 
propositional fragment deductive system complete linear time propositional tl shown gabbay sistla clarke emerson halpern shown validity problem versions propositional tl pspace complete linear structures exptime complete branching structures 
embedding tl dl tl subsumed dl 
embed propositional tl pdl take atomic program mean step program 
linear model tl constructs expressed respectively 
process logic dynamic logic temporal logic embody markedly different approaches reasoning programs 
dichotomy prompted researchers search appropriate process logic combines best features 
appropriate candidate combine ability reason programs compositionally dynamic logic ability reason directly intermediate states encountered course computation 
pratt parikh nishimura harel suggested increasingly powerful propositional level formalisms basic idea interpret formulas traces states 
particular harel system called process logic pl essentially union tl test free regular pdl 
proves satisfiability problem decidable gives complete finitary axiomatization 
syntactically programs propositions pdl 
atomic symbols type compound expressions built operators 
applied boolean combinations atomic formulas 
addition temporal operators rst 
temporal operators available expressing reasoning trace properties programs constructed compositionally pdl 
operators defined pdl see section skip handled specially 
semantically programs propositions interpreted sets traces 
start kripke frame mk section set states function mk interprets atomic formulas subsets atomic programs binary relations temporal operators defined tl 
trace models satisfy pdl axioms 
section define halt def def halt inf def say trace length finite length infinite length respectively 
define new operators def def operator pdl 
shown pdl axioms hold establishing mk mk mk mk mk mk mk david harel dexter kozen jerzy tiuryn mentioned version pl harel decidable nonelementary time complete 
shown restrict semantics include finite traces necessary restriction obtaining results pl expressive pdl 
translations pl structures pdl structures investigated making possible elementary time decision procedure deterministic pl see halpern halpern extension pl rst replaced regular operators formulas shown decidable nonelementary harel logic comes closer desired objective powerful decidable logic traces natural syntactic operators closed attachment regular programs formulas 
calculus calculus suggested formalism reasoning programs scott de bakker developed hitchcock park park de bakker heart approach fixpoint operator captures notions iteration recursion 
calculus originally defined firstorder level formalism propositional versions popular 
operator binds relation variables 
logical expression free relation variable expression represents exists 
example reflexive transitive closure binary relation binary relation containing closed reflexivity transitivity expressed order calculus def read binary relation related related captures usual fixpoint formulation reflexive transitive closure 
formula regarded recursive program computing inductively defined assertion true pair iff pair reflexive transitive closure existence fixpoint guaranteed certain restrictions 
formula fixpoint exist 
typically restricts application binding operator formulas positive syntactically monotone formulas free occurrence occurs scope number negations 
implies relation operator 
semantically monotone knaster tarski theorem ensures existence fixpoint 
order calculus define sets definable order induction 
particular capture input output relation program built dl programming constructs discussed 
dynamic logic order calculus admits order quantification easily seen powerful dl 
shown park finiteness definable order calculus monotonicity restriction foundedness version calculus independent ck 
dl expressive power 
foundedness binary relation written severe syntactic restriction binding operator allow application formulas syntactically continuous formulas occur free scope negation universal quantifier 
shown syntactic restriction implies semantic continuity fixpoint union shown park version strictly weaker ck 
pratt kozen kozen propositional versions calculus introduced 
version consists propositional modal logic fixpoint operator 
powerful logic type subsuming known variants pdl game logic parikh various forms temporal logic see section seemingly stronger forms calculus vardi wolper 
presentation focus version gained fairly widespread acceptance see kozen kozen parikh streett streett emerson vardi wolper walukiewicz walukiewicz walukiewicz stirling language propositional calculus called modal calculus syntactically simpler pdl 
consists usual propositional constructs atomic modalities fixpoint operator 
greatest fixpoint operator dual defined def variables monadic operator may applied syntactically monotone formulas 
discussed ensures monotonicity corresponding set operator 
language interpreted kripke frames atomic propositions interpreted sets states atomic programs interpreted binary relations states 
propositional calculus subsumes pdl 
example pdl formula atomic written 
formula expresses existence forced win player player game formula expresses foundedness equivalent wf see section inexpressible pdl shown streett kozen shown addition halt construct pdl strictly expressive calculus 
david harel dexter kozen jerzy tiuryn propositional calculus satisfies finite model theorem shown kozen progressively better decidability results obtained kozen parikh vardi stockmeyer vardi culminating deterministic exponential time algorithm emerson jutla automata theoretic lemma safra calculus subsumes pdl exptime complete 
kozen kozen axiomatization propositional calculus proposed conjectured complete 
axiomatization consists axioms rules propositional modal logic plus axiom rule 
completeness deductive system syntactically restricted subset formulas shown kozen kozen completeness full language proved walukiewicz walukiewicz quickly followed simpler alternative proofs ambler kwiatkowska showed alternating hierarchy greatest fixpoints strict 
interesting open question complexity model checking formula propositional calculus hold state kripke frame 
progress see bhat cleaveland cleaveland emerson lei smolka stirling walker unknown problem polynomial time algorithm 
propositional calculus popular system specification verification properties transition systems practical impact steffen 
papers model checking context see bhat cleaveland cleaveland emerson lei smolka stirling walker comprehensive stirling kleene algebra kleene algebra ka algebra regular expressions 
named mathematician kleene achievements invented regular expressions proved equivalence finite automata kleene kleene algebra appeared various guises names relational algebra ng ng tarski semantics logics programs kozen pratt automata formal language theory kuich kuich salomaa design analysis algorithms aho dynamic logic tarjan mehlhorn steiglitz kozen 
discussed section kleene algebra plays prominent role dynamic algebra algebraic model program behavior 
monograph conway authors contributed years development algebraic theory see backhouse kleene kuich salomaa kozen bloom hopkins kozen see kozen 
kleene algebra algebraic structure 
satisfying axioms refers natural partial order def short ka idempotent semiring 
solution solution axioms say essentially behaves operator sets strings reflexive transitive closure binary relations 
particular axiomatization kozen kozen competing ones 
axioms correspond reflexive transitive closure rule rtc pdl section 
postulate equivalent axioms correspond loop invariance rule li 
induction axiom ind inexpressible ka negation 
kleene algebra continuous satisfies infinitary condition sup david harel dexter kozen jerzy tiuryn def def supremum respect natural order 
think conjunction infinitely axioms infinitary horn formula presence axioms continuity condition implies strictly stronger sense exist kleene algebras continuous kozen 
fundamental motivating example kleene algebra family regular sets strings finite alphabet classes structures share equational theory notably binary relations set 
fact interpretation kleene algebra suitable choice modeling programs dynamic algebras 
unusual interpretations min algebra shortest path algorithms see aho tarjan mehlhorn kozen kas convex polyhedra computational geometry described steiglitz axiomatization equational theory regular sets central question going back original kleene completeness theorem relational algebras extended language ng ng tarski axiomatization central focus monograph conway bulk treatment infinitary 
proved finite equational axiomatization 
schematic equational axiomatizations algebra regular sets necessarily representing infinitely equations bloom salomaa gave finitary complete axiomatizations sound regular sets sound general standard interpretations including relational interpretations 
axiomatization finitary universal horn axiomatization sound complete equational theory standard relational language theoretic models including regular sets kozen kozen 
completeness appears literature contains bewildering array inequivalent definitions kleene algebras related algebraic structures see conway pratt pratt kozen kozen aho mehlhorn kuich kozen demonstrated kozen strongly related 
important property shared closure formation matrices 
proved axiomatization kozen kozen idea essentially goes back kleene conway backhouse result gives rise algebraic treatment dynamic logic finite automata automata represented transition matrices 
equational theory kleene algebra pspace complete stockmeyer meyer apparently complex pdl exptime complete theorem strict separation complexity classes open 
kleene algebra tests practical standpoint simple program manipulations loop unwinding basic safety analysis require full power pdl carried purely equational subsystem axioms kleene algebra 
tests essential ingredient needed model conventional programming constructs conditionals loops handle assertions 
motivates definition variant ka introduced kozen kozen kleene algebra tests kat kleene algebra embedded boolean subalgebra 
formally sorted algebra 

kleene algebra 
boolean algebra unary negation operator defined elements called tests written elements including elements written pdl test written kat dispense symbol 
deceptively concise definition carries lot information 
operators 
play roles applied arbitrary elements refer nondeterministic choice composition fail skip respectively applied tests take additional meaning boolean disjunction conjunction falsity truth respectively 
usages conflict example sequential testing tests testing conjunction coexistence admits considerable economy expression 
applications program verification standard interpretation kleene algebra binary relations set boolean algebra subsets identity relation 
consider trace models kleene elements sets traces sequences states boolean elements sets states traces length 
ka form algebra david harel dexter kozen jerzy tiuryn matrices kat boolean elements structure diagonal matrices kat express conventional imperative programming constructs conditionals loops pdl 
perform elementary program manipulation loop unwinding constant propagation basic safety analysis purely equational manner 
applicability kat related equational systems practical program verification explored cohen cohen cohen kozen kozen patron language theoretic model plays role kat regular sets play ka algebra regular sets guarded strings corresponding completeness result obtained kozen smith kat complete equational theory relational models shown kozen smith expressive pdl kat apparently difficult decide pspace complete ka shown cohen kozen shown kat subsumes propositional hoare logic sense 
partial correctness assertion encoded kat equation equivalently rule derivable propositional hoare logic translation universal horn formula 
theorem kat 
example rule hoare logic see section generally relationally valid horn formulas form 
theorems kat kozen 
horn formulas important practical standpoint 
example commutativity conditions model idea execution certain instructions affect result certain tests 
light complexity universal horn theory ka kat interest 
positive negative results 
shown kozen horn formula continuous kleene algebras contains commutativity conditions universal horn theory complete dynamic logic contains monoid equations problem complete arbitrary finite sets equations problem complete 
hand commutativity assumptions form test assumptions form eliminated loss efficiency shown cohen kozen smith note assumptions form need encode hoare logic described 
typed kleene algebra introduced kozen kozen elements types allows kleene algebras matrices applications 
shown kozen hoare logic subsumed type calculus typed ka augmented coercion rule tests 
hoare style reasoning partial correctness assertions reduces typechecking relatively simple type system 
dynamic algebra dynamic algebra provides algebraic framework relates pdl boolean algebra relates propositional logic 
dynamic algebra defined sorted algebraic structure 
boolean algebra 
kleene algebra see section 
scalar multiplication satisfying algebraic constraints corresponding dual forms pdl axioms axioms 
example dynamic algebras satisfy equations 

correspond pdl validities respectively 
boolean algebra abstraction formulas pdl kleene algebra abstraction programs 
interaction scalar multiplication iteration axiomatized finitary infinitary way 
postulate 
david harel dexter kozen jerzy tiuryn corresponding diamond form pdl induction axiom axiom viii 
iff alternatively postulate stronger axiom continuity 
sup 
think conjunction infinitely axioms infinitary horn formula presence axioms implies kozen strictly stronger sense dynamic algebras continuous pratt 
standard kripke frame mk pdl gives rise continuous dynamic algebra consisting boolean algebra subsets kleene algebra binary relations operators interpreted pdl including 
empty program 
identity program 

nonstandard kripke frames see section give rise dynamic algebras necessarily continuous ones 
dynamic algebra separable pair distinct kleene elements distinguished boolean element exists 

research directions area include 
representation theory 
known separable dynamic algebra isomorphic possibly nonstandard kripke frame 
certain conditions possibly nonstandard replaced standard general continuous algebras kozen kozen kozen 
algebraic methods pdl 
small model property theorem completeness theorem pdl established purely algebraic considerations pratt 
comparative study alternative axiomatizations example known separable dynamic algebras distinguished standard kripke frames order formula 
distinguish continuous separable dynamic algebras kozen 
equational theory dynamic algebras 
seemingly unrelated models computation share equational theory dynamic algebras pratt pratt 
addition interesting questions arise algebraic viewpoint interesting connections topology classical algebra model theory kozen 
dynamic logic bibliographical notes systematic program verification originated floyd hoare hoare logic introduced hoare see cousot apt apt olderog surveys 
digital abstraction view computers state transformers operate performing sequence discrete instantaneous primitive steps attributed turing finite state transition systems defined formally mcculloch pitts state transition semantics idea quite prevalent early program semantics verification see hennessy plotkin relational algebraic approach taken programs interpreted binary input output relations introduced context dl pratt notions partial total correctness early hoare regular programs introduced fischer ladner context pdl 
concept nondeterminism introduced original turing develop idea 
nondeterminism developed rabin scott context finite automata 
burstall suggested modal logic reasoning programs pratt prompted suggestion moore shown extend modal logic useful way considering separate modality program 
research devoted propositional reasoning programs fischer ladner fischer ladner pdl 
mentioned preface general logical systems reasoning programs suggested semantics kripke semantics studied see berman nishimura kozen kozen pratt modal logic applications vast literature introductions hughes cresswell chellas alternative iterative guarded commands studied gries partial correctness assertions hoare rules section formulated hoare regular expressions regular program operators introduced kleene algebraic theory investigated conway applied context dl fischer ladner fischer ladner axiomatization pdl axioms formulated segerberg tests converse investigated various authors see peterson berman berman paterson streett streett vardi continuity diamond operator presence reverse due filtration argument small model property pdl due fischer ladner fischer ladner nonstandard kripke frames pdl studied berman berman parikh pratt pratt kozen kozen kozen kozen david harel dexter kozen jerzy tiuryn kozen axiomatization pdl axiom system introduced segerberg completeness shown independently gabbay parikh short easy follow proof kozen parikh completeness treated pratt pratt berman nishimura kozen exponential time lower bound pdl established fischer ladner fischer ladner showing pdl formulas encode computations linear space bounded alternating turing machines 
deterministic exponential time algorithms pratt pratt pratt theorem showing problem deciding fixed set pdl formulas complete due meyer computational difficulty validity problem nonregular pdl borderline decidable undecidable discussed harel fact nonregular program adds expressive power pdl theorem appeared explicitly harel theorem undecidability context free pdl observed ladner theorems harel alternative proof theorem tiling supplied harel see harel existence primitive recursive letter extension pdl undecidable shown harel undecidability particular case theorem harel paterson theorem harel decidable extensions theorem proved koren pnueli general results section theorems harel raz notion simple minded pda 
decidability emptiness pushdown stack automata trees needed proofs harel raz better bound complexity emptiness results peng iyer sufficient condition pdl addition program single letter alphabet finite model property harel completeness exponential time decidability theorem upper bound theorem proved ben ari lower bound theorem parikh theorems halpern reif halpern reif tests add power pdl proved berman paterson known test depth hierarchy strict berman peterson rich test pdl strictly expressive poor test pdl peterson berman berman paterson results hold 
results programs automata theorems appear pratt dynamic logic alternative proofs harel sherman see harel years development automata theoretic approach logics programs prompted renewed inquiry complexity automata infinite objects considerable success 
see courcoubetis yannakakis emerson emerson jutla emerson sistla manna pnueli muller safra sistla streett vardi vardi vardi vardi stockmeyer vardi wolper vardi wolper arnold arnold thomas especially noteworthy area result safra involving complexity converting nondeterministic automaton infinite strings equivalent deterministic 
result significant impact complexity decision procedures logics programs see courcoubetis yannakakis emerson jutla emerson jutla safra intersection programs studied harel axioms converse yield completeness proved parikh complexity pdl converse various forms foundedness constructs studied vardi authors studied logics fixpoint operator propositional order levels scott de bakker hitchcock park park pratt kozen kozen kozen kozen parikh streett vardi stockmeyer 
version propositional calculus introduced kozen kozen propositional calculus strictly expressive pdl wf show streett logic strictly expressive pdl halt shown harel sherman logic strictly expressive pdl shown streett wf construct complement repeat investigated streett streett theorems due pratt proved 
halt construct complement loop introduced harel pratt theorem harel sherman finite model properties logics propositional calculus established streett streett kozen decidability results obtained streett streett kozen parikh vardi stockmeyer vardi deterministic exponential time completeness established emerson jutla safra strongest variant exponential time decidability follows vardi concurrent pdl defined studied peleg additional versions logic employ various mechanisms communication concurrent parts program considered peleg peleg papers contain results concerning expressive power decidability undecidability concurrent pdl communication 
pdl described includes nonstandard models david harel dexter kozen jerzy tiuryn studied berman berman parikh pdl boolean assignments studied abrahamson restricted forms consequence problem studied parikh order dl defined harel named dynamic logic 
carried direct continuation original pratt variants dl defined harel particular dl close context free dynamic logic investigated 
uninterpreted reasoning form program common activity considerable impetus luckham paterson hewitt see greibach study correctness interpreted programs goes back turing von neumann defined area research floyd hoare manna embedding logics programs 
observations theorem meyer parikh theorem harel see harel harel kozen similar expressiveness result cook theorem corollary harel kozen arithmetical structures defined moschovakis name acceptable structures 
context logics programs reintroduced studied harel completeness dl proved meyer theorem appears harel alternative proof harel see harel theorem meyer halpern fragment dl considered theorem proved pratt theorem follows harel kozen name spectral complexity proposed tiuryn main ideas results concerning notion tiuryn urzyczyn see tiuryn urzyczyn full version 
notion instance called second order spectrum formula 
firstorder spectra investigated originates known 
reader find problem related results survey notion natural chain urzyczyn results tiuryn urzyczyn tiuryn urzyczyn result similar theorem area finite model theory obtained sazonov independently gurevich higher order stacks introduced engelfriet study complexity classes 
higher order arrays stacks dl considered tiuryn strict hierarchy class elementary recursive sets established 
main tool proof strictness hierarchy generalization cook auxiliary pushdown automata theorem higher order stacks due kowalczyk dynamic logic meyer halpern showed completeness termination assertions theorem 
infinitary completeness dl theorem similar result algorithmic logic see section proof sketch harel adaptation henkin proof 
appearing keisler notion relative completeness theorem due cook notion arithmetical completeness theorem harel invariants prove partial correctness founded sets prove termination due floyd excellent survey methods corresponding completeness results appears apt contrasting negative results contained clarke lipton wand results relative expressiveness answer questions posed harel similar uninterpreted research comparing expressive power classes programs detached surrounding logic taken place name comparative quite extensively see greibach manna theorems result application called spectral theorem connects expressive power logics complexity classes 
theorem obtained tiuryn urzyczyn tiuryn urzyczyn tiuryn urzyczyn simplified framework approach statement theorem proof harel theorem appears berman proved independently stolboushkin alternative proof tiuryn results extend substantial way earlier simpler result case regular programs equality vocabulary appears halpern simpler proof special case quantifier free fragment logic regular programs appears meyer theorem tiuryn urzyczyn theorem stolboushkin proof case regular programs see stolboushkin uses result group theory 
results expressive power dl deterministic programs boolean stack stolboushkin kfoury theorem tiuryn urzyczyn tiuryn urzyczyn tiuryn tiuryn kfoury kfoury stolboushkin contain results expressive power dl programming languages bounded memory 
shows dl dreg dl 
main proof technique pebble games finite trees 
theorem urzyczyn different proof result structures appears stolboushkin theorem urzyczyn studies programs boolean arrays 
wildcard assignments considered harel name nondeterministic assignments 
theorem meyer david harel dexter kozen jerzy tiuryn theorem meyer parikh exposition comparison expressive power logics assumption programs quantifier free order tests 
follows results urzyczyn allowing full order tests cases results increased expressive power 
urzyczyn proves adding array assignments nondeterministic programs increases expressive power logic 
contrasted result meyer tiuryn meyer tiuryn effect deterministic programs array assignments increase expressive power 
considers weaker notion equivalence logics common investigations model theory models extended interpretations additional predicate symbols 
notion shown versions logics programs treated equivalent 
algorithmic logic introduced extended allow nondeterministic programs studied operators 
complete infinitary deductive systems propositional order versions algebraic methods sikorski surveys early constable constable donnell goldblatt logics similar dl reasoning deterministic programs 
nonstandard dynamic logic introduced andr studied see information 
halt construct complement loop introduced harel pratt wf construct complement repeat investigated pdl streett streett theorem meyer theorem harel peleg theorem harel axiomatizations ldl pdl discussed harel harel dynamic algebra introduced kozen pratt studied numerous authors see kozen kozen kozen kozen pratt pratt pratt survey main results appears kozen phd thesis ramshaw contains engaging subject probabilistic semantics verification 
kozen provided formal semantics probabilistic programs 
logic dl feldman harel deductive system complete kozen semantics relative extension order analysis 
various propositional versions probabilistic dl proposed reif feldman parikh mahoney kozen temporal approach probabilistic verification studied lehmann dynamic logic shelah hart courcoubetis yannakakis vardi interest subject probabilistic verification undergone revival see morgan segala lynch hansson jonsson jou smolka baier kwiatkowska huth kwiatkowska blute concurrent dl defined studied peleg additional versions logic employ various mechanisms communication concurrent parts program considered peleg peleg david harel dexter kozen jerzy tiuryn david harel weizmann institute science rehovot israel dexter kozen cornell university ithaca new york jerzy tiuryn university warsaw warsaw poland bibliography abrahamson abrahamson 
decidability expressiveness logics processes 
phd thesis univ washington 

problem identities groups 
springer verlag 
aho alfred aho john hopcroft jeffrey ullman 
design analysis computer algorithms 
addison wesley reading mass 
ambler ambler kwiatkowska 
duality completeness modal calculus 
theor 
comput 
sci november 
andr 
complete logic reasoning programs nonstandard model theory part theor 
comput 
sci 
andr 
complete logic reasoning programs nonstandard model theory part ii 
theor 
comput 
sci 
apt olderog apt 
olderog 
verification sequential concurrent programs 
springer verlag 
apt plotkin apt plotkin 
countable nondeterminism random assignment 
assoc 
comput 
mach 
apt apt 
years hoare logic survey part acm trans 
programming languages systems 

new finite complete solvable calculus algebra regular languages 
manuscript state university 
arnold arnold 
initial semantics calculus trees rabin complementation lemma 
technical report university bordeaux 
arnold arnold 
calculus trees rabin complementation theorem 
technical report university bordeaux 
backhouse roland carl backhouse 
closure algorithms star height problem regular languages 
phd thesis imperial college london 
backhouse backhouse 
program construction verification 
prentice hall 
baier kwiatkowska christel baier marta kwiatkowska 
verification qualitative properties probabilistic processes fairness constraints 
information processing letters april 

algorithmic logic metamathematical investigations theory programs 
editors math 

comput 
sci pages 
banach center warsaw 
ben ari ben ari halpern pnueli 
deterministic propositional dynamic logic finite models complexity completeness 
comput 
syst 
sci 
berman paterson berman paterson 
propositional dynamic logic weaker tests 
theor 
comput 
sci 
berman berman halpern tiuryn 
power nondeterminism dynamic logic 
nielsen schmidt editors proc th colloq 
automata lang 
prog volume lect 
notes comput 
sci pages 
springer verlag 
berman berman 
expressiveness hierarchy pdl rich tests 
technical report comput 
sci 
dept univ washington 
berman berman 
completeness technique axiomatizable semantics 
proc 
th symp 
theory comput pages 
acm 
dynamic logic berman berman 
semantics looping programs propositional dynamic logic 
math 
syst 
theory 
bhat cleaveland bhat rance cleaveland 
efficient local model checking fragments modal calculus 
margaria steffen editors proc 
second int 
workshop tools algorithms construction analysis systems tacas volume lect 
notes comput 
sci pages 
springer verlag march 
bloom stephen bloom zoltan 
program correctness iteration theories 
proc 
th int 
conf 
mathematical foundations programming semantics volume lecture notes computer science pages 
springer verlag 
bloom stephen bloom zoltan 
equational axioms regular sets 
math 
struct 
comput 
sci 
blute blute desharnais panangaden 
bisimulation labeled markov processes 
proc 
th symp 
logic comput 
sci pages 
ieee 
maurice 
une sur les systemes 
informatique applications theoretical informatics applications 
maurice 
une condition les 
informatique applications theoretical informatics applications 
kwiatkowska kwiatkowska 
re interpreting modal calculus 
ponse van rijke venema editors modal logic process algebra pages 
csli lecture notes august 
borger 
completeness logical decision problems 
borger editors logic machines decision problems complexity proccedings volume lect 
notes comput 
sci pages 
springerverlag 
julian 
modal calculus alternation hierarchy strict 
montanari sassone editors proc 
concur volume lect 
notes comput 
sci pages 
springer 
burstall burstall 
program proving hand simulation little induction 
information processing pages 
chandra ashok chandra dexter kozen larry stockmeyer 
alternation 
assoc 
comput 
mach 
chellas chellas 
modal logic 
cambridge university press 
clarke clarke 
programming language constructs impossible obtain hoare axiom systems 
assoc 
comput 
mach 
cleaveland rance cleaveland 
efficient model checking equational calculus 
proc 
th symp 
logic comput 
sci pages 
ieee july 
cohen ernie cohen dexter kozen frederick smith 
complexity kleene algebra tests 
technical report computer science department cornell university july 
cohen ernie cohen 
hypotheses kleene algebra 
available ftp ftp telcordia com pub ernie research homepage html april 
cohen ernie cohen 
lazy caching 
available ftp ftp telcordia com pub ernie research homepage html 
cohen ernie cohen 
kleene algebra reason concurrency control 
available ftp ftp telcordia com pub ernie research homepage html 
constable donnell constable donnell 
programming logic 

constable constable 
theory programming logics 
proc 
th symp 
theory comput pages 
acm may 
conway john horton conway 
regular algebra finite machines 
chapman hall london 
cook cook 
soundness completeness axiom system program verification 
siam comput 
courcoubetis yannakakis courcoubetis yannakakis 
verifying temporal properties finite state probabilistic programs 
proc 
th symp 
foundations comput 
sci pages 
ieee october 
david harel dexter kozen jerzy tiuryn cousot patrick cousot 
methods logics proving programs 
van leeuwen editor theoretical computer science volume pages 
elsevier amsterdam 

completeness theorem dynamic logic 
notre dame formal logic 
davis davis sigal weyuker 
computability complexity languages fundamentals theoretical computer science 
academic press 
de bakker de bakker 
mathematical theory program correctness 
prentice hall 
emerson halpern emerson halpern 
decision procedures expressiveness temporal logic branching time 
comput 
syst 
sci 
emerson halpern emerson halpern 
revisited branching vs linear time temporal logic 
acm 
emerson jutla emerson jutla 
complexity tree automata logics programs 
proc 
th symp 
foundations comput 
sci pages 
ieee october 
emerson jutla emerson jutla 
simultaneously complementing automata 
proc 
th symp 
logic comput 
sci 
ieee june 
emerson lei emerson 
lei 
efficient model checking fragments propositional calculus 
proc 
st symp 
logic comput 
sci pages 
ieee june 
emerson lei emerson lei 
modalities model checking branching time strikes back 
sci 
comput 
programming 
emerson sistla emerson sistla 
deciding full branching time logic 
infor 
control 
emerson emerson 
automata temporal logics 
parikh editor proc 
workshop logics programs volume lect 
notes comput 
sci pages 
springer verlag 
emerson emerson 
temporal modal logic 
van leeuwen editor handbook theoretical computer science volume formal models semantics pages 
elsevier 

algorithmic properties structures 
math 
syst 
theory 
engelfriet engelfriet 
iterated pushdown automata complexity classes 
proceedings fifteenth annual acm symposium theory computing pages boston massachusetts 

expressive power programming logics 
proc 
conf 
research theoretical programming pages 
russian 
feldman harel feldman harel 
probabilistic dynamic logic 
comput 
syst 
sci 
feldman feldman 
decidable propositional dynamic logic explicit probabilities 
infor 
control 
fischer ladner michael fischer richard ladner 
propositional modal logic programs 
proc 
th symp 
theory comput pages 
acm 
fischer ladner michael fischer richard ladner 
propositional dynamic logic regular programs 
comput 
syst 
sci 
floyd floyd 
assigning meanings programs 
proc 
symp 
appl 
math volume pages 
ams 
friedman friedman 
algorithmic procedures generalized turing algorithms elementary recursion theory 
gandy yates editors logic colloq 
pages 
northholland 
gabbay gabbay pnueli shelah 
temporal analysis fairness 
proc 
th symp 

prog 
lang pages 
acm 
gabbay gabbay hodkinson reynolds 
temporal logic mathematical foundations computational aspects 
oxford university press 
gabbay gabbay 
axiomatizations logics programs 
unpublished 
goldblatt goldblatt 
logic computer programming volume lect 
notes comput 
sci 
springer verlag 
goldblatt goldblatt 
logics time computation 
technical report lect 
notes center study language information stanford univ 
dynamic logic greibach greibach 
theory program structures schemes semantics verification volume lecture notes computer science 
springer verlag 
gries gries 
science programming 
springer verlag 
gurevich yu 
gurevich 
algebras feasible functions 
th ieee annual symposium foundations computer science pages 
halpern reif halpern reif 
propositional dynamic logic deterministic structured programs 
proc 
nd symp 

comput 
sci pages 
ieee 
halpern reif halpern reif 
propositional dynamic logic deterministic structured programs 
theor 
comput 
sci 
halpern halpern 
expressive power dynamic logic ii 
technical report tm mit lcs 
halpern halpern 
deterministic process logic elementary 
proc 
rd symp 

comput 
sci pages 
ieee 
halpern halpern 
deterministic process logic elementary 
infor 
control 
hansson jonsson hansson jonsson 
logic reasoning time probability 
formal aspects computing 
harel kozen david harel dexter kozen 
programming language inductive sets applications 
information control 
harel paterson harel paterson 
undecidability pdl fa 
comput 
syst 
sci 
harel peleg harel peleg 
looping vs repeating dynamic logic 
information processing letters 
harel pratt harel pratt 
nondeterminism logics programs 
proc 
th symp 

prog 
lang pages 
acm 
harel raz harel raz 
deciding properties nonregular programs 
siam comput 
harel raz harel raz 
deciding emptiness stack automata infinite trees 
information computation 
harel sherman harel sherman 
looping vs repeating dynamic logic 
infor 
control 
harel sherman harel sherman 
propositional dynamic logic flowcharts 
infor 
control 
harel harel 
nonregular pdl finite models fibonacci programs 
information computation 
harel harel meyer pratt 
computability completeness logics programs 
proc 
th symp 
theory comput pages 
acm 
harel harel pnueli vardi 
dimensional temporal logic pdl intersection 
unpublished 
harel david harel dexter kozen rohit parikh 
process logic expressiveness decidability completeness 
comput 
syst 
sci 
harel harel pnueli 
propositional dynamic logic nonregular programs 
comput 
syst 
sci 
harel david harel dexter kozen jerzy tiuryn 
dynamic logic 
mit press cambridge ma 
harel harel 
order dynamic logic volume lect 
notes comput 
sci 
springer verlag 
harel harel 
dynamic logic 
gabbay guenthner editors handbook philosophical logic volume ii extensions classical logic pages 
reidel 
harel harel 
recurring dominoes making highly undecidable highly understandable 
annals discrete mathematics 
harel harel 
algorithmics spirit computing 
addison wesley second edition 
hart hart sharir pnueli 
termination probabilistic concurrent programs 
proc 
th symp 

prog 
lang pages 
acm 

duality modal logics 
theor 
comput 
sci 
david harel dexter kozen jerzy tiuryn hennessy plotkin hennessy plotkin 
full abstraction simple programming language 
proc 
symp 
semantics algorithmic languages volume lecture notes computer science pages 
springer verlag 
hitchcock park hitchcock park 
induction rules termination proofs 
nivat editor int 
colloq 
automata lang 
prog pages 
north holland 
hoare hoare 
axiomatic basis computer programming 
comm 
assoc 
comput 
mach 
hopkins kozen mark hopkins dexter kozen 
parikh theorem commutative kleene algebra 
proc 
conf 
logic computer science lics pages 
ieee july 
hughes cresswell hughes cresswell 
modal logic 
methuen 
huth kwiatkowska huth kwiatkowska 
quantitative analysis model checking 
proc 
th symp 
logic comput 
sci pages 
ieee 

logical schemes algorithms 
problems cybernetics volume pages 
pergamon press 
steiglitz kazuo kenneth steiglitz 
semiring convex polygons zero sum cycle problems 
siam comput 
jou smolka jou smolka 
equivalences congruences complete axiomatizations probabilistic processes 
proc 
concur volume lecture notes comput 
sci pages 
springer verlag 

automata characterise fixed point temporal logics 
phd thesis university edinburgh april 
report cst 
kamp kamp 
tense logics theory linear order 
phd thesis ucla 
keisler keisler 
model theory infinitary logic 
north holland 
kfoury stolboushkin kfoury stolboushkin 
infinite pebble game applications 
information computation 
kfoury kfoury 
definability programs order structures 
theoretical computer science 
kfoury kfoury 
definability deterministic nondeterministic programs applications order dynamic logic 
infor 
control 
kleene stephen kleene 
representation events nerve nets finite automata 
shannon mccarthy editors automata studies pages 
princeton university press princeton 

axiomatizations propositional logics programs 
technical report ruu cs rijksuniversiteit utrecht november 
koren pnueli koren pnueli 
exist decidable context free propositional dynamic logics 
proc 
symp 
logics programs volume lecture notes computer science pages 
springer verlag 
kowalczyk kowalczyk tiuryn 
generalization cook auxiliary pushdown automata theorem 
fundamenta informaticae xii 
kozen parikh dexter kozen rohit parikh 
elementary proof completeness pdl 
theor 
comput 
sci 
kozen parikh dexter kozen rohit parikh 
decision procedure propositional calculus 
clarke kozen editors proc 
workshop logics programs volume lecture notes computer science pages 
springer verlag 
kozen patron dexter kozen maria cristina patron 
certification compiler optimizations kleene algebra tests 
john lloyd veronica dahl ulrich furbach manfred kerber kung lau palamidessi luis pereira yehoshua sagiv peter stuckey editors proc 
st int 
conf 
computational logic cl volume lecture notes artificial intelligence pages london july 
springer verlag 
kozen smith dexter kozen frederick smith 
kleene algebra tests completeness decidability 
van dalen bezem editors proc 
th int 
workshop computer science logic csl volume lecture notes computer science pages utrecht netherlands september 
springer verlag 
kozen tiuryn dexter kozen jerzy tiuryn 
logics programs 
van leeuwen editor handbook theoretical computer science volume pages 
north holland amsterdam 
dynamic logic kozen dexter kozen 
dynamic algebra 
editor proc 
workshop logic programs volume lecture notes computer science pages 
springer verlag 
chapter propositional dynamic logics programs survey rohit parikh 
kozen dexter kozen 
duality dynamic algebras kripke models 
editor proc 
workshop logic programs volume lecture notes computer science pages 
springer verlag 
kozen dexter kozen 
representation dynamic algebras 
technical report rc ibm thomas watson research center october 
kozen dexter kozen 
representation dynamic algebras ii 
technical report rc ibm thomas watson research center may 
kozen dexter kozen 
representation theorem models free pdl 
proc 
th colloq 
automata languages programming pages 
eatcs july 
kozen dexter kozen 
logics programs 
lecture notes aarhus university denmark 
kozen dexter kozen 
induction vs continuity 
kozen editor proc 
workshop logic programs volume lecture notes computer science pages new york 
springer verlag 
kozen dexter kozen 
expressiveness 
manuscript 
kozen dexter kozen 
semantics probabilistic programs 
comput 
syst 
sci 
kozen dexter kozen 
results propositional calculus 
proc 
th int 
colloq 
automata languages programming pages aarhus denmark july 
eatcs 
kozen dexter kozen 
results propositional calculus 
theor 
comput 
sci 
kozen dexter kozen 
ramsey theorem infinitely colors 
lenstra lenstra van emde boas editors le parole pages 
university amsterdam amsterdam may 
kozen dexter kozen 
probabilistic pdl 
comput 
syst 
sci april 
kozen dexter kozen 
finite model theorem propositional calculus 
studia logica 
kozen dexter kozen 
kleene algebras closed semirings 
editor proc 
math 

comput 
sci volume lecture notes computer science pages slovakia 
springer verlag 
kozen dexter kozen 
completeness theorem kleene algebras algebra regular events 
proc 
th symp 
logic comput 
sci pages amsterdam july 
ieee 
kozen dexter kozen 
design analysis algorithms 
springer verlag new york 
kozen dexter kozen 
completeness theorem kleene algebras algebra regular events 
infor 
comput may 
kozen dexter kozen 
action algebras 
van eijck visser editors logic information flow pages 
mit press 
kozen dexter kozen 
kleene algebra tests commutativity conditions 
margaria steffen editors proc 
second int 
workshop tools algorithms construction analysis systems tacas volume lecture notes computer science pages passau germany march 
springer verlag 
kozen dexter kozen 
automata computability 
springer verlag new york 
kozen dexter kozen 
kleene algebra tests 
transactions programming languages systems may 
kozen dexter kozen 
complexity reasoning kleene algebra 
proc 
th symp 
logic comput 
sci pages los alamitos ca june 
ieee 
kozen dexter kozen 
typed kleene algebra 
technical report computer science department cornell university march 
kozen dexter kozen 
hoare logic kleene algebra tests 
proc 
conf 
logic computer science lics pages 
ieee july 
kozen dexter kozen 
hoare logic kleene algebra types 
technical report computer science department cornell university july 
abstracts th int 
congress logic methodology philosophy science ed 
david harel dexter kozen jerzy tiuryn poland august 
appear proc 
th int 
congress logic methodology philosophy science ed 
gardenfors kluwer 
daniel 
complete system rational identities 
theoretical computer science october 
kuich salomaa werner kuich salomaa 
semirings automata languages 
springer verlag berlin 
kuich werner kuich 
kleene parikh theorem complete semirings 
ottmann editor proc 
th colloq 
automata languages programming volume lecture notes computer science pages new york 
eatcs springer verlag 
ladner ladner 
unpublished 
lamport lamport 

proc 
th symp 

prog 
lang pages 
lehmann shelah lehmann shelah 
reasoning time chance 
infor 
control 
lewis papadimitriou harry lewis christos papadimitriou 
elements theory computation 
prentice hall 
lipton lipton 
necessary sufficient condition existence hoare logics 
proc 
th symp 

comput 
sci pages 
ieee 
luckham luckham park paterson 
formalized computer programs 
comput 
syst 
sci 

verification modal properties boolean equation systems 
phd thesis fr informatik technische universitt september 

equivalence weak second order nonstandard time semantics various program verification systems 
proc 
st symp 
logic comput 
sci pages 
ieee 

measuring expressive power dynamic logics application model theory 
proc 
th int 
colloq 
automata lang 
prog volume lect 
notes comput 
sci pages 
springer verlag 

probabilistic propositional dynamic logic 
manuscript 
manna pnueli manna pnueli 
verification concurrent programs temporal proof principles 
kozen editor proc 
workshop logics programs volume lect 
notes comput 
sci pages 
springer verlag 
manna pnueli manna pnueli 
specification verification concurrent programs automata 
proc 
th symp 
principles programming languages pages 
acm january 
manna manna 
mathematical theory computation 
mcgraw hill 
mcculloch pitts mcculloch pitts 
logical calculus ideas nervous activity 
bull 
math 
biophysics 
mehlhorn mehlhorn 
graph algorithms np completeness volume ii data structures algorithms 
springer verlag 
meyer halpern meyer halpern 
axiomatic definitions programming languages theoretical assessment 
assoc 
comput 
mach 
meyer parikh meyer parikh 
definability dynamic logic 
comput 
syst 
sci 
meyer tiuryn meyer tiuryn 
note equivalences logics programs 
kozen editor proc 
workshop logics programs volume lect 
notes comput 
sci pages 
springer verlag 
meyer tiuryn meyer tiuryn 
equivalences logics programs 
journal computer systems science 
meyer meyer 
expressing program looping regular dynamic logic 
theor 
comput 
sci 
meyer meyer streett 
deducibility problem propositional dynamic logic 
editor proc 
workshop logic programs volume lect 
notes comput 
sci pages 
springer verlag 
miller miller 
riemann hypothesis tests primality 
comput 
syst 
sci 
dynamic logic 
formalized systems algorithmic logic 
bull 
acad 

sci 
ser 
sci 
math 

phys 

algorithmic logic nondeterministic programs 
fund 
informaticae iii 

pal propositional algorithmic logic 
editor proc 
workshop logic programs volume lect 
notes comput 
sci pages 
springer verlag 

pal propositional algorithmic logic 
fund 
informaticae iv 
morgan morgan mciver seidel 
probabilistic predicate transformers 
acm trans 
programming languages systems 
moschovakis moschovakis 
elementary induction structures 
northholland 
muller muller schupp 
weak alternating automata give simple explanation temporal dynamic logics decidable exponential time 
proc 
rd symp 
logic computer science pages 
ieee july 

free algebra variety generated representable dynamic algebras separable representable 
manuscript 

nonstandard dynamic logic 
kozen editor proc 
workshop logics programs volume lect 
notes comput 
sci pages 
springer verlag 
ng tarski ng tarski 
relation algebras transitive closure 
notices amer 
math 
soc 
ng ng 
relation algebras transitive closure 
phd thesis university california berkeley 
nishimura nishimura 
sequential method propositional dynamic logic 
acta informatica 
nishimura nishimura 
descriptively complete process logic 
acta informatica 

propositional calculus expressive propositional dynamic logic looping 
university warsaw 
parikh mahoney parikh mahoney 
theory probabilistic programs 
clarke kozen editors proc 
workshop logics programs volume lect 
notes comput 
sci pages 
springer verlag 
parikh parikh 
completeness propositional dynamic logic 
proc 
th symp 
math 

comput 
sci volume lect 
notes comput 
sci pages 
springerverlag 
parikh parikh 
decidability result second order process logic 
proc 
th symp 

comput 
sci pages 
ieee 
parikh parikh 
propositional dynamic logics programs survey 
editor proc 
workshop logics programs volume lect 
notes comput 
sci pages 
springer verlag 
parikh rohit parikh 
propositional game logic 
proc 
rd ieee symp 
foundations computer science 
park park 
finiteness 
theor 
comput 
sci 
paterson hewitt paterson hewitt 
comparative 
record project mac conf 
concurrent systems parallel computation pages 
acm 

complementation buchi automata 
theor 
comput 
sci 
peleg peleg 
communication concurrent dynamic logic 
comput 
sys 
sci 
peleg peleg 
concurrent dynamic logic 
assoc 
comput 
mach 
peleg peleg 
concurrent program schemes logics 
theor 
comput 
sci 
peng iyer peng iyer 
new type pushdown tree automata infinite trees 
int 

comput 
sci 
peterson peterson 
power tests propositional dynamic logic 
technical report comput 
sci 
dept univ rochester 
david harel dexter kozen jerzy tiuryn pnueli pnueli 
temporal logic programs 
proc 
th symp 

comput 
sci pages 
ieee 
pratt pratt 
semantical considerations floyd hoare logic 
proc 
th symp 

comput 
sci pages 
ieee 
pratt pratt 
practical decision method propositional dynamic logic 
proc 
th symp 
theory comput pages 
acm 
pratt pratt 
dynamic algebras examples constructions applications 
technical report tm mit lcs july 
pratt pratt 
models program logics 
proc 
th symp 

comput 
sci pages 
ieee 
pratt pratt 
process logic 
proc 
th symp 

prog 
lang pages 
acm 
pratt pratt 
dynamic algebras nature induction 
proc 
th symp 
theory comput pages 
acm 
pratt pratt 
near optimal method reasoning actions 
comput 
syst 
sci 
pratt pratt 
decidable calculus preliminary report 
proc 
nd symp 

comput 
sci pages 
ieee 
pratt pratt 
graphs understand pdl 
kozen editor proc 
workshop logics programs volume lect 
notes comput 
sci pages 
springer verlag 
pratt vaughan pratt 
dynamic algebras behaved fragment relation algebras 
editor proc 
conf 
algebra computer science volume lecture notes computer science pages ames iowa june 
springer verlag 
pratt vaughan pratt 
action logic pure induction 
van eijck editor proc 
logics ai european workshop jelia volume lecture notes computer science pages new york september 
springer verlag 
rabin scott rabin scott 
finite automata decision problems 
ibm res 
develop 
rabin rabin 
probabilistic algorithms testing primality 
number theory 
ramshaw ramshaw 
formalizing analysis algorithms 
phd thesis stanford univ 
sikorski sikorski 
mathematics metamathematics 
polish scientific publishers 

defining relations algebra regular events 

mat 

russian 
reif reif 
logics probabilistic programming 
proc 
th symp 
theory comput pages 
acm 
rogers rogers 
theory recursive functions effective computability 
mcgraw hill 
safra safra 
complexity automata 
proc 
th symp 
foundations comput 
sci pages 
ieee october 
jacques 
kleene theorem revisited formal path kleene chomsky 
editors trends techniques problems theoretical computer science volume lecture notes computer science pages new york 
springer verlag 
salomaa salomaa 
complete axiom systems algebra regular events 
assoc 
comput 
mach january 

formalized algorithmic languages 
bull 
acad 

sci 
ser 
sci 
math 

phys 

algorithmic logic tool investigations programs 
hintikka editors logic foundations mathematics computability theory pages 
reidel 
sazonov sazonov 
polynomial computability finite domains 
und 
scott de bakker scott de bakker 
theory programs 
ibm vienna 
dynamic logic segala lynch segala lynch 
probabilistic simulations probabilistic processes 
proc 
concur volume lecture notes comput 
sci pages 
springer verlag 
segerberg segerberg 
completeness theorem modal logic programs preliminary report 

amer 
math 
soc 
shoenfield shoenfield 
mathematical logic 
addison wesley 

ein problem der logik 
journal symbolic logic 
sistla clarke sistla clarke 
complexity propositional linear temporal logics 
proc 
th symp 
theory comput pages 
acm 
sistla sistla vardi wolper 
complementation problem buchi automata application temporal logic 
theor 
comput 
sci 
smolka smolka 
incremental model checking modal calculus 
dill editor proc 
conf 
computer aided verification volume lect 
notes comput 
sci pages 
springer june 
steffen bernhard steffen tiziana margaria andreas volker braun rita manfred 
constraint oriented service environment 
margaria steffen editors proc 
second int 
workshop tools algorithms construction analysis systems tacas volume lect 
notes comput 
sci pages 
springer march 
stirling walker stirling walker 
local model checking modal calculus 
proc 
int 
joint conf 
theory practice software develop 
tapsoft volume lect 
notes comput 
sci pages 
springer march 
stirling colin stirling 
modal temporal logics 
abramsky gabbay maibaum editors handbook logic computer science pages 
clarendon press 
stockmeyer meyer stockmeyer meyer 
word problems requiring exponential time 
proc 
th symp 
theory computing pages new york 
acm 
stolboushkin stolboushkin 
deterministic dynamic logic strictly weaker dynamic logic 
infor 
control 
stolboushkin stolboushkin 
regular dynamic logic interpretable deterministic context free dynamic logic 
information computation 
stolboushkin stolboushkin 
complexity bounds dynamic logic 
proc 
th symp 
logic comput 
sci pages 
ieee june 
streett emerson robert streett allan emerson 
propositional calculus elementary 
proc 
th int 
colloq 
automata languages programming pages 
springer 
lect 
notes comput 
sci 

streett streett 
propositional dynamic logic looping converse 
proc 
th symp 
theory comput pages 
acm 
streett streett 
propositional dynamic logic looping converse elementarily decidable 
infor 
control 
streett streett 
fixpoints program looping reductions propositional calculus propositional dynamic logics looping 
parikh editor proc 
workshop logics programs volume lect 
notes comput 
sci pages 
springer verlag 
streett robert streett 
fixpoints program looping reductions propositional calculus propositional dynamic logics looping 
parikh editor proc 
workshop logics programs pages 
springer 
lect 
notes comput 
sci 

tarjan robert tarjan 
unified approach path problems 
assoc 
comput 
mach pages 
thiele thiele 
untersuchungen sprachen 
theorie der deutscher verlag der wissenschaften 
berlin 
thomas thomas 
languages automata logic 
technical report universitat kiel may 
tiuryn urzyczyn tiuryn urzyczyn 
relationships logics programs complexity theory 
proc 
th symp 

comput 
sci pages 
ieee 
david harel dexter kozen jerzy tiuryn tiuryn urzyczyn tiuryn urzyczyn 
remarks comparing expressive power logics programs 
editors proc 
math 

comput 
sci volume lect 
notes comput 
sci pages 
springer verlag 
tiuryn urzyczyn tiuryn urzyczyn 
relationships logics programs complexity theory 
theor 
comput 
sci 
tiuryn tiuryn 
survey logic effective definitions 
editor proc 
workshop logics programs volume lect 
notes comput 
sci pages 
springer verlag 
tiuryn tiuryn 
unbounded program memory adds expressive power order programming logics 
proc 
nd symp 

comput 
sci pages 
ieee 
tiuryn tiuryn 
unbounded program memory adds expressive power order programming logics 
infor 
control 
tiuryn tiuryn 
higher order arrays stacks programming application complexity theory logics programs 
editors proc 
math 

comput 
sci volume lect 
notes comput 
sci pages 
springer verlag 
tiuryn tiuryn 
simplified proof ddl dl 
information computation 

dynamic algebras kripke structures 
proc 
th symp 
math 

comput 
sci pages 
turing turing 
computable numbers application entscheidungsproblem 
proc 
london math 
soc 
erratum ibid pp 

urzyczyn urzyczyn 
necessary sufficient condition order herbrand interpretation expressive relative recursive programs 
information control 
urzyczyn urzyczyn 
expressed 
journal computer system sciences 
urzyczyn urzyczyn 
deterministic context free dynamic logic expressive deterministic dynamic logic regular programs 
fundamenta informaticae 
urzyczyn urzyczyn 
logics programs boolean memory 
fundamenta informaticae xi 

decision complexity variants propositional dynamic logic 
proc 
th symp 
math 

comput 
sci volume lect 
notes comput 
sci pages 
springer verlag 
van emde boas van emde boas 
connection modal logic algorithmic logics 
symp 
math 

comp 
sci pages 
vardi stockmeyer vardi stockmeyer 
improved upper lower bounds modal logics programs preliminary report 
proc 
th symp 
theory comput pages 
acm may 
vardi wolper vardi wolper 
automata theoretic approach automatic program verification 
proc 
st symp 
logic computer science pages 
ieee june 
vardi wolper vardi wolper 
automata theoretic techniques modal logics programs 
comput 
syst 
sci 
vardi vardi 
automatic verification probabilistic concurrent finite state programs 
proc 
th symp 

comput 
sci pages 
ieee october 
vardi vardi 
taming converse reasoning way computations 
parikh editor proc 
workshop logics programs volume lect 
notes comput 
sci pages 
springer verlag 
vardi vardi 
verification concurrent programs automata theoretic framework 
proc 
nd symp 
logic comput 
sci pages 
ieee june 
vardi vardi 
linear vs branching time complexity theoretic perspective 
proc 
th symp 
logic comput 
sci pages 
ieee 
vardi vardi 
reasoning past way automata 
proc 
th int 
colloq 
automata lang 
prog volume lect 
notes comput 
sci pages 
springerverlag july 
walukiewicz igor walukiewicz 
completeness result propositional calculus 
proc 
th ieee symp 
logic comput 
sci june 
walukiewicz igor walukiewicz 
completeness kozen axiomatisation propositional calculus 
proc 
th symp 
logic comput 
sci pages 
ieee june 
dynamic logic walukiewicz igor walukiewicz 
completeness kozen axiomatisation propositional calculus 
infor 
comput february march 
wand wand 
new incompleteness result hoare system 
assoc 
comput 
mach 
wolper wolper 
temporal logic expressive 
proc 
nd symp 
foundations computer science pages 
ieee 
wolper wolper 
temporal logic expressive 
infor 
control 
