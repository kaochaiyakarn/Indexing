locating features source code thomas eisenbarth rainer koschke daniel simon understanding implementation certain feature system requires identify computational units system contribute feature 
cases mapping features source code poorly documented 
semi automatic technique reconstructs mapping features triggered user exhibit observable behavior 
mapping general injective computational unit may contribute features 
technique allows distinguish general speci computational units respect set features 
set features identi es jointly distinctly required computational units 
technique combines dynamic static analyses rapidly focus system parts relate speci set features 
dynamic information gathered set scenarios invoking features 
assuming correspondence features scenarios earlier handle scenarios invoke features 
furthermore show method allows incremental exploration features preserving mental map analyst gained analysis 
keywords program comprehension formal concept analysis feature location program analysis software architecture recovery certain feature implemented major problem program understanding 
real understanding starts locate implementation feature code 
systems appear large number modules containing hundreds lines code 
general obvious parts source code implement feature 
typically existing documentation outdated exists system original architects longer available view outdated due changes 
maintenance introduces incoherent changes cause system structure degrade 
understanding system turn harder time change 
option trying escape vicious circle completely reverse engineer system order exhaustively identify components assign features components 
integrated published automatic techniques component retrieval incremental semiautomatic process results selected automatic techniques validated user 
exhaustive methods cost ective 
fortunately knowledge components implementing speci set features suces cases 
consequently eisenbarth koschke simon institute computer science university stuttgart stuttgart germany 
mail simon informatik uni stuttgart de 
feature oriented search focusing components interest needed 
article describes process supporting techniques identify parts source code implement speci set related features 
process automated large extent 
combines static dynamic analyses uses concept analysis mathematical technique investigate binary relations derive correspondences features computational units 
concept analysis additionally yields computational units jointly distinctly required set features 
advantage starting features domain knowledge user perspective may exploited especially useful external change requests error reports expressed terminology program problem domain 
remainder article organized follows 
sect 
ii gives overview technique introduces basic concepts 
sect 
iii introduces concept analysis 
sect 
iv describes process locating analyzing features detail 
sect 
report case studies conducted validate approach 
related research area summarized sect 
vi 
ii 
overview goal technique identify computational units speci cally implement feature set jointly distinctly required computational units set features 
technique combines static dynamic analyses 
section gives overview technique describes relationships features scenarios computational units summarized fig 
explains kind dynamic information input technique 
section introduces simple example description method sections 
example inspired previous case study analyzed drawing tool xfig 
computational unit computational unit executable part system 
examples computational units instructions accesses global variables basic blocks routines classes compilation units components modules subsystems 
exact speci cation computational unit generic parameter method 
feature 
feature realized functional requirement system term feature intentionally de ned weakly exact meaning depends speci context 
generally term feature subsumes non functional requirements 
context functional features relevant consider feature ob computational unit routine module basic block feature scenario implemented invokes fig 

conceptual model uml notation 
behavior system triggered user 
example 
ctitious drawing tool fig resembles xfig allows user draw move color di erent objects rectangles circles ellipses forth 
viewpoint analyst interested implementation circle operations fig ability draw move color circle relevant features 
computational unit excluding dead code contributes purpose system corresponds feature basic feature ability system start terminate 
features may interest analyst task hand 
assume subset features relevant 
consequently computational units required features interest 
feature unit map result technique describes computational units implement set relevant features 
scenario 
features descriptions system expected behavior 
user wants invoke feature system needs provide system adequate input trigger feature 
instance draw circle user fig needs press certain button control panel selecting circle drawing operation position cursor drawing area specifying center circle specify diameter moving mouse eventually press left mouse button circle 
sequences user inputs trigger actions system observable result called scenarios 
technique requires set scenarios invoke features analyst interested 
scenario invokes feature result observed user system described scenario scenario may invoke multiple features features may invoked multiple scenarios 
instance scenario moving circle requires draw circle rst scenario invokes feature circle drawing 
may di erent scenarios invoking set features 
scenario represents alternative way invoking features 
instance fig allows user push button keyboard shortcut circle drawing operation 
set scenarios representing options choices feature resembles case 
scenarios technique gather computational units relevant features dynamic analysis similarly wilde technique 
system described scenario execution trace lists sequence performed calls scenario 
technique aims identifying computational units order computational units execution need execution pro le 
execution pro le program run set computational units called run information order execution 
execution pro le gather fact computational unit executed 
ignore duration computational unit execution computation time hardly gives hints feature speci computational units 
speci computational units identi ed technique techniques static dynamic slicing obtain order execution required 
techniques applied goal oriented focusing feature speci computational units yielded technique 
feature unit map 
technique derives feature unit map concept analysis mathematically sound technique 
application concept analysis concept analysis simply stated mutually intersects execution pro les scenarios resulting intersections obtain speci computational units feature jointly distinctly required computational units set features 
example 
fig allows draw circle diameter radius 
analyst interested di erences circle operations di erences circle operations moving coloring set scenarios listed fig 

lists computational units executed scenarios fig 

intersecting execution pro les shows speci feature draw circle radius move move circle color color circle 
scenario name actions performed draw circle diameter draw circle diameter draw circle radius draw circle radius move circle draw circle diameter move color circle draw circle diameter color fig 

example scenarios fig 
simply identifying computational units scenario executed computational units draw circle diameter draw draw circle radius draw move circle draw move color circle draw color fig 

execution pro les fig 

speci cally required feature concept analysis additionally allows derive detailed relationships features computational units 
relationships identify computational units jointly required subset features classify computational units low level high level respect set features 
example 
intersecting execution pro les fig 
additionally shows computational units jointly required draw circle diameter move circle draw draw required scenarios 
information gained concept analysis guide subsequent static analysis static dependency graph order narrow computational units form self contained understandable computational units 
computational units basic computational units building blocks computational units containing application speci logic sorted 
additional static analyses strongly connected component identi cation dominance analysis program slicing support search units interest 
large complex systems approach applied incrementally described 
applicability retrieval feature unit map dynamic information computational units executed scenario collected 
scenario describes invoke feature 
section describes assumptions features scenarios computational units 
features technique primarily suited functional features may mapped computational units 
particular non functional features robustness reliability maintainability easily map computational units 
technique suited features invoked outside internal implementation features garbage collector may necessarily deterministically easily triggered outside 
scenarios scenarios designed selected existing test cases invoke known set relevant features assume analyst knows advance features invoked scenario 
suitable scenarios essential technique domain expert needed set scenarios 
cases domain expert reuse existing test cases scenarios locate features 
purpose test cases reveal errors test cases tend complex cover features 
contrarily scenarios feature location technique simpler invoke fewer features di erentiate computational units clearly 
order explore variations feature domain expert provides scenarios triggering feature variation di erent set input 
obtain ective ecient coverage builds equivalence classes relevant input data 
identifying equivalence classes may require knowledge internal details system 
computational units exact notion computational unit generic parameter technique depends task system hand 
principle limit granularity computational units basic blocks routines classes modules subsystems 
subsystems computational units suitable obtain overview large systems 
considering routines methods subprograms computational units gives overview global declaration level classes modules lie subsystem global declaration level 
basic blocks computational units adequate smaller systems parts system detail needed due information overload analyst 
practical reasons decided routines computational unit choice routine function procedure subprogram method programming language 
case studies routines appropriate 
static dynamic dependencies results concept analysis dynamic information guide analyst static analysis inspection static dependency graph 
dynamic information guide de nite answer dynamic information depends suitable input data test environment scenarios executed 
static dependency graph extracted procedural functional object oriented programming languages 
execution pro les recorded languages technique applicable languages 
precision static extraction uences ease analyst inspection static dependencies static analysis inherently dicult object oriented languages functional languages higher order functions procedural languages 
static analyses need conservative assumptions presence pointers dynamic binding weaken precision dependency graph 
fortunately research pointer analysis considerable progress 
large body pointer analysis procedural languages object oriented languages resolves general pointers function pointers dynamic binding :10.1.1.25.1069:10.1.1.25.6013:10.1.1.43.4867:10.1.1.22.4648:10.1.1.109.6502
techniques vary precision costs 
interestingly milanova empirical data indicating expensive theoretically precise techniques resolve function pointers reach precision expensive theoretically precise techniques due common way function pointers opposed pointers stack heap objects 
iii 
formal concept analysis section presents necessary background information formal concept analysis 
readers familiar concept analysis skip section 
formal concept analysis mathematical technique analyzing binary relations 
mathematical foundation concept analysis laid birkho 
detailed information formal concept analysis refer mathematical foundation explored 
concept analysis deals relation set objects set attributes tuple called formal context 
set objects set common attributes de ned fa og analogously set common objects set attributes de ned fo ag formal context represented relation table columns hold objects rows hold attributes 
object attribute relation cell column row marked 
example binary relation arbitrary objects attributes shown fig 

formal context fo fa fa fo tuple called concept objects share attributes concept called extent denoted extent called intent denoted intent 
informally speaking concept corresponds maximal rectangle lled table cells modulo row column permutations 
fig 
concepts relation fig 
listed 
set concepts formal context forms partial order superconcept subconcept ordering dually note imply de nition 
called subconcept called superconcept instance fig 
set concepts formal context partial order form complete lattice called concept lattice mum concepts lattice computed intersecting extents follows mum describes set common attributes sets objects 
similarly supremum determined intersecting intents supremum yields set common objects share attributes intersection sets attributes 
concept lattice formal context fig 
depicted directed acyclic graph nodes represent concepts edges denote superconcept subconcept relation shown fig 

general concept called top element denoted 
special concept called bottom element denoted 
concept lattice visualized readable equivalent way marking graph node attribute represented concept general concept intent 
analogously node marked object represents special concept extent 
unique element concept lattice marked intent unique element marked object extent call graph representing concept lattice marking strategy sparse representation lattice 
equivalent sparse representation lattice fig 
shown fig 

content node representation derived follows objects objects attributes attributes instance node fig 
marked concept fo fa 
practical reasons useful apply 
example large number attributes just small number objects eliminate redundant appearance attributes keep full list objects concepts 
iv 
analysis process process locate features depicted fig 
idef notation 
consists major activities formal context 
fo fa fo fa fo fa fo fa fo fa fo fa fo fa 
fa concepts formal context 
fig 

example relation objects attributes 
corresponding concepts derived formal context listed right 
fo fa fo fa fo fa fo fa fo fa fa fo fa fo fa full concept lattice 
fo fa fa fa fo fa fa fo fa fa sparse representation 
fig 

concept lattices example context fig 

code source dynamic analysis scenario creation unit map relevant initially concept lattice interpretation concept lattice static dependency analysis filter granularity need additional scenarios incremental analysis validated statically unit map scenarios human involvement part idef notation static dependency dependency graph extraction analyst fig 

process feature location idef notation 

scenario creation features known initially discovered incremental analysis domain expert creates scenarios 

static dependency graph extraction static dependency graph system analysis extracted 

dynamic analysis system selected scenarios 

interpretation concept lattice data yielded dynamic analysis interpreted analyst 
relevant computational units identi ed 

static dependency analysis analyst searches system additional computational units relevant selected features 
di erent roles human resources activities human resources highlighted process diagrams uml actor icon analyst person interested features map source code 
interprets concept lattice performs static analysis 
domain expert designs scenarios lists invoked features scenario 
user person uses system selected scenarios 
activities static dependency graph extraction done bene knowledge gained previous iterations applied repeatedly sucient knowledge system gained 
order activities speci ed idef diagram fig 
activity may start input available 
activities explained sections 
static dependency graph extraction static dependency graph subsume types entities dependencies dynamic dependency graph unnecessary extract dynamic information subsequent static analysis 
static dependency graph may provide additional types entities dependencies ne grained information static extraction tool exceeds capabilities available dynamic extraction tool 
case static analysis leverage dynamic information conservative 
case studies instance extracted detailed static dependencies global declarations routines global variables user de ned types pro ler extract dynamic call relationship routines 
way analyze static variable accesses executed scenarios 
scenario creation domain expert needed creating scenarios 
available information system behavior documentation existing test cases domain models useful input 
existing test cases may useful necessarily directly applicable focus testing cover code completely combine features ways 
scenarios sense distinctive invoke relevant features features possible ease mappings scenarios features features computational units unavoidable invoke features interest task hand 
scenarios documented similarly test cases 
additionally documentation includes features invoked scenarios 
domain experts speci es expected result scenario scenario may simple test case 
dynamic analysis goal dynamic analysis nd computational units contribute set features 
feature invoked prepared scenarios 
process deals dynamic analysis shown detail fig 

inputs process source code set scenarios created process step fig 

proceed follows compile recording source code compiled pro ling options instrumented obtain execution pro le 
scenario execution system executed user scenarios execution pro les recorded 
suitable tool support available scenario execution may recorded wish exclude parts execution relevant start shutdown system 
certain debuggers instance allow start trace recording 
instrumenting source code relevant parts recorded generally option requires map partially known 
alternative solution specify special start scenario containing actions ltered 
instance order mask initialization nalization code domain expert may prepare start scenario system started immediately shut 
scenario precise description sequence user inputs trigger actions system execution scenario yields execution pro le system nondeterministic 
case nondeterminism unite pro les executions scenario di erentiate scenario execution 
useful identify di erences due nondeterminism 
interpretation concept lattice process step concept lattice relation table created process step built 
goals interpreting resulting concept lattices 
identi cation relationships scenarios computational units process steps 
identi cation relationships scenarios features features computational units process step sect 
iii main part object computational unit set objects set computational units objects computational units attribute scenario set attributes set scenarios attributes scenarios incidence relation invocation table fig 

translation identi ers sect 
iii identi ers instantiate formal concept analysis 
subsections describe achieve goals 
basic process lattice interpretation depicted fig 

scenario selection number execution pro les selected order set context 
execution pro les may recombined analyze various aspects system execution pro les scenarios reused 
example 
analyst fig may rst interested di erent ways draw circle 
select scenarios draw circle diameter radius 
understands di erences features investigate circle operations additionally select move circle 
concept analysis process embodies completely automated step creates concept lattice invocation table 
order derive feature unit map means concept analysis de ne formal context objects attributes relation interpret resulting concept lattice accordingly 
formal context applying concept analysis derive relationships scenarios computational units laid follows computational units considered objects 
scenarios considered attributes 
pair computational unit scenario relation executed performed 
shows map identi ers general description concept analysis sect 
iii identi ers speci instantiation concept analysis method 
system set scenarios time execution pro les recorded 
system run yields executed computational units single scenario column relation table lled system run 
applying scenarios selected process scenario selection provides relation table formal concept analysis 
example 
shows concept lattice invocation table fig 
scenarios selected 
basic interpretation concept analysis applied formal context described section yields lattice interesting relationships derived 
relationships fully automatically derived analyst 
analyst know interpret derived relationships need familiar theoretical background lattices 
base relationships derived sparse representation lattice note duality computational unit required scenarios lattice instance required draw circle diameter move circle fig 

scenario requires computational units lattice instance color circle requires color draw fig 

computational unit speci exactly scenario scenario paths top element instance color speci color circle fig 

scenarios computational units jointly contribute identi ed supremum 
lattice supremum closest common node top element starting nodes attached 
scenarios common node jointly implemented instance color jointly contribute color circle fig 

computational units jointly required scenarios described mum 
lattice mum closest common node bottom element starting nodes attached 
computational units common node jointly required instance draw jointly required move circle color circle fig 

computational units required scenarios bottom element instance draw required scenarios fig 

scenarios require computational units top element 
fig 
scenario 
relationships computational units scenarios useful aspects scenarios hand computational units hand may derived holds computational units computational unit speci respect scenarios computational unit contributes just features contributes features 
instance color speci color circle speci draw fig 

holds scenarios scenario scenario executed computational units extent need executed 
instance move circle color circle scenario execution compile recording profiles execution compiler code source executable scenarios fig 

process dynamic analysis fig 

scenario selection incremental table invocation concept analysis feature mapping map concept execution profiles basic interpretation lattice fig 

process interpretation concept lattice fig 

draw color move draw circle radius color circle draw circle diameter move circle fig 

sparse concept lattice fig 

draw circle diameter fig 

lattice re ects level application speci city computational units 
information described derived tool fed back analyst 
inspecting relationships derived concept lattice decision may analyze subset original features depth due additional dependencies concept analysis reveals 
computational units required features easily derived concept lattice form starting point static analyses validate identi ed computational units identify computational units possibly executed dynamic analysis limitations design scenarios 
scenario feature mapping interpretation concept lattice described gives insights relationship scenarios computational units analyst primarily interested relationship features computational units section describes identify relationship concept lattice correspondence scenarios features 
feature invoked scenarios scenario invoke features strict correspondence features scenarios 
instance discussed scenarios move circle color circle fig diameter fig 
order move color shape draw rst 
scenario moving coloring shape necessarily invoke feature draws shape 
fortunately invocation relation 
fu fs gg fu fs fu fs fu fs fu fu fs fu fs fu fs concept lattice context fig 
fu fs gg fu fs fu fs spec fu fs fu fs fu fs fu fs sparse concept lattice fig 
categorized respect feature exposed scenarios fig 

categorizing concept lattices 
simple way identify computational units relevant actual features concept lattice unambiguous identi cation may require additional discriminating scenarios 
basic idea isolate features concept lattice combinations overlapping scenarios 
scenario invokes features formally model scenario set features ff fm fn set relevant features 
modeling simplifying abstracts exact order frequency feature invocations scenario 
hand order frequency feature invocations count scenarios may considered complex features right 
scenarios yield di erent execution pro les appear di erent concepts lattice commonalities di erences revealed may analyzed 
domain expert additional knowledge features invoked scenario identify computational units relevant certain feature 
consider invocation relation fig 
better legibility scenarios listed rows computational units listed columns 
table contains called computational units scenario furthermore invoked features scenario ff ff ff corresponding concept lattice invocation relation fig 
shown fig 

feature part table ignored constructing lattice 
computational units speci feature intersection executed computational units scenarios invoked intersection computational units executed identi ed extent mum concepts associated fs fu 
share feature computational units particularly relevant notice scenarios consider speci computational unit computational unit contrast scenarios executing state hypothesis speci 
scenario containing computational unit computational unit speci note just hypothesis features involved truly speci explicitly listed scenarios 
explanation accident executed appears scenarios speci chances high speci executed jointly invoked suggests comes play interacts rate categorization needs validated analyst 
computational units related speci computational units executed scenarios invoking features 
example invoke computational units extents concepts contain fore potentially relevant example potentially relevant addition computational unit executed scenario contain altogether identify categories computational units regard feature see fig 
spec speci scenarios invoking scenarios 
relevant scenarios invoking general scenarios invoking 
executed scenarios invoking speci scenarios invoke computational units conditionally speci speci decidable concept lattice 
hand scenarios invoking scenarios executed scenarios require hand executed required executed scenarios require executed scenarios invoking executed scenarios invoking shared features 
computational units presumably relevant executed invoked relevant executed scenarios invoking irrelevant executed scenarios containing facts obvious sparse representation lattice 
representation feature identi es concept condition holds ffg concept called feature speci concept feature speci concept categorize computational units follows spec computational units holds 
computational units holds 
computational units holds 
computational units intent concept holds incomparable 
computational units categorized categories 
distance considered additional nuances categories possible 
distance measures size set features computational unit potentially relevant 
larger set speci computational unit example 
scenario move circle fig 
invokes features ability fig draw circle diameter ability move circle 
scenario color circle uses ability draw circle colors circle moving 
computational units responsible drawing circle attached concept fig 
represents intersection features invoked move circle color circle 
scenario draw circle diameter necessarily required identify computational units drawing circle diameter sparse lattice reveals computational units direct mum move circle color circle draw circle diameter considered 
draw circle diameter useful separate draw 
matter fact concepts condition holds di erent computational units executed feature depending scenario contexts feature embedded 
instance assume analyzing fig undo capabilities 
scenarios provided explore feature draw circle undo circle drawing circle undo preceding drawing operation overlapping scenarios circle may assume di erent computational units executed speci command draw circle quite additional computational units executed handle erroneous attempt call undo previous operation 
consequently lattice contain concept circle subconcept 
mum scenarios contain computational units undo operation executed normal exceptional execution concept representing contains computational units error handling 
case multiple concepts condition holds unite computational units spec respect concepts 
identi ed concepts subconcept relation superconcept represents strict extension behavior feature 
concepts incomparable concepts represent varying context dependent behavior feature 
concept condition holds needs additional scenarios factor feature instance order isolate feature scenario ff simply add new scenario ff computational units speci 
necessary consider possible feature combinations order isolate features lattice 
intersecting currently available scenarios exactly tells features isolated intersection done concept analysis applied formal context consisting scenarios features incidence relation describes feature invoked scenario 
slightly modi ed variants scenarios invoking feature added isolate feature speci cally 
addition new scenarios order discriminate features lattice lead incremental construction concept lattice described sect 
iv 
come describe static dependency analysis 
static dependency analysis concept lattice easily derive computational units executed set relevant features 
gives set computational units clear computational units truly feature speci generalpurpose computational units building blocks computational units 
feature interest question answered follows rst approximation computational units extents feature speci concepts jointly contribute analyst re nes approximation adding removing computational units inspecting static dependency graph source code computational units sorts irrelevant computational units may add feature relevant computational units executed due incomplete input coverage scenarios 
concept lattice important guidance analyst inspection dependency graph 
example 
fig ability color circle analyst need validate set computational units concept lattice fig 

lattice shows analyst start inspecting color appears speci computational unit coloring circle 
building starting set computational units extent concept jointly contribute features intent concept immediately follows de nition concept 
may computational units extent contribute features speci feature 
may computational units extent contain code 
computational units extent concept need inspected manually 
reliable criteria known automatically distinguish feature speci code general purpose code analysis automated human expertise necessary 
concept lattice may narrow candidates manual inspection 
concept lattice dependency graph help decide order computational units inspected ort manual inspection reduced minimum 
interested computational units speci feature start computational units attached concept holds feature speci concept computational units collect computational units feature speci concepts minimal distance sparse representation 
concept unite computational units attached concepts 
subset computational units identi ed step accepted manual inspection called starting set start 
example 
starting set fig ability color circle start color circle 
inspection static dependency graph inspect executable static dependency graph speci subset static dependency graph contains transitive control ow successors predecessors computational units start 
concentrate computational units active constituents subject dynamic analysis 
executable static dependency graph annotated features scenarios computational units executed 
computational unit annotated scenario computational unit executed 
non executable parts system declarative parts may added relevant computational units identi ed 
static pointsto analysis needed resolve dynamic binding calls routine pointers 
static points analysis may take advantage knowledge executed computational units yielded dynamic analysis 
primarily consider computational units extent holds computational units executed invoked dynamic analysis 
combine static dynamic information eliminate conditional static computational units executions order reduce search space 
check reasons certain computational units executed 
kind traversal executable static dependency graph possible depth rst search control ow suited computational unit understood executed computational units understood 
breadth rst search human cope continuous context switches 
goal inspection sort computational units belong feature narrow sense contain feature speci code 
executable static dependency graph concept lattice traversed inspection lattice really re ect control ow dependencies imply control ow predecessor concept lattice may provide useful information inspection 
section iv observation lower concept lattice general computational unit serves features vice versa 
concept lattice gives insight level abstraction computational unit contributes degree con dence speci computational unit contains feature speci code 
example 
analyst rst validate starting set fig ability color circle start color circle 
inspect control ow predecessors successors color 
executed brief check necessary sure irrelevant 
continue eventually inspect draw 
additional analyses gather information useful navigating dependency graph strongly connected component analysis identify cycles dependency graph computational unit cycle contains feature speci code computational units cycle related feature cyclic dependency 
dominance analysis identify computational units local computational units 
computational unit dominates computational unit path dependency graph root contains words reached way computational unit feature speci dominators relevant feature need executed order executed 
dominator contains feature speci code dominator feature speci dominator clear cutting point local 
consequently dominator omitted understanding system 
feature relevant simply unites starting sets feature follows approach 
feature concept lattice identi es computational units jointly distinctly features 
relevant computational units identi ed static program slicing dynamic analyses trace recording obtain order execution applied obtain information 
analyses performed goal oriented leveraging retrieved feature unit map 
incremental analysis reasons incremental consideration scenarios desirable 
get suite scenarios suciently discriminating rst time 
new scenarios necessary di erentiate scenarios features 
second new scenarios useful trying understand unfamiliar system incrementally 
starts small set relevant scenarios locate understand fundamental set features providing small manageable overview lattice 
successively increments set considered scenarios widen understanding 
adding scenarios means adding attributes formal context situations objects added incrementally cases computational units need re ned 
instance computational units low cohesion computational units multiple di erent functions sink concept lattice contribute features 
routine containing large switch statement branch executed feature typical example 
analyst encounters routine static analysis lower level granularity computational units speci cally routine basic blocks 
basic blocks computational units disentangle interleaved code example routine large switch statement individual switch branches clearly assigned respective feature concept lattice 
section describe incremental consideration attributes scenarios 
incremental consideration objects re nement computational units analogous 
soon understands basics system adds new scenarios detailed investigation exploration unknown portions system 
tries capture features software resulting lattice may large detailed unmanageable 
starts smaller set scenarios increases set accumulated knowledge analyst gained working smaller lattice preserved 
lattice mental map analyst understanding changes new scenarios added 
fortunately smaller lattice mapped larger smaller lattice result called subcontext 
definition 
context called subcontext called application concept analysis add new rows new scenario assuming scenarios occur rows relation table new columns relation table statically know computational units advance 
adding new rows leads new formal context relation extends relation proposition 

extent extent proof 
see 
proposition extent subcontext show 
plausible relation table added rows change existing rows maximal rectangles forming concepts extend vertical direction scenarios listed rows 
proposition extents subcontexts di er set objects results simple mapping concepts subcontext formal proof see 
mapping preserving embedding meaning partial order relationship completely preserved 
consequently basically re nement subcontext 
mapping concepts subcontext 
may include new concepts subcontext 
consequence visualization newly introduced concepts highlighted easily visualized lattice concepts subcontext mapped concepts superconcept possible user annotations 
additionally incremental automatic graph layout chosen additional nodes edges may introduced nodes edges subcontext kept 
position concepts relatively preserved 
example 
assume analyst fig interested invoking feature circle drawing twice di erence di erences drawing circle drawing dot draw dot hand moving circle undoing circle move operation move circle undo hand 
domain expert design appropriate scenarios 
resulting invocation table previous scenarios may fig 

lattice new shown fig 

new scenario draw circle diameter twice subsumed existing scenario draw circle diameter showing feature twice lead additional relevant computational units 
new scenario draw dot subsumed bottom concept draw dot shares computational unit draw feature circle drawing 
scenarios draw circle diameter twice draw dot change general structure lattice 
concept highlighted fig 
new 
concept shows di erence move circle move circle undo additionally executed computational unit undo 
case studies section describes case studies evaluating method 
rst case study web browsers shows bene combining static dynamic information 
second case study focuses dynamic information exempli es incremental analysis large commercial system 
case studies computational units choice routines 
bauhaus tools extract static dependency graph 
extracted static dependency graph contains global declarations routines global variables user de ned types dependencies calls routines global variables routines type information variables dependencies user de ned types occurrences types routine signatures 
dynamic analysis standard pro ler gather execution pro les 
pro ler limitation record accesses variables 
analyzed variable accesses statically 
system version kloc wc subprograms mosaic chimera fig 

analyzed web browsers 
web browsers section discuss usefulness static dynamic informations introduced sect 
iv 
analyzed web browsers written see fig 
set relevant related features 
concept lattice systems derived described sect 
iv 
required routines identi ed dynamic analysis relationships derived concept analysis formed starting point static dependency analysis 
case study setup experiments tried understand speci sets related features implemented browsers process described 
goal analysis recover feature speci computational units way interact reverse engineer partial description software architecture 
partial software architecture instance allows decide feature speci computational units extracted system integrated system minor changes 
chimera implement features mosaic provides wanted nd respective feature speci computational units mosaic reused chimera 
experiment history chimera allows going back history visited urls chimera forward button allows user move forward history back button 
mosaic back forward button 
experiment going back going forward considered related features 
experiment bookmark mosaic chimera er bookmarks visited urls 
urls may bookmarked bookmarked urls may loaded removed 
considered related features addition new bookmark currently viewed url removal bookmark navigation bookmarked url 
objectives questions wanted answer case study follows identi cation extraction history bookmark features implemented mosaic chimera 
interfaces speci computational units implement features rest mosaic chimera 
cases partial description software architecture recovered 
integration identi ed portion code browser integrated browser 
draw move color undo draw circle diameter draw circle radius move circle color circle draw circle diameter twice move circle undo draw dot fig 
draw color move undo move circle undo draw circle diameter draw circle radius color circle move circle draw circle diameter twice draw dot lattice super context fig 
fig 

lattice fig 

experiment initial setup scenarios compiling pro ler options architectural sketches took people half day altogether mosaic chimera 
scenarios dynamic analysis experiment browser ran browser start scenario browser started immediately quit order separate startup shutdown code 
additional scenarios de ned speci cally experiments 
experiment history covered scenarios basic scenario doing browsing scenario back button scenario back forward buttons chimera scenario performed chimera possesses forward button 
experiment bookmark covered scenarios basic scenario simply opening closing bookmark window scenario adding new bookmark currently displayed url scenario removing bookmark scenario selecting bookmark visiting associated url scenario immediately ended quitting respective system 
provided scenarios invoke feature scenario forward button back button 
conse relevant mosaic mosaic chimera chimera fig 

subprogram counts mosaic chimera 
quently concept containing routines executed scenario subconcept concept related 
likewise bookmark deleted url added 
circumvent problem started browser non empty bookmark le scenarios 
consider case insertion empty bookmark list 
static dependency analysis dependency graph browsers visualized bauhaus extension rigi derived statically transitively called routines rigi basic selection facilities intersected static information executed routines manually 
additionally ltered routines speci html window graphical user interface guided browser proper naming conventions 
routines bottom element concept lattice 
results provides summary numbers routines needed considered step shows search space reduced step 
browser gui history mosaic history 
inner state location history dispatch browser gui chimera history 
component data storage routine call fig 

mosaic chimera history architecture 
routine calls routine specific routines general purpose functions specific routines cutting level lower region upper region fig 

relevant parts chimera history 
history experiment denoted bookmark experiment denoted 
total number routines kernels including libraries html jpeg zlib column number executed routines scenarios shown column 
routines statically called routines selected set dynamically executed routines upper concepts lattice called routines starting set column 
intersection column contains routines dynamically called routines selected set dynamically executed routines upper concepts lattice number reported column 
column relevant reports routines column speci selected features manual inspection 
routines purposes bookmarks histories 
eventually small number routines needed inspected thoroughly due top inspection process 
example fig 
shows remaining routines chimera omitting names relevant history experiment 
picture clearly shows possible cutting points dependency graph consisting routines global variables user de ned types dependencies routines speci history features upper region non speci routines lower region entities need removed isolate feature speci non speci entities 
recovered parts architecture mosaic chimera relevant experiments 
results history interface mosaic browser kernel history component see fig 
formed routines get current url set current url communicate action event changed url 
history component easily extracted mosaic source code separate component history integral part chimera kernel cf 
fig 

set routines chimera reasonably addressed history manager component mosaic 
chimera uses layer wrappers calling dispatching routine list actions displayed urls part list 
recovered partial architecture shows chimera browser kernel built list visited urls mosaic browser kernel know history visited urls 
analysis partial architectural architectures reveals re mosaic history components chimera dicult due architectural mismatch 
browser gui bookmarks mosaic bookmarks 
inner state dispatch gui browser bookmarks chimera bookmarks 
fig 

mosaic chimera bookmark architecture 
results bookmarks partial architectures systems similar respect bookmarks 
architectures include encapsulated bookmark component communicates narrow interface basic browser kernel see fig 

basic actions performed get currently shown url set currently shown url display bookmarks communicate bookmark selection back 
exchanging implementations mosaic chimera reasonably easy 
case study agilent section reports case study conducted investigate usefulness approach realistic full scale industrial setting 
case study stresses importance incremental understanding large concept lattices described section iv modeling scenarios set features explained section iv 
system analyzed part software agilent soc series semi conductor test equipment produced agilent technologies 
agilent soc series agilent soc series single scalable tester platform manufacturing process integrated circuits 
provides test capabilities digital analog radio frequency circuits embedded memories 
software controls complex tester hardware 
interactive environment developing running test programs 
consists numerous tools supporting test engineering tasks 
center software lies rmware interpreter ieee commands 
rmware responsible programming hardware 
input rmware test cases sequences rmware commands 
rmware parses interprets command drives agilent device returns result 
rmware analyzed case study 
software agilent soc series maintained geographically distributed groups 
situated usa japan germany 
group case study conducted soc test platform division germany 
rmware agilent evolved years 
today consists commented lines code counted unix program wc non empty lines declarative executable code respectively 
static call graph part rmware analyzed case study routines call edges excluding standard routines operating system routines 
depicts software architecture rmware described software architects agilent 
rmware simultaneously di erent tools running separate processes 
interaction tools rmware shared memory message queues part rmware 
semaphore synchronize interaction rmware tools 
rmware basically interpreter test programs 
test program led shared memory rmware parses runs command 
order run command rmware dispatches corresponding routine acts entry point implementation command 
routine referred executor command 
executor nished result written back shared memory waiting process informed message queue 
fig 
suggests executors share set re usable utility routines routines ering general services 
utility routines shared executors shown architectural sketch 
matter fact software architect currently exactly know precise relation executors utility routines due size system lack documentation 
commands interpreted rmware come pairs actual command additional command fetch result execution 
called query command 
commands named letter acronyms 
query commands additionally annotated question mark 
instance cntr 
query command cntr 
rmware understands di erent actual commands corresponding query command 
altogether di erent commands 
case study focused digital part rmware con guration setup relay control level setup timing setup vector setup commands classes commands analog setup ac test function dc measurement test result utility line calibration attributes commands con guration setup commands con guring pins rst step take preparing test 
commands class allow assigning pin names test power supply channel con guring pin type operation modes specifying series resistor things 
routing setup commands routing setup commands specify signal mode connection pin order connections 
level setup commands level setup commands specify required driver ampli er receiver comparator voltage levels set termination active load set clamp voltage 
timing setup commands timing setup commands de ne length device cycle shape waveforms making device cycle position timing edges tester cycle con gured pins 
vector setup commands vector setup commands required set sequence test vectors 
relays control commands relay control commands set relay positions tester state 
objectives case study goals 
architectural sketch fig 
mapped source code parts system contribute blocks executors utility functions identi ed 
clari ed routines executors 

utility routines assigned executors support 
mapping clari es ne structure utility functions block fig 


commands agilent rmware investigated assigned classes con guration setup relay control level setup timing setup vector setup commands architect user manual 
classi ed resulting concept lattice see lattice provides useful information classify features 
goal case study map architecture sketch fig 
source show utility routines really shared 
mentioned classes commands hypothesis executors commands class share utility routines 
hand commands di erent classes expected commonalities words expect general utility routines shared 
scenarios rmware agilent software architect agilent selected commands digital tests investigated 
students university stuttgart created test cases advised expert 
relevant rmware command test case provided executes command 
execution commands bound certain preconditions need ful lled calling commands rst requires add commands test cases 
test case generally single command sequence rmware commands relevant command required preparing steps 
order preparing commands test cases commands preconditions test cases executing set routines 
described section iv model test case scenario set commands features command order identify routines speci relevant command factor preparing steps additional test cases execute preparing commands relevant command 
instance order call command needs execute rst 
test case relevant 
order identify routines speci cally simply add test case executing 
routines speci identi ed concept lattice described section iv 
command query command test cases created actual command query command 
contains actual command query command query command actual command cases query command called calling actual command 
command di erent options test case executes command di erent combinations options 
combination aimed covering equivalence classes option settings 
pair actual query command command sdsc scenarios created actual query command 
di erence scenarios actual query command setting speci cation parameter relates timing level setup 
distinction see command requires routines di erent parts system timing setup level setup parts 
utility functions constructor command yacc parser response queue message shared memory control flow data flow applications firmware firmware hardware fig 

software architecture agilent rmware real scenarios relevant commands scenario nop command additional additional parameter combinations factoring start scenarios preparing steps total scenarios fig 

test cases scenarios 
test case represents scenario 
total scenarios provided cf 
fig 

scenarios correspond relevant rmware command digital tests 
additional scenario contained just operation nop command ect tester 
additional scenarios added call command query command alternative parameter setting 
remaining scenarios refactor scenarios start scenario remove start shutdown code simply starting system executing reset command shutting system factoring scenarios provided factor preparing steps real scenarios 
agilent large test suite testing rmware needed scenarios explore preferably command feature respectively time 
agilent test cases combinations commands 
existing test driver test suite executes tests run result single pro le test cases individual pro le test case 
resulting concept lattice resulting concept lattice shown fig 

consists concepts non transitive subconcept relations :10.1.1.22.2891
statically declared routines executed considered scenarios start scenario remove routines pro les scenarios executed initialization reset shutdown system 
worst case execution time compute concept lattice exponential number objects attributes computation concept lattice rmware took minutes intel pentium iii mhz machine running linux 
developer agilent di erent software architect sketched rmware architecture asked validate resulting concept lattice 
clear distinction validating expert expert sketched rmware architecture called developer software architect 
developer familiar rmware involved preparation test cases 
explained test cases selected interpretation concept lattice described 
show architecture sketch software architect 
asked developer explain general structure system concept lattice surprises lattice 
developer immediately spotted direct subconcepts top element concepts rst row top element lattice individual executors commands including executor nop 
fig 

lattice commands 
boxes height corresponds number routines concepts 
top element contain scenario 
concepts contain single scenario contain scenarios 
ones scenarios di erent parameter settings sdsc command corresponding query command cf 
sect 

consequently implementation sdsc command executes routines independently parameter refers timing level setup respectively 
executors immediately detected lattice 
observations easily map concept lattice fig 
architecture sketch fig 

real scenarios subconcepts mentioned concepts 
reason scenarios directly top element represent commands needed preparing steps commands 
instance commands called call 
scenarios consequently respectively 
scenario contains part concept common mum scenarios 
representing test cases scenarios sets commands features isolating commands intersecting test cases described section iv easily identify executors remaining commands test case directly located top element 
described rmware commands categorized di erent classes con guration setup relay control level setup timing setup vector setup command 
order visualize jointly routines executors commands class colored concept lattice follows 
concept representing executor lattice gets color executor class colored concept starting node traversal step 

top traversal starting colored concept color respective executor propagated subconcepts executor concept di erent executor reached 
colored concept lattice agilent rmware gives interesting insights 
concepts directly top element fig 
just color concepts represent just executor command 
concept color routines holds contribute commands di erent classes 
matter fact concepts bottom element di erent colors showing substantial sharing routines executors class commands 
utility routines concepts having color speci just single class commands 
words routine speci class commands command classes general 
dynamic analysis conjunction concept analysis important insight internal structure black box labeled utility routines fig 
routines routines executed test case statically declared routines respectively related executors speci cally attached bottom element 
executors commands class share general routines bottom element routines executed executors 
remarkable example executors con guration setup single pins hand con guration setup pin groups 
executors single pins share routines speci class executors pin groups belong class con guration setup share routine bottom element executors single pins executors pin groups 
hypothesis routines jointly con guration setup commands pin groups similarly commands single pins 
developer reviewing concept lattice explained macros heavily routine inlining subsystem implementing pin group con guration 
developer subsystem older part system 
apparently initial development compiler automatic routine inlining available 
macros undermines way collect dynamic information 
pro ler records routine calls reveal code sharing pin group commands 
generally concepts just top element contain routine 
contain routines 
cases programmer apparently split large executor smaller pieces better modularization 
concept just top element contains large number routines 
concept represents test execution 
developer explained routines speci cally attached concept strongly related grouped scenarios test execution provided 
developer looked large concept located middle concept lattice 
looking routines speci cally attached concept told routines deal memory management 
concept collected large number semantically related routines 
routines speci cally attached bottom element routines scenarios 
routines selection test cases failed structure set routines routines necessarily required possible usage scenarios case techniques needed group routines semantically 
goal identify executors routines shared executors investigate routines bottom element 
inferring categorization concept lattice prior analysis software architect selected rmware commands investigated 
categorized commands described section 
turned analysis concept lattice categorization incomplete 
software architect categorized commands listed fig 

additionally prepared scenarios explored commands listed fig 

incomplete categorization gave opportunity check possible categorize commands classes just basis concept lattice knowledge system application domain 
authors article guessed categories concept lattice precisely sharing utility routines classi ed commands 
assumption command belongs class commands shares utility routines 
altogether commands assigned classes assumption 
remaining commands lattice provide unambiguous information 
oracles validate guesses 
firstly asked developer classify commands con guration setup cntr cntr conf conf 


pals pals 

pact pact 
relay control test execution 
level setup commands 
term term 
timing setup commands 
wave wave 

vector setup commands 

fig 

categorization commands software architect 
sdsc dmas fig 

commands categorized software architect 
guess developer manual relay control test execution level setup commands timing setup commands vector setup commands dmas dmas multiple sdsc sdsc sdsc dmas fig 

comparison oracles 
secondly checked user manual rmware 
comparison guesses oracles shown fig 

interestingly classi cation manual incomplete 
commands described manual 
command really belong targeted classes commands manual added software architect starting command actual test execution 
sdsc commands assigned class command contain aspects di erent classes 
seen fig 
classi cation developer incomplete know rmware commands 
commands counting corresponding query commands 
classi cation developer accordance user manual described manual 
compare lattice guesses oracle nd author truly wrong command 
case command assigned command class equally possible classes 
interesting see commands assigned correctly simply lattice knowledge application domain implementation system 
lessons learnt case study explained basic interpretation concept lattice developer going formal mathematical details 
developer learnt read concept lattice surprisingly quickly minutes suggests technique easily adopted practitioners 
developer con rmed technique useful maintenance programmers familiar system order quickly identify executors 
naming convention executors place locating executors done textual search tools grep easily noted 
developer con rmed general approach static analysis executors located modify command traverses dependency graph 
lack sophisticated tools simple tools unix tool ctags get necessary information 
developer agreed dicult simple tools identify rmware commands routine contributes 
kind information help impact analysis changes 
dicult identify sharing utility routines executors 
case study revealed diculties proposed technique 
instance due inlining routines way macros pro ler identify code sharing commands pin groups 
inlining static analysis necessary 
order identify kind code sharing try identify joint uses macros non preprocessed code duplicated code preprocessed code way clone detection techniques 
diculty tackled case study problem handling parameterized scenarios scenarios alike values certain parameters 
instance commands rmware options 
options course uence behavior system 
command may execute di erent routines di erent options 
problem equivalent input coverage problem testing software general 
analogously test cases agilent case study de ned cover equivalence classes possible parameter values 
rmware commands called di erent combinations representative values equivalent parameter settings 
full coverage possible combinations exceed available resources guarantee software behaves equivalently apparently equivalent input values 
due dynamic analysis routines formal context concept lattice 
likewise number scenarios realistic trimmed digital part system 
concept lattice rmware agilent chip tester containing concepts relatively large complex 
large concept lattices challenge visualization 
regard time produce visualization reading understanding large graph 
graphviz layout graph automatically virtually time 
resulting layout acceptable rate better drawn graph 
liked group nodes graph semantically terms classes associated commands belong aesthetic criterion minimizing edge crossings 
lattice large screen 
reason print lattice pages din format discussion developer print names routines scenarios hard read 
experiences size complexity nal lattice agilent case study lead develop support incremental construction understanding concept lattice described section iv 
visual di erence considering scenarios incrementally illustrated fig 

contains concept lattice timing setup commands 
lattice fig 
scenarios vector setup added 
scenarios classes commands added lattice fig 
obtained 
vi 
related research section discusses research related 
discuss aspects interest 
take look papers closely related approach 
summarize visualizes dynamic timing commands 
timing vector commands 
fig 

concept lattice digital part agilent rmware 
static information di erent ways 
feature location wilde pioneered locating features fully dynamic approach 
goal software reconnaissance support maintenance programmers modify extend functionality legacy system 
execution test cases particular feature sets computational units identi ed computational units commonly involved code executed test cases regardless computational units potentially involved code executed test case invokes computational units involved code executed test cases invoke computational units uniquely involved code executed exactly cases invoked primary goal location starting points investigations wilde focus locating speci computational units required computational units 
approach deals feature time gives little insight connections sets related features 
set related features considered single feature repeat analysis invoking feature separately unite speci cally required computational units 
relationships groups features recognized 
approach dynamic information taken wong colleagues :10.1.1.22.2891
analyze execution slices corresponds execution pro les test cases implementing particular functionality 
process follows 
invoking input set set test cases terminology set scenarios identi ed invoke feature 

excluding input set identi ed invoke feature 

program executed twice separately 

comparison resulting execution slices computational units identi ed implement feature 
deriving required computational units execution slice including input set sucient 
subtracting computational units execution slice excluding input set execution slice invoking input set computational units remain speci cally deal feature 
information sucient identify interface constituents component source code computational units starting point detailed static analysis 
interdependencies features revealed easily 
wong way quanti cation features 
metrics provided compute dedication computational units features concentration features computational units disparity features 
complements earlier research re nement wilde technique 
chen rajlich propose semi automatic method feature location programmer browses statically derived system dependency graph asdg 
asdg describes detailed dependencies routines types variables level global declarations 
navigation asdg computeraided programmer takes search feature implementation 
method takes advantage programmer experience analyzed software 
suited locate features programmers pre knowledge know start search 
asdg quality essential method 
asdg includes assumptions function pointers programmer may routines called function pointers 
re ects conservative assumptions search space increases drastically 
statically undecidable control ow paths taken runtime conservative static analysis yield overestimated search space 
contrast dynamic analyses exactly reveal parts runtime particular run 
insights dynamic analyses valid input data environment system run 
wilde rajlich compared approaches 
case study techniques ective locating features 
software reconnaissance showed suited large infrequently changed programs rajlich method effective changes require deep complete understanding 
visualization object oriented systems de pauw colleagues provide general model visualization execution objectoriented systems 
language platform independent approach visualizes dynamic information runtime behavior means message sequence charts chart views summary information 
program explorer lange nakamura tool understanding programs means visualization 
static dynamic information extracted combined presentation objectoriented system 
static information derived source class hierarchy structural data stored program database 
dynamic information comprises method invocation object longevity variable accesses gained line execution traces 
program explorer ers selective instrumentation source requiring user certain knowledge system 
cope amount information user merge prune slice results analyses remove undesired information 
dynamic information coupled static information yielding class object object class clari cation 
program explorer useful global understanding user knowledge system focus relevant parts 
approach class object centered er levels abstraction 
koskimies developed scene tool visualizing object oriented systems written programming language oberon 
scene uses scenario diagrams visualizing message ow objects terms method invocations 
scenario diagrams generated event traces linked sources information 
jerding colleagues focus interactions program components runtime 
observed recurring interaction pattern abstraction process program understanding 
authors developed pattern identi cation algorithm structure dynamic information identi ed patterns 
primarily aims object oriented systems applicable procedural programming paradigms 
jerding rugaber tool support architectural localization extraction 
static dynamic information extract components connectors 
components speci ed analyst traditional static analyses connectors recognized actual execution traces 
execution traces analyzed aforementioned methods 
dynamic information visualized variant message sequence charts user ability restrict instrumentation speci les system 
syst focuses reverse engineering java legacy systems 
discusses combination static dynamic information reengineering java environment 
rigi extract static information class les connect dynamic information represented state diagrams gained program runs 
visualization abstraction ort combine dynamic static information object oriented systems taken ducasse 
er query approach facts legacy system modeled terms logical facts 
queries produce di erent views software di erent levels abstraction help restrict amount data generated 
information exchange views 
se ka colleagues visualize statics dynamics object oriented system terms architectural abstractions 
code instrumentation light weight architecture aware 
provides ecient line instrumentation support architecture guided queries 
architectural abstraction taken basis visualization 
similarly walker colleagues aim visualization dynamic information higher level abstraction 
program animation techniques program understanding 
murphy address problem crosscutting concerns object oriented systems 
propose usage concern graphs implementation details concerns explicitly show relationships parts concerns 
extraction concern graphs legacy system bene dynamic feature location techniques 
concept analysis primarily snelting introduced concept analysis software engineering 
evaluate class hierarchies explore con guration structures preprocessor statements recover components :10.1.1.10.9845
research utilizes static information derived source code 
technique similar taken ball :10.1.1.44.6482
describes concept analysis dynamic analysis test sets 
source code instrumented pro le information gathered 
results concept analysis data provide intermediate point entity path coverage criteria 
summary researchers program traces face problem huge amount data produced execution 
problem tackled removing undesired information instrumenting parts system providing ltering mechanisms patterns static information stored traces 
amount information gained pro ling tracing smaller precise handled eciently 
pro ling ne grained level routines methods basic blocks leads comprehensible results 
primary goals sequences operations crucial parts regained static information 
frequency invocations play major role believe information exploited research 
vii 
technique identi es computational units speci set related features execution pro les di erent usage scenarios 
rst concept analysis mathematically sound technique analyze binary relations allows locating computational units executed computational units 
static analysis uses computational units identify additional computational units dependency graph 
combination dynamic static information reduces search space drastically 
value technique demonstrated case studies 
case study analyzing web browsers recover partial description software architecture respect speci set related features 
commonalities variabilities partial architectures recovered quickly 
altogether experiments systems respectively feature speci routines routines mosaic respectively chimera 
routines needed inspected manually 
second case study performed loc production system 
experiences case study showed problems approach growing complexity concept lattices large systems features need handling compositions features 
extended technique solve problems 
showed method allows incrementally exploring features preserving mental map analyst gained analysis 
second improvement described detailed look composing features complex scenarios 
assuming correspondence features scenarios earlier handle scenarios invoke features 
implementation approach simple 
concept analysis tool concepts 
visualization graphical bauhaus front 
layouts generated graphviz 
glue code written perl compiling pro ling gcc gprof 
acknowledgments gerd jens agilent technologies support agilent case study 
markus stefan students university stuttgart preparing test cases agilent case study 
meir lehman programs life cycles laws software evolution proceedings ieee special issue software evolution vol 
pp 
sept 
rainer koschke atomic architectural component recovery program understanding evolution dissertation universit stuttgart germany 
thomas eisenbarth rainer koschke daniel simon derivation feature component maps means concept analysis proceedings th european conference software maintenance reengineering lisbon portugal mar pp 
ieee computer society press 
xfig drawing tool version available www xfig org 
james rumbaugh ivar jacobson grady booch uni ed modeling language manual addison wesley 
norman wilde michael software reconnaissance mapping program features code journal software maintenance research practice vol 
pp 
jan 
susan horwitz thomas reps david binkley interprocedural slicing dependence graphs acm transactions programming languages systems vol 
pp 
jan 
arp ad tam dynamic slicing method maintenance large programs proceedings th european conference software maintenance reengineering 
mar pp 
ieee computer society press 
lars ole andersen program analysis specialization programming language ph thesis diku university copenhagen :10.1.1.109.6502
antoniol paolo tonella impact function pointers call graph proceedings european conference software maintenance reengineering amsterdam netherlands mar pp 

ben chung cheng wen mei hwu modular interprocedural pointer analysis access paths proceedings conference programming language design implementation vancouver bc canada pp :10.1.1.43.4867

das uni cation pointer analysis directional assignments proceedings conference programming language design implementation vancouver bc canada pp 

emami rakesh ghiya laurie hendren context sensitive interprocedural points analysis presence function pointers proceedings conference programming language design implementation orlando fl usa pp :10.1.1.25.6013

robert wilson monica lam ecient contextsensitive pointer analysis programs proceedings conference programming language design implementation la jolla ca usa pp :10.1.1.22.4648

sean zhang barbara ryder william landi program pointer aliasing step analyses symposium foundations software engineering pp 

bjarne steensgaard points analysis linear time symposium principles programming languages st petersburg beach fl usa jan pp 
:10.1.1.22.2891
amer diwan kathryn mckinley eliot moss types analyze optimize object oriented programs programming languages systems vol 
pp 

rountev ana milanova barbara ryder pointsto analysis java annotated constraints proceedings conference object oriented programming systems languages applications tampa fl usa oct pp :10.1.1.25.1069

ana milanova rountev barbara ryder precise call graph construction presence function pointers proceedings nd international workshop source code analysis manipulation montreal canada oct ieee computer society press 
garret birkho lattice theory american mathematical society colloquium publications providence ri usa rst edition 
bernhard ganter rudolf wille formal concept analysis mathematical foundations springer 
idef available www idef com idef html dec 
kai koskimies scenario browsing object oriented systems scene report johannes kepler universit linz austria aug 
danny lange nakamura program explorer program visualizer proceedings usenix conference object oriented technologies monterey ca usa june 
danny lange nakamura object oriented program tracing visualization computer vol 
pp 
may 
new bauhaus stuttgart available www 
bauhaus stuttgart de 
rainer koschke jean fran cois girard martin intermediate representation reverse engineering analyses proceedings th working conference reverse engineering honolulu hi usa oct pp 
ieee computer society press 
rigi visual tool understanding legacy systems available www rigi csc uvic ca 
david garlan robert allen john architectural mismatch hard build systems existing parts proceedings th international conference software engineering seattle wa usa apr pp 
acm press 
labs research graphviz open source graph drawing software available www research att com sw tools graphviz 
norman wilde juan gomez thomas douglas locating user functionality old code proceedings international conference software maintenance orlando fl usa nov pp 
ieee computer society press 
eric wong gokhale joseph horgan trivedi locating program features execution slices proceedings ieee symposium application speci systems software engineering technology richardson tx usa mar pp :10.1.1.22.2891
ieee computer society press 
eric wong gokhale joseph hogan quantifying closeness program components features journal systems software vol 
pp 
oct 
chen rajlich case study feature location dependence graph proceedings th international workshop program comprehension limerick ireland june pp 
ieee computer society press 
norman wilde michelle henry page rajlich case study feature location unstructured legacy fortran code proceedings th european conference software maintenance reengineering lisbon portugal mar pp 
ieee computer society press 
wim de pauw richard helm doug john visualizing behavior object orient systems proceedings conference object oriented programming systems languages applications washington dc usa sept pp 
acm press :10.1.1.22.2891
wim de pauw doug john vlissides modeling object oriented program execution proceedings th european conference object oriented programming bologna italy july vol 
lecture notes computer science pp 
springer 
wim de pauw david lorenz john vlissides mark wegman execution patterns object oriented visualization proceedings th usenix conference object oriented technology systems santa fe nm usa pp 

dean jerding john stasko thomas ball visualizing interactions program executions proceedings th international conference software engineering boston ma usa may pp 
acm press 
dean jerding spencer rugaber visualization architectural localization extraction science computer programming vol 
pp 
mar 
syst relationships static dynamic models reverse engineering java software proceedings th working conference reverse engineering atlanta ga usa oct pp 

st ephane ducasse recovering high level views object oriented applications static dynamic information proceedings international conference software maintenance oxford england uk aug pp 
ieee computer society press 
se ka sane roy campbell architecture oriented visualization proceedings conference object oriented programming systems languages applications san jose ca usa oct pp 
acm press 
robert walker gail murphy bj rn freeman benson wright swanson jeremy visualizing dynamic software system information high level models proceedings conference object oriented programming systems languages applications vancouver bc canada pp 

martin gail murphy concern graphs finding describing concerns structural program dependencies proceedings th international conference software engineering orlando fl usa may 
gregor snelting frank tip reengineering class hierarchies concept analysis proceedings th sigsoft symposium foundations software engineering orlando fl usa nov pp :10.1.1.10.9845
acm press 
krone gregor snelting inference con guration structures source code proceedings th international conference software engineering sorrento italy may pp 
ieee computer society press 
gregor snelting reengineering con gurations mathematical concept analysis acm transactions software engineering methodology vol 
pp 
apr 
tobias kuipers leon moonen types concept analysis legacy systems proceedings th international workshop program comprehension 
june pp 
ieee computer society press 
canfora cimitile andrea de lucia di case study applying eclectic approach identify objects code proceedings th international workshop program comprehension pittsburgh pa usa may pp 
ieee computer society press 
holger implementing concept analysis tool identifying data types code diplomarbeit universit kaiserslautern germany 
christian lindig gregor snelting assessing modular structure legacy code mathematical concept analysis proceedings th international conference software engineering boston ma usa may pp 
ieee computer society press acm press 
melo hakim fran cois applying concept formation methods object identi cation procedural code proceedings international conference automated software engineering lake tahoe ca usa nov pp 
ieee computer society press 
michael si thomas reps identifying modules concept analysis proceedings international conference software maintenance bari italy oct pp 
ieee computer society press 
arie van deursen tobias kuipers identifying objects cluster concept analysis proceedings st international conference software engineering los angeles ca usa pp 
ieee computer society press 
paolo tonella concept analysis module restructuring ieee computer society transactions software engineering vol 
pp 
apr 
thomas ball concept dynamic analysis acm sigsoft software engineering notes vol :10.1.1.44.6482
pp 
nov 
christian lindig concepts available www 
de lindig software 
thomas eisenbarth received diploma computer science university stuttgart germany 
working dissertation university stuttgart eld reverse engineering member bauhaus project 
research interest reengineering reverse engineering program understanding software architecture 
focuses recovery methods connectors source code 
rainer koschke post doctoral researcher computer science department university stuttgart 
research interests primarily elds software engineering program analyses 
current research includes architecture recovery feature location program analyses reverse engineering 
teaches reengineering compilers programming language concepts 
holds doctoral degree computer science university stuttgart germany 
daniel simon received diploma computer science saarland university saarbr germany 
working dissertation university stuttgart eld reverse engineering member bauhaus project 
research interest eld reverse engineering program analysis program understanding 
authored papers feature location software product lines current research focus 
