fast computation concept lattices data mining techniques gerd stumme ra taouil yves bastide nicolas pasquier lot lakhal technische universit darmstadt fachbereich mathematik 
darmstadt germany stumme mathematik tu darmstadt de laboratoire informatique universit blaise pascal scienti que des av 
des ere cedex france bastide pasquier univ fr new algorithm called titanic computing concept lattices 
data mining techniques computing frequent itemsets 
algorithm experimentally evaluated compared ganter closure algorithm 
concept lattices represent conceptual hierarchies inherent data 
core mathematical theory formal concept analysis fca 
introduced early ies formalization concept concept fca years grown powerful theory data analysis information retrieval knowledge discovery 
arti cial intelligence ai fca knowledge representation mechanism 
database theory fca extensively class hierarchy design management 
usefulness analysis data stored relational databases demonstrated commercially management system toscana conceptual information systems 
current research domain common ai database community knowledge discovery databases kdd 
fca formal framework implication association rules discovery reduction improving response times algorithms mining association rules 
interaction fca kdd general discussed 
show vice versa fca bene ideas mining association rules computing concept lattices important issue investigated long years 
address problem computing concept lattices data mining viewpoint level wise approach provide new ecient algorithm called titanic 
section theoretical foundation 
turned pseudocode section 
conclude results experimental evaluation 
lack space provide proofs discuss general fca ai database theory 
computing concept lattices support function formal concept analysis rst part section brie recall basic notions formal concept analysis 
extensive formal concept analysis refer 
de nition formal context triple sets binary relation 
elements called objects elements items 
inclusion read object attribute 
assume sets nite especially de ne fm ig de ne dually fg ig 
formal concept pair called extent called intent concept 
set concepts formal context partial order equivalent complete lattice called concept lattice jacobs jacobs light jacobs free jacobs mild jacobs plus plus plus plus gold classic hag cafe cafe mild mild jacobs plus classic mild formal context ee brands sold supermarket 
shows formal context lists ee brands sold supermarket 
shows concept lattice context line diagram 
line diagram name object attached circle representing light mild classic dm plus jacobs mild cafe mild hag classic cafe plus plus plus plus gold jacobs free jacobs light jacobs mild jacobs jacobs concept lattice context smallest concept extent dually name attribute attached circle representing largest concept intent 
allows read context relation diagram object attribute ascending path circle labeled circle labeled extent concept consists objects labels diagram intent consists attributes attached concepts hierarchy 
example concept labeled dm plus plus plus gold extent dm plus house brand supermarket dm intent 
say implication holds context object having attributes attributes implication association rule con dence 
instance implication holds ee context 
implications read directly line diagram largest concept having plus classic intent concept labeled dm 
shown association rules con dence visualized line diagram 
support computation closure system concept intents composed function 
closure operator extensive monotonous idempotent 
related closure system set exactly set intents concepts context 
structure concept lattice determined closure system 
restrict computation closure system concept intents sequel 
computation extensive support function de nition support de ned supp jx jgj case sets obviously support 
hand comparable attribute sets support closures lemma 
supp supp ii supp supp lemma allows develop algorithm general setting de nition weight function function powerset partially ordered set 
set called weight weight function compatible closure operator ii iii closure operator nite set compatible weight function 
task determine eciently closure system fx xg related closure operator easy check formal context support function ful lls conditions de nition closure operator problem weight function computation closure system induced functional dependencies valid actual data relational database refer 
discuss problem computing closure system weight function parts 
compute closure set weight function closure operator 

compute closure system computing closures possible 
weight function usually stored explicitly derive weights sets possible weights computed 
questions independent 
provide optimal answer improves bene holds functional dependencies min sequel de nition replaced max 
weight computation closures constraints function determining closure set comparing weight weights immediate supersets 
proposition fm fmg know weights sets compute closure operator 
algorithm steps 
subsection discuss sets necessary compute closure order obtain closed sets 
subsection discuss weights needed computations determined 
level wise approach computing closed sets compute closure system applying proposition subsets ecient closed sets determined times 
de nition de ne equivalence relation powerset equivalence class fy knew equivalence relation advance sucient compute closure set equivalence class 
determine relation computation consider element class general 
known algorithms mining association rules level wise approach 
de nition set subset jxj de ne fx jxj kg 
kth iteration weights sets remained pruning strategy described determined closures sets passed pruning th iteration computed 
rst sets equivalence class reach level wise approach minimal sets class de nition set key set minimal generator min 
set key sets denoted obviously fh kg 
proposition set order ideal 
section give algorithms section 
skipped rst reading 
pruning strategy 
originally strategy heuristic determining frequent sets terminology sets weights user de ned threshold 
show strategy applied arbitrary order ideals powerset de nition order ideal 
candidate set subset proper subsets de nition justi ed lemma lemma set candidate sets order ideal order ideal generated 

subset exists order ideal 
order ideal inclusion holds 
ecient generation set candidate sets level described proposition 
algorithm 
assume linearly ordered ng 
proposition 
ffx fx fx xg fx fxg xg 
fx candidate set xg 
apriori algorithm application pruning set 
algorithm step determined properties properties subsets taken account 
causes additional step generation function 
algorithm step compared original version 
additional step iteration non key sets candidate sets pruned ii proposition 
proposition 
fmg fmg 
ii key set fmg 
deriving weights known weights reach set known key set passed key sets equivalence class earlier iteration 
know weight 
proposition determine weight weights computed 
proposition key set xg sucient compute weights candidate sets calling function depending speci implementation algorithm step 
weights derived weights 
titanic algorithm pseudo code algorithm 
list notations provided table 
algorithm titanic forall fmg mg loop weigh fx sg forall closure closure exit loop titanic gen loop return fx closure table notations titanic counter indicates current iteration 
kth iteration key sets determined 
contains kth iteration key sets weight closure closure 
stores candidate sets counter stores minimum weights subsets counter step prune non key sets 
algorithm starts stating empty set key set weight case concept lattices equal steps 
sets candidate sets de nition steps 
iterations candidate sets determined function titanic gen step algorithm step straight forward implementation proposition 
result step step algorithm pruning non key sets 
candidate sets determined function weigh called compute weight stores variable step 
case concept lattices weigh determines weights supports single pass context 
fact candidate passes needed reason eciency titanic 
algorithm titanic gen input set key sets weight output set candidate sets values fmg cg 
variables assigned sets fp generated step initialized fp 
ffp fp fp forall forall subsets fxg exit forall min return algorithm closure forall fmg closure forall fmg fmg minfk fmg return step algorithm candidate sets key sets pruned proposition ii 
remaining sets known key sets closures computed step 
closure function algorithm straight forward implementation propositions additional optimization step 
algorithm terminates key sets left step 
iteration begins steps 
experimental evaluation algorithms proposed computing concept lattices 
ecient best knowledge ganter closure algorithm 
experimental evaluation version titanic algorithm implemented rewriting ch 
lindig version closure 
comparisons took place pentium iii running mhz mb main memory performed mushroom objects attributes internet objects attributes databases available uci kdd archive kdd ics uci edu varying number objects 
results listed table visualized 
show relatively strongly mushrooms database closure faster attributes takes twice time titanic dataset 
weakly internet database di erence larger 
stems fact development titanic inspired apriori algorithm known perform weakly data 
table database characteristics evaluation results computation time sec 
database objects attr 
concepts closure titanic mushrooms internet time number objects closure titanic number objects closure titanic comparison titanic closure mushrooms left internet databases right problem computing concept lattices exponential complexity 
shows expect algorithm robust claimed solves problem reasonable time worst case 
experimental results show normal conditions handled care strong algorithm may improve exploration unknown regions knowledge 
agrawal srikant 
fast algorithms mining association rules 
proc 
vldb conf expanded version ibm report rj ganter reuter finding closed sets general approach 
order 
kluwer academic publishers ganter wille formal concept analysis mathematical foundations 
springer heidelberg godin missaoui incremental concept formation approach learning databases 
tcs stumme wille wille conceptual knowledge discovery data analysis 
ganter mineau eds conceptual structures logical linguistic computational structures 
proc 
iccs 
springer heidelberg appear kivinen mannila approximate inference functional dependencies relations 
tcs ch 
lindig concepts 
ftp ftp ips cs tu bs de pub local misc concepts 
tar gz 
open source implementation concept analysis mannila toivonen levelwise search borders theories knowledge discovery 
data mining knowledge discovery scholl algorithm insertion lattice application type classi cation 
proc 
rd intl 
conf 
fodo 
lncs springer heidelberg pasquier bastide taouil lakhal discovering frequent closed itemsets association rules 
proc 
icdt conf pasquier bastide taouil lakhal ecient mining association rules closed itemset lattices 
journal information systems ingo schmitt gunter saake merging inheritance hierarchies database integration 
proc 
rd ifcis intl 
conf 
cooperative information systems new york city usa august stumme wille wille conceptual knowledge discovery databases formal concept analysis methods 
zytkow eds principles data mining knowledge discovery 
proc 
nd european symposium pkdd lnai springer heidelberg stumme wille eds methoden und anwendungen 
springer heidelberg taouil pasquier bastide stumme lakhal mining bases association rules formal concept analysis 
journal knowledge information systems submitted vogt wille toscana graphical tool analyzing exploring data 
lncs springer heidelberg taouil lakhal object database approach managing concept lattices 
proc 
th intl 
conf 
conceptual modeling lncs springer heidelberg wille restructuring lattice theory approach hierarchies concepts 
rival ed 
ordered sets 
reidel dordrecht boston lakhal bordat io algorithmic method building inheritance graphs object database design 
proc 
th intl 
conf 
conceptual modeling 
lncs springer heidelberg 
