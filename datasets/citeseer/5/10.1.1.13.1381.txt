automatic extraction object oriented component interfaces john whaley michael martin monica lam computer systems laboratory stanford university stanford edu component software design popular ective approach designing large systems 
components typically de ned interfaces sequencing information calls come order formally speci ed 
proposes multiple nite state machine fsm submodels model interface class 
submodel includes subset methods example implement java interface access particular eld 
state modifying method represented state fsm transitions fsms represent allowable pairs consecutive methods 
addition state preserving methods constrained execute certain states 
designed implemented system includes static analyses deduce illegal call sequences program dynamic instrumentation techniques extract models execution runs dynamic model checker ensures code conforms model 
extracted models serve documentation serve constraints enforced static checker studied directly developers determine program exhibiting unexpected behavior determine completeness test suite 
system run large code bases including virtual machine basic java libraries java enterprise edition library code 
experience suggests approach yields useful information 

popular approach designing large systems component software design 
idea improve software reuse crafting carefully engineered software elements suitable broad array applications 
research supported part nsf award nsf student fellowship stanford graduate fellowship 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
copyright acm xxxxx xx xx xx 
commit save rollback fsm database example applications programming interface api designed implementors lower number dependencies code needs worry concentrating providing services api speci es 
result modern enterprise computing architectures monolithic systems typically consist multiple tiers reusable components user interfaces system services transactions security databases 
resulting component libraries reused di erent applications 
api components includes constraints public method may invoked 
example sql server may include commands commit save rollback 
command rst executed series save rollback commands issued nally commit 
incorrect example save rollback commit invoked command 
represent constraints nite state machine fsm shown 
constraints common apis 
deal deals modeling objects nite state machines 
previous systems vault nil hermes provide programmers linguistic constructs specify state variables program compiler ensure object correct state 
advantage approach code written way guaranteed conform nite state models 
requires programmers rewrite code retro tting large systems existing code framework plausible 
systems pre metal slam operate directly existing software check code conforms pre de ned correctness constraints expressed fsms 
systems demonstrated successful nding errors operating systems 
bottlenecks systems correctness constraints readily available large systems 
programmers willing able write speci cations 
furthermore programmers may wrong specifying constraints 
deal various attempts infer constraints automatically 
engler proposed techniques infer constraints programs analyzing behavior code statically 
allow errors program behavior observed time considered norm 
results suggest approach ective nding bugs lock function call followed unlock 
addition dynamic techniques extract information directly programs proposed :10.1.1.137.4260
particular ammons machine learning techniques limited success extract speci cations program analyzing dynamic program traces 
problem focus developing techniques automatically extract application interfaces directly existing code 
previous area interested techniques apply large object oriented component level software system code written low level languages large applications typically manipulate dynamically allocated objects stored recursive data structures 
instances class may follow state transition model di erent states time 
states may encoded cases explicit variables states governed highly application speci semantics unknown programming tools 
techniques track control ow values variables limited programming paths ective 
interest handling large software order millions lines code formal methods model checking feasible 
techniques designed take advantage modularity object oriented programming languages 
object oriented system set public methods class de nition de nes complete interface instances objects belonging class 
guaranteed methods class mutate state object 
operate method level dealing de nitions uses individual memory locations focus nding higher level relations methods commit rollback relate 
proposes multiple fsm submodels model interface class 
submodel includes subset methods example implement java interface access particular eld 
state modifying method represented state fsm transitions fsms represent allowable pairs consecutive methods 
addition state preserving methods constrained execute certain states 
explore fully automatic techniques extracting partial interface models large java programs dynamic tool static analysis tool 
dynamic analysis technique observes program runs build model re ects operations performed execution program 
dynamic analysis su er disadvantage static analyses necessarily conservative 
results gathered complete sequences events take place 
unfortunately dynamic system prove things existentially 
purported universal dynamic system nds may prove artifact test cases system trained 
demonstrate model actively forbids certain cases turn static analysis 
static analysis technique searches method sequences component invariably cause exceptions thrown 
sequences deemed illegal 
static system su ers disadvantage easily identify priori sequence part typical permitted usage 
advantages disadvantages static dynamic approaches complement nicely hybrid system uses acquire great deal information 
hybrid system take advantage advantages dynamic static approaches directly pertain model 
static system fuller access structure code variety deductions nature classes dynamic system focus carefully useful features program runs 
dynamic system turn easy access current state heap time need advanced pointer alias analysis static side 
deductions require detailed alias information simply delayed run time 
applications automatically extracted models partial models extracted system useful ways 
information serve documentation system 
especially useful programmers faced large piece software rst time 
second component designers may wish examine extracted model see coincides expectations 
third dynamic analysis means measure coverage test suite 
model extracted analyzing test suite gives succinct summary sequencing methods tested 
results may suggest additional tests written test important subsequences method invocations 
fourth model may extracted automatically prepared programmer monitor execution program automatically ag errors deviate correct behavior 
static tools check conformance model implemented locate errors programs 
implemented analyses systems operate java bytecodes 
case studies show relatively simple scalable techniques successful extracting useful models large programs 
tested tools di erent applications consist lines code 
demonstrate 
ectiveness model 
model automatically extracted socket implementation java net illustrates interface models effective capturing correct usage class 

automatic static model extraction 
static analysis successfully extracts useful models standard java libraries 
information useful documentation static tools look errors programs 

model characterize test suites 
demonstrate scalability dynamic analysis tool ee enterprise edition platform 
show extracted models convey interesting information program tested test suite 

models software auditing 
get sense applicability system program evolution developer feedback applied technique program familiar virtual machine 
dynamic system able nd discrepancies intended implemented api static system provided accurate rendition appropriate call sequence 
overview rst de ne model component interfaces section illustrate example discuss optimize utility 
describe static analysis section dynamic analysis section 
preliminary experience section 
section discusses related section concludes 

component interface model design model interface inspired concept path expressions 
path expressions originally designed allow simple speci cation complex synchronization schemes concurrent processes operating systems 
regular expressions de ne set admissible execution histories operations shared resource 
histories represent interleaving actions multiple threads 
approach simpli ed version path expressions treat objects resource shared di erent sections application 
allowing general regular expression capture history methods invoked object place restrictions fsms easier extract ecient enforce dynamically 
na approach method model represented exactly state 
de nition na model 
na interface model class cl nite state machine denoted cl hs set methods class cl plus special methods start set legal method sequences 
instance state op op method set invoked instance state start method exists 
method op invoked instance instance state op op op major problems na model 
objects suciently complex sequencing constraints merely knowing method called capture proper behavior object 
secondly methods state preserving side effects advance state object 
including na model destroys accuracy 
remainder section re ne na model address issues 
section discusses issue start set set get get na model example set set get get start start improved model eld splitting complex sequencing constraints section discusses state preserving transitions 
section concludes formal speci cation model 
model slicing type member fields models associated individual classes class instantiable object superclass unimportant model 
objects members multiple classes members class subclasses type implement number interfaces 
type methods encapsulate set constraints 
type object may cast speci es separate model turn represented fsm 
full set sequencing constraints object represented product fsms 
token slice methods class eld accesses 
precisely class elds create submodels submodel contains methods necessarily unique submodel access eld 
submodel may subsume methods allowable method pairs superset 
rationale slicing elds methods refer variable related relative ordering independent 
representing separately allows accurately model independent aspects single object 
consider simple class elds methods set get set get method get invoked set similarly method get invoked set attempting model behavior na model produces model shown 
notice order allow arbitrary interleaving get set operations give capability enforcing de ned 
split model get fsms shown 
new system able enforce get get preceded set set respectively 
start set get set get start final model get set example state preserving transitions na model method call changes state model 
methods update state object tostring hashcode methods de ned java objects examples 
having methods model allows method followed method provided state preserving method invoked 
common approach improve accuracy create nite state machines keep track calls call 
approach exacerbate problem 
model may contain transitions greatly complicating analysis 
furthermore legal state preserving calls row landing object state reach state 
approach distinguish methods produce side ects 
side ect free methods advance state object common examples side ect free methods java include tostring hashcode 
including create overly weak model discussed 
ignore side ect free methods building set side ect free method may advance state object may sequencing constraints example method get value may value set 
de ne side ect free method set states legal call method 
represent model diagrams dotted lines connecting methods states states method legal 
illustrate consider example previous section assume get get side ects 
nal models shown 
formal definition model expand na de nition model include re nements de nition interface model class collection submodels triple denoted hu set methods governed submodel plus special methods start set methods qualify states set allowable method pairs 
instance state op op method set invoked instance state start method exists 
method op invoked instance instance state op op op 
static model extractor section describes static analysis technique automatically detect sequencing constraints component interfaces designed guard misuse 
basic idea analyze uses de nitions elds class identify pairs method invocations cause exception program 
example method stores null eld followed invocation method dereferences eld unconditionally 
rst discuss information available designed java components discuss technique extracts information 
defensive programming widely components programmed detect illegal sequences method invocations ensure integrity component 
typical approach maintain state value check state valid performing operation 
valid java program usually throw appropriate exception programs written languages typically return return code indicating error assert state invalid exit program 
state may implicitly encoded eld holds normal data operated 
example null eld indicate method sets invoked 
state explicitly encoded eld 
eld typically implemented enumerated type holding possible states object 
bene enumerated types java implementations typically integers booleans 
eld similar concept type state variables 
presents empirical evidence notion type state variables particularly applicable object oriented software especially languages exception handling facility 
consider example design list iterator shown 
code taken java util class standard java class library 
java util implements java util interface 
set operation writes object current element iterator indicated index variable 
previous methods adjust index variable remove add methods eliminate notion having current element 
indicated setting variable cause set operation throw intervening previous method invocations 
variable doubles value algorithm type state 
code programmed possible analyze implementation deduce sequences forbidden component 
algorithm algorithm consists steps 
method identify elds predicates guard exceptions thrown 
second nd methods set elds values cause exception 
immediate transitions illegal 
interprocedural analysis run class determine methods may modify eld 
complement illegal transitions respect relevant methods forms model transitions accepted static analysis 
public object cursor public object previous cursor public void remove throw new public void add object public void set object throw new 
example code 
general problem invocation method may cause raise exceptions undecidable 
fortunately state variables simple manner illustrated example 
restrict analysis nding simple predicates involve testing eld constant null constant integer 
note java dereferences preceded null check de nition includes nding runtime exceptions thrown result java semantics 
algorithm nds predicates control exceptions thrown 
algorithm computes control dependence information method 
site throw exception checks predicate guarding execution single comparison eld current object constant value eld written prior tested 
say single predicate pre condition method eld tested state variable 
second step analyzes methods nd assign constant values state variables 
perform constant propagation analysis methods determine state variables set constant exit 
identi ed illegal transition constant value satis es condition guards exception throwing statements 
implemented algorithms compiler system 
correctly identi es start set start remove remove set add set remove remove add remove transitions throw exception 
complement allowable transitions shown fig 

previous remove add start set submodel extracted statically slice 

dynamic extractor checker section describes dynamic instrumentation technique automatically detect usage pattern objects building series submodels enforce speci ed model run time 
basic idea track instance instrumented class individually 
method invoked update history object record sequence relevant submodel 
rst discuss basic extraction technique discuss issues addressed implementing system java 
extracting model set class les instrument running mod ref analysis section bytecode determine methods relevant eld 
eld assigned submodel 
method writes deemed state modifying method reads write deemed relevant state preserving 
guide insertion calls analysis routines method boundaries 
system uses byte code engineering library rewrite bytecodes insert calls analysis routines 
analysis routines deal submodel time method relevant multiple models multiple calls inserted 
calls placed run training programs instrumented objects 
instance keeps track submodel state modifying method called instance 
method invoked object extractor examines records updates submodels appropriately updates call information instance submodel method state modifying 
order capture exported interface ignore internal usage object dynamic system maintains knowledge local call stack ignores call internal instance 
program nishes transitions state noted instance nal set models written 
dynamic checker accepts set models input 
nearly identical extractor primary di erence extractor adds elements set legal transitions checker prints warnings raises exceptions previously unseen transition occurs 
complications conceptually simple number challenges program description lines code analyses java net networking library static dynamic java libraries general purpose library static ee business platform dynamic java jvm implementation static dynamic table applications experiments complications arise implementing system 
inheritance 
submodel speci es methods instrument class 
methods may exist class le inherited superclass 
solve problem adding dummy methods simply call methods superclass explicitly 
may instrumented methods class de nes 
exceptional control ow 
control ow may leave method uncaught exception 
sucient merely insert calls method return instruction 
deal uncaught exceptions add additional exception handler method catch uncaught exception call analysis routines rethrow exception 
multithreading 
java language supports encourages multithreading 
raises issues rst ensure model extraction routines get corrupted due race conditions second address issue call means multiple threads making concurrent calls object 
ensure model state corrupted thread model extracting code time 
ensure mutual exclusion declaring extraction checking routines synchronized 
routines fairly short occur method boundaries signi cantly impact program execution 
object multiple threads system keeps separate call history thread accesses object capturing protocol followed thread independently 
memory leaks 
may maintain hard object actual program preclude unreachable storage reclaimed garbage collector 
solve problem advantage java facility weak refer object inhibiting reclamation garbage collector 
object loses non weak garbage collector noti es dynamic system adds transition ceases tracking object 

experiences applied tools real life applications 
set programs shown table 
rst model extracted java net library illustrate model 
show model provides signi cantly better results na methods considered state transformers model 
second static analysis technique extract models java standard library 
third apply dynamic instrumentation tool extract models ee application large application framework prior knowledge implementation 
developed simple test suite generator models extracted gives useful insight completeness test suite 
apply static dynamic tools program java compiler java virtual machine written java show value automatic model extraction bring system designer 
illustration model tools rst experiment demonstrate feasibility model capturing component interface 
apply technique class java net java net library 
java net common superclass classes implement sockets java 
create client server sockets 
class consists methods shown 
ran experiments 
rst experiment dynamic model extractor nd lower bound model 
instrumented irc client exercised connecting irc server 
second experiment applied static analysis tool nd upper bound model 
method description create creates datagram socket connect connects socket bind binds socket listen sets maximum queue length incoming connections accept accepts connection returns input stream view returns output stream view available returns number bytes read blocking close closes socket shuts input stream shuts output stream returns le descriptor returns address socket returns remote port number returns local port number reset closes socket important methods java net experiment dynamic model extractor ran dynamic tools rst assuming na model method call changes state nite state machine 
obtained model 
model states edges 
implied usage rules create connect start close available finalize dynamically extracted na model java net available start close create connect dynamically extracted submodel fd eld java net simply artifacts client code example call followed 
shows na model slicing elds identifying state preserving methods basically pointless case 
proceeded slice methods elds access separate state preserving methods rerun dynamic tests submodels 
obtained models simple state put get models 
model fd le descriptor eld interesting 
fd eld state setting state dependent methods state modifying create connect close state dependent available close re ran dynamic tests information obtained model 
slicing elds separating state preserving methods produced dramatically simpler model succinctly summarizes sequencing constraints object 
experiment static analysis tool second experiment applied static analysis tool determine transitions throw exception 
static analysis correctly identi ed illegal perform sequences start start start available close close close available 
worth noting standard java api documentation java net class specify conditions exception thrown 
inspection source code able check results tool 
inspecting source code connect method implicitly performs create operation create unnecessary 
furthermore legal call connect multiple times call create connect call close time 
transitions triggered dynamic tests static analysis subsequent inspection source code con rm fact legal 
automatic static model extraction java standard class library evaluate ectiveness static analysis extracting models bytecode directly applied tool java standard class library 
library contains classes tool classes method sequences invariably threw exceptions 
wide variety classes amenable technique 
tool able identify iterator classes library iterator model discussed section 
addition nds conformance model classes vector linkedlist data retrieved exists 
calling retrieval method immediately construction clearing collection illegal 
socket classes data read written connection set le streams closed 
timer new tasks scheduled timer canceled 
certain methods accessed initializations 
classloader classes attempts object initialization reinitialize object throw exception 
attempting destroy throws exception 
signature initialization updating signing proceed sequentially 
actual constraints classes extracted shown 
brevity clarity consolidated simpli ed extracted constraints 
row table describes constraints di erent sets classes classes similar constraints merged single row table 
table contains types constraints 
negative constraints marked sign say calling method column immediately followed calling method column throw exception illegal 
positive constraints marked start sign update verify model extracted statically signature 
sign say call column precede calls column exception thrown 
column table gives condition instance variable constraint 
model extracted java security signature particularly interesting 
state object explicitly encoded eld called state class 
state eld integer value 
state set initializer 
calling sets state calling sets state 
sign called state exception thrown 
likewise verify called state exception thrown 
update called state exception thrown 
information static analysis able generate model shown 
evaluating test suites ee third experiment attempted dynamic model extractor characterize test suite 
addition wished nd limit dynamic instrumentation exercising large application 
purpose selected java enterprise edition ee version popular component architecture creating enterprise applications java 
large system comprising nearly lines code source les 
application ee architecture java pet store demo web enterprise application provided sun intended framework developing ee business applications 
instrumenting class ee renders system slow usable 
identi ed web service org apache hierarchy bottleneck just skipping instrumentation package sucient create usable system 
typical latency loading page second range 
goal experiment determine dynamic tool evaluate test suite 
unfortunately access ocial test suite ee platform 
purpose experiment developed tool automatically generates test cases web applications graphical user interface 
button simulates user traversing web site parsing traversing web pages 
randomly clicks links goes back aborts transfers reloads pages parses form data correctly ll web forms 
tool adapted ralf program 
presumably avoid having initialize state variable 
start suspend resume commit rollback sample model start sample model running multiple concurrent copies button simulates web server heavy load 
collected models concurrently running instances running instance full iterations 
complete test run pet store took approximately minutes 
get sense button compared manual testing performed separate experiment manually accessing server dozen di erent machines simultaneously performing various operations 
comparing models derived testing methods button complete ective 
fact button sequences commands triggered uncaught exceptions ee system 
running button sample pet store application invoked just fth methods ee library extracted models classes 
expected uninteresting models 
example models merely speci ed initializer constructor followed arbitrary sequences di erent get set routines 
approximately interesting models extracted database transactions 
example interface automatically extracted class transaction shown 
example illustrates tool ective extracting sensible models automatically java byte codes 
uses na model class question interface internal class variable itr collections previous remove set null hashmap hashmap enumerator add remove remove set index linkedlist treemap iterator vector init size linkedlist sockets close finalize methods fd null connect receive read pipedreader connect connect connected close receive read connect write connected connect connect null null null timer cancel finalize sched init function various init methods initialized init init classloader destroy destroy destroyed signature start sign sign update state verify verify update constraints extracted static analysis elds 
programmer unfamiliar system learn salient information code just models 
developers may take information starting point augment create complete model 
importantly provides interesting characterization behavior program test suite model generated 
case see rollback methods methods invoked object 
suggests application simply discards transactions rolled back test suite exercise code performs operations rollback 
shown example provides useful information test suite 
gure automatically extracted model ee internal class com sun corba ee internal io 
clear model recursion depth stream call 
see test suite adequately test scenarios recursion encountered 
experiments ee show automatic model extractor capable extracting useful object behavior large piece software providing useful information characterizes test suite 
protocol checking fourth experiment explore tools help developer gain insight program nd errors program 
purpose applied tool system complete java virtual machine just time compiler developed authors 
compile java class les intel object code 
sources consisting approximately lines code available sourceforge net 
jq method object java method system 
method loaded prepared compiled corresponding jq method object goes sequence states load prepare compile execute 
complexity due dynamic loading linking large number defects attributed erroneous assumptions state jq method 
fact aid debugging explicit state variable introduced jq method class detect state violations run time 
experiment developer software reasonable model system 
rst step experiment dynamic model extractor extract model jq method class automatically 
surprise model included instances load compile transition violation tended api 
ran dynamic model checker input intended api 
tool invocation compile method created violation 
investigation revealed method subclass jq method jq duplicated code jq method prepare 
assertions source catch lack prepare state jq method updates state variable indicating prepare called 
external indication performed prepare operation 
program happens correctly fragile inadvertently calling may trigger incorrect prepare transition 
furthermore functionality prepare changed highly updated accordingly 
static analysis analyze behavior jq method class 
correctly identi ed presence integer state variable state jq method class deduced correct sequence load 
prepare compile execute 
static analysis able identify incorrect transition 
submodels elds identi ed data dependencies methods example execute method dereferences compiled code eld set compile method 
submodel compiled code eld correctly identi es dependency 
example illustrates usefulness independent tool checks behavior program discrepancy intended implemented api may potential source errors software evolves 
case programmer provided speci cation incorrect 
example illustrates usefulness dynamic model checker 

related dynamic model extractor modeler inspired part ernst daikon system extracts invariants programs dynamically 
daikon tries discover invariants relations variables program system uses dynamic techniques discover component interfaces 
daikon applied relatively small programs instrumented code lower overhead applicable large applications 
daikon static checker esc integrated system daikon discover invariants esc tries verify 
dynamic techniques include system instruments data locations tracks changes invariants time goes 
system proven successful nding sources errors dicult corner cases 
nite state machine models model program behavior quite common 
metal system slam toolkit successful applying fsm models statically operating system code 
programming languages vault nil hermes encode machines directly source code 
systems pre contain models represented fsms 
metal system uses simple global fsm model track changes state 
uses metalevel compilation step statically identify locations code model may violated 
models di er metal system model object oriented behavior low level system resources instance fsm models single global fsm model 
slam toolkit checks temporal safety properties general programs 
properties speci ed language called slic uses safety automaton model execution behavior level function calls 
authors works programs behavior governed underlying nite state protocol 
splitting models data ective isolating behaviors 
ammons system speci cation mining attempts extract fsm models program behavior program traces 
system runs processed traces program code shelf probabilistic nfa learner 
system contrast trades generality order leverage object oriented program designs produce focussed speci cations component behavior 
models component behavior similar notion typestates 
typestates type object changes values stored elds change program invokes operations object 
strom yemini developed system called typestate languages nil hermes formal typestate rules enforce static invariants state program di erent program points 
support traditional pointers 
programs checked conformity ow sensitive data ow analysis demand driven backward analysis 
typestates statically verify initialization properties values 
xu uses typestates check safety machine code 
vault type safe variant 
vault requires programmer annotate rewrite code match strict type model 
vault notion path sensitivity state objects consistent point program 
restrictions aliasing 
allows vault strong assertions program behavior programs written roles guarded predicates 
vault system forbids valid programs written style 
systems vault nil hermes complementary system 
able take advantage strong models require programmer write code obey strict model 
technique able obtain weaker models arbitrary large pieces code 
technique similar notions type 
girard introduces notion linear logic says resources 
wadler uses linear logic propose new type system functional languages models changes state 
gi ord lucassen introduced type ect discipline uses type inference techniques track accesses resources 
ideas models objects map closely object oriented design notion roles 
role part object ful lls responsibilities objects 
specifying role models mechanisms role programming 
describe system programmer specify roles objects aliasing relationships objects mechanism statically verify aliasing constraints 

proposes new model component interfaces 
propose nite state machine eld class state method writes eld 
add restrictions states methods read eld may invoked 
proposed implemented techniques automatically extract models 
rst dynamic instrumentation technique records legal method sequences working programs 
second static analysis infers pairs methods called consecutively 
developed dynamic model enforcer ensure model obeyed 
applied tools large software systems automatically extract variety useful data assisting various stages software development 
programmer may run tool learn common uses component 
build model component extracting models implied test suite resulting models may examined evaluate completeness test suite 
component developer may tools determine implemented api matches intended 

ammons bodik larus 
mining speci cations 
proceedings th acm symposium principles programming languages pages 
ball rajamani 
automatically validating temporal safety properties interfaces 
proceedings spin workshop model checking software pages 
bush pincus static analyzer nding dynamic programming errors 
software practice experience spe 
habermann campbell 
speci cation process synchronization path expressions 
lecture notes computer science 
chou chelf engler heinrich 
meta level compilation check flash protocol code 
proceedings ninth international conference architectural support programming languages operating systems pages 
dahm 
byte code engineering library 
sourceforge net 
deline fahndrich 
enforcing high level protocols low level software 
proceedings acm sigplan conference programming language design implementation pages 
engler chelf chou hallem 
checking system rules system speci programmer written compiler extensions 
proceedings symposium operating systems design implementation pages 
ernst cockrell griswold david notkin 
dynamically discovering program invariants support program evolution 
proceedings international conference software engineering icse pages 
ferrante ottenstein warren 
program dependence graph uses optimization 
acm transactions programming languages systems 
girard 
linear logic 
theoretical computer science 
gottlob rock 
extending object oriented systems roles 
acm transactions information systems 
lam 
tracking software bugs automatic anomaly detection 
proceedings international conference software engineering 
van notkin 
templates implement role designs 
technical report tr department computer science engineering university washington 
lam rinard 
role analysis 
proceedings th annual acm symposium principles programming languages pages 
lie chou engler dill 
simple method extracting models protocol code 
proceedings international symposium computer architecture pages 
lucassen gi ord 
polymorphic ect systems 
proceedings fifteenth annual acm symposium principles programming languages pages 
sun microsystems 
java platform enterprise edition 
java sun com ee 
sun microsystems 
application java platform enterprise edition 
java sun com features html 
nimmer ernst 
static veri cation dynamically detected program invariants integrating daikon esc java 
electronic notes theoretical computer science volume 
reiss 
encoding program executions 
proceedings international conference software engineering pages 
strom yellin 
extending typestate checking conditional liveness analysis 
software engineering 
strom yemini 
typestate programming language concept enhancing software reliability 
software engineering 
wadler 
linear types change world 
broy jones editors ifip tc working conference programming concepts methods pages 
whaley 
virtual machine 
sourceforge net projects 


rw de ralf index en html 
xu reps miller 
typestate checking machine code 
proceedings european symposium programming pages 

