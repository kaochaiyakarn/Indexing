consideration publication theory practice logic programming answer sets consistent query answering inconsistent databases marcelo arenas cia universidad de chile departamento de ciencia de santiago chile 
ing puc cl bertossi carleton university school computer science ottawa canada 
bertossi scs carleton ca jan chomicki state university new york bu alo dept computer science engineering bu alo ny usa 
chomicki cse bu alo edu relational database inconsistent satisfy set integrity constraints 
data consistent constraints 
apply logic programming answer sets problem retrieving consistent information possibly inconsistent database 
consistent information persists original database minimal repairs approach speci cation database repairs disjunctive logic programs exceptions answer set semantics represented computed systems implement stable model semantics 
programs allow declare persistence default data original instance repairs changes restore consistency exceptions 
concentrate mainly logic programs binary integrity constraints nd integrity constraints practice 
integrity constraints ic capture important normative aspect database application aim guarantee consistency data 
dicult impossible consistent database instance 
databases may inconsistent respect set integrity constraints 
may happen due factors certain ics expressed maintained existing dbmss 
transient inconsistencies caused inherent non atomicity database transactions 
delayed updates 
integration heterogeneous databases particular duplicated information 
inconsistency respect soft integrity constraints current address university toronto department computer science toronto canada 
cs toronto edu arenas bertossi chomicki transactions violation conditions prevented executing 
legacy data wants impose semantic constraints 
consistency database restored executing transactions 
user constraints checked maintained 
independently cause inconsistency inconsistent database may source data available may want need number reasons 
restoring consistency database may option may require permissions don lead loss useful information complex non deterministic process 
circumstances faces natural problem characterizing retrieving consistent information database 
information database consistent database provide correct answers certain queries making problem determining kinds queries query answers consistent integrity constraints worthwhile ort 
problem de ning retrieving consistent information inconsistent relational database studied context relational databases 
basic approach intuition information consistent despite inconsistency database invariant sensible ways consistency database restored 
precisely answer query consistent obtained answer time query posed minimally repaired version original database arenas :10.1.1.12.3324:10.1.1.12.3324
example assume database instance salary salary name amount smith smith jones stone fd functional dependency name amount meaning name functionally determines amount violated table salary tuples participating violation value smith attribute name 
ask tuples consistent wrt fd retrieve jones stone tuples stay reasonable way restore consistency 
want consider repaired versions original instance minimally di er original instance sense set inserted deleted tuples restore inconsistency minimal set inclusion possible repairs inconsistent database salary name amount salary name amount smith smith jones jones stone stone answer sets consistent query answers see tuples jones stone repairs 
address problem retrieving consistent information general rst order queries posed inconsistent relational database 
consistent information database persists repairs solve problem logic programs answer sets semantics specify compact manner class repairs inconsistent instance 
consistent answers de ned terms minimally repaired version database interested restoring consistency particular computing repairs database repairs auxiliary notion order give model theoretic characterization consistent answers queries 
easy nd situations exponentially repairs inconsistent database exist arenas :10.1.1.125.8854
possible computational mechanism retrieving consistent answers rst introduced arenas follows rst order query inconsistent database instance explicitly computing repairs querying new query computed posed available database :10.1.1.12.3324
answers new query expected consistent answers iterative operator query transformation introduced analyzed respect soundness completeness termination arenas bertossi :10.1.1.12.3324
query rewriting approach limitations 
iterative operator introduced arenas bertossi works particular classes queries constraints queries conjunctions literals universal integrity constraints completeness lost applied disjunctive existential queries :10.1.1.12.3324
methodology obtaining consistent answers applied rst order query 
furthermore notion consistent answer introduced arenas model theoretic notion complemented computational mechanism :10.1.1.12.3324
approach accompanied logical speci cation class repairs database instance relative xed set ics 
speci cation contribution speci cation expressed disjunctive logic program answer set semantics 
database repairs correspond intended models answer sets program 
motivated mainly possibility retrieving consistent answers general rst order queries extending possibilities developed arenas :10.1.1.12.3324:10.1.1.12.3324
logical speci cation reason database repairs particular consistent query answers 
derive specialized algorithms consistent query answering 
analyze complexity issues related consistent query answering 
obtain intended models speci cation database repairs allowing analyze di erent ways restore consistency database 
mechanism computing database repairs con ict resolution 
arenas bertossi chomicki notice consistent answers non monotonic sense adding information original database may cause loosing previous consistent answers 
consequence non monotonic semantics speci cation consequences expected 
preliminary version appeared arenas extended disjunctive logic programs exceptions introduced applied speci cation database repairs retrieve consistent answers general rst order queries :10.1.1.125.8854:10.1.1.125.8854:10.1.1.125.8854
extends arenas addressing new issues nd detailed analysis correspondence answer sets database repairs binary integrity constraints :10.1.1.125.8854:10.1.1.125.8854
application dlv system eiter obtain database repairs consistent answers 
extensions methodology general universal constraints referential integrity constraints 
analysis applicability disjunctive founded semantics consistent query answering 
weak constraints capture database repairs minimal number changes 
structured follows 
section introduce notions database repair consistent answer query query language 
section introduces extended disjunctive logic programs exceptions 
section main section repair programs binary integrity constraints show consistently evaluate queries 
section show examples dlv system obtain database repairs consistent answers 
section illustrate handle referential integrity constraints 
section analyze founded interpretation approximation set consistent answers identify cases provides exact solution 
section show database repairs minimal number changes speci ed introducing weak constraints repair programs 
section draw sketch extensions case general universal ics mention open issues discuss related 
consistent query answers database schema represented typed language rst order predicate logic contains nite set predicates xed nite set constants relational database instance seen interpretation rst order structure domain interpretation constant constant predicates nite extensions 
follows database instance represented natural way nite set ground atoms atoms true 
active domain database instance set elements explicitly appear active domain nite denote act 
may set built evaluable predicates equality order relations arithmetical relations case language possibly extended predicates 
database instances schema predicates xed possibly nite extension 
de ned answer sets consistent query answers database instances nite sets ground atoms considering built atoms members database instances 
addition database schema instances may set integrity constraints ic expressed language rst order formulas database instances expected satisfy 
database instance satis es ic standard model theoretic sense denoted ic say consistent wrt ic say inconsistent 
case assume ic logically consistent set rst order sentences 
original motivation arenas consistently answer rstorder queries :10.1.1.12.3324
call basic queries de ne grammar atom way explicitly asking object level consistent answers rst order query consists introducing new logical operator way basic query asks values consistent answers consistently true true repairs sentence 
queries similarly de ned kb concentrate answering basic queries form kb basic query 
de nition arenas database instance set integrity constraints ic repair wrt ic database instance schema satis es ic :10.1.1.12.3324
symmetric di erence minimal set inclusion 
arenas tuple consistent answer rst order query equivalently answer query kq database instance answer query repair wrt ic symbols kq repair general query de ned inductively usual base case :10.1.1.12.3324
example example continued inconsistent database fd jones consistent answer query salary salary jones salary smith 
holds salary smith salary smith salary smith 
computing consistent answer generation possible repairs natural feasible alternative arenas :10.1.1.125.8854
approach querying available inconsistent database natural 
rewriting approach introduced arenas complete arenas bertossi chomicki disjunctive existential queries salary smith example :10.1.1.12.3324
able obtain consistent answers basic queries 
notice de nition consistent query answer depends de nition repair 
section consider alternative de nition repair minimal number changes minimal set changes 
logic programs exceptions logic programs exceptions kowalski sadri default rules consequences overridden consequences exception rules 
turn right formalism specifying database repairs default persists original database instance repairs changes necessary restore consistency 
introduced kowalski sadri consist de nite clauses head body contain literals form atom classical negation 
bodies literals may ected weak negation negation failure 
lpe default rules clauses positive heads exception rules clauses negative heads 
capture intuition exceptions priority defaults kowalski sadri new semantics introduced answer sets 
de ned follows 
instantiate program database domain making ground 
set ground literals fl candidate model guess veri ed accepted properly justi ed 
generate new set ground rules steps delete rule containing body 
delete clauses condition body 
delete default rule having positive result ground extended logic program answer set original program smallest set ground literals clause 
lm 
lm 
contains complementary literals set literals 
answer sets intended models original program 
answer sets semantics extended logic programs gelfond lifschitz gives account exceptions 
order specify database repairs need extend semantics kowalski sadri considering disjunctive logic programs exceptions contain negative defaults 
defaults negative overridden positive exceptions extended disjunctive exceptions rules form 
lm literals 
answer semantics extended follows 
ground program pruned modi ed rule application scenario need disjunctive exceptions rules disjunctive defaults 
answer sets consistent query answers 
delete positive default having positive negative default having negative applying 
ground program left ground disjunctive logic program candidate set literals belongs set minimal models program say answer set 
semantics capture priorities defaults principle con icting defaults 
case semantics allow defaults override defaults preferences 
example program containing defaults exception rules answer sets fpg pg 
case applications logic programs exceptions due kind defaults see de nition situation appear potentially con icting defaults apply mutually exclusive cases 
take advantage existence correspondence answer sets answer sets extended disjunctive logic program gelfond lifschitz see section 
logic programs specifying database repairs answering basic queries 
set ics inconsistent database instance rst step consists writing repair program having answer sets repairs original database instance 
captures fact database instance repaired data persists tuples 
consequence default rules introduced persists instance repairs 
necessary introduce exception rules persists stated defaults ics violated satis ed 
rst order query posed intention retrieving consistent answers query program expresses query run repair program 
section introduce specifying database repairs give careful analysis programs consistent query answering wrt binary integrity constraints universally quanti ed sentences form denotes universal closure literals associated database schema rst order formula containing built predicates free variables appearing possibilities terms sign literals universal closures built predicates xed extension database particular repair subject changes 
arenas bertossi chomicki database atoms 
database literal plus possibly formula containing built ins called unary ics 
interesting classes ics abiteboul database praxis represented range constraints full inclusion dependencies functional dependencies see example referential ics zq need existential quanti ers skolem functions fitting 
considered section 
finite domain databases section momentarily depart assumption databases nite domain see section analyze case nite domain databases 
reason general case interested domain independent active domain relevant nite 
change program order introduce repair programs analyze behavior concentrate rst sub program contain defaults rules 
program denoted 
responsible changes persistence 
splitting program way analysis easier 
furthermore keeping 
di erent form defaults capture di erent kinds repairs 
section introduce defaults leading notion repair minimal set changes de nition 
section defaults lead repairs minimal number changes 
de nition set ic instance change program 
contains rules 
facts ground database atom fact 
fact dom 

ic forms respectively triggering rule dom dom 
ic rst form pair stabilizing rules dom dom ic second form pair stabilizing rules dom dom answer sets consistent query answers ic third form pair stabilizing rules dom dom primed versions original database predicates stand database predicates repairs 
rules dom abbreviation conjunction memberships dom individual variables abbreviation representation negation 
depending syntax may necessary unfold formula additional program rules usually conjunction literals 
example consider inclusion dependencies ic xy xy inconsistent database instance fp program 
contains clauses 
facts 

triggering exceptions rules represent possible ways repair corresponding ic separately rst rule says order locally repair rst ic eliminate insert semantics gives disjunction exclusive interpretation 
example due form ics need domain predicates 

stabilizing exceptions rules state eventually ics satis ed repairs 
necessary example interacting ics local repairs sucient 
propagation changes required rst triggering step 
ics repaired deleting inserting tuple contrapositive versions ics needed 
notice stabilizing rules 
contain disjunctions heads 
de nition model set ground literals contain complementary literals satis es usual logical sense weak negation interpreted element de nition model 
de ne database instance corresponding fp sg fp notice model change program merges new instance positive primed tuples old non primed tuples persisted negative primed version belong model 
persistence defaults 
persistence captured explicitly 
arenas bertossi chomicki proposition database instance set ic model 
satis es ic de nition database instances schema domain de ne fp fp dg collects maximal consistent set literals obtained database instances original instance repair 
atoms corresponding second argument primed 
negative literals corresponding rst argument considered weak negation applied 
proposition database instance set ic satis es ic model 

result tells subsets potential models change program 
large model sense di erence may minimal 
proposition change program 
answer set answer sets consistent contain complementary literals 
repair program program 
gives account changes 
fact repairs contain data persists original instance captured persistence defaults 
de nition repair program consists rules program 
de nition plus rules predicate original database 
persistence defaults dom 
example example continued persistence defaults 
dom dom dom means default put repair 

defaults 
consequence talk answer sets gelfond lifschitz answer sets kowalski sadri 
answer sets consistent query answers program rules 

priority rule 
possible verify answer sets program expected database repairs fp underlined literals represent insertion repair deletion resp 
original atoms remain rules change 
literals shown explicitly answer sets negative literals inherited original instance negative defaults 
shown kowalski sadri program answer semantics transformed disjunctive extended logic program answer set semantics transforming persistence defaults de nition respectively 
persistence rules dom shown gelfond lifschitz resulting program transformed disjunctive normal program stable model semantics 
correspondence answer sets stable models interchangeably talk answer sets stable models 
proposition database instance nite domain set ic sm answer set 
sm fp sm sm sm sm answer set 
lemma says build answer set literals taken satis es ics close possible recover 
condition contained sure literals taken right maximal set literals 
lemma database instances schema domain ic set 
assume ic symmetric di erence 
minimal element set inclusion set 
icg 
answer set 
contained holds 
theorem program 
plus rules nite domain database instance set ic holds 
repair wrt ic exists answer set fp sg 

answer set exists repair wrt ic fp sg 
arenas bertossi chomicki case nite domain databases domain declared 
situation handle set binary ics caring safeness domain independence ullman 
example consider fa cg ic xp inconsistent instance fp contains default rules dom triggering exception dom stabilizing exception dom facts dom dom dom 
answer set dom dom corresponds repair fp ic requires element nite domain belongs table achieved 
nite domain obtain nite program instance table containing nitely tuples 
nite domain databases consider ics domain independent checking satisfaction instance done considering elements nite active domain act ullman 
ic example domain independent 
domain independent previous lemmas theorems hold nite domain obtain need predicate act standing active domain act instance predicate dom 
domain independent database domain considered act 
furthermore case omit dom facts goals 
consequence theorem 
theorem set domain independent binary integrity constraints database instance correspondence answers sets repair program repairs evaluating basic queries speci cation database repairs obtained provides underpinning general method evaluating basic query form basic query 
expressed terms database predicates obtain strati ed logic program standard construction lloyd abiteboul terms new primed predicates introduced 
predicate symbols answer designated query answer predicate 
second determine answers sets logic program 
third compute intersection answer answer extension answer set tuples set answers equivalently set consistent answers answer sets consistent query answers example example continued consider query consistent answers database instance 
query transformed query program containing rules answer answer 
order obtain consistent answers necessary evaluate query goal answer wrt program obtained combining obtained examples program 
answer sets combined program contain set ground answer atoms 
arguments answer atoms simultaneously answer sets consistent answers original query 
second example consider query xq 
order obtain consistent answers keep run combination new query program answer 
notice consistent answers query obtained repair program plus query program cautious skeptical answer set semantics combined logic program true program true answer sets 
section give computational examples 
program rst order query naturally split split precise sense introduced lifschitz turner follows set literals consisting primed database literals plus non primed database literals appearing form splitting set literal appears head rule literals body rule appear splits precisely expected parts literals appear heads rules literals act extensional literals 
consequence splitting know lifschitz turner answer set represented union answer set answer set answer set acts extensional database computation answer sets 
program strati ed answer set answer set 
computational examples section assume repair programs extended disjunctive logic programs answer set semantics 
consequence implementation semantics 
particular give examples application dlv system eiter computation database repairs consistent query answers 
arenas bertossi chomicki computing database repairs dlv example consider schema emp name ssn functional dependencies name ssn ssn name stating person just ssn di erent persons di erent ssns 
inconsistent instance emp name ssn irwin koper irwin koper mike dlv program corresponds repair program 
repaired primed version table emp denoted emp domains database dom name irwin koper 
dom name mike 
dom number 
dom number 
dom number 
initial database emp irwin koper 
emp irwin koper 
emp mike 
default rules emp emp emp 
emp dom name dom number emp emp 
triggering rules emp emp emp emp emp emp emp emp stabilizing rules 
emp emp dom number emp emp dom name dlv asked compute answer sets obtain corresponding possible repairs emp name ssn irwin koper mike emp name ssn irwin koper mike order pose query emp asking consistent tuples table employee add new query rule program answer emp 
answer sets contain answer literals answer sets consistent query answers answer irwin koper answer mike answer irwin koper answer mike ground answer atom intersection answer sets new program 
consistent answer tuple mike 
referential integrity constraints section show extend speci cations repairs binary integrity constraints referential integrity constraints rics 
done appropriate representation existential quanti ers program rules 
consider ric inconsistent database instance fp assume underlying database domain repair program persistence default rules dom dom addition triggering exception rule null aux aux null stabilizing exception rules null aux null aux aux 
variables program range take value null reason rst literal clause 
literal clause necessary insert null value needed clause relies fact variables range 
instantiating variables answer sets expected ones delete insert null 
natural include functional dependency expressing primary key foreign key done problems constraints interact repairing cause violations 
elimination tuples considered admissible changes null values triggering exception changed aux 
simple way enforce object level introduce predicate clauses force variables take values excluding null value 
arenas bertossi chomicki referential ics strong constraints possible dlv impose preferences repairs appropriate representation constraints 
rics example preference null values cascade policy captured 
example example continued consider schema fds instance emp name ssn irwin koper irwin koper mike dlv repair program example facts dom number 
dom number 
emp irwin koper 
emp irwin koper 
emp mike 
dlv run program input obtain answer sets emp irwin koper emp irwin koper emp mike emp mike emp irwin koper emp irwin koper emp mike emp mike corresponding database repairs emp name ssn irwin koper mike emp name ssn irwin koper adding query rule answer emp ask persons ssn 
answer sets obtained answer irwin koper answer mike answer irwin koper consistently say irwin koper ssn 
extend schema unary table person name contents original contents table emp person name irwin koper mike answer sets consistent query answers want person ssn may impose ric person stating person ssn saw repair section introducing null values cascading deletions 
may want options want null values key ssn want delete employees case person 
alternative dlv possibility specifying strong constraints ect pruning answer sets satisfy 
done dlv introducing denial dom name ssn ssn emp 
answer sets original program satisfy ics ltered repair obtained emp irwin koper emp irwin koper emp mike emp mike ssn irwin koper ssn mike answer irwin koper answer mike person ssn ssa predicate 
expected answers original query irwin koper mike 
notice strong constraints di er database integrity constraints generation repairs nal step repairs discarded 
furthermore strong constraints constraints answer sets directly semantics database 
founded consistent answers intersection answer sets extended disjunctive logic program contains founded interpretation programs leone computed polynomial time size ground program 
interpretation may partial necessarily model program 
total interpretation answer set 
leone shown compute answer sets program starting founded interpretation 
dlv basically starting founded interpretation starts eciently computable set deterministic consequences program contained intersection answer sets turn contains founded interpretation 
dlv explicitly asked return set deterministic consequences program approximation intersection answer sets 
side general case computing stable model semantics disjunctive programs complete size ground program founded interpretation hw program sets true positive true negative unknown literals resp xpoint operator maps means option det see review complexity results logic programming 
arenas bertossi chomicki interpretations interpretations leone 
precisely assuming ground instantiation repair program de ned interpretations sets ground literals pairs complementary literals gus 
intuitively immediate consequence operator declares literal true ground rule containing head body true literals disjunctive head false gus denotes set complements literals gus largest set unfounded literals de nitely derived program set assumptions consequence complements declared true 
intersection answer sets core fs answer set interpretation subset core approximation core computed eciently database repairs intersection general case 
possible identify classes ics coincides core 
proposition database instance set ics containing functional dependencies unary ics core program coincides set true ground literals founded interpretation program 
results previous established repair programs introduced section nite database domains results known hold nite domain databases domain independent integrity constraints ones proposition 
corollary proposition obtain fds unary constraints core computed polynomial time size ground instantiation result rst established arenas fds :10.1.1.125.8854:10.1.1.125.8854
core consistently answer non existential conjunctive queries 
furthermore arenas case functional dependencies conditions queries identi ed take advantage computations core answer aggregate queries eciently :10.1.1.125.8854:10.1.1.125.8854
example shows core repair program may coincide founded interpretation 
example consider ic fq rg empty database instance 
program contains triggering rules stabilizing rules persistence rules answer sets consistent query answers answer sets fq core fs 
results obtained far section apply repair program 
add arbitrary query program possible new core properly extends founded interpretation extended program fds 
example consider fp fd query 
combined program dom dom dom answer dom dom dom answer sets founded interpretation hw fp dom fp answer particular answer core answer know complexity results arenas functional dependencies np consistent answers rst order queries computed polynomial time :10.1.1.125.8854:10.1.1.125.8854
consequence expect compute core program includes query program means wellfounded interpretation 
alternative semantics discussed arenas database repairs obtained revision models corresponding possible model approach introduced winslett chou winslett context belief update :10.1.1.12.3324
database instance model updated set ics new set models generated database repairs 
winslett revision models repairs minimal set changes wrt original model 
cardinality repairs weak constraints dalal context belief revision update alternative notion revision model minimal number changes introduced 
de nition database instance instance dalal repair wrt ic ic 
minimal element fj 
icg 
arenas bertossi chomicki give de nition dalal consistent answer exactly terms de nition replacing repair dalal repair 
specify dalal repairs repair programs section persistence defaults replaced weak constraints 
imposed original database answer sets change program 
responsible changes introduced section 
weak constraints form ln literals 
constraints added extended disjunctive program ect answer sets minimize number violated ground instantiations weak constraints kept 
order capture dalal repairs need simple weak constraint 
program speci es dalal repairs database instance wrt set consists program 
section rules 

plus 
database predicate weak constraints constraints say original database repair expected coincide 
weak constraints allow violations minimum number tuples belong repair original instance way accepted 
results change program 
hold 
consequence program answers sets correspond repairs minimal set inclusion number changes answer sets corresponding dalal repairs 
example fag fp ic contains facts dom triggering exceptions stabilizing exceptions weak constraints 
weak constraints implemented dlv run program returns answer set corresponding empty database repair winslett repair set changes speci ed conj conj conjunction possibly negated literals 
see dlv user manual www dbai tuwien ac proj dlv man answer sets consistent query answers wrt elements rst repair di ers change 
notice example change program 
weak constraints obtain eventually discarded answer set implicitly contains 
reason persistence rules cause persist database 
consequence interpret answer sets establish correspondence repairs 
done theorem interpretation de nition 
consequence nite domain databases theorem nite domain database instance set ic 
dalal repair wrt ic exists answer set 
answer set exists dalal repair wrt ic winslett repairs theorem holds nite domain databases domain independent 
interpreting answer sets due implicit presence primed literals caused lack persistence defaults pose queries expecting consistent answers may interpret original query transformation shown table original query query program query query query query dom original query replace query query resp add rules right hand side table 
alternative avoid interpreting answer sets queries explicitly obtain dalal repairs imposing weak constraints repair program contains default rules 
general methodology consistently answer rst order queries posed relational databases violate ics 
restricted mainly case binary integrity contraints universal ics containing database literals 
methodology extended universal ics larger number database literals 
facts persistence triggering exceptions rules number stabilizing rules grows number subsets database literals ic 
sketch solution means example 
arenas bertossi chomicki example consider fp ternary integrity constraints ic repair program contains usual persistence defaults triggering exception rules rst ic ic need stabilizing rules rst ic rst ic case obtain answer set repair empty instance represented fp rules stabilizing rules disjunctive stabilizing rules empty repair obtained 
extending current methodology relational databases view de nitions straightforward 
ongoing open issues deserve investigation analyze conditions simpler optimized programs obtained 
detailed treatment referential ics existential ics 
identi cation classes ics founded interpretation intersection database repairs coincide 
representation preferences certain kinds repair actions 
principle preferences captured choosing right disjuncts triggering rules 
approach speci cation repairs completely restores consistency database independently query posed fact violated ics 
approach repairs stored di erent queries posed 
useful specify compute repairs partially restore consistency database wrt ics relevant query 
possibly appropriate grounding techniques case 
repair programs materialize closed world assumption explicitly producing negative primed literals 
due persistence answer sets consistent query answers default rules 
practical applications avoided restoring program implicit closed world assumption applied repairs 
addressed problem obtaining query answers general queries 
method basic queries needs combined method evaluating rst order queries 
example safe range rst order queries abiteboul translated relational algebra 
approach queries subqueries form replaced new relation symbols 
resulting relational algebra query evaluated need arises materialize new relations method accomplish goal 
interesting open issues related computational implementation methodology 
existing implementations stable models semantics grounding rules database applications may lead huge ground programs 
intelligent grounding techniques implemented dlv 
furthermore implementations geared computing stable models possibly consistent query answering requires implicitly having stable models relevant parts 
particular opens interesting issue having construction relevant parts stable models guided query query answering primary goal computation repairs 
current query evaluation methodologies stable model semantics specially disjunctive programs completely insensitive query hand 
goal avoid irrelevant computations 
database applications posing answering open queries variables natural common answering ground queries 
existing implementations stable model semantics better designed 
useful implement consistent query answering system interaction repairs logic programs relational dbms 
purpose functionalities front ends included dlv architecture eiter 
trying push computation dbms right way proceed 
related inconsistency handling done long time di erent communities philosophical non classical logic knowledge representation logic programming databases software speci cation mention related may relation notions repair consistent answer form logic programming 
similarities approach consistency handling followed belief revision update community 
mentioned section database repairs coincide revised models de ned winslett 
treatment mainly propositional preliminary extension rst order knowledge bases chou winslett 
papers concentrate computation models revised theory arenas bertossi chomicki repairs case query answering 
revision database instance ics produces new database instances repairs original database 
motivation starting point quite di erent belief revision 
interested computing repairs se answering queries hopefully original database possible 
possible look methodologies logic programming approach representing querying simultaneously implicitly repairs database 
bry bry knowledge rst author consider notion consistent query answer inconsistent databases 
de ned consistent query answers provability minimal logic 
proposed inference method nonmonotonic fails capture minimal change bry notion consistent query answer weaker 
bry approach entirely provide computational mechanism obtain consistent answers rst order queries 
papers studied problem making inferences possibly inconsistent propositional rst order knowledge base 
basic idea infer classical consequences maximal consistent subsets knowledge base baral consistent models knowledge base kifer avron order models de ned base atom annotations drawing values lattice bi lattice 
provides non monotonic consequence relation special role integrity constraints truth captured 
issue processing general rst order queries considered 
brie review speci cation logic programming approaches consistency handling databases 
direction closest approach independently greco see greco greco 
disjunctive programs specify minimal sets changes set inclusion lead database repairs sense arenas :10.1.1.12.3324:10.1.1.12.3324
authors compact schema generating repair programs general universal integrity constraints 
application schema leads programs involve essentially possible disjunctions database literals heads programs example 
concentrate mainly producing set changes repaired databases explicitly 
particular persistence rules program 
consequence program directly obtain consistent answers 
interpretation results possibly introduced section necessary 
introduce repair constraints specify preferences certain kinds repairs 
annotated predicate logic introduced kifer applied arenas task computing consistent query answers speci cation database repairs :10.1.1.125.8854:10.1.1.125.8854:10.1.1.125.8854
speci cation derive algorithms consistently answering restricted forms rst order queries obtain complexity results 
expected database repairs correspond certain minimal models speci cation 
approach non answer sets consistent query answers classical logic computing consistent answers straightforward 
speci cation methodology extended universal ics referential ics bertossi :10.1.1.13.1032
proposals language constructs extending strati ed datalog programs purpose specifying nondeterministic queries 
essentially idea construct maximal subset relation satis es set functional dependencies 
usually subset approach yields nondeterministic queries natural way 
clearly maximal consistent subsets choice models correspond repairs case functional dependencies 
strati ed datalog choice combines enforcing functional dependencies inference strati ed datalog programs 
answering queries choice models queries greco corresponds notion computation consistent query answers rst order queries 
revision programs marek truszczynski logic programs updating databases restore consistency compute database repairs 
rules programs allow explicitly declaring enforce satisfaction integrity constraint explicitly stating ics intended procedural meaning inserting database atom database give declarative stable model semantics revision programs 
preferences certain kinds repair actions captured declaring corresponding rules program omitting rules lead forms repairs 
revision programs programs greco obtain consistent answers directly give account changes 
blair subrahmanian blair subrahmanian introduced paraconsistent logic programs 
non classical semantics inspired paraconsistent rst order semantics 
kifer subrahmanian general annotated logic programs 
lattice semantics non classical 
atoms clauses annotations kifer annotations may contain variables functions providing stronger representation formalism 
implementation annotated logic programs query answering mechanisms discussed leach lu 
subrahmanian annotated programs generalized order amalgamating databases resolving potential con icts integrated data 
purpose product lattices underlying database constructed semantic basis integrated database 
con ict resolutions preferences captured means function annotations 
approaches paraconsistent logic programming discussed damasio pereira 
bertossi bertossi starting lattice speci cation introduced arenas logic programs containing annotations arguments opposed annotated programs contain annotated atoms specify database repairs compute consistent answers queries :10.1.1.125.8854:10.1.1.125.8854:10.1.1.125.8854:10.1.1.13.1032
approach works general universal ics referential ics 
arenas bertossi chomicki logic programs stable model semantics 
cost annotations extra arguments program balanced fact program contains linear number rules case number literals ic grows see example 
consequence ics non binary approach bertossi convenient :10.1.1.13.1032
acknowledgments supported nsf int nsf iis carleton university start nserc 
bertossi holds faculty fellowship center advanced studies ibm toronto lab 
grateful francisco orchard informative presentations discussions experiments dlv 
grateful nicola leone kindly answering questions dlv 
appreciate comments received anonymous reviewers helped substantially improve presentation 
abiteboul hull vianu foundations databases 
addison wesley 
arenas bertossi chomicki consistent query answers inconsistent databases 
proc 
acm symposium principles database systems acm pods philadelphia acm press pp 

arenas bertossi chomicki specifying querying database repairs logic programs exceptions 
flexible query answering systems 
developments larsen zadrozny christiansen eds springer pp 

arenas bertossi chomicki scalar aggregation fd inconsistent databases 
database theory icdt proc 
international conference database theory icdt springer lecture notes computer science pp 

arenas bertossi kifer applications annotated predicate calculus querying inconsistent databases 
computational logic cl 
stream th international conference rules objects databases dood springer lecture notes arti cial intelligence pp 

avron model theoretic approach recovering consistent data inconsistent knowledge bases 
journal automated reasoning 
baral minker kraus combining multiple knowledge bases 
ieee transactions knowledge data engineering 
bertossi repairing databases annotated predicate logic 
proc 
ninth international workshop non monotonic reasoning nmr 
special session changing integrating information theory practice 
benferhat giunchiglia eds morgan kaufmann publishers pp 

bertossi logic programs querying inconsistent databases 
proc 
fifth international symposium practical aspects declarative languages padl 
springer lecture notes computer science pp 

blair subrahmanian paraconsistent logic programming 
theoretical computer science 
bry query answering information systems integrity constraints 
proc 
answer sets consistent query answers ifip tc working conference integrity internal control information systems 
chapman hall pp 

leone enhancing disjunctive datalog constraints 
ieee transactions knowledge data engineering 
faber leone pfeifer pruning operators answer set programming systems 
proc 
ninth international workshop non monotonic reasoning nmr 
benferhat giunchiglia eds morgan kaufmann publishers pp 

bertossi querying inconsistent databases algorithms implementation 
computational logic cl 
stream th international conference rules objects databases dood pp 

springer lecture notes arti cial intelligence 
chou winslett model belief revision system 
journal automated reasoning 
dalal investigations theory knowledge base revision preliminary report 
proc 
seventh national conference arti cial intelligence aaai pp 

damasio pereira survey paraconsistent semantics extended logic programs 
handbook defeasible reasoning uncertainty management systems vol 
gabbay ph 
smets eds kluwer academic publishers pp 

eiter gottlob voronkov complexity expressive power logic programming 
acm computing surveys 
eiter leone pfeifer scarcello knowledge representation system dlv progress report comparisons benchmarks 
proceedings international conference principles knowledge representation reasoning kr trento italy june 
morgan kaufman 
eiter faber leone pfeifer declarative problem solving dlv 
logic arti cial intelligence minker ed kluwer pp 

fitting order logic automated theorem proving 
texts monographs computer science 
springer verlag nd ed 
gelfond lifschitz stable model semantics logic programming 
logic programming proceedings fifth international conference symposium kowalski bowen eds mit press pp 

gelfond lifschitz classical negation logic programs disjunctive databases 
new generation computing 
greco zaniolo programming non determinism deductive databases 
annals mathematics arti cial intelligence 
greco zaniolo datalog queries strati ed negation choice proc 
international conference database theory springer verlag pp 

greco querying inconsistent databases 
proc 
th international conference logic programming automated reasoning lpar springer lncs pp 

greco computing repairs inconsistent databases 
proc 
third international symposium cooperative database systems advanced applications beijing april 
greco greco logic programming approach integration repairing querying inconsistent databases 
proc 
th international arenas bertossi chomicki conference logic programming iclp ph 
ed lncs springer pp 

kowalski sadri logic programs exceptions 
new generation computing 
kifer logic reasoning inconsistency 
journal automated reasoning 
kifer subrahmanian theory generalized annotated logic programming applications 
journal logic programming 
leach lu query processing annotated logic programming theory implementation 
journal intelligent information systems 
leone scarcello disjunctive stable models unfounded sets fixpoint semantics computation 
information computation 
lifschitz turner splitting logic program 
proceedings eleventh international conference logic programming pascal van hentenryck ed mit press pp 

lloyd foundations logic programming 
springer verlag 
resolving contradictions plausible semantics inconsistent systems 
journal automated reasoning 
marek truszczynski revision programming 
theoretical computer science 
subrahmanian amalgamating knowledge bases 
acm transactions database systems 
ullman principles database knowledge base systems vol 
computer science press 
winslett reasoning action possible model approach 
proc 
seventh national conference arti cial intelligence aaai pp 

appendix proofs proof proposition consider arbitrary element ic assume element form proof analogous binary constraints containing positive literals negative literals 
prove satis es instantiation formula say 
consider cases 
satisfy ground constraint satis es body ground triggering rule dom 
case 
ii satis es ground constraint satis es 
rst case 
assume 
contradiction assume 
de nition 
case satis es body ground stabilizing rule dom 
conclude contradiction 
de nition answer sets consistent query answers 
case satis es body ground stabilizing rule dom 
conclude contradiction 
proof proposition order prove satis es 
need consider di erent types ground stabilizing rules satisfaction rules follows fact satis es ic 
satis es body rule dom satisfy dom 
ic 

analogously possible prove satis es remaining types ground stabilizing rules 
proof proposition previous proposition know change program models consistent program 
program consistent non trivial answer set consistent lifschitz turner 
show obtain consistent answer sets 
program split subprograms lifschitz turner 
rst contains domain database facts plus rules 
second containing stabilizing rules triggering rules modi ed replacing literals form bodies rst program strati ed consistent answer set 
second subprogram contain weak negation positive program sense minimal models coincide answer sets 
result lifschitz turner original program answer sets unions answer sets rst program answer sets second atoms treated extensional database predicates computation answer sets second subprogram 
proof proposition set added sm easy verify sm 

sm answer set 
order prove answer set suces prove ii 

element sm sm rules 

sm sm dom reduced ground persistence rule 

ii possible deduce element stabilizing rules 
assume dom rule 
dom rule 
need show arenas bertossi chomicki contradiction suppose sm sm sm de nition sm sm satis es body rule dom 
implies sm contradiction sm contradiction 
sm rule dom conclude sm contradiction 
analogously possible prove property type stabilizing rule 
proof lemma answer set 
subset 
prove 



cases holds 

case de nition conclude 
implies 


ii 
case minimal model need 
de nition conclude 
implies 





proposition satis es ic 
equal 

minimal set inclusion 
icg 
conclude proof theorem prove rst part theorem 
second proved analogously 
repair lemma sm sm answer set 
sm 
de ne sm proposition 
answer set 
construction sm 
furthermore fp sg 
proof proposition case core leone need show core consequence necessary check literal belongs core tuple elements domain database predicate fetched nite integer literal original database primed version answer set complement proof cases positive literals appear invoking cwa 
literals original instance belong core 
answer sets consistent query answers considering literal contained core possible transitions original instance core negative positive core positive positive 
negative negative 
positive negative 
prove rst cases similar 
case cases veri ed di erent ground program rules get core 
assume core prove fds produce deletions true due unary constraint false icd false false icd instantiation ics domain ground program nd rule dom 
second subgoal true 
dom obtain 
assume core means persisted original instance answer set 

icd false 
ground program rule dom 
body true dom gets wfs rst step case 

ground constraint item icd true 
case applicable rule form dom ground program 
rules associated fds delete tuples obtained default rule dom ground program 
operator declares unfounded belong concentrate 
get rules form dom obtained unary ics 
case core possible core 
obtained default rule dom second subgoal false 
obtained possible belongs answer sets 
left rules associated fds 
assume icd associated triggering rule applied 
ii principle triggering rule applied belongs answer sets forced arenas bertossi chomicki unary ics case false repairs get 
reason icd false force true corresponding triggering rule turn force true answer set due fd 
possible core 
consequence rule applied 
analyze stabilizing rule associated 
rule apply 
ii 
furthermore obtained default dom false 
saw obtained rule dom 
consequence unfounded stabilizing rule turns unfounded 
remaining cases prove core core 
possible show core 

