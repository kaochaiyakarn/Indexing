syntactic type abstraction dan grossman greg morrisett steve zdancewic cornell university software developers structure programs way different pieces code constitute distinct principals 
types help define protocol principals interact 
particular types allow principal strong assumptions typed clients facilities provides 
show notions principals type abstraction formalized language 
different principals know implementation different types 
additional syntax track flow values types evaluation program demonstrate framework supports syntactic proofs style subject reduction type abstraction properties 
properties traditionally required semantic arguments syntax avoids need build model language 
various typed lambda calculi principals including versions mutable state recursive types 
categories subject descriptors software engineering software architectures information hiding languages programming languages formal definitions theory syntax semantics programming languages language constructs features data types logics meanings programs semantics programming languages operational semantics logics meanings programs studies program constructs type structure general terms languages security theory verification additional key words phrases operational semantics parametricity proof techniques syntactic proofs type abstraction 
programmers notion principal designing structure program 
examples principals include modules large system host clients separate functions 
dividing code agents useful composing programs 
increasing extensible systems web browsers databases operating systems notion principal critical reasoning untrusted clients interact host provided code 
incorporate idea principal various typed lambda calculi 
doing allows formulate security policies check type material supported part afosr arpa radc national science foundation graduate fellowships 
opinions findings recommendations expressed publication authors reflect views agencies 
authors address department computer science upson hall cornell university ithaca ny email cs cornell edu 
permission digital hard copy part material fee personal classroom provided copies distributed profit commercial advantage acm copyright server notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
acm acm transactions programming languages systems vol 
november pages 
dan grossman 
file handle implemented int abstype fh open string fh read fh char fig 

interface file handles 
system enforces 
example useful policy clients gain access file handle open procedure consider host provided interface type file handles fh includes operations create 
principals scenario host implementation interface clients 
principal view world corresponds knowledge regarding fh 
particular host knows fh int clients 
conventional wisdom data types type safe language prevents clients directly accessing host data 
client may manipulate data host provided interface 
formalize wisdom necessary prove theorems say client code violate type abstractions provided host instance client able treat object type fh integer host implements way 
prove properties 
way phrasing result say client behaves parametrically respect type fh 
observation encode agent program language girard system girard polymorphic lambda calculus reynolds 
type fh held encoding client polymorphic function fh host open string fh read fh char client code appeal reynolds parametricity results reynolds conclude client respects host interface 
unfortunately representation independence results proven semantic arguments model language see mitchell example 
unaware similar results languages including multiple features modern languages recursive types objects threads control operators 
calculus circumvents problem syntactically distinguishing agents different type information 
coloring host code client code differently track colors evaluation 
different semantics principal force client respect types provided host 
separation principals provides hooks enable prove type abstraction properties syntactically 
see new mechanisms useful consider evaluation client code linked host implementation 
shows standard encoding linking application 
step standard operational semantics host type substituted client code 
impossible talk type fh remaining client fh replaced int 
second step host code substituted client code distinctions principals lost 
acm transactions programming languages systems vol 
november 
open string fh read fh char syntactic type abstraction fh host client code int host code host int fh int fh client code host code host int fh client code host code fig 

standard encoding linking client host code 
section describe agent setting sufficient proving interesting properties file handle example 
introduces general approach distinguishing principals evaluation 
section introduces multiagent calculus provides multiple agents multiple types arbitrary assignment types known agents 
prove safety abstraction theorems calculus safety properties agent calculus follow corollaries 
sections sketch extensions system believe difficult syntactic framework 
section adds state presentation emphasizes subtle ways naive treatments state break type abstraction 
section adds recursive types polymorphism emphasize features treated orthogonal principals features encoded principals 
section surveys related includes approaches proving type abstraction approaches syntactic proof techniques approaches putting notion principal programming language 
extends previously published zdancewic providing complete presentation agent multiagent calculi extensions incorporate state recursive types polymorphism 

agent calculus syntax section describes variant simply typed lambda calculus principals client host 
language maintains syntactic distinction host client code evaluation 
host exports type implemented concrete type gives syntax agent calculus 
types include base type host type function types 
terms language client terms client values host terms host values metavariable xc ranges client variables disjoint host variables ranged xh 
metavariables bc bh range values base type 
assume host client underlying representation values base type 
values fundamental medium information exchange agents 
example client value corresponds host value 
possible relax assumption conversion host client values require computation instance change byte order integer words principal agent color interchangeably 
acm transactions programming languages systems vol 
november 
dan grossman xc bc xc 
cc bc xc 
px xh bh xh 
hh bh xh 
fig 

agent syntax 
values 
advantages distinguishing principals places marshalling unmarshalling needed explicit program 
helpful think terms generated having different colors indicated subscripts respectively indicate principal belongs 
observed client host terms mix evaluation 
keep track agent terms contain embedded host terms form intuitively brackets delimit piece colored code exported agent type 
dually host terms may contain embedded clients 
type annotations embeddings keep track values type execution 
particular host term type may embedded client term 
annotation client information form term inside embedding 
embedding annotation containing host value client value 
intuition semantics imagine copies simply typed lambda calculus augmented new type client copy host copy host knowledge asymmetry language 
semantics asymmetry manifests rules host refines means notion value depends principal type information embedding annotation client value 
embedding host value annotation type host 
notation describing semantics define convenient notions 
range client host terms range client host values 
color term color note terms syntactically formed application color 
host client terms share semantic rules rules range kinds terms 
intention terms mentioned rule color rule short hand analogous rules color 
write capture avoiding substitution terms equal alpha conversion substituted variables color 
define substitution types written 
intuitively sub acm transactions programming languages systems vol 
november 
syntactic type abstraction steps ee 
client steps qy bc px xh 
xc px xh host steps qy bh px xc 
xh px xc qy fig 

agent dynamic semantics 
produce host view 
say client term host free contains embeddings similarly client free host terms 
dynamic semantics describes small step operational semantics agent calculus 
rules simply typed call value lambda calculus 
rules handle embeddings 
rules allow evaluation proceed embeddings 
inside embeddings rules color apply 
context switches ensure terms evaluate appropriate rules color 
embedded value exported outer principal type outer agent strip away embedding value see rules 
point conversion data representations take place 
rules maintain distinction client host code 
example suppose client contains host function exported type case client know embedding contains function client apply argument suitable type 
function exported type client able apply 
subtlety host type function may specific client type converts embedded host function client function argument type body client version function embedding host code argument comes client occurrence original argument variable xh replaced embedding client argument variable xc embedding exported host type type host originally expected function argument 
rule hosts symmetric host may occurrences host function type annotation replaced final rule allows host open client value embedded host value 
rule allows host recover value acm transactions programming languages systems vol 
november 
dan grossman 
open string fh 
open myfile px sh string 
ho string fh string fh 
myfile sc string 
string qy fh sc string 
string qy fh myfile px myfile string qy fh myfile fh 
px fh fig 

client calling open 
embedded abstractly client 
restricted form rule ensures term inside embedding value embedding 
specifically annotation term value 
rule applies 
restriction keeps system deterministic property find convenient probably necessary 
crucial point attempt client treat value type function leads stuck configuration rule applies 
generally ensure configuration value appears active position stuck 
fact stuck configurations simply typed lambda calculus allows prove safety properties section 
examples give examples program evaluation agent calculus 
returning example file handles fh int 
shows client obtaining file handle host interface 
simplicity host open function provided client 
host implementation ho takes string produces integer representing file handle 
code embedded inside client type string fh 
step uses convert embedded host function client function 
note new variable sc embedded host client term 
step standard reduction 
reduction steps correspond linking host client code example type information fh client code 
step reduction passing client string myfile step uses extract string embedding 
point host function ho applied host value 
repeated allows host function proceed 
assume ho returns applied myfile result embedded client code type fh client value 
second example illustrates client calling host read function passing file handle fh embedded client exported type fh char 
body host function host term integer representing file handle returning character read file 
step client extracts host function rule 
type argument client type annotation changed acm transactions programming languages systems vol 
november 
px int 
hr fh char syntactic type abstraction px fh fh 
int px fh fh char 
px fig 

client calling read 
rules var const app cfn hfn xc client rules xc xh xh host rules fig 

agent static semantics 
ee fh 
second step reduction 
point evaluation continues step allows embedded host code extract integer held client host value 
application hr proceeds usual host computes character read file 
embedded character exported client type char rule produces value static semantics describes static semantics agent calculus 
typing context maps variables color types 
rules standard rule client functions 
host functions difference allowed appear annotation argument function 
host knows restriction limit expressiveness 
convenient effect side condition rule types host terms contain presence host function types complicate rules var app need refine type order types preserved evaluation 
interesting typing rules embeddings 
rule embedded host term exported client type may contain occurrences hastype host able show actual type 
words host may hide type information client replacing occurrences exported type 
rule clients embedded inside host terms dual host refines types acm transactions programming languages systems vol 
november 
dan grossman provided client 
erase xi erase erase 

erase erase erase erase erase erase fig 

agent erase translation 
safety properties section explore properties agent calculus including soundness type abstraction theorems 
defer proofs corollaries corresponding theorems sections 
properties intended general possible 
convey flavor statements provable syntactic arguments 
lemmas establish type soundness lemma canonical forms 
assuming type lemma preservation 

lemma progress 
value exists definition 
stuck value theorem type soundness 
stuck term ignore colors erase embeddings replace typed term simply typed lambda calculus 
formally defines erasure agent term 
rules 
lemma states erasure commutes evaluation 
lemma erasure 
agent term 
erase erase 
interesting fact erasure rule basically 

substitution erasure process ensures types bound variables side transition 

alpha equivalent 
transition corresponds identity transition zero steps erased language 
soundness erasure established reexamine abstraction properties 
host capable providing information acm transactions programming languages systems vol 
november 
syntactic type abstraction client particularly interested evaluations assume host 
recall say host free describe client term host terms embedded 
desirable property file handle interface client breaks type abstraction file handles 
example host free handle fh fc fh 
fc fh 
handle evaluates term handle treated integer 
property corollary type soundness client code type fh equal int example expression fc typed 
stronger property client oblivious particular choice integer host uses represent file handle 
formally theorem independence evaluation 
fh fh typed host free fc fh 
fh fc fh 
fh bc fc fh 
fh bc 
proof strengthens claim step step evaluation correspondence lemma value abstraction 
host values type cis host free xc fh fh xc value exists host free term xc fh fh xc fh xc fh xc fh xc embeddings enable track expressions type evaluation allowing formalize third property client called open obtain file handle 
theorem file handles come open 
suppose host free ho client free open string fh 
cis typed 
open string fh 
applied sh string 
ho sh string fh steps term containing fh subterm derived sequence form ho proof shows step host embedding embedded term application ho intermediate result application 

multiagent calculus far described simple agent setting host strictly information client 
model interesting cases fashion times principals wish hide information agents involved 
example need multiagent setting prove safety properties nested data types 
natural generalization allow agent export multiple types 
facility exists agents able share type information 
acm transactions programming languages systems vol 
november 
dan grossman 
agents lists types terms ei xi bi xi 
ei ei fix fi xi ei qy vi bi xi 
ei values vi vi px vj qy dom fig 

multiagent syntax 
syntax shows syntax multiagent language 
types include base type function types type variables ranged follows range type variables 
just colors terms assume agents fixed 
metavariables set agents 
term exactly color indicated subscript 
embeddings color determined context grammar allows ei ej produce syntactically identical embedding terms 
explicitly state color term ambiguous particularly relevant discussion 
functions applications constructed subterms color 
terms agent include variables xi constants bi nonrecursive functions xi 
ei recursive functions fix fi xi ei function applications ei ej include recursive nonrecursive functions simplify dynamic semantics see rule 
embedding containing term labeled list agents reasons explained section 
write simply singleton list containing agent juxtaposition denote appending lists concatenation lists 
static semantics requires list embedded term begins term ej write just unimportant 
rev mean list reversal 
type information goal language agent limited knowledge type information 
represent agent knows ensure agents sharing information consistently 
example agent know fh int 
may piece information know realization fh knowledge compatible knows 
case thinks fh string 
capture information assume agent finite partial map type variables types called maintain consistency knowledge agents require agents know implementation type know implementation 
restrict maps acm transactions programming languages systems vol 
november 
syntactic type abstraction type variable unique concrete interpretation example allow subtle examples admit defined notion concrete type need consistency agents motivates part definition need concrete interpretations type motivates second part 
definition 
aset finite partial maps type variables types compatible dom dom 
collection type variables totally ordered agent type variable variables precede extends naturally total function types types dom dom applying yields information type variables appearing concrete version 
example fh fh int int 
say refines write reflexive transitive closure viewed relation types 
fh fh int int 
second condition definition compatibility fact agent finite amount type information guarantees process agent refining type halts 
sequence reaches fixpoint write 
fixpoint concrete view agent able determine knowledge 
agents pool information type variables notion concrete view valid 
write union compatible maps 
contains composite knowledge agent system 
reflexive transitive closure relation 
process refining terminates reaches fixpoint 
notation indicates fixpoint concrete type compatible 
practice compatibility constraints guarantee things 
set agents conspire show incompatible types equal effectively cast integer function example 
second defined notion concrete type agent 
criterion clearly necessary soundness system 
second criterion greatly simplifies static semantics 
may notions compatibility relax conditions admitting sound type system behaved semantics 
embeddings set terms values depends available type information 
addition usual notion values embedded agent value determine type information value 
vj value dom 
acm transactions programming languages systems vol 
november 
dan grossman embedding nested embedding example xj 
xj value 
terms values result significantly complicate dynamic semantics example nested embedding passed agent able refine arrow type need cross embedding boundaries find function agent expects 
dynamic semantics collapses embeddings case xj 
xj ji result values cross embedding time embeddings annotated list agents 
somewhat complicated mechanism necessary 
way relating type term inside embedding type annotation embedding agent export integer function 
list agents allows maintain exactly information needed establish connection type term inside embedding type annotating embedding 
forget agents inconsistencies may arise 
example consider agents andk int 
collapsing term violates type abstraction properties knows abstracts int 
sets agents ordered lists reasonable rules permissive lose information agent exported integer type export type explain section type system admits nested embedding term collapsed version ij 
summary lists agents embeddings remember particular order principals necessary type checking treating nested embeddings values 
dynamic semantics shows operational semantics agent multiagent language 
rules depend color term reduced rules denote color 
rules establish typical call value semantics 
rule allows evaluation inside embeddings 
rule lets agent pull constant embedding provided constant exported type rule corresponds rules agent scenario 
agent case host type information client agent knowledge refine type embedded term 
previously substitution rule served purpose 
captures type refinement information available agent correspondingly rule allows refine type embedded value 
side condition rule conjunction conditions ensures evaluation deterministic 
determinism type refinement rules critical system proofs easier applicable rule evaluation step 
choice operational semantics refines type information interacts apply maps static semantics chose maintain invariants static semantics derives believe language easily adapted call name setting 
acm transactions programming languages systems vol 
november 
ei ei vi vi fix fi xi ei xi 
fix fi xi ei fi ei xi 
ei vi vi xi ei qy bi px vj qy px vj qy vj qy qy px vj qy px xj 
syntactic type abstraction dom ej qy qy xi px xj xi fresh fig 

multiagent dynamic semantics color concrete type term types explicitly mentioned lambda abstraction syntax concrete 
possible reformulate calculus conditions relaxed allowing nondeterministic type refinement rule static semantics doing require additional proof normalization arguments 
rule multiagent generalization rule 
rules allow progress nested embeddings inner embedding reduced inner agent considers value 
agent case situation occur outer agent host 
concerned tracking values host manipulates rule strips away embeddings 
symmetric multiagent setting naively stripping away embeddings loses information agents contributed information type term 
rule says nested embeddings vj inner embedding vj value dom embeddings collapsed vj 
append lists lose information agents participated evaluation term 
interesting rule really tracks principals 
embedded function lifted outside 
argument belongs outer agent inside agent type thinks argument 
body function term term occurrence new formal argument xi embedded term inside term 
corresponding type annotation argument 
function body function applied actual argument held remaining issue agent list formal argument embeddings 
inside type outside type reversed roles list reverse order 
intuitively agents successively provided function argument type undo body function 
side condition ensuring embedding type concrete respect outer agent preserves determinism semantics ensures acm transactions programming languages systems vol 
november 
dan grossman assume fh int fh dom yh int int 
yh px xc fh 
fh yh int int 
yh px xc fh 
int int yh int int 
yh int 
int 
fh px int hc explicit type xi concrete 
fig 

multiagent evaluation example 
example example encode agent calculus letting map fh int letting undefined 
evaluation uses novel rules appears 
host program invokes client function defined terms type fh 
simplicity just identity function 
evaluation takes place host context enabling host apply function value client function expects argument type fh 
body client code host value wrapped embedding treated abstractly 
host code able recover value returned client 
numbers reduction rules take step 
note simple system rules encode previously hard wired rule 
similarly rules 
static semantics shows multiagent static semantics 
note rules depend color term value maps rules denote color term 
values maps change leave implicit 
judgment ei read maps context agent show ei type rules embed essentially standard 
rules abs fix additional conditions force agent concrete type available functions internal agent analogous side condition hfn agent case 
similarly embed guarantees embedded term viewed agent concrete type possible 
formally convenient invariant maintaining ei implies 
issue consistency agents arises type checking 
instance want principal export int function 
likewise want agent collection agents violate type abstractions represented maps 
need relate type expression inside embedding type annotation embedding 
acm transactions programming languages systems vol 
november 
const bi var xi xi app abs fix embed xi xi fi xi eq fix fi xi syntactic type abstraction ej ei ei xi dom fig 

multiagent static semantics ei 
trans fig 

type relations 
fi xi dom fi xi establish agent list indexed family relations types judgments form showing types may related list 
rules say im exist types agent ik able show 
informally agents able chain knowledge type information show embed rule uses relation ensure type inside embedding matches annotation embedding 
agent appended list outermost agent implicitly involved evaluation term 
safety properties section illustrates standard safety theorems typed programming languages presents embedding erasure transformation commutes evaluation 
standard lemmas help establish type soundness 
proofs straightforward 
lemma canonical forms 
assuming vi bi xi xi dom vi vj vj 
give nondeterministic rule trans concerned algorithmic presentation type checking 
formulation lets slightly simplify proofs type relations properties essential correctness 
acm transactions programming languages systems vol 
november 
dan grossman lemma substitution 
suppose xj ei ej ej xj ei 
need properties relations 
lemma type relation properties 
idempotence ii reversal rev 
arrow proofs properties simple arguments induction derivation type relation 
proof property requires tedious normalization argument showing derivation relates types top level constructors arrows 
give brief sketch argument proof induction length list 
base case length follows compatibility relations 
inductive case straightforward types chain arrows suppose chain types showing type variable encountered type number type variables chain arrow type 
consistency conditions maps arrow type need occurrence chain simply replace words occurrences type variables provide additional information remove reducing problem chain consisting arrow types 
results need prove main lemmas 
lemma preservation 
ei ei 
proof 
induction derivation ei proceed cases step derivation 
cases follow induction 
cases follow immediately substitution lemma 
case trivial prove 
consider remaining cases individually typing derivation follows vj vj equals eq wehavethat 
trans wehavethat ii remove second idempotence 
derive vj vj desired result 
acm transactions programming languages systems vol 
november 
typing derivation follows vj vj vj syntactic type abstraction fact inner embedding labeled list starting follows canonical forms lemma 
furthermore trans premises kk idempotence proves derive vj vj desired result 
typing derivation follows xj ej xj ej xj ej furthermore concreteness side condition rule implies definition know arrow lemma right hand premise bottom step conclude reverse reversal lemma derive xi xi xi xi original derivation provides conclude xi xi provides xj ej xi fresh may weaken claim xi xj ej substitution xi xi xj ej derive xi xi xj ej xi xi xj ej xi xi xj ej desired result 
lemma progress 
typed value exists proof sketch 
proof straightforward inductive argument structure interesting case ei vj rule applies 
vj embedding rule applies 
proceed acm transactions programming languages systems vol 
november 
dan grossman erase xi erase bi erase xi 
ei 
erase ei erase fix fi xi ei fix erase ei erase ei erase ei erase erase qy erase ej fig 

multiagent erase translation 
cases form 
rule applies 
rule applies 
ei value 
previous lemmas conclude type safety theorem type safety 
stuck cost including embeddings addition dynamic rules 
worse recursion multiple agents lists annotating embeddings grow arbitrarily large 
erasure property stated essentially shows syntactic tricks proof technique 
erasure typed language necessary combine type information agents 
multiagent definition erase recall map obtained union compatible maps 
concrete type agents knowledge 
target language agent embeddings 
lemma erasure 
ei typed ei erase ei diverge ei vi erase ei erase vi 
proof sketch 
induction number steps source deriva tion 
step show ei erase ei erase erase ei erase 
erased version takes zero steps source step uses rules step source step uses rule 
divergence show contrapositive term erasing term 
essence argument source derivation take finite number steps rules 
type abstraction properties section subject reduction arguments prove type abstraction properties generalize agent case 
definition 
agents ei set colors appearing ei 
set necessarily includes agents appearing lists annotating embedding subterms ei 
definition 
set agents type dom 
acm transactions programming languages systems vol 
november 
syntactic type abstraction theorem independence evaluation 
ei term agents ei oblivious xi ei vj closed typed terms type 
xi ei vj bi xi ei bi 
note vj primitive values 
vj values 
know agents ei vj constant function vj typed embed ensures dom 
agents ei oblivious agents ei 
proof theorem strengthens claim step step evaluation correspondence vj give intuition presenting formal lemma maintain intermediate terms evaluation sequences exactly occurrence vj replaced 
ensure correspondence show occurrence vj safely embedding type agents relate agents oblivious embedding type maintain terms ones abstracting appears embedding list element 
conditions suffice argue helps agents break type abstraction 
specifically properties defined lemma suffice show agents ei distinguish values type help agent properties suffice show provide help 
lemma value abstraction 
vj type 
ei mean xj ei 
agents ei oblivious 
term ei xj 
may appear zero times 
xj term ei 
appears embedding list ei element 
ei vj xj ei exists vj xj xj ei xj proof sketch 
induction derivation vj xj ei proceeding cases rule derivation 
rules essentially follow induction definition substitution 
note embedded term term term vj value 
rules follow definition substitution fact variable substitute term distinct xj term xj different colors 
furthermore vj closed substitution effect 
acm transactions programming languages systems vol 
november 
dan grossman rule trivial prove term inside embedding vj vi property hold 
assume contradiction term inside vj 
property substitution term xj 
properties free list agents simple proof induction rules shows contradicts property 
rules straightforward verify 
note outer agent list contain properties 
rule requires analogous argument show term inside embedding xj 
agent list embedding contain property preserved agent list reversed 
substitution body function unproblematic vj closed unaffected 
lemma suffices prove independence evaluation assumptions theorem xi ei xj 
induction length evaluation property holds bi result evaluation vj 
implies bi result evaluation results alpha equivalent 
generalization theorem theorem 
effectively says client containing value type fh obtained value host provided function 
theorem host provided values 
suppose prog closed welltyped term form fh 
client xh ho fh suppose agents client oblivious fh knows fh ho embedding free prog ei 
subterm ei closed value type fh form vh fh eh xh ho vh erase eh base value note necessarily case bh xh ho vh fh function type dynamic semantics evaluate functions 
note restrictions agents client type abstractions know implementation fh 
example agent export fh abstractly agent 
proof consists intricate subject reduction argument general idea 
intuitively terms result argument 
knows fh values type fh come applying ho 
main complication tracking functions essentially xh ho differ color embeddings step prog uses convert xh ho fh xi xi xh ho fh consider term legitimate producer file handles 
agent pass term agent result legitimate 
due complications carefully state property evaluation typed term preserves presents relations usual mean relations closed appropriate inference rules 
rules assume color know fh colors acm transactions programming languages systems vol 
november 
ee 
syntactic type abstraction fix eh xh ho erase eh eh fh qy xj px qy xh fh yk xj qy yk qy px xh fh fig 

host provided values preservation property 
range color 
implicitly assume context host provided values theorem xh ho closed typed embedding free 
rules just structural rules find important terms functions essentially xh ho results applying functions 
terms allowed 
rule accepts terms intermediate results applying functions 
functions differ ho terms embeddings doesnot require hl exists vh vh xh ho vh may eh long erasure value 
rule accepts terms essentially xh ho auxiliary relation 
rule accepts function step prog 
foreach time function passed agent rule rule conclude resulting function acceptable 
include rule prog holds 
easy show implies closed typed 
straightforward prove preserved evaluation host provided values theorem true verify prog 
ei ei prog ei 
simple induction derivation ei appealing canonical forms values necessary suffices prove subterm closed value type fh 
rule necessary derive antecedents rule strong prove theorem 
separate inductive argument shows subterm closed value type fh 
proceed rigorous proof preserved 
usual subject reduction argument relies substitution lemma prove presenting main lemma 
lemma host provided substitution 
color color 
proof 
proof induction derivation proceeding cases acm transactions programming languages systems vol 
november 
dan grossman rule derivation 
cases trivial 
cases follow straightforward inductive arguments 
case follows eh xh ho closed evaluation preserves property 
case follows implies closed shown induction derivation 
lemma host provided preservation 
ande 
proof 
proof induction derivation proceeding cases rule derivation 
follows induction hypothesis 
follows induction hypothesis 
derivation ends 
note impossible holds values embeddings values fit conditions 
result follows induction hypothesis 
know eh xh ho appropriate eh 
know eh xh ho 
follows induction hypothesis host provided substitution 
xj vj vj type derivation ends 
vj xj derivation ends 
result follows induction hypothesis host provided substitution 
xj derivation 
form suffices show vj xj 
prove fact prove xj vj vj type implies stronger facts erase vj ej type ej ej ej xj 
clear strengthened claim suffices 
prove induction derivation proceeding cases rule 
case fact follows canonical forms lemma typedness second fact ej xj ej xh ho fh applies letting eh ej eh xh ho 
case xj xj xj yk 
furthermore derivation yk induction hypothesis conclude vk type vk erase vk canonical forms lemma conclude vj type vj obligation 
induction hypothesis know ek type ek ek ek yk 
arbitrary ej ej ej ej conclude acm transactions programming languages systems vol 
november 
syntactic type abstraction ej yk 
definition substitution ej xj xj yk 
rule definition substitution derive ej xj xj yk second obligation 
immediate 
derivation ends 
note impossible derivation agent refine fh 
inspection antecedents reveals rule applies step 
steps derivation 
note impossible nested embedding fh type variable 
induction hypothesis conclude 
step second step induction hypothesis conclude 
note suffices satisfy requirement type annotation fh 
remaining cases step show contradiction situation impossible 
suppose derivation ends 
consequent rule value form vj embedding free eh easy show eh xh ho evaluate value embedding 
derivation ends 
note impossible agents client oblivious fh fh 
derivation ends know xh ho fh xi xi xh ho fh lets conclude 
derivation ends know second step 
result follows host provided substitution 
know rule derive result form cases 

note typedness fact suffice satisfy antecedents 
worth considering generalize proof proof technique 
generalizing means clients obtain file handles straightforward 
function ho just example constructor expression exported type fh appears positive position 
tracking constructors show values originate 
generally syntax subject reduction track flow values requires find interesting terms purpose rules 
rule describes property interest case term came invocation host implementation open 
auxiliary predicate describes host term appear exported number agents embeddings pile uniform way change underlying code interface code available 
acm transactions programming languages systems vol 
november 
dan grossman 
state section augment program states preceding development mutable store appropriate expressions manipulating store 
goal extend type abstraction results stateful setting unduly restrictive 
section brief overview formalization state ignoring issues regarding agents type abstraction 
point simply establish basic notation discussion follows 
follows closely standard treatment subject reduction setting see wright felleisen harper 
give informal description issues store particularly interesting addition framework 
formally augment calculus state discuss reasons particular design decisions 
augment proofs type soundness safety properties appropriately 
notation ignoring types agents store partial map labels values 
collection labels infinite set range members 
program state pair store closed expression dynamic semantics operates program states 
new expression forms allow program manipulate store 
creation ref evaluates fresh label extends store map dereference evaluates store 
update evaluates changes current store map may give appropriate types labels add unary type constructor ref 
store values type ref hastype 
static semantics ensures formed program states refer labels defined store 
restriction applies store just closed expression 
stores expressions formed relative labels store types labels 
store types ranged formalize assumptions partial map labels types 
summarizes preceding considerations presenting syntax semantics lambda calculus state 
note rule store wellformedness permits store contain cycles 
problems state semantics associated stateful calculus understood discussing type abstraction principals setting considerably complicated 
examples difficulties 
difficulty expressions program may evaluation syntactically captured subterms expression 
previously described client expression free account obtaining host code store 
example expression evaluation independent value depends value current store 
obvious solution define host free entire program state solution unnecessarily restrictive 
safety theorems notion expressions reachable 
acm transactions programming languages systems vol 
november 
syntax dynamic semantics syntactic type abstraction ref ee fix ref 
ref ref 
ref static semantics fresh fix 
fix dom dom dom 
ref ee fix ref dom fig 

lambda calculus state 
ref 
ref ref dom second difficulty store provides new medium interagent communication 
example client assign shared host dereferences 
suppose shared program evaluates client program state 
interpret program mean host perspective store contains client term 
mean store contains 
dual case potential problem host assigns type client dereferences result client expression preserves type abstraction 
general assigned know agents dereference value 
despite lack knowledge semantics create acm transactions programming languages systems vol 
november 
dan grossman correct embeddings allow syntactic account type abstraction 
fortunately expressions colored know agent assigned 
third difficulty host provide client ref ref notation syntactic sugar function application expression violates requirement form rh ref client xc ref yc ref ref ref client rh rh see problem consider values xc yc body client function application client rh rh 
answer preserves types expressions xc yc respectively answer requires dynamic semantics depends types xc yc 
dependence undesirable substitution semantics 
approach sensible consider code fragment yc xc agent knows construct value type assign shared 
ensuing dereference preserve type xc host provided term 
resolve subject reduction issues exemplified resulting system break type abstraction 
example give known context ml programming language device works setting pierce sangiorgi 
client term determine values types ref ref value correctly conclude client fragment determination aliasing information 
assume client distinguish values type 
yc abs xc yc xc abs yc aha problems challenge prohibit agent viewing contents different levels abstraction 
doing restrict language expressiveness 
revised calculus presenting formal calculus summarize solve problems just outlined 
acm transactions programming languages systems vol 
november 
syntactic type abstraction definition host free straightforward expression reachable subterm subterm reachable 
host free terms reachable client terms 
correctly handle interagent communication store semantics dereference operator depend color expression currently stored 
example vc lh vc lh vc different colors 
know type put embedding annotate labels types see 
conversely lc vc 
technique requires expression embedding color determine color run time 
intuitively value embedded precisely received different agent 
alternatively dereference operations return embeddings 
allowing embeddings code perfectly reasonable fact multiagent calculus prevent 
choose take approach prefer introduce embeddings precisely interagent communication occurs 
theorems rely fact evaluation introduce embeddings find fact aesthetically pleasing 
crossing embedding boundary requires computation change data representation avoiding redundant embeddings reduces computational overhead 
prevent agent exporting different levels abstraction 
enforce restriction syntactically associate type expression label creation expression ref expressions type ref exported precisely ref fully type host decide creating level abstraction expose contents 
prevent exposing different level abstraction rules relating type embedding annotation type embedded value substitute types ref constructor 
course host allow client access type ref providing functions get xh ref xh ref set xh yh ref yh xh ref appear client get set encode aliasing example breaks type abstraction 
assume client know function bodies associated get set client conclude sure different types aliases 
get perform computation happened evaluate contents supposedly aliased value 
words correctness aliasing device relies atomic completely specified behavior assignment dereference operators 
having intuition design decisions augmented calculus 
extend multiagent calculus symmetry calculus simplifies presentation explain system terms familiar host client example 
recall finite partial map type variables types encodes type variables agent knows 
agent case maps generally concerned stores finite size interpret definition inductively coinductive interpretation warranted 
acm transactions programming languages systems vol 
november 
dan grossman ref vi vi fresh color ej qy vi vi vi color qy fig 

dynamic semantics state partial cis empty map 
extend types operate ref constructor dom dom ref ref value type ref exported abstractly ref ref 
agent case previously wrote identity function 
syntax suggests substitution misleading sub occur ref 
type case just dynamic semantics straightforward combination multiagent semantics stateful semantics 
specifically system defined rules suitably extended operate program states modify store 
top rules allow evaluation proceed subexpressions applications state operations 
rules evaluating state operations allowing evaluation embedding shown 
rules enforce decision introduce embeddings heap facilitates interagent communication 
rule allows agent extract label embedding agent sufficient type information know embedding contains label 
note type label embedding ref equality consistent definition interesting additions static semantics appear 
obtain full semantics include rules figures modification typing judgments include store type context 
store contents typechecked color 
may hold value color 
agent setting policy means contains host value value type host static semantics contains agent value value acm transactions programming languages systems vol 
november 
label assign heap heap syntactic type abstraction ei dom dom dom 
color dom ref ref ei ref ei deref fig 

static semantics state partial 
ei ref ei ref ei ref ei type agent static semantics 
note treatment requires determine color 
maintain convenient invariant vi implies 
type annotated invariant means type dereference operation explicitly type ref 
rules creation assignment require subexpression evaluates eventual contents type 
words know legitimate abstraction invariant concrete 
example agent system consider type expression formed host term agent term 
rule relating type embedding type embedded expression prevents ref exported type ref ref constituent type 
important fact follows definition relation defined terms maps 
agent case right antecedent rule embed simply host terms agent terms 
safety properties type soundness erasure results established calculi state extend naturally stateful calculus 
aspects theorems proofs pertain additional rules 
canonical forms lemma describes form vi assuming vi 
addition ref form li sake type soundness substitution lemma need describe substitution expressions opposed program states 
simplicity dynamic semantics substitutes expressions 
see independence evaluation lemma needs definitions substitution program states formedness open stores stores may contain values free variables 
equivalent antecedent equivalent 
acm transactions programming languages systems vol 
november 
dan grossman preservation lemma expresses evaluation extends store consistently 
store weakening lemma stating store extensions change type expression induction hypothesis strong 
lemma store weakening 
extension 
lemma preservation 
exists extends 
note strengthening preservation precisely needed extend lambda calculus state principals add complications 
proof careful static semantics routine 
recall proof induction derivation 
show cases rules 
cases simple analogous cases proof state trivial inductive arguments store weakening lemma 
proof 
assumption derivation form vi ref vi ref letting vi extends 
know suffices prove vi facts follow antecedents static derivation store weakening lemma 
final obligation definition static semantics 
assumption derivation form ref vi ref follows vi letting vi extensions respectively 
hypothesis derivation vi show 
know follows vi assumption derivation form ref 
letting need show vi 
cases color 
assume color vi 
follows hypotheses needed prove vi immediate 
assume different color 
vi argument case know eq conclude 
embed applies desired result 
acm transactions programming languages systems vol 
november 
induction 
assumption derivation form dom ref ref ref ref ref syntactic type abstraction ref ref hypothesis dom derive ref label 
letting done 
statement progress lemma remains unchanged program states expressions 
additions proof entirely straightforward 
case vj additional case form ref case canonical forms guarantees vj form lj take step 
defining erasure stateful language embeddings calculus erasure commutes evaluation straightforward omit details 
note target transformation include explicit types labels explicit types real dynamic effect 
extending value abstraction lemma independence evaluation theorem corollary stateful calculus straightforward technical distractions 
notion reachable expressions includes expressions store simpler notion subterms 
second value abstraction lemma uses substitution vj xj ei correspondence evaluations 
technique extend definition substitution stores pointwise fashion 
lemma apply agent stored vj store strong prove independence evaluation theorem 
substituting store requires define formed open store respect context sense 
correct definition obvious generalization dom wherem possibly open value 
extending host provided values theorem stateful calculus straightforward 
essentially preservation property needs inductively defined include terms reachable current program state considering trusted ho term 
ho maintain private state invalidating theorem 

polymorphism recursive types section explore extension multiagent language section include recursive types polymorphism 
mechanisms define type variables type establishes equation 
instantiation polymorphic value establishes context type 
maps multiagent calculus provide way expressing equalities form may try encode recursive polymorphic types 
current multiagent language sufficient encode acm transactions programming languages systems vol 
november 
dan grossman types 
terms ei 
roll ei unroll ei vi 
roll vi ei roll ei roll unroll roll vi vi vj qy roll ei roll px vj qy roll ei unroll ei unroll ei unroll ei unroll ei fig 

recursive types orthogonal extension 

sections discuss consequences adding necessary mechanisms 
recursive types general approaches adding recursive types multiagent language 
way straightforward interacts previous results language 
idea treat bound type variables separate entities type variables abstraction drawn syntactic class separating cleaner presentation 
contains necessary additions language 
new types include recursive type variables ranged types 
terms roll unroll mediate isomorphism 
value roll vi 
typing judgments new forms standard 
operational rules standard allow progress roll unroll establish composing unroll roll identity 
new rule propagates embedding roll expression exported concrete type 
similar rule embedded functions outer agent may different information nature recursive type 
instance outer agent may know value type lists inner agent int views value int list 
side condition ensures dynamic semantics deterministic rule applies disjoint collection terms 
remaining change needed establish soundness system abstractions types annotating roll terms required concrete possible need apply concreteness type antecedent implies concreteness type roll 
formally add product sum types framework doing straightforward 
example qy concrete 
acm transactions programming languages systems vol 
november 
syntactic type abstraction extend definition terms bound type variables syntactically distinct abstraction type variables sense domain avoid problems capture prohibit free occurrences range having additions language straightforward establish type soundness 
establish preservation case need lemma analogous arrow lemma case lemma type relations 
interesting case proof preservation rule dynamic derivation proof 
assumption derivation form ej roll ej roll ej right antecedent lemma conclude top antecedent derive ej ej assumption side condition condition easy show derive ej roll ej progress lemma routine uses extension canonical forms lemma asserts values type form roll vi 
way dealing recursive types advantage simplicity presence recursive types orthogonal kind type abstraction allowed embeddings proofs safety properties section require minimal changes account new constructs 
approach incorporating recursive types system requires change notion compatibility maps account cycles 
recursive type observe rolled values behave essentially abstractly 
destructor term roll vi unroll 
observation suggests encode recursive types fresh acm transactions programming languages systems vol 
november 
dan grossman type variables 
create special agent sole function provide roll unroll operations recursive type 
type perspective knows undefined 
client agent wishes values type terms encoding roll unroll roll xr 
xr unroll xr 
xr type variable acts type 
expected agent provides identity functions appear clients having types appropriate roll unroll respectively 
approach initially appealing requires substantial changes language 
essential difficulty may concrete form type variable due possibly cyclic nature type information 
reasonable alternatives move operational semantics types refined nondeterministically require agent type information acyclic cycles globally 
options satisfactory 
reasoning behavior programs unduly complicated 
second choice means giving type information agent destroy system compatibility 
suffer problem erasure typed language harder establish 
may merit considering approach particularly agents module level constructs concern mutually recursive data types cross module boundaries 
core language simplicity approach compatibility previous proofs valuable 
polymorphism primary difference polymorphism type abstraction multiagent calculus scope types multiagent calculus global static polymorphic instantiation local part program 
application 
introduces type equality scope expression second difference type abstraction polymorphism type variable may instantiated different types example 
int bool 
appears int holds part term bool holds different part term 
second difference superficial 
type bound free rename occurrence body 
think term int establishing equation int second term choose type equivalent type bool defines bool 
way type application establish concrete form distinct type variable 
true distinction type abstraction mechanism polymorphism local scoping 
approach recursive types acm transactions programming languages systems vol 
november 
types 
terms ei 

ei ei vi 

ei dom dom syntactic type abstraction 
ei iei px 

qy intro elim ei 
ei ei ei fig 

polymorphism 
dom dom include features separately 
investigate extend framework unify type abstraction polymorphism single mechanism 
bridging gap features amounts allowing definitions maps change evaluation 
notation mean set type maps captures type knowledge agent particular point program evaluation 
integrate traditional polymorphic terms extending notion evaluation ei ei approach similar allocation explicit type passing semantics polymorphism dissertation morrisett 
contains necessary adjustments language 
note form type variable 
keeping convention respect polymorphism allow range type variables addition types extended form 
add terms form 
ei ei 
instantiation type variable represented ei 
operationally see rule application corresponds extending include 
notation mean mapping types types obtained 
notation represents 
extension valid preserves compatibility maps 
ting dom mean dom easy show compatible dom compatible 
notational convenience implicitly assume dom 
need specify behavior types form 
assuming dom possible alpha conversion wehave 
original multiagent calculus maintains invariant types appearing part syntax term concrete agent perspective 
acm transactions programming languages systems vol 
november 
dan grossman invariant enforced typing rules example abs rule requires unfortunately invariant harder maintain agent may learn information type variable runtime 
introduce special substitution operator perform substitution terms colored including subterms colored subexpressions 
extend operator contexts pointwise manner variables context color 
understand operational behavior new constructs 
polymorphic expressions values 
rule performs type instantiation 
agent type map extended new binding substitute colored terms body 
importantly agents knows 
way body polymorphic expression different color able techniques argue sufficient conditions evaluates independently certain values passed 
rule describes transition step embedded polymorphic value exported 
case type maps change outer embedding simply moved inside 
static semantics derived regular polymorphic lambda calculus twists account different style tracking type information 
changes course evaluation parameterize typing judgments current definition 
need track lexical scoping bound type variables 
adding set type variables currently scope 
new form typing judgments ei 
additions static rules original multiagent calculus carry new setting understanding occurrences judgments refer parameter rule 
unused new version old rules 
typing rules new constructs intro elim 
lets conclude polymorphic term type add variables scope body type 
side condition ensures distinct variables scope distinct variables defined map 
satisfy condition suitable alpha conversion 
note condition means agent may mention 
rule elim shows type polymorphic instantiation 
agent performing instantiation require instantiation type concrete perspective agent antecedent requires update preserves compatibility 
expect static scoping type variables regulated dynamic information encapsulated closely related 
lemma need prove preservation establishes relation 
lemma 
suppose ej dom 

ii proof sketch 
simultaneous induction parts ii derivation ej acm transactions programming languages systems vol 
november 
syntactic type abstraction usual add new type constructor language need type relations lemma relate subcomponents related types 
case lemma type relations 
alter statement preservation account difference program configurations 
usual allocation style semantics show program lose type information course evaluation 
definition definition 
mean agent type type variable dom 
reflexive transitive closure 
refines 
lemma preservation 
ei ei 
furthermore compatible refines 
proof 
cases terms involving new constructs similar cases earlier omit 
new cases assumption derivation form ei 
ei 
ei dom 

apply lemma antecedent obtain iei clearly compatible refines assumption derivation form ej 
ej 
ej side conditions ensure dom able conclude 

need construct derivation ej ej 
ej 
antecedent original typing derivation 
type relations lemma says implies 
side condition intro observed 
compatible refines done 
context changes evaluation definition vj value depends notion value acm transactions programming languages systems vol 
november 
dan grossman 

dom 

ftv fig 

polymorphic lambda calculus 
dynamic 
write ei value ei ei vj dom 
progress proved usual induction structure ei lemma progress 
ei ei value exists ei translation polymorphic lambda calculus net effect design decisions faithfully embed polymorphic lambda calculus shown new language simply decorating term single color 
case operational semantics degenerates regular polymorphic lambda calculus particular type application substitutes type type variable 
naive translation system provide opportunity syntactic proofs type abstraction 
show smarter translation essentially colors code way agents different type information explicit allows recover type abstraction proofs syntactic manner 
formulate translation type directed transformation 
translation takes additional parameters agent indicating desired color result term map source variables target variables including color information 
maintain invariant compiling judgment dom 
result translation term 
translation 
rules straightforward recursively translate subterms expression combine results corresponding construct 
interesting cases tvar 
rule translating variable simply looks map 
resulting variable color desired color term action needed 
translation produces embedding variable yield term appropriate color 
type variables currently scope embedding may 
idea translating polymorphic term spawn new agent color body type abstraction 
recursively translating body term new color explicitly marks boundaries acm transactions programming languages systems vol 
november 
syntactic type abstraction color tvar px qy color tabs tapp xi ei 
xi 
ei ei ee ei ej 

qy ei fresh ei fig 

translation polymorphic lambda calculus 
type information changes 
examples translations 


xj 
xj 
xi 
xi translation type preserving formalized lemma pointwise application variables 
lemma 
suppose polymorphic lambda calculus map source variables target variables dom dom 
suppose ei 
agents ei ftv free type variables appearing 
ei 
proof sketch 
induction derivation source language 
base case handled definition 
uses fact nonempty 
idea show embedding introduced translation polymorphic term typed 
show translated type application formed need show dom follow fact empty map 
remainder cases follow straightforward induction 
erase extended multiagent calculus excluding fix polymorphic lambda calculus extending definition erasure include new terms 
definition composite type information depends current treat input erase 
erase 
ej 
erase ej erase ei erase ei techniques prove lemma lemma erasure 
ei typed ei erase ei erase 
acm transactions programming languages systems vol 
november 
dan grossman lemma lets establish correspondence polymorphic lambda calculus translation multiagent setting 
lemma translation 
polymorphic lambda calculus erase proof sketch 
induction derivation typed 
invariant strengthened include open terms 
putting previous lemmas yields theorem establishes correctness translation theorem correctness translation 
suppose term polymorphic lambda calculus andc furthermore agents ei 
exists vi ei vi erase vi return file handle example letting string fh fh 
host int host code fh 
int host 
assume host value canonical forms lemma tells function xh string 
host 
string int host view fh int 
steps operational semantics fh 
int host host client codec host host client codec evaluation point rule 
invariant host provided preservation lemma assume client code host free easy establish client code 
rule host code 
host provided substitution able conclude host client codec 
conclude closed value type fh appearing client code evaluation obtained host interface 
technically require bodies client host contain polymorphic terms proof section account new extensions language 
expect requirement necessary 

related representation independence parametric polymorphism pioneered strachey reynolds ma reynolds 
notions incorporated programming languages sml milner haskell peyton jones studied extensively girard system 
connection type abstraction existential types studied mitchell plotkin 
acm transactions programming languages systems vol 
november 
syntactic type abstraction model theoretic approaches studying polymorphism enjoyed rich history incorporating notions recursion proven difficult see macqueen coquand abadi plotkin 
pitts studied relational properties recursively defined domains investigated parametricity extensions polymorphic lambda calculus include fixpoint recursion pitts 
wright felleisen popularized syntactic techniques proving type safety 
view extending theirs prove stronger properties adding innocuous syntax language 
right syntactic additions resulting proofs follow precisely subject reduction form wright felleisen advocate 
abadi taken syntactic approach parametricity formalizing logical relations arguments proofs 
crary proposed singleton types means proving parametricity results resorting construction models 
explicitly involves notion principal 
syntactic separation agents similar nielson nielson level lambda calculus nielson nielson 
concerned binding time analysis principals code inherently mixed evaluation 
notion principal arises study language security privileged agents may leak information unprivileged ones 
see example riecke slam calculus volpano smith security language jflow myers 
pierce sangiorgi prove parametricity results polymorphic pi calculus operational setting 
add principals term language external substitutions reason bisimilarity polymorphic processes concrete views data values 
sewell vitek idea coloring variant pi calculus prove properties causal relationships security setting 
closest leroy investigation safety properties typed applets leroy 
lambda calculus augmented state order prove theorems similar agent theorems 
distinguish execution environment code applet code similar principals consider agent case take syntactic approach 

summary types invaluable tool software designers 
aid programmers reasoning interfaces different pieces code 
despite utility hard prove informal reasoning types file handles obtained open system call correct 
approach encode different principals understood polymorphic lambda calculus appeal results parametricity 
approach feasible language includes state threads recursive types expressive features 
syntactic proofs type abstraction properties tedious conceptually straightforward 
contrast building model conceptually difficult yield elegant proofs 
acm transactions programming languages systems vol 
november 
dan grossman syntactic approach proving type abstraction properties 
main idea color different principals language access different type information 
show track principals evaluation 
extra syntactic structure gives framework prove properties certain values came file handle example abstraction preserved evaluation 
arguments take form subject reduction proofs show desired property invariant respect evaluation hope scale easily model theoretic techniques 
evidence supporting hope shown extend results include mutable recursive types parametric polymorphism 
number open questions approach 
parametric polymorphism offers strong notion representation independence reason equivalence data types 
long implementations equivalent appropriate sense matter implementation program uses produce equivalent results 
avoided building logical relations remains seen exactly formal connections drawn results ones 
investigated connections multiagent calculus process calculi object oriented calculi notion principal threads objects arises naturally 
method tracking principals evaluation adapt domains may learn multiagent calculus viewing agent thread embedding annotations points synchronization occurs execution 
similarity section global alpha conversion restriction operator pi calculus generate fresh type variable runtime 
addition approach integration traditional subtyping 
considered need adapt framework permit primitive subtyping relation multiple base types standard extension type constructors 
multiagent calculus allow principal reveal partial information type 
example letting int andt int agent export function type int int different types 
connection sort partial information partial information knowing subtype approach closer polymorphism subtyping 
kinds properties proven multiagent language limited granularity types 
system prove agent misuse file handles instance duplicating confusing different file handles obtained separate calls open 
reason track embeddings granularity types theorems distinguish particular instances type fh 
imagine tracking fine grained details necessary invariants subject reduction proofs may complex 
notion principal prove useful results abstraction 
example easily give different operational semantics different principals reason interlanguage interoperability 
lifting constants values embeddings require wrapper code data conversions 
acm transactions programming languages systems vol 
november 
syntactic type abstraction similarly imagine embeddings represent form remote communication 
case putting values embeddings values require marshalling unmarshalling 
abadi cardelli curien 

formal parametric polymorphism 
th acm symposium principles programming languages 
acm press new york ny 
abadi plotkin 
model polymorphism 
th annual symposium logic computer science 
ieee computer society press los alamitos ca 
coquand gunter winskel 
di domains model polymorphism 
mathematical foundations programming language semantics main melton mislove schmidt eds 
lecture notes computer science vol 

springer verlag new york ny 
coquand gunter winskel 
domain theoretic models polymorphism 
inf 
comput 
may 
crary 
simple proof technique certain parametricity results 
th acm international conference functional programming 
acm press new york ny 
girard lafont taylor 
proofs types 
cambridge university press cambridge uk 
harper 
simplified account polymorphic 
information processing letters august 
heintze riecke 
slam calculus programming secrecy integrity 
th acm symposium principles programming languages 
acm press new york ny 
leroy 
security properties typed applets 
th acm symposium principles programming languages 
acm press new york ny 
ma reynolds 
types abstraction parametric polymorphism part 
proceedings mathematical foundations programming semantics brookes main melton mislove schmidt eds 
number lecture notes computer science 
springer verlag new york ny 
macqueen plotkin sethi 
ideal model recursive polymorphism 
information control october november 
milner tofte harper macqueen 
definition standard ml revised 
mit press cambridge ma 
mitchell 
equivalence data representations 
artificial intelligence mathematical theory computation papers honor john mccarthy lifschitz ed 
academic press san diego ca 
mitchell plotkin 
types existential type 
acm transactions programming languages systems july 
morrisett 
compiling types 
ph thesis carnegie mellon university 
published cmu tech report number cmu cs 
myers 
jflow practical static information flow control 
th acm symposium principles programming languages 
acm press new york ny 
nielson nielson 
level functional languages 
number cambridge tracts theoretical computer science 
cambridge university press cambridge uk 
peyton jones hughes augustsson barton boutel fasel hammond hinze hudak johnsson jones launchbury meijer peterson reid runciman wadler 
haskell non strict purely functional language 
www haskell org 
pierce sangiorgi 
behavioral equivalence polymorphic pi calculus 
tech 
rep ms cis university pennsylvania 
apr 
summary th acm symposium principles programming languages 
acm transactions programming languages systems vol 
november 
dan grossman pitts 
relational properties domains 
inf 
comput 

pitts 
parametric polymorphism operational equivalence 
mathematical structures computer science 
reynolds 
theory type structure 
programming symposium 
lecture notes computer science vol 

springer verlag new york ny 
reynolds 
types abstraction parametric polymorphism 
information processing mason ed 
elsevier science publishers 
north holland amsterdam 
sewell vitek 
secure composition untrusted code wrappers causality types 
progress www cs purdue edu homes jv html 
strachey 
fundamental concepts programming languages 
unpublished lecture notes summer school computer programming 
volpano smith 
type approach program security 
tapsoft theory practice software development 
lecture notes computer science vol 

springer verlag new york ny 
wright felleisen 
syntactic approach type soundness 
inf 
comput 

preliminary version rice tech 
rep 
zdancewic grossman morrisett 
principals programming languages syntactic proof technique 
th acm international conference functional programming 
acm press new york ny 
received february revised september accepted november acm transactions programming languages systems vol 
november 
