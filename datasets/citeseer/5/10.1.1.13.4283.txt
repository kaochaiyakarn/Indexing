journal circuits systems computers vol 
petri nets design veri cation asynchronous circuits systems alex university aizu aizu japan jordi univ de catalunya barcelona spain michael university aizu aizu japan luciano lavagno politecnico di torino torino italy alexander taubin university aizu aizu japan petri nets powerful formalism modeling concurrent systems 
capable implicitly describing vast state space succinct representation gracefully captures notions causality concurrency con ict events 
petri nets chosen authors formalism describe behavior asynchronous circuits interpreting events signal transitions term signal transition graph stg 
design framework asynchronous systems involves main aspects formal speci cation veri cation synthesis 
review main techniques cover aspects years special focus asynchronous circuits 
synchronous hypothesis stating computation communication take zero time events happen discrete points time quite rigid match physical reality 
enabled digital circuit design incredible progress years 
asynchronous hypothesis stating precise assumption time computation communication take apparently exible closer reality 
role digital circuit design marginal 
believe main reason lack widely accepted established design ow asynchronous circuits sound mathematical model exactly finite state machines boolean algebra foundations cad supported synchronous digital design possible 
purpose review results asynchronous circuit analysis synthesis sound mathematical model yield ecient automated tools 
sucient bring asynchronous circuits mainstream logic design require deep change way design carried hope help promote idea asynchronicity synonymous black magic longer 
mathematical model interpretation widely known petri net pn model pn transition models circuit signal change 
show means examples real ctitious known problems speci ed form solved terms analyzing speci cation properties terms generating logic circuit implementation 
class asynchronous circuits consider called speed independent pioneering muller 
class computation takes priori unbounded amount time communication assumed take small precisely smaller computation amount time 
may appear unrealistic modern vlsi technology communication large chip take longer gate switching 
consider useful point point single receiver communication modeled computation delay loss generality possible enforce communication protocols ensure dependency communication delays protocols generically termed delay insensitive enables restricted described section boolean optimization eciently implement circuit 
hypothesis optimization capabilities applicability asynchronous logic altogether delay insensitive circuits non existent synthesis techniques amount little syntax driven translation speci cation language peephole optimizations 
consider design ow asynchronous circuits see 
formal speci cation asynchronous circuits behavior speci cation system top design ow block 
stg model inherits asynchronous semantics pns naturally specifying behavior target asynchronous implementation 
approach illustrated considering design examples 
pns bottom design ow block 
circuit module netlist gates syntactically translated pn called circuit pn 
pn veri cation circuit optimization resynthesis 
veri cation asynchronous circuits veri cation di erent stages design corresponding blocks marked 
system speci ed answer question implemented asynchronous circuit 
requires veri cation implementability properties block 
iterative loop changing speci cation implementable 
changing speci cation designer information violation implementability properties provided veri cation process 
correct circuit gate netlist behavior pn circuit synthesis implementability checking engineering reverse specification pn design hazards 
circuit analysis specification pn top bottom translation pn pn usage design ows implementability conditions known literature formulated terms pn markings 
approach requires reachability analysis pn stg explicit generation reachability graph binary encoded version state graph complex highly concurrent behavior 
known techniques ght state explosion problem behavioral analysis petri nets 
symbolic binary decision diagram bdd traversal reachability graph allows implicit representation generally compact explicit enumeration states 
methods avoid generation corresponding reachability graph considering nite pre equivalent occurrence net 
pre called unfolding acyclic net places input transition 
mainly concentrate approaches property veri cation pns veri cation certain properties complemented stubborn sets partial order techniques 
approaches asynchronous circuits veri cation pns similar formalisms 
circuit synthesized implementation veri cation required checking implementation circuit conforms speci cation block 
pn framework problem viewed comparison pns pn describing speci cation circuit pn corresponding implementation 
implementation veri cation hand crafted designs automatically synthesized circuits synthesis method correct construction debugging synthesis checking physical implementation corresponds design assumptions correct construction synthesis methods 
task considered comparison pns representing speci cation derived circuit 
correct design circuit pn conform speci cation 
circuit implementation may require verify properties 
example asynchronous circuit free hazards short spurious pulses outputs gates block 
done way top design module translating circuit speci cation corresponding pn synthesis optimization asynchronous circuits signal transition graph produce net list asynchronous controller target gate library preserving speci ed input output behavior 
di erent routes synthesis 
rst approach syntax directed translation pn veri ed certain implementability properties circuit 
direct translation approach easy implement practical cases hardly yield elegant compact solution 
shortly discusses direct translation methods going challenging synthesis approach details structural methods refer survey 
alternative synthesis procedure way similar classical logic design nite state machines 
seen set equivalent transformations original speci cation means event insertion satisfy implementability properties 
includes state assignment solving complete state coding problem coupled logic minimization technology mapping target library 
related approaches 
methods theory state regions provide ecient framework solution tasks allow treat uniformly large sets markings 
state regions suited symbolic manipulation 
methods discussed section 
basic notions hp petri net pn set places set transitions ow relation initial marking 
transition enabled marking input places marked 
enabled transition may re producing new marking token input place token output place denoted 
new marking transitions enabled 
talk sequences transitions re markings reachable initial marking sequences transitions called feasible traces simply traces 
set input places transition denoted set output places 
similarly stand sets input output transitions place place called choice place output transition 
choice place called free choice output transitions input place 
pn free choice choice places free choice 
set markings reachable initial marking called reachability set graphical representation called reachability graph rg 
example pn reachability graph shown choice places pn free choice places consequently pn free choice 
reachable marking pn token marking reachability graph contains place 
pn concurrency 
pn called bounded reachable marking number tokens place greater place called bounded reachable marking number tokens veri cation analyzing partial order techniques state graph derived circuit ecient practice 
pn rg sg stg qq example pn stg greater bounded nite bounded safe bounded bounded place called safe place transition called non persistent enabled reachable marking transition disabled ring non persistency respect called direct con ict pn persistent contain non persistent transition 
pn transitions enabled initial marking 
firing disables pn non persistent 
show application pns digital circuit design consider signal interpretation pns called signal transition graphs 
model widely asynchronous design specifying control circuits 
signal transition graphs pns transitions interpreted changes circuit signal levels 
signal transition represented th transition signal th transition generic name rising falling transition sa denotes set signals stg divided input output internal signals 
de nition stg triple hn sa pn sa set signals sa partially de ned labeling function 
transition unde ned label called dummy transition 
de nition stg di ers de nition ways 
limit class pns free choice pns allows dummy transitions 
example stg shown stg obtained labeling transitions pn signal transitions 
drawn shorthand form transitions denoted labels bars places input output transition omitted 
follow origin stg model change maps signal graphs 
worthwhile mention related models change diagrams labeled marked graphs 
req rw ack req rw ack rw req ack address data control data req req ack ack read cycle write cycle read cycle write cycle req rw ack req rw ack speci cation asynchronous petri nets interpretation pn transitions changes binary signals allows introduce binary encoded reachability graph 
graph called state graph sg 
historically sgs appeared independently earlier pns 
formal language pioneering muller specify behavior called speed independent circuits 
de ning sg supplementary model stg encoded reachability graphs gives nice opportunities event stg state models sg design ow 
advantages approach clear sections 
sg directed graph vertices correspond markings reachability graph 
sg vertex labeled boolean vector hs representing value stg signals number signals stg 
vector called state 
states corresponding markings connected edge sg reachable ring event stg 
transition called enabled state signal called enabled state transition enabled called stable disabled 
example sg stg shown marks enabled signals sg state 
overview design methodology section presents simple example illustrating design asynchronous circuit interpreted petri nets 
informal methodology discussed detail sections 
shows behavioral speci cation asynchronous bus controller 
timing diagrams read write cycles describe temporal behavior terms signal transitions events 
diagrams show di erent types relations events choice read write cycle controller initial state causality pairs ordered events req ack concurrency pairs events req rw read cycle occur order 
petri nets appropriate capture previous relations behavioral model 
interpreted petri net signal transition graph controller speci cation shown implementation controller follow conventional scheme separating design datapath design control part 
datapath regular part generally built composing reusable units registers alus multipliers units asynchronous composition require di erent design methods consider see 
hand controller generally irregular dicult reuse assemble eciently basic components larger standard logic gates 
logic design control parts main target methodology review 
illustrate design steps means bus controller 
speci cation see section 
stage formalize notion going implement 
output speci cation step stg describing control part veri cation see sections 
veri cation generally means gain con dence formal speci cation contain error 
absolute con dence obtained due impossibility model errors con dence absence increased checking simple properties new request produced done set phase rising request followed reset phase falling request properties analysed construction binary encoded graph called state graph see section 
easy check state graph controller con rms correctness original speci cation 
synthesis see section state graph satis es implementability conditions checked veri cation step de nes truth table signal stg 
conventional logic minimization techniques derive logic equations non input signals 
logic equations correspond arbitrary boolean functions may available gate library 
functions decomposed simpler components directly matched library gates 
step called technology mapping non trivial asynchronous design decomposition may introduce hazards circuit implementation 
non input signal controller signal ack logic equation ack req ack rw 
di erent implementations ack obtained speed independent technology mapping shown speci cation circuits show pns top design methodology design ow starts behavior speci cation ends circuit implements 
approach illustrated examples 
discuss pns bottom design ow 
ow starting point set library blocks extracting behavior speci cation useful veri cation optimization resynthesis 
set dominant latch 
set dominant latch basic block logic design 
similar conventional sr latch inputs set reset output output goes high set input asserted goes low reset input asserted set input low see 
note due asymmetry latch behavior combination input values feasible latch operation latch robust conventional sr latch combination forbidden 
easy see behavior speci ed stg implemented set dominant latch 
stg logic equation latch output derived 
weak dominant latch set dominant latch implementation consumer producer problem 
consider implementation control system multiple consumers single producer 
consumers synchronized producer bu er restricted capacity 
simplest case capacity bu er equals consuming process requires piece production bu er producer start working piece consumed bu er empty 
means system operating requests consuming idle request 
input output behavior control unit consumer producer system speci ed signals input requests consuming th consumer con prod output consuming producing respectively 
assume consumer produce request time choice requesting consumers non deterministic 
means away speci cation reason environment may decide consumers 
abstraction non determinism powerful mechanisms simplify analysis synthesis tasks complex concurrent systems 
control unit communicates environment handshake fashion 
consumer produced request granted con 
granted consumer removes request control unit waits synchronization producer prod report nishing consuming con restart process initial state 
process consumer system speci ed stg shown note req req rising transitions distinct request signals con con transitions signal 
means distinct pn transitions physical interpretation 
req csc conflict req con prod conp prod req req con con req req stg consumer producer system sg purpose optimization share logic controlling di erent consumers possible 
part handshake communication event con common processes 
approach clearly di erent distributed control implementation event duplicated consumer process 
implementation control unit consumer producer system discussed sections 
railway control 
consider imaginary ring railway sections trains see 
trains move direction transport goods 
speed time loading unloading constrained way necessary appropriate control guarantee safety railway 
assume trains motion free section 
delay processes arbitrary problem semantics control circuit asynchronous design 
tk sk ring railway trains signals ft denote location trains sections 
ti train th section ti train signals fs denote states semaphore th section si semaphore open si closed 
task control circuit produce output signals controlling semaphores values detectors current state semaphores 
derive causal relations events railway 
clearly train appears th section event ti means time leaves th section event 
fact train non zero length shall consider rst appears th section detector reset arrival train th section complex event ti train passes th section arrived th section complex event ti happened semaphore open 
safety trac requirements follows semaphore th section si opened train left th section event semaphore closed soon train appears th section ti 
casual dependencies graphically shown railway system sections generated see 
sections discuss get correct control circuits stg 
ti tit si ti sit si behavior speci cation safe trac railway 
initial marking indicates trains initially sections 
dining philosophers 
known problem sharing resources forks concurrent processes philosophers 
system contains forks eating spaghetti philosophers sitting table see system philosophers 
eat spaghetti philosopher needs forks left right 
clearly philosopher eating left right neighbor missing fork wait philosopher nishes frees forks 
left right forks philosopher independent actions take fork wait free 
ignore sake simplicity italian table manners require eating protocol 
eating philosopher returns forks simultaneously 
re ne classical formulation allow philosopher return forks independently 
gives additional exibility describing philosopher behavior 
example standard wise fair philosopher describe malicious philosopher intentionally delay returning forks annoy neighbor 
section see complication crucial consequences complexity veri cation 
speci cation philosopher behavior follows 
philosopher ready eat produces request eating eat takes left lf right forks rf available places respectively contain token 
eating eat philosopher returns forks lf rf returns initial state 
speci cation philosophers stg easily scalable philosophers 
eat lf rf eat lf rf eat lf rf eat rf eat lf rf eat lf rf lf dining philosophers circuit petri nets previous examples pns behavioral speci cation system designed 
possible application arises extract behavior system designed speci ed netlist gates logic equations 
set logic equations syntactically translated petri net 
pn looking bit awkward translated reachability graph corresponding sg token ow simulation 
sg new circuit synthesized 
suggests ecient way resynthesis optimization 
behavior circuit signal represented called signal cycle see 
places signal cycle denote markings signal value respectively 
transition re signal logic function signal opposite value 
show construct circuit pns logic equation signal 
cofactor boolean function respect de ned 
clearly states logic function equals speci ed 
transition signal cycle input places express condition 
transition ring pns semantics 
order express condition input places transition fp boolean function represented 
conjunctive normal form modeling disjunctive normal forms possible 
allows model circuit safe pn 
idea construction illustrated signal speci ed logic equation bc bc ab 
cofactor boolean function respect bc bc conjunctive normal form 
place models condition tokens arrive ring transitions removed similarly place models condition 
marked function equals transition re 
clearly change signal uence value places connected self loops arc denotes arcs 
condition ring transition way conjunctive normal form ac cb bb modeling circuit behavior pn latch 
latch asynchronous latch output takes value inputs takes value keeps value 
state function latch inputs output ab 
example bottom approach design consider circuit presents input latch output closed latch inputs inverters corresponding set logic equations shown boolean function output latch gives cofactors ab transition res place marked places marked res ab 
conditions require introduce additional places circuit pn realized directly transitions circuit pn corresponding latch inverters shown removing redundant arcs obtain stg observing behavior stg easy see latch performs synchronization parallel processes inputs 
ab ac bc bc bb cc ad modeling latch behavior circuit pn implementing pns asynchronous circuits speed independent circuits circuit interconnection logic gates 
gate composed instantaneous logic function evaluator delay attached function output see 
delays involved switching transmission signals gate connecting wire prior fork assumed reduced output delay 
skew signals fork due wire delays assumed minimum gate delay 
delay induced wire may modeled explicitly needed inserting auxiliary component bu er wire break 
asynchronous behavior exact value bounds delays unknown pessimistic assume circuit delays gates nite unbounded 
circuit behavior correct values gate delays called speed independent 
consider design speed independent circuits delay function evaluator model circuit gate state circuit binary vector signal values outputs gates input nodes 
behavior ith gate described boolean equation values signals nodes corresponding inputs ith gate delay value logic function ith gate 
signal stable state value state equal value computed logic function 
signal said enabled 
example gate output input enabled state enabled signal change value 
generates dynamic behavior circuit transitions initial state states 
key issue correctness asynchronous circuit operation hazard freedom 
hazard appears pulse possibly short spike correspond signal transitions speci cation 
example hazardous behavior shown 
circuit implements output xor function inputs inputs transition speci cation output stay 
circuit deviate hazard may occur 
reason hazards asynchronous circuit signals propagate inputs outputs di erent delays compete 
consider example circuit note design styles asynchronous circuits pn possible see methods synthesis bounded delay circuits 
slow transition cube xor hazards logic circuit output upper gate changed output gate enabled change 
depending relative delays gates circuit may output bottom gate changes rst 
race inputs gate lead short spike output 
speed independent circuits correct distribution delays free hazards 
speed independent circuit enabled signal disabled changing value 
hazard previous example occur output disabled due changes gate inputs case gate output switch depending gate delay 
property proper disabling characteristic speed independent circuits 
implementability order analyze implementability stg circuit introduce notion equivalence pns turn inducing equivalence notion equivalence circuits 
notions equivalence may vary depending required level detail internal signals circuit matter 
behavior pns compared comparing languages generated pns language pn de ned usual set feasible traces 
start informally establishing forms equivalence pns strong equivalence 
pns strongly equivalent number transitions nets languages sets feasible traces coincide transition renaming 
trace equivalence 
set transitions pn rst partitioned observable external non observable internal transitions 
pns trace equivalent languages coincide renaming observable transitions non observable transitions removed feasible traces 
contrary strong equivalence trace equivalence allows map transitions pn transition ignore internal transitions checking equivalence observable external transitions 
internal behavior pns quite di erent number ring transitions long external behavior stays 
similarly talk equivalence stg circuit implementation comparing respective languages comparison possible circuits weaker notion conformance de ned hierarchical veri cation 
topic outside scope review 
de ne feasible traces signal transitions represented state graphs 
say stg gate implementable logic circuit strongly equivalent implementable logic circuit trace equivalent gate implementability condition guarantees circuit number signals stg additional internal signals required implementing speci cation 
signal circuit associated boolean function implemented complex gate word gate de nition 
practice complex gates large physically implementable single cell gate library decomposed 
design step called technology mapping performed introducing hazards circuit considered 
case circuit implementing stg gates number signals initial stg speci cation 
reasons 
initial stg speci cation de nes behavior implemented set logic gates adding state signals explained section 
logic decomposition complex gates smaller ones introduces internal signal nodes circuit 
implementability condition captures equivalence stg circuit observable external behavior 
add pre si say stg si implementable si gate implementable circuit implementing stg speed independent hazard free 
properties required implementability section discuss properties stg speci cation related implementability redundancy boundedness consistency determinism signal transition persistency 
redundancy boundedness determinism place redundant removal change language pn set feasible traces 
redundant places contribute trace behavior pn removed altering speci cation 
sake simplicity consider irredundant pns 
irredundant speci cation implemented logic circuit nite state space boundedness underlying irredundant stg necessary condition implementability 
stg corresponding sg called deterministic respect signal transition state state 
sg corresponding stg deterministic deterministic signal transitions 
consider deterministic circuits determinism speci cation necessary condition implementability 
redundant stg speci cation produce nite marking space implementable 
trivial example obtained inserting stg additional place live transition 
place unbounded new stg ect behavior transition 
consistency bounded stg interpreted speci cation set circuit gates 
assume example sequence feasible stg 
ring signal logical correct interpretation suggested transition 
property consistency state assignment guarantees problem occurs 
stg corresponding sg consistent feasible trace initial state rising falling transitions alternate signal 
speci cations considered far consistent 
stg bounded consistent deterministic implemented circuit 
additional state signals may required resolve state con icts 
complete state coding csc illustrate example consumer producer system inserting state signals necessary 
binary encoded sg corresponding stg specifying system consumers shown states encoded binary code di erent value output signal prod state signal prod stable high state enabled fall 
de nition state function signal prod require contradictory values due rst state due second state binary vector 
circuit boolean functions corresponding output signals con prod implement stg pair states sg binary encoding di erent enabling non input signals said complete state coding csc con ict 
stg corresponding sg satisfy complete state coding property pair sg states encoding di erent non input signals 
bounded consistent stg non input signals csc property implemented circuit arbitrarily complex logic gates 
csc con icts resolved encoding corresponding states additional signals 
signals distinguish csc con icts assigning corresponding states di erent binary codes 
ective procedure inserting additional signals resolve csc con icts 
procedure preserves trace equivalence speed independence original speci cation converges safe 
persistency properties considered restrict hazards implementation 
capture speed independence requirement stg level consider signal persistency property signal persistency similarly speed independence de ned circuits means stg signal enabled res independently ring signals distinguish input non input signals 
inputs controlled environment possible non deterministic choice represented stg say stg sg consistent state assignment 
notion persistency related 
shown loosely connected number cubes sum products implementation signal 
consider stg speci cations implemented non deterministic circuits arbiters 
see detailed discussion 
model con icts disabling input signal input signal 
input con icts se imply hazardous behavior 
non input signals produced circuit gates signal transition disabling may lead hazards output gate discussed making circuit behavior dependent gate delays 
disabling input transitions non input transitions hand considered dangerous lead hazards logic implementation environment de nition sg corresponding stg signal persistent 
non input signal disabled signal 
input signal disabled non input signal 
bounded consistent deterministic signal persistent stg implemented speed independent circuit 
signal persistency transition persistency see section closely related 
clearly source signal non persistency signal non persistency transition labeled 
non persistency leads violation persistency signal transitions labeled non persistent 
signals persistent corresponding sg ring disables enables transition 
ring signal remains enabled 
sets feasible traces behavior signals equivalent concurrent ring 
stg sg 
conclude signal con ict transition fake 
fake free signal persistency transition persistency coincide signal persistency checked transition persistency stg level generating state graph 
shown fake con icts non input signals replaced concurrency stg speci cations excluding fake con icts restrict expressiveness stg speci cations 
abc 
transition signal non persistency summary conclude bounded consistent deterministic stg implementable logic circuit logic implementation environment hazardous presence input input disabling 
considered acceptable non determinism result abstraction environment behavior speci cation purpose simplifying stg model 
environment general persistent speci cation order implementable hazard free logic circuit 
distinguished necessary true concurrency semantics interleaving 
gate implementable satis es csc requirement si implementable signal persistent 
state veri cation properties stg implementability formulated section terms sg states 
explicit manipulation sg problematic exponential growth size respect number signals 
developments symbolic techniques reachable state space traversal binary decision diagrams bdds applied avoid explicit manipulation state set soften space explosion problems :10.1.1.119.326
modeling bounded petri nets boolean functions hp safe petri net set markings jp jm 
marking represented boolean vector denotes marked marked set markings mp represented characteristic logic function equals vectors correspond markings example petri net depicted characteristic function set markings calculated disjunction boolean vectors resulting function 
transition function petri net function mp mp transforms transition set markings new set markings follows fm set markings transition function calculates new set markings reachable step computation transition function eciently implemented structural information pn 
give expression transition function introduce characteristic functions important sets related transition enabled asm successors marked npm predecessor marked nsm successor marked 
function asm states input output places transition contain token function npm nsm states input output place contains token 
recall useful de nitions theory boolean functions 
boolean function variables 
cofactor respect literal cofactor respect literal 
notion cofactor generalized set variables existential abstraction respect restriction safeness considered clarity 
unsafe bounded places represented framework boolean variables 
express set markings reachable set markings considering transition marking enabled symbolic representation follows 
npm nsm 
asm existential quanti cation formula gives set markings reachable ring enabled transition marking denotes cofactor boolean function respect set boolean product literals example 
assume example calculate req set req cofactor respect req selects markings req enabled removes predecessor places characteristic function req 
product npm req eliminates tokens predecessor places req 
npm req 
cofactor respect nsm req removes successor places obtaining req 
npm req nsm req 
product asm req adds token successor places req 
hn sa stg underlying petri net 
sg corresponding set binary states correspondence markings states represent full state stg vector marking state code corresponding state respectively 
transition function extended function mp mp set full states de ned follows 

verifying si implementability symbolic traversal stg implementability properties veri ed calculating reachable markings states stg 
initial marking initial values signals set states stg calculated symbolic traversal techniques similar veri cation nite state machines 
describes algorithm symbolic traversal 
starts initial full state 
outermost iteration transitions petri net visited red new states far 
algorithm halts xed point reached new states generated 
safeness boundedness 
calculation reachability space symbolic traversal done assumption petri net safe 
calculation erroneous markings unsafe unsafe markings representable encoding place signal 
traverse stg reached repeat endfor new reached reached reached new new new return reached set reachable states algorithm symbolic traversal stg detecting unsafe marking reachable done identifying marking transition enabled successor place predecessor marked 
situation ring transition place tokens 
idea implemented algorithm 
safe succ enabled reached 
reached set reachable markings succ succ enabled 
succ return false return true algorithm safeness checking bounded place represented set boolean variables encode possible number tokens 
number required variables depends type encoding 
hot encoding variables needed 
example bounded petri net number tokens place represented variables 
binary encoding dlog variables required see tab 

tokens hot encoding binary encoding table encoding bounded places worst thing traversal unsafe stg bound number tokens transition persistency jp enabled 
enabled error disabled algorithms verify persistency place guessed advance order compute transition function 
case guessed bound place exceeded traversal restarted new de nition state non safeness problematic property state art bdd techniques 
consistency 
verifying stg consistent done traversal checking consistency newly generated states 
rst de ne characteristic function enabled characteristic function states inconsistent assignment derived de nition consistency cf 
section inconsistent 
enabled inconsistent 
enabled inconsistent inconsistent inconsistent inconsistent sa inconsistent call set reachable states markings binary codes stg inconsistent inconsistent 
persistency 
fake free stg transition persistency coincides signal persistency 
analyze persistency stg sucient analyze absence direct con icts involving non input transitions 
algorithm check transition persistency shown 
note transitions common predecessor place direct con ict 
algorithm reduce search 
set reachable markings set markings enabled calculated 
set markings reachable step ring transition obtained 
enabled markings persistent 
complete state coding 
csc requirement checked non input signal de ning characteristic functions er 
er 
qr 
qr 
denotes existential abstraction respect set variables representing places pn operation removes variables corresponding boolean functions 
er set binary codes correspond states enabled set excitation regions 
obtained abstracting places states excitation region 
qr set quiescent regions set binary codes correspond states enabled similarly qr 
csc con ict occurs sg states binary code non input signal enabled rise stable enabled fall stable means state belongs excitation region belongs quiescent region signal 
binary code characteristic functions excitation quiescent regions intersect 
csc requirement non input signal checked follows csc er qr er qr csc non input csc example 
example consumer producer system set states signal prod stable equal quiescent region prod see 
set states prod enabled equal excitation region prod single state 
intersection excitation region quiescent region non empty indicating presence csc con ict see due states code 
determinism fake con icts 
determinism fake con icts easily checked manipulations characteristic boolean functions 
section showed properties related stg si implementability checked symbolic traversal reachability space 
surprising set reachable states naturally contains information needed implementation stg 
ort required symbolic traversal reachability space manipulated implicitly check properties complex formulation 
implicit representation reachability set size corresponding bdd exponential respect size original stg 
examples event approach developed section ecient 
symbolic representation binary decision diagrams section brie explain sets states represented means boolean functions eciently manipulated binary decision diagrams bdds 
place petri net bdd representing set reachable markings place encoding 
bdd directed acyclic graph root leaf nodes 
non leaf node labeled boolean variable outgoing arcs labels 
bdd represents boolean function interpreted follows variable assignment corresponding path goes root node leaf nodes 
label leaf node value function assignment 
example bdd depicted represents function value function assignment 
assignment corresponds path 
refer reader details manipulate boolean functions eciently means bdds 
illustrates reachability set markings pn represented bdds 
example relies fact ecient encoding represent reachable markings 
strategy encoding observation sets places sm fp sm fp sm fp state machines pn 
information structurally obtained algebraic methods 
state machines correspond pn preserve token count reachable markings 
initial marking net places state machine marked marking 
encoding proposed boolean variables encode token sm boolean variables sm boolean variable sucient sm sm encodes distinguished 
proposes encoding places way set reachable markings represented boolean function note function corresponds reachable marking function 
examples markings represented sets marked places encoded fp fp unreachable marking representation basic operations sets states union intersection complement mimicked boolean operations boolean functions 
functions compact representation 
event veri cation 
unfolding approach methods partial orders known techniques avoid state explosion problem behavioral analysis petri nets pn 
reachability graph nite pre called unfolding equivalent occurrence net acyclic net places input transition generated 
consider application unfolding approach veri cation tasks bdd methods section techniques unfortunately incomparable terms eciency dicult tell priori better special properties subclasses pns 
viewed complementary completely independent 
petri net unfolding cyclic acyclic pns 
call pn acyclic cycles graph pn 
acyclic pn places input transitions 
assume places initially marked token places initially marked 
examples cyclic acyclic pn shown de nition ordering relations hp acyclic pn precedes denoted belongs re exive transitive closure path graph pn con ict denoted exist distinct transitions concurrent denoted jjx precedence con ict 
consider relations example acyclic pn directly de nition nd jjp jjp acyclic pns easier analyze properties completely speci ed ordering relations 
suggests ective way analyze manipulate general pns rst cyclic pn unfolded equivalent acyclic net nite pre acyclic net 
particularly convenient unfold pn special kind acyclic pn called occurrence net place input transition 
shows occurrence net pn transition ti place pj initial pn set corresponding transitions places occurrence net ti ti ti pj pj pj called instantiations ti pj 
shown partition associates transition pn instantiations original pn trace equivalent occurrence net 
refer object occurrence net equivalent object original cyclic pn adding adding superscript name 
example corresponding transitions occurrence net pn marking occurrence net corresponding marking pn 
occurrence net unfolding 
occurrence net cyclic pn nite possible bounded pn truncate occurrence net nite complete subgraph unfolding carries amount information 
need introduce notions order de ne truncation 
de nition con gurations 
set transitions con guration occurrence net 
con guration contains predecessors 
contains mutually con icting transitions 
minimal con guration contains transitions preceding called local con guration transition denoted con guration corresponds marking called nal marking reachable transitions red 
nal marking local con guration called basic marking denoted bm occurrence net pn fig 
local con guration transition equal fa basic marking bm fp marking fp correspond local con guration corresponds con guration fa cut occurrence nets truncated cut transitions 
criteria choosing transitions di erent classes pns suggested 
necessary condition transition cut basic marking repeats basic marking transition generated earlier occurrence net called image 
intuitively means ring generates marking original pn reached ring shown precautions taken determining cut de nition transition occurrence net cut transition exists transition 
bm bm 
adequate partial order 
simplest partial order de ned integer ordering size de ned number transitions con gurations 
elaborate ecient cut criteria de ned 
unfolding obtained occurrence net removing places transitions follow cut unfolding corresponding pn shown basic markings pointed near transitions 
easy see transitions basic marking pn cut image parts occurrence net see cut absent unfolding 
shown reachable marking original pn lost unfolding 
adequate partial order needed metrics set con gurations 
di erent subclasses pns di erent partial orders proposed see diagram unfolding size safe general cd kkt esp kkt mcm simplicity class pn di erent cut criteria number transition instantiations change diagrams kkt size con gurations number transition con guration mcm comparison parikh vectors normal form con gurations safe pns esp enhanced cut kkt cut criteria general ecient terms size generated unfolding 
criterion esp optimal sense allows de ne total order transitions basic marking 
time transitions basic marking generated unfolding de ned cut unfoldings obtained method minimal size 
shortcoming roughly speaking cd models causality causality concurrency con icts 
practice roughly comparable marked graph 
approach restriction class safe pns enhanced cut general pns guarantee minimal size unfoldings 
size unfolding obtained enhanced cut criterion typically smaller size rg pn 
example users distributed mutual exclusion dme arbiter rg contains approximately markings unfolding contains transitions 
checking implementability properties unfoldings boundedness 
shows example unbounded pn 
place unbounded trace generate unbounded number tokens 

unbounded pn occurrence net 
unfolding pn unbounded transition instantiations bm bm 
checking boundedness pn reduced analysis precedence relation transitions unfolding 
return example 
soon transition generated unfolding conclude original pn unbounded 
instantiations transition bm bm marking place grow inde nitely place unbounded 
persistency 
unfolding gives explicit representation con icts 
pair con icting transitions non persistent direct con ict 
example con icting transitions pn share input place disable 
con icting transitions direct con ict share input place enabled simultaneously 
structural properties direct con icts stated follows direct con ict occurs transitions share input place predecessors con ict direct con ict occurred predecessors 
transition persistency check reduced analysis con ict relations transitions unfolding 
extension method unsafe nets proposed experimental results known 
pn direct non direct con icts example pn transitions direct con ict direct predecessor con ict ft direct con ict 
stg non deterministic transitions label direct con ict 
clearly particular case non persistency 
similarly fake con icts stg checked direct con ict relation 
consistency 
consistency property states ring sequence stg rising falling transitions signal alternate 
analyze unfoldings need formulate consistency terms ordering relations events 
de nition 
unfolding stg called auto concurrent contains concurrent transitions labeled signal 

unfolding stg sign alternating pair rising signal transitions exists falling transition 
similarly falling transitions 
stg shown transitions concurrent 
trace feasible 
ring signal logical transition signal negative 
trace contains positive transition 
shows auto concurrency captures features consistency 
example 
illustrate importance auto concurrency sign alternation return railway example rail sections section part unfolding 
notice events si si concurrent unfolding see 
case railway system sections 
reason di erence behavior sections trac trains strictly synchronized train move relatively section 
sections system freedom motion increases seemingly speci cation shows inconsistencies implemented 
eliminate problem change speci cation allow train appear th section strictly semaphore previous section closed 
ti 
obtained stg shown consistent implemented speed independent circuit 
note complication system introducing sections lead incorrectness corresponding stg keeps implementability properties 
auto concurrency sign alternation allow check consistency signal transition instantiations unfolding 
see return example shown suppose transition removed stg places cutoff cutoff ap stg inconsistent state assignment unfolding 
inconsistent consistent speci cations railway system 
remaining part unfolding non auto concurrent sign alternating feasible trace shows violation consistency 
fact explicitly observed unfolding information transition signal 
problem solved considering binary states corresponding basic markings 
marking unfolding stg mapped binary state values signals obtained ring transitions con guration corresponds marking say stg satis es proper state assignment property pair transitions equal basic markings corresponding binary states coincide 
statement gives necessary sucient conditions stg consistent 
bounded stg unfolding non auto concurrent sign alternating proper state assignment consistent 
proper state assignment property helps distinguish consistency violation unfolding initial state stg ring transitions reaches marking corresponding binary states di erent respectively 
reduced checking stg consistency analysis ordering relations unfolding 
auto concurrency sign alternation particular cases concurrency precedence relations binary states corresponding basic markings calculated locally binary states corresponding preceding transitions 
complete state coding 
property dicult analysis unfoldings 
csc con icts essentially de ned pairs binary states little hope check csc property completely analyzing reachability set 
alleviate diculty unfolding methods perform conservative check csc 
analysis approximation reachable state space testing sucient conditions ensure absence csc con icts 
case conditions satis ed sure stg csc property 
may case csc con ict really exists conditions overly conservative analysis produce false negative results 
exact analysis csc property currently better bdd approach described previous section 
section considered application unfolding technique veri cation speci properties related stg implementability 
unfolding analysis powerful restricted consideration special case veri cation simpler general case sucient decide applicability synthesis technique 
event vs state veri cation sections di erent approaches veri cation asynchronous systems 
approaches aimed checking properties quite di erent characteristics applications 
easy provide exact recipe apply methods 
try give hints comparing veri cation results obtained software tools bdd techniques unfolding unfolding methods 
note small moderate examples methods nearly equally analysis times small 
property expressed propositional logic extended possibility operator checked unfoldings 
table presents results checking stg implementability examples section 
example si impl 
si gate impl 
cpu unf remarks set dominant latch fig 
consumer producer fig 
non csc section railway fig 
section railway fig 
inconsistent modi ed section railway fig 
dining philosophers fig 
table veri cation results small examples cpu times seconds 
compare eciency event state veri cation consider scalable examples railway system sections dining philosophers 
cpu times sizes internal representations bdd case state veri cation unfolding event methods table 
bdd unfolding example places trans 
states size cpu sec 
places trans 
cpu sec 
sections railway hours dining philosophers hours table experimental results big size examples table clearly shows diculties direct comparison state event methods unfolding method superior bdd technique veri cation railway system bdd traversal ecient analysis dining philosophers example cases philosophers 
intuition ineciency unfolding methods veri cation dining philosophers 
common parts alternative branches pn duplicated unfolding roughly speaking unfolding grows width respect amount con icts 
concurrency di erent instantiations pn transition di erent basic markings due concurrency unfolding grows depth 
sequential process instantiations transition basic marking 
dining philosophers example characterized complicated structure con ict concurrency relations 
size unfolding quickly blows number philosophers increases 
note diculty arises re ned version dining philosophers problem returning left right forks considered independent actions 
classical version forks returned simultaneously concurrency behavior single philosopher unfolding method works eciently bdd technique 
observation class speci cations dicult unfolding approach far rigorous 
things vague talking eciency methods 
size bdds obtained symbolic traversal quite di erent depend factors 
important factors order signals bdd construction size bdd stg bad order signals exponentially larger ordering 
heuristics ordering signals size bdds di er orders magnitude stg speci cations approximately equal size 
bdds suitable regular speci cations scalable examples handle large examples unstructured speci cations bdd size generally blows faster 
comparison unfolding bdd approaches follows complementary techniques allow attack di erent sides veri cation problem asynchronous systems 
eciency depends di erent unrelated features speci cation technique fails succeed 
synthesis asynchronous circuits pns approaches designing asynchronous circuits syntax directed compilation logic synthesis shown 
transformations implementable equivalent stg implementable eventbased statebased sg set circuit primitives compiler stg verification implementation design stg speci cations syntax directed structural compilation compiles stg pn circuit syntax directed translation basis pre designed primitives 
circuit primitives model behavior stg fragments single places single transitions possibly larger fragments stg 
compilation process solves tasks matching stg elements corresponding primitives library assembling primitives proper implementation 
approach fast simple 
gives circuit implementations linear size original stg 
allows estimate complexity implementation early stage design process 
implementation inecient terms area performance 
restricts application structural synthesis methods 
synthesis approach respects opposite structural methods complex computationally expensive gives ecient implementations 
approach initial speci cation gradually re ned behavior signal implemented library gate 
re nement done means equivalent transformations inserting new signals performed directly stg level route corresponding sg route 
structural synthesis basic elements pn places transitions 
simulating pn behavior circuit done places transitions modeling basis 
modeling places 
simplicity consider safe persistent pns 
goal synthesis procedure achieve correspondence marking place value output signals corresponding binary value corresponding marking token token stored latch 
marking supposed change token ow corresponding latch changes stored value 
example circuit primitives place implementation pn shown 
marking place encoded values outputs rs latch follows token marked token marked 
activity gate triggers transmission token place places 
pn circuit primitive place implementation pn token ow pn fragment simulated circuit way 
initially place marked latch state latch state 
passing token starts switching activity gate 
forces latch change state unmarked marked going transient state events triggers latch move unmarked state events acknowledged cell modeling switching activity input event 
token shifted 
consideration follows atomic ring operation transition modeled circuit steps rst token appears erased 
lead confusion modeling process transient state token resides token ow stopped preventing activity gate switching gate set latch goes unmarked state 
basic primitive easily modi ed modeling complicated token ows 
output place join transition see token appear marked 
modeled ing falling events activity gates cells 
input place fork transition see token erased appears 
modeled ing falling transitions signals resetting latch 
note restriction safeness crucial suggested approach unsafe nets modeled similar way adding additional bu ers basic primitives 
non persistency modeled adding additional input variables environment 
thorough analysis pn structure possible simplify modeling circuit 
hopes get area ecient circuit approach low level granularity modeling pns general expensive model place separate latch 
approach useful fast prototyping asynchronous controllers synthesis time area delay cost crucial issue 
modeling transitions 
alternative way simulating pn behavior circuit consists modeling transitions 
simplest form ring transition modeled switching output corresponding circuit primitive 
direction switching rising falling irrelevant 
initially output odd ring transition corresponds ring corresponds kind modeling called phase 
rst complete set circuit primitives phase modeling pn behavior suggested patil dennis 
constructions simple elegant suitable safe persistent nets input place shared transitions 
restrictions partly removed safeness necessary modeling scheme 
transition implementation pn firing transition corresponds switching input element 
initially signals output rise rising signals model rings transitions 
occurrence transition modeled signal falling 
happens falling transition re second time rising successors nish rst rings 
negative feedbacks circuits modeling successor transitions prevent interference consecutive ring ows transition 
transition implementation typically area ecient place ecient logic techniques described section 
synthesis methods section gave formal conditions satis ed stg order implementable 
particular shown deterministic persistent consistent stg non input signals satis es csc property exists speed independent circuit gates behavior strongly equivalent original stg 
statement restrict way types gates circuit 
assumes implementation basis limited gates implement arbitrary boolean function called complex gates 
assumption looks unrealistic methods complex gate implementation interest due reasons 
complex gate implementation satisfy requirements real library see case examples considered far 

complex gate implementation starting point technology mapping methods decompose complex gates library blocks 

development asics fpgas implementation basis realize quite complex boolean functions cell xilinx fpga implement boolean function variables 
task complex gate implementation stg csc property obtain logic equations non input signals 
straightforward solution considers corresponding sg 
complete state coding requirement met non input signal stg sg de nes incompletely speci ed logic function sets boolean vectors set set states function evaluates set set states evaluates dc set don care set set states function speci ed 
dc set includes states reachable initial state sg 
de ne states belong set set considering called implied value signal value signal going take 
signal stable sg state belongs set set signal enabled state value opposite current belongs set current value set 
notation enabled signals rules shortly formulated follows state included set included set 
example 
illustrate synthesis procedure deriving logic equation set dominant latch section 
behavior speci cation form sg reproduced output signal equal stable initial state state belongs set keeps value enabled included set rules ll map signal shown derive logic equation rq conventional minimization techniques 
known equation sr latch 
synthesis performed directly stg 
methods approximation techniques similar discussed section 
complicated omit due lack space 
look details 
rq derivation logic equations set dominant latch circuits semaphore control railway system sections automatically derived method see figures table shown circuits railway control shown respectively 
see circuits parameters complex gates quite reasonable implementations realized real libraries 
implementations railway system control stg si implementable speed independent circuit trace equivalent stg 
speci cations rejected synthesis procedure changed hand satisfy implementability properties 
describe method satisfy csc requirement inserting additional state signals 
complete state encoding stg contains csc con icts disambiguated additional signals 
done inserting signal time con icts resolved iterative procedure formulated follows 
partition sg states subsets inserted signal value states set value states set rst formulated similar procedure attempted solve con icts 
suboptimal fail nd feasible solution cases 

insert new signal switch states nd subsets states inserted signal enabled re states respectively 

check new sg csc con icts iterate csc con icts 
introducing theory procedure consider informally works synthesis consumer producer system 
example 
csc con ict states sg separate con icting states partition shown req con con req req prod req req con con req req prod req req con req con prod conflict csc reduction csc form state state enter set state transition csc new signal csc enabled see insertion csc stg 
hand border states enter signal csc enabled 
means transition csc inserted concurrently transitions border states see 
stg obtained insertion signal csc satis es csc property implementation complex gates shown see logic functions implementation complicated case railway system controller complexity may exceed requirements gate library 
complex gate implementation decomposed simpler gates latches technology mapper see 
req req con csc prod req req map prod csc con map implementation control consumer producer system questions important csc elimination procedure nd bi partition sg states sets nd proper set states enabling inserted signal old newly inserted signals preserved 
answer questions section theory state regions 
speed independence preserving event insertion regions excitation regions switching regions 
subset states sg say transition enters transition exits transition cross region subset states transitions labeled event exactly entry exit relation 
relation predecessor successor relation petri net 
consider sg shown 
set states region transitions labeled enter transitions labeled exit transitions labeled cross hand set states shown dotted line region transition enters set transition labeled 
region aa bb region er excitation regions excitation regions sg region pre region event transition labeled exits region post region event transition labeled enters shows correspondence regions petri net places 
place corresponds region 
place input place transition labeled region pre region regions sg related places corresponding pn excitation regions related transitions pn 
set states called excitation region event denoted er maximal set states state er transition 
shown sg corresponding safe stg excitation region persistent transition obtained intersection pre regions transition 
sg excitation region er shown dotted line 
corresponds transition pn 
similarly er de ne switching region event set states reached immediately occurrence denoted sr 
insertion scheme 
informally event insertion operation selects subset states splits selected states states creates basis new states excitation switching region new event 
illustrates insertion scheme typically applications asynchronous design 
state signal insertion preserve si implementability properties original speci cation 
formally say set states er selected insertion new signal sr er er event insertion technique sg speed independence preserving set sip set sg obtained inserting event si implementable 
set states sip intersects state diamond cases shown 
state diamond quadruple states concurrent events re states shown 
sip sets state diamond properties insertion sets link regions sip sets 
shown si implementable sg set states sip 
region 
excitation region persistent event 
intersections pre regions event connected exit events persistent 
suggests candidates insertion sets sought basis regions intersections 
disjoint union regions region gives important corollary sets states selected insertion new events built eciently bricks regions sand states 
partitions borders 
return rst problem bi partitioning set states 
distinguish csc con icts sg bi partition states sets constructed 
con ict relation de ned pairs states requirements sip sets allow manipulate single states construction partition 
problem nding optimal sip partition maximizing number distinguished con icts intractable requires develop appropriate heuristics 
approach considering larger sets states constructing partition 
regions intersections pre post regions event candidates bricks looking sip sets individual states sand 
construct partition adjacent bricks combined form bigger blocks 
union bricks guided cost function takes account number distinguished con icts 
greedy block merging approach practice 
example 
sg pairs csc con icts partition distinguishing con icts constructed intersections post regions 
post regions transition regions shown dashed lines transition shown dotted lines 
intersections shown dashed areas union intersections gives set states included form cb bb bb ab aa br elimination con icts region approach bi partition set sg states excitation regions new signal 
new signal change value crossing borders exit input borders rst candidates excitation regions 
intuitively exit border partition block denoted eb subset states transitions exiting call eb formed transitions leading states eb back states eb 
exit border formed insertion consistency state assignment violated 
formedness necessary condition preserving si implementability properties 
partition fs possible nd minimal formed exit borders denoted 
example calculated point recursion 
eb 
example 
partition fs sg state transition exiting eb similarly eb exit borders shown dashed areas formed satisfy sip set requirements 
result insertion additional signal exit borders shown right 
resulting sg csc con icts implemented speed independent circuit 
circuit corresponds latch inputs inverters discussed section see 
example obtained bipartition distinguishes csc con icts original sg 
general iterations inserting signals required 
iteration speci cation re ned excluding con icts 
convergence procedure shown class sgs corresponding safe 
discussed various techniques speci cation analysis synthesis asynchronous circuits developed years interpreted pn speci cation called stg 
shown means examples function asynchronous control circuit speci ed stg existing asynchronous netlist modeled analysis re synthesis stg 
data path usually designed independently controlled control circuit form request acknowledge timing assumptions bundled data simplify control logic 
compared bdd versus unfolding analysis techniques 
summarized state encoding logic synthesis techniques asynchronous circuits 
hope review useful rst contribution establishment practical asynchronous circuit design ow second paradigm establishment interpretation petri nets synthesis classes asynchronous processes 
designer interested applying synthesis techniques examples guideline specify asynchronous controllers means tools theory described previous sections order implement control logic 
example tools available www ac upc es vlsi html 
data path hand designed semi synchronous techniques clock signals locally generated controllers 
standard physical design tools additional constraints arising need satisfy fork assumptions place route circuit 
information forks obtained directly pn veri cation techniques 
strongly believe scope application pns limited analysis simulation means formal techniques extended synthesis 
possible mapping interpretation net domain synthesis techniques developed boolean domain case interpreting pn properties persistence desirable dangerous implementation properties hazard freeness 
need enhance techniques summarized notion time order compete synchronous circuits take full advantage fact physical delays bounded 
area done aggressive ecient optimization needed 
design ow needs abstraction mechanism unfortunately general pns particularly lacking respect logic circuit abstraction boxes inputs outputs stg models sequencing events 
done needs development 
acknowledgments javier esparza pastor marco pena alex sergei peter alexandre useful discussions topics 
steve anonymous reviewers useful comments draft 
peter 
cad tools synthesis veri cation testability robust asynchronous circuits 
phd thesis stanford university 
randal bryant 
symbolic boolean manipulation ordered binary decision diagrams 
acm computing surveys september 
burns 
general conditions decomposition state holding elements 
international symposium advanced research asynchronous circuits systems aizu japan march 

chu 
synthesis self timed vlsi circuits graph theoretic speci cations 
phd thesis mit june 
lavagno 
complete state encoding theory regions 
international symposium advanced research asynchronous circuits systems aizu japan march 
lavagno 
synthesizing petri nets statebased models 
proceedings international conference computer aided design november 
lavagno 
designing asynchronous circuits behavioural speci cations internal con icts 
international symposium advanced research asynchronous circuits systems salt lake city utah november 
coudert madre 
veri cation sequential machines boolean functional vectors 
editor proc 
ifip int 
workshop applied formal methods correct vlsi design pages leuven belgium november 
desel esparza 
free choice petri nets 
cambridge university press cambridge great britain 

combinatorics traces 
lecture notes computer science volume 
springerverlag 
dill 
trace theory automatic hierarchical veri cation speed independent circuits 
mit press cambridge mass 
acm distinguished dissertation 
ehrenfeucht rozenberg 
partial structures part basic notions representation problem part ii state spaces concurrent systems 
acta informatica 
esparza 
model checking net unfoldings 

gaudel 
jouannaud editors tapsoft theory practice software development 
th int 
joint conference caap fase volume lecture notes computer science pages 
springer verlag 
esparza 
cuto criteria unsafe petri nets 
personal communication 

computing clocks arm processor 
graham birtwistle davis editors asynchronous digital circuit design workshops computing pages 
springer verlag 
godefroid 
partial orders improve automatic veri cation methods 
clarke kurshan editors proc 
international workshop computer aided veri cation 
dimacs series discrete mathematica theoretical computer science pages 
hack 
analysis production schemata petri nets 
technical report tr project mac mit 
hoare 
communicating sequential processes 
prentice hall 
xilinx xc data book 

omer esparza vogler 
improvement mcmillan unfolding algorithm 
lecture notes computer science vol 

springer verlag 
jump thiagarajan 
interconnection asynchronous control structures 
journal acm 
taubin 
concurrent hardware theory practice self timed design 
john wiley sons london 
taubin 
self timed behavior veri cation 
proceedings acm international workshop timing issues speci cation synthesis digital systems tau 
pastor 
checking signal transition graph implementability symbolic bdd traversal 
proc 
european design test conference pages paris france march 
lavagno 
technology mapping speed independent circuits decomposition resynthesis 
international symposium advanced research asynchronous circuits systems eindhoven april 
taubin 
structural approach analysis petri nets reduced unfoldings 
international conference application theory petri nets lecture notes computer sciences osaka japan june 
alex alexander taubin 
veri cation speed independent circuits stg unfoldings 
proc 
international symposium advanced research asynchronous circuits systems pages november 
lavagno sangiovanni vincentelli 
algorithms synthesis testing asynchronous circuits 
kluwer academic publishers boston 
lee 
representation switching functions binary decision programs 
bell system technical journal 

lin 
lin 
realization algorithm asynchronous circuits stg 
proceedings european design automation conference pages 
de micheli 
algorithms technology mapping binary decision diagrams boolean operations 
ieee transactions computer aided design may 
mcmillan 
technique state space search unfolding 
formal methods system design 
teresa 
meng robert brodersen david messerschmitt 
asynchronous design programmable digital signal processors 
ieee transactions signal processing april 
miller 
switching theory volume chapter pages 
wiley sons 
molnar 
fang 
synthesis delay insensitive modules 
chapel hill conference vlsi pages may 
muller 
theory asynchronous circuits 
annals computing laboratory harvard university pages 
murata 
petri nets properties analysis applications 
proceedings ieee pages april 
myers 
meng 
synthesis timed asynchronous circuits 
proceedings international conference computer design october 
nielsen plotkin winskel events structures domains 
theoretical computer science 
nielsen rozenberg thiagarajan 
elementary transition systems 
theoretical computer science 
pastor 
polynomial algorithms synthesis hazard free circuits signal transition graphs 
proceedings international conference computer aided design november 
pastor 
petri net analysis boolean manipulation 
th international conference application theory petri nets zaragoza spain june 
pastor jordi alex 
structural methods synthesis speed independent circuits 
proc 
european design test conference pages paris france march 
patil dennis 
description realization digital systems 
proceedings ieee compcon pages 
peterson 
petri nets volume 
acm computing surveys september 
petri 
kommunikation mit 
phd thesis bonn institut ur mathematik 
technical report des iim nr 

rozenberg simone 
survey equivalence notions net systems 
lecture notes computer science 
reisig 
petri nets 
eatcs monographs theoretical computer science 
springer verlag berlin 
jordi pastor 
hierarchical gate level veri cation circuits 
asynchronous design methodologies pages may 
rosenblum 
signal graph language modeling exchange protocols aperiodic circuits 
proc 
conference simulation digital control computer systems ussr february 
russian 
siegel de micheli 
decomposition methods library binding speed independent asynchronous designs 
proceedings international conference computer aided design pages november 
sutherland 

communications acm june 
turing award lecture 

formal model de ning classifying delay insensitive circuits systems 
distributed computing 
valmari 
state art report stubborn sets 
petri nets newsletter 
goossens de man optimized synthesis asynchronous control circuits graph theoretic speci cations 
ieee transactions computer aided design january 
peter bill lin gert goossens hugo de man generalized state assignment theory transformations signal transition graphs 
journal vlsi signal processing february 

asynchronous control device design net model behaviour simulation 
international conference application theory petri nets lecture notes computer sciences osaka japan june 
rosenblum taubin 
self timed control concurrent processes 
kluwer academic publisher 
russian edition 

limitations extensions stg model designing asynchronous control circuits 
proceedings international conference computer design pages october 

modelling analysis synthesis asynchronous control circuits petri nets 
integration vlsi journal december 
michael 
speci cation veri cation asynchronous circuits marked graphs 
voss rozenberg editors concurrency nets advances petri nets pages 

