adding compression block addressing inverted indexes gonzalo navarro silva de moura ziviani ricardo baeza yates department computer science univ chile chile 
dcc uchile cl 
department computer science univ federal de minas brazil 
dcc br 

inverted index compression block addressing sequential search compressed text techniques separately developed efficient low overhead text retrieval 
modern text compression techniques reduce text size allow searching directly faster uncompressed text 
inverted index compression obtains significant reduction original size processing speed 
block addressing inverted lists point text blocks exact positions pay reduction space sequential text scanning 
combine ideas single scheme 
compressed inverted file indexes compressed text uses block addressing 
consider different techniques compress index study performance respect block size 
compare index separate techniques varying block sizes showing index superior isolated approach 
instance just extra space overhead index scan text exact searches allowing error matches 
keywords text compression inverted files block addressing text databases 

large sizes today text collections demand specialized indexing techniques allow fast access documents searched users 
index persistent data structure built text advance speed query processing 
simple indexing structure large text collections inverted index inverted file baeza yates ribeiro neto witten 
inverted indexes popular indexing technique large text databases storing natural language documents 
partially supported siam dcc project mct project gonzalo navarro ricardo baeza yates capes scholarship silva de moura miner technology group scholarship cnpq ziviani 
fl kluwer academic publishers 
printed netherlands 
tex inverted index typically composed vector containing distinct words text collection lexicographical order called vocabulary word vocabulary list text positions word occurs called list occurrences 
search word inverted index locates word vocabulary retrieves list text positions 
search phrase proximity pattern words appear consecutively close respectively word searched separately lists occurrences intersected care closeness word positions text 
proposals williams 
important considerations evaluate efficiency indexing scheme construction updating querying times space requirements 
time space requirements function granularity index defines unit information represented 
different types inverted indexes identified granularity going faster process queries slower build index space demanding slower process queries faster build index space demanding 
called word addressing inverted index 
appropriately implemented fastest index solve queries 
uses simplest scheme index points positions words text 
construction time space requirement higher 
occurrences take nearly text size 
reduced omitting stopwords vocabulary ara 
stopwords articles prepositions words carry meaning appear removed user queries 
stopwords represent text words 
extra space high space requirement large text collection different techniques exist reduce space taken lists occurrences 
second type known document addressing inverted index 
document addressing index lists occurrences point exact occurrences words just documents word appears 
saves space occurrences word document referenced pointers may smaller documents text positions 
normal space requirements document addressing indexes text size 
single word queries solved directly document addressing indexes access text 
tex word appears document document retrieved 
phrase proximity queries solved information index stores 
words document may may form phrase close 
queries search directly text documents relevant words appear 
third type called block addressing index goes step manber wu baeza yates navarro 
divides text blocks fixed size may span documents part document overlap document boundaries 
index stores blocks word appears 
normally blocks documents space occupied index small chosen user needs 
hand query solved sequential searching text known documents block word appears 
index just device filter blocks collection contain match 
index scheme proposed glimpse manber wu widely known system uses block addressing index 
interesting glimpse transparently index files user 
index takes little space kept updated periodic rebuilds allows finding time user files containing pattern 
glimpse index web sites providing fast search web pages low overhead index technique 
orthogonal technique reduce space requirements inverted indexes compression 
text index compressed reduce space requirements 
key idea reduce size inverted indexes list occurrences word increasing order gaps consecutive positions stored absolute values 
compression techniques small integers 
gaps smaller longer lists longer lists compressed better 
shown document addressing indexes reduced original size degrading performance performance may improve reduced witten 
text compression difficult combine inverted index need access text random positions presentation purposes sequentially search parts text required document block addressing indexes 
needs traditionally demanded text reaching desired part 
text compression techniques bentley moffat allow reducing tex text original size allows direct searching compressed text decompressing moffat moura faster search done uncompressed text 
compression techniques huffman coding symbol table vocabulary text 
couple inverted index 
inverted index compression block addressing sequential search compressed text combined single scheme precisely 
compressed inverted index indexes compressed text uses block addressing 
study specialized techniques compress block addressing index study performance respect block size 
index built memory compression scheme improves performance reducing cost index construction see hawking 
scheme index user files glimpse result improvement indexing searching times 
furthermore space compressed text plus compressed index take nearly third original uncompressed files index 
arrangement transparent user system implemented compressed indexed file system 
layer applications file system takes care compressing texts write read operations respectively editors web servers applications transparently files dos windows 
time system keeps small index allows finding time files containing user query 
show instance gb text indexed overhead warm state search word patterns seconds traversing text phrase patterns seconds traversing text 
organized follows 
section presents compression technique huffman coding words 
section explains search efficiently compressed text 
section presents block addressing scheme 
section presents techniques compress occurrences inverted index proposals specialized compressing block addressing indexes 
section shows complete scheme combining block addressing index compression text compression 
section presents experimental results combined approach isolated technique 
section presents directions 
tex 
word byte oriented huffman compression large natural language texts information retrieval ir context effective compression technique word huffman coding huffman bentley moffat 
idea huffman coding assign unique variable length bit encoding different word text compression achieved assigning shorter codes words higher frequencies 
compression proceeds passes text 
encoder pass text obtain frequency different text word performs actual compression second pass 
traditional implementations huffman method adopt characters symbols alphabet 
successful idea merging requirements compression algorithms needs ir systems consider symbols compressed words characters bentley moffat 
words atoms ir systems built 
words symbols means table symbols compressor exactly vocabulary text allowing natural integration inverted index word huffman compression method important consideration size text vocabulary 
empirical law widely accepted ir heaps law heaps states vocabulary text words size fi fi depends text 
shown ara fi practice vocabulary needs space proportional square root text size 
large texts overhead storing vocabulary minimal 
useful law related vocabulary zipf law zipf states frequency text th frequent word times frequent word constant depends text 
text words th frequent word appears times constant frequencies add natural language text composed words separators 
efficient way deal words separators method called words moura 
word followed space just word encoded 
word separator encoded 
decoding time assumed space follows word symbol corresponds separator 
presents example compression huffman coding space operations inefficient file exported system current compressed form 
tex words method 
set symbols case rose frequencies respectively 
rose phi phi phi phi original text compressed text rose rose rose 
compression huffman coding words 
example shows codes symbols organized called huffman tree 
huffman method gives tree minimizes length compressed file trees achieved compression left right children exchanged node 
preferred choice applications canonical tree right subtree taller left subtree case 
canonical trees allow efficiency decoding time memory requirement 
algorithms building huffman tree symbol frequencies described instance bell 
require log worst case time due zipf distribution average time linear decompression accomplished follows 
stream bits compressed file traversed sequentially 
sequence bits read traverse huffman tree starting root 
leaf node reached corresponding word constitutes decompressed symbol printed tree traversal restarted 
tree presence code compressed file leads decompressed symbol 
original method proposed huffman binary code 
moura huffman code assigned text word sequence bytes huffman tree nodes degree called byte oriented huffman compression 
example possible huffman code word rose byte code 
experimental results moura shown significant degradation compression ratio experienced bytes bits coding words vocabulary 
hand decompression searching tex byte huffman code faster binary huffman code bit shifts masking operations necessary 
important consequence byte huffman coding possibility performing fast direct searching compressed text 
search algorithm explained section 
seen technique useful speed sequential search improve indexed schemes combine inverted indexes sequential search 

sequential search compressed text explain compressed text searched moura 
start general technique allows searching complex patterns consider possible speedups 
general technique simplest complex scenario 
final setup allows large number variants forms language originally defined agrep wu manber 
gamma searching allowing errors called approximate pattern matching query pattern number system retrieves occurrences words transformed query errors 
error insertion deletion replacement character 
instance searching color retrieves colour 
gamma searching classes characters pattern position may match set characters just character 
allows interesting queries ffl range characters xt means letter ffl arbitrary sets characters aei xt meaning words text ffl complements ab xt ab means single character xt means single character ffl arbitrary characters means character second character word ffl case insensitive patterns text text considered word 
gamma searching regular expressions exactly allowing errors 
examples tex ffl unions ai xt means words text ffl arbitrary number repetitions ai xt means words followed ai zero times followed xt ffl arbitrary number characters middle pattern xt 
customary denote 
gamma combining exact matching parts approximate matching parts te xt meaning exact occurrence te followed occurrence xt error 
gamma matching nonuniform costs cost insertions defined twice cost deletions 

general search technique consider search single word 
preprocessing consists searching vocabulary marking corresponding entry leaf huffman tree 
search efficient binary search hashing 
scan compressed text byte byte time traverse huffman tree downwards decompressing text 
time reach leaf huffman tree know word read check leaf marked case report occurrence 
leaf marked return root huffman tree resume text scanning 
pattern simple word perform direct search vocabulary 
case preprocessing phase corresponds sequential vocabulary search mark words match pattern 
specialized sequential algorithms search allowing classes characters errors matches regular expressions multiple patterns combinations 
vocabulary small compared text size fi size recall section sequential search feasible alternatives considered section 
text scanning phase exactly difference leaf huffman tree may marked 
consider search phrase query 
phrase sequence elements simple complex pattern 
trying extend previous approach brute force fashion simple possible phrase occurrences may overlap words may match phrase elements phrase elements set bit mask bits word leaf huffman tree 
th bit word set tex matches th element phrase query 
element phrase turn searched vocabulary marks th bit words matches 
note elements may simple words searched binary search hashing may complex patterns sequentially searched 
preprocessing concluded scan text 
time arrive leaf word retrieve bit mask indicates phrase elements word matches 
search phrases organized nondeterministic automaton states 
automaton allows moving state state th element phrase recognized 
state zero active occurrences reported state activated 
automaton nondeterministic moment states may active prefixes phrase may matched text 
time reach leaf huffman tree send bit mask automaton 
active state gamma activate state th bit mask active 
automaton transition word text 
illustrates phase pattern ro rose allowing error word ro means word starting ro 
instance word rose vocabulary matches pattern positions 
huffman tree vocabulary rose row road 

marks nondeterministic searching automaton 
general searching scheme phrase ro rose allowing error 
scheme allows disregarding separators words phrase 
phrase pattern separator words couple spaces space 
achieve ignore leaves huffman tree arrive separators 
way stopwords ignored phrase match 
difficult typical sequential search algorithms uncompressed text 
hand avoid tex phrase spans sentence account separators contain period 
leaves huffman tree bit mask composed zeros phrase occurrence contain 
remaining problem implement automaton efficiently 
algorithm choice shift baeza yates gonnet able simulate automaton states length bits computer word performing constant number operations text character 
case means solve phrases words depending machine extremely fast 
longer phrases need machine words simulation technique 
idea algorithm map state automaton bit computer word 
new text word reached leaf suffix tree active state activate simulated shift bit mask 
match current phrase element pass simulated bit wise operation bit mask leaf huffman tree 
shift operation text word search state updated original algorithm uses reverse bits efficiency name shift 
search time kn fi worst case term comes searching vocabulary second text search operations byte compressed text 

faster filters previous scheme general cope complex searching 
possible search faster 
particular interested examining characters compressed text 
simplest case consider search single word 
case previous approach simply find word vocabulary get compressed code search code compressed text directly standard pattern matching algorithm 
resulting algorithm fast fastest search uncompressed text additional benefit reduced terms elapsed time search faster text read disk 
problem solved possibility false matches compressed pattern text just matches inside concatenation compressed codes 
solved bit bytes compressed codes signal code setting synchronization points tex compressed text codes aligned 
case potential match followed verification starting synchronization point 
consider complex cases 
case single complex query find codes matching words perform search compressed text 
case phrase choose element representative search directly text verify surrounding text match complete phrase occurrences 
element search chosen trying search faster longest code codes search 
average time search text improved scheme 
search single pattern possible obtain log time length bytes compressed pattern 
complexity search closed expression 

block addressing block addressing technique reduce space requirements inverted index 
proposed system called glimpse manber wu 
idea text logically divided blocks occurrences point exact word positions blocks word appears 
space saved blocks text positions pointers shorter occurrences word single text block referenced 
illustrates block addressing index blocks words rb 
searching block addressing index similar searching word addressing 
pattern searched vocabulary list blocks pattern appears retrieved 
obtain exact pattern positions text sequential search qualifying blocks necessary 
index filter avoid sequential search blocks need checked 
reduction space requirements obtained expense higher search costs 
point reader may wonder advantage pointing artificial blocks pointing documents files way natural divisions text collection 
consider case simple queries say word required return list matching documents pointing documents adequate choice 
shown baeza yates navarro may reduce space requirements respect tex words block words block words block blocks text words occurrences index 
block addressing index 
blocks fixed size 
blocks fixed size pack short documents logical block traverse matching blocks simple queries determine documents inside block matched 
consider case required deliver exact positions match pattern 
case need sequentially traverse qualifying blocks documents find exact positions 
important types queries phrases proximity queries index tell words appear block need traverse order determine form phrase 
case pointing documents different sizes idea larger documents searched higher probability searching costs 
fact expected cost search directly related variance size pointed documents 
suggests documents different sizes may idea logically partition large documents blocks put small documents blocks size 
block addressing analyzed baeza yates navarro important result analytically proved experimentally verified block addressing index may yield sublinear space overhead time sublinear query time 
traditional inverted indexes tex pointing words documents achieve second goal 
shown baeza yates navarro order obtain space overhead theta fl necessary set theta gammafl gammafi case query time obtained fi gammafi ff 
formula ff related query complexity ff vocabulary words match query ff exact queries ff fi complex queries 
time complexity sublinear fl gamma gamma fi fi gamma ff 
practice space query time obtained exact queries 
course optimal block size space time tradeoff related case corresponds word addressing indexes space requirements time single word query fi gammafi ff exact searching 
extreme omega gamma means just vocabulary stored needing fi space search time 

index compression show section compress inverted indexes order achieve significant space reduction allow fast access inverted lists 
describe section simple technique improve compression block addressing 
idea avoid storing lists words appear text blocks reducing size index amount processing queries 
comprehensive works showing compress inverted indexes literature stanfill moffat bell witten block addressing just type inverted index 
previous works useful 
techniques compress inverted indexes classified parameterized non parameterized 
parameterized techniques golomb codes golomb produce different outputs depending parameters adjust coding scheme characteristics input compress 
non parameterized coding schemes need information elements coded output fixed input 
parameterized coding necessity previous knowledge input requires passes list symbols coded drawback interested performance particular inability generate inverted list directly compressed form may translate higher indexing time 
passes merged passes need obtain approximation parameters tex decompression slower anyway 
best parameterized coding methods produce just slight better compression ratios compared best non parameterized methods 
main focus building block addressing indexes improve performance 
non parameterized scheme 
previous studies shown best non parameterized methods inverted index compression moffat bell witten 
sake completeness repeat important concepts gaps unary coding elias fl coding elias ffi coding 
gaps block numbers assigned incrementally parsing text pointers inverted list ascending order 
non initial pointer substituted difference gap previous number list 
processing usually done sequentially starting list original block numbers recomputed sums gaps 
lists composed smaller integers obtain better compression encoding represents shorter values fewer bits 
unary coding simple scheme codes integer gamma followed zero bit called unary code 
unary codes numbers shown table elias fl coding elias elias studied variable length encodings integers 
elias fl code represents integer concatenation parts unary code blog xc followed code blog xc bits corresponding gamma blog xc binary 
total code length blog xc 
examples table elias ffi coding coding scheme introduced elias ffi code prefix indicating number bits second part coded elias fl code unary 
elias ffi code integer requires blog log xc blog xc bits 
table shows small values elias fl codes shorter elias ffi codes situation reversed grows 
experiments methods compress index 
particular techniques combined methods allow direct access list periodic intervals witten permits speed phrase conjunctive queries involving long short lists 
techniques 
tex table sample codes integers 
integer unary elias fl elias ffi 
improving index compression techniques previous section developed compress document word addressing indexes 
special features block addressing indexes improve compression significant changes performance system 
blocking addressing words appear half blocks 
phenomenon common document word addressing indexes occur frequently block addressing indexes large block sizes 
cases simple idea improve index compression represent list non occurrences frequent words 
word occurs half blocks store block numbers occur 
call lists complemented lists 
alternative form compress words run length compression gaps half times 
economy space similar length run ones precisely value gap complemented list minus 
instance blocks word appears nd st list gaps 
run length compression list gaps yields ih ih ih ih format number repetitions hand complemented list list gaps 
note run length compression needs store information gaps complemented list 
second advantage complemented lists operated efficiently converting normal lists 
describe perform boolean operations normal complemented tex lists time proportional normal complemented representations 
depending operation result left normal complemented form 
inverted indexes common index stopwords save space 
stopwords probably appear blocks index zero cost 
need keep vocabulary decompression purposes 

memory bucket compression compressed inverted schemes witten generation inverted list proceeds stage compression second stage 
compression parametric cases way lists generated 
step text traversed occurrences generated text order 
occurrences sorted word represent 
final sorting lists separated words gaps generated order compress lists 
non parameterized coding scheme need global information list order compress 
additional decision allows lists generated memory compressed form generate occurrences text order sort generate separated word 
store separate list occurrences word know vocabulary new text occurrence added occurrence list corresponding word 
compute gaps store compressed form fly 
technique generating occurrences unsorted form preferred space reasons storing list occurrences word may waste space pointers stored empty space preallocated 
especially important zipf law words occurrences 
storing separate lists hand advantage avoiding final sort saves time 
combining compression advantage separate lists appears lists generated compressed form take space 
improved space usage translates better indexing time text indexed memory resorting disk 
indexing schemes avoid sorting occurrences hawking moffat harman 
tex propose efficient approach store lists occurrences word tries adapt typical word frequencies 
idea represent list occurrences word linked list node bucket occurrences 
buckets composed pointer bucket term stream bits represents portion compressed list term 
bucket pointed structure continues stream bits 
important decision scheme size buckets 
large compensate extra space pointer bucket small reduce extra memory lost empty spaces bucket term 
experiments chosen bytes bucket term byte buckets remaining buckets term 
reason smaller bucket terms occur just collection 
smaller bucket saves memory terms 
shows example list occurrences term appeared blocks 
coding scheme shown section list converted list gaps 
elias fl coding scheme list gaps converted stream bits 
bucket size bits remaining buckets bits buckets term shown 
empty space buckets space represent pointer bucket linked list 
pointer represented dlog bits number buckets fit memory buffer 
example pointers represented bits allowing buckets main memory 
block second block 
linked list buckets memory compression scheme 
memory bucket compression technique allows index large texts making just pass text generate index 
general applied construction kind inverted index word document addressing indexes 
index placed memory need dump partial list disk second pass merge dumps described moffat bell 
tex 
integrated approach section combined design includes text compression block addressing index compression single approach 
resulting structure follows see vocabulary vocabulary collection useful symbol table huffman coding inverted index vocabulary 
canonical huffman tree comprises small extra structure added vocabulary need search decompress text 
recall separators huffman tree searchable 
occurrences vocabulary word list blocks word appears 
list increasing block number compressed techniques section 
despite separators kept vocabulary decompression purposes build lists occurrences 
common choice inverted indexes filter words map letters lowercase apply stemming 
baeza yates ribeiro neto recover original file 
filtration done fly search time 
block structure blocks form logical layer natural file structure collection files physically split concatenated 
implemented list files collection position file list sort identifier 
keep list blocks 
blocks number words span continuous range list file identifiers necessarily matching file boundaries 
block store identifier file spans list offset byte file belongs block 
text files original file collection compressed separate file single huffman coding collection 
space index analyzed baeza yates navarro shown vocabulary takes fi space occurrences take rb fi space heaps law new block fi different words exists lists occurrences 
lists blocks files negligible tex compressed vocabulary block canonical structure occurrences huffman tree text files compressed 
structure index 
size 
hand occurrences compressed reduces space factor independent space rb fi 
shown baeza yates navarro fi value small blocks larger asymptotic value converges close relatively small blocks 

construction index efficiently built notice processes merged single pass text 
huffman compression needs passes text passes able build index 
index construction process stages 

stage stage corresponds finding global information interest 
determine set files index number blocks compute vocabulary collection frequencies word determine lists represented complement 
requires simple linear pass text memory required storing vocabulary list files output disk 
pass computed list files vocabulary text frequencies 
know total number words collection define number blocks need collect different frequency parameters 
number times word occurs second number blocks word occurs 
needed tex huffman algorithm second determine list word stored simple complemented form 
statistics useful relevance ranking 
number times word occurs easy compute number blocks requires little care store word block appeared number blocks appeared 
know current block increment time new words read 
occurrence word check appeared current block 
second case increment number blocks appeared update block word seen 
moving stage run huffman algorithm vocabulary build canonical huffman tree 
replace frequency information vocabulary word compressed code assigned 
tree immediately swapped disk small anyway 
hand data structure build vocabulary efficiently find words kept memory help second stage 
vocabulary stored memory hash table trie order provide average worst case access time respectively 

stage second stage heavier part 
text file collection compressed order dictated list files 
word separator text searched vocabulary need data structures search words huffman code output compressed file 
finish file compressed version replaces original 
time construct lists occurrences 
time word output compressed code add entry list occurrences represented shown section 
course entry added appeared block store word block appeared 
recall inverse process done words occurrence list stored complemented form word appears block previous block appeared current previous add list block interval current block occurrence non occurrences word 
current block number incremented time new words processed 
time add new entry list blocks pointing current file processed store number bytes written compressed version file 
list tex sent disk generated map block number physical position block collection 
list occurrences sent disk compressed form 
separately save vocabulary disk pointers place list occurrences word starts file occurrences 
problem scheme despite fact index needs little space may able store occurrence lists memory construction time 
problematic structure rest small buffered 
occurrences hand sent disk generated final entries list come second list 
solution chosen time memory filled store occurrences computed disk free space memory starting empty list 

stage stage set partial occurrence lists merged order words correspond 
lists word concatenated order generated 
auxiliary information stored partial lists help identify word belong word identifier length list 

analysis collecting vocabulary text done linear time provided adequate data structures trie words guarantee worst case linear time hash table average linear time 
huffman construction done linear expected time words follow statistical rules widely accepted text retrieval shown moura 
processes stage linear time negligible practice 
second stage linear discussed data structures find text words vocabulary 
compressed codes output total space text take linear time adding block numbers lists occurrences constant time text word 
linear third stage merges lists 
memory available index construction partial occurrence lists generated merged 
heapsort total merge takes log time 
third stage avoided resorting virtual memory writing partial lists tex disk merging faster practice 
interesting see merge phase commonly needed memory compression block indexes tend small 
example machine mb ram words block length small block size able index collection size close gb needing stage 

searching describe search process index divided steps 
explain search single element show search phrases 

step step search find query pattern vocabulary single word regular expression allowing errors 
data structures indexing time kept speed search resort sequential binary search save space done exactly explained section 
list words match query built binary masks case phrase searching 

step take advantage block information done simple sequential searching 
query pattern matched set vocabulary words just search single word 
take list blocks words occur merge single list ordered increasing block number 
blocks excluded final list contain occurrence query element 
lists merge compressed form decompress fly time merge 
new list element read decode bits compressed representation gap add gap element list processed 
technique reduce size lists complementation long lists 
operation complemented lists done fast time proportional complemented list 
complemented lists merged complemented result intersect complements note words simultaneously sorted alphabetically order required canonical huffman tree extra indirection array required 
tex complement result 
similarly intersected apply complemented proceed set difference gamma gamma 
step final step sequential search blocks find exact documents positions query occurs 
blocks mentioned list occurrences matched words need searched 
block structure determine portions files sequentially traversed 
search algorithm exactly sequential searching index 
new choice respect boyer moore search 
sequential setup compressed codes matching words simultaneously searched information different word appears 
clear search performance degrades number patterns search grows 
index information 
know block vocabulary word matched 
imagine query matched words appears blocks appears blocks need search hand searched words 
different hopefully faster search text block 
price need different pattern preprocessing block set patterns search depends block counterproductive blocks small 
idea mentioned baeza yates navarro tested 

phrase search query may just pattern sequence patterns word regular expression main idea search phrases take intersection occurrence lists involved blocks 
elements phrase appear block consider block boundaries shortly 
proceed pattern phrase list occurrences pattern obtained making union list vocabulary words match pattern 
list pattern phrase intersect lists perform sequential search blocks patterns appear time 
case simple elements may search blocks occurrences complete query 
natural question point avoid losing phrases lie block boundaries intersection method fail 
tex solved letting consecutive blocks overlap words 
indexing time determine allow searching phrases words 
block ends th word document start word gamma 
causes small overhead solves elegantly problem phrase words appears completely inside block 
main problem limit indexing time longest phrase searched 
words longer modify list intersection process contiguous blocks verified words phrase appears block words second block 
expensive 
solution slightly relax rule blocks exactly words long move block boundaries little match sentence separator containing period 
case phrase cross block boundaries need blocks overlap limit length phrases search 
hand parsing text bit complicated 
sophisticated searching proximity search sequence words appear correct order interval text words accommodated similar way 
sequential searching changes see moura techniques search diverse sophisticated patterns block boundaries overlap gamma words 

analysis analyze performance search process 
step vocabulary search analyzed section phrase elements takes jn fi fi time depending complexity search 
second step merging intersection lists 
consider word queries analyzed baeza yates navarro recall section 
word occurrence list gammafi average length cost merge lists gammafi ff log 
cost intersect lists phrase patterns jn gammafi ff log lists stored compressed form need traverse 
recall long lists compressed representing complement representations efficiently handled 
cost second steps negligible compared third step 
know search cost text size remains determined percentage text traversed block index 
tex consider word patterns 
block words fi different words ff random words fi vocabulary words selected search probability block gets selected word searched fi ff gammafi 
blocks cost traverse total search cost fi ff gammafi gammafi ff fi 
tends cost approaches word addressing indexes ara 
phrase searching better 
shown ara zipf law shortest list random words constant length 
means average search blocks phrase searching time 
cost intersect lists similar union sequentially processed 
summarize total search cost fi gammafi ff fi single patterns fi gammafi ff phrases 
considered constants simplify final complexity 

updating final issue update index documents added removed modified 
procedures update normal inverted index known brown extra complications block index 
removing document simply handled removing occurrence lists point blocks contain document overlap remove complete blocks totally contained removed document 
alternative block expensive block different size incorrect may degrade performance 
inserting new documents handled adding new blocks needed document compressed indexed occurrence lists merged index 
hand shown baeza yates navarro block size grow sublinearly text size grows 
best choice handle updates type index periodic reindexing manber wu 
index completely rebuilt periodic intervals say daily weekly 
choice imply limitations update frequency maximal size database 
handle updates manner light 
paid slight degradation index performance periodic rebuilds 
deletions document marked deleted list documents physically deleted 
altered index 
tex block sequentially traversed document course skipped 
possible block traversed words anymore 
hand removing files collection fast 
insertions choices 
compress file add incomplete block index create new block add entry block lists words appear new document 
fully integrates document collection takes time 
choice add identifier document special block indexed included sequential search 
equivalent having new files indexed search sequentially times rebuild 
degrades slightly performance insertions fast 
index forced rebuild user determines extra block large 
replacements best way handle replacement deletion followed insertion 
complication comes fact compressing text 
case periodic rebuilds avoid text frequently 
try handle incremental modifications huffman codes 
changes alter frequencies words alter optimality code new words appear representation huffman tree 
choice leave placeholder tree 
fake word frequency zero created node new words appear 
time placeholder new created 
hand words totally disappear discovered occurrence list null place tree left placeholder new words added 
expect words appear disappear low frequency technique placeholders yields negligible degradations compression 
changes accumulate time mechanism devised recover optimality huffman codes 
choice periodic database period quite large practice shown moffat section 
challenging alternative perform small modifications tree keep optimal minimize number files need 
open research issue pursuing 
tex alternative method studied moffat escape codes 
new words representation huffman tree represented explicitly text preceding special byte 
scheme needs method avoid compression degradation changes accumulate time 
show moffat idea words low frequency putting tree improve compression tree reduces lot vocabulary 
merge inverted index scenario keep anyway words vocabulary avoid traversing text word incomplete vocabulary 
worse infrequent words interesting ones ir frequently searched 
vocabulary sizes problem current computer servers 
problems solved addition escape codes keeping track vocabulary new words appeared 

experimental results section experimental results evaluate effectiveness combined approach 
tests literary texts trec collection harman 
chosen gigabyte texts ap newswire doe short abstracts doe publications fr federal register wsj wall street journal ziff articles computer selected disks ziff davis publishing 
collection put single file 
considered word contiguous string characters set fa separated characters set fa 
tests run pc pentium ii mhz megabytes ram running linux performing tasks 
disk uses interface scsi ultra dma 
show elapsed times 

construction time space start evaluating time space build index function block size determine effectiveness inmemory compression technique 
shows time main memory requirements construct index compress texts collection varying block size words 
ram requirements include structures implementation space store vocabulary data tex compression algorithm space keep list buckets term collection 
seen index gb built minutes uses mb ram build ram need build partial indexes merge 
differences block size grows due reduction number entries index 
just compressing text takes minutes just indexing need minutes main cost text parsing shared compressor indexer 
included time index collection mg block size controlled adding artificial document terminators inside unique file appropriate intervals 
seen mg times slower 
glimpse included comparison control block size splitting input real files 
slows indexing time point comparison useless 
size block hundreds words mg size block hundreds words main memory 
time build different indexes seconds left main memory usage mb index right varying block size 

compression ratio space overhead consider space overhead final index 
left shows number bits entry elias ffi elias fl 
decreases block size grows gap values tend smaller larger blocks reduces number bits represent index entries elias coding 
plot shows little difference methods 
right part shows size index function block size 
index size reduces quickly block size grows due main reasons 
reduction bits entry explained 
second number index entries reduced block size grows 
tex figures show gain compression obtained complemented lists modest 
elias fl complemented lists 
size block hundreds words gamma complemented lists gamma complemented lists delta complemented lists size block hundreds words gamma complemented lists gamma complemented lists delta complemented lists 
bits entry left size compressed index percentage uncompressed text right varying block size 

search time consider search time 
measured randomly choosing patterns text 
experimented patterns words averaging patterns pattern size 
shows time exact approximate searching block sizes varying words 
sequential search algorithm fast filter described section false matches problem solved synchronization points 
search times include loading vocabulary correspond running server vocabulary loaded memory answers requests users warm state 
size block hundreds words word words words size block hundreds words word words words 
time seconds exact searching left allowing error right patterns words varying block sizes 
shows amount text traversed experiments 
seen small percentage text traversed tex small index 
particular search time percentage traversed text drops quickly search phrases number blocks involved words appear smaller 
size block hundreds words word words words size block hundreds words word words words 
amount text traversed megabytes exact searching left allowing error right patterns words varying block sizes 
note block size words jump search times counterpart amount text traversed 
fact corresponds caching effect shows complex parameters involved complete tuning index 
particular type consideration selecting block size practice target system 
compare figures related consider small glimpse index built gb text 
case glimpse produces index text size 
build index space overhead index compressed gives smaller blocks translates better search times 
construction index glimpse took minutes index minutes includes text compression glimpse perform 
excluded mg comparison retrieval functionalities totally different mg retrieves documents ranking index glimpse retrieve exact positions inside documents 
include comparison sequential search algorithms show gains due index agrep wu manber known sequential searching software base glimpse moura software sequential searching byte huffman compressed text sequential search algorithm index uses 
results shown table ii 
timing methodology times include time load vocabulary memory cold state 
notice search time indexes improve lot phrases blocks words occur searched 
note gains tex table ii 
comparison search time seconds gb 
exact searching words agrep glimpse index error words agrep glimpse index sequential searching higher warm state evident figures 
final observation note glimpse faster exact searching phrases words 
due fact sufficiently long phrases amount text traverse sequentially small parameter interest overhead finding relevant blocks 
glimpse efficient prototype aspect 

updating text finish showing experiments behavior compression ratios text updated 
techniques discussed section implemented leaving special escape symbol huffman tree escape code code new strings length code bytes escape symbol 
list newly inserted words kept search algorithms altered account escape codes 
left shows deletions affect compression quality 
different trec texts considerations compressed separately 
removed text collections mb 
seen compression ratios keep basically constant means frequency words total texts approximated small fraction texts 
right part shows successive insertions affect compression quality wsj file 
compress respectively file insert rest tex existing codes escape codes new words 
curve permits comparing optimal compression 
example obtain compression wsj build huffman codes text insert rest codes compression ratio raises 
certainly modest price 
text processed mb ap doe ziff wsj compression ratio text processed mb 
compression ratios obtained deleting portions files left inserting text wsj right 
test pessimistic case huffman codes built collection text completely deleted new collection inserted 
shows compression ratios obtained 
seen increments compression ratios 
compression ratio text processed mb ap wsj ap doe ap ziff 
compression ratios obtained replacing collection 

shown combine different ideas allow reducing size inverted indexes texts associated 
block addressing inverted index compression tex compressed text permits direct search 
particular proposed new index compression techniques specific block addressing indexes 
integration ideas needs fine tuning parameters involved experimental results suggest block size words gb 
point reasonable trade index space search time 
block size words index just needs mb text size cached memory 
addition construction time mb needed represents text size 
hand search time warm state seconds word seconds words quite reasonable 
percentage text traversed space overhead 
result index text compressed original text size achieving searching times seconds gb 
shown index times faster glimpse 
number issues open boolean queries efficiently boolean operations inverted indexes 
document addressing clear advantages operation translated set operations lists occurrences 
smaller index operated lists blocks pre filter reduce text scanned 
structured text add support structural queries limit occurrences occur inside text field 
shown baeza yates navarro baeza yates inverted indexes significantly help supporting structured text queries indexing real virtual structural tags distinct words translating structural queries operations regarding words tags followed words tags 
block addressing index way help filter blocks contain occurrence 
flexible pattern matching block addressing index filter text sophisticated pattern matching approximate searching word level described moura 
efficient updating reflect index updates text collection undergoes 
periodic rebuilding works tex done large collections gigabytes example storage management techniques allow expansion contraction occurrence lists interest 
different integration ideas appears considering problem searching web 
case block addressing distribute search space size computation load 
central search engine handles smaller index current indexes altavista allowing scalability pure centralized architectures 
server distributes query small number local servers local index 
case block size large fixed unique 
local indexes may may block addressing may text compression 
vocabulary block 
integration advantage flexible decisions local example compression may depend factors architecture system scalable 
main disadvantages needs cooperation different sites problem done single network traffic increases 
idea pursued baeza yates related harvest bowman 
ara navarro ziviani large text searching allowing errors 
baeza yates ed proc 
th south american workshop string processing vol 

pp 

baeza yates distributed searching architecture web 
personal communication 
baeza yates gonnet new approach text searching 
communications acm 
baeza yates navarro integrating contents structure text retrieval 
acm special interest group management data sigmod record 
baeza yates navarro block addressing indices approximate text retrieval 
journal american society information science jasis 
baeza yates navarro vegas de la model visual query language structured text 
proc 
th south american symposium string processing information retrieval spire 
pp 

baeza yates fast algorithms dimensional multiple pattern matching 
proc 
nd scandinavian workshop algorithm theory swat 
pp 

baeza yates ribeiro neto modern information retrieval 
addisonwesley 
tex bell cleary witten text compression 
prentice hall 
bentley sleator tarjan wei locally adaptive data compression scheme 
communications acm 
bowman danzig hardy manber schwartz harvest information discovery access system 
proc 
nd international world wide web conference 
pp 

brown callan croft fast incremental indexing full text information retrieval 
proc 
th large data base conference vldb 
santiago chile pp 

elias universal codeword sets representations integers 
ieee transactions information theory 
golomb run length encodings 
ieee transactions information theory 
harman fox baeza yates lee inverted files pp 

prentice hall 
harman overview third text retrieval conference 
proc 
rd text retrieval conference trec 
gaithersburg maryland pp 

hawking scalable text retrieval large digital libraries 
peters eds proc 
st european conference digital libraries 
pisa italy pp 

heaps information retrieval computational theoretical aspects 
ny academic press 
huffman method construction minimum redundancy codes 
proc 
institute electrical radio engineers vol 

pp 

stanfill compression indexes full positional information large text databases 
proc 
international acm sigir conference research development information retrieval sigir 
pp 

manber wu winter glimpse tool search entire file systems 
proc 
usenix technical conference 
pp 

moffat word text compression 
software practice experience 
moffat economical inversion large text files 
computing systems usenix assoc 
journal 
moffat bell situ generation compressed inverted files 
journal american society information science 
moffat zobel sharman text compression dynamic document databases 
ieee transactions knowledge data engineering 
moura navarro ziviani linear time sorting skewed distributions 
proc 
th symposium string processing information retrieval spire 
pp 

moura navarro ziviani baeza yates fast flexible word searching compressed text 
acm transactions information systems 
appear 
previous versions st international acm sigir conference research development information retrieval sigir th symposium string processing information retrieval spire 
moffat fast file search text compression 
proc 
th australian computer science conference 
pp 

tex williams zobel anderson 
efficient structures phrase querying 
roddick ed proc 
th australasian database conference auckland nz 
singapore pp 

witten moffat bell managing gigabytes 
new york morgan kaufmann publishers second edition 
wu manber fast text searching allowing errors 
communications acm 
zipf human behaviour principle effort 
addison wesley 
tex 
