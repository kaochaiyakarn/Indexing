calculus inductive type theory furio honsell marino miculan ivan large think significant case study computer assisted formal reasoning 
start giving higher order syntax encoding calculus higher order inductive coinductive type theories cic cc ind encoding gives rise full fledged proof editor proof assistant calculus embed coq interactive proof development environment cc ind computerized assistant prove formally substantial chapter theory strong late bisimilarity amounts essentially section calculus mobile processes milner parrow walker 
task greatly simplified higher order syntax 
fact delegate conveniently metalanguage conversion substitution introducing suitable axiomatization theory contexts accommodate machinery generating new names 
axiomatization introduce quite general easily portable formalizations higher order syntax 
coinductive types corresponding tactics allows give alternative possibly natural proofs properties strong late bisimilarity originally milner parrow walker 
keywords higher order syntax calculus proof checking logical frameworks typed calculus 
goal interactive proof assistant milner calculus higher order syntax hoas presentation calculus intuitionistic coinductive type theory cc ind 
utility flexibility proof assistant illustrated developing formal theory strong late bisimilarity section calculus mobile processes milner parrow walker 
calculus process algebra models communicating systems dynamically change topology channels 
widely accepted theoretical model concurrency intended play le calculus plays functional programming 
processes partially supported murst la specifica la la la di sistemi software esprit wg types 
dipartimento di matematica informatica universit degli studi di udine 
delle scienze udine italy 
mailto honsell miculan dimi algebras calculus intricate formal system 
easy overlook detail carrying hand elementary derivation 
informal arguments equivalence processes error prone exhaustive case analyses possible transitions elusive 
calculus field formal methods reasoning concurrent systems particularly need practical computer assisted proof editors 
building implementation particular version calculus notion process equivalence scratch tenable approach 
variability presentations wide range equivalences consideration worth put effort enterprise particular 
order achieve generality explored possibility tailoring generic proof editor calculus hoas encoding subsumes number different presentations serve paradigm plethora calculi 
generic proof development environment proof development environment particular system play le logic specification language logical framework 
higher order predicative impredicative intuitionistic type theories successfully experimented logical frameworks 
theories represent formalize faithfully uniformly relevant notions aspects inference process arbitrary system syntactic categories terms assertions axiom schemata rule schemata tactics 
basic idea judgements types terms proofs paradigm 
nowadays choice generic proof development environments type theory nuprl alf lego coq isabelle implement respectively martin type theory calculus inductive constructions higher order logic 
line research interactive proof assistant calculus obtained directly coq full fledged computerized proof environment cc ind developed inria 
crucial step specification cc ind adequate encoding calculus 
encoding builds higher order syntax hoas presentation calculus style church binding operators represented constructors higher order type 
think offer substantial case study computer assisted formal reasoning significant various reasons 
illustrate building ideas complex formal system calculus benefit hoas presentation 
allows delegate conveniently metalanguage details syntactic manipulations case calculus include conversion binders substitution names machinery generating fresh local names 
previous approaches literature implementation calculus adopted direct order encoding dropped names tout court favour de indexes 
approaches needs implement explicitly machinery dealing names 
user overwhelmed technical details lemmata equivalence free names operators substitution functions 
proved lemmata concern technical details index handling 
hand delegate functional metalanguage 
hoas allows construe phrases system terms new binding operators 
treat instance bound transitions calculus 
system appears purified form 
clearly single essential idiosyncrasies treatment bound names explain away inessential side conditions normally rules 
secondly approach pioneered investigate possibility reasoning infinite circular objects coinductive types 
coinduction proofs rendered infinite proof objects bisimulations need exhibited outset built incrementally natural tactics 
approach turns extraordinarily successful 
order provide elbow room carrying proofs represent process equivalence traditional axiomatic way prove formally equivalence approaches 
hoas critical reflecting properties hoas delegates metalanguage substitution conversion freshness names 
case lemmata propositions section 
order prove properties need extend encoding new postulates reify object level details hoas delegates metalanguage 
postulates intended capture natural way basic theory contexts hoas 
quite general easily portable encodings hoas 
formulated attitude committing possible way able carry operations normally carried real life contexts 
minimalistic attitude normally applying axiomatic method 
tried isolate restricted set general properties capturing general theory contexts 
quite general portable encodings hoas 
part ongoing research programme computer science department university udine proof editors started hoas encodings dependent typed calculus program logics experience nicely confirmed dealing calculus logical frameworks allow encode faithfully formal systems consideration imposing user proof editor burden cumbersome encodings 
honestly say real user friendly interactive system proving processes 
proof editors logical frameworks development 
think construction benefit extensive case studies applications 
material contained object thesis university udine 
structure 
section recall theory monadic calculus theory strong late bisimilarity 
section briefly discuss basic ideas underlying inductive type theory logical frameworks 
give short coq proof assistant 
encodings syntax calculus operational semantics strong late bisimilarity appear section 
section formal verification carried coq theory strong late bisimilarity section discussed compared informal counterpart 
comparison related directions appear section 
complete coq signatures lists statements formally proved excerpts verification sessions appear appendix freely notions definitions type theory coq calculus 
user refer details 
calculus section introduce briefly calculus see details 
particular introduce syntax language late operational semantics relation strong late bisimilarity 
calculus primitive entities names processes agents 
infinite set names ranged set processes ranged defined syntax xy operators listed decreasing order precedence 
input prefix operator restriction operator bind occurrences respectively 
process define sets free names fn bound names bn names def fn bn 
alpha equivalence processes defined expected denoted 
px denotes set fn 
traditionally processes taken equivalence 
capture avoiding substitution single name place denoted need simultaneous substitutions shall consider identifiers definitional equations 
language language calculus originally introduced apart replication operator place identifiers recursive rules presence mismatch operator refer intuitive explanation meaning basic constructs 
process behaves essentially implement recursive processes 
process behaves different names 
operator particularly useful applications section see encoding raises interesting issues 
actions calculus defined syntax xy 
intuitive meaning 
silent action means reduce interacting processes 
free output xy means reduce emitting name channel 
input means receive channel name evolve 
bound output means evolve emitting channel name bound channel called subject objects parameters 
functions fn bn extended actions follows fn fn fn xy fn bn bn xy bn bn usual def fn bn 
free output actions called free remaining ones called bound 
operational semantics calculus labelled transition system lts reduction system structural congruence relation processes identifies processes syntactic detail conversion monoidal laws sum parallel composition 

encoding calculus view specification interactive proof development editor find convenient give lts semantics 
congruence rules fact problematic point view top proof search see section details 
plethora slightly different labelled transition systems late operational semantics calculus 
original relation smallest relation processes satisfying rules 
number different notions observational equality considered processes 
shall focus strong late bisimilarity extensively discussed original calculus 
defined follows definition strong late bisimilarity binary relation processes strong late simulation iff processes 
free action 

strong late bisimulation strong late simulations 
strong late bisimilarity binary relation defined strong late bisimulation known strong late bisimilarity defined greatest fixed point suitable monotonic operator subsets fn xy xy par bn fn sum par bn fn sum xy xy com com res repl match mismatch open xy fn tau close close late operational semantics calculus 
inductive type theories logical frameworks section succinctly logical technological tools sections 
specifically shall recall main features proof assistant coq type theory called calculus inductive constructions briefly cc ind introduced coquand huet extended paulin gim nez 
refer reader details 
utilize calculus inductive constructions logical framework shall section short discussion basic ideas generic logical specification languages 
inductive type theory cc ind impredicative intuitionistic type theory dependent inductive coinductive types 
formally system deriving assertions shape list type assignments variables 
xn tn signature list typed constants term type 
propositions types terms proofs paradigm cc ind viewed system representing assertions higher order intuitionistic logic proofs 
implies valid assertions correspond inhabited types types exists closed term type proof checking corresponds type checking 
lack space shall describe detail rich language terms types cc ind properties 
shall point important property cc ind checking term type cc ind decidable 
crucial property possible cc ind core proof checker 
shall discuss briefly features cc ind simple inductive types defined follows inductive ident term ident term 

name ident name inductively defined object term type 
constructors ident ident 
types term 
respectively 
instance set natural numbers defined inductive nat set nat nat nat 
types constructors satisfy positivity condition roughly requires ident may occur strictly positive positions types arguments ident 

condition ensures soundness definition details see 
instance definition accepted inductive set lam nat inductive definitions automatically provide induction recursion principles defined type 
principles state elements type built constructors 
instance automatically generated induction principle nat known peano principle nat ind nat prop nat nat objects inductive types founded built finite unlimited number constructors 
coinductive types arise relaxing condition coinductive objects fact non wellfounded infinite number constructors structure 
coinductive objects specified means non effective processes construction expressed circular definitions example set streams natural numbers defined coinductive stream set seq nat stream stream 
stream zeros stream seq 
course coinductive types non wellfounded induction principle 
way manipulating coinductive objects means case analysis form outermost constructor 
order ensure soundness definitions satisfy condition 
roughly constant defined may appear defining equation argument constructors 
definitions stream allowed 
interesting possibility arises cc ind connection propositions types paradigm due fact proofs class objects 
coinductive predicates rendered coinductive types propositions infinitely long circular proofs 
condition formedness infinite objects allows sense infinitely regressing proof arguments 
consistently assume thesis hypothesis provided applications appear proof guarded constructor corresponding type 
propositional version guarded induction principle introduced coquand gim nez reasoning coinductive objects constructive counterpart coinductive proofs 
see appendix extended example guarded induction proof search 
coq proof assistant coq interactive proof assistant type theory cc ind developed inria institutes 
complete description refer online documentation pauillac inria fr coq 
specifically coq editor interactively searching inhabitant type top fashion applying tactics step step backtracking needed verifying correctness typing judgements 
coq specification language allows express type theory cc ind pure ascii text follows written written written written give independent syntax cc ind formulation 
signature written proof search starts entering lemma ident goal 
goal type representing proposition prove 
point coq waits commands user order build proof term inhabits goal proof 
coq offers rich set tactics application assumptions application rules previously proved lemmata elimination inductive objects inversion inductive hypotheses 
tactics allow user proceed proof search informally 
step type checking algorithm ensures soundness proof 
proof term completed saved command qed applications 
logical frameworks type theories edinburgh logical framework calculus inductive constructions especially designed fruitfully general logic specification language logical framework lf 
lf represent faithfully uniformly relevant concepts inferential process logical system syntactic categories terms variables contexts assertions axiom schemata rule schemata instantiation tactics judgements types terms proofs paradigm 
key concept representing assertions rules martin general judgement rendered type dependent typed calculus logical framework 
calculus metalanguage lf supports higher order syntax hoas la church syntax language constructors may higher order types 
hoas substitution conversion bound variables instantiation schemata safely taken care uniformly metalanguage 
lf allow higher order assertions judgements treat par axioms rules theorems derived rules encode generalized natural deduction systems sense 
encodings lf provide normative formalization system consideration 
specification methodology lf fact forces user precise tacit informal conventions accompany presentation system 
interactive proof development environment type theoretic metalanguage lf coq lego readily turned specific logic 
need fix suitable environment signature declaration typed constants corresponding syntactic categories term constructors judgements rule schemata 
generated editor allows user reason assumptions go developing proof way mathematicians normally reason hypotheses formulating conjectures storing retrieving lemmata top goal directed fashion 
hoas formalization calculus section describe signature encodes theory calculus 
formal proof development environment induces coq adequate reasoning calculus representing processes proving correctness transitions equivalences 
section introduce signature extending appropriate metareasoning calculus 
stages section describe signature encodes syntax processes section extend allows encoding labelled transition system 
section extend represent strong late equivalence 
encoding syntax language order take best advantage features coq hoas inductive definitions possible 
declaration signature corresponds set names parameter name set 
view fact binding operators represented higher order terms take name inductive 
non relevant exotic parasite terms arise 
far encoding theory calculus concerned property name needed properties eventually needed dealing metatheory 
set name constructors names calculus represented variables cc ind type name 
declaration inductive type representing set processes inductive proc set nil proc bang proc proc tau pref proc proc par proc proc proc sum proc proc proc nu name proc proc match name name proc proc mismatch name name proc proc pref name name proc proc pref name name proc proc 
names constructors type recall operators encode suffix pref tau pref pref pref distinguishes analogous constructors actions see section 
principles hoas encode binding operators functions higher order type name proc 
allows delegate directly metalanguage cc ind conversion capture avoiding substitution 
need implement explicitly conversion mechanism done see section 
seen half ensure freshness bound names respect existing ones notion substitution names bound 
encoding outlined possible pure lf approach inspired encode syntax calculus inductive definitions constructor axiomatized constant 
order deal strong late equivalences processes pure lf approach axiomatize discrimination injection principles process constructors induction principle processes 
hand principles immediately available mechanism inductive definitions coq 
signature consisting declarations section 
xn def name 
xn name instance discrimination principle injection principle syntactic equality rendered coq leibniz equivalence 
course discrimination principle pair different constructors injection principle constructor 
px nil bang tau pref par sum nu name match mismatch pref name xy pref proc px nil bang tau pref par sum nu fresh match mismatch pref fresh pref xy encoding decoding functions syntax calculus 
def proc canonical canonical term mean essentially long head normal form sense 
encoding decoding functions defined sake simplicity drop exponents 
map fresh fixed fresh name selection function condition fresh satisfy finite fresh possible definition fresh enumeration ni fresh nmax ni 
encoding processes faithful original system sense formalized theorem theorem adequacy syntax finite 
compositional surjection px proc 
compositional injection proc px 

px proof 
standard induction structure processes normal forms type proc 
consequence theorem equivalent processes encoded term corollary px 
considered slightly non standard feature presentation calculus 
fact original system equivalent processes taken distinct 
matter discussion essential 
introduce signature inductive predicates isin notin reflect level language metatheoretic properties occurrence non occurrence variable coq code reported appendix 
roughly isin holds iff name occurs free process dually notin encodes freshness names processes 
interesting point predicates needed interested reasoning evaluation processes mismatch operators 
encoding late operational semantics section describe encoding transition system 
differently approaches encoding transition relation higher order follows 
take advantage inductive features cc ind transition relation rendered mutually defined inductive predicates ftrans btrans take care transitions involving free actions bound actions respectively 
case result transition process process context process hole conveniently represented function name proc 
arity complete code appears section mutual inductive ftrans proc act proc prop btrans proc act name proc prop act act inductive sets representing free actions bound actions respectively inductive act set tau act name name act 
inductive act set name act bout name act 
notice constructors sets defined order bind name actions 
bound actions free names mentioned bound names objects represented indirectly holes result process bound transition 
choice formalizing transition relation means predicates forces duplicate rules schemas involve schematic variable 
formalize version ftrans btrans 
view hoas leads substantial clarification original syntax calculus 
side conditions need explicitly encoded automatically taken care metalevel 
view hoas lets focus essence calculus away tedious unnatural details concerning names 
case instance scope extrusion rule close order syntax different albeit equivalent forms rule 
hoas allows delegate metalanguage freshness non occurrence issues formalizations rules collapse term metalanguage viz close ftrans 
way metalanguage deals fresh variables needs care 
true time new variable type name introduced proof environment automatically chosen metalanguage different pre existent variable 
fact explicit known object level 
information necessary uses hoas order logic evaluating processes calculus mismatch 
need isin notin predicates case 
reasoning aspects calculus mismatch operator strong late bisimilarity processes especially reasoning calculus explicit information indispensable 
fact features properties calculus deal explicitly freshness names 
need reflect reify information object level 
achieve introducing freshness hypotheses notin assumptions locally quantified name 
amounts strengthening encoded versions rules match strength original ones 
complex case encoding res rule ftrans follows name proc act nlist name notin nu notin nu nlist notin act notin ftrans ftrans nu nu apply rule locally bound variable automatically chosen different variables 
order reflect fact object level need introduce extra assumptions 
mentioning notin act notin state appear assumption nlist notin allows specify finite set list names variable differ 
sound locally bound differs variables course consider mismatch operator interested discussing coq strong late bisimilarity extra hypotheses safely dropped 
case encoding syntax language section case operational semantics coq inductive definition profitable 
instance elimination inversion tactics immediately available 
course price extra encoding elaborate proof search operational semantics encoded pure lf approach second order quantification 
signature declared far adequate sense theorem theorem adequacy ftrans btrans completeness finite exists canonical ftrans tau 
px xy exists canonical ftrans 
px 
px px exists canonical btrans name 
px px exists canonical btrans bout name soundness finite 
px exists canonical ftrans tau exists px 
px exists canonical ftrans exists px xy 
px px exists canonical btrans name exist px 
px px exists canonical btrans bout name exist px proof result long induction structure derivations structure normal forms 
adequacy result elaborate decoding successful transition equivalence resulting process see corollary 
root awkwardness fact judgements original presentation calculus closed conversion 
instance transition shape derived system 
subtle failures closure conversion arise connection rule res 
consider formal lemma weird na interpretation weird derivation derivation unsound application res appears 
sound decoding weird derivation variable name 
lemma weird btrans nu name pref name nil name nu name nil 
apply name nil empty intros apply 
qed 
res res failure closure conversion 
encoding strong late bisimilarity section discuss encoding strong late bisimilarity processes 
cc ind done various ways 
define strong late bisimilarity coinductive binary predicate processes greatest fixed point la tarski appropriate operator binary relations processes 
approach carried inductive definitions straight higher order logic 
prove formally coq approaches equivalent far provability 
differ substantially point view practical proof search 
coq fact provides different sets built tactics inductive coinductive types case pure higher order definition derived principles 
approaches lead different proof developments 
course versions greatest fixed point approach differ amount user 
discuss detail coinductive greatest fixed point approach inductive version ones practical elimination inversion tactics appropriate point view proof development 
prove formally cc ind equivalence 
section shall compare practical point view 
guarded approach key feature cc ind implemented coq versions respect predecessors lf cc cic possibility defining coinductive types 
take full advantage feature defining directly coinductive property strong late bisimilarity 
achieved means just coinductive definition defines class coinductive sets parametrized pairs processes processes contains set finitary infinitary proofs equivalence formal definition coinductive predicate stbisim representing strong late bisimilarity section 
predicate rule sb natural derived definition strong late bisimilarity definition processes bisimilar transition reducts bisimilar 
signature defined far extended declaration section soundness encoding theorem theorem soundness processes fn exists term stbisim strongly bisimilar 
proof 
defined follows def exists stbisim 
prove bisimulation definition 
free action theorems definition exist ftrans stbisim tau xy 
rule stbisim exists canonical terms term ftrans stbisim 
exploiting definition theorems exists case dealt similarly 
case bound actions follows closely free actions btrans place ftrans 
bisimulation worthwhile noticing soundness result depend particular formalization syntax operational semantics adopted provided adequate 
change encoding theory calculus sticking pure lf approach inductive definitions 
long adequacy results hold theorems theorem holds 
completeness encoding converse theorem hold 
faithfully represented logical framework 
suppose complete encoding type checking decidable absurd 
restrict set processes finite agents decidable complete axiomatization available section 
fragment encoding complete 
greatest fixed point approach approach described fits neatly notion strong late bisimilarity carried intuitionistic logical frameworks featuring coinductive types cc ind alf 
alternative traditional approach fact strong late bisimilarity encoded formulating logical framework definition greatest fixed point style tarski 
approach adopted cases see due generality 
carry alternative encoding need inductive fragment cc ind encoding readily translated logical frameworks mutatis mutandis 
formally proceed follows 
define monotone operator relations processes see section 
notice done away inductive definitions op stbisim simpler definition inductive version convenient respect proof tactics coq 
define ordering relations definition proc proc prop proc 
characterize strong late bisimilarity greatest fixed point op stbisim inductive stbisim proc prop ind proc proc prop op stbisim stbisim 
amounts saying order prove stbisim find relation included op stbisim holds internal cross adequacy interesting point approaches outlined previous paragraphs formally proved equivalent coq lemma soundness proc stbisim stbisim 
lemma completeness proc stbisim stbisim 
results compared constructions carried gim nez section 
practical point view lemmata useful 
imply order prove bisimilarity matter encoding 
choose greatest fixed point coinductive depending prefer practically easier 
applying proof terms cross adequacy lemmata convert strong late bisimulations kind equivalent strong late bisimulations kind 
completeness lemma theorem prove soundness greatest fixed point encoding strong late bisimilarity 
signature defined far extended declaration section predicate included stbisim corollary soundness processes fn exists term stbisim strongly bisimilar 
formal verification section coq important sections 
report substantial case study formal verification development coq theory calculus developed section 
enterprise significant various viewpoints 
knowledge largest case studies involving coinductive types 
furthermore serious attempt higher order syntax la church studies outside type theory 
order achieve satisfactorily devise theory contexts higher order syntax 
methodology follow doing axiomatic 
prefer introduce directly necessary properties axioms proving basis possibly inductive principles require form justification 
section shall briefly indicate possible ways carrying formal justification 
axioms explicit general properties contexts processes normally taken granted informal reasoning process mention names name occur generic 
feel axiomatic approach appropriate formal verification leaves open issue justifying axioms 
case birth geometry ancient greece story 
recommended methodological attitude postulating strictly necessary trying unwanted ontological commitments 
axiomatization general flavour readily adapted metatheoretic treatments systems hoas 
specifically section recall theory calculus appearing section 
section extend signature contains axiomatization theory calculus contexts order establish formally properties consideration 
section formal counterparts section formally verified coq 
section report proper verification activity including statistical data compare contrast formally verified theory development development hand 
theory calculus developed section section standard basic properties calculus processes 
contains crucial lemmata concerning transition semantics calculus basic algebraic theory strong late bisimilarity 
order easier follow formal representation verification results carried subsections recall 
course reformulated account fact syntax contains mismatch operator features place original equational rewriting 
stick original numbering appearing 
theorem mpw strong late bisimulation 
theorem mpw 
equivalence relation 
free action 
fn theorem mpw theorem mpw theorem mpw theorems mpw fn subject theorems mpw fn fn fn technical lemmata lemma fn fn fn fn bn 
lemma respectively exists respectively 
lemma bn fn fn bn exists lemma fn bn fn exist lemma free action exists respectively exists respectively 
lemma fn 
lemmata concerned names conversion 
particular lemmata state preserved conversion substitution fresh names respectively 
freshness condition lemma differs original lemma presence mismatch operator syntax 
basic technique proving properties exhibiting explicitly suitable strong late bisimulations 
cases achieved indirectly appropriate alternative forms bisimulations bisimulations restriction subsequently proved included 
shall recall technical lemmata appear section concerning alternative forms bisimulations 
formally verified proofs results build coq follow fact completely different pattern guarded induction principle 
signature reasoning metatheory calculus establishing metatheoretic properties higher order encoding straightforward cases symmetry reflexivity monoidal laws see section 
cases proofs metatheoretic properties problematic 
especially case proofs hand deal directly aspects hoas encodings delegate metalanguage substitutions freshness conversion 
proving transitive theorem instance dealing restriction operator reasons directly explicit substitutions bound name fresh 
mimicked hoas encoding bound names directly visible 
order handle adequately name related results need add new axioms concerning names processes actions 
essentially reflect theory level fact axiomatization isin notin captures correctly informal notions occurrence non occurrence freshness respectively 
axioms natural general process fruitful conceptual analysis informal terms contexts 
far names concerned postulate axioms axiom unsat proc ex name notin 
axiom lem oc name proc isin notin 
axiom unsat states process contain names words process choose name occur 
justified calculus set names assumed infinite 
axiom lem oc states name occurs occur process 
adds classical flavour encoding allowing prove properties case analysis comparison names important proofs proceed case analysis names see lemmata 
axiom needed name inductive set higherorder induction principle proc 
simpler law excluded middle names name derivable lem oc vice versa 
notice tries derive lem oc induction syntax processes case binding constructors fails 
far processes actions concerned deal contexts 
particular experience general properties needed proving technical lemmata 
phrase intend expressions process action type expansion phrase name context occur 
extensionality contexts contexts equal equal fresh name monotonicity appear appear 
clearly hold contexts processes actions informally proved induction syntax 
instances proved cc ind fact higher order encoding contexts syntactic sort represented functions term type name proc stands process hole filled names 
induction principle level functional types type theory taken axioms 
full list axioms appendix examples uses proof developments 
particular far processes regarded assumed axiom proc ext name proc name notin nu notin nu axiom proc mono name proc name notin notin nu 
axiom proc ext equivalently processes formulating nu nu equality proc name proc 
form adopt highlights equivalence contexts simply formul uniform formulation higherorder instances principle see ho proc ext 
expansion proved corresponding expansion law higher order processes processes holes axiom ho proc exp name proc name ex name name proc notin nu name nu 
axiom ho proc exp name name proc name ex name name name proc notin nu name nu name nu 
axiom ho proc ext name name proc name notin nu name nu notin nu name nu free bound actions extensionality monotonicity properties postulated case expansion law proved 
properties capture idea functions type name proc processes hole just filled name changing structure process 
holds long name inductive set easy get inconsistency defining exotic functions case analysis 
instance define name nat take def def def name nil def name proc case nil name par nil nil definitions nil par nil nil 
extensionality easily prove nil par nil nil inconsistent proc inductive 
worthwhile noticing axioms peculiar calculus 
contrary proper hoas approach tries capture general theory contexts 
mutatis mutandis set axioms readily applicable formalizations hoas need reasoning details hoas takes care metalevel 
course ask formal justification axioms 
point model categories presheaves validates axioms just developed martin hofmann 
line justification 
consider term model signature basic signature axioms question 
model type name name proc interpreted set canonical terms case constructor 
proved induction syntax terms axioms hold model term model model axioms 
course model types corresponding axioms inhabited 
apply strong form reflection internalize properties introducing remaining axioms kind reflection principle invoke say claiming consistency existence inaccessible cardinal bare consistency axioms set theory 
notice pointed hofmann axioms proc ext unsat lem oc inconsistent assumed axiom unique choice axiom uc set prop ex ex 
coq axiom uc derivable 
derived kinds prop set identified 
metalogic quite weird notion existential far removed standard intuition 
wonder axioms dictated ordinary reasoning inconsistent 
verifying section section comment experiments formal theory calculus carried coq encoding particular computer assisted verification formal counterpart section 
properties formally proved listed appendix proofs properties trans congruence respect constructor laws quite simple 
need deal low level details names exploiting fully coinductive features offered coq combination top refinement proceed directly need introduce auxiliary notions bisimulations 
case instance associativity 
proved introducing new kind bisimulation called strong late bisimulation restriction proved strong late bisimulation 
encoding need introduce notion bisimilarity 
suitable bisimulation built coq directly interactively means guarded applications coinductive hypothesis coinductive circular argument see appendix 
proof transitivity commutativity coinductive argument ultimately relies lemma 
rendered coq follows lemma lemma name proc name notin nu notin nu stbisim name notin nu notin nu stbisim 
lemma reflects reasoning style frequently dealing schematic derivations freely replaces occurrence variable fresh 
precisely kind properties require extra axioms introduced section order proved 
quite long coq proof lemma peculiarity exploits possibility switching greatest fixed point coinductive encodings means cross adequacy result section 
proof stbisim reduced existence bisimulation built inductively sketch 
may wonder lemma proved directly coinductive proof 
existence coinductive proof term lemma eventually proved easy derive directly means tactic 
main problem apply coinductive hypothesis twice nested manner violates restrictive conditions enforced coq 
direct coinductive proof follow natural pattern adopts informally 
coq code available www dimi pi calculus html interesting point higher order encoding may express prove properties natural correspondence ordinary calculus 
fact equivalence strong late bisimulation lemma eta name proc stbisim nu nu name 
decoding nu name nu property important formal reasoning allows normalize process encodings canonical form 
turned essential proof laws theorems 
hoas clashes especially connection fact coq tactics deal adequately higher order unification 
example proofs lemmata simply rely mutual induction principle generated system 
weak applied goals involve context variables 
order overcome drawback introduce hand appropriate unifications 
proof congruence respect constructor needs particular care difficulty pointed earlier related top proof search connection rules satisfy sub formula property 
case problematic rule repl inversion tactic introduces subgoals new instances producing infinite regress 
overcame difficulty proving coq formal equivalent normal form theorem theorem action 
exist 
holds xy 
theorem proved induction structure allows invert effectively predicates shape deducing structure crucial proof congruence respect 
notice lists variables encoding restriction rule necessary 
consider example proof lemma 
argu ment goes usual induction depth derivations crucial step case res rule 
hypotheses inverting fn sake simplicity proposition denote 

fresh name fn 
induction hypothesis 
knowing conclude 
formalizing previous argument need enrich local environment encoding res rule generic list names order choose fn 
list contain names appear processes involved transition proof environment may come play different names 
case proof lemma list contains name introduced processes substitution 
conclude section giving statistics formal development coq 
data refer environment sun enterprise server ultrasparc processors mhz mb ram mb swap space process running coq native mode 
number proofs size source code kb maximum kb lemma length proofs average kb minimum byte soundness broadest proof tree main subgoals ass par times compilation theory sec cross adequacy sec theory contexts sec lemmata sec metatheory sec congruence sec maximum memory consumption mb comparing sec 
formal counterparts section briefly compare formal development basic theory version appearing section emphasizing gained learnt experience 
place formal development forced spell proofs details 
effect imperfections proofs 
proof lemma res case fact follow hypotheses fv chosen fresh respect names 
proof easily fixed requiring extra condition explicitly loss generality 
formalization extra condition reflected encoding rule res introducing generic list names assuming bound variable appear 
secondly minor omission appears proof transitivity mention lemma 
formalization lemma turns indispensable case bound output transitions 
remarkably hand proofs imperfections extraordinarily detailed exceptionally accurate exhaustive proofs 
pointed previous subsection formal proofs adopt completely different approach 
case properties proved bisimulations commutativity 
tactic need introduce explicitly auxiliary notions bisimulations show included 
directly prove properties means natural coinductive arguments thesis hypothesis accordingly guarded induction principle 
remarked sense proofs easier corresponding ones section directly guided definition bisimulation 
follow common pattern rule strong late bisimilarity sb 
need produce advance bisimulation containing processes 
bisimulation gradually built interactively proof way completely transparent user 
hoas tradeoff 
hand simplification arguments 
obvious case theorem asserts equivalence bisimulation 
theorem simply disappears 
happens lemma lemma 
example lemma stated different ways 
versions differ hypothesis bound names 
hoas hypotheses need formulated explicitly enforced metalanguage 
formal translation need worry formulation choose versions formalized type 
reason lemma lemma collapse formalization 
hand hoas problematic establishing metatheoretic properties involving exactly notions delegated metalanguage substitution names freshness conversion 
overcome difficulties introduce section partial axiomatization theory contexts full list appears section 
informal reasoning properties usually taken granted formal approach postulated 
point main difference formal top development version hand system structural congruences 
effect literature operational semantics calculus structural congruence relation suitable semiautomatic proof search lead non founded proof trees 
rules eq applied reducing complexity goal 
suppose prove goal inverting hypothesis want reason case analysis way hypothesis inferred 
eq rule applicable invert find back proof search problem similar started 
prove goal context containing premises eq inversion arises problem inversion leads apply ad infinitum symmetry rule switching back forth 
luckily exist purely transitional presentations calculus ones 
faithful hoas encoding calculus inspired suitable logical frameworks intuitionistic type theory 
view representation advantages compared traditional approaches formal developments calculus 
extensive careful higher order syntax frees tedious encoding ordinary mechanisms involved handling bound names automatically inherited metalevel 
solution offers smooth simple treatment syntax processes transitions produces think clean intuitive representation system 
forced mention explicitly isin notin predicates side conditions freshness sure facing essential peculiarity calculus handling bound variables 
case instance restriction operator 
main drawback hoas difficulty dealing metatheoretic issues concerning names process contexts terms type name proc 
consequence natural metatheoretic properties involving substitution freshness names inside proofs processes proved inside framework postulated 
soundness completeness axiomatization elementary theory contexts deserves investigation 
case martin hofmann announced axioms validated suitable pre sheaves models 
investigated detail ways encoding strong late bisimulations means inductive encoding tarski definition greatest fixed point means coinductive predicate 
approach widely applicable takes full advantage pragmatic features offered coq coinductive tactics guarded induction principle coquand gim nez 
originally anticipated coquand tactic allows straightforward development equivalence proofs force user produce advance bisimulation 
having introduce auxiliary generalized forms strong late bisimulation restriction strong late bisimilarity bisimulation introduced 
formal development nontrivial fragment theory calculus coq encoding essentially amounts section 
dealt strong late bisimilarity 
ideas techniques quite general readily applied case strong early semantics see appendix weak semantics see 
summing claim faithful proof editor calculus practical workbench reasoning calculus 
related solutions adopted quite different formal developments calculus proof development environments 
calculus encoded isabelle hol means plain firstorder inductive approach 
binding syntactic constructor input prefix represented order constructors syntactic operations substitution delegated metalevel defined hand 
bisimulations defined directly translating coinductive definitions inductive setting done section 
fragment polyadic calculus encoded coq radically different approach 
names represented means de bruijn indexes need introduce specific set names higherorder syntactic constructors 
encoding close intuitive syntax processes non trivial additional technical machinery needed order manipulate indexes communications 
author proves formally purely inductive setting interesting set properties operator encoding calculus calculus sangiorgi theory progressions context techniques inductive setting 
formalized metatheoretic reasoning systems hoas explored authors 
apart approaches current state development appears general sustain investigations calculus 
current encoding cc ind calculus step wider research programme building computerized tools reasoning processes algebras 
open problems concerning system 
just recall complete formal development hoas theory contexts analysis induction principles higher order types 
pragmatic constraints current implementation coq partially affect friendliness workbench calculus 
instance mention fact nested applications coinductive hypotheses allowed available instances higher order unification sufficiently general 
limitations hopefully removed releases coq 
current multitude variants calculus brings serious problem develop general proof editor mobile processes 
think considering encodings weaker notions bisimulation polyadic versions asynchronous versions calculus 
issue building proofs systems general action calculi addressed 
time considered polyadic calculus 
higher order presentation system bring forward host radically new delicate issues 
main issue face adequacy problem arising encoding syntactic categories introduced milner original system normal processes processes abstractions concretions agents 
categories defined dependent mutual manner normal process considered process abstraction arity zero 
straightforward way encoding dependencies dependent types theory cc ind means coercion operators 
yields different canonical terms belonging type representing object 
obviously standard form adequacy achieved case exist compositional bijection objects polyadic calculus cc ind terms representing 
despite problem recover form adequacy introducing concept encoding relations simply formalization correspondence syntactic objects polyadic calculus cc ind terms encoding 
difficult problem arises connection representation milner pseudo application embodies complexity communicating names time channel 
original syntax relies multiple substitution data names bound names cc ind abstractions applications monadic 
exploiting higher order syntax possible decompose polyadic communication monadic ones appearance composed substitution 

grateful jo lle despeyroux mauro eduardo gim nez martin hofmann marina christine paulin mohring randy pollack davide sangiorgi anonymous referees helpful hints discussions 
preliminary version ic eatcs school models paradigms concurrency held udine italy september 
note added proof 
print flaw discovered typing systems coq version 
systems define non normalizing terms nesting coinductive definitions 
typing system current version coq strengthened ruling nested coinductive terms altogether 
consequence significant cases correct apply anymore previously proved coinductive lemma inside coinductive proof 
top coinductive proofs developed coq check longer new version 
properties proved internal adequacy result section longer inductive arguments time possibly upto techniques 
original updated coq code available www dimi pi calculus html avron honsell mason pollack 
typed lambda calculus implement formal systems machine 
journal automated reasoning 
coq proof assistant manual version 
inria may 
available ftp ftp inria fr inria coq doc 
coquand 
infinite objects type theory 
pages 
coquand huet 
calculus constructions 
information control 
cornes 
automating inversion inductive predicates coq 
pages 
despeyroux felty hirschowitz 
higher order syntax coq 
proc 
tlca 
lncs springer verlag 
despeyroux pfenning sch rmann 
primitive recursion higher order syntax 
cmu cs school computer science carnegie mellon university pittsburgh 
aug 

sistemi di dei 
thesis universit di udine italy july 
italian 
geuvers 
inductive coinductive types iteration recursion 
available www dcs ed ac uk research types bra proc proc dvi gz june 
gim nez 
application inductive types coq verification alternating bit protocol 
pages 
gim nez 
codifying guarded recursion definitions recursive schemes 
proc 
types 
lncs springer verlag 
harper honsell plotkin 
framework defining logics 
acm jan 

bisimulation proofs calculus calculus constructions 
proc 

lncs springer verlag 
honsell montanari pistore 
final semantics calculus 
proc 

ifip chapman hall 
honsell miculan 
natural deduction approach dynamic logics 
pages 
hofmann 
semantical analysis higher order syntax 
proc 
th lics 
ieee 

themes final semantics 
phd thesis dipartimento di informatica universit di pisa italy mar 
martin meaning logical constants justifications logic laws 
tr dip 
di matematica universit di siena 
mcdowell miller 
logic reasoning higher order syntax 
proc 
th lics 
ieee 
melham 
mechanized theory calculus hol 
nordic comput 
miculan 
expressive power structural operational semantics explicit assumptions 
pages 
miculan 
encoding logical theories programs 
phd thesis dipartimento di informatica universit di pisa italy mar 
milner 
polyadic calculus tutorial 
logic algebra specification volume nato asi series springer verlag 
milner parrow walker 
calculus mobile processes 
tech 
rep ecs lfcs dept computer science univ edinburgh june 
milner parrow walker 
calculus mobile processes 
inform 
comput 
milner parrow walker 
modal logics mobile processes 
theoretical computer science 
nipkow paulson 
isabelle system 
proceedings cade pages 
lncs springer verlag 
nordstr petersson smith 
programming martin type theory 
oup 
paulin mohring 
inductive definitions system coq rules properties 
proc 
tlca pages 
lncs springer verlag 
pfenning elliott 
higher order syntax 
proc 
acm sigplan pages june 
acm 
pollack 
theory lego 
phd thesis univ edinburgh 
rossi 
di 
thesis universit di udine italy 
sangiorgi 
theory bisimulation calculus 
acta informatica 

di di logical frameworks 
thesis universit di udine mar 
italian 
schroeder heister 
natural extension natural deduction 
symbolic logic dec 
proceedings types 
lncs springer verlag 
proceedings types 
lncs springer verlag 
coq code occur check predicates inductive isin name proc prop isin bang proc isin isin bang isin tau proc isin isin tau pref isin par proc isin isin par isin par proc isin isin par isin sum proc isin isin sum isin sum proc isin isin sum isin nu name proc name isin isin nu isin match proc name isin isin match isin match proc name isin match isin match proc name isin match isin mismatch proc name isin isin mismatch isin mismatch proc name isin mismatch isin mismatch proc name isin mismatch isin name proc name name isin isin pref isin name proc isin pref isin proc name isin isin pref isin proc name isin pref isin proc name isin pref 
inductive notin name proc prop notin nil notin nil notin bang proc notin notin bang notin tau proc notin notin tau pref notin par proc notin notin notin par notin sum proc notin notin notin sum notin nu name proc name notin notin nu notin match proc name notin notin match notin mismatch proc name notin notin mismatch notin name proc name name notin notin pref notin proc name notin notin pref 
inductive act notin name act prop act notin tau act notin tau act notin name act notin 
definition act notin ho name name act name act notin 
inductive act notin name act prop act notin name act notin act notin bout name act notin bout 
definition act notin ho name name act name act notin 
transition system calculus mutual inductive ftrans proc act proc prop tau proc ftrans tau pref tau proc name ftrans pref proc act ftrans ftrans sum proc act ftrans ftrans sum proc act ftrans ftrans par par proc act ftrans ftrans par par name proc act ftrans ftrans match name proc act ftrans ftrans mismatch proc act ftrans par bang ftrans bang com proc name proc name btrans ftrans ftrans par tau par com proc name proc name ftrans btrans ftrans par tau par name proc act nlist name notin nu notin nu nlist notin act notin ftrans ftrans nu nu close proc name proc name btrans btrans bout ftrans par tau nu name par close proc name proc name btrans bout btrans ftrans par tau nu name par btrans proc act name proc prop name proc name btrans pref proc act name proc btrans btrans sum proc act name proc btrans btrans sum proc act name proc btrans btrans par name par proc act name proc btrans btrans par name par name proc act name proc btrans btrans match name proc act name proc btrans btrans mismatch proc act name proc btrans par bang btrans bang name proc act name name proc nlist name notin nu nlist notin notin nu name nu btrans btrans nu name nu open name proc name name notin nu notin nu ftrans btrans nu bout 
coinductive encoding strong late bisimilarity coinductive stbisim proc proc prop sb proc act proc ftrans ex proc ftrans stbisim proc ftrans ex proc ftrans stbisim name name proc btrans ex name proc btrans name stbisim name proc btrans ex name proc btrans name stbisim name name proc btrans bout ex name proc btrans bout name notin nu notin nu stbisim name proc btrans bout ex name proc btrans bout name notin nu notin nu stbisim stbisim 
coinductive encoding strong early bisimilarity early semantics obtained replacing com com com xz xz xy com xz xz rules encoded natural way definition ftrans just replace rules com com ein name proc name ftrans pref fin proc name ftrans fin ftrans ftrans par tau par proc name ftrans ftrans fin ftrans par tau par fin name name act new constructor type act 
definition binary relation processes strong early simulation sq implies bn fn exists sq relation strong early bisimulation strong early simulations 
strong early bisimilar written sq strong early bisimilarity encoding coinductive proc proc prop seb proc act proc ftrans ex proc ftrans proc ftrans ex proc ftrans name name proc btrans ex name proc btrans name notin nu notin nu name proc btrans ex name proc btrans name notin nu notin nu name name proc btrans bout ex name proc btrans bout name notin nu notin nu name proc btrans bout ex name proc btrans bout name notin nu notin nu 
operator strong late bisimilarity inductive op stbisim proc proc prop proc proc prop op sb proc act proc ftrans ex proc ftrans proc ftrans ex proc ftrans name name proc btrans ex name proc btrans name name proc btrans ex name proc btrans name name name proc btrans bout ex name proc btrans bout name notin nu notin nu name proc btrans bout ex name proc btrans bout name notin nu notin nu op stbisim 
definition proc proc prop proc 
inductive stbisim proc prop ind proc proc prop op stbisim stbisim 
theory contexts process contain names axiom unsat proc ex name notin 
law excluded middle decidability occur check predicates axiom lem oc name proc isin notin 
extensionality contexts axiom proc ext name proc name notin nu notin nu 
name occur applied context occur context axiom proc mono name proc name notin notin nu 
free actions axiom act ext name act name act notin ho act notin ho axiom act mono name act name act notin act notin ho 
bound actions axiom act ext name act name act notin ho act notin ho axiom act mono name act name act notin act notin ho 
extensionality processes contexts axiom ho proc ext name name proc name notin nu name nu notin nu name nu beta expansions axiom ho proc exp name proc name ex name name proc notin nu name nu 
axiom ho proc exp name name proc name ex name name name proc notin nu name nu name nu 
uses axioms 
expansion 
consider proof transitivity case bound output actions prove knowing 

hold 
obviously order prove goal natural show hold 
necessarily imply need expansion axiom 

lemma 
context 
definition iff process 
prove process 
sake simplicity prove subgoal analogous 
accomplished applying lemma fresh name yields subgoal 
conclude applying lemma obtain hypothesis extensionality 
consider lemma usual properties concerning lts proceed induction derivation depth judgement proof case transition follows infer 
coq argument rendered follows term coincides tau pref coincides tau coincides 
tau pref 
conclude need extensionality axiom proc ext prove equivalent tau pref analogous argument applies transition label 
monotonicity 
consider lemma fn fn fn 
proof induction derivation depth transition judgement deal case res rule fn 
inverting hypothesis deduce 
induction hypothesis know fn fn fn 
facts fn fn 
argument natural coq correspond respectively nu nu 
represented satisfies properties freshness notin nu notin nu recall name 
name 

part thesis regarding transition label easy order prove notin nu need monotonicity axiom proc mono know notin nu hypothesis notin induction hypothesis 
technical lemmata calculus form lemma free bound transitions lemma proc act name notin ftrans act notin notin 
lemma btr proc name proc act name notin btrans act notin notin nu 
lemmata free bound transitions lemma name proc name act name notin nu notin nu act notin ho ftrans name notin nu notin nu act notin ho ftrans 
lemma btr name proc name name proc name act name notin nu notin nu name nu act notin ho btrans name notin nu notin nu name nu act notin ho btrans 
lemma lemma name proc name notin nu notin nu stbisim name notin nu notin nu stbisim 
toolkit calculus section equivalence 
theorem variables proc 
lemma ref stbisim 
lemma sym stbisim stbisim 
lemma trans stbisim stbisim stbisim 
equivalence 
section structural congruence 
theorem variables proc 
hypothesis stbisim 
lemma tau stbisim tau pref tau pref 
lemma sum stbisim sum sum 
lemma par stbisim par par 
lemma bang stbisim bang bang 
variables name 
lemma match stbisim match match 
lemma mismatch stbisim mismatch mismatch 
lemma stbisim pref pref 
variable name proc 
lemma nu name notin nu notin nu stbisim stbisim nu nu 
lemma notin nu notin nu name isin nu isin nu stbisim stbisim pref pref 
structural congruence 
section monoidal sum 
theorem variables proc 
lemma id sum stbisim sum nil 
lemma idem sum stbisim sum 
lemma comm sum stbisim sum sum 
lemma ass sum stbisim sum sum sum sum 
monoidal sum 
section bang unfolding 
theorem lemma bang unf proc stbisim bang par bang 
bang unfolding 
section matching laws 
theorem variables proc 
variables name 
lemma match stbisim match 
lemma match stbisim match nil 
lemma mismatch stbisim mismatch 
lemma mismatch stbisim mismatch nil 
matching laws 
section restriction laws 
theorems variable proc 
variable name proc 
variable name name proc 
lemma nu stbisim nu name 
lemma nu comm stbisim nu name nu name nu name nu name 
lemma nu sum stbisim nu name sum sum nu nu 
lemma nu tau pref stbisim nu name tau pref tau pref nu 
lemma nu pref name stbisim nu name pref pref nu 
lemma nu pref name stbisim nu name pref pref name nu name 
lemma nu nil name stbisim nu name pref nil 
lemma nu nil stbisim nu name pref nil 
restriction laws 
section monoidal par 
theorem variables proc 
lemma id par stbisim par nil 
lemma comm par stbisim par par 
lemma ass par stbisim par par par par 
variables name proc 
lemma nu extr stbisim nu name par par nu 
lemma nu par stbisim nu name par par nu nu name 
lemma nu par stbisim nu name par par nu name nu 
monoidal par 
example proof section develop formally cases proof associativity 
theorem property proved bisimulation restriction 
approach take advantage tactic 
order proof fragment readable allow comparison corresponding proof insert comments explain effect tactics applied list proof environments incrementally generated 
worthwhile noticing main difference formal development proof coq informal counterpart incremental building necessary bisimulation need explicit bisimulations 
lemma ass par proc stbisim par par par par 
proof 
subgoal proc stbisim par par par par apply tactic introduces thesis hypotheses apply rule sb order ensure subsequent applications thesis guarded legal ass par intros apply sb try split intros 
subgoals ass par proc stbisim par par par par proc proc proc act proc ftrans par par ex proc ftrans par par stbisim subgoal ex proc ftrans par par stbisim subgoal ex name proc btrans par par name stbisim subgoal ex name proc btrans par par name stbisim subgoal ex name proc btrans par par bout name notin nu notin nu stbisim subgoal ex name proc btrans par par bout name notin nu notin nu stbisim subgoals consider fact case comes symmetric corresponding clauses definition strong late bisimilarity cases omitted 
case milner parrow walker appendix theorem subgoal ass par proc stbisim par par par par proc proc proc act proc proc name proc name proc name btrans bout btrans ex proc ftrans par par tau stbisim par nu name par tau supply explicitly process corresponding ass par exists nu name par par split 
subgoal ass par proc stbisim par par par par proc proc proc act proc proc name proc name proc name btrans bout btrans ftrans par par tau nu name par par subgoal stbisim par nu name par nu name par par prove subgoal claims tau ass par change ftrans par par tau ass par nu name par name par ass par apply close assumption apply assumption 
remaining goal claims subgoal ass par proc stbisim par par par par proc proc proc act proc proc name proc name proc name btrans bout btrans stbisim par nu name par nu name par par directly prove 
notice introduce auxiliary notion bisimulation necessary bisimulation built implicitly applying coinductive hypothesis ass par ass par apply sym ass par apply trans nu name par par 
subgoal ass par proc stbisim par par par par proc proc proc act proc proc name proc name proc name btrans bout btrans stbisim nu name par par nu name par par ass par apply nu intros apply sym apply ass par 
lemma nu states stbisim congruence respect nu see appendix subgoal ass par proc stbisim par par par par proc proc proc act proc proc name proc name proc name btrans bout btrans stbisim nu name par par par nu name par ass par change stbisim nu name par name par ass par ass par par nu name par ass par apply nu extr 
nu extr scope extrusion law see appendix case cases omitted qed 

