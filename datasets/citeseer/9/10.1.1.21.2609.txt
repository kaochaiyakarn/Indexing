making safe past adding genericity java tm programming language gilad bracha sun microsystems gilad bracha sun com martin odersky university south australia odersky cis edu au david stoutamire sun microsystems david stoutamire sun com philip wadler bell labs lucent technologies wadler research bell labs com gj design extends java programming language generic types methods 
explained implemented translation language 
translation closely mimics way generics emulated programmers erases type parameters maps type variables bounds inserts casts needed 
subtleties translation caused handling overriding 
gj increases expressiveness safety code utilizing generic libraries longer buried plethora casts corresponding casts inserted translation guaranteed fail 
gj designed fully backwards compatible current java language simplifies transition non generic generic programming 
particular retrofit existing library classes generic interfaces changing code 
implementation gj written gj freely available web 
generic types important language lacks may designed simulate 
object oriented languages designed support subtypes directly support generics idiom replacing variable types top type hierarchy 
instance collection elements type represented collection elements type object 
appear th annual acm sigplan conference object oriented programming systems languages applications oopsla vancouver bc canada october 
approach exemplified java programming language gls 
generics represented idiom standard java libraries including vectors hash tables enumerations 
java development kit jdk evolved generics played increasing role 
jdk introduced observer pattern depends generics collection classes introduced jdk 
oberon relies generic idiom dynamically typed languages smalltalk gr idiom implicitly 
generics may merit direct support 
designing language direct support subtyping generics straightforward 
examples include modula ada eiffel sather 
adding generics existing language routine 
proposed adding generics java programming language pizza ow know proposals afm mbl tt cs :10.1.1.26.1697
clemens szyperski proposed adding generics oberon rs 
strongtalk bg layers type system generic types top smalltalk 
generic legacy problem proposals tackle generic legacy problem direct support generics added language supports generic idiom happens legacy code exploits idiom 
pizza backward compatible java programming language legal program legal 
compatibility little help comes generics 
example jdk contains extensive library collection classes generic idiom 
straightforward rewrite library generics directly replacing legacy type collection parametric type collection 
pizza types incompatible rewrite legacy code write adaptor code convert legacy parametric types 
code bloat may result refer ences legacy parametric versions library 
note problem merely size legacy libraries may small managing upgrade legacy types parametric types major headache legacy types dispersed large body code 
legacy libraries code available binary source problems compounded 
gj propose gj superset java programming language provides direct support generics 
gj compiles java virtual machine jvm byte codes executed java compliant browser 
respects gj pizza gj differs tackles generic legacy problem 
gj contains novel language feature raw types capture correspondence generic legacy types retrofitting mechanism allow generic types imposed legacy code 
parametric type collection may passed corresponding raw type collection expected 
raw type parametric type representation adaptor code required 
retrofitting allows attribute existing collection class library parametric types requires version library added plus new code run jdk compliant browser built collection class library 
raw types retrofitting apply libraries code available binary class files source available 
combined techniques greatly ease task upgrading legacy code generics 
semantics gj translation back java programming language 
translation erases type parameters replaces type variables bounding type typically object adds casts inserts bridge methods overriding works properly 
resulting program pretty write language generic idiom 
pathological cases translation requires bridge methods encoded directly jvm byte codes 
gj extends expressive power java programming language remaining compatible jvm 
gj comes cast iron guarantee cast inserted compiler fail 
caveat guarantee void compiler generates unchecked warning may occur legacy parametric code mixed benefit retrofitting 
furthermore gj compiles jvm safety security properties java platform preserved 
second guarantee holds presence unchecked warnings 
security may contrast styles implementing generics homogeneous heterogeneous 
homogeneous style exemplified generic idiom replaces occurrences type parameter type object 
heterogeneous style exemplified ada copy class instantiation type parameter 
gj pizza compilers implement homogeneous translation agesen freund mitchell afm propose having class loader implement heterogeneous translation 
proposals utilize mixture homogeneous heterogeneous techniques cs 
observed agesen freund mitchell heterogeneous translation provides tighter security guarantees homogeneous 
example homogeneous translation method expecting collection secure channels may passed collection kind object leading security breach 
minimize problem gj inserts bridge methods subclassing generic class user may ensure security simply declaring suitable specialized subclasses 
homogeneous translation enjoys advantages heterogeneous 
surprisingly security model java virtual machine heterogeneous translation impossible form sensible type instantiations 
problem entirely obvious retrospect 
gj languages homogeneous translation suffer difficulty 
type inference type systems subtyping generics understood combine remains topic active research 
particular difficult infer instantiations type arguments generic methods 
gj uses novel algorithm purpose combines desirable blush contradictory properties local type expression depends types subexpressions context occurs works empty inference produces best types values empty list possible types 
inference algorithm supports subsumption expression type may regarded having supertype type 
contrast algorithm pizza non local support subsumption empty algorithm strongtalk bg empty local supports subsumption algorithms constraintbased type inference aw est non local empty support subsumption 
pizza uses variant hindley milner algorithm mil regard non local type term may depend context unification 
raw types retrofitting raw types serve purposes gj support interfacing legacy code support writing code situations definition equality method necessary downcast type object parameterized type linkedlist determine value type parameter 
type rules raw types carefully crafted compiler guarantee absence type errors methods equality 
interfacing legacy code compiletime checking possible case unchecked warning may issued 
proliferation unchecked warnings avoided retrofitting add information type parameters legacy code 
related gj closely handling parametric types pizza ow :10.1.1.26.1697
pizza compiler written pizza freely available web 
gj differs pizza providing greater support backward compatibility notably allowing new code old libraries 
gj uses simpler type system 
pizza type expression may depend type expected context gj type expression determined solely type constituents 
gj maintains run time information type parameters 
design decision pizza proposal add parametric types oberon rs 
number proposals adding parameterized types java programming language carrying type information runtime afm mbl cs 
run time types may efficient implement erasure may harder interface legacy code hand arguably expressive maintain run time type information consistent rest design java programming language maintains run time type information classes arrays 
reason gj designed compatible extension maintains type information run time 
particular cartwright steele developed design tandem gj cs 
just java programming language subset gj gj subset 
detailed comparison appears 
virtual types suggested alternative parametric types tho tor 
comparison relative strengths parametric virtual types appears bow 
may possible merge virtual parametric types bow tt clear benefits merger outweigh increase complexity 
status implementation gj freely available web gj 
gj compiler derived pizza compiler standalone compiler java programming language 
compiler lines gj 
concentrates design issues underlying gj 
companion papers provide tutorial gj precise specification gj 
outline remainder structured follows 
section introduces basic features gj running example collections linked lists 
section details translation gj java programming language jvm byte code 
section explains invariant subtyping rule parameterized types 
section describes type inference algorithm 
section discusses generics relate java platform security model 
section details restrictions imposed source language lack run time type information 
section introduces raw types 
section describes retrofitting 
section shows generics exploited implementation gj compiler 
section concludes 
generics gj shows simplified part java collection class library expressed gj 
interfaces collections iterators linked list class 
collection interface provides method add element collection add method return iterator collection iterator 
turn iterator interface provides method determine iteration done hasnext method return element advance iterator 
linked list class implements collections interface 
contains nested class list nodes node anonymous class list iterator 
interfaces class take type parameter written angle brackets representing element type 
nested class node implicit parameter inherited scope full name class linkedlist node 
scope type parameter entire class excluding static members static initializers 
required different instances class may different type parameters access static members 
parameters irrelevant class name access static member interface collection public void add public iterator iterator interface iterator public public boolean hasnext class extends class linkedlist implements collection protected class node elt node null node elt elt elt protected node head null tail null public linkedlist public void add elt head null head new node elt tail head tail new node elt tail tail public iterator iterator return new iterator protected node ptr head public boolean hasnext return ptr null public ptr null elt ptr elt ptr ptr return elt throw new class test public static void main string args linkedlist string ys new linkedlist string ys add zero ys add string ys iterator collection classes gj interface comparable public int class byte implements comparable byte private byte value public byte byte value value value public byte return value public int byte return value value class collections public static implements comparable max collection xs iterator xi xs iterator xi xi hasnext xi return generic methods bounds omitted 
general nested classes may type parameters static inherit type parameters surrounding class 
angle brackets chosen type parameters familiar users form brackets may lead confusion 
round brackets difficult distinguish type value parameters 
square brackets difficult distinguish type parameters array dimensions 
curly brackets difficult distinguish type parameters class bodies 
phrases linkedlist linkedlist string pose problem parser treated single lexeme 
similarly 
users required add extra spaces avoid problem 
gj grammar modified spaces required 
example shows part collection class library jdk expressed gj 
interface comparable objects compared objects type class byte implements interface type parameter bytes compared 
class defines static method max returns maximum element non empty collection 
method demonstrates features generic method bounded type parameter 
method generic applies variety types 
declare generic method quantified type variables written angle brackets preceding method signature body 
type automatically instantiated point 
instance ys type collection byte may write byte collections max ys parameter max inferred byte 
type parameter bounded varies types types comparable 
instance parameter may instantiated byte byte implements comparable byte 
type parameter interface class generic method may bounded 
bound indicated parameter keyword implements interface extends class 
bounding interface class may parameterized may include type variables appearing parameter section 
recursion mutual recursion parameters allowed gj supports bounded polymorphism 
omitting bound equivalent bound object 
translating gj translate gj java programming language replaces type erasure 
erasure parametric type obtained deleting parameter linkedlist erases linkedlist erasure non parametric type type string erases string erasure type parameter erasure bound collections max erases comparable 
translating gj code collection classes figures yields code figures 
translated code identical original collection class code written generic idiom 
property essential means gj program compiled parameterized collection library run browser contains original collection library 
translation method erases argument types return type inserts type casts required 
cast inserted method call result type method type parameter field access type field type parameter 
example compare test main translation cast inserted call 
translation inserts bridge methods ensure overriding works correctly 
bridge required interface collection public void add object public iterator iterator interface iterator public object public boolean hasnext class extends class linkedlist implements collection protected class node object elt node null node object elt elt elt protected node head null tail null public linkedlist public void add object elt head null head new node elt tail head tail new node elt tail tail public iterator iterator return new iterator protected node ptr head public boolean hasnext return ptr null public object ptr null object elt ptr elt ptr ptr return elt throw new class test public static void main string args linkedlist ys new linkedlist ys add zero ys add string string ys iterator translation collection classes interface comparable public int object class byte implements comparable private byte value public byte byte value value value public byte return value public int byte return value value public int object return byte class collections public static comparable max collection xs iterator xi xs iterator comparable comparable xi xi hasnext comparable comparable xi return translation generic methods bounds subclass non trivially instantiates type variable superclass 
example erasure comparable yields method takes object erasure byte yields method takes byte 
overriding occurs method signatures match exactly bridge method introduced translation byte takes object casts byte 
overloading allows bridge original method share name 
translation gj yields code identical original collection class library jdk including bridge methods 
bridge far problematic case bridging may arise type parameter appears result arguments overridden method 
class implements iterator interface 
class interval implements iterator integer private int public interval int int public boolean hasnext return public integer return new integer method class returns integer match instantiation type parameter 
translation yields 
expect bridge added interval class 
interface iterator public boolean hasnext public object class interval implements iterator private int public interval int int public boolean hasnext return public integer return new integer bridge public object return unfortunately legal java source code versions distinguished identical arguments 
code distinguishes intention declarations calls appropriate 
fortunately versions distinguished jvm identifies methods signature includes result type 
situation represents place gj defined translation directly jvm byte code 
gj permits covariant overriding overriding method may result type subtype method overrides match exactly java programming language 
example 
class implements public copy return clone class extends implements public copy return clone translation introduces bridge method second class 
class extends implements public copy return clone bridge public copy return copy implemented technique 
subtyping purposes type comparison subtyping invariant parameterized types 
instance class string subtype object parameterized type linkedlist string subtype linkedlist object 
comparison arrays covariant subtyping array type string subtype object 
invariant subtyping ensures type constraints enforced gj violated 
consider code 
class loophole public static string loophole byte linkedlist string xs new linkedlist string linkedlist object ys xs compile time error ys add return xs iterator code illegal violate type constraints returning byte string expected 
method call adds byte object list objects return extracts string list strings assignment aliases list string list objects fault 
instructive compare analogous code arrays 
class loophole public static string loophole byte string xs new string object ys xs ys run time error return xs code legal raises array store exception 
observe type safety covariant subtyping depends fact array carries type run time making store check possible 
approach viable parameterized types type parameters available run time 
class public linkedlist empty return new linkedlist public linkedlist singleton linkedlist xs new linkedlist xs add return xs public linkedlist linkedlist xs new linkedlist xs add xs add return xs class test static new public static void main string args linkedlist number zs new integer new float linkedlist string ys singleton null linkedlist byte xs empty linkedlist object err abc new integer compile time error example inference noted explicitly declared subtyping problem 
instance fine pass linkedlist string collection string expected 
type parameter inference gj includes novel type parameter inference algorithm permits elide type parameters polymorphic method calls 
type parameters safely omitted erased translation anyway carry operational meaning 
type parameters inferred parametric method call choosing smallest type parameter yields valid call 
example consider code defines factory methods lists zero elements 
example call integer float arguments infers type parameter number 
unique smallest type inference fails call string integer comparable class cell public value public cell value public static cell return new cell class pair public fst public snd public pair fst snd public static pair duplicate return new pair class loophole public static string loophole byte pair cell string cell byte pair duplicate cell null compile time error snd value return fst value public static string permitted string pair cell string cell string pair duplicate cell string null fst value return snd value illegal situation inference 
serializable common supertypes 
rule needs generalized cases argument types involving inferred variable argument null 
support inference cases type inferencer may bind type variable special bottom type type null 
type subtype type 
type type inference algorithm appear type declarations gj programs 
type containing regarded subtype type results replacing type 
exception rule invariant subtyping 
linkedlist subtype linkedlist string pair byte subtype pair byte byte 
instance second third calls method main type parameter inferred 
assignments valid linkedlist subtype linkedlist byte linkedlist string 
additional linearity restriction required type parameter instantiated appears interface interface interface extends interface extends class static choose return hash hash static void test choose ok near ambiguous situation inference result type 
see necessary consider code 
call duplicate loophole illegal smallest choice appears twice result type duplicate 
hand call duplicate permitted ok cast ensures smallest choice string 
cast smallest choice call illegal 
restriction loophole circumvent type system making possible treat string byte 
general covariance may lead unsound type system argue carefully type system restricted form covariance remains sound 
argument goes follows declare variables type value type assign pass variable parameter type 
possibilities depending variable type variable type supertype case assignment clearly sound 
variable type type position 
value populates type null value type furthermore method type argument contains bottom type parametric type equally applied 
value type value type assignment sound 
variable type type variable code accesses variable works type may instantiated code give rise type errors 
furthermore variable appears method linearity restriction method formal result type contain occurrence actual type method application form 
type parameter inference scheme similar pierce turner local type inference pt 
pierce turner consider covariant type constructors sensible assumption predominantly functional languages dealing 
gj exclusive invariant type constructors special treatment essential type inference 
experience far shown works 
instance gj compiler consisting lines heavily generic code single instance type inference helped explicit parameterization type cast 
instructive compare gj local type inference constraint inference hindley milner system mil extensions subtyping aw est 
essence type system correspond type hindley milner system fresh type variable 
type occurrence occurrence replaced different type variable 
subtyping types containing corresponds instantiations type variables hindley milner system 
linearity condition sure types duplicated types method calls inferred type mapped back fresh type variable method result type 
restriction types declared user roughly corresponds variable polymorphism restriction hindley milner wri ensures values containing mutable polymorphic 
note inference algorithm subject problems ambiguity 
consider code 
type inferencer determine formal parameter corresponds actual parameter call choose marked line 
say definition changed extends interface extends call choose ambiguous 
programmer taken care preserve supertypes structure interface code breaks due change 
undesirable property software engineering perspective 
java programming language suffers similar problem regard overloading adding type inference introduce new holes 
believe convenience inference outweighs attendant 
security implications homogeneous translation erases type information opens potential security hole run time 
hole filled needs aware 
consider example due agesen freund mitchell afm class extends channel public string read class public linkedlist cs 
linkedlist gets erased just linkedlist possible attacker add channel list way leak information secure system 
attacker written gj prevented generic type system 
attacker written gj java programming language jvm byte code language case compiler run time system detect type system violation 
address problem programmer needs prevent information type parameter lost erasure 
class questions export parameterized fields achieved declaring specialized type extends type linkedlist 
specialization inherits fields methods supertype constructor simply forwards analogous constructor supertype class extends linkedlist super class cs 
linkedlist gets translated type information lost 
furthermore gj translation scheme bridge methods ensures argument types properly checked run time 
translation class public static object newinstance object int return object array newinstance getclass class extends linkedlist super public void add object super add note inserted bridge method linkedlist add checks run time passed channel secure 
scheme applied public fields parameterized types access fields encapsulated bridge methods 
type specialization general method maintaining type parameter information lost erasure 
heterogeneous translation effectively applies type specialization looks better fit security perspective 
argued agesen afm 
surprisingly heterogeneous translation fits poorly security model java virtual machine 
problem reported lies package visibility model types interfere automatic type specialization 
jvm security model supports kinds visibility top level classes package wide public visibility 
possible refer class outside package class declared public 
jvm specification ly requires virtual machine throw class refers class package public 
rules impossible find package heterogeneous type instantiation placed 
consider instantiation parameterized class defined package applied parameter class defined different package possibilities class public case place instantiation package body class refer public classes case place instantiation package 
cases apply private package refers private classes package package place instantiation heterogeneous translation fail 
illegal access error raised matter package placed 
class accesses checked identifiers creating new instance array resolved run time error occur irrespective classes specialized compile time run time 
problem difficult packages effectively presence heterogenous translation 
change jvm security model clear change fix problem 
problem arise homogenous translation 
restrictions gj translation type erasure requires language restrictions necessary translation maintained types run time 
restrictions affect object array creation casts instance tests 
object array creation new expression type type variable illegal 
new illegal type variable 
expressions executed type parameters available run time 
great loss generic creation limited value 
create object variable type pass object suitable method creating new objects commonly called factory object 
new expression type array type variable generates unchecked warning 
new unchecked type variable 
expressions executed usual semantics type parameters available run time 
create arrays variable type recommended vector arraylist classes collection library pass array type model run time poor man factory object 
facilitate method provided gj lang reflect array class 
public static newinstance int call returns new array run time type length location initialized null 
method allows array act factory arrays type 
erasure method implemented terms existing reflection primitives shown 
types parametric typed version added gj library 
implemented retrofitting feature discussed section 
purposes defining vector necessary create new arrays variable type 
expressions unchecked illegal 
case translation replaces type variable bound usual 
new translates new object type variable bounded object 
creating new array variable type generate unchecked warning indicate type soundness constraints normally enforced gj may violated 
consider code 
class public static singleton return new unchecked warning public static void main string args string singleton zero run time exception code passes compiler unchecked warning issued expression new 
case creation expression violate gj type constraints called bound string creates array run time type object string 
translation code 
class public static object singleton object return new object public static void main string args string string singleton zero run time exception important recognize run time type system jvm remains secure line translated code fails run time 
safe create new array variable type takes care ensure array escape scope type variable 
method unsafe new array escapes scope type variable attached singleton method 
example sensible arrays consider vector class simplified collection library 
class vector public final int min capacity protected int protected public vector new min capacity public void add length new int public get int return throw new public void set int throw new public int size return public length array newinstance int int length null return vector class array type run time type object leaves scope class 
method returns array leaves scope class array argument array large array runtime type created newinstance 
usual code translated replacing object including replacing object 
casts instance tests type parameters available run time casts instance tests parameterized types permitted 
legal include parameters cast instance test parameters determined combination information known compile time determinable run time 
class convert public static collection linkedlist xs return collection xs public static linkedlist collection xs xs instanceof linkedlist return linkedlist xs throw new method cast omitted included clarity 
method run time information check collection linked list linked list compile time constraints ensure type parameters match 
parameterized types casts instance tests way verify parameter 
illegal 
class public static object linkedlist string xs return object xs public static linkedlist string object instanceof linkedlist string compile time error return linkedlist string compile time error throw new marked lines indicate compile time errors 
possible workarounds problem 
type specialization section creating new class extends linkedlist string 
class extends linkedlist string 
create wrapper class field type linkedlist string 
class linkedlist string contents case resulting class type parameters may target cast 
raw types occasionally necessary refer parameterized type stripped parameters call raw type 
raw types maintain consistency legacy code class linkedlist implements collection public boolean equals object instanceof linkedlist return false iterator xi iterator iterator yi linkedlist iterator xi hasnext yi hasnext xi object yi null null equals return false return xi hasnext yi hasnext equality raw types instance new code may refer parameterized type collection legacy code refer raw type collection 
raw types useful cast instance tests may adequate information run time check full parameterized type 
defines extension linked list class section define equality 
expect object passed equals type linkedlist cast type checked type parameters available run time 
possible check cast raw type linkedlist 
roughly speaking raw type linkedlist corresponds type linkedlist indeterminate value way resembles existential types pizza 
pizza existential types useful writing methods equality help interfacing legacy code raw types ease 
method call iterator receiver type list returns value type iterator method receiver list raw type list returns value raw type iterator 
similarly method call receiver xi type iterator returns value type method receiver yi type iterator returns value type object 
general signature member object raw type erasure signature member object parameterized type 
value parameterized type assignable variable corresponding raw type 
value raw type may assigned variable corresponding parameterized type assignment generates unchecked warning 
method calls objects raw type generate unchecked warnings indicate type soundness constraints normally enforced gj may violated 
consider code 
class loophole public static string loophole byte linkedlist string xs new linkedlist string linkedlist ys xs ys add unchecked warning return xs iterator code passes compiler unchecked warning issued call add method 
case call violate gj type constraints adds byte list strings xs 
translation code 
class loophole public static string loophole byte linkedlist xs new linkedlist linkedlist ys xs ys add return string xs iterator run time exception run time type system jvm remains secure line translated code fails run time 
rules generating unchecked warnings raw types method call raw type generates unchecked warning erasure changes argument types 
field assignment raw type generates unchecked warning erasure changes field type 
unchecked warning required method call result type changes reading field constructor call raw type 
example equality test linked lists raw method calls unchecked empty argument lists erasure leaves type unchanged 
loophole method call add unchecked erasure changes argument type object 
unchecked method calls field accesses may needed interface legacy code illegal 
example compile gj versions collection interface linkedlist comparator version collections 
test code compile generate unchecked warning method calls compare case calls happen sound 
rule gj generate unchecked warnings conservative 
practice interfacing legacy code new gj code calls may labelled unchecked sound 
proliferation unchecked warnings avoided updating legacy code retrofitting technique discussed section 
retrofitting support independent compilation gj compiler store extra type information compile time 
fortunately jvm class file format supports adding extra attributes 
information parameterized types stored signature attribute read written gj compiler ignored jvm load time 
gj designed new code run old libraries 
instance new code may refer parameterized linked list type run old code source binary implements linked list type generic idiom 
smoothly gj compiler retrofitting mode add signature attributes existing code 
type information specified source file contains type information fields methods 
instance say class file version linkedlist wishes parameterized types 
done retrofitting file 
class linkedlist implements collection public linkedlist public void add elt public iterator iterator gj compiler takes file source looks class file specified classpath 
outputs new class file including appropriate signature attribute directory specified user 
current gj compiler specified flags retrofit path directory 
compile time classpath specify retrofitted class file 
run time classpath may specify retrofitted legacy class file 
particular new code compile retrofitted linked list class file run browser containing legacy linked list library 
entire collection class library available jdk retrofitted way 
public methods jdk collection classes single exception sensible parameterized type signatures gj 
type signatures rewritten legacy code need recompiled 
signatures order magnitude compact code saves considerable effort 
cases anticipate eventually rewriting source library parameterized types 
advantage compatibility offered gj may schedule rewriting convenient time necessary rewrite legacy code new code exploit parametric types 
anticipate rewriting code straightforward consisting adding type parameters replacing occurrences object suitable type variables 
code may easy upgrade 
instance collection class library implementation finite maps includes code may return key value map entry 
welltyped generic idiom class map key value type object 
typed parameterized types class map key type value type portion code restructured update source gj providing separate code process keys values 
need restructure usually small portion code shows flexibility interfacing legacy code offered gj helpful 
implementation gj implemented publicly available number web sites gj 
gj compiler originally derived pizza compiler substantially redesigned 
written gj 
generic types methods essential implementation 
instance compiler heavy generic container types linked lists dictionaries iterators 
uses compiler relies generic methods central tree traversal routines implemented visitor pattern ghjv 
pizza gj compilers structured series passes syntax tree 
pizza compiler extensive algebraic data types pattern matching supported pizza java programming language 
syntax tree pizza compiler represented algebraic data type case pizza syntactic constructs 
pass consists recursive method case statement pattern matches relevant cases tree type 
possible decouple traversal algorithms tree definition 
sense expect language proces sors implemented traversal passes change frequently language process represented tree 
gj algebraic types pattern matching available 
visitor pattern applied achieve analogous program decomposition 
gives overview 
class tree subclasses gj syntactic constructs 
total subclasses shown 
base class subclass define method visit takes visitor object applies method visitor corresponds subclass defined 
visitor methods overloaded name case distinguished subclass tree take argument 
visitor class contains case method tree subclasses 
concrete subclasses override case methods possibly encountered traversal 
standard idiom widely applicable visitor class generic type parameters 
parameter stands result type case methods concrete visitor 
parameter stands type additional argument methods take 
instance shows fragment tree attribution visitor 
case method visitor takes environment type env additional parameter method returns type type type 
visitor passes compiler different argument result types 
missing result types argument types get instantiated class void 
multiple results arguments expressed tuple types pair 
visit class tree needs able apply different parameterized instantiations visitor class needs polymorphic 
consequently type tree visit visitor arg technique application visitor pattern compiler quite natural 
tried apply pattern form language generics generic idiom abundance required type casts concept considerably harder 
worth noting polymorphic methods essential achieve generic typing visitors parameterized types 
gj extension java programming language generic types methods 
class tree public visit visitor arg return case arg static class return extends tree public tree expr public return tree expr expr expr public visit visitor arg return case arg static class visitor public case tree arg throw new unexpected public case return arg return case tree arg public case throw arg return case tree arg cases public class attr extends tree visitor type env public type case return tree env env type code attribution return statements return attribution cases 
visitors gj compiler gj implemented translating back language repeating idiom programmers simulate generics 
reason easy interface gj legacy code straightforward reflection gj programs 
design pizza strongly constrained criterion backward compatibility java programming language 
design gj constrained criterion smooth interfacing legacy code forward compatibility language design cs maintains information type parameters run time 
referee characterized polymorphism hand tied back 
remarkably constraints gj tighter pizza design arguably simpler 
gj inference algorithm simpler pizza gj raw types simpler powerful pizza existential types 
main alternatives design pursued gj 
heterogenous translation 
saw section alternative difficult packages effectively requires change security model jvm 
second pass type information run time explored design cartwright steele cs 
gj forward compatibility possible arrange superset gj legal gj program legal program identical meaning 
exception gj changes properties program reflection 
gj advantages 
expressive gj restrictions discussed section need imposed 
particular implement new allocating new array correct run time type information avoiding severe restrictions placed construct gj 
implement instance test cast parameterized type linkedlist string workarounds required gj 
arguably run time types better fit java programming language maintains run time type information class object type elements array 
hand gj considerably simpler design 
gj maintains type information run time may efficient measurement required determine difference significant 
importantly gj achieves greater compatibility legacy code 
gj backward compatible java programming language forward compatible gj backward forward compatibility legacy code 
backward compatibility legacy code generic idiom may call new parameterized libraries newly created objects parameterized type may passed legacy code uses generic idiom 
forward compatibility new parameterized code may call legacy libraries generic idiom objects created legacy code generic idiom may passed new code expects objects parameterized type 
roughly speaking gj achieves backward compatibility raw types forward compatibility retrofitting 
contrast backward compatibility 
new code legacy libraries objects created legacy code passed new code adaptor methods convert legacy objects run time type information objects run time type information specified type parameter 
combination forward backward compatibility gj considerably easier manage process upgrading legacy parameterized code believe chief advantage gj 
matthias zenger input implementation security aspects joshua bloch cartwright guy steele support productive discussions 
members java genericity mailing lists valuable criticism continued feedback 
anonymous referees cogent comments 
afm ole agesen stephen freund john mitchell 
adding parameterized types java 
conference object oriented programming systems languages applications pages 
aw alexander aiken edward wimmers 
type inclusion constraints type inference 
functional programming languages computer architecture pages acm 
bg gilad bracha david griswold 
strongtalk typechecking smalltalk production environment 
conference object oriented programming systems languages applications pages 
bow kim bruce martin odersky philip wadler 
statically safe alternative virtual types 
european conference object oriented programming july 
earlier version th workshop foundations object oriented languages january 
peter canning william cook walter hill walter john mitchell 
polymorphism object oriented programming 
functional programming languages computer architecture pages acm 
cs cartwright guy steele 
compatible genericity run time types java programming language 
conference object oriented programming systems languages applications 
est jonathan scott smith trifonov 
sound polymorphic type inference objects 
conference object oriented programming systems languages applications pages 
ghjv erich gamma richard helm ralph johnson john vlissides 
design patterns elements reusable object oriented software 
addison wesley 
gr goldberg robson 
smalltalk language implementation 
addison wesley 
gj martin odersky 
gj compiler 
available www cis edu au pizza gj ira uka de pizza gj www math luc edu pizza gj www cs bell labs com wadler pizza gj gj gilad bracha martin odersky david stoutamire philip wadler 
gj java programming language type parameters 
manuscript 
available gj web site 
gj gilad bracha martin odersky david stoutamire philip wadler 
gj specification 
manuscript 
available gj web site 
gls james gosling bill joy guy steele 
java language specification 
java series sun microsystems isbn 
ly tim lindholm frank yellin 
java virtual machine specification 
java series sun microsystems isbn 
mil robin milner 
theory type polymorphism programming 
journal computer system sciences 
mbl andrew myers joseph bank barbara liskov 
parameterized types java 
symposium principles programming languages pages acm 
martin odersky 
measuring cost parameterized types java 
research report cis advanced computing research centre university south australia january 
ow martin odersky philip wadler :10.1.1.26.1697
pizza java translating theory practice 
symposium principles programming languages pages acm 
pt benjamin pierce david turner 
local type inference 
symposium principles programming languages pages acm 
rs paul roe clemens szyperski 
lightweight parametric polymorphism oberon 
proceedings joint modular languages conference johannes kepler university linz austria march www fit qut edu au gardens tho thorup 
genericity java virtual types 
european conference object oriented programming pages lncs springer verlag 
tor mads 
virtual types statically safe 
th workshop foundations object oriented languages january 
tt thorup mads 
structural virtual types 
informal session types java th workshop foundations object oriented languages january 
wri wright simple imperative polymorphism lisp symbolic computation 
