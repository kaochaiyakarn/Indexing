faster approximate string matching ricardo baeza yates gonzalo navarro department computer science university chile blanco santiago chile dcc uchile cl new algorithm line approximate string matching 
algorithm simulation non deterministic finite automaton built pattern text input 
simulation uses bit operations ram machine word length omega gamma bits text size 
essentially similar model wu manber improve search time packing automaton states differently 
running time achieved small patterns mk log pattern length number allowed errors 
contrast result wu manber kn log 
longer patterns processed partitioning automaton machine words mk search cost 
allow generalizations pattern classes characters gaps essentially search cost 
explore novel techniques cope longer patterns 
show partition pattern short subpatterns searched errors simple automaton obtain average cost close mk 
allow superimpose subpatterns single automaton obtaining near mk average complexity oe alphabet size 
perform complete analysis techniques show combine optimal form obtaining new tighter bounds probability approximate occurrence random text 
show experimental results comparing algorithms previous 
experiments show algorithms fastest ones typical text searching fastest cases 
aim mainly text searching believe ideas successfully applied areas computational biology 
approximate string matching main problems classical string algorithms applications text searching computational biology pattern recognition text length pattern length maximal number errors allowed want find text positions pattern matches text errors 
errors substituting deleting inserting character 
call ff error ratio oe alphabet size 
supported part 
solutions problem differ algorithm line text known advance line text preprocessed 
interested case classical dynamic programming solution mn running time 
years algorithms achieve kn comparisons worst case average case advantage properties dynamic programming matrix values neighbor cells differ 
trend average time complexity kn oe 
average case figures assume random text uniformly distributed alphabets 
approaches filter text reducing area dynamic programming needs 
algorithms achieve sublinear expected time cases low error ratios text characters inspected kn log oe typical filtration effective errors 
filtration fact portions pattern appear errors approximate occurrence 
deterministic finite automaton dfa recognizes approximate occurrences pattern text proposed 
search phase dfa huge 
automaton computed lazy form states reached text generated 
approaches bit parallelism simulate parallelism bit operations ram machine word length omega gamma bits reduce number operations :10.1.1.53.88
cells dynamic programming matrix packed diagonals achieve mn log oe time complexity 
russians approach pack matrix machine words achieving kn time average fact dfa trade number states internal complexity 
special interest considers non deterministic finite automaton nfa functionally similar dfa states 
achieve kmn time parallelizing bits automaton 
main contributions follow 
ffl new algorithm approximate string matching 
bit parallelism bit operations simulate behavior non deterministic finite automaton nfa built pattern text input 
automaton similar wu manber 
pack diagonals rows machine words 
leads worst case running time independently small patterns mk 
case single word text patterns 
simple algorithm experimentally shown fastest aware short patterns small values filtration algorithms faster 
ffl show partition large automaton fit computer word obtain algorithm performs near operations dm kn performed wu manber operations simpler 
difference especially noticeably small patterns 
algorithm performs error ratios pattern long fastest high error ratios area largely unexplored previous 
ffl show generalizations pattern call extended patterns handled additional search cost 
allow classes characters pattern position just character position gaps inside pattern ffl technique partition long pattern subpatterns subpatterns searched errors simple automaton 
search fact filter matches subpatterns verified complete matches 
average time search close mk moderately high error levels 
show experimentally algorithm competitive best known algorithms 
ffl show subpatterns obtained previous algorithm fact superimposed single automaton speed searching 
analytically find maximum degree superimposition allowed limited error level obtain algorithm average cost close mk 
show experimentally speedups factors obtained low error ratios 
ffl analyze possibility combining pattern automaton partitioning finding combination increases tolerance errors pattern partitioning provide smooth transition pattern automaton partitioning error level increases 
mixed partitioning average search cost log 
show experimentally mix works intermediate error level 
ffl simple speedup technique doubles practice performance algorithms low error levels allowing quickly discard large parts text low cost character 
technique quite general applied algorithms filtration algorithms 
ffl thoroughly analyze algorithms areas applicable finding optimal heuristic combines 
side effect give tighter bounds probability approximate occurrence random text 
give better bounds analysis ukkonen cut algorithm 
ffl extensive experiments running time algorithms previous 
aimed show practical behavior algorithms verify analysis compare 
show algorithms fastest ones typical text searching especially short patterns 
approximate string matching particular case sequence similarity important problem computational biology 
specifically aimed text searching believe ideas adapted generic cost functions associated string editing operations generic patterns example rna prediction dna sequence databases incidentally search short patterns 
preliminary versions parts 
organized follows 
section introduce problem associated nfa 
section explain automaton simulation split machine words 
section problem partitioning techniques 
section analyze algorithms find optimal way combine general heuristic 
section experimentally validate analysis compare algorithm 
section give directions 
preliminaries problem approximate string matching stated follows long text length short pattern pat length sequences characters alphabet sigma size oe find segments called occurrences matches text edit distance pat number allowed errors 
common report points occurrences discard occurrences containing contained 
focus returning points occurrences containing 
edit distance strings minimum number edit operations needed transform allowed edit operations deleting inserting replacing character 
problem non trivial error ratio defined ff notation operations 
text denote current character text str denote th character str strings position zero 
consider nfa searching patt errors shown 
row denotes number errors seen 
second 
column represents matching pattern position 
iteration new text character considered automaton changes states 
horizontal arrows represent matching character advance pattern text followed corresponding match occurs vertical arrows represent inserting character pattern advance text pattern increasing number errors solid diagonal arrows represent replacing character advance text pattern increasing number errors dashed diagonal arrows represent deleting character pattern empty transitions delete character pattern advancing text increase number errors 
self loop initial state allows consider character potential starting point match automaton accepts character match rightmost state active 
care number errors occurrences consider final states full diagonal 
empty transitions acceptance equivalent lower right state active 
nfa theta states 
assign number state row column initially active states row columns represent deletion characters pattern 
consider boolean matrix corresponding automaton 
state active 
matrix changes character text read 
new values computed current ones rule gamma text pat gamma gamma gamma gamma gamma ffl ffl ffl ffl ffl ffl ffl ffl error errors sigma errors nfa approximate string matching 
unlabeled transitions match character 
active states active lower left triangle 
enclose dotted states represented algorithm 
term 
note empty transitions represented immediately propagating position elements diagonal single iteration computing ffl closure 
self loop initial state represented fact column updated 
main comparison algorithms approximate string matching consist fundamentally working dynamic programming matrix 
column matrix holds state search text character 
hard show column stores position minimum row nfa active column automaton 
sense dynamic programming matrix corresponds simulating automaton columns packing columns machine words 
hand wu manber consists fundamentally simulating automaton rows packing row machine word 
cases dependencies introduced diagonal empty transitions prevent parallel computation new values 
section approach avoids dependence simulating automaton diagonals diagonal captures ffl closure 
idea leads new fast algorithm 
new algorithm suppose just full diagonals automaton length 
presents problem shorter diagonals full ones value past full ones influence state 
statement may obvious vertical transitions allow carry diagonals state 
diagonals crossed full diagonal empty transitions deletions immediately copied state 
goes state corresponds segment containing reported 
notice state active states active due empty deletion transition 
number diagonals regarding column state diagonal represented number smallest row value active diagonal smallest error 
state simulation consists gamma values range 
note need store 
new values gamma read new text character derived eq 
min gamma defined min fk pat term update formula represents substitution follows diagonal 
second term represents insertion character coming diagonal 
term represents matching character select minimum active state min formula previous diagonal matches text move current 
deletion transitions represented precisely fact state diagonal active consider active subsequent states diagonal keep just minimum 
empty initial transition corresponds 
find match text dm gammak simulation advantage computed parallel property design fast algorithm exploits bit parallelism small patterns extend handle general case 
linear algorithm small patterns show section simulate automaton diagonals bit parallelism assuming problem fits single word 
gamma length bits computer word 
select suitable representation problem describe algorithm 
gamma non trivial diagonals takes values range need gamma dlog bits 
function computed parallel optimal representation 
precompute store take oe gammak space accessed parallel exponential space cost automaton approach preferable 
unary encoding values case computed parallel 
need gamma bits encode problem gamma blocks bits stores value value stored aligned right wide block separator highest bit having 
blocks stored contiguously gamma aligned right computer word 
bit representation state dm gammak gammad gammad gammad gammak dm gammak exponentiation mean digit repetition 
observe word contains rearrangement relevant part automaton 
rearrangement exchanges reads diagonals left right bottom top see 
separator separator final state encoding example nfa 
example 
representation minimum equivalent anding adding equivalent shifting position left oring rightmost position accessing previous diagonal means shifting block positions left right respectively 
computation function carried defining character bits long mask representing match mismatch pattern computing mask having block bits long segment relevant block see 
pat pat gamma pat condition stands bit aligned right 
precompute gamma gamma shifts right bits takes bits result bits fall discarded 
note fits computer word problem 
elements implement algorithm 
represent current state computer word value initially initial value gammak formula update reading text character derived eq 

gammak 
gammak gamma gammak 

update formula sequence corresponding min eq 

line corresponds second line third line function applied previous diagonal fourth line ensures invariant having zeros separators needed limit propagation 
note assuming shifts get zeros borders word unsigned semantics 
case particular architecture additional masking necessary 
detect state active checking 

find match clear diagonal 
ensures occurrences match 
simple filter improve previous algorithm fact algorithms noticing approximate occurrence pattern errors characters 
allows quickly discard large parts text operations character 
run automaton text characters scan text looking initial characters pattern 
start automaton 
automaton returns initial configuration resume scanning 
scanning cheaper operation automaton fact cheaper done text character algorithms 
precompute boolean table stores character letters pattern 
observe table solves problem case gamma positive answer occurrence 
presents complete algorithm automaton plus filter 
simplicity refine preprocessing done efficiently code suggests 
partitioning large automata automaton fit single word partition number machine words simulation 
suppose small large 
automaton horizontally split subautomata necessary holding number diagonals 
call columns sets diagonals packed single machine word 
subautomata behave differently simple communicate diagonals neighbors 
gamma partition automaton horizontally columns gamma 
note need automaton diagonal fits single search ext pat preprocessing sigma pat pat gamma pat gamma gamma pat gammak gammak gammak gamma gammak gamma 
searching text characters 

text 


report match clear diagonal algorithm search short pattern 
strings assumed start position 
machine word suppose large close width gamma small 
case automaton wide tall vertical partitioning necessary 
subautomata behave differently previous ones propagate ffl transitions subsequent subautomata 
case gamma partition automaton vertically rows row holding automaton rows diagonals formula difference case need automaton row fits machine word gamma need overflow bit diagonal cell 
previous conditions hold need generalized partition rows columns 
rows columns cell contains bits diagonals 
hold options pick problem 
show roughly equivalent cost integer round offs noticeable practice 
prefer select small possible determine gamma bw gamma cells column row may smaller residues 
simulation automaton complex follows principle update formula 
matrix automata gamma gamma matrix masks coming splitting original new update formula 
gamma 
gamma 
gamma 
gamma 
gamma gamma 
gamma gamma 

gamma 
gamma text gamma 
gamma assumed gamma gamma find match gamma gamma position gamma gamma gamma gamma counting right 
case clear diagonal gamma fact select minimal solve case gamma simpler algorithm table causes general scheme fall simpler cases automaton horizontal automaton horizontal diagonal fits word automaton spreads horizontally vertically diagonal fits word 
cases solved simpler times faster update formula 
practice cases purely vertical automaton better 
particular wu manber automaton thought vertical partitioning nfa details different 
handling extended patterns show generalizations approximate string search problem considered introduced algorithm additional search cost :10.1.1.53.88
call extended patterns patterns involving generalizations 
shift algorithm exact matching specify set characters position pattern single called limited expressions 
example find patt case insensitive search fp tg find patt followed digit search 
achieved modifying table making element set match position running time overhead 
addition classes characters support operator defined 
allows zero arbitrary characters strings occurrences 
characters counted errors 
shown order handle operator force automaton state column jxj active keeps active 
search create word having ones states columns jx jx jx jx jx jx gamma modify computation eq 

text clearly technique orthogonal classes characters 
technique easily extended partitioned automata 
modify automaton compute edit distance precisely determine edit distance 
obtained eliminating initial self loop initializing automaton need represent initial diagonals discarded 
need exact edit distance represent diagonals discarded 
priori bound distance need set search words running edit distance algorithm word beginnings re initialize checking matches words 
searching different integral costs insertion substitution including allowing operations accommodated scheme changing arrows 
deletion built model way order change meaning diagonals straight ffl transition chains 
generalizations studied 
handle easily efficiently previous ones 
generalization combination pattern parts match exactly match errors 
adaptation avoid propagation ffl closures scheme ad hoc elegant 
believe effective way handle patterns quickly search parts match exactly trying extend matches complete pattern automaton compute edit distance 
generalization approximate search regular expressions 
regularities rows allow solve regular expression letters dm dm operations text character dm dm dm dm machine words memory respectively 
partitioned automata regular need roughly times space requirements operations text character 
precise scheme formulas valid provided replace gamma 
instance cost pay solve 
scheme reasonably applicable short expressions 
new partitioning techniques lemma generalization partitioning scheme suggests way partition large problem smaller ones 
lemma segm text matches pat errors pat concatenation subpatterns segm includes segment matches bk jc errors 
proof suppose opposite 
order transform pat segm need transform segm segm bk jc errors needs bk jc edit operations transformed segment segm particular 
transformation needs bk jc operations 
contradiction 
lemma generalization consider case return case slight generalization consider cases form partition pattern binary fashion short subpatterns obtained 
consider partition pieces size lemma allows split 
explore different ways lemma 
pattern partitioning lemma allows reduce number errors divide pattern provided search subpatterns 
match subpattern checked determine fact complete match notice subpatterns extended patterns 
suppose find position text match subpattern position pat 
potential match searched area text gamma gamma gamma wide area 
checking done algorithm resistant high error levels automaton partitioning technique 
pattern extended ukkonen cut algorithm 
perform partition pick integer split pattern subpatterns length precisely qj subpatterns length dm je gamma length bm jc 
lemma check subpatterns text bk jc errors 
select small possible subproblems fit computer word min ae gamma oe second condition avoids searching subpattern length errors length dm je guaranteed longer bk jc 
exists implies searching errors 
case errors aho corasick machine guarantee total search time 
variation shift algorithm algorithm boyer moore family suggested 
advantage wu manber approach flexibility queries boyer moore faster supported typically subpatterns 
particular pattern extended shift algorithm correct choice 
extended patterns preferred sunday algorithm boyer moore family extended search 
extension consists building trie subpatterns position searching text trie 
find subpattern advance window sunday shift 
precomputed minimum shift patterns 
considered just implementation previous 
shows general algorithm written way clarity 
practical implementation better run synchronization picking moment candidate initial checking position leftmost set checking area advancing candidate position 
allows avoid re verifying text different overlapping candidate areas 
done remembering checked position keeping state checking algorithm 
ext pat min dm re gamma bk rc bk rc bm rc bk search ext pat gamma len dm je bm jc len gamma position reported search ext pat len bk jc check area text gamma gamma gamma algorithm pattern partitioning 
effectiveness method limited error level 
subpatterns appear spend lot time verifying candidate text positions 
section find error level allows scheme 
superimposing subproblems search divided number smaller patterns possible search separately 
describe technique called superimposition collapse number searches single 
scheme patterns length 
differ truncate shortest length 
automata structure differing labels horizontal arrows 
superimposition defined follows build table pattern eq 
take bitwise tables 
resulting table matches position th character pattern 
build automaton table 
resulting automaton accepts text position ends occurrence relaxed pattern fact extended pattern fp fp example search patt wait string watt accepted zero errors see 
occurrence reported automaton verified patterns involved 
sigma ffl ffl ffl ffl ffl ffl ffl ffl errors error errors nfa filter parallel search patt wait 
moderate number patterns constitutes filtering mechanism cost single search 
clearly relaxed pattern triggers verifications simple ones 
limits severely amount possible superimposition 
show practice cut search times 
idea applied problem multiple approximate string matching similar speedup figures obtained 
analyze subpatterns collapsed keeping number verifications small 
form sets patterns searched search set separately 
notice extended patterns containing may superimposed words different 
observe having character position patterns improve filtering efficiency 
fact select best partition pattern 
mixed partitioning possible combine automaton pattern partitioning 
partition pattern subpatterns large fit computer word automaton subpattern partitioned subautomata 
generalization includes techniques particular cases uses smaller value 
show analysis technique better practice pure pattern partitioning 
find larger tolerant error level scheme smaller necessary ff high 
high error levels largest allowed ff large allowed value equivalent pure automaton partitioning 
mixed partitioning provides smooth transition pure pattern pure automaton partitioning 
superimposition applied resulting large automata 
analysis section analyze different aspects algorithms 
study statistics problem useful analysis 
heavy shorthand ff important notice average case analysis assumes pattern extended text patterns random strings independently generated uniformly distributed alphabet size oe 
alphabet uniformly distributed replace oe formulas probability random letters match 
generalized patterns ff values different able compute 
summarize results section involve optimal heuristic combine algorithms 
table presents summary important limiting ff values analysis 
name simplified meaning definition subpatterns ff gamma oe pattern partitioning eq 
sec 
safely superimposed ff gamma oe pure pattern eq 
sec 
partitioning ff gamma oe mixed eq 
sec 
partitioning table limiting ff values analysis 
simplified definition valid approximation moderate values 
sketch algorithm behaves areas delimited ff ff ff cases heuristic table reduce average cost 
ffl problem fits single word 
gamma simple algorithm average worst case 
problem fit single word may pattern automaton mixed partitioning 
ffl ff ff pattern partitioning plus superimposition best choice 
ff ff effect superimposition pattern partitioning time average 
range ff ff ff average cost close km eq 

grows fixed cost approximately 
ffl ff ff ff error level necessary smaller mixed partitioning 
average search cost log eq 

ffl ff ff pattern mixed partitioning advisable large number verifications pure automaton partitioning choice 
average worst case cost area gamma eq case ff gamma oe 
illustrates analysis 
show left exact ff values oe replaced see 
see ff maximum error level exact partitioning linear precisely exact solution eq 

right show schematically combined complexity 
ff ff ff ff ff mixed partitioning pattern partitioning superimposition ff ff ff ff mk log gammak left exact ff values oe 
right simplified complexities algorithm 
statistics problem natural questions distribution statistical behavior problem hard answer 
probability occurrence 
occurrences average 
columns dynamic programming matrix active 
questions arise analysis algorithms 
give new results 
concern probability matching 
probability random pattern length matching text position errors 
probability determinant assure number verifications candidate matches pattern partitioning theta theta theta theta theta theta theta pi pi pi pi pi pi oe ff theta upper bound gamma oe curve gamma oe experimental data exact lower bound eq 
fl pi conservative lower bound gamma oe theoretical practical bounds ff 
large 
show appendix ff gamma gammaff fl fl 
particular ff gamma oe exponentially decreasing shows experimental verification analysis obtained similar results values 
curve ff gamma oe included show closeness experimental data 
squares gives approximation ff gamma oe squared error smaller gamma experiment consists generating large random text running search random pattern text errors 
text character record minimum position match pattern 
analyze histogram consider safe histogram values significant 
threshold set cost verify match 
selection threshold important histogram extremely concentrated 
example significative values hundreds 
second question answer number columns average cut heuristic ukkonen 
call smallest row active state column nfa largest satisfying 
columns satisfying called active columns past active need computed 
ukkonen conjectured number active columns proved chang 
follow proof find tighter bound 
call active column know gamma oe fl fl take gamma oe obtain gamma oe gammae oe fl gamma oe shows average active column 
refines proof heuristic kn 
squares experimental data find accurate formula gamma oe 
simple algorithm preprocessing phase algorithm optimized take oe min oe time requires oe space 
search phase needs time 
algorithm limited case gamma ram model assumed log machine independent bound gamma log gamma takes maximum value gamma assure algorithm applied gamma independently linear algorithm log example bits bits 
partitioning automaton divide automaton ij subautomata rows columns update cells column 
heuristic similar processing columns active active automaton diagonals 
compute expected active diagonal result eq 
measures active columns active diagonals subtract obtain average ke oe gamma diagonals 
pack gamma diagonals single cell average ke oe gamma gamma machine words 
columns total complexity min ke gamma oe gamma shows choice fixed ij ij gammak gamma final cost expression independent round offs min gamma ke oe gamma gamma oe log time 
improves ff gamma oe gamma kn log time 
complexity worst case algorithm 
see automaton partitioning better plain dynamic programming consider large ff works ij gamma gamma text position second works 
means ff gamma ff better partition automaton better just dynamic programming 
ff gamma ff automaton partitioning better dynamic programming moderate size patterns slightly different practice operations cost 
preprocessing time space complexity algorithm 
partitioning pattern main components cost pattern partitioning 
simple searches carried checks done 
part jn second costs jm defined section observe error level ff subpatterns 
complexity comes considering perform independent searches verification costs dynamic programming verification clearly worst case text position verified avoid re checking text mn worst case complexity show happen average 
determine consider equation derived eq 
gamma solution gamma gamma wk gamma preprocessing time storage requirements general algorithm times simple 
search time jn mk simplification valid ff improve complexity section superimposition 
consider limit error level applicability 
know ff gamma gammaff fl fl 
ff small fl affect complexity provided fl 
happens fl fl holds fl gammaff gammaff gammak ff ff ff gamma oe gammak gamma oe ff cost verifications significant 
function defined gamma replacing eq 
yields ff wff gamma ff recall algorithm pattern extended analysis holds extended patterns anyway 
ff ff gamma gamma 
approximation ff moderate ff gamma oe 
superimposing subpatterns suppose decide superimpose patterns single search 
limited amount superimposition increase error level tolerate 
analyze patterns superimpose 
prove appendix probability text position matching random pattern exponentially decreasing ff gamma oe condition hold probability high 
formula oe stands probability character crossing horizontal edge automaton probability characters equal 
extend result note characters edge mentioned probability gamma gamma oe new limit ff ff gamma gamma gamma oe gamma oe pessimistic approximation tight 
oe 
pattern partitioning search subpatterns determined dependent 
eq 
number verifications negligible ff gamma oe gammak solving get maximum allowed amount superimposition gamma ff oe ff partition set subsets size 
implies cost algorithm general 
replacing gamma ff yields cost ff ff oe gamma ff technique limited case ff gamma oe complexity ff ff oe km approximation valid moderate values 
natural question error level superimpose patterns obtain linear algorithm holds 
eq 
ff gamma oe gammak limit point defined ff gamma gamma ff ff oe ff easy solve analytically 
moderate practical simplified solution ff gamma oe observe ff gamma oe cost jn better pattern partitioning superimposition 
value marks limit usability pattern partitioning 
interesting compare limit linearity algorithm exact partitioning partitioning pattern pieces searching errors verifying subpattern occurrence complete match 
analyze exact partitioning assume aho corasick machine search subpatterns parallel guaranteed search time explained better alternatives practice 
search subpatterns linear time find total amount due verifications linear 
split pattern pieces length bm dm terms probability occurrence shorter pieces oe times probable oe size alphabet 
occurrence subpattern verified complete match cost total cost verifications oe linear approximately ff ff ff defined ff oe ff reasonable approximation ff log oe 
limit restricting ff eq 
sufficiently large rough approximation oe 
typical text searching error level tolerated algorithm higher ff ff 
show experiments exact partitioning faster practice preferred ff ff mixed partitioning analyze general partitioning strategy partition pattern number subpatterns partition automaton 
obtain optimal strategy consider partition subpatterns perform searches bk jc errors 
ff gamma oe cost solving subproblems partitioning automaton recall eq 
ke oe gammae gamma jn shows lowest cost obtained largest value mixed partitioning pure pattern partitioning possible 
place algorithm 
point limit usefulness ff reduced grows eq 

ff ff may smaller partition automata keep verifications negligible 
part eq 
obtain maximum value allowed ff gamma log oe gamma ff counting cost carrying searches resulting subautomata eq 
complexity scheme 
possible superimposition scheme 
select superimpose subsets superimpose patterns means error level allow larger selection optimal 
try optimize simultaneously 
suppose superimpose groups subpatterns 
eq 
hold obtain gamma log oe gamma ff 
cost times pure automaton partitioning reaches worst case pushing limit 
optimize gammak gamma log gamma log oe gamma ff minimize formula find optimum value oe gamma ff corresponds gamma ln 
optimal search cost oe gamma ff ln gamma oe log notice maximum allowed pure automaton partitioning 
happens ff gamma oe gammaff observe ff gamma 
gamma oe grows 
smooth transition pattern partitioning automaton partitioning 
experimental results section experimentally compare different variations algorithm fastest previous algorithms aware 
tested random patterns mb random text sun sparcstation running solaris mb ram bit machine 
oe typical case text searching 
tested lower case english text selecting patterns randomly text words length mimic classical information retrieval queries 
data point obtained averaging unix user time trials 
previous tests run sun mb ram running sunos gave slightly worse results 
probably due amount main memory available algorithms depend 
times seconds combined heuristics 
left pattern partitioning forced superimposition full line dashed dotted 
right pattern partitioning forced mixing full lines larger jumps maximal dashed 
reader may curious strange behavior curves especially algorithms 
curves definitely non expected gammak behavior automaton partitioning depend statistical deviations tests 
peaks due integer round offs intrinsic algorithms noticeable small patterns 
instance pattern partitioning split search need search subpatterns need just 
example consider automaton partitioning 
number cells ij change 
superimposition mixed partitioning show effect superimposition 
practice rare able superimpose patterns 
left side shows times pattern partitioning random text 
level superimposition forced 
shows superimposition effective reduce level superimposition error level increases 
show right side effect mixed partitioning 
area narrow shorter patterns random text 
force different values show maximal pure pattern partitioning 
shows better larger necessary switch smaller ones error level increases 
peaks left plot correspond example integer round offs pattern partitioning 
comparison parallel nfa algorithms algorithm shares wu manber nfa model idea 
parallelization techniques different 
compare algorithms 
general implementation wu manber code needs array size 
implemented optimized versions 
different code developed value order avoid arrays enable machine registers 
show algorithms optimized general 
show effect simple speed heuristic table running algorithm filtration heuristic 
shows results 
show case simple algorithm automaton partitioning 
past times wu manber algorithm double need machine words row automaton 
seen algorithms heuristic outperform optimized versions wu manber spectrum short patterns 
longer patterns outperform general version wu manber specialized versions fixed faster probably keep slightly faster larger values depends availability machine registers 
course practical implement different algorithm possible value 
hand table cuts running times algorithm error level reasonably low course heuristic applied algorithm 
comparison hybrid heuristics developed hybrid heuristic automatically determines best algorithm suite 
heuristic uses analytical results determine best choice 
works random text needs tuning english text 
fact best choice selected independent confirmation analytical results random text 
section compare complete heuristic hybrid algorithm agrep 
agrep widely distributed approximate string search software 
case include filtering table agrep uses speed techniques altogether 
include implementation baeza yates algorithm call exact partitioning 
determine partitioning pieces necessary fall naturally algorithm developed part 
sense algorithm considered part heuristic propose 
shows results maximum currently allowed agrep 
seen exact partitioning faster low error ratios roughly ff 
agrep especially optimized small values fastest case 
rest spectrum algorithm faster 
reason agrep times drop past point soon finds match line ffl ffl ffl ffi ffi ffi ffi ffi ffl ffl ffl ffi ffi ffi ffi ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi ffi ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi ffi ffi rows ffl rows fixed diagonals diagonals table times seconds row second row 
plots left random text oe right english text 
ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi agrep exact partitioning times seconds left right english text 
text reports line searching line 
skips lines faster high error ratios 
peak hybrid algorithm english text hand due imperfect tuning heuristic non random text 
comparison fastest algorithms comparison algorithms fastest previous algorithms aware 
compare fastest algorithms leave aside competitive range parameters study 
simple algorithm pure pattern pure automaton partitioning 
table speed applied algorithms 
algorithms included comparison alphabetical author order pattern partitioning automaton partitioning algorithms 
simple automaton considered automaton partitioning figures 
pattern partitioning includes superimposition 
exact partitioning baeza yates essentially case 
code 
algorithm wu manber boyer search suggested 
column partitioning chang algorithm kn clp computes places value dynamic programming matrix change column 
code author 
counting jokinen tarhio ukkonen moves window text keeping letters window match pattern 
number high area verified 
variant implemented navarro window fixed size 
dfa navarro converts nfa deterministic automaton computed lazy form state created needed processing text 
idea implementation 
grams sutinen tarhio filtration algorithm finding portions grams pattern text verifying candidate areas 
method limited ff implementation gamma 
code authors 
number samples match maximal length grams suggested 
cut ukkonen standard dynamic programming algorithm working active columns 
code 
nfa rows wu manber uses bit parallelism simulate automaton rows 
code 
code limited slower generalized 
general code arbitrary russians wu manber myers applies russians technique pack automaton transitions computer words 
code authors suggested related size russians tables 
shows results 
seen algorithm efficient problem fits single word low error level baeza yates unbeaten 
algorithms fastest ones quite close 
particular automaton partitioning fastest algorithm close show detail case small 
peaks pattern partitioning explained section 
holds automaton partitioning 
reason peak curve obscure number cells change second cell active frequently expected analysis 
happens second cell switches inactive active back inactive quite times 
overhead include exclude second cell explains higher times 
hand analysis confirmed 
random text predict eq 
replacing pattern partitioning useful ff quite close real value 
predict ff close real 
precision allows set fine tuned heuristics 
english texts prediction harder 
concluding remarks new algorithm approximate pattern matching bit parallel simulation automaton 
eliminate dependencies introduced ffl transitions 
enables possibility computing new values time text character provided ffl ffl ffl ffl ffl pi pi pi pi pi pi pi pi theta ffi ffi ffi ffl ffl ffl ffl pi pi pi pi pi pi pi pi theta ffi ffi ffi ffl ffl ffl pi pi pi pi pi pi theta ffi ffi ffl ffl pi pi pi pi theta theta ffi ffi ffl ffl ffl pi pi pi theta theta ffi ffi ffl ffl ffl pi pi pi theta ffi ffi pattern part 
automaton part 
exact part 
column part 
ffl counting pi dfa theta grams cut ffi nfa rows russians times seconds second third row respectively 
plots left random text oe right english text 
ffl ffl ffl pi pi pi theta theta ffi ffl ffl pi pi pi theta ffi ffl ffl ffl pi pi pi theta theta ffl ffl pi pi pi theta ffi pattern part 
automaton part 
exact part 
column part 
ffl counting pi dfa theta grams cut ffi nfa rows russians times seconds second row respectively small plots left random text oe right english text 
problem fits single computer word 
gamma 
show technique partition automaton subautomata 
handle extended patterns allow classes characters gaps generalizations patterns 
show technique partition pattern subpatterns grouped superimposed searches 
searches carried simple algorithm candidate matches verified 
show combine pattern automaton partitioning 
combined algorithm small patterns moderate ff roughly km oe log moderately high ff gamma kn log large ff 
analyzed optimum strategy combine algorithms showed experimentally algorithm fastest ones typical text searching 
studied cases long patterns algorithm perform filtration algorithms tend better small alphabets normally best choices 
illustrates results english text showing case algorithm applied patterns moderate size 
include agrep pure algorithm 
agrep included area replace exact partitioning counting 
seen filtering algorithms best low error ratios 
hand different implementations automaton model deterministic fastest choices long patterns 
remaining area russians approach best choice seen version dfa 
particular algorithms fastest short patterns moderate error level high error level 
ff simple counting automaton partitioning russians dfa exact partitioning areas algorithm best english text 
numbers indicate megabytes second machine 
deal finite alphabets easily extend algorithms unbounded case tables filled characters pattern 
case log factor added complexities search tables probability characters equal longer oe involves detailed experimental study combine heuristics 
study guided theoretical analysis take account practical complications round offs important practice 
instance text random subpatterns pattern partitioning different lengths probabilities occurrence similar 
prefer prune pattern splitting avoiding perform searches probability false matches high 
areas tu pursue optimal automaton partitioning optimal amount superimposition optimal mixed partitioning 
acknowledgments gene myers udi manber helpful comments 
people sent working versions algorithms tests lot easier sense fair william chang wright gene myers erkki sutinen takaoka 
anonymous referees suggestions improve 
aho corasick 
efficient string matching aid bibliographic search 
communications acm june 
baeza yates 
text retrieval theory practice 
van leeuwen editor th ifip world computer congress volume algorithms software architecture pages 
elsevier science september 
baeza yates 
unified view string matching algorithms 
keith jeffery kr miroslav editors theory practice informatics volume lecture notes computer science pages czech republic november 
verlag 
invited 
baeza yates gonnet 
new approach text searching 
communications acm october 
baeza yates navarro 
fast heuristic approximate string matching 
ziviani baeza yates aes editors proc 
wsp pages 
carleton university press 
ftp ftp dcc uchile cl pub users wsp ps gz 
baeza yates navarro 
faster algorithm approximate string matching 
hirschberg myers editors proc 
cpm lncs pages 
ftp ftp dcc uchile cl pub users cpm ps gz 
baeza yates navarro 
multiple approximate string matching 
proc 
wads lncs pages 
ftp ftp dcc uchile cl pub users wads ps gz 
baeza yates 
fast practical approximate pattern matching 
information processing letters 
chang 
theoretical empirical comparisons approximate string matching algorithms 
proc 
cpm lncs 
chang lawler 
sublinear approximate string matching biological applications 
algorithmica oct nov 
chang marr 
approximate string matching local similarity 
proc 
cpm lncs pages 
springer verlag 
el 
fast identification rna motifs genomic dna 
application trna search yeast genome 
molecular biology november 
galil park 
improved algorithm approximate string matching 
siam journal computing 
jokinen tarhio ukkonen 
comparison approximate string matching algorithms 
software practice experience 
kurtz 
fundamental algorithms declarative pattern matching system 
dissertation technische fakultat universitat bielefeld available report july 
landau vishkin 
fast string matching differences 
journal computer systems science 
landau vishkin 
fast parallel serial approximate string matching 
journal algorithms 
myers 
sublinear algorithm approximate keyword searching 
algorithmica oct nov 
navarro 
multiple approximate string matching counting 
proc 
fourth south american workshop string processing wsp 
carleton university press 
appear 
ftp ftp dcc uchile cl pub users wsp ps gz 
navarro 
partial deterministic automaton approximate string matching 
proc 
fourth south american workshop string processing wsp 
carleton university press 
appear 
ftp ftp dcc uchile cl pub users wsp ps gz 
needleman wunsch 
general method applicable search similarities amino acid sequences proteins 
journal molecular biology 
sellers 
theory computation evolutionary distances pattern recognition 
journal algorithms 
shi 
fast approximate string matching blocks sequences 
ziviani aes editors proc 
wsp pages 
carleton university press 
sunday 
fast substring search algorithm 
communications acm august 
sutinen tarhio 
gram locations approximate string matching 
spirakis editor proc 
esa lncs 
springer verlag 
takaoka 
approximate pattern matching samples 
proc 
isaac lncs pages 
springer verlag 
tarhio ukkonen 
boyer moore approach approximate string matching 
gilbert karlsson editors swat lncs pages 
springer verlag 
ukkonen 
approximate string matching grams maximal matches 
theoretical computer science 
ukkonen 
algorithms approximate string matching 
information control 
ukkonen 
finding approximate patterns strings 
journal algorithms 
watson 
performance single multiple keyword pattern matching algorithms 
ziviani baeza yates aes editors proc 
wsp pages 
carleton university press 
wright 
approximate string matching word parallelism 
software practice experience april 
wu manber 
agrep fast approximate pattern matching tool 
proc 
usenix technical conference pages 
wu manber 
fast text searching allowing errors 
communications acm october 
wu manber myers 
sub quadratic algorithm approximate limited expression matching 
algorithmica 
appendix 
upper bound probability pattern matches text position errors text position reported match 
find upper bound error level probability fl fl eq 

aim probability exponentially small take bound fl consider valid error level strictly smaller bound 
ff gamma oe 
prove fl consider upper bound suppose text area text matches pattern 
report segments character matches pattern know pat 
consider character matching pattern 
length gamma range gamma errors gamma characters pattern text 
uniform model probability matches oe gammak characters pattern text gammak oe gammak gamma gamma gamma gamma oe gammak gamma gamma gamma gamma count ways choose gamma gamma matching characters pattern text respectively 
gamma second characters text match pattern 
divided sum parts area length gamma characters match gamma see 
text pattern matches matches matches upper bound 
assume constant ff cover cases 
summation easy solve exactly get gamma ff gamma delta oe gammak prefer analyze largest term useful second summation 
term oe gammak gamma gamma gamma gamma gamma ff oe gammak oe gammaff ff ff gamma ff gammaff gamma gamma ff ff step done stirling approximation factorial 
clearly summation fl fl largest term order happens base exponential fl 
hand summation bounded times term summation fl term recall exponential multiplied gamma safely multiply 
oe flff ff gamma ff gammaff gammaff fl gammaff ff ff gammaff gamma ff easy show analytically gamma ff ff gammaff ff fl suffices oe gamma ff ff gamma oe arbitrary fl ff gamma gammaff sufficient condition largest term fl summation 
address second summation complicated 
observe oe gammak gamma gamma gamma gamma oe gammak gamma bound find tight 
case clear largest term 
see term oe gamma considering xm gamma ff applying stirling approximation problem maximize base resulting exponential ff ff oe gamma gammax ff ff elementary calculus leads solve second degree equation roots interval gamma ff oe ff gamma ff due eq 
interested oe gamma ff roots maximum gamma ff 
means gamma term second summation largest term summation 
conclude fl fl result suffices condition hold satisfy condition 
prove different model ff gamma oe omega gamma gamma cost verifications significant 

