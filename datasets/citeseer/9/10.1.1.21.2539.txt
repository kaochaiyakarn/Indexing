march department electrical engineering computer sciences university california berkeley california le th ere lig process networks edward lee thomas parks published proceedings ieee may 
ieee rights reserved review model computation industrial practice signal processing software environments experimentally contexts 
give model name dataflow process networks study formal properties utility basis programming language design 
variants model commercial visual programming systems spw alta group cadence systems synopsys dsp station mentor graphics 
research software university new mexico ptolemy university california berkeley 
dataflow process networks shown special case kahn process networks model computation number concurrent processes communicate unidirectional fifo channels writes channel non blocking reads blocking 
dataflow process networks process consists repeated firings dataflow actor 
actor defines functional quantum computation 
dividing processes actor firings considerable overhead context switching incurred implementations kahn process networks avoided 
relate dataflow process networks dataflow models including dataflow machines static dataflow tagged token model 
relate dataflow process networks functional languages haskell show modern language concepts higher order functions polymorphism effectively dataflow process networks 
number programming examples visual syntax 
research part ptolemy project supported advanced research projects agency air force program contract semiconductor research project dc national science foundation mip office naval technology naval research laboratories state california companies bell northern research hitachi mentor graphics mitsubishi nec pacific bell philips rockwell sony synopsys 
motivation motivation concerns programming methodologies commonly called graphical dataflow programming extensively signal processing experimentally appli cations 
graphical means simply program explicitly specified directed graph nodes represent computations arcs represent streams data 
graphs typically hierarchical node graph may represent directed graph 
nodes graph language primitives subprograms specified lan guage fortran 
common signal processing community visual syntax specify graphs case model called visual dataflow programming means essential visual syntax 
graphical programming environments allow arbi mixture visual textual specification language 
example signal lustre languages visual textual syntax available commercial mentor graphics dsp station dfl 
languages related semantics sisal primarily exclusively textual syntax 
language lucid primarily textual syntax experimental visual forms 
hierarchy graphical program structure viewed alternative usual abstraction subprograms procedures functions objects 
better suited visual syntax better suited signal processing 
examples graphical dataflow programming environments intended signal pro cessing including image processing university new mexico distributed research ptolemy university california berkeley signal processing spw alta group cadence com disco systems synopsys dsp station mentor graphics edc 
matlab mathworks popular signal process ing applications visual interface called simulink 
survey graphical data dataflow process networks motivation flow languages applications hills 
software environments claim variants dataflow semantics word caution order 
term dataflow loosely semantics bear little resemblance outlined dennis davis 
major motivation point rigorous formal underpinning dataflow graphical languages establish precisely relationship languages functional languages show languages benefit significantly modern programming concepts polymorphism strong typing higher order functions 
rarely exploited visual dataflow programming show languages effective recursion 
graphical signal processing environments define language strict sense 
fact designers environments advocate minimal semantics arguing graphical organization sufficient useful 
semantics program environments determined contents graph nodes subgraphs grams 
subprograms usually specified conventional programming language environments including spw take middle ground permitting nodes graph subgraph contain arbitrary subprograms defining precise semantics interaction nodes 
halbwachs call language define subprograms nodes host language 
jagannathan call language defining interaction nodes coordination language 
possibilities explored precise semantics coordination languages including example computation graphs karp miller synchronous dataflow graphs lee messerschmitt cyclo static dataflow processing graph method pgm kaplan granular lucid 
limit expressiveness exchange considerable advantages compile time predictability 
graphical programs interpreted compiled 
common signal process ing environments provide options 
output compilation standard procedural language assembly code programmable dsp processors specifica dataflow process networks formal underpinnings tions silicon implementations 
considerable effort put optimized compilation see example 
formal underpinnings graphical programming environments nodes graph viewed processes run concurrently exchange data arcs graph 
pro cesses interaction usually constrained csp sccs 
better fortunately simpler formal underpinning kahn process network 
kahn process networks process network concurrent processes communicate way fifo channels unbounded capacity 
channel carries possibly infinite sequence stream denote 
xi atomic data object token drawn set 
token written produced exactly read consumed exactly 
writes channels non blocking succeed immediately reads block ing 
means process attempts read empty input channel stalls buffer sufficient tokens satisfy read 
lest reader protest show model computation require multitasking parallelism certainly capable exploiting 
usually require infinite queues efficient memory comparable methods functional lan guages see 
process kahn model mapping input sequences output sequences 
process usually constrained continuous technical sense 
develop idea need little notation 
consider prefix ordering sequences sequence precedes sequence written prefix equal example common say approximates provides partial information dataflow process networks formal underpinnings empty sequence denoted bottom obviously prefix sequence 
consider possibly infinite increasing chain sequences increasing chain sequences upper bounds xi 
upper bound upper bound upper bound upper bound may infinite sequence 
denote set finite infinite sequences 
set complete partial order cpo prefix order defining ordering 
complete simply means increasing chain upper bound denote set tuples sequences 
set understood set empty sequences 
sets sequences ordered write set tuples sequences 
greatest lower bound possibly may may upper bound 
increasing chain 
upper bound cpo integer functional process maps set input sequences set output sequences 
increasing chain sets sequences map set set sequences may may increasing chain 
denote upper bound increasing chain 
said continuous chains exists 
analogous notion continuity conventional functions upper bound interpreted limit 

kahn sketches proof networks continuous processes intuitive prop erty called monotonicity 
process fis monotonic 
thought form causality invoke time 
signal pro dataflow process networks lim formal underpinnings cessing provides useful analog causality works multirate discrete time sys tems requiring invocation continuous time 
increasing chain monotonic process map set increasing chain completeness prove kahn claim continuous process monotonic 
prove process monotonic continuous 
process monotonic exist 

increasing chain 
note 
equal 
concludes proof 
key consequence properties process computed iteratively 
means prefix final input sequences may possible compute part output sequences 
words monotonic process non strict inputs need complete computation 
addition continuous process wait forever producing output wait completion infinite input sequence 
network processes essence set simultaneous relations sequences 
denote sequences network including outputs set input sequences network functional processes represented mapping forms solution called fixed point 
kahn argues continuity implies exactly minimal fixed point minimal sense pre fix ordering inputs get execution network setting finding minimal fixed point 
solutions iterative computation inputs gradually extended works monotonic prop erty 
note continuity implies monotonicity way 
process monotonic continuous dataflow process networks formal underpinnings 
outputs possible finite sequences 
show monotonic note sequence infinite 
finite prefix possible outputs 
show continuous consider increasing chain exactly elements 
infinite iterative computation function clearly problematic 

useful property network monotonic processes defines monotonic pro cess 
property valid process networks feedback loops formally proven induction 
surprising results far formally show networks monotonic processes determinate 
nondeterminism finite sequence useful property modern languages ability express nondeterminism 
construct programs respond unpredictable sequences events build incomplete programs deferring portions specification complete information system implementation available 
capability extremely valuable needs balanced observation vast majority programming tasks programmers need determinism 
unfortunately allowing freedom interaction nodes graphical programming environments surprise user behavior 
nondeterminate operations powerful programming tool powerful programming tool necessary 
problems arise shown apt plotkin nondeterminism leads failures continuity 
dataflow process networks formal underpinnings bayesian perspective system random information known sys tem inputs sufficient determine outputs 
semantics programming language may determine known properties execution may unspeci fied 
graphical programming environments define complete lan guages easy dangerous circumvent semantics host language 
fact common principle avoiding specifying programs leaves aspects execution unspecified opens door nondeterminate behavior 
behavior depends unspecified aspects nondeterminate 
nondeterminism added kahn networks methods allowing pro cesses test inputs emptiness allowing processes internally nondeterminate allowing process write channel allowing process con sume data channel allowing processes share variables 
argues implement gives semantics extended process networks 
shared variables form particular pitfall coordination language easy implement host language 
example process network shown graph specifies relative timing processing nodes suppose nodes modify variable share 
order access variable certainly affect outcome program 
problem process network semantics spec ify communication mechanism circumvented shared variable host lan guage 
may powerful useful capability caution particular surprise programmer 
capability built 
process network specify relative timing processing nodes nondeterminate merge specify order results appear dataflow process networks formal underpinnings pgm specification form called graph variables similar shared variables peek poke nodes appears 
share variable described potentially nonmonotonic 
knowing conclude extended inputs affect order shared variable accessed 
monotonic example discipline access shared variable equivalent implementing kahn channel 
different example suppose actor nondeterminate merge variants discussed 
behavior data value token available input immediately move token output 
output depends order produce outputs timing examines inputs 
shown nondeterminate merge unfair nonmonotonic continuous 
involved technically unfair intuitively means favors input 
arvind brock argue nondeterminate merge practically useful resource management problems 
resource manager accepts requests resource money bank balance multiple requests returns deny related data value 
observed resource manager build memory cell precisely type resource functional programming trying get away 
abramsky points functionality nondeterminate merge widely practice time dependent systems despite unsatisfactory formal methods reasoning 
network nondeterminate merge clearly nondeterminate determinate 
example suppose produces outputs 
nondeterminate merge network nondeterminate 
nondeterminate merge satisfy kahn conditions process net reads channels blocking 
constraint impossible process test input presence data 
nondeterminate merge graph fig ure strictly speaking kahn process network 
dataflow process networks formal underpinnings term determinate loosely 
formally define determin ism context process networks main result section follows immediately 
define history channel sequence tokens traversed channel written read 
kahn process network said determinate ries internal output channels depend histories input channels 
monotonic process clearly determinate 
network monotonic processes monotonic network monotonic processes determinate 
streams graphical programming environments concerned design simulate real time signal processing systems 
real time signal processing systems reactive respond continual stream stimuli environment synchronize 
argues streams functions natu ral way model reactive systems 
streams model signals signal pro cessing community routinely uses non real time systems 
observe different ideas literature stream camp defines streams recursively cons list constructors usu ally treats functionally lazy semantics 
view apparently originally due lan din 
lazy semantics ensure entire stream need produced consumer operates 
example burge describes streams functional analog coroutines may considered particular method representing list creation list element delayed needed example scheme streams typically implemented element cell element value head stream procedure computes rest stream 
recursive operations streams require special delay operator defers recursive call access cdr stream element attempted 
ad hoc mechanism recursive streams possible language lazy semantics 
mechanism avoids laziness called structures dataflow languages 
dataflow process networks formal underpinnings camp sees streams channels just channels kahn process network 
channel functional modified appending new elements 
kahn macqueen outline demand driven multitasking mechanism implementing chan nels 
ida tanaka argue channel model streams observing algorithmically transforms programs recursive iterative form 
dennis contrast argues recursive cons representation streams sisal program representation suggests trans non recursive dataflow implementations channel model 
franco argue channel model demand driven execution style pro pose implementation scheme 
channels implemented call current con mechanism scheme 
mechanism essentially supports process suspension resumption authors admit time writing scheme implementa tion supported considerable expense control stack copy 
unique approach implemented language blends benefits declarative style simplicity channel model 
symbol represents infinite stream 
language notion global cycle simple symbol thought referring current value stream implicit infinite itera tion surrounds program 
language successfully software hardware synthesis mentor graphics dsp station cathedral project hyper project berkeley 
global cycle process network context studied observes permits suspension interruption processes predictable way 
general approach associate stream clock done lustre signal 
clock logical signal defines alignment tokens different streams 
example stream second token aligns token stream streams may infinite view having twice tokens powerful algebraic methodology developed reason rela tionships clocks particularly signal language 
caspi described pre attempt notion clocks applies process networks 
applied abstraction lucid language solve certain problems determining dataflow process networks formal underpinnings program executes bounded memory 
different solution problem buck uses called balance equations described section 
difference models streams need important practice choice model may lead unfortunate choices language design 
prefer channel model number reasons 
recursive cons model puts equal emphasis destruction consumption data stream construction production data stream 
suggest costly lazy evaluation 
demand driven style control popular theoreticians established signal processing program ming environment uses partly cost partly benefits avoid ing unnecessary computation usually obtained efficiently compile time analysis 
objectives addressed path analysis reduce cost lazy evaluation functional languages compile time analysis 
channel model streams streams synchronous languages lustre signal concept simultaneity tokens tokens different streams lining 
tokens queued fifo discipline done early dataflow schema 
especially important signal processing applications recognize streams carry truly vast amounts data 
real time digital audio stream instance carry samples second channel run hours 
video sequences carry 
viewing stream conventional data structure gets troublesome quickly 
may require storing forever data enters stream 
practical implementation store sliding window stream preferably small window 
just providing construct random access elements stream example language designer difficult impossible compiler bound size window 
useful stream model context losing data recycling memory storing data 
prefix ordered sequences carried channels kahn process networks excellent model streams blocking reads remove data stream 
special care required memory requirements channels network remain bounded 
problem elaborated 
dataflow process networks formal underpinnings reekie consider problem supporting streams functional programming language haskell 
propose interesting extensions language motivate convincing discussion information needed compiler effi ciently implement streams 
kahn process network model haskell pro grams classify static dynamic 
static networks streams infinite 
dynamic networks streams come go structure network change 
mechanisms dealing types networks different 
static networks common signal processing fortunately easier implement efficiently consider types 
efficiency reekie wish evaluate process networks eagerly lazily normally required haskell 
propose eager evaluation strictness analysis reveals stream head strict meaning element stream evaluated 
similar optimization embodied execution model dataflow graphs combines data driven demand driven evaluation operator nets partitioning net subnets evaluated eagerly causing wasteful com putation 
effect translates recursive cons view streams channel view 
reekie point analysis reveals subgraph synchronous sense synchronous dataflow efficient evaluation possible 
observation known time signal processing circles putting context functional programming valuable contribution 
clarify point establish clear relationship dataflow functional languages kahn process networks 
streams generalized higher dimensionality done lucid ptolemy 
scope 
dataflow functional languages process networks dataflow actor fires maps input tokens output tokens 
actor applied streams fire repeatedly 
set firing rules specify actor fire 
specifically rules dictate precisely tokens available inputs dataflow process networks formal underpinnings actor fire 
firing consumes input tokens produces output tokens 
sequence fir ings particular type kahn process call dataflow process 
network pro cesses called dataflow process network 
specialized dataflow models dennis static dataflow synchronous dataflow described terms dataflow processes 
models sig nal processing environments mentioned described terms dataflow pro cesses 
tagged token model arvind related identical show 
signal lustre called synchronous dataflow languages form dataflow processes lack fifo queues communication chan nels 
implemented dataflow process networks certain benefits parallel implementation 
sufficient condition dataflow process continuous defined equation actor firing functional set firing rules sequential 
func tional means actor firing lacks side effects output tokens purely function input tokens consumed firing 
condition stronger kahn condition process functional meaning output sequences function input sequences 
kahn condition actors manipulate state 
relax constraint actors manipulate state 
sequential means firing rules tested pre defined order blocking reads 
little notation help technical definition precise 
firing rules actor input streams firing rules 

actor fire firing rules satisfied firing rule constitutes set patterns inputs ri ri 
rip 
dataflow process networks formal underpinnings pattern rij finite sequence 
firing rule satisfied pattern rij form prefix sequence tokens input actor input streams enabled 
firing rules patterns empty lists 
means available sequence input jis acceptable sequence particular mean input empty 
accommodate usual dataflow firing rules need generalization prefix ordering algebra 
symbol denote token wildcard 
sequence prefix sequence token 
sequence prefix sequence tokens 
sequence prefix 
notice statement saying token sequence prefix says token 
aj 
denote sequence available tokens th input 
firing rule enabled rij aj 

write condition partial order sets sequences 
ap actors firing rules simple 
consider adder inputs 
firing rule meaning inputs token 
generally synchronous dataflow actors single firing rule pattern firing rule form 
fixed number wildcards 
words sdf actor enabled fixed number tokens input 
interesting actor select actor firing rules 
sdf actor produces fixed number tokens fires captured firing rules 
interesting variant called cyclo static dataflow permits number tokens produced consumed vary cyclically 
modeling firing rules requires straightforward generalization 
give generalization section 
dataflow process networks rij formal underpinnings match true false valued booleans respectively 
behavior actor read boolean control input read token specified data input copy token output 
firing rules sequential blocking read control input fol blocking read appropriate data input invoke appropriate firing rule 
rules nondeterminate merge inputs shown firing rules sequential 
blocking read input fails produce desired behav 
ior illustrated 
blocking read top input unblock 

true data input 
false data input 
control input select 
data input 
data input 
select nondeterminate merge actors combine data streams select actor uses boolean control signal determine accomplish merge 
merge 
illustration firing rules nondeterminate merge sequential 
blocking read input cause networks deadlock inappropriately 
dataflow process networks merge merge formal underpinnings blocking read bottom input unblock 
cases behavior incorrect 
note correct implementation nondeterminate merge networks nondeterminate 
unspecified times token circulate feedback loop arrivals tokens left 
identifying sequential firing rules general set firing rules sequential procedure fail 
find input rij 
find input firing rules require token input 
input exists fail 

choice input divide firing rules subsets specific token value mentioned position rij 
rij 
firing rule appear subsets 

remove element rij 

subsets empty firing rules succeed 
repeat steps subset non empty firing rules 
step identifies input token required firing rules 
idea sec ond step reading token particular input partially determine firing rules apply 
observing value reduce size set applicable firing rules 


consider select actor 
steps 
firing rules divide sets rule 

new firing rules subset second subset 

imply number firing rules finite 
john reekie pointed personal communication relax constraint sequential firing rules corresponding determinate actors procedure fail terminate 
practical matter may need additional restriction procedure terminate 
example actor inputs integer specifying number tokens consume 
firing rules take form 
dataflow process networks formal underpinnings 
procedure repeats trivially subset step modified firing rules empty 
nondeterminate merge procedure fails immediately application step 
relationship higher order functions constraining actors functional dataflow process roughly equivalent function maps burge reekie 
similar map function haskell mapcar function lisp introduces notion consuming tokens match firing rule easily deals infinite streams 
variants map higher order functions take functions arguments return functions 
define map function return function applies element stream set firing rules enabled 
precisely map firing rule colon indicates concatenation sequences 
new set sequences formed appending sequence corresponding sequence notation haskell defines sequences returned input sequences prefix 
notice definition recursive 
recursion terminates argument longer firing rule prefix 
function typically require finite number tokens input function returned map take infinite stream arguments 
map dataflow process firing consists application dataflow actor function nondeterminate example example combines points far constructed nondeterminate operator introduced mccarthy hudak dataflow process networks chosen randomly formal underpinnings declarations define output function firing rules 
dataflow process constructed repeatedly firing function stream inputs 
mccarthy points expression take value uses argue nondeterminism implies loss referential transparency create dataflow process example mixes distinct causes 
random behavior actor acting sufficient lose determinacy referential transparency 
simpler definition chosen randomly sufficient take value 
choice random number random number generator normally random number generator state initial ized seed 
seed shown explicitly argument function chosen generating random number seed suddenly regain referential transparency determinacy 
possible equal example 
giving seed argument functional 
consider simplified definition definition random numbers dataflow process network possible equal 
firing rules sequential 
output depends choice firing rules specified language semantics 
show directly attempt construct dataflow process function yields process monotonic continuous 
map represent 
basic notion lambda calculus referential transparency means identical expressions identical values 
clearly instances taken value 
dataflow process networks formal underpinnings dataflow process actor function easy show process mono tonic 
fact function inputs take possible output value 
consider empty sequence 
clearly 

get take possible values clearly nondeterminate non functional 
possible outcomes satisfy monotonicity constraint 
choose arbitrarily firing rules 
policy choices easy construct example inputs violate monotonicity 
argue different interpretation firing rules firing rule pattern matches empty input tokens available 
interpretation get monotonic appear determinate recall argued continuity sufficient determinacy necessary 
examination reveals implicit assumptions synchronization input streams 
see consider prefix ordered sequences 
reasonable argue fact exactly sequences 
just looking value sequences 
implicit syn assumptions output different 
outputs prefix ordered monotonic process 
issue clearer considers complete dataflow process net shown 
dataflow processes inputs firing rule simple enabled 
produce outputs streams prob dataflow process networks formal underpinnings lems addressed context refer relative timing token production compared timing firings map process 
dataflow process network semantics timing specified 
firing rules template matching functional languages template matching function definitions way firing rules 
consider haskell example slightly simplified syntax fac fac fac defines factorial function 
argument result 
argument result fac 
ambiguous semantics haskell gives priority template removing ambiguity 
second template really shorthand templates viewed firing rules naturally sequential rule consumes token implicitly states previously declared firing rule applies inputs match pattern course remove ambiguities due function arguments data needed 
haskell lazy semantics deferring evaluation function arguments data needed function may invoked decide need data arguments 
embedding example factorial function dataflow process network introduces new interesting problems 
consider map fac stream 
firing actor trigger creation new streams process network static 
consider interesting recursive examples considerable detail defer discussion 

variant mccarthy ambiguous function embedded dataflow process network 
dataflow process networks sequential processes formal underpinnings vuillemin mathematical definition sequential functions entirely consistent notion sequential firing rules 
actor functions processes sequential sense 
definition relationship conti monotonicity summarized 
process sequential continuous 
xp exists xi 
intuitively easy understand context process networks considers simply evolved state input streams words extends streams stream extended 
process sequential needs stream extended extend output stream 
process needs extended extend output 
notice definition sequentiality applied just easily actor function process map 
theorem obvious 
theorem actor function sequential firing rules process map sequential 
sequential continuous monotonic monotonic 
continuous sequential 


xp yi xi continuous 

summary function class definitions relationships function dataflow process networks formal underpinnings question naturally arises non sequential functions continu ous guarantee determinacy 
fact trivial example function identity function inputs 
easy see sequential extending input extends output 
straightforward prove continuous 
order define map need set fir ing rules 
reasonable set firing rules identity function 
firing rules earlier nondeterminate merge identity function clearly determinate 
case continuous map contin uous 
question naturally arises theorem extends continuous functions 
continuous conclude map continuous 
answer demonstrated counterexample 
non empty finite sequence 
define 
colon means concatenation sequences 
function similar identity function simple difference prepends prefix input sequences 
easy show continuous 
map continuous firing rules defined identity function 
fact monotonic functional 
input sequences possible output 
function produces copy prefix outputs fires 
output streams number copies sequence inserted tokens corresponding input stream 
berry defined class functions called stable functions may tial continuous 
class broad class continuous functions certain circumstances easier 
scope 
dataflow process networks formal underpinnings relationship kahn process networks dataflow process networks sequential firing rules functional actors special case kahn process networks 
construct process sequence map atomic actor invocations suspending process blocking read non blocking write processes freely interleaved scheduler determines sequence actor firings 
actors functional state needs stored actor terminates fires 
biggest advantage context switch overhead process suspension resumption entirely avoided 
cost scheduling 
programs cost entirely shifted compiler 
impossible shift costs compiler large clusters process network scheduled compile time greatly reducing number dataflow processes dynamically scheduled 
consequence efficiency finer granularity practical processes simple just add streams 
consider execution models detail 
execution models dataflow process network surprising variety execution models associ ated 
variety due small part fact dataflow process network specify algorithm way non declarative semantics 
execution models dif ferent strengths weaknesses date clear winner 
concurrent processes kahn macqueen propose implementation kahn process networks multi tasking primarily demand driven style 
single driver process puts demands inputs 
suspends due input unavailable input channel marked hungry source process activated 
may turn suspend inputs available 
process issues put command hungry channel suspended destination process restarted left injecting data driven phase dataflow process networks formal underpinnings computation 
get operation suspends process source process suspended waiting input deadlock detected 
kahn macqueen schema configuration network fly allowed 
allows recursive definition processes 
recursive definition streams data permitted form directed loops process graph 
repeated task suspension resumption style execution relatively sive requires context switch 
suggests granularity processes relatively large 
dataflow process networks cost lower general case granularity smaller 
dynamic scheduling dataflow process networks dataflow process networks natural execution models due breakdown process sequence actor firings 
firing actor provides different quantum exe cution process suspends blocking reads 
quantum avoids ties task management context switching scheduling implied kahn macqueen explicitly described franco 
context switching data flow process networks executed scheduling actor firings 
scheduling done compile time run time case done hardware software 
widely known execution models dataflow process networks emerged research computer architectures executing dataflow graphs 
association may unfortunate performance architectures prove competitive 
architectures actors fine grained scheduling done hardware 
attempts apply architectures signal processing widely dataflow programming environments signal processing dataflow architectures 
signal processing environments example synopsys dynamic dataflow domain ptolemy run time scheduler implemented software 
performs essentially function performed hardware dataflow machines dataflow process networks formal underpinnings usually actors larger granularity 
scheduler tracks availability tokens inputs actors fires actors enabled 
static scheduling dataflow process networks signal processing applications firing sequence determined statically compile time 
class dataflow process networks possible called synchronous dataflow 
synchronous dataflow solution set bal ance equations relating production consumption tokens gives relative firing rates actors 
relative firing rates combined simple precedence analysis allows static construction periodic schedules 
synchronous dataflow code generation simulation multirate version spw alta group cadence domains ptolemy 
balance equation methods extended cover dynamic dataflow graphs implement boolean dataflow code generation domains ptolemy 
buck shown addition select actor fig ure switch actor routes input data tokens outputs control boolean input synchronous dataflow model sufficient turing complete 
means implement universal turing machine programming model 
means critical questions undecidable 
reason buck methods statically schedule dynamic dataflow graphs 
turing complete dataflow models necessary programs responsibilities deferred run time sched 
compilation dataflow graphs static schedules emerge buck boolean dataflow scheduler finite sequential representations infinite execution dataflow graph 
schedule dataflow graph translated lean sequential program process normally call com 
parallel implementations briefly discussed section 
dataflow process networks formal underpinnings addition scheduling efficient compilation requires memory allocation done statically possible 
despite kahn process network model infinite fifo channels usually possible construct bounded memory implementations statically allocated memory channels 
unfortunately boolean dataflow model turing complete undecidable arbitrary dataflow graph executed bounded memory static memory allocation channels possible 
programs cost dynamically allocated memory channels needs incurred static analysis techniques break 
address problems benveniste argue called synchro nous approach dataflow clocks associated tokens carried channels 
major part motivation guarantee bounded memory 
compelling advan approach 
clocks impose total order tokens system compared partial order specified process network 
easy implement example determinate merge operation 
viewed way actors test inputs absence data cause nondeterminism process networks 
synchro nous approach critical questions decidable 
restrictions language required programs executable 
argue total ordering synchronous specification fact overspecification reducing implementation options 
partially ameliorated implementation explored le guernic 
tagged token model execution model developed arvind generalizes dataflow process network model 
model token tag associated firing actors enabled inputs matching tags available 
outputs stream produced distinct tags 
immediate consequence need fifo discipline channels 
tags keep track ordering 
importantly need tokens produced consumed order 
possibility order execution allows con dataflow process networks experimenting language design struct dataflow graphs deadlock fifo scheme tagged token scheme 
consider detailed example developing usable language 
experimenting language design dataflow process network model defined far provides framework define language 
define complete language need specify set primitive actors 
outline coordination language leaving design primi tives somewhat arbitrary 
compelling reasons leave primitives unspecified 
graphical dataflow environments rely host language specification primi tives allow arbitrary granularity user extensibility 
depending design primitives language may may functional may may able express may may expressive languages 
granular lucid example coordination language semantics lucid 
coordination languages dataflow semantics described gifford lucassen williams 
contrast approach reekie dsp station mentor graphics new actors defined language semantics identical visual language 
compel ling advantages approach compiler optimizations available level host language primitives 
hybrid approach host language tive semantics gives user flexibility 
purpose explore dataflow pro cess network model fully flexibility essential 
ptolemy system discussion concrete ptolemy software environment illustrate trade offs 
suited reasons visual block diagram textual interface visual interface similar principle signal processing software environments 
dataflow process networks experimenting language design model computation built kernel experiment different models computation interactions models 
dataflow process network domains built ptolemy precisely carry experiments 
set primitive actors easily extended host language 
gives freedom test limits dataflow process network model compu tation 
domain ptolemy user defined subsystem implementing particular model computa tion 
ptolemy domains constructed dataflow semantics general process network semantics 
synchronous dataflow domain sdf particu suited signal processing low overhead execution imperative 
sdf domain scheduling decisions compile time 
dynamic dataflow domain ddf scheduling decisions run time flexible 
boolean dataflow domain bdf attempts scheduling decisions dynamic dataflow graphs compile time called token flow formalism 
resorts run time scheduling analysis techniques break 
process network domain pn uses multi tasking kernel manage process suspension resumption 
permits non blocking reads allows nondeterminism 
ptolemy supports distinct execution models interpreted compiled 
compilation implemented simple code generation mechanism allowing quick tion implemented sophisticated transformation optimization tech niques 
optimization may require knowledge primitives simple code generation mechanism simply code fragments defining actor 
visual hierarchy analog procedural abstraction keeping majority signal processing programming environments visual syntax interconnection dataflow processes 
fact ptolemy program entirely visual actors data structures defined textually 
dataflow process networks experimenting language design gross program structure described visually 
visual equivalent expression course subgraph 
subgraphs encapsulated single node forming larger dataflow pro cess composing smaller ones 
analogous procedural abstraction imperative lan guages functional abstraction functional languages 
determinacy referential transparency dataflow process network determinate discussed sufficient actors properties mappings input tokens output tokens functional free side effects firing rules actor sequential technical sense section 
actors properties language ref erential transparency meaning syntactically identical expressions value regardless lexical position program 
referential transparency subgraphs shown equivalent 
inputs identical dataflow processes identical streams outputs identical 
primitive actors functional hierarchical actors may functional complications due scheduling directed loops graph delays 
functional behavior hierarchy modern languages considered important abstractions semantically lit tle different language primitives 
primitive actors functional hierarchical nodes functional 
primitive actors firing rules hierarchical nodes firing rules 
find goal problematic 
hierarchical node dataflow process network subnetwork input output ports shown examples 
reach ideal able 
referential transparency implies dataflow process networks equivalent 
dataflow process networks experimenting language design describe behavior hierarchical node map constitutes single func tional firing hierarchical node 
possible 
problems arise may defined may functional 
note problem arises defining hierarchical node mapping input sequences output sequences 
func tional actors node functional firings sequential firing rules 
firing subgraphs balance equations examples actor raise question determine firings constituent actors reasonable firing hierarchical node 
approach solve balance equations deter mine firings actor needed return subsystem original state 
original state mean number tokens internal channel arc firing 
consider example 
lee messerschmitt symbol output means produces token fires 
input 
hierarchical nodes dataflow process network may functional primitives contain functional 
large arrowheads indicate input output hierarchical node 
dataflow process networks experimenting language design means consumes token fires 
reasonable firing hierarchical node consist firing single balance equation example number firings equation simply says ai number tokens produced arc equal number consumed keeping balance 
firing hierarchical node invokes th actor times return subsystem original state 
dynamic dataflow graphs balance equations bit complicated lead definitive relative number firings actors required maintain balance 
nonempty set firings returns subsystem original state called complete cycle 
unfortunately problems arise 
useful systems balance equations solution 
systems said inconsistent unbalanced complete cycle usually unbounded memory requirements 
simplified probably useful example shown 
balance equations subsystem arc 
equations solution 
set firings actors leave sub system new state 
hint unbalanced systems useful consider algorithm com ordered sequence integers form abc 
problem considered dijkstra kahn macqueen 
dataflow implementation equivalent kahn macqueen shown 
merge block ordered merge nondecreasing sequence input values streams merges single stream nondecreasing values removes duplicates 
efficient dataflow process networks ai ai experimenting language design implementation generate duplications need eliminate 
inconsistent 
implemented bounded memory 
second fundamental problem existence complete cycles dynamic dataflow graphs undecidable 
algorithm able identify com plete cycle graphs 
third problem actors hierarchical node may form connected graph considering graph node sits 
case bal ance equations node solution 
way select solutions 
node complete cycle identified may able define mapping performed complete cycle 
case map captures behavior node 
unfortunately difficulties 
result merge merge merge merge 
inconsistent dataflow graphs compute ordered sequence integers form triangular icons multiply inputs indicated constant 
delay icon diamond represents initial token value annotated 
dataflow process networks result side effects state experimenting language design node complete cycle second problem arises attempt define mapping terms map 
actors node func tional node may 
consider example 
single firing actor obviously defines complete cycle 
feedback loop implement recurrence feedback channel store tokens firing hierarchical node firing 
usage hier node state functional case feedback loop initialized tokens order avoid deadlock 
shaded diamond called delay typically implemented initial token channel 
described map functional behavior eas ily defined input sequence initial token con catenation operator 
initial token enables firing actor requires token top input 
called delay channel unit delay th token read channel th written 
feedback loop delay effectively stores state mak ing single firing hierarchical node non functional 
delay shown typically implemented cons operator initial ize streams streams recursive cons model 
roughly equivalent operator tagged token model 
visual equivalent fby followed lucid pre operator lustre 
single assignment language developed signal processing delay written 
expression refers stream delayed token initial token value defined declaration value example defines stream consisting non negative integers order 
functional languages recurrent construct delay state usually carried program recursion 
consider example haskell program dataflow process networks integrate xs scanl xs experimenting language design scanl higher order function arguments function number list 
defined follows certain liberties haskell syntax scanl fq scanl fq xs scanl xs definitions template matching invoked third argument empty stream 
gives initial value sum equivalent value initial token delay carries running summation 
syntax xs divides list ele ment rest xs 
syntax expr represents list head expr defines rest just done sequences 
example scanl produces 
program uses recursion carry state higher order function scanl 
observed efficiency recursion translated iterative implementa tion 
streams mandatory depth recursion extremely large 
delays hierarchical node single firing node non functional feedback loop 
consider example 
balance equations tell complete cycle consists firing policy state preserved firings arc connecting actors making firing hierar node non functional 
problems state solved requiring delays appear top level hierarchy done example boss system 
awkward anyway provides partial solution 
better solution simply reconcile desire functional behavior desire maintain state 
done simultaneously hierarchical nodes primitives greatly increasing flexibility convenience lan guage maintaining desirable properties functional behavior 
dataflow process networks experimenting language design basic observation internal state primitive hierarchical node syntactic sugar convenient syntactic shorthand delays feedback loops top level graph 
words reason put feedback loops top level semantics maintained convenient syntax 
observation allow actors state 
objects functions represent data methods operating data 
implicit feedback loop actor hier node state establishes precedence relationship successive firings actor 
precedence serializes actor firings ensuring proper state updates 
allow actors state simple extension allow actors side effects handling inherently sequential nature actor outputs stream file example simply represented feedback loop carry meaningful data establishes precedences successive firings actor 
actors state notation map longer directly valid 
little adap tation 
wish model actor inputs outputs plus state define actor function extra argument carries state firing 
device notice firing rules depend state 
example cyclo static dataflow model actor consume cyclically vary ing number tokens input 
instance dataflow process input output consume token odd numbered firings tokens numbered firings 
case binary valued state variable value zero numbered firings odd numbered firings 
firing rules argument state 
cyclo static actor modeled way 
fact fir ing rules change course firings modeled way vary cyclically long firing rules firing determined firing 
th dataflow process networks th experimenting language design function arguments parameters input streams ptolemy software environments genre phases execution program 
setup phase pass hierarchical program graph initial izing delays initializing state variables evaluating parameters evaluating portion schedule pre computed performing setup functions program mod ules require 
run phase involves executing pre computed schedule dynamic schedule computed fly 
run finite phase allocated memory freed final results user required cleanup code executed 
parameters evaluated setup phase related expression language 
parameters represent part computation operate streams values stream processing computed 
simple examples gain values associated triangular icons initial values delays 
principle values may specified arbi complex expressions 
gain blocks may viewed functions arguments multiply ing constant input stream 
functional languages clear syntactic distinction parameter arguments stream arguments 
functional languages dis type system 
syntax ptolemy tex tual expression language specify value parameters parameter screen 
expression language standard programming lan guages including types scoping rules 
entirely replaced standard program ming language preferably declarative semantics 
parameters formally viewed arguments function represented actor 
syntactic distinction parameters stream arguments especially convenient visual programming 
avoids cluttering diagrammatic program representation great arcs representing streams change value 
job compiler interpreter simpler obviating optimization step identifying static streams 
dataflow process networks experimenting language design ptolemy compiled mode implementation code generation occurs parameters evaluated allowing highly optimized application specific code generated 
example single telephone channel simulator subroutine capable simulating combination impairments optimized code takes advantage fact third harmonic distortion set zero see synthesized 
partic important implementation hardware synthesis increasingly common signal processing systems 
arguments function parameters case call actor source dynamic inputs see example actors 

top typical parameter screen ptolemy hierarchical node models telephone channel 
parameter file 
icon node shown right 
level hierarchy shown lower right window 
lower left parameter screen shows parameter gain actor inherits value noise parameter hierarchy 
parameter values expressions 
dataflow process networks experimenting language design referential transparency source actors preserved long parameters consid ered 
transformation shown possible actors subgraphs consolidated identical parameters 
syntactic devices actors state notation map delays actors parameters inputs referential transparency possible 
call actors generalized functional actors 
firing rules strictness function strict requires arguments com putation 
dataflow process viewed function applied stream clearly strict stream complete process computation 
pro cess fact defined sequence firings consume partial input data produce partial output data 
context trivial form non strictness 
dataflow process composed sequence actor firings 
actor firings selves strict non strict 
determined firing rules 
example actor formed mccarthy function section clearly non strict fire arguments available 
process actor continu ous process non determinate 
possible determinate process non strict actors 
recall select actor 
select select firing rules implied definition sequential token required third argument value argument determines firing rule applies 
select functional process repeated firings actor determinate 
ptolemy icon process shown 
function clearly strict function require arguments 
see non strictness essential general form recursion 
fact non strictness essential recursion functional languages observed course non strict consequent alternative 
dataflow process networks experimenting language design natural question hierarchical nodes strict 
particular hierarchical nodes exists defined firing firing strict 
example shown suggests definitive answer 
hierarchical node composed subprocesses shown 
firing expanded definition consist firing followed connected shown network deadlocks quite unnecessarily insist hierarchical node inputs available firing 

switch select actors dynamic dataflow domains ptolemy 
determinate actors merge split streams control boolean stream 

hierarchical node simple subnetwork expanded definition 
actor strict subnetwork deadlocks 
dataflow process networks experimenting language design dataflow domains ptolemy non strict hierarchical nodes 
implement schedulers domains take simple approach flatten hierarchy constructing schedule 
approach may expensive large programs repeated hierarchical nodes particularly line code generated 
precludes incremental compilation hierarchical nodes 
appears necessary support graphs 
sophisticated scheduler constructs strict hierarchical nodes safe clustering process order build compact schedules 
ignores user specified hierarchy doing 
recurrences recursion functional languages haskell commonly recursion carry state 
compa mechanism dataflow process networks feedback loops usually initial tokens shown 
feedback loops specify recurrence relations self ref erential usual sense recursion 
ida tanaka abramsky noted advantages representation 
consequence recursion plays considerably reduced role dataflow process networks compared functional languages 
mean recursion useful 
consider sieve eratosthenes algorithm considered kahn macqueen 
computes prime numbers constructing chain filters prime number far 
filter removes stream multiple prime number 
algorithm starts creating single filter prime number chain runs successively larger integer chain filters 
time number gets chain prime new filter created added chain 
recur sive implementation algorithm concise convenient elegant course express recursive algorithm iteratively 
recursive implementation dynamic dataflow domain ptolemy shown fig ure 
icon concentric squares higher order function explained invokes named hierarchical node sift fires 
case named hierar node recursive hierarchical node icon appears 
dataflow process networks experimenting language design direct expression recursion supported ptolemy graphical interface supported underlying kernel 
ptolemy implements simple expensive way dynamically expands graph recursive block invoked 
efficient imple easy image 
note recursion expresses mutable graph structure graph changes program executes 
dynamics permitted kahn mac fork replicate stream generate constant stream value filter value pass arriving token output 
remaining input tokens traverse lower path 
discard delay initial value initial value filter eratosthenes recursive sift discard non primes store arriving value feedback loop 

recursive implementation sieve eratosthenes dynamic dataflow domain ptolemy 
top level system just actors produces integers greater filters primes displays results 
icons explained 
dataflow process networks sift true top input multiple bottom input experimenting language design queen 
mutability considerably complicates compile time anal ysis graph 
compile time scheduling methods extended recursive graphs 
raises interesting question recursion precludes compile time scheduling 
find somewhat surprisingly 
illustrate point derive recursive implementation fast fourier transform fft syn chronous dataflow domain ptolemy show completely scheduled compile time 
statically parallelized recursive description imposing ment 
classic derivation fft leads directly natural intuitive recursive represen tation 
completeness repeat simple derivation 
th order discrete fourier transform dft sequence get values simply periodically repeat values period define note properties write change variables summations wn wn wn kn dataflow process networks wn wn 
kn kn wn odd kn wn kn kn wn wn 
experimenting language design key step derivation called decimation time fft summa tion order dft samples second order dft odd samples 
general write wn 
recall periodic period periodic period 
arrive recursive specification shown 
actor distributor collects samples time fires routing top output second lower output 
recursive invocation block accomplishes decimation time 
outputs distributor connected ifthenelse blocks repre senting possible replacement subsystems 
order parameter larger threshold ifthenelse block replaces recursive galaxy sits implementing fft half order 
order parameter gets threshold ifthenelse block replaces direct implementation small order fft 
ifthenelse block example higher order function discussed detail 
repeat block takes account periodicity dfts distributor ifthenelse fft half order recursive repeat 
recursive specification fft implemented sdf domain ptolemy 
recursion unfolded setup phase execution graph completely scheduled compile time 
dataflow process networks experimenting language design order duplicating computation 
block bottom simply generates wn sequence 
sequence precomputed computed fly 
traditional visual representation fft shown 
representa tion extremely inconvenient programming represent ffts size typically points 
visual representation order fft granularity specification hard wired specification 
better parameterized 
argue visual representation fig ure intuitive direct representation underlying idea 
interesting generalization conditional recursion templates parameter values select possible implementations node 
recursion identical functional languages haskell albeit visual syntax 
illustrated practical example application recursion 
consider system shown 
shows multirate signal processing applica tion analysis synthesis filter bank harmonically spaced subbands 
stream coming left split matching highpass lowpass filters labeled qmf quadrature mirror filter 
decimating polyphase finite impulse response fir filters tokens consumed input token produced outputs 
left qmf labeled number tokens consumed produced behave way 
output lowpass side split second qmf lowpass output third qmf 
boxes labeled represent function performed decimated dataflow process networks 
fourth order decimation time fft shown graphically 
order fft hard wired representation 
experimenting language design stream quantization 
qmf boxes right reconstruct signal matching polyphase interpolating fir filters 
distinct sample rates ratio largest smallest 
type application typically needs implemented real time low cost compile time scheduling essential 
graphical representation useful developing intuition exposes exploitable parallelism useful programming 
depth filter bank hard wired visual representation conveniently parameter filter bank module 
representation better 
hierarchical node called fb filterbank defined parameter depth 
definition block center 
contains self parameter inside changed 
definition bottom 
system top consisting just block labeled fb exactly equivalent representation visual representation depend depth 
visual recursion unfolded completely compile time exposing exploitable parallelism incurring unnecessary run time overhead 
higher order functions dataflow process networks arcs connecting actors represent streams 
icons rep resent actors processes repeated firings actor 
functional languages qmf qmf qmf 
analysis synthesis filter bank sdf model 
depth filter bank hard wired representation 
dataflow process networks qmf qmf qmf experimenting language design represent processes higher order functions 
example haskell map xs applies function list xs 
single input process dataflow process network con invocation higher order function applied stream list 
visual syntax function specified simply choice icon 
haskell variant zipwith xs ys function takes arguments 
corresponds simply dataflow process inputs 
similarly haskell function scanl xs takes scalar list xs 
function applied head xs 
function applied returned value second element xs 
corresponding visual syn tax dataflow process network 
fb qmf fb fb dataflow process networks fb qmf 
recursive representation filter bank application 
representation uses template matching 
experimenting language design recall proposed syntactic sugar representing feedback loops actors state 
typically initial value state parameter node 
fact dataflow processes state cover commonly higher order func tions haskell 
basic icons visual syntax may viewed implementing small set built higher order functions 
elaborate higher order functions immediately recognizable prove extremely useful 
pioneering higher order functions visual languages done hills najork golin reekie 
draw 
created actor ptolemy called map generalizes haskell map 
icon shown 
parameters name replacement actor 
defined location definition actor 
parameter map set parameters replacement actor 
input map connect inputs 
output map connect outputs 
xs 
visual syntax dataflow process network equivalent haskell scanl xs higher order function 
map 
icon map higher order function ptolemy 
dataflow process networks experimenting language design implementation map simple effective 
creates instances spec ified actor may hierarchical node splices instance posi tion graph 
call specified actor replacement actor takes place map actor 
map actor self 
done setup phase execution overhead incurred higher order function run phase execution signal processing applications critical 
replacement viewed form partial evaluation program 
consider example shown 
replacement actor specified raised cosine built actor signal processing environment ptolemy 
built need specify defined defined parameter blank 
actor single input named single output named names values input map output map parameters 
parameter map parameter specifies values parameter instance replacement block created 
parameter specifies excess bandwidth raised cosine pulse generated actor 
value parameter instance actor second third 
impulse impulse impulse map dataflow process networks bus defined parameter map instance number input map output map 
example map actor plot different raised cosine pulses 
experimenting language design diagonal slash connection right bus 
single parameter specifies number logical connections single visual connection represents 
bus width 
inputs map actor instances actor created 
outputs instances need go 
result running system shown 

plot results running program 
dataflow process networks experimenting language design program equivalent 
setup phase execution topology process network exactly 
map actor appear topology 
figures number instances actor specified graphically 
specified implication number instances impulse actor 
specified directly 
really takes advantage higher order functions 
program equivalent figures impulse impulse impulse 
program equivalent higherorder functions 
src bus impulse defined parameter map output map output map 
program equivalent figures number instances impulse actors specified parameter 
dataflow process networks bus defined parameter map instance number input map output map experimenting language design easily modified include fewer instances actor 
necessary modify parameters bus icons visual representation 
left actor variant map actor called src 
inputs 
case number instances replacement actor created match num ber output streams 
visual programming languages higher order functions function slots concept visually representing replacement function box inside icon higher order function 
implemented ptolemy conceptually similar visual representation 
variants map src actors called icons shown 
important realize contains icons repre senting single actor 
complicated shape icon intended suggestive func tion block diagram 
actors just map src actors programmer specifies replacement block visually ally 
example system specified shown 
notice replacement actors impulse instance shown visually 
actors single parameter called parameter map 
parameters map src represented visually replacement block input output mapping 
note effect accomplished tricks graphical user interface done instance grape ii 
requires modifying gui support new capabilities 
number additional variations possible 
replacement actor may input case input streams grouped appropriately sized groups distribute collect dataflow process networks collect 
icons higher order functions ptolemy 
experimenting language design provide arguments instance specified actor 
example replacement actor inputs input streams instances actor created 
instance process streams second streams map actor creates instance replacement actor directly recursion 
recursion terminate 
variant map actor defined instantiates replacement actor run time 
essentially implement recursion 
dynamic dataflow dynamic map actor fires conditionally 
fires creates instance replacement actor may hierarchical node recursively referenced self 
dynamic map higher order function implemented ptolemy implemented different name ha 
run time operation quite expensive requiring dynamic creation dataflow graph 
considerable motivation recursion statically unrolled done 
fact system imple mented higher order function ifthenelse derived map 
ifthenelse actor takes replacement actors parameters plus predicate 
predicate spec replacement actors 
actor expanded graph instance spliced position ifthenelse actor 
ifthenelse actor map actor self 
unused replacement actor argument evaluated impulse collect parameter map bus distribute collect 
program equivalent replacement actors higher order actors specified visually textually 
dataflow process networks bus parameter map instance number experimenting language design semantics non strict ifthenelse actor implement recursion 
recur sion completely evaluated setup phase execution compile time recursion imposes run time overhead run phase 
analogous unrolling style partial evaluation called manifest recursion 
higher order functions key restriction replacement actor specified parameter input stream 
avoid embedding unevaluated closures streams 
ptolemy tokens pass channels objects hard implement general form 
warrants investigation 
tagged token execution model recall tagged token execution model developed arvind allows order execution 
allows dataflow graphs produce output deadlock fifo channel model 
example shown 
graph computes 
order execution allowed deadlocks producing output fifo model 
sequence values labeled arcs table 
loop left counts delay initialized value circulating loop decremented time 
test diamond shape compares value 
outputs true 
time select select 






factorial program deadlocks order execution provided example tagged token model 
dataflow process networks experimenting language design enabled tokens false input 
notice time queue control input select false tokens followed true token 
false tokens consumed 
order execution allowed select able fire 
select state reason prohibit order exe cution 
order execution requires bookkeeping provided tagged token model 
consumption true token th firing logically select 
produced output logically th output produced select 
show output entry table produced tempo rally 
logical ordering preserved 
recall delay initial token channel 
delay left ordinary delay initial token initialized value delay right thing new negative delay 
initial token delay discards token enters channel 
implemented variety ways shown 
effect negative delay shown column token logically temporally produced select discarded negative delay 
produced th firing logically select consumed th firing multiply upper right 
input multiply value th input th output log ically output temporally multiply 
available th token logically select false input consumed th firing cally select 
produced multiplied enabling th firing select 
continue firing logically select produces 
point tokens input icon bottom downward arrow switch 
way implement negative delay discards token arrives input stream 
dataflow process networks experimenting language design enabling 
consumes tokens outputs logically 
output 
note appear unduly complicated way compute facto demonstrates enabling order execution increase expres language 
course limited value represent obscure unnecessarily complicated algorithms 
data types polymorphism key observation dataflow process networks far data type represented visually stream 
tokens stream arbitrary type approach flexible sounds 
instance embed arrays streams directly sequencing elements array encapsulating array sin gle token generalizing multidimensional streams 
ptolemy tokens con tain arbitrary objects actors operate tokens sophisticated ways making effective data abstraction 
ptolemy networks strongly typed 
actor port input output type type consistency statically checked 
polymorphism single actor operate variety data types supported natural way 
hudak distinguishes types polymorphism parametric ad hoc overloading 
function behaves way regardless data type arguments 
behavior different depending type 
principle supported ptolemy parametric polymorphism visual pro gramming syntax 
way parametric polymorphism handled actors declare inputs outputs type 
actors operate tokens abstracted type handles 
polymorphic blocks ptolemy include perform control functions streams distributor 
map actor polymorphic complicated way 
dataflow process networks parallelism experimenting language design functional languages dominant view appears parallelism defined programmer annotating program processor allocation 
indicated harrison ubiquity recursion functional programs parallel algorithms 
harrison proposes higher order func tions express parallel algorithms functional language place recursion 
parallel implementation accomplished mechanized program transformations higher order function description 
called transformational parallel programming explored reekie potter context process networks 
transformations interactive supported meta programming 
transformation methodology unfold fold method burstall darlington partial symbolic evalua tion substitution equal expressions 
dataflow community contrast parallelism implicit 
part due scarce recursion 
dataflow graph typically reveals great deal parallel ism exploited run time hardware firing sequence sufficiently predictable compiler 
dataflow process networks combine best 
parallelism implicit higher order functions simplify syntax graphical specification 
phased execution static higher order functions evaluated setup phase analogous fold unfold method burstall darlington need specialized transformation tool understands semantics higher order functions 
parallelism exploited equally user defined higher order functions built language 
surprising twist statically evaluated higher order functions enables recursion compromising parallelism 
recursion evaluated setup phase parallelizing scheduler invoked 
scheduler sees fully expanded graph recursion 
fully exploit compile time parallelism graph 
regain elegance recursion lends functional lan dataflow process networks guages 
example recursive specification fft 
situations recursion evaluated setup phase sieve eratosthenes difficult exploit parallelism compile time 
signal processing software environments domain specific 
techniques including especially visual syntax proven domain specific context 
best features best modern languages including natural efficient recursion higher order functions data abstraction polymorphism 
presents theory design partially put practice signal processing community 
words milner theory stand fall experiment conventional scientific sense pertinence theory judged experiment truth 
acknowledgments entire ptolemy team especially joe buck ha alan dave messerschmitt conceiving building infrastructure kinds experiments described 
gratefully acknowledge helpful comments suggestions albert benveniste gerard berry bhattacharyya john reekie srini juergen teich anonymous reviewers 
inspiration came originally jack dennis pointed need relate dataflow signal processing broader computer science community 
dataflow process networks abelson sussman structure interpretation computer programs mit press cambridge ma 
abramsky reasoning concurrent systems chambers duce jones editors distributed computing academic press london 
ackerman data flow languages computer vol 
february 
apt plotkin countable nondeterminism random assignment acm vol 
pp 

arvind bic evolution data flow computers advanced topics data flow computing ed 

bic prentice hall 
arvind brock resource managers functional programming parallel distributed computing vol 

arvind relationships asynchronous interpreters dataflow language formal description programming languages ifip working group 
arvind interpreter computer february 
arvind nikhil pingali structures data structures parallel computing acm transactions programming languages systems vol 
pp 
oct 
ashcroft jagannathan operator nets proc 
ifip tc working conf 
fifth generation computer architectures north holland netherlands 
benveniste berry synchronous approach reactive real time systems proceedings ieee vol 
pp 

benveniste le guernic hybrid dynamical systems theory signal language ieee tr 
automatic control vol 
pp 
may 
benveniste caspi le guernic halbwachs data flow synchronous languages de bakker 
de roever rozenberg eds decade concurrency reflections perspectives lecture notes computer science springer verlag berlin 
berry bottom computation recursive programs revue fran automatique informatique recherche op vol 
pp 
march 
bhattacharyya lee memory management synchronous dataflow programs appear ieee tr 
signal processing may 
bhattacharyya lee looped schedules dataflow descriptions multirate signal processing algorithms appear formal methods system design updated ucb erl technical report may 
engels static scheduling multi rate cyclo static dsp applications proc 
workshop vlsi signal processing ieee press 
bloss hudak path semantics proc 
third workshop mathematical foundations programming language semantics lecture notes computer science pp 
springer verlag 
dataflow process networks de processus avec equitable une approche du temps reel th se etat ph thesis french universit curie cnrs universit paris place jussieu paris cedex france june 
de processus rapport de recherche inria sophia antipolis france november french 
brock ackerman scenarios model non determinate computation proc 
conf 
formal definition programming concepts lncs pp 
springer verlag berlin 
buck scheduling dynamic dataflow graphs bounded memory token flow model tech 
report ucb erl ph 
dissertation dept eecs university california berkeley ca 
buck lee token flow model data flow workshop hamilton island australia may 
advanced topics dataflow computing multithreading ed 
bic guang gao jean luc ieee computer society press 
buck ha lee messerschmitt multirate signal processing ptolemy proc 
int 
conf 
acoustics speech signal processing toronto canada april 
buck ha lee messerschmitt ptolemy framework simulating prototyping heterogeneous systems international journal computer simulation april 
burge stream processing functions ibm research development vol 
january 
burstall darlington transformation system developing recursive programs jacm vol 

carriero gelernter linda context comm 
acm vol 
pp 
april 
caspi clocks dataflow languages theoretical computer science vol 
march 
caspi lucid proc 
hermes paris pp 

chen developing multidimensional synchronous dataflow domain ptolemy ms report erl technical report ucb erl university california berkeley ca may 
church calculi lambda conversion princeton university press princeton nj 
holt marked directed graphs journal computer system sciences vol 
pp 

consel danvy tutorial notes partial evaluation th acm symp 
principles programming languages pp 
january 
davis data driven nets maximally concurrent procedural parallel process representation distributed control systems technical report department computer science university utah salt lake city utah july 
davis keller data flow program graphs computer february 
de man goossens van note architecture driven synthesis techniques mapping digital signal processing algorithms silicon proceedings ieee vol 
pp 
february 
dennis version data flow procedure language technical memo mac tm may mit laboratory computer science 
dennis data flow supercomputers ieee computer vol november 
dataflow process networks dennis stream data types signal processing unpublished memorandum september 
efficient assembly code generation dsp starting data flowgraph trans 
icassp minneapolis april 
dijkstra discipline programming prentice hall englewood cliffs new jersey 
franco friedman johnson multi way streams scheme comput 
lang vol 
pp 

gifford lucassen integrating functional imperative programming proc 
acm conf 
lisp functional programming pp 

ha compile time scheduling dataflow program graphs dynamic constructs ph dissertation eecs dept university california berkeley ca april 
halbwachs caspi raymond pilaud synchronous data flow programming language lus tre proceedings ieee vol 
pp 

halbwachs synchronous programming reactive systems kluwer academic publishers dordrecht 
harrison higher order approach parallel algorithms computer journal vol 

hicks ang arvind performance studies id monsoon dataflow system parallel distributed computing vol 
pp 
july 
hilfinger high level language silicon compiler digital signal processing proceedings custom integrated circuits conference ieee computer society press los alamitos ca pp 
hills visual languages computing survey data flow visual programming languages visual languages computing vol 

hoare communicating sequential processes communications acm vol 
august 
hudak haskell functional programming acm computing surveys sept 
hughes compile time analysis functional programs turner ed research topics functional programming addison wesley 
ida tanaka functional programming streams information processing elsevier science pubs north holland 
jagannathan parallel execution glu programs nd international workshop dataflow computing hamilton island queensland australia may 
ashcroft hybrid model parallel processing proc 
int 
conf 
parallel processing pp ieee august 
kahn semantics simple language parallel programming proc 
ifip congress north holland publishing 
kahn macqueen coroutines networks parallel processes information processing editor north holland publishing 
kaplan processing graph method specification version unpublished memorandum naval research laboratory washington december 
karp miller properties model parallel computations determinacy termination queueing siam journal vol 
pp 
november 
dataflow process networks landin correspondence algol church lambda notation communications acm vol 

ad geometric parallelism cyclo static dataflow grape ii proc 
th int 
workshop rapid system prototyping grenoble france june 
lee consistency dataflow graphs ieee transactions parallel distributed systems vol 
april 
lee representing exploiting data parallelism multidimensional dataflow diagrams proc 
icassp minneapolis mn april 
lee messerschmitt static scheduling synchronous data flow programs digital signal processing ieee transactions computers january 
lee messerschmitt synchronous data flow ieee proceedings september 
le guernic gauthier le le programming real time applications signal proceedings ieee vol 
september 
le guernic signal fine grain parallel implementations int 
conference parallel architectures compilation techniques ifip north holland pp 
august 
mcallester fairness signaling appear jcss 
mccarthy recursive functions symbolic expressions computation machine part comm 
acm april 
mccarthy basis mathematical theory computation computer programming formal systems north holland pp 

mcgraw sisal streams iteration single assignment language language manual lawrence livermore national laboratory livermore ca 
milner communication concurrency prentice hall englewood cliffs nj 
najork golin enhancing show tell polymorphic type system higher order functions proc 
ieee workshop visual languages illinois october pp 

olson klop mavis visual environment active computer vision proc 
ieee workshop visual languages seattle wa usa sept ieee comput 
soc 
press 
signal processing language coarse grain dataflow multiprocessors mit lcs tr technology sq cambridge ma june 
expressive power indeterminate dataflow primitives information computation vol 
may 
pino parks lee mapping multiple independent synchronous dataflow graphs heterogeneous multiprocessors proceedings ieee asilomar conference signals systems computers november 
pino ha lee buck software synthesis dsp ptolemy journal vlsi signal processing vol 
pp january 
powell lee newman direct synthesis optimized dsp assembly code signal flow block diagrams proceedings icassp san francisco march 
dataflow process networks automatic mapping large signal processing systems parallel machine memorandum cmu cs school computer science carnegie mellon university ph thesis may 
rabaey chu potkonjak fast prototyping datapath intensive architectures ieee design test computers pp 
june 
williams integrated visual language software development environment journal visual languages computing vol pp 
reekie effective programming parallel digital signal processing research report university technology sydney po box broadway nsw may 
reekie integrating block diagram textual programming parallel dsp proc 
int 
symp 
signal processing applications queensland australia august 
reekie potter transforming process networks massey functional programming workshop massey university north new zealand august 
reekie potter generating efficient loop code programmable dsps proc 
icassp adelaide australia april 
manning block oriented system simulator boss telecommunications laboratory university kansas internal memorandum 
lee compile time scheduling heuristic interconnection constrained heterogeneous processor architectures ieee trans 
parallel distributed systems vol 
february 
lee declustering new multiprocessor scheduling technique ieee trans 
parallel distributed systems june 
stream languages data flow advanced topics data flow computing ed 

bic prentice hall 
srini architectural comparison dataflow systems computer march 
biswas korner browne task level dataflow language parallel distributed systems june 
vuillemin proof techniques recursive programs ph 
thesis computer science department stanford university usa 
wadge ashcroft lucid dataflow programming language london academic press 
exploring stream data type sisal languages appear advanced topics dataflow computing multithreading ed 
bic guang gao jean luc ieee computer society press 
dataflow process networks 
