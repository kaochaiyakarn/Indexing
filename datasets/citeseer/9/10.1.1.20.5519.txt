statemate semantics statecharts david harel weizmann institute science amnon naamad logix describe semantics statecharts implemented statemate system 
executable semantics defined language decade 
terms controversy changes step take effect current step semantics adopts approach 
categories subject descriptors software software engineering logics meanings programs semantics programming languages general terms languages additional key phrases behavioral modeling reactive system semantics state chart statemate 
article introduced language statecharts harel brief discussion semantics defined 
rigorous semantics defined language harel 
variants statecharts proposed literature papers include definitions semantics 
examples huizing de roever huizing kesten pnueli leveson pnueli shalev 
survey yon der beek discusses nearly variants 
revised version semantics statecharts technical report logix 
harel supported israel academy sciences 
authors dresses harel weizmann institute science rehovot israel email harel weizmann ac il naamad logix ma email amnon com 
permission digital hard copy part personal classroom fee provided copies distributed profit commercial advantage copyright notice title publication date appear notice copying permission acm copy publish post servers lists requires prior specific permission fee 
acm acm trans re engineering methodology vol 

october pages 
david harel amnon naamad subtle issues arise tries define semantics language consensus right way go task 
statecharts intended start real engineers specifying real systems central considerations deciding useful semantics clarity simplicity 
user need see details mathematical definition able understand works relatively intuitive way 
article describes semantics language statecharts statemate system harel harel 
initial version semantics developed team years ago 
added experience users system extended modified 
executable semantics operation driving simulation dynamic tests code generation statemate technical report describing available logix 
decided revise publish report widely accessible alleviate confusion official semantics language counter number incorrect comments literature way statecharts implemented 
example survey yon der beek mention statemate implementation statecharts semantics adopted semantics different ones surveyed developed earlier harel 
example leveson describe case exhibits unacceptable kind behavior statechart say semantics statecharts leads pp 

unfortunately base discussion statechart semantics semantics proposed various authors pnueli shalev give reader impression official semantics language 
unofficial language statecharts clearly official semantics researchers free propose semantics see fit 
implemented working semantics statecharts years described way exhibit kind behavior described example surrounding text leveson 
fact semantics quite similar approach suggested years add leveson dozen years ago contemplated building statemate semantics close pnueli shalev 
main difference served central topic heated deliberations changes occur step generated events updates values data items take effect current step 
semantics current version statemate available logix termed state mate 
parts managed alarm users statemate models dangerously erroneous 
ac software engineering methodology vol 
october 
statemate semantics statecharts adopted contrast harel pnueli shalev takes approach 
appendix address son semantics especially relate issues spelled von der beck 
main consideration definition selection seman tics described commercial tool designed specification design real life complex systems coming variety disciplines 
semantics rich support different styles modeling simple intuitive 
technically straightforward enable fast simulation models generate useful hardware software code models 
noteworthy vhdl ieee standard language description hardware evolved time semantics statecharts described defined adopted approach changes carried step delta vhdl nomenclature sensed 
despite qualitative claims semantics knows anomalous examples constructed semantics proposed concurrent language represents way language implemented statemate 
due somewhat different goals usage statemate analy sis tools simulation dynamic tests hand generated code extreme cases may slight differences behaviors entailed tools 
include treatment nondeterminism racing states enabled default transitions 
cases analysis tools issue warning message 
details provided 
article concentrates mainly notions special slate charts hierarchy states orthogonality history connectors 
number issues unique statecharts widely available formalisms may new statemate users 
generic charts logic queues treated detail logix documents describe 
describe appendix combinational assignments 
appendix discusses priority transitions process undergoing change coming versions statemate 

basics statemate set languages modeling reactive systems harel pnueli structured analysis paradigm 
described detail harel harel 
backbone 
system model activity chart hierarchical data flow diagram functional capabilities system captured activities data elements signals flow 
semantics functional description acm software engineering methodology 
vol 
october 
david harel naamad sii ai 
dynamically asserts activities active information flow specify happen 
behavioral aspects specified state charts called control activities potentially activity activity chart 
activity statechart controls dynamics data flow including ability activate deactivate activities cause data written modified read send signals sense things happened affecting subsequent behavior 
shows structure simple hierarchy activities 
statemate model 
boxes activities rounded boxes control activities mentioned specified statecharts 
precise way statecharts describe behavior control behavior entire setup activities data time heart system model defining semantics statecharts crucial 
operational terms statemate simulation code generation dynamic tests tools execute model explicitly implicitly semantics 
full definition allowed syntax statecharts statemate scope article 
refer reader short description acm software engineering methodology vol 
october 
statemate semantics statecharts harel full harel 
brief reminders 
types states statechart states states basic states 
states substates related exclusive states orthogonal components related 
basic states bottom state hierar chy substates 
state highest level parent state called root 
general syntax expression labeling transition statechart event triggers transition condition guards transition taken true occurs action carried transition taken 
optional 
special events conditions actions relate statemate mode entities activities data items states 
example special action start abbreviated st causes activity start 
similarly simply external primitive event special event entered abbreviated en occurs causes transition take place state entered 
mentioned explicitly article concentrate statecharts 
events closed boolean operations conditions 
expression interpreted 
allowing actions appear transitions appear associated entrance exit state state level 
actions associated entrance state executed step entered appear transition leading similarly actions associated exit executed step exited appear transition exiting 
events en ex sensed step entered exited respectively 
addition state associated static reactions srs format transition label carried enabled long system exiting state question 
semantically sr state regarded transition virtual substate orthogonal ordinary substates srs example figures depict behavior 
activity linked directly state specifying take place semantics activity active state starts active entering stops leaving 
semantics activity active state may active system entails stopping exited 
action scheduled units carrying new action form schedule abbreviated sc 
similarly special event timeout abbreviated tin occurs time units acm transactions sofware engineering methodology vol 
oc david harel amnon naamad ev act 
ev act occurrence event way calculated discussed sections 
behavior system described state mate set possible runs representing responses system sequence external stimuli generated environment 
run consists series detailed snapshots system situation snapshot called status 
sequence initial status subsequent obtained predecessor executing step see 
shall see defining step precisely ramifications side effects semantics 
status contains information active states activities values data items conditions generated events scheduled actions information regarding system history past behavior 
step environment supplies system descrip tion external stimuli 
changes occurred system previous step trigger transitions states static reactions states 
result system moves new status 
states exited entered values conditions data items modified new events generated ties started stopped 
general principles adopted defining semantics reactions external internal events changes occur step sensed completion step 
events live duration step occur remembered subsequent steps 
calculations step situation step states system activities active values conditions data items time 
maximal subset nonconflicting transitions srs executed 
refer greediness property semantics 
execution step takes zero time 
time interval executions consecutive steps part step semantics 
acm transactions software engineering methodology vol 
october 
statemate semantics statecharts stcp step step step status status status status status initial 
depends execution environment time model users tool significant degree control 
discussed section 
important note statemate supports time models steps may execute point time 
event generated step time may sensed step 
occurrence event sensed steps follow step steps execute time general quite straightforward define effect step involving single statechart transition nonconflicting transitions separate orthogonal components 
trivial situations 
example transitions enabled may conflicting unable participate step 
transition arrow crosses boundaries nested states accurately define states exited transition entered 
main technical goal article describe way general case treated 
organized definition incrementally starting simplest obvious cases complicating things go 

basic system reaction configuration maximal set states system simultaneously 
precisely root state configuration relative set states obeying rules contains contains state type contain exactly substates 
contains state type contain substates 
states required rules 
follows configurations closed upwards system state parent state course root case parent 
fact uniquely determine configuration sufficient know basic states 
conse quently term basic configuration refer maximal set basic states system simultaneously words set basic states legal configuration 
illustrate consider 
basic configuration full configuration contains root 
maximal basic configuration 
legal configuration system simultaneously acm sofware engineering methodology vol 
october 
david harel naamad offspring state 
el basic configuration full configuration set 
step system typically carry operations types transitions static reactions actions performed entering state actions performed exiting state 
section discuss simplest kind step involving single transition ordinary un adorned statechart 
consider assume system state event ev just occurred 
response system follows transition tl enabled system tl source state trigger event ev generated 
tl taken meaning system exit state enter state execute action act 
special events exited entered generated sensed step 
special condition false condition true 
actions specified take place exiting state executed 
actions specified take place entering state executed 
srs state enabled trigger true executed 
system state step exit step 
activities specified active state deactivated defined active state necessarily defined active activated 
figures ofi 
en write names transitions tl 
arc parts statemate syntax just help exposition 
shaded states figures serve represent basic configuration system moment 
acm transactions software methodology vol 
october 
statemate semantics statecharts re 
consequence direct changes listed events generated conditions change value 
example special tr appears model generated result executing tl occurs condition false 
activity activated event started occurs condition active true 
mentioned changes sensed steps 
example fact state exited generates event exited static reaction triggered event executed step 
applies generated events changes conditions data items 
things means system enter exit state step 
interestingly possible self looping transition exit reenter state step 
example suppose action act defined act act value evaluating arithmetic expression boolean expression value step incremented 
value step act act executed 
semicolon action appearing transition static reaction signifies meaning actions executed parallel 
actions executing step call changing value common data item predict outcome 
correct implementations semantics may yield different results 
cases say racing condition 
example illustrates acute type racing statemate semantics affect behavior action changes value step 
change occurs step issue unpredictability differences behavior situation detected intention different outcome 
types racing detected reported statemate simulation dynamic tests tools 
racing discussed detail 
acm software engineering methodology vol 
october 
david harel naamad 
compound transitions execution step lead system legal configuration 
particular statechart stuck execution connector exception termination connector 
similarly statechart nonbasic state ability enter appropriate substates 
mind actual transition configurations taken step complicated 
may consist number separate transitions appearing different orthogonal state components may consist number linked transition segments labeled arrows connect states connectors various kinds 
section illustrates way transition segments combined form full transitions 
uses number different kinds compound transitions 
basic compound transition ct maximal chain transition segments linked connectors executable simultaneously single transition 
trigger ct taken conjunction triggers constituent segments action concatenation actions thereof 
connectors enable transition segments combined form ct come forms 
joint fork connectors see figures 
transition segments connected connector participate ct words set transition segments leading emanating connector ct contains segment contain segments condition selection junction connectors see figures 
connector sets transition segments leading emanating respectively 
ct contains segment contain exactly segment 
types basic cts initial ct ct source state continuation ct ct source default history connector 
targets types basic cts states history termination connectors 
full ct combination initial ct possibly continuation cts executed lead system full basic configuration 
cases depicted full ct consists basic transition 
examples show execution basic ct guarantee system legal configuration 
full ct central concept 
type connector diagram connector 
diagram connectors help reduce clutter arrows chart 
semantically best way view diagram connectors ones label single connector happens appear locations 
acm transactions software engineering methodology vol 
october 
statemate semantics statecharts 
tl 
cv ct nd ev actl act 
transition tl executed ing 
set tl ct full ct source target trigger ev action actl act 
equivalent 
cts tl full cts 
left triggers conditions 
tl initial ct accompanied form full ct transitions tl executed tl subsets ct note ct targets sources 
act sources targets may refer source set target set 
depicts complex situation 
tl executed lead full configuration accompanied 
initial ct tl continuation cts form full cts tl tl ts 
exhibits situations state mate simulation tool behaves differently generated code 
consider case system state ev generated false 
semantics figures identical simulation tool stay notify user reach basic states initial ct enabled 
message serves warn user generated code may behave differently simulation potentially undesired probably unintentional behavior discovered 
generated code execute initial ct reaching discover enter basic states point roll back theoretically feasible generate code roll back stances find efficient way 
issue require research 
initial ct tl accompanied continuation cts order full ct rest article concentrates full cts 
acm software engineering methodology vol 
october 
david harel amnon naamad 

dealing history statecharts feature kinds history connectors 
basic algorithm interpreting history 
suppose executing ct target history connector state 
note graphical syntax statecharts requires connector reside state area state area 
history connector substate system 
treated target 
connector basic configuration relative system treated targets states 
system history erased clear history action tl treated target transitions emanating priority higher emanating default connector example consider tl taken 
system tl treated target state full transition taken tl system target state taken full transition taken 
system previously history cleared acm transactions engineering methodology vol 
october 
statemate semantics statecharts 

ev ev ev ev ctl act ct 
system tl treated target full transition taken tl 
case taken contrast case entered virtue history actions associated executed 
acm transactions software eng neering methodology vol 
october 
david harel naamad 

actions erase history state history clear applies history deep clear effect applies descendant states 
new entrance case deep clear entrance descendent causes new item history information registered subsequent entrances capturing substate presently en tered type clear action taken type history connector cleared 
history state cleared action applies ordinary connector deep history connector 
acm transactions sofware vol 
october 
statemate semantics statecharts complicated situation illustrating priority transitions emanate history connectors 
consider assume system state event generated state history 
execution tl transition gets priority default entrance executed 
false default attempted succeed true 
false appear loop 
statemate detect simulation generated code issue appropriate message 
nice way illustrating fact values elements changed step 
suppose step enter history connector drawn state perform action clears history 
abbreviates history clear 
clear history lacking history enter default substate isa enter history clear history 
answer 
recall entered leave step 
curious effect making redundant subsequent clearing history entrance register history clearing performed 

scope transitions little precise full cts assembled 
full ct really collection transitions linked head tail fashion rules governing different connectors 
result attachments contains internal loop connector connector loop source state back state allowed course compound transition illegal 
maximality requirement attachments implies source full ct contains states connectors target contains basic states termination connectors 
statechart incomplete presumably lacks default arrows 
ct legal states source states target mutually orthogonal source acm software engineering methodology vol 
october david harel amnon naamad hc 
target parts legal basic configurations 
fact target set maximal contains descendant component state contains descendants components 
act said enabled step step system states source set trigger conjunction components triggers true 
mention empty triggers evaluate true 
simple example consider 
step system state events generated previous step tl enabled 
reason trigger true step source state entered step system source state step 
explained earlier event occurs system transition taken step previous occurrence lost 
transition source target ct pass different levels statechart hierarchy 
question arises nonbasic states exited entered process transition 
important reasons set oi actions may called exiting entering states 
example executing tl exit reenter state 
executing exit reenter state 
executing exit reenter state 
answer similar questions introduce concept scope compound transition 
scope ct tr lowest state hierarchy states proper common ancestor sources targets tr including nonbasic states explicit sources targets transition arrows appearing tr 
history connectors targets arrows represented states previous reports related semantics particular document semantics statecharts lowest common ancestor lca scope 
transactions software engineering methodology vol 

october 
statemate semantics statecharts re 
tl 

drawn 
transition tr taken proper descendants scope system resided step exited proper descendants scope system reside result executing tr entered 
scope lowest state system stays exiting transition 
example scope type implies exiting states depending system step entering states 
state exited 
case tl arrow clearly system transition scope step starts 
acm transactions software engineering methodology vol 
october 
david harel amnon naamad 
drawn exiting contour 
parent tl scope 
notion scope depend way arrow drawn sources targets 
scope oft implies exiting states entering states exited 
scope history connector represented implies exiting entering appear somewhat counterintuitive arrow drawn entirely state cause state exited 
way arrow drawn unimportant semantics case result special nature history connectors entered outside state 
full ct scope exits legal configuration relative substate enters legal configuration relative potentially necessarily substate 
conflicting transitions say cts conflict common state exited taken 
example tl conflict imply exiting state conflict oft taken system substates 
follows tl example taken step 
semantics treats kinds conflicts differently 
case triggers tl enabled step system faced nondeterminism reason prefer 
situation different tl enabled step 
priority tl nondeterminism 
currently priorities transi tions determined outside describe priority scheme re versions statemate see appendix tx ty conflicting transitions sx sy scopes respectively 
transitions conflict acm soft 
ware engineering methodology vol 

october 
statemate semantics statecharts 
common state source sets implies scopes orthogonal exclusive 
equal scopes ancestor state hierarchy 
accordingly priority transition scope higher hierarchy 
sx sy tx ty priority occurs 
example scope tl scope scope tl priority higher priority tl 
hand conflict tl 
general nondeterminism occurs conflicting cts priority enabled step conflicting ct higher priority enabled 
case different steps possible lead different statuses 
course steps taken particular run 
various statemate tools deal nondeterminism arises execution 
simulation tool statemate waits possibilities selected 
selection carried interactively user specifying selection criterion start 
dynamic tests tool try different possibilities exhaustive fashion 
code synthesized software code generator select possibility finds enabled proceed execute 
hardware code generated behaves similarly user option asking code detect report nondeterministic situa tions 
say word static reactions srs 
explained earlier enabled static reaction defined state executed system step exited ct step 
context say sr defined state conflict cts exit ancestors 
furthermore occur transitions lead target state resulting states count transitions involve different actions 
acm software engineering methodology vol 
october 
david harel amnon naamad 
cts higher priority srs state exited result ct srs executed 
note exited step srs executed step 

basic step algorithm section schematic description algorithm executes single step 
lies heart dynamic analysis tools statemate 
inputs status system includes list states system currently resides list activities currently active current values conditions data items list events generated internally previous step list scheduled actions time execution list timeout events time occurrence relevant information history states current time see discussion time 
list external changes environment step 
may include example events occurred changes values conditions data items 
comment 
scheduled action appears list pair appeared action expression form sc carried time scheduled executed 
similarly timeout event form tin appears am tr sol ware engineering methodology vol 
october 
statemate semantics statecharts pair time generation timeout event 
output new system status 
algorithm stage step preparation add external events list internally generated events 
execute actions implied external changes 
includes changing values data items conditions activities states 
pair list scheduled actions carry remove list 
pair timeout event list tin generated set current time generate set comments order execution stage important 
timeouts evaluated want guarantee tin occur step occurs 
ii result executing stage system status may change 
potentially includes data items conditions activities new events 
rest algorithm new status 
iii logically equality time comparison cause real life steps take time iv important note delay expression constant evaluated values operands triggering event generated 
sense interpretation tin occurred time units ago viewed operation occurs recorded carried 
stage compute contents step 
stage mark cts srs executed 
compute set enabled cts 
remove set cts conflict enabled acm transactions software engineering nd methodology vol 
october 
david harel amnon naamad ct higher priority 
split set enabled cts maximal nonconflicting sets 
comment set cts nonconflicting cts set conflict 
maximal means enabled ct included set conflict ct included set 
example nonconflicting sets 
set cts compute set enabled srs defined states currently active exited cts set 
enabled cts srs step empty stage resulted single set set constitutes step stage produced set nondeterminism sets chosen step 
comment simulation tool informs user nondeterminism detected select set executed 
generated code select set arbitrarily specific request issue message nondeterminism encountered 
stage execute cts srs 
en set enabled cts srs computed stage 
sr en execute action associated 
ct en sx sn sets states exited entered respectively update history parents states sx delete states sx list states system resides execute actions associated exiting states sx execute actions execute actions associated entering states sn add list states system resides states sn 
notes comments contains example nonconflicting sets see item stage algorithm 
various sr denote static reactions associated corresponding states 
assume system configuration represented shaded basic states transitions static reactions enabled 
higher priority tl higher priority transitions right hand component priority 
left hand component taken implies srl carried step sr 
middle component taken sr carried right hand component transitions taken sr carried 
compactly maximal acm transactions sofware vol october 
semantics statecharts st sr ing sets follows means steps taken srl sr sr srl sr sr st st st srl sr sr srl sr sr srl st st ii order implement semantics step assignments carried stages 
creates list pairs form element new value 
pair specifies element assigned new value step 
guarantees execution step old values elements system insensitive possible order actions executed 
example semantics specify order cts srs executed stage specify order actions ct sr executed 
stage completed actions executing current step second stage starts elements assigned new values 
element assigned new value step assignment counts 
cases refer write write racing order action execution affect results step 
statemate simulation dynamic tests tools able detect cases 
section discuss racing detection detail 
iii actions performed activities may cause chain reactions 
activity stopped suspended stopped suspended 
activity endowed controlling statechart default rules started started acm software vol 
october 
david harel amnon naamad 
iv vi stopped parent activity stopped 
reactions executed step 
activity control activate step activated 
events generated step collected new list generated events inputs step 
current list events containing generated previous step step evaluate actions form event action scheduled scheduled action expression form sc executed stage 
added list scheduled actions pair current time 
termination connector treated basic state parent state drawn 
entering termination connector steps executed 
example event occurs termination connector entered steps executed occurs 
statechart question serves control activity activity execution enters termination connector activity stopped step event sp generated 

models time far discussed semantics single step issues involving sequences steps 
particularly important issue time relationship steps internal clock advanced relative execution steps long steps take terms clock 
statemate supports models timing synchronous asynchronous 
synchronous time model assumes system executes single step time unit reacting external changes occur time unit elapsed completion previous step 
asynchronous time model assumes system reacts acm engineering methodology vol 
october 
statemate semantics statecharts external change occurs allowing external changes occur simultaneously importantly allowing steps take place single point time 
collection steps called superstep 
models execution step may viewed zero time far environment concerned execution step external changes effect time stops duration execution 
basic algorithm step previous section implemented statemate simulation dynamic tests tools various code generators executes step somewhat different circumstances way models time reflected execution differs slightly 
shall concentrate way time treated simulation tool briefly discuss treatment tools 
synchronous time model fits systems highly synchronous 
assuming previous step executed time issuing go command statemate simulation works follows execute external changes reported completion previous step increment clock time unit execute timeout events scheduled actions due time falls inside interval excludes includes execute step 
asynchronous time model call greedy model fits kinds asynchronous systems 
time model execu tion steps advance internal time simulation simulator operator environment explicitly 
different go commands user control advance time simulation 
important go command go repeat works follows execute external changes reported completion previous step execute timeout events scheduled actions time due including current time repeatedly execute step system stable state generated events enabled cts srs 
note go repeat increment internal clock steps may executed point time 
repeat loop description superstep series steps executed course single go repeat command point time external changes occurring constituent steps 
go repeat command may result infinite loop 
suspected infinite loops detected simulation tool 
example consider assume conditions false event generated environment 
go repeat com mand cause steps executed acm set ware engineering vol october 
david harel amnon naamad tl tr cl tr va 
transition tl taken leading basic configuration making true generating transitions taken leading basic configuration making true transition taken leading basic configuration making true 
note taken event alive step step longer exists 
taken leading basic configuration go advance command designed conjunction go repeat advance clock 
doing pay debts due time planned advance 
suppose current time command go advance advance time happens execute external changes reported completion previous step sett repeat execute timeout events scheduled actions time due including current time execute go repeat set time closest scheduled action timeout event set smaller 
go repeat go advance commands suffice implement greedy asynchronous time model 
additional go commands life little easier go step executes step advancing time 
com mand enables easier debugging model 
acm sofware engineering methodology vol 
october 
statemate semantics statecharts go advances clock time timeout event scheduled action carrying step 
time advanced steps executed executed 
go extended combination go go repeat intended execute superstep really 
works follows execute external changes reported completion previous step generated events enabled cts srs execute superstep advance clock time timeout event scheduled action execute scheduled actions timeout events time due execute superstep 
completes discussion treatment time simulation tool statemate 
dynamic tests tool external changes sensed fixed period time time models user option injecting external changes steps superstep 
statemate hardware code generators user select code styles compatible different time model 
rtl code style means generation vhdl verilog code mechanism determines step execute sensitive event rising falling edge clock 
similar statemate synchronous mode 
hand hdl code generated behavioral code style reacts change inputs moment occur 
identical statemate asynchronous mode 
software code generators generate style code different schedulers provided support different time models 
uses cpu dock time 
effect steps supersteps take zero time 
simulation external changes sensed start step 
steps take zero time external changes timeout events scheduled actions may occur system stabilized 
words synchrony hypothesis see berry gonthier shalev preserved 
means cpu clock time model equivalent statemate simulator go re peat supported 
scheduler uses simulated clock 
simulated clock advances system stable status 
external changes timeout events scheduled actions occur system stable 
simulated clock time model guarantees behavior identical statemate asynchronous mode 
acm transactions soft 
ware engineering methodology vol 
nu 
october 
david harel amnon naamad 

racing conditions racing conditions arise value element modified modified single point time 
approach greedy model multiple steps executed appears point time racing problems arise step transitions actions executed different steps 
racing checked supersteps single steps take account causality dependencies transitions carried different steps single superstep 
example suppose transition labeled executed enabling transition superstep labeled step modified point time racing problem second transition necessarily comes 
steps superstep executed zero lime considered executed order 
little precise racing defined 
step superstep transitions may enabled 
enabled transitions viewed executing implementation sensitive order 
order consistent enabling order sense transition executed ones enabled 
race situation executed enabled transitions different order legal criteria obtained different results data items condi tions 

event occurs semantics prescribes transition 
taken step second step tb lrd step 
attain value second step attain third step 
notice acm transaction soc engineering methodology 
vol 
october 
statemate semantics statecharts 
constraints ordering transitions tl come come 
greediness semantics causes taken step 
wrong semantics postpone taken consecutive steps may result different value cases cause statemate report racing condition 

multiple statecharts semantics described applies aspects statecharts running simultaneously statemate occurs represent activities happen active concurrently 
multiple active statecharts treated basically orthogonal compo nents highest level single statechart statecharts nonactive entering termination connector activity controls stopped charts continue active 
activity statechart controlling reactivated default configuration 
consider example charts 
treated essentially single chart 
notice entering termination connector original chart just entering special idle state corresponding orthogonal component new chart 
special start events leading idle states depict events cause original statechart start started activity activity controlled statechart question 
asynchronous time model steps multiple statecharts carried synchronization just represented orthogonal components big statechart 
really happening greediness property applies system level meaning enabled transitions single chart executed simultaneously charts transitions entire system executed simultaneously 
synchronous time model hand chart may clock telling execute step 
may acm methodology vol 
october 
david harel amnon naamad 

specified different time unit different clock rate happening chart orthogonal components remain synchronized chart synchronized clock necessarily charts 
time models time units evaluating time expressions timeout events scheduled actions may defined differently chart 
example actions schedule schedule executed step statecharts respectively actions carried time time units evaluation defined differently 
appendix comparison appendix devoted issues regarding comparison seman tics proposed semantics statecharts 
mentioned fundamental question changes occur step generated events value updates take effect current step 
semantics adopts contrast semantics harel pnueli shalev 
shall say papers 
natural candidate comparison rsml language leveson various reasons 
comments leveson prompted publish article second case semantics leveson claimed supported tool third despite difference years conception semantics underlying acm ware nd methodology vol 
october 
statemate semantics statecharts principles similar fact changes take place step 
main differences approaches syntactical 
example rsml support history connector features directed communication channels broadcast communication lows tables entering condition expressions support disjunctions trigger events 
appear significant differences dynamic semantics different terms 
steps rsml microsteps supersteps rsml steps 
step basic atomic operation superstep statemate users compose commands simulator option generated code 
description leveson appears step superstep basic atomic operation 
reasons somewhat difficult talk precisely semantics rsml issues discuss length ignored leveson cts built legal configurations turn survey von der beek 
lists issues relevant proposals semantics statecharts 
imple mented semantics statecharts described article precursor mentioned yon der beek issues yon der beak catalog published semantics feel best thing comment approach deals issues 
list issues number title similar von der beek give sentence explanation thereof adapted phrasing yon der beek followed short discussion way language semantics relates 
leave reader task consulting yon der beek detailed explanation motivation issues 
mention questions features language supports note approaches surveyed yon der beek varying syntax ii semantic aspects relevant supersteps 

perfect synchrony 
perfect synchrony hypothesis external events immediately 
statemate semantics supports time models asynchronous synchronous 
asynchronous model system reacts zero time instant external change 
system reaction stretched steps event triggering steps execute zero time 
time model perfect synchrony hypothesis holds 
synchronous time model system reacts detects occurrence special event usually edge clock cycle 
referred yon der beek problems way statecharts described 
acm sofware engineering methodology vol 

david harel amnon naamad possible nonzero time passes instant external event occurs time system reacts 
model reaction requires steps step executes special event sensed 
time takes react depends number steps needed complete system reaction hypoth hold 

self triggering causality 
self triggering involves events executed actions ot caused external event causality means transition taken caused indirectly external event 
really issue semantics internal events sensed step generated 
trivial sense say statemate respects causality 

negated trigger event 
negated event models ordinary event 
approach supports negated trigger events allowed syntax covered semantics 
statemate simulator sup ports full 
code generator experience shows virtually users employing negated events ed positive events 
reason code generator set default mode supports negated trigger events ed positive events 
example supported supported supported 
execution generated code 
scheduler available user supports general negated trigger events 

effect transition executing contradictory cause 
example event triggering action essentially negation 
issue approach effect trigger event sensed step 
particular statemate problem transition labeled 
transition 
transition crossing states 
statemate supports transitions full 

state 
ability refer states orthogonal component deciding transition taken 
statemate supports full 
cases main output statechart set states 
hardware language code generators support adding states output ports 

compositional semantics self termination 
compositional semantics defines meaning construct meanings constituent constructs self termination von der beek means stratified transitions replace ones aid making semantics compositional 
acm software engineering methodology 
vol 
october 
statemate semantics statecharts semantics defined compositional manner 
fact syntax allows transitions 

operational versus denotational semantics 
semantics oper 

instantaneous state 
state entered exited simul action generated entrance causes state exited 
semantics instantaneous states prohibited step 
assertion yon der beek effect implies instant time transitions may executed reside parallel components inaccurate asynchronous time model steps may execute instant time 

durability events 
issue concerns question event available instant time 
semantics event sensed step generated 
multiple steps execute instance time event generated step sensed step 

parallel execution transitions 
issue concerns question transitions allowed execute simultaneously reside different orthogonal components 
approach transitions scopes mutually orthogonal execute step 

transition refinement 
issue concerns difference single transition refinement sequence transitions top development process example take longer 
asynchronous time model semantics problem steps may execute instance time refinement equivalent refined transition 
synchronous time model difference exist 

multiple entering exiting instantaneous state 
concerns possibility infinite loop caused repeated entering exiting instantaneous state 
step semantics issue instantaneous states supported see issue number 
happen superstep 

infinite sequence transition executions ln tant time 
similar number 

determinism 
concerned statechart behavior exhibit nondeterministic choices 
model nondeterministic behavior statecharts 
state mate code generators treat underspecification don care distinction user 
acm transactions engineering arid methodology vol 
october 
david harel amnon naamad 
priorities transition execution 
feature provides way model determine transition set conflicting transitions exhibits nondeterminism executed 
current versions statemate priorities transitions determined scope transition 
priority scheme implemented versions statemate transition source described appendix 
versus nonpreemptive interrupt 
preemptive interrupt high level transition prevents transitions lower levels 
statemate supports interrupts priorities higher level transitions 
priority concept relevant issue insensitive difference new old versions priorities statemate discussed appendix 

distinguishing internal external events 
concerns question difference sensing internal versus hal events microsteps macrostep relevance possibility satisfying synchrony hypothesis 
semantics internal events sensed superstep externally generated ones 

time specification timeout event timed transition 
con cern issue time progresses support timeout events timed transitions transitions bounded time 
semantics time advance system stable status meaning transitions execute occurrence external event 
statecharts support timeout events timed transitions 
column semantics table yon der beek read follows combinational assignments combinational assignments cas supported sofware hardware versions statemate 
associated states transitions activities entire chart 
viewed continuous implementation function function computed automatically immediately change parameters 
syntax ca similar regular kind assignment may contain clauses 
appendix concentrates specifying cas exe 
ca executed immediately change operands assigned expression right hand side assign acm software engineering methodology vol 
october 
statemate semantics statecharts ment 
put way step operand changed externally internally relevant cas executed 
models contain cas step algorithm section modified stage new stage carried cas executed 
done phases phase cas operands changed executed 
right hand side expressions participating cas evaluated assignments carried simultaneously way element changed ca phase operand ca new value available phase 
loops cas legal implies possibility infinite loops 
example consider cas stabilize 
error specification statemate analysis tools detect infinite loop run time 
element changes value times step original value phases executing cas value changed particular event changed abbreviated ch generated 
example consider cas suppose step values 
suppose hat execution transition changed changed 
values elements modified follows phase phase returns old value 
event ch generated 
semantics implemented statemate tools exception 
generating code hardware vhdl verilog decided implement statemate cas cas target hardware language 
generating hardware code user choice generating behavioral style code rtl style register transfer level code 
purposes behavioral style asynchronous rti style synchronous 
difference phase execution cas takes delta hardware description languages step takes time 
rtl style deltas added execution real step clock signal arrives phases cas arc executed part step 
hand behavioral style transitions execute moment acm transactions vn software engineering methodology vol 
october 
david harel amnon naamad 
enabled 
find elegant way postpone transition execution cas completed behavioral style cas carried step transitions follow step changed operands 
transition changes value ca ofthe form ifx changes value step change value step transition taken 
priori transitions aspects relevant determination priority transitions statemate 
structural priority sp compound transition priority numbers pn associated transition segments 
structural priority main criterion determining priority transition 
transition tl higher sp tl priority higher 
sp defined initial cts 
determined particular state associated ct call structural priority determinant 
higher determinant ct hierarchy states higher sp 
determinant ct determined sources targets 
current versions statemate determinant initial ct tr defined scope 
recall scope tr lowest state hierarchy states proper ancestor sources targets tr 
versions statemate determinant primarily explicit source tr 
source set tr denoted scope structural priority determinant tr defined follows st state st proper descendant set states proper ancestors st proper descendants may empty states singleton determinant tr st determinant highest level state consider example 
current versions statemate acm software vol 
october 
statemate semantics statecharts 
give tl priority higher versions give tl priority lower 
determinant highest level state exited tl determinant tl source tl higher priority versions 
reason determinant oft tl conflict executed step 
leave determinant oft way specify higher priority 
addition orthogonal components state longer truly orthogonal examine happening inside 
importantly generated code inefficient 
note definition suffices transitions identical mutually conflict higher determinant ct state hierarchy higher sp 
main reason change definition priority new intuitive preferred statemate users 
new definition endow transi tion higher sp changing meaning 
example tl equivalent current semantics new semantics gives higher priority behavior 
priority number pn integer affix transition segments 
priority transition segment compared priorities segments source state connector priority determinant 
letx compound transition composed transition segments 
xn order 
xi source acm tran ware mc 

vol 


october 
david harel amnon naamad 
target 
similarly ct composed ym order 
suppose structural priority determinants compare priorities pns 
comparison procedure yi doi index different pair segments pn xi pn yi return higher priority pn xi return higher priority return priority example consider priority numbers parenthesized 
ct leading state higher priority cts leading priority cts leading 
table summarizes priority relationships cts represented target states interestingly priority relationship define transitive 
example pairs equal priorities greater ts 
pose problem transitions determinant enabled priority maximal candidates execution 
words ct enabled ct greater priority candidate acm software engineering vol 
october 
statemate semantics statecharts 
execution 
transitions enabled possible steps leading 
ct contains segments connected joint fork connectors possible arrange linear order target source 
cases view combination segments incident connector incoming outgoing single virtual segment 
properties virtual segment defined constituent actual virtual segments follows priority maximum constituent segments source set consists sources constituent segments excluding fork joint connector target set consists targets constituent segments excluding fork joint connector 
necessary definition carried recursively fork joint connectors removed 
actual virtual segments linearly ordered 
ct depicted example regarded having segments consisting consisting oft consisting oft 
acknowledgments basic concepts semantics described developed lengthy sessions deliberations group people included amir pnueli michal schmidt rivi sherman 
article possible 
wish members statemate development team contributed updating revision semantics years 
include cohen gory mark 
special acm transactions software en neering methodology vol 
october 
david harel amnon naamad 
amir pnueli jim armstrong philip brookes nick paul urban reviewers comments previous version 
berry gonthier 
esterel synchronous programming language de sign semantics implementation 
sci 
cornput 
program 

il 
statecharts visual formalism complex systems 
sci 
cornput 
program 

preliminary version available tech 
rep cs weizmann inst 
science rehovot israel 
feb 
ue 
development reactive systems 
logics models concurrent sys tems apt ed 
nato asi series vol 

springer verlag new york 
harel 
modeling reactive systems statecharts state 
mate approach 
published 
preliminary version available tech 
rep logix mass titled languages statemate 
harel naamad pnueli ing ot 
statemate working environment develop ment complex reactive systems 
ieee trans 
softw 
eng 

preliminary version appeared proceedings loth international conference engineer ing 
ieee press new york pp 

scripts 
formal semantics statecharts 
proceedings nd ieee symposium logic computer science 
ieee press new york 

design choices semantics statecharts 
inf 
process lett 

gr 
modeling statecharts behavior fully way 
proceedings trees algebra programming 
lecture notes computer science vol 

springer verlag new york 
en nd 
timed hybrid statecharts textual formal techniques real time fault tolerant systems ed 
lecture notes computer science vol 

springer verlag berlin 
lv hmr org il ap rse 
specification process control systems 
ieee trans 
softw 
eng 


operational semantics asynchronous automaton compositions 
proceedings concur 
lecture notes computer science vol 

springer verlag berlin 
acm transaction software methodology vol 
october 
statemate semantics statecharts ano sha 
step semantics statecharts 
proceedings symposium theoretical aspects computer software 
lecture notes computer science vol 

springer verlag berlin 
yon der beek 
comparison statechart variants 
formal techniques real time fault 
tolerant systems de roever eds 
lecture notes computer science vol 

springer verlag new york 
received november revised february accepted july acm transactions software engineering methodology vol 
october 
