observable sequentiality full abstraction robert cartwright matthias felleisen department computer science rice university houston tx major challenges denotational semantics construction fully models sequential programming languages 
past fifteen years research problem focused developing models pcf idealized functional programming language typed lambda calculus 
practical languages pcf facilities observing exploiting evaluation order arguments procedures 
believe facilities crucial understanding nature sequential computation focuses sequential extension pcf called spcf includes classes control operators error generators escape handlers 
new control operators enable construct fully model spcf interprets higher types sets error sensitive functions continuous functions 
error sensitive functions form scott domain isomorphic domain decision trees 
believe construction yield fully models functional languages different control operators observing order evaluation 
full abstraction sequentiality denotational semantics programming language determines natural equivalence relations program phrases 
relation denotational equivalence equates phrases denote element model 
second relation observational equivalence equates phrases observable behavior 
denotational framework observable behavior refers concrete output produced entire programs 
phrases observationally equivalent authors supported part nsf ccr darpa nsf ccr 
appear th popl january albuquerque nm interchanged arbitrary program affecting output 
equivalence relations different general 
denotational equivalence implies observational equivalence denotational models compositional 
converse rarely holds conventional models practical programming languages observationally equivalent phrases inevitably different meanings 
semantics denotational equivalence observational equivalence coincide said fully 
observational equivalence fundamental constraint governing program optimization 
users program primarily interested input output behavior compiler optimize program interchanging observationally equivalent phrases 
denotational semantics fully observational equivalence reduces denotational equivalence analyzed traditional mathematical tools 
consequently primary goals research denotational semantics construction fully models practical languages 
example shows models conventional continuous function spaces typically fully sequential languages 
consider family procedures defined sequential call name functional language false omega false omega gamma omega true true omega equation omega denotes divergent expression denotes arbitrary natural number 
easy show exhaustive case analysis procedures diverge inputs possible inputs sequential procedures 
observationally equivalent procedure defined omega gamma hand conventional model language includes functions evaluate arguments parallel 
simple example parallel func term procedure function refer primitive operators functional procedures necessarily interpreted functions models 
tion parallel returns false input false returns true inputs true 
apply conventional meaning parallel computation produces answer divergent subcomputations ignored parallel consequently conventional model functional languages fails identify essentially example constructed practical deterministic programming language procedures passed parameters 
example call value languages procedures rewritten parameter takes constant procedures arguments uses procedures simulate call name boolean arguments 
commonly deterministic languages sequential 
informal terms language sequential implemented multiple threads control 
practical languages eschew parallel operations parallel painful implement encourage inefficient programming 
deterministic languages parallel machines sequential 
summary previous milner plotkin researchers study full abstraction problem sequential languages 
focused constructing fully models pcf call name functional language typed calculus 
example shows continuous function model pcf fully 
milner plotkin developed different strategies eliminating discrepancy continuous function model observable behavior pcf 
milner eliminated parallel functions model constructing syntactic model elements equivalence classes observationally equivalent terms 
milner model fully generally regarded denotational model identify mathematical structure program denotations operational semantics 
plotkin extended pcf adding parallel deterministic operations eliminating discrepancy continuous function model procedures definable language 
unfortunately milner plotkin result showed construct fully denotational models sequential languages 
effort understand semantics sequential languages berry curien constructed models pcf restrictive domains procedure denotations 
berry eliminated parallel functions domain procedure denotations forcing functions stable 
construction eliminated spurious distinctions phrases conventional model introduced new ones 
address problem berry curien imposed restrictions space procedure denotations interpreting procedures sequential algorithms concrete domains 
sequential algorithm function plus strategy evaluating arguments 
approach eliminates parallel functions resulting model extensional contains different procedure denotations exactly behavior application 
addition pcf express observations characterize sequential algorithms order argument evaluation 
result sequential algorithm model pcf fully 
mulmuley generalized milner showing construct fully model pcf quotient conventional model lattices cpos 
mulmuley defined retraction conventional model equates parallel functions overdefined element top 
milner original fully model mulmuley model syntactic flavor construction relies syntactic notion observational equivalence 
details history full abstraction problem sequential languages refer reader extensive surveys 
summary results fifteen years milner plotkin original fundamental question remains fully denotational models sequential programming languages 
answer question affirmatively showing construct fully denotational models observably sequential functional programming language simple sequential extension pcf 
construction relies closely related insights 
practical languages programmer observe order procedure evaluates arguments generating run time errors 
similarly languages permit programs determine exploit evaluation order subexpressions explicit control operators exception handlers 

continuous functions identified decision trees constructed composing error sensitive operations 
informal terms operation error sensitive propagates errors encounters evaluating arguments 
remainder organized follows 
presenting syntax informal semantics observation due meyer mit personal communication august pcf section compare pcf realistic functional languages section 
practical versions functional languages pcf lacks control operators generating errors performing non local exits impossible observe order procedures evaluate arguments 
extend pcf include facilities construct fully model identifying error sensitive functions decision trees 
define model section show extensional 
section sketch proof full abstraction theorem 
section show extension pcf sequential formulate notions error sensitivity observable sequentiality 
due space limitations sketches construction model proof full abstraction theorem 
refer interested reader extended version 
pcf pcf simple functional language typed calculus numerals increment decrement procedures numerals conditionals family fixedpoint combinators 
collection types consists single ground type denoting set non negative integers procedure types oe denoting sets higher order procedures constructed simpler types oe 
set types formally defined recursive rule rule equivalent shows procedures interpreted maps ary tuples ground results 
second view emphasizes fact procedures fixed arity 
set pcf terms consists numerals procedural constants typed variables oe abstractions term oe oe oe 
oe 
oe add sub oe oe oe pcf programs closed pcf terms ground type 
syntactic context term holes place subexpressions 
term result filling holes possibly capturing free variables process 
models pcf numerals denote numbers abstractions denote call name procedures denote procedure applications procedural constants add sub usual meanings 
procedures add sub respectively add subtract integer inputs diverges 
procedure evaluates argument result evaluates second argument returns evaluates third argument returns 
combinator computes fixed points procedures appropriate type 
pcf program text constant omega gamma abbreviates term prototypical divergent expression 
equations define different versions binary addition procedure pcf xy add sub xy add sub examples subsequent discussions 
define denotational model pcf functional language typed calculus define family domains family meaning functions domain consists denotations closed terms type gamma 
meaning function maps set closed terms type meaning 
contains conventional function model pcf interprets type oe set continuous functions type oe type denotational model language define notion observational equivalence full abstraction follows 
definition 
denotational equivalence observational equivalence full abstraction closed expressions denotationally equivalent model written jm iff 
observationally equivalent written iff integer contexts programs 
model fully iff implies jm closed 
observational equivalence depends meanings complete programs 
independent choice model long models agree meanings complete programs 
standard denotational model pcf fully domain continuous functions includes parallel functions parallel pcf define sequential functions 
denotational semantics determined define means language sequential 
definition 
sequentiality sequential iff condition holds 
expressions program omega omega gamma omega gamma 
exists gamma omega omega gamma domains 
oe gamma 
oe meaning functions cl cl cl cl cl apply cl cl cl cl apply free apply apply apply apply add sub ff 
ng add 
sub sub 
continuous function space model pcf straightforward prove pcf sequential activity lemma 
observing sequentiality pcf omits features essential practical languages 
glaring omissions lack provision generating run time errors performing non local exits 
design choice simplifies definition language thwarted efforts construct fully models pcf similar sequential languages 
paragraphs explain addition simple control mechanisms pcf important perspective language designer presence programming language affects construction denotational model 
errors programmers observe order evaluation 
obvious omission pcf provision computations generate errors 
practical implementation pcf signal error application procedure sub invalid input 
behavior inconsistent semantics pcf requires sub diverge far informative programmer point view 
permits programmers observe order evaluation programs conducting simple experiments 
provide pcf error generators add constants error error ground type language force procedures extended language error sensitive 
operation error sensitive propagates errors encounters evaluating arguments 
pcf errors programmer observe evaluation order subexpressions exploiting error sensitivity program operations 
pair subexpressions programmer replace distinct error value observe behavior modified program 
subexpression evaluation original program modified program returns error value corresponding subexpression evaluated 
result programmer distinguish distinct versions commutative procedures addition procedures defined section 
expression error error produces error evaluates left argument error error returns error evaluates right argument 
error handlers programs observe order evaluation 
pcf errors sequential behavior procedures observable externally programmer information accessible internally programs 
consequently program determine order evaluation arguments procedure application 
express computations program able delimit dynamic extent control actions generating errors 
reason practical languages include error handling facility non local control operator 
original version scheme example contained lexically scoped catch construct implementing non local exits expressions 
evaluation expression catch add return popping control stack back lexical binding catch encountering sub expression 
catch construct possible write program determines order evaluation procedure arguments procedure catch maps 
add capability pcf introduce family catch procedures types procedure type catch returns gamma evaluates th argument constant procedure result alternatively catch gamma omega omega gamma error omega omega gammai returns error 
pcf catch procedure expressive power scheme downward catch construct catch procedure simpler semantic definition better suited proving representability lemma see section 
designate sequential extension pcf name spcf 
definition 
spcf spcf pcf constants error error type catch procedures type procedure denotations contain computational structure ordinary function graphs 
conventional models languages spcf written continuation passing style cope behavior control operators 
form model contains parallel functions fully sequential languages 
construct fully model spcf need develop new form model excludes parallel functions 
informal operational semantics spcf particularly catch operator suggests procedure denotations internal structure function graphs 
particular explicate order arguments evaluated 
consider procedure gamma type 


means view procedure mapping quadruples integers integers 
procedure evaluates second argument subsequent evaluation order depends value evaluates third argument evaluates fourth argument capture information define denotation index paired function maps value second argument appropriate information 
rest denotation described manner argument maps third argument skips argument decreases value fourth argument 
error 
error error 
error 

error 
error error 
error 



error 
error error 
error 



continuous error sensitive map error error rotate object view decision tree gamma gamma gammar gamma gamma gammar node represents query th argument clarity henceforth represent argument index pair hi decision trees 
branches node labeled possible values th argument 
target node branch specifies happens 
simple integer error completed computation continues query argument 
omitted branches map error error avoid cluttering decision trees implied information 
higher order procedures explore trees sequentially 
deciding procedures denote decision trees natural ask higher order procedures process procedural inputs 
trees resemble lisp expressions visualize higher order procedures processes examine decision trees essentially manner lisp procedures traverse expressions 
simplify notation express queries patterns match paths decision trees 
specifically query rooted finite path nodes edges decision tree terminated marker 
marker identifies node procedure wants inspect 
answer produced query information stored specified node 
match yields error result entire process error lisp procedure higher order procedure inspect node input tree inspecting predecessors 
illustrate process examine behavior procedure add omega error tree representing applied argument tree knows value needs know behaves certain arguments asks question determine root value procedure described response question contents root knows demands information second argument 
find provide information requested 
information determines subtree wants inspect 
information specified extending previous response edge matching pattern yields node value query third argument 
passes value third argument consequently query form matching pattern yields leaf value final answer subcomputation omega error complete proceed add result calling yielding final answer 
preceding query response protocol represented tree nodes labeled queries arcs labeled possible answers 
shows part denotation including path just discussed 
includes paths describe interacts procedure arguments immediately demand value fourth argument case returns case signals error branches tree denoting omitted 
procedures represented trees easy see higher order procedures extract apparently intensional information procedural arguments 
example tree represents procedure maps unary constant procedures strict procedures gamma gamma gammar pr similarly catch procedure extracts information evaluation order argument 
information intensional distinct trees represent distinct continous functions 
presence error values ground domain combined convention procedures error sensitive evaluation information extensional 
section prove correspondence graphs observably sequential functions tree representations 
decision trees simply identify mathematical structure functions 
tree model model spcf essentially form model pcf 
consists family scott domains family meaning functions model spcf domains consisting decision trees described previous section 
meaning function map closed spcf terms trees appropriate domain 
define meaning functions rely extensions translation abstraction algorithms delta cl pcf see 
interpret combinators produced translation decision trees function berry curien proposed representing procedures trees concrete sequential algorithms 
domains include error elements associate distinct trees function 
example denote distinct concrete sequential algorithms denote function 
framework evaluation information intensional 
berry curien noted sequential algorithms distinguish different algorithms function 
connection intensional procedures control operators catch 
discussions curien revealed surprising relationship berry curien model pcf model spcf 
restrict model operators pcf project error values model isomorphic theirs curien ens personal communication may 
df gamma gamma gamma df gamma gamma gamma pr error ir gamma gamma gammar fragment procedure apply oe 
theta oe gamma 
converts decision trees functions 
subsection define tree domains 
define apply functions prove tree representation extensional procedural trees identical precisely distinguished apply 
third fourth subsection assign interpretations procedural constants combinators associated spcf prove basic equational properties tree model 
domains scott domain ideal completion finitary basis 
finitary basis countable partially ordered set finite bounded subset upper bound principal ideals corresponding elements finite elements domain determined set ideals 
construction domain consistently complete algebraic cpo 
discussing domains convenient ignore distinction elements finitary basis corresponding principal ideals 
definition domains procedure types relies notion legal queries responses arguments 
domain define set queries higher type objects ask elements type set proper responses queries 
behavior error sensitive functions answers error error predetermined include answers set proper responses appear tree representations 
precise definition oe subtle 
start giving preliminary definition contains elements 
refine definition achieve correspondence decision trees observably sequential functions 
definition set domains type proceeds induction structure procedure domains expansion type map arbitrary tuples ground types refer possible argument indices 
type expressions observable type denote natural number diverging computation error value error error approximation ordering usual approximates elements rest elements mutually incomparable 
possible query argument type initial query response completely determines element 
proper responses query integers 
consequently define set ground queries proper responses follows type finite higher order objects finite decision trees 
path tree finite leaves elements addition finitely branches nonterminal node 
inductively define set finite elements follows 
finite tree type 
leaf 
triple hi fi consisting index query type th argument branching function maps proper responses finite trees 
finite set proper responses called proper domain function produce value 
pictures represent tree hi fi node labeled hi qi outgoing edge labeled elements ae fhi fi ik ae 
ae fhi rig fr finiteg paths ae ae fhi hr pii ae ae fhi rig queries ae legal queries ae ae ae fq ae ae rg ae hi qi fhi hr ii hi hr ii fhi hr ii responses ae fhi ik ae legal responses fr hi elements queries responses response proper domain edge attached subtree 
type tentatively define set queries responses follows 
queries responses type designate paths trees type exactly concrete representation finite trees exceptions 
domains branching functions queries responses contain element 
second degenerate query denoted special marker final branching function query map response 
path denote branching function maps response path pair hr pi 
similarly denote undefined branching function may occur response 
marker query identifies node value query seeking 
replacing marker query final answer intermediate answer hi yields response query notation denotes response obtained replacing tree node response type finite tree query type element replace define 
sake brevity notation abbreviate triple hi pair hi qi 
similarly pictures represent response labeling edge answer replaces corresponding query entire response 
unfortunately preliminary definitions broad constitute extensional representation error sensitive functions 
sources imprecision 
definition permits duplicate queries trees implying different trees represent function 
second definition trees require procedure inspect predecessors node argument tree inspecting definition guarantee responses query appropriate 
solve problems maintaining environment accumulates responses appear path root procedure tree node 
refer environment tree context node 
term context place tree context ambiguous 
technically context relation mapping argument indices responses set valued function 
context contains knowledge procedure gathered arguments point computation 
precisely context ae node procedure ae finite approximation argument type known node computation 
context node determine set queries argument legal node query index extend approximation tree ae ith argument exactly node identified query restriction queries guarantees queries duplicated 
guarantees predecessors node argument tree inspected inspected 
formalize set legal queries defining function maps set prior responses particular index legal set queries definition 
definition auxiliary function maps legal response set queries extending response branch hr legal answer query set empty response terminates final answer query 
pictorially gammar gammar hi qi gammar gammar hi qi contains formal definition problem address definition legal responses query question easy response legal iff node appear point specified selected argument tree 
test reduces confirming response formed tree 
arguments trees lower type reduction circular 
preceding analysis finalize definition finite elements procedure types 
parameterize definition sets contexts ae demand subtrees shape hi fi satisfy conditions 
ae 

ae fhi rig 
fr finite 
inductive definition summarized set equations 
set ae contains subtrees appropriate tree context ae 
domain finite elements subtrees exits empty context 
approximation order domain expected 
trees prefix definition 
approximation ae context subtrees ae 


hi fi hi gi 
finishes formal definition finite elements family domains tedious straightforward prove functions defined finitary basis 
ideal completion process adds infinite trees finite elements domain application function apply oe 
theta oe gamma 
interprets decision trees functions 
subtree procedural tree entire argument tree produces subtree appropriate context 
specifically inputs oe 
oe apply defined case analysis 
constant apply ignores value returns value 
tree form apply performs pattern match specified query argument proper responses apply selects appropriate branch branching function continues process constructing output tree 
improper answers error error mapped error error respectively 

tree form hi apply constructs new decision tree type form hi constructed recursively processing subtree response contains formal definition function apply including definition auxiliary function match 
match function compares query element returns response replacing contents node matches matched node error value bottom match returns node value response 
easy show apply match welldefined apply uses match arguments defined apply returns subtree stipulated type tree context 
function apply determines approximable mapping finite decision trees 
consequently extend apply continuous function arbitrary elements 
importantly prove model curien ens personal communication august pointed order extensionality theorem hold model contains error value 
example functions error incomparable apply apply error 
hand model single error value extensional 
conjecture model fully 
brookes cmu personal communication october suggested modified approximation apply apply fi ae apply match apply hi fi hi apply match match hi fi hi qi match hi hr ii hi fi ae hi hr ii match application tree model definition 
order extensionality language conforming syntax typed lambda calculus constants 
model interpreting order extensional iff oe apply apply implies theorem tree model spcf 
proof 
assume apply apply recall ff vf finite fg vg finite exists finite finite true lemma exists finite apply apply apply gg apply apply finiteness apply 
apply monotonic apply apply contradicts assumption 
extensionality arbitrary decision trees reduces extensionality finite decision trees 
lemma finite elements oe finite apply apply proof idea 
proof proceeds induction depth tree induction step case analysis possible differences corresponding nodes error elements domain play crucial role proof 
identical node different queries argument construct input places error position specified error position specified extensionality theorem implies domain oe isomorphic domain functions oe defined follows 
definition 
oe oe fun denote function apply 
domain oe set oe pointwise ordering functions iff corollary oe isomorphic oe ordering successive nodes behaviorally indistinguishable collapse 
ordering model single error order extensional cost making ordering ineffective 
assigning meaning terms assign meaning phrases spcf translate programs sublanguage abstractions combinators translation conventional abstraction algorithm see apply add sub catch error conversion suffices interpret primitive functions combinators 
contains pictorial formal definitions primitive combinators 
definition combinators tedious 
explain general idea defining denotation recall typed setting supposed represent abstraction oe xn begins evaluation process probing argument returns constant answer returns answer final answer 
responds query th argument directs query ignoring answer query information needs know 
obtaining response probes new query extends response additional information provided response subjected case analysis 
formalize process defining chain finite approximations encode recursive process kn kn hi pi hi fii kn hi hr ii limit approximations fh kn ng easy check fun apply new element contains node shape hi qi contained node shape hi qi 
add ir gamma gamma gammar pr sub ir gamma gamma gammar pr ir phi phi phi phi phi gamma gamma gammar pr ir gamma gamma gammar pr add sub ng gi ng hj gamma primitive combinators defined lines defined usual manner ym 
ng properties model combinators satisfy usual equations 
lemma apply apply apply apply apply apply apply proof 
induction approximation kn sn implies fi axiom bracket abstractions valid model 
corollary fi combinator terms 
determine important equations catch error values draw operational intuition capturing behavior control operators reduction rules 
main idea formalize notion program counter program text tool determines term program evaluated order determine program answer 
introducing auxiliary notion evaluation context apply apply apply catch xn add sub evaluation context context hole leftmost outermost position path root hole strict primitive functions left including applications catch abstraction 
evaluation context contains error bottom value hole denotes error bottom 
lemma evaluation contexts numbers variables xn error error catch xn gamma catch xn proof 
show xn hj fi appropriate branching function induction structure context 
rest follows directly 
equations catch natural equations numerical primitives fi completely determine operational reduction semantics spcf 
equations suffice show representability lemma section certain terms represent finite elements 
full abstraction theorem plotkin showed order extensional model pcf parallel operations fully language define finite elements model 
exactly argument carries spcf 
know tree model order extensional prove fully showing finite trees definable spcf 
section strategy prove fully spcf 
theorem full abstraction closed spcf expressions iff proof 
proof follows exactly outline plotkin proof full abstraction theorem continuous function model pcf parallel operations 
relies lemma 
lemma finite element closed spcf expression proof sketch 
proof lemma proceeds induction depth type induction step decomposes element root set proper responses attached set subtrees need prove stronger result lemma subtrees necessarily trees specifically prove finite subtree finite element representable spcf 
subtree representable iff term query element ii 
definition subtree representability reduces tree representability decision tree empty 
prove term represents subtree convenient rely equational characterization representability criterion 
extensionality condition ii equivalent constraint apply apply appropriate domains 
determines context ae subtree restate condition succinctly 
arguments satisfy constraints ae righthand side equation equivalent apply 
argument violates constraints fd ae subtree affect result application 
consequently spcf expression represents subtree ae iff apply apply arguments appropriate type ae 
ready prove subtrees type representable 
term procedure type form spcf expression free variables construction proof represents proceeds induction depth subtrees 
remainder proof nested induction argument induction hypothesis holds subtrees type smaller subtrees type base case leaf 
easy verify leaf expression represents expression works similarly 
inductive case finite subtree hi fi ae arbitrary tree context ae gamma gamma gamma oe root fm fm bb theta theta theta theta bb theta theta theta theta bb theta theta theta theta bb theta theta theta theta ae pq gamma gamma psi root hi qi proper domain branching function set fr responses pairs hh hhm pm responses final answers refer final responses query responses 
edge labeled points subtree root node bottom 
denote subtrees corresponding responses induction hypothesis subtree representable spcf expressions execution procedure determine contents node identified value bound precisely determine responses node matches 
information apply expression representing subtree arguments understand process extracting node need state assumptions 
ae tree context determined responses embedded type oe oe naively construct expression tries obtain contents node applying tuple argument expressions encode information arguments ae 
terminal node naive strategy works 
fails query node return gathered information arguments produce final answer 
contain information ae able general gather information return final answer 
dominates query responses say eventually attempt probe argument event occurs naive argument contain requested information query process diverge 
solve problem need embed code escapes information requested 
spcf program perform non local exits applying catch operator appropriate procedure 
problem define abstraction arguments requests th argument precisely dominates query responses ym parameters key steps writing code 
associate query response parameter 
embed variable argument ends hh 
apply arguments 
form parameters ym appear free argument expressions precise form expressions depends query moment assume construct argument expressions application catch abstraction identifies proper response produces query value invoke code representing subtree performing case split 
loss generality assume final answers sorted catch sub gamma sub fm sub fm nx omega gamma notation sub denotes fold application sub preceding argument reduced task constructing constructing argument expressions index range construction falls cases 
case query response asks information th argument 
case code representing tree ae exists induction hypothesis type oe smaller shallower interesting case number query responses index root assume loss generality query responses hh hh 
know queries extend information ae 
consequently form tree ae ht ht denotes arity type oe type 
induction hypothesis represent finite tree expression type smaller loss generality assume variables associated queries define expression follows completes proof sketch 
sketch omits proof term represents subtree term proof constructed equations catch previous section 
detailed proof refer reader technical report 
observable sequentiality pcf easy show spcf sequential 
program satisfying hypothesis definition omega omega gamma omega gamma 
show argument position forces divergence 
model satisfies equation fi apply suffices consider denotations ary procedure possible denotations procedure elements triples form hj fi jk branching function clearly case contradicts hypothesis definition 
second case specifies ary procedure probes th argument 
fact implies diverges expression jth hole diverges regardless expressions holes 
program behaves sequentially 
spcf satisfies stronger condition sequentiality procedure propagates errors encountered program evaluation 
formalize stronger condition called error sensitivity follows 
definition 
error sensitivity language typed calculus error sensitive iff exist closed expressions denoting distinct inconsistent elements flat domain ground type property 
terminating program omega omega gamma omega gamma 
exists gamma lk 
theorem spcf error sensitive 
proof 
exactly analysis preceding proof sequentiality spcf program returns error jth argument error regardless values remaining arguments 
error sensitivity implies sequentiality 
theorem language error sensitive sequential 
proof 
terminating program omega omega gamma omega gamma 
error sensitive exists gamma gamma monotonicity gamma omega gamma omega denote inconsistent ground values flat domain gamma omega omega gamma precisely sequentiality demands 
error sensitivity spcf implies tree model extensional 
domain decision trees type oe gamma 
isomorphic domain continuous functions mapping oe error sensitivity decision tree model fully 
represent error sensitive functions spcf need mechanism language determining evaluation order programs 
call property languages observable sequentiality 
definition 
observable sequentiality language observably sequential iff satisfies property 
closed expressions program omega omega gamma omega gamma 
exists program context 
catch procedures spcf observably sequential 
theorem spcf observably sequential 
proof 
shown spcf error sensitive 
remainder proof trivial simply set add catch 
spcf observably sequential language studied context full abstraction problem 
sequential algorithms berry defined observably sequential language called cds 
sequential algorithms model cds fully extensional error sensitive 
obviously pcf pcf parallel operations observably sequential 
conjecture construction fully model carries observably sequential programming languages 
practical programming languages typically contain non local control operators permit program evaluation order observed construction fully model spcf solves full abstraction problem large class sequential functional languages 
yield fully models sequential languages include control delimiters prompt 
inclusion control delimiters language prevents delimiters swallow errors generated dynamic extent 
consequently important class sequential functional languages full abstraction problem remains open 

rama dorai sitaram helping hone intuitions error sensitivity sequentiality 
discussions pierre louis curien clarified relationship sequential algorithms convinced working tradition full abstraction literature 
steve brookes pointed mistake original definition sequentiality 

barendregt lambda calculus syntax semantics 
revised edition 
studies logic foundations mathematics 
north holland amsterdam 

berry mod eles compl ad des lambda calculus typ 
ph dissertation universit paris vii 

berry 
curien 
sequential algorithms concrete data structures 
theor 
comput 
sci 


berry 
curien 
theory practice sequential algorithms kernel applicative language cds 
algebraic methods semantics edited reynolds nivat 
cambridge university press 
london 

berry 
curien 
evy 
sequential languages state art 
algebraic methods semantics edited reynolds nivat 
cambridge university press 
london 

cartwright demers 
topology program termination 
proc 
symposium logic computer science 

cartwright felleisen 
observable sequentiality full abstraction 
technical report tr 
rice university department computer science 

curien 
categorical combinators sequential algorithms functional programming 
research notes theoretical computer science 
london 


felleisen theory practice firstclass prompts 
proc 
th acm symposium principles programming languages 

felleisen hieb 
revised report syntactic theories sequential control state 
technical report rice university june 
theor 
comput 
sci appear 

felleisen friedman kohlbecker duba 
syntactic theory sequential control 
theor 
comput 
sci 

preliminary version proc 
symposium logic computer science 

kahn plotkin 
structures des donn es 
inria report 


meyer 
fully semantics local variables 
proc 
th acm symposium principles programming languages 

milner fully models typed calculi 
theor 
comput 
sci 


mulmuley full abstraction semantic equivalences 
ph dissertation carnegie mellon university 
mit press cambridge massachusetts 

plotkin lcf considered programming language 
theor 
comput 
sci 


rose steele jr extended language data parallel programming 
proc 
second international conference supercomputing 
international supercomputing institute 
santa clara volume ii 
available technical report 
pl thinking machines 

scott domains denotational semantics 
proc 
international conference automata languages programming lecture notes mathematics springer verlag berlin 

scott lectures mathematical theory computation 
techn 
monograph prg oxford university computing laboratory programming research group 

sitaram felleisen 
reasoning continuations ii full abstraction models control 
proc 
acm conference lisp functional programming 

steele jr common lisp language 
digital press 

steele jr sussman 
revised report scheme dialect lisp 
memo mit ai lab 

stoughton fully models programming languages 
research notes theoretical computer science 
london 


