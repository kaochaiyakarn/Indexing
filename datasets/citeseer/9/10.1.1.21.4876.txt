efficient flexible incremental parsing tim wagner susan graham university california berkeley previously published algorithms lr incremental parsing inefficient unnecessarily restrictive cases incorrect 
simple algorithm parsing lr sentential forms incrementally parse arbitrary number textual structural modifications optimal time storage overhead 
central role balanced sequences achieving truly incremental behavior analysis algorithms described automated methods support balancing parse table generation parsing 
approach extends theory sentential form parsing allow ambiguity grammar exploiting notational convenience denote sequences construct compact syntax trees directly 
combined techniques automatically generated incremental parsers interactive software development environments practical effective 
addition address information preservation environments optimal node reuse defined previous definitions shown insufficient method detecting node reuse provided simpler faster existing techniques 
program representation self versioning documents detect changes program generate efficient change reports subsequent analyses allow parsing transformation treated reversible modification edit log 
categories subject descriptors software engineering programming environments interactive software engineering distribution maintenance version control programming languages processors compilers parsing translator writing systems compiler generators data data structures trees general terms algorithms languages performance theory additional key words phrases syntax ambiguity balanced structure incremental parsing operator precedence optimal reuse 
batch parsers derive structure formal language documents programs analyzing sequence terminal symbols provided lexer 
incre research sponsored part advanced research projects agency arpa mda part nsf institutional infrastructure cda 
content article necessarily reflect position government 
authors addresses wagner borland mariner island blvd suite san mateo ca email cs berkeley edu cs berkeley edu graham soda hall dept electrical engineering computer science computer science division university california berkeley ca email graham cs berkeley edu cs berkeley edu graham 
permission digital hard copy part material fee granted provided copies distributed profit commercial advantage acm copyright server notice title publication date appear notice copying permission association computing machinery 
acm 
copy republish post servers redistribute lists requires prior specific permission fee 
fl acm acm transactions programming languages systems vol 
march pages 
delta tim wagner susan graham mental parsers retain document structure form parse tree data structure update parse changes user tools ghezzi mandrioli wegman gallier 
topic incremental parsing treated previously published algorithms completely adequate inefficient time space 
incorrect overly restrictive class grammars apply 
central requirement actual incremental behavior balancing lengthy sequences ignored previous approaches 
incremental parser improve batch performance reusing existing grammars 
incremental parsing algorithm runs lg time new terminal symbols modification sites tree containing nodes 
performance determined primarily number scope modifications previous application parsing algorithm 
published algorithms incremental parsing location changes affect running time algorithm supports multiple edit sites may include combination textual structural updates 
technique applies lr approach implementation uses bison corbett existing grammars produce table driven incremental parsers language syntax lalr 
parsing algorithm additional space cost intrinsic storing parse tree 
algorithm requirements parent children associated grammar production node accessible constant time 
state information parse stack links terminal symbol links recorded tree nodes 
transient stack required application parsing algorithm part persistent data structure 
presentation assumes complete versioning system exists necessary production environment 
parser generators accept ambiguous grammars combination additional specifications operator precedence default conflict resolution rules 
techniques provide notational convenience result significantly smaller parse trees especially languages terse expression dense 
provide new results allow incremental sentential form parsing accommodate ambiguity form preserving notational benefits grammar space saving properties resulting compact trees 
incremental software development environments incremental notable exception approach precludes possibly empty sequences occur frequently programming language grammars 
systems nodes carry runtime type information 
additional space typically required encode production represented node 
absence history services describe bits node needed track changes applications parser old value structural link remain accessible completion parsing 
essentially form parse forest filtering klint visser statically encoded parser remains deterministic 
acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta parsing just interactive speed retained data structure important right shared representation analysis presentation editing tools 
setting demands placed incremental parsing algorithm involve just improved performance relative batch systems 
provide intelligent node reuse structural component statement conceptually retained editing operations parser discard recreate node representing component 
intelligent reuse changes match user intuition size development record decreased performance analyses semantics improves 
incremental parsing algorithm capable retaining entire subtrees change points nodes path root parse tree modification site reused doing correct intuitive user 
retaining nodes especially important represent structural elements functions modules classes contain significant numbers user annotations automated annotations time consuming restore profile data 
previously published correctly describes optimal reuse context arbitrary structural textual modifications 
new formulation concept independent operation parsing algorithm limited complexity location number changes 
common cases changing identifier spelling parser modifications parse tree 
reuse technique simpler faster previous approaches requiring additional asymptotic time negligible real time compute 
rest article organized follows 
section compares previous incremental parsing requirements results needed understand material follows 
program representation editing model summarized section 
section introduces sentential form parsing presents incremental parsing algorithm uses existing table construction routines 
results extended section develops optimal implementation incremental parsing 
support ambiguous grammars combination conflict resolution schemes covered section 
section addresses representation handling repetitive constructs sequences constructs model incremental performance permit meaningful comparison batch parsing incremental algorithms 
section develops theory optimal node reuse discusses reuse computation performed tandem incremental parsing history mechanisms section 
history sensitive approach error recovery described separately wagner 

related early approaches incremental parsing data structures persistent parse tree achieve incrementality agrawal yeh kastens 
algorithms decrease time required parse program change text materialize persistent syntax tree required applications incremental parsing 
acm transactions programming languages systems vol 
march 
delta tim wagner susan graham incremental parsing algorithms restrict user single site editing reps teitelbaum editing select set syntactic categories degano parse current single cursor point shilling 
goal provide unrestricted editing model permits mixed textual structural editing number points including erroneous edits indefinite extent scope analyze entire program merely prefix syntactic fragment 
description incremental lr parsing suitable multiple textual edit sites ghezzi mandrioli 
algorithm desirable characteristics restriction lr grammars limits applicability 
ll grammars practical having definitions programming languages techniques developed incremental top parsing grammar class shilling 
li describes sentential form ll parser accommodate multiple edit sites 
gallier provide incremental parsing algorithm suitable lr grammars multiple edit sites persistent parse tree representation 
algorithm associates parse states tree nodes computing reusability previous subtrees state matching 
test sufficient necessary decreasing performance requiring additional compute optimal reuse 
effect especially severe lr grammars due large number distinct states equivalent cores 
extended lr grammars matching condition originally formulated ghezzi mandrioli allows parser retain structural units fully contain modification site 
focuses indirect performance gains accrue node reuse 
original lr algorithm algorithm exhibits linear batch performance cases 
example replacing opening bracket function definition requires entire function body scratch 
definition node reuse provided describe opportunities reuse considered truly optimal 
linked operational semantics particular parsing algorithm 
history mechanisms define subsume mark dispose operations described 
recognizes explicit states need stored nodes parse tree 
parsing theory unnecessarily restrictive requires grammar lr rl incremental behavior 
grammars outside class require batch parsing right edit region defined matching condition similar 
node reuse subset discovered algorithm 
yang recognizes utility sentential form parsing records parse states nodes requires post pass relabel subtrees 
li describes sentential form parser algorithm generate incorrect parse errors grammars ffl rules 
limited com section reviews state matching 
acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta plete lr parse tables invalid reductions induce cycling algorithm 
authors suggest improving parsing algorithm matching condition checks impede performance require additional space store state information node 
approaches ideal 
unrestricted lr grammars require additional space node parse tree example requires extra fields node 
degano address problem mixed textual structural editing impose restricted editing framework require novel table construction techniques 
algorithms employ matching conditions fail reuse nodes overlap modification sites 
existing reuse definitions sub optimal tied details particular parsing algorithms 
sentential form algorithms support ambiguous grammars 
approach addresses concerns 
incremental parsing algorithm simple idea sentential form lr parser augmented reuse computation integrate arbitrary textual structural changes efficient correct manner 
results easily extended enforce restrictions previous systems including top expansion correct programs placeholders restricting structural editing correct transformations limiting text editing subset nonterminals retain syntactic roles changes 
technique suitable lr lalr slr similar grammar classes works correctly presence ffl rules 
theory extends naturally lr grammars address general case proofs 
existing table construction methods popular unix tools yacc bison may little change 
technique uses time space offers intrinsic subtree reuse previous approaches 
nonterminal shift check necessary sufficient 
approach designed provide complete incremental parsing solution incorporates balanced representation sequences supports ambiguous grammars static parse forest filters provides provably optimal node reuse 

editing model change reporting section reviews representation structured documents model editing transforming 
object versioning services described provide incremental parser tools environment means locate record modifications 
interface undo textual structural edits undo effects transformation including incremental parsing 
representation self versioning document model wagner graham 
representation algorithms described article embedded implementation ensemble system developed berkeley 
ensemble software development environment structured document processing system 
role structured document system requires support dynamic presentations multimedia components documents high quality render acm transactions programming languages systems vol 
march 
delta tim wagner susan graham ing 
need support software necessitates sophisticated treatment structure fast traversal methods automated generation mixed explicit direct editing structure text support complex incremental transformations wagner 
ensemble document model supports attributed graphs discussion restrict attention tree structured documents focusing primarily text structure associated programs 
document tree associated instance language object 
case programs object represents programming language contains grammar appropriate specialization analysis transformation tools 
tree structure corresponds concrete syntax programming language leaves represent tokens 
tree nodes instances strongly typed classes representing productions grammar 
classes automatically generated language description including grammar processed line 
semantic analysis tools extend base class production add attributes slots maddox 
editing model permit unrestricted editing model user edit component representation time 
changes typically introduce inconsistencies program components 
frequency timing consistency restoration policy decision ensemble incremental lexing parsing semantic analysis performed requested user usually quite frequently keystroke 
incremental parses user perform unlimited number mixed textual structural edits order point program 
performance tools including incremental parser adversely affected location edit sites changes middle program integrated equally quickly 
approach handles transformations user changes applied tools incremental parsing uniform fashion 
benefits allows user existing undo redo commands return state program 
uniform treatment critical providing rational user interface requires additional effort implementation incremental parser effects captured development history records program modifications 
policy reflects experience showing reanalysis keystroke unnecessary adequate performance typically invalid results distracting user van de 
restrictions structural updates save node type remain fixed resulting structure remain tree 
structural changes compatible grammar permitted special error nodes introduced necessary accommodate changes 
textual modifications represented local changes terminal symbol containing edit point 
acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta program versions change reporting includes variety tools analyzing transforming programs 
tools applied strict order example semantic analysis applied incremental lexing parsing restored consistency text structure program component 
simple editing operations viewed transformations perspective particularly useful discussing change reporting means tools convey history services portion program changed 
modifications program initially applied user directly actions tools 
completion logical sequence actions indicated commit step committed contents version read treated single atomic action changing versions 
versions named allowing tools readily identify accessible state program 
history versioning services provide correspondence names versions values 
primary responsibility maintain development log retaining access old information 
updates persistent information routed history service current value versioned data cached optimum performance 
history services provide uniform way tools locate modifications efficiently 
service fully general tool examine regions altered versions 
changes examined just level entire program distributed fashion node subtree 
generality achieved having node maintain edit history wagner graham 
change reporting protocol tools discover modifications interest 
change reporting mediated history service tools record changes side effect transforming program discover changes perform analysis 
history service provides boolean attributes node distinguish local nested changes 
local changes modifications applied directly node 
terminal symbols local change usually caused operation external representation symbol 
case programs local changes usually indicate textual edit 
structural editing normally causes local changes internal nodes 
nested changes indicate paths altered regions tree 
node possesses attribute lies path root locally modified node 
local changes simply derived view local history log nested change annotations incrementally computed synthesized attributes versioned 
summarizes node level history interface needed incremental parsing node reuse 
incremental parsing involves distinct versions program version program represents parsed state 
version concluded parse operation may prototype selects parsed version acm transactions programming languages systems vol 
march 
delta tim wagner susan graham bool changes local nested 
bool changes version id local nested 
routines permit clients discover changes single node traverse entire sub tree visiting changed areas 
version provided query refers current version 
optional argument restricts query local nested changes 
node child 
node child version id 
methods return ith child 
single argument current cached version 
similar pairs methods exist versioned attribute node parent annotations versioned semantic data void set child node 
sets ith child node 
children versioned method automatically records change history log 
similar methods exist update versioned attribute 
bool exists version id 
determines node exists current specified version 
bool new 
determines node created current version 
fig 

summary node level interface incremental parser 
node maintains version history capable reporting local changes attributes nested changes modifications subtree rooted node 
version id arguments refer document efficiently translated names values local history versioned attribute 
fig 

relationship permanent sentinel nodes parse tree structure 
permanent tokens bracket terminal yield parse tree third sentinel points tokens current root parse tree 
sentinel nodes change version 
bos eos token stream tree subsequent parse 
exception initial parse newly entered program version represents batch scenario 
previous state program immediately prior start parsing 
version read parser provide input stream 
modifications accrued version previous version determine subtrees available potential reuse 
current version written constructed parser 
tools including incremental parser permanent sentinel nodes locate starting points mutable tree structure 
sentinel nodes shown mark token stream root tree 
create new program null tree corresponding acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta completing production start symbol grammar constructed 
initial program text assigned temporarily lexeme bos 
batch analysis performed constructs initial version persistent program structure subsequent structure derived solely incorporation valid modifications parser tools 

incremental parsing sentential forms incremental parsing algorithm utilizes persistent parse tree detailed change information restrict time required regions tree affected 
input parser consists terminal nonterminal symbols natural representation unmodified subtrees version parse tree 
discussing tests subtree reuse simplified algorithm incremental parsing introduces basic concepts 
section extends results achieve optimal incrementality subsequent sections discuss representation issues additional functionality 
subtree reuse previous algorithms incremental parsing lr lalr grammars relied state matching push automata parser 
configuration machine summarized current parse state node parse tree records state shifted stack 
test unmodified subtree reuse time state recorded root compared machine current state 
match required lookahead items valid parser shift subtree inspecting contents 
testing validity lookahead usually accomplished conservative check terminal symbols subtree previous parse required follow new version 
disadvantage state matching space associated storing states tree nodes 
state matching restricts set contexts subtree considered valid state matching test sufficient necessary 
overly restrictive test particularly limiting lr parse tables opposed lalr large number similar distinct states distinct item sets identical cores practically guarantees legal syntactic edits valid state matches 
failure match states subtree grammatically correct context causes state matching incremental parser discard subtree rebuild isomorphic labeled different state numbers 
lalr parsers fare better algorithms greater proportion modifications permit test succeed 
sentential form parsing strictly powerful technique state matching deterministic grammars capturing intrinsic incrementality problem 
lr parsers mere fact grammar symbol associated subtree root node shifted current parse state indicates entire subtree incorporated analysis 
situation similar complex lr case 
stated acm transactions programming languages systems vol 
march 
delta tim wagner susan graham right subtree reuse stack nested changes reuse candidate acd left parse stack tos lookahead local changes fig 

incremental parsing example 
illustrates common case change spelling identifier results split tree root token containing modified text 
shaded region left initial contents parse stack instantiated separate data structure contains mixture old new subtrees 
shaded region right provides potentially reusable portion parser input stream 
stack explicitly materialized contents derived traversal parse tree existed immediately prior 
new text scanned top element right stack serves parser lookahead symbol 
remaining nodes candidates explicit reuse section 
example shown tree path nested changes parser need create new nodes incorporate change program 
informally fact subtree representing nonterminal shiftable current parse state means entire subtree right hand edge portion affected lookahead outside subtree immediately reused 
sentential form parsing provides incrementality limitations state matching states recorded nodes subtrees reused grammatically correct context lookahead validation accomplished free consuming input stream 
gallier conceptually split tree series locations determined modifications previous parse 
modification sites interior nodes structural changes terminal nodes textual changes split points fixed number lookahead items constructing parse table 
input stream parser consist new material form tokens provided incremental lexer reused subtrees conceptually stack produced directed traversal previous version tree 
explicit stack maintain new version tree built 
stack holds symbols nodes states recorded nodes 
illustrates common case change identifier spelling resulted split terminal symbol con textual structural modifications reflected tree 
section discusses representation programs techniques summarizing changes 
acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta taining modified text 
formalize concept shifting subtrees 
notation 
denote terminal symbol arbitrary symbol implicit grammar greek letters denote possibly empty strings symbols denotes size terminal lookahead constructing parse table 
denotes state 
subscripts indicate left right ordering 
la denotes union lookahead sets collection lr items represented goto indicates transition symbol state 
partial function illegal transitions denoted distinguished error value 
additional terminology aho 
theorem 
consider conventional batch lr parser configuration 

gamma 

suppose 

note may derive empty string ffl 
goto la parser eventually enter configuration 

gamma 
proof 
correctness lr parsing fact 
atm viable prefix 
results theorem directly testing terminal symbol subtree lookahead set current state supported existing parse tables information available table construction 
result restricted fashion 
subtree internal modifications root symbol shiftable current parse state parse operations including shift final terminal symbol tree predetermined put parser directly configuration additional knowledge legal lookaheads 
transition accomplished shifting subtree parse stack removing breaking right edge 
situation complicated slightly possibility subtrees null yield may need removed top parse stack represent reductions predicated uncertain lookahead 
illustrates breakdown procedure 
validity established theorem relates configuration parse stack section describe technique involves minimal changes table construction methods provides better incremental performance terminal lookahead information achieve 
right edge breakdowns done eagerly avoid cycling parse table contains default reductions canonical lalr lr input erroneous 
complete lr tables right edge breakdowns done demand analogous fashion left edge breakdown shown 
acm transactions programming languages systems vol 
march 
delta tim wagner susan graham remove subtrees top parse stack null yield break right edge topmost subtree 
right breakdown node node replace node children 
node parse stack pop child terminal symbol 
foreach child node shift child nonterminal node shift node leave final terminal symbol top stack 
shift node parse stack update current parse state 
void shift node node parse stack push parse state node parse state parse table state shift parse state node symbol fig 

procedures break right hand edge subtree top parse stack 
iteration node holds current top stack symbol 
subtree null yield appearing top stack position removed entirety 
shift nonterminal 
aj 
shift 

part way breakdown 

breakdown complete 
bd 
fig 

illustration right breakdown 
shaded region shows reductions undone breakdown nodes representing reductions predicated terminal symbol removed 
subtrees null yield discarded right hand edge subtree top stack removed leaving final terminal symbol topmost stack position 
parse stack holds states nodes node labels shown 
contents parse state batch parser incremental parser shifted nonterminal invoked right breakdown 
theorem 

production 
viable prefix 
denote batch lr parser grammar configuration 

gamma 

denote incremental lr parser grammar configuration acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta 

gamma 
yield 
configuration shift subsequent invocation breakdown procedure identical configuration immediately shifts proof 
iteration loop right breakdown leaves viable prefix stack 
routine top element 
parse tree derivation unique final stack configuration match equivalence parse states follows 
incremental parsing algorithm theorem construct incremental parser 
pseudocode algorithm shown 
algorithm represents simple conservative style incremental parsing similar state matching algorithm 
input stream mixture old subtrees previous version parse tree constructed fly traversing previous tree structure local nested change information described section 
parse stack contains states subtrees discarded parsing complete 
incremental lexing performed separate pass prior parsing shown demand driven way incremental parser encounters tokens may inconsistent 
assume incremental lexer resets lookahead la point old subtree completes contiguous section 
reductions occur conventional batch parser terminal lookahead symbol index parse table 
shifts may performed nontrivial subtrees representing nonterminals 
state matching shift test sufficient necessary valid shift determined grammar relationship configurations parse stack 
subtrees shifted broken level time contained modification 
nontrivial subtree shifted reductions predicated terminal symbol removed call right breakdown 
reductions valid case discarded structure immediately reconstructed 
section eliminate sources suboptimal behavior 
correctness algorithm theorem associates configuration incremental parser immediately prior reduction corresponding configuration batch parser 
theorems apply equally lalr slr parsers algorithm grammar classes parse tables 
restriction applies grammar class table construction techniques lossy compression goto table rendered partial map 
legal nonterminal shifts arise batch parsing final stage reduction parsing needs exact test determine subtree acm transactions programming languages systems vol 
march 
delta tim wagner susan graham void parse initialize parse stack contain bos 
parse stack clear parse state parse stack push bos node la pop lookahead bos set lookahead root tree 
true terminal la incremental lexing advances la side effect 
la changes version la switch parse table action parse state la symbol case accept la eos parse stack push eos return stack bos start symbol eos 
recover break case reduce reduce break case shift shift la pop lookahead la break case error recover break nonterminal lookahead 
la changes version la left breakdown la split tree changed points 
reductions processed terminal lookahead 
perform reductions possible terminal shiftable la place lookahead parse stack right hand edge removed 
shift la right breakdown la pop lookahead la la left breakdown la fig 

incremental parsing algorithm theorem 
input series subtrees representing portions previous parse tree intermixed new material generated invoking incremental lexer modified token encountered 
nonterminal shift right breakdown invoked force reconsideration reductions predicated terminal symbol 
nontrivial subtrees appearing input stream broken symbol represent valid shift current state contain modified regions 
terminal returns earliest terminal symbol input stream lookahead yield null leftmost terminal symbol yield 
pop lookahead left shown changes history query 
bos eos token illustrated 
input legally shifted 
establish running time algorithm suppose height subtree containing nodes lgn 
modification sites previous version tree split lg subtrees 
tokens resulting newly inserted text parsed linear time 
lookahead symbol reused subtree lg time required access leading terminal symbol order process reductions 
subtree shifted new context lgn time consumed reconstructing trailing reduction sequence right breakdown 
assume section discusses model incremental parsing assumptions regarding form grammar parse tree representation 
acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta decompose nonterminal lookahead 
node left breakdown node la la arity node result la child previous version fragile result return left breakdown result return result return pop lookahead la pop right stack traversing previous tree structure 
node pop lookahead node la la right sibling previous version null la la parent previous version node result la right sibling previous version fragile result return left breakdown result return result fig 

historical structure queries update right input stack incremental parser 
lookahead subtree decomposed level invocation left breakdown conceptually popping lookahead symbol pushing children right left order analogous iteration right breakdown loop 
pop lookahead advances lookahead subtree consideration previous structure tree 
boxed code support ambiguous grammars section 
change bounded effect results bounded number additional subtree breakdowns combined cost shifting nonterminal symbol lg 
new tokens yields total running time lg 
note persistent space cost attributable solely incremental parsing algorithm syntax tree required environment 
ability shift subtrees independently previous parsing state avoids need record state information tree nodes 

optimal incremental parsing previous section developed incremental parsing algorithm existing information lr similar parse tables 
section improve result avoiding unnecessary calls right breakdown eliminating requirement terminal symbols perform reductions 
result optimal algorithm incremental parsing running time lg 
focus primarily case indicate additional lookahead accommodated 
algorithm perform reductions lookahead symbol terminal lookahead nonterminal algorithm traverse structure locate leading terminal symbol 
providing slightly information parsing tables nonterminal lookaheads reduction decisions directly eliminating source extra lg factor maintaining terminal pointer node 
lookahead symbol nonterminal nonnull yield extends viable prefix need access leftmost terminal symbol acm transactions programming languages systems vol 
march 
delta tim wagner susan graham yield order perform reductions follow rightmost derivation 
reduction handle batch parser symbols constitute lookahead recorded parse table action take nonterminal lookahead change avoids performance cost extracting initial terminals subtree representing current lookahead symbol 
lookahead invalid extend viable prefix contains modifications broken 
basing reductions nonterminal lookaheads sufficient improve asymptotic performance results previous section algorithm unnecessary invocations right breakdown eliminated 
spurious reconstructions avoided parsing optimistically parser omits call right breakdown shifting subtree performs reductions lookahead contains fewer terminal symbols yield 
actions turn correct unnecessary avoided 
actions incorrect problem discovered terminal symbols past point invalid action shifted 
parser backtracks efficiently invalid transitions case backtracking merely delayed invocation right breakdown 
optimistic behavior improves asymptotic practical performance incremental parser 
algorithm implements optimistic strategy technique similar trial parsing batch parser error recovery burke fisher 
suppose legally shift reused subtree resulting state continue shifting additional symbols deriving terminal symbol incorporating input 
way happen subtree correct entirety including final reduction sequence 
shifts terminal symbols indicate lookahead set shifting initial subtree proving reductions optimistically retained applied insufficient lookahead valid 
reductions include subtrees null yield ffl subtree top parse stack right hand edge topmost non ffl subtree 
optimistic strategy possibilities exist lookahead symbol indicate shift reduce action 
illustrates sequence events 
parser begins incrementally discarding structure nonterminal lookahead valid action indicated parse table lookahead terminal symbol 
point error persists algorithm uses right breakdown discard speculative reductions 
point top parse stack lookahead terminal symbols 
input valid incremental parser proceeds change existing table generators minor parse table augmented slightly represent valid invalid nonterminal transitions explicitly 
algorithms constructing parse tables classes parsers described aho easily modified enumerate lookahead symbols terminals 
grammar contains nonterminals amount backtracking limited kv 
case complicated fact gamma terminal symbols shifted error discovered 
acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta void parse bool verifying false initialize parse stack contain bos 
parse stack clear parse state parse stack push bos node la pop lookahead bos set lookahead subtree bos 
true terminal la la changes version la switch parse table action parse state la symbol case accept la eos push eos return stack bos start symbol eos 
recover break case reduce verifying false reduce break case shift verifying false shift la la pop lookahead la break case error verifying right breakdown delayed breakdown 
verifying false recover actual parse error 
nonterminal lookahead 
la changes version la left breakdown la split changed point 
switch parse table action parse state la symbol case reduce yield la verifying false reduce break case shift verifying true shift la la pop lookahead la break case error la arity la left breakdown la la pop lookahead la fig 

improved incremental parsing algorithm 
correctness expressed theorem 
works lr lalr table set nonterminal transitions complete correct 
boxed statements included canonical lr tables improve performance slightly validating reductions lookahead symbol ffl subtree 
parsing classes consider viable prefix property ability shift non ffl subtree automatically validates speculative reductions including speculatively shifted ffl subtrees 
real parse error occurs algorithm invokes recover configuration batch parser initiate recovery error 
shift zero valid reductions 
event actual parse error algorithm invokes error handling exactly configuration batch parser discover error 
canonical tables configuration terminal symbol top parse stack lookahead position 
classes parsers invalid reductions may performed acm transactions programming languages systems vol 
march 
delta tim wagner susan graham discarding left edge right stack 
discarding right edge left stack 
fig 

situation error detected 
course action progressively traverse left edge subtree considered reuse 
action counterpart right breakdown implemented incrementally simply changing lookahead item top right stack 
error persists terminal symbol lookahead position right breakdown ensure topmost element parse stack terminal symbol 
input correct parsing continue usual point 
event actual parse error exists invalid reductions typically re performed point parse tables canonical 
event error detected terminal symbols shifted error recovery initiated exactly configuration batch parser 
error detected 
happens note setting verifying false essential prevent incremental parser cycling 
invalid reductions reapplied followed call right breakdown 
canonical lr tables reductions non ffl subtree lookahead validate speculative reductions 
lossy compression terminal reduction actions invalid reductions permitted parser classes lalr slr limit validation shifts non ffl subtrees 
lalr slr parser generator identifies reductions guaranteed erroneous reduction validation employed case case basis 
flow control similar previous algorithm optimizations defined 
simple cases example illustrated subtree appearing input stream shifted breakdowns required expose modification sites 
conservative invocation right breakdown nonterminal shift replaced error cases right breakdown implement backtracking 
ability reduce nonterminal lookahead results new reduce case identical terminal counterpart 
correctness demonstrate parse tree produced algorithm parse tree resulting batch parse identical replacing error entries terminal transition portion canonical parse table reductions effect 
parsing classes consider retain viable prefix property ensures shift non ffl subtree possible preceding reduction sequence valid 
acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta parse table establishing correctness case 
justify optimized shifting strategy 
recall theorem apply set reductions removed right breakdown 
parser continue shifting case canonical parse table reducing non ffl subtree lookahead clearly configuration immediately shift represented valid prefix rightmost derivation right breakdown unnecessary 
lookahead known valid theorem ensures configuration batch incremental parsers identical shift operation breakdown procedure 
second consider making parsing actions basis lookahead symbol represented ffl subtree input stream 
length terminal yield lookahead decisions potentially invalid 
cases arise case error left breakdown la invoked 
eventually non ffl subtree lookahead reached cases applies 
case reduce action new node created advancing lookahead 
case shift action ffl subtree pushed parse stack 
equivalent application reductions 
shifting reducing ffl subtree lookahead merely adds set pending reductions 
subsequent shift non ffl subtree occur extends viable prefix reductions invalid eventual call right breakdown remove entire reduction sequence apply correct set reductions terminal symbol 
establish configuration parser identical batch parser number defined match points 
theorem 
configuration incremental parser defined algorithm matches batch parser parse table information cases parse empty stack lookahead set bos 
parse accept routine invoked 
error detected recover routine invoked 
immediately prior shift non ffl subtree incremental parser 
proof sketch 
equality clearly holds case 
case modeled special case treating shift eos symbols order reduce start symbol augmented grammar 
argument 
case relies argument optimized shifting conjunction backtracking observing incremental parser performed possible reductions shift occur 
general case similar bookkeeping proof algorithm complex due need backtrack shifting non ffl subtree 
acm transactions programming languages systems vol 
march 
delta tim wagner susan graham corollary 
incremental parsing algorithm produces parse tree constructed batch parser reading terminal yield 
optimality investigate claim algorithm algorithm optimal respect general model incremental shift reduce parsing 
establishing algorithm form improve asymptotically total number steps independent grammar edit sequence 
assume input sequence reused subtrees new tokens reused subtrees provided traversal changed regions previous version tree 
parse table grammar nonterminal transitions complete correct 
conventional model shift reduce parsing augmented ability shift nonterminals form nontrivial subtrees retained previous version tree 
node may reused new version tree child nodes identical trees 
section explores models node reuse greater detail 
cost model charges time node visited constructed 
stated previously version sentential form parsing uses subtree shift test necessary sufficient 
follows immediately parsing algorithm perform fewer shifts 
understand number reductions asymptotically optimal consider restricted case lr parse tables terminal action transitions complete default reductions 
straightforward replacement right breakdown routine operates stepwise fashion 
assume algorithm avoids reduction algorithm performs 
reduction avoided reuse node represent reduction trees 
marked nested changes prior parsing cost extra reduction asymptotically subsumed traversal needed generate input algorithm 
broken left breakdown unnecessarily order trigger calls right breakdown 
order reductions reconsidered nontrivial subtrees adjacent input stream adjacent new tree arbitrary additional knowledge algorithm choose optimal order tests priori 
different combination grammar edit sequence result requiring reductions algorithm 
suppose parser class permits erroneous reductions lossy compression terminal reduction actions parse table version right breakdown shown 
case reduction performed algorithm may due fact right breakdown removes reduction unnecessarily 
recall routine assure configuration terminal symbol top acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta parse stack order avoid cycling presence erroneous reductions 
suppose predicates node reusability part lookahead symbol done state matching approaches 
subtrees question necessarily adjacent previous version parse tree easily exhibit grammars edit sequences performs reductions arranging terminal symbol different previous parse tree 
suppose predicate reusability lookahead symbol 
avoid configurations invokes right breakdown shift remove reductions unnecessarily circumstances 
enter configuration avoid cycling remove reductions dependent lookahead symbol exactly 

ambiguous grammars parse forest filtering ambiguous grammars frequently important advantages unambiguous counterparts shorter simpler result faster parsers smaller parse trees easier maintenance 
parser generator tools bison permit forms ambiguity conjunction mechanisms eliminating resulting nondeterminism parse table 
methods include default resolution mechanisms prefer shift prefer earliest reduction order appearance grammar notation expressing operator precedence associativity aho 
resolving conflicts parse table additional information including default mechanisms built parser generator interferes sentential form parsing assumes parse table reflects grammar language 
particular transitions nonterminal lookaheads appear valid may result parse tree produced batch parser 
illustrates problem 
text edit converting addition multiplication trigger restructuring accommodate higher precedence new operator 
grammar ambiguous straightforward implementation incremental sentential form parsing produces wrong parse tree 
situation occurs conflict resolution encoded parse table available lookahead symbol nonterminal 
incremental parsing methods state matching problem incrementality derives re creating configurations pushdown automaton 
respect unambiguous grammars state matching sufficient necessary test 
case ambiguous grammars stronger state matching test useful treating parse methods describe section apply unambiguous grammars nondeterministic respect particular parsing algorithm absence conflict resolution parse table construction 
resolution methods widely theoretical disadvantages including fact may result incomplete nonterminating parsers 
thorup examines methods eliminate conflicts preserving completeness termination performance results classic lr parsers 
klint visser describe parse tree filters applied parse table construction time 
acm transactions programming languages systems vol 
march 
delta tim wagner susan graham token ident order indicates precedence left low left high ident bison input file 
original program edit site marked 
incorrect parse due ambiguity reused subtree shaded 
correct parse due additional breakdowns 
fig 

incremental parsing presence ambiguity 
grammar ambiguous precedence associativity declarations control parser generator resolves conflicts 
shown sentential form parser produces wrong parse tree test subtree reuse take conflict resolution account state matching methods 
forcing parser break fragile productions occur lookaheads result correctly parsed structure 
table definitive permits incremental parser ignore relationship parse table grammar 
state matching intrinsically supports static conflict resolution mechanism 
existing grammars ambiguous incremental sentential form parsers practical support type ambiguity 
possible solution encode dynamic selection desired parse trees incremental parsing algorithm 
example existing theory operators aasa extended produce incremental evaluator maintaining synthesized attributes describe expression subtree precedence associativity exposed operators 
incremental parser expose operands additional left right breakdown operations accordance operator specifications 
technique limited class ambiguities addressed operator notation 
encapsulating ambiguity second general solution employ efficient state matching implementation restricted basis limiting just portions parse tree involving ambiguous constructs 
ambiguous regions parser acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta uses state matching determine set reusable subtrees unambiguous regions sentential form parsing 
state matching required current state item set contains conflict lookahead symbol node constructed state matching fragile node 
conditions signal parser switch conservative subtree reuse test 
set fragile nodes determined combination grammar analysis dynamic parse time tracking 
set directly ambiguous productions output parser generator productions appear state item set containing conflict node representing instance production list fragile 
parser generators provide information verbose mode 
analysis applies framework produces deterministic parse table selective elimination conflicts including shift reduce reduce reduce conflicts 
nodes indirectly fragile example chain reduction fragile production likewise fragile 
propagation stops number terminal symbols equal lookahead parsing accumulated fragile region example adding parentheses arithmetic expression fragile region results unambiguous construct 
indirect dynamic fragility determined synthesizing exposure conflicts left right sides subtree shown 
node shifted parse stack dynamic fragility determined node explicitly fragile requires state left right side yield exposes fragile production 
entry parse stack extended include additional information needed track terminal yield counts left right conflict exposure 
implementing limited state matching constructing sentential form parser applies state matching fragile nodes straightforward combination algorithms 
prefer avoid additional space overhead explicit state storage applying state matching portions parse tree correctly handled sentential form parsing areas simply re created demand 
state information affected nodes effectively reduced single boolean value 
approach simple implemented explicit storage costs whatsoever small size regions affected fast practice 
order implement approach regions parse tree described ambiguous portions grammar re created visser examines alternative approach modifies item set construction encode parse forest filters heering 
approach conjunction incremental parsing productions priority constraints apply indicated manner analogous conflict causing productions lr parser generator 
practice unnecessary store yield counts persistently count nontrivial subtree reused parser approximated conservatively minimum yield production represents 
environment maintains length subtree text synthesized node attribute information replace yield computation case 
acm transactions programming languages systems vol 
march 
delta tim wagner susan graham bool fragile node node return grammar fragile production node prog node dyn fragility class parse stack entry protected int state node node void push int old state node node 
extend normal parse stack entry object additional fields class extended stack entry public parse stack entry private bool left fragile right fragile int total yield public push node stack children nodes stack entries represented children array 
extended stack entry node parse stack entry children int int num kids node arity compute conservative estimate child yield total yield 
int yield num kids token children node yield type extended stack entry children yield children yield return grammar estimate yield children node total yield yield compute record left side fragility 
left fragile false int exposed yield grammar fragile production children node type type extended stack entry children children left fragile left fragile true break exposed yield yield break compute record right side fragility symmetric 
set node dynamic fragility status 
node dyn fragility left fragile right fragile fig 

computation dynamic fragility 
acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta cation occurs affect structure 
change required sentential form algorithm inclusion boxed code replaces fragile node appearing input stream constituents 
unambiguous symbols containing ambiguous structures parenthesized expressions grammar continue parsed fast 
lookahead exposed ambiguous structure broken order determine action 
fragile nodes constitute negligible portion tree variety programs languages studied java fortran modula additional re computation noticeable impact parsing performance 
grammars practical interest combination sentential form parsing limited state matching uses time space full state matching parsers supporting class conflict resolution mechanisms 

representing repetitive structure asymptotic performance results described article require parse tree support logarithmic search times 
usual case repetitive structure sequences statements lists declarations typically expressed grammars represented trees left right recursive manner 
parse trees really linked lists practice concomitant performance implication incremental algorithms degenerate best linear behavior providing asymptotic advantage batch counterparts 
types operators grammars create recursive structure semantic significance arithmetic operators truly associative possibly implicit sequencing operators separate statements 
represent true performance problems sequences construct naturally limited instance assume size expression program bounded practice 
type problematic substantial program nontrivial length 
depending form grammar modifying program common cases require time linear length program text optimal incremental parser 
avoid problem represent associative sequences nondeterministically ordering yield maintained internal structure unspecified 
convention permits tools freedom impose balancing condition sort normally binary trees 
small amount reorganization due rebalancing affect user visible tree structure results net performance gain practice 
appropriate data structures algorithms known tarjan concentrate interaction nondeterministic structure incremental parsing 
obvious way indicate freedom choose internal representation associative sequences describe syntax language extended context free regular right part grammar lalonde 
grammar specify syntax language declaratively acm transactions programming languages systems vol 
march 
delta tim wagner susan graham describe representation resulting syntax trees 
productions grammar correspond directly nodes tree regular expressions denoting sequences internal representation chosen system guarantee logarithmic performance 
choice operators provided alternatives conveniently expressed alternative productions grammar symbol 
assume unbounded sequences expressed fashion grammar 
note changes grammar necessary parser generator associativity properties sequences treat grammar declarative specification form parse tree 
tools base understanding program structure grammar 
associativity regarded algebraic property sequencing operator essentially semantic notion determined interpretation operators 
sequence specification affects performance incremental parsing correctness existing grammars introduced environment subsequently modified provide incremental performance 
changes required port existing grammars including java modula prototype environment amounted text 
changes simplified grammars regular expression notation compact readable recursive productions replaces 
grammar containing sequence notation transform conventional lr grammar expanding sequence set productions unique symbol 
form productions expresses associativity sequence illustrates transformation 
intermediate symbol required possibly empty sequences 
incremental parsing algorithm requires changes order process sequences 
expanded grammar ambiguous conflicts original grammar conflicts induced expansion sequence notation require special handling described previous section 
simple reconstruction approach handling ambiguity requires left recursive expansion sequence notation result grammar contains conflicts involving sequences 
conflicts represent impediment incremental performance requiring sequence reconstructed entirety appeared lookahead symbol 
gen note powerful transformations involving right recursive expansions sequences employed goal nondeterministic sequences reuse nontrivial subtrees occur input stream precludes delaying reductions entire sequence seen 
class grammars permitted exactly acceptable left recursive expansion sequences 
existing techniques constructing batch parsers directly grammars nakata algorithms treat sequences inherently batch fashion 
necessary undesirable incremental parser restore balancing condition 
complicate parsing assist transformation tool maintaining balancing condition 
environment rebalance modified sequences immediately committing update 
tools perform line rebalancing performance severely degraded waiting completion edit 
acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta ffl ffl grammar sequence notation 
conventional left recursive formulation 
nondeterministic specification 
right recursive tree structure 
balanced tree structure 
fig 

supporting balanced structure 
regular expressions grammar denote associative sequences 
conventional left linear expansion employed batch parsing sequence operator expanded additional symbol productions allow nondeterministic grouping 
tree constructed parser sequence new tokens initially unbalanced 
commit time processing restores balancing condition actual representation vary depending exact location modifications specific rebalancing algorithm 
sequence operators summarized 
rhs ffl sym sym type separator type separator type separator ffl ident fig 

describing nondeterministic sequences 
possible notation differentiates zero sequences allows multiple symbols sequence element optional separator 
comma separated list identifiers written idlist id 
eral approach combining state matching sentential form framework impose limitation running time increases lg assumption sequences conflict productions 
performance analysis techniques earlier sections produce correct incremental parsers grammar accepted parser generator choice grammars accepting language matters greatly sake incre acm transactions programming languages systems vol 
march 
delta tim wagner susan graham mental performance 
examine assumptions accompanied performance analysis algorithms sections 
basic goal ensure node tree reached logarithmic linear time 
tree sufficiently balanced particular sequence unbounded practice represented associative sequence grammar 
note nonassociative sequences syntactically unbounded limited size semantic pragmatic considerations 
example length individual expressions declarations imperative languages rules prolog primitive forms lisp effectively bounded 
assumption unbounded sequences appear grammar list notation violate performance guarantee interpretation yield sequence depends context 
consider bad grammar regular language ajb grammar clearly problematic reduction determined initial symbol sentence arbitrarily distant 
recomputation needed time leading symbol toggled situations arise interpretation associative sequence terminal yield independent surrounding context 
fact long contextual effect structure phrase limited bounded number terminals performance constraints hold 
grammar gain optimum performance requires determination associative sequences check invalid dependencies handled inspection 

node reuse incremental parsing tools collectively support incremental compilation associated environment services 
performance affected just time takes incremental parser update program structure impact parser changes tools environment 
reuse nonterminal nodes parser essential achieving environment performance maintaining user annotations 
indicates set nodes retained explicit reuse calculation common case changing identifier spelling 
characterizing node reuse define justify concept reuse paths discuss specific policy determining set available paths 
second aggressive fortunately form required incremental performance simpler natural expression syntax 
acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta policy described section 
methods computing policies covered section 
node reuse strategy consider tool user needs 
approach simple concept reuse node indicated context contents retained 
reuse justified exhibiting paths base case node question 
reused context typically corresponds path reusable node 
referred top reuse 
reused content corresponds path reused token reusable nonterminal node referred bottom reuse 
cases existence path justifies node reuse anchoring retained node 
goals node reuse particular need avoid spurious surprising results user perspective assert converse true absence path warrants new name associated nonterminal 
note formulations optimality minimal edit distance useful context objective preserving conceptual names program entities 
reuse path establishes inductive proof justifying reuse nodes path manner matches user intuition improve environment response time 
description reuse paths schema different policies employed determining local constraints node reuse generating different sets paths general 
bottom reuse natural extension implicit node reuse occurs incremental parser shifts nontrivial subtree 
unambiguous policy physical object representing nonterminal node reused children version reused 
optimal incremental parser explicit bottom reuse checks necessary reverse effect breakdown turned unnecessary optimal choice breakdown order known advance section 
explicit reuse modified tokens incremental lexer presence errors input stream introduce additional possibilities node reuse explicit bottom checks 
top reuse defined analogously node exists current previous version tree ith child changed represents production versions tree ith child node may reused new version 
illustrates types reuse paths 
incremental parsing algorithms tried capture subset top reuse implementing matching condition li 
test indicates change spliced existing tree structure avoiding complete reconstruction spine nodes 
technique historical basis introduced ghezzi mandrioli precluded better ap recall section persists changes 
assume set reused tokens known incremental lexer change relative order reused tokens 
ffl subtrees retained parsing algorithm serve starting points bottom reuse paths 
acm transactions programming languages systems vol 
march 
delta tim wagner susan graham fig 

illustration reuse paths 
case circle represents reused node lines indicate reuse path justify retention current version linking base case 
unambiguous bottom reuse reused contents 
top reuse reused context 
ambiguous bottom reuse policy subset children required remain unchanged 
additional top reuse result ambiguous model 
proaches time test matching conditions maintain data needed perform tests outweighs cost simple parsing algorithm followed direct reuse computation 
combination bottom top reuse results optimal node reuse set reuse paths computed globally maximal additional reuse justified unambiguous policy decision 
definition reuse expressed particular parsing algorithm language editing model 
ambiguous reuse model policy restricting bottom reuse nodes children reused may appear overly restrictive 
relax bottomup reuse constraint include case child remains unchanged 
expanded definition increase total number reused nodes cases partial overlap new material included 
example consider changing conditional expression statement statement node retained despite replacement children 
relaxed constraint bottom reuse introduces potential ambiguity 
consider happens children node exist new version tree different parents 
reuse site 
decisions require resolution outside scope syntactic reuse computation se desired outcome may depend specific language details environment user preference 
policy adopt implementation come served order determined operational details parser 
ambiguous bottom reuse create new start addition matching conditions precludes incremental synthesized attribution conjunction parsing 
reasonable policies refusing reuse node competing reuse sites voting scheme site larger number children facilitated replacing bottom reuse check creation list potential sites sites processed parsing complete tree intact top reuse takes place 
acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta reuse parent production children remain 
node reuse check int prod node kids arity prod return new node prod node old parent kids parent previous version old parent type prod return new node prod int node new kids return new node prod old parent kids parent previous version return new node prod return old parent fig 

computing unambiguous bottom node reuse reduction time 
reuse algorithm return node previous version tree production unchanged children parent create new node represent reduction new tree new node 
access previous children provided history interface 
ing points top reuse paths originate 
ambiguous policy set reuse paths maximal path legally extended global maximum defined depends general policy resolving competition reuse paths form tree 
differences slight elaborate metrics maximizing total number reused nodes provide little additional benefit time required compute 
implementation consider implementation methods discovering bottom reuse incremental parsing top reuse postpass parse 
methods avoid space overhead suboptimal behavior associated reuse computed matching conditions 
bottom reuse computed easily adding explicit check incremental parser performs reduction 
unambiguous case node representing symbol right hand side production reused share parent node previous version 
illustrates test 
ambiguous bottom reuse computed similar manner relaxing reuse condition 
policy single retained child required trigger reuse parent 
previous set children may split multiple sites new version tree algorithm guard duplicate reuse parent maintaining explicit table reused nodes parse 
unambiguous policy competition single node occur 
top reuse computed separate postpass 
involves recursive traversal current tree limited regions modified incremental parser 
node changed children subject top check attempts replace new child counterpart previous version tree 
algorithm illustrates process 
reachability analysis discovers nodes previous version tree eliminated acm transactions programming languages systems vol 
march 
delta tim wagner susan graham reuse parent production child unchanged 
node reuse check int prod node kids arity prod return new node prod int node new kids node old parent kids parent previous version old parent type prod reuse list old parent add reuse list old parent return old parent return new node prod fig 

computing ambiguous bottom node reuse reduction time 
method differs allowing partial match succeed reuse candidate parents reused children represent production reduced 
simple fcfs policy resolves competition parent children appear multiple sites new tree 
duplicate reuse avoided maintaining list explicitly reused nodes 
compute top reuse single traversal new tree 
top reuse compute reachability mark deleted nodes 
top reuse traversal apply localized top reuse check modification site 
top reuse traversal node node node changes local node new reuse isomorphic structure node node changes nested foreach child node top reuse traversal child restore reuse paths descending node 
reuse isomorphic structure node node int node arity node current child node child node previous child node child previous version current child new previous child exists current child type previous child type replace current child previous child reuse isomorphic structure previous child current child changes nested top reuse traversal current child fig 

computing top reuse 
algorithm performs top traversal structure includes modification site attempting replace newly created nodes discarded nodes 
compute reachability identifies set nodes previous version tree discarded producing current version nodes candidates topdown reuse 
acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta new version deleted nodes constitute candidates top reuse 
reachability check top reuse duplicate nodes reused implicitly incremental parser 
changes algorithm required support ambiguous reuse model 
correctness performance adding explicit reuse incremental parser result node twice 
unambiguous bottom reuse avoids node duplication construction 
bottom reuse ambiguous model top reuse contain explicit guard duplication 
bottom check performed constant time adds significant overhead incremental parsing 
top reuse affect asymptotic results section nodes touched incremental parser examined 
combination optimistic sentential form parsing reuse checks reduction time separate top reuse pass results optimal reuse unambiguous case maximal solution ambiguous model computed optimal space time 
preferred approach practice apply ambiguous bottom reuse top pass locates virtually reusable nodes including top reuse paths 
cases involving ffl subtrees chain rules missed children exist anchor parent node reuse 
example shown simple method results changed node entire tree modified token 

article provides main research contributions 
offers general algorithm incremental parsing lr grammars optimal time space supports unrestricted editing model 
existing techniques constructing lr lalr slr parsers little modification 
second extends sentential form parsing theory permit ambiguous grammars conjunction static disambiguation mechanisms allowing sentential form approach apply grammars widespread 
extensions parsing algorithm support static filtering parse forest simple efficient 
third describes importance balancing lengthy sequences providing solution terms grammar notation parse table construction runtime services 
conjunction representation realistic offered allows meaningful comparisons batch parsing incremental algorithms 
define optimal node reuse independently operational details parsing 
general models ambiguous unambiguous reuse simple efficient methods implement approaches 
lexer reuses token tree possess changes whatsoever lexing parsing analysis 
obviously user modification semantic significance original edit path information remains available tools semantic analysis analyses 
acm transactions programming languages systems vol 
march 
delta tim wagner susan graham acknowledgments grateful ensemble developers helping create appropriate testbed project 
special go john boyland todd feldman william maddox vance anonymous reviewers comments drafts article 
aasa 
precedences specifications implementations programming languages 
theor 
comput 
sci 
may 
agrawal 
efficient incremental lr parser grammars epsilon productions 
acta inf 

aho johnson ullman 
deterministic parsing ambiguous grammars 
commun 
acm aug 
aho sethi ullman 
compilers principles techniques tools 
addison wesley reading mass butcher graham 
grammatical abstraction incremental syntax analysis language editor 
proceedings acm sigplan symposium compiler construction 
acm press new york 

incremental scanning parsing galaxy 
ieee trans 
softw 
eng 
july 
burke fisher 
practical method lr ll syntactic error diagnosis recovery 
acm trans 
program 
lang 
syst 
apr 
corbett 
bison release 
free software foundation cambridge ma 
degano 
efficient incremental lr parsing editors 
acm trans 
program 
lang 
syst 
july 

parallel incremental compilation 
ph dissertation university rochester rochester ghezzi mandrioli 
augmenting parsers support incrementality 
acm july 

incremental semantic analysis 
ph dissertation department computer science lund university 
heering hendriks klint rekers 
syntax definition formalism sdf manual 
asf sdf project 

definition ell grammars 
acta inf 

gallier 
building friendly parsers 
proceedings th acm symposium principles programming languages 
acm press new york 
klint visser 
filters disambiguation context free grammars 
proceedings workshop parsing theory 
lalonde 
regular right part grammars parsers 
commun 
acm 

optimal incremental parsing 

program 
lang 
syst 

li 
simple efficient incremental ll parsing 
theory practice informatics czech republic 
lecture notes computer science 
springerverlag berlin 
li 
generating practical language editing systems 
ph dissertation university western australia 
maddox 
incremental static semantic analysis 
ph dissertation university california berkeley 
tech 
rep ucb csd 

presentation tree transformation 
ph dissertation university california berkeley 
tech 
rep ucb csd 
acm transactions programming languages systems vol 
march 
efficient flexible incremental parsing delta prasad srikant 
incremental recursive descent parsing 
comput 
lang 


reusing batch parsers incremental parsers 
proceeding th conference foundations software technology theoretical computer science bangalore india 
lecture notes computer science vol 

springer verlag berlin 
reps teitelbaum 
synthesizer generator system constructing language editors 
springer verlag berlin 
nakata 
simple realization lr parsers regular right part grammars 
inf 
proc 
lett 

shilling 
incremental ll parsing language editors 
ieee trans 
softw 
eng 
sept 
tarjan 
data structures network algorithms 
society industrial applied mathematics philadelphia pa thorup 
controlled ambiguity 
acm trans 
program 
lang 
syst 
may 
van de graham 
coherent user interfaces language editing systems 
int 
man machine stud 

visser 
case study optimizing parsing schemata disambiguation filters 
tech 
rep programming research group university amsterdam 
july 
wagner 
practical algorithms incremental software development environments 
ph dissertation university california berkeley 
tech 
rep ucb csd 
wagner graham 
efficient self versioning documents 
compcon 
ieee computer society press los alamitos calif 
wegman 
parsing structural editors 
proceeding st annual ieee symposium foundations computer science 
ieee press new york 
yang 
incremental lr parsing 
international computer symposium conference proceedings vol 

national tung university taiwan 
yeh kastens 
automatic construction incremental lr parsers 
acm sigplan 
mar 
received april revised september accepted december acm transactions programming languages systems vol 
march 
