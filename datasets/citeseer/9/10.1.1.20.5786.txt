understanding protocols byzantine clock synchronization fred schneider august department computer science cornell university ithaca new york supported part nsf dcr office naval research contract 
understanding protocols byzantine clock synchronization fred schneider department computer science university ithaca new york august published fault tolerant clock synchronization protocols shown result refining single paradigm 
allows clock synchronization protocols compared permits single correctness analysis holds 
paradigm reliable time source periodically causes events detection event causes processor reset clock 
distributed system reliable time source approximated combining values processor clocks generalization fault tolerant average called convergence function 
performance clock synchronization protocol paradigm quantified terms parameters characterize behavior convergence function accuracy precision 
supported part nsf dcr office naval research contract 

certain applications require synchronized clocks available processors distributed system 
example accuracy performance statistics computed terms elapsed time events different sites depends closely clocks participating sites syn 
timeouts time synchronization schemes state machine approach lamport involve delays proportional closely clocks participating sites synchronized 
real time process control systems require accurate timestamps assigned sensor values values correctly interpreted 
applications require clocks advance approximately rate real time 
ensure deadlines met real time process control applications tasks usually broken small computations scheduled processor clock 
clock tion protocol suddenly sets clock forward momentarily increasing rate processor able handle timely manner tasks due 
clocks times assign timestamps events possible infer potential causality events 
example creation times files usually taken define order files created 
clock synchronization protocol suddenly sets clock back destroy consistency time respect potential causality 
start processor clocks time probably remain synchronized long 
crystal clocks today processors run rates differ seconds second real time drift apart second days clocks power line frequency drift considerably time base power grid northeastern united states typically drifts seconds real time course evening mills 
keeping clocks distributed system synchronized appealing single centralized time service requires clock values exchanged clocks periodically adjusted 
failures result faulty processors exhibiting arbitrary behavior protocol additional burden tolerating erroneous inconsistent clock values 
gives single paradigm correctness proof understand pub fault tolerant protocols keeping clocks distributed system synchronized despite faulty processors exhibit arbitrary behavior 
paradigm allows identify different imple mentation choices protocol solving subproblems defines 
permits 
babaoglu 
cristian 
halpern eta 

kopetz 
lamport melliar smith melliar smith lynch schneider srikanth toueg 

various byzantine clock synchronization protocols compared contributions isolated 
previously clock synchronization algorithms viewed terms distinct classes convergence agreement diffusion flooding messages 
proof interesting necessarily generalizes correctness proofs appeared individual clock synchronization algorithms 
proof clocks treated advancing discrete times ticks 
previous proofs modeled clocks monotonically increasing functions form real time clock time 
remainder organized follows 
clock synchronization paradigm described section 
techniques reading computer communications network described section 
section discuss properties convergence functions central component paradigm give examples convergence functions 
section discusses agreement protocols implementing convergence function 
related appear section 
appendix analyzes performance clock synchronization pro derived paradigm derives bounds various parameters protocol appendix contains glossary notation 

paradigm clock synchronization hardware dock correct processor viewed implementing function 
function maps real time clock time non decreasing argument character ized positive constants ix constant ix defines range initial values clock hardware initial value constants restrict rate clock time increases function real time 
physical clocks counters increase response periodically generated events called cks 
physical clock real time interval ticks vary cause clock value advance different rate real time 
purposes convenient model hardware clock having fixed real time interval ticks advancing varying real number value cp hardware rate called tick width drift rate clock 
notice require value remain fixed successive ticks clocks case computing literature arbitrary behavior response failure called byzantine behavior 
clock synchronization protocols tolerate failures called byzantine clock synchronization protocols 
hardware rate merely ensures rate clock advances rate real time passes 
assumptions behavior clocks faulty processors modeled functions 
clock faulty processor need increase real time passes give inaccurate conflicting information read 
clock synchronization protocol implements virtual clock processor virtual clock hardware clock function maps real time clock time non decreasing argument characterized positive constants correct processors andq virtual synchronization iq 
characterizes closely virtual clocks synchronized drift rate vir tual clocks specifies real time interval virtual clock ticks 
reliable time source available satisfying simple 
reliable time source periodically distributes correct time processors receipt correct time processor adjusts virtual clock accordingly 
provided time distributed frequently processor clocks drift far apart interval adjustments main tained 
provided processor adjust clock adjustment spread interval precedes resynchronization maintained 
implement reliable time source 
reliable time source serves functions clock synchronization protocol just lined 
periodically generates event detected correct processor causes processor resynchronize clock 
formalized terms constants rm rm rts reliable time source generates sequence events real times trs gr tts real time detects event produced trs satisfies vi rs 
choosing trs models fact protocol clocks start real time 
second addition causing events reliable time source facilitates clock synchronization providing value correct processor 
rts processor obtains value adjusting consistent 
things note rts rts 
properties imply correct time available processors available periodically 
having reli able time source correct time available results different clock ization paradigm just described 
second rts stipulate value obtained processor value provided achieve 
permits values obtained different processors compensated known delays due pro tocol execution message delivery 
easy satisfy rts rts single clock resulting time source fault tolerant clock reliable time source depend correct operation single clock constructed approximately synchronized clocks distributed sys tem 
rts achieved individual processor clocks signal periodic tion events rts achieved having processors compute type fault tolerant average values clocks processors system 
describe implementation rts rts distributed system con view resetting virtual clock starting virtual clock runs concurrently old 
initially real time uses virtual clock starts new virtual oi clock real time detects resynchronization event produced time rrs 
convention value characterized tb cl cl 
implemented processor hardware clock virtual clock adding adjustment value maintained clock synchronization protocol 
formally cat rx ct able design clock synchronization protocols paradigm far unable develop generic proof 
function clock time processor correction hardware clock cp 
real time reading cp adding appropriate adjustment value reads cv current value 
virtual clock violate virtual rate value change gradually function time 
fix spreads change correction cv adjustment interval ai clock seconds parameter protocol 
definition achieves 
adjustment cv necessary implement adjust ment implement additional amount add order approach clock second interval starting min cp ai fix ai key definition gradually spread clock seconds 
long avoid violating drift rate bounds vir tual rate long virtual synchronization violated superscripted clock started full adjustment com leaving larger adjustment performed 
case aj called continuous resynchronization occurs 
appendix characterizes values ai parameters paradigm ensure virtual synchronization vir tual rate hold 
implement rts function cf essentially averages values approxi mately synchronized clocks correct processors system 
system processors rts defined cf called convergence function brings clocks closer 
definition cv 
cv amount differs give clock synchronization clock times denoted upper case letters ames lower case letters 
evaluating cf tr cn seemingly requires able read instant virtual clocks maintained processors 
section explains get problem 
protocol processor distributed system consisting processors 
important things protocol unspecified 
appears implementation detect event generated time oi rts processor reads virtual clocks processors convergence function cf 
different choices result different clock synchronization protocols 
fact various choices permit viewing terms paradigm published clock synchronization protocols external time source 
devoted different implementation choices unspecified aspects 
remainder section discusses different implementations detect oi event generated time grs section discusses methods ways processor read vir tual clocks processors 
sections give properties examples convergence functions 
forever od detect event generated time rt real time cf ai lx cv tp 
clock synchronization protocol ere notational device real time way talk value clock execution 
variable implemented directly accessible program cr detecting resynchronization events obvious approach implementing detect event generated time oi grs uses approxi mately synchronized virtual clocks 
predefined value processor waits cp reads ir starting interval timer busy waiting employed implement waiting 
scheme trs earliest real time correct processor virtual clock value ir 
virtual clocks correct processors advance quickly clock seconds real second advance slowly clock seconds real second rma 
compute note time fastest correct clock reads due slowest correct clock read ir 
slow correct clock take long real seconds reaches ir 
implementation detect event generated time ts processor broad cast message virtual clock reaches predefined value resynchronize message received correct processor 
bounded variance real time delay performing broadcast 
details scheme simple form agreement section 
reading clocks processors access clock time real time means order processor obtain arguments cf needed compute see obtain requires read clocks simultaneously 
impossible reasons 
special hardware processor read clock time 
second distributed system processors necessarily access clocks 
solution problems processor locally implement approxima tions virtual clocks processors 
processor maintains collection tables 
compute approximation approximates real time 
approximate simply reading compute values needed described lamport melliar smith processor technique construct periodically communicates processors system 
suppose minimum max imum delays clock correct processor incurred sending message correct processor receiving processing fma 
processor compute executing send ts clock time receive timeout fmax timed real time cp tno processor responds th clock time request sending back real time reply sent 
define clock reading error error inp approximation max cq 
imum clock reading error pair correct processors 
vp cp order bound note approximation clock drift away clock clock seconds real second rate error bounded rate error bounded initially error fmax fm message delay incurred response time request accounted calculation 
real time satisfies iv real time executed assignment clock reading pro tocol 
function upper bound usually known treated constant 
error kept small recomputing frequently keeping small 
practice suffices obtain clock values processors just computing minimizes clock reading error just clock values needed 
reasonable intervals minimizing uncertainty network delay key reducing 
uncertainty network delay reduced installing clock reading protocol lowest level operating system 
large part uncertainty network delay attributed uncertainty program execution time due interrupts forms multiprogramming 
time takes message traverse wire connecting computers high variance 
messages routed intermediate sites delays due queuing sites doing relaying measured recorded message accounted 
variation clock reading scheme just clock synchronization protocols babaoglu drummond cristian lynch srikanth toueg reduces number messages half increase clock reading error 
requesting time processor periodically broadcasts virtual clock value includ ing superscript 
receipt message updates follows 
receive real time reduction number messages sent scheme due lack explicit request messages passage time explicit request message causes transmission clock value 
point point network clock reading errors increase scheme 
increase processor necessarily know communica tions line monitor clock message receive 
polling communications lines done processor microcode increases fm possible message remain queued receiver entire polling cycle 
polling increase effect increase fmax fm increases 
local area networks usually single connection processor network problem 

convergence functions convergence function cf system processors function arguments satisfies certain properties 
argument identifies processor evaluating cf arguments xq gence functions 
properties proofs virtual synchronization virtual rate appendix 
characterization convergence functions permits single set proofs appendix apply collection clock syn protocols 
property required function cf convergence function ically non decreasing arguments 
monotonicity cf clock synchronization arguments time values pro states value reliable time source decrease time passes 
property asserts relative magnitudes virtual clock values absolute values matter combined produce value provided rts 
cf satisfies translation invariance property allows values cf computed different processors different times compared 
evaluation cf processor values arguments xt shifted amount reflecting passage time values result computed shifted amount result computed second 
third require values cf different processors similar values corresponding arguments closer xq 
reason cf called convergence function 
utility convergence function regard characterized constant called fault tolerance degree function called precision 
fault tolerance degree specifies number argument values differ significantly evalua tion cf evaluation cf greatly affecting difference results precision specifies close values obtained evaluations 
realized precision enhancement property cf xl xn cf 
yt xi yi corresponding argument pairs yi xi conditions define width interval spanned values correct proces sors cf implement reliable time source condition satisfied virtual clocks correct processors synchronized read condition stipulates corresponding arguments cf apart reliable time source condition satisfied values obtained reading virtual clock real seconds apart small values differ result drift 
precision enhancement property states order cf convergence function evaluations produce values apart provided correct values values arguments presumably faulty processors differ arbitrarily remaining pair corresponding arguments differs provided cf implements time source furnishes different processors time values term precision usual definition connection data error analysis physical sciences 
precision measure exactly result determined reproducible result sense precision asserts result close quantity actual ly measured just close measure quantity 
term accuracy reserved characterizing close result true value measures 
closer synchronized virtual clocks correct processors 
final property convergence function cf asserts cf xt away correct argument argument width interval contain ing arguments considered correct 
accuracy preservation property xo subset xt members ofn ofx xt 
xo cf xn 
obvious consequence definition 
cf reliable time source correct clocks synchronized bounds maximum amount virtual clock processor adjusted 
correct processors 
function called accuracy cf 
sense apt name reasons 
bounds rate change virtual clock xp bounding accuracy rate virtual clock 
second insofar clock correct processor approximates real time considered true value interest bounds difference value newly reset virtual clock true value 
examples functions satisfy properties convergence functions include egocentric average xl xn average arguments xt fast convergence algorithm xl xn average arguments xl xt arguments 
fault tolerant midpoint xt midpoint range spanned argu ments xt highest lowest values discarded 
fault tolerant average xl xn average arguments xt highest lowest values discarded 
fault tolerance degree precision faulty processors precision goes infinity accuracy functions 
name fault tolerance precision worst precision accuracy degree faults cf rm rm se fma se rm rm rm 
un 
properties convergence functions convergence functions mentioned discussed section 
analyzed melliar smith connection interactive digital signatures 
convergence clock synchronization algorithm 
cff proposed schneider 
cf dolev basis clock synchronization pro tocol lynch ami vlsi clock synchronization chip described kopetz 
characterizing convergence functions terms precision accuracy done schneider precision accuracy functions reported 

agreement convergence agreement protocol allows correct processors distributed system agree action set values 
help ways implementing reliable time source 
agreement protocol disseminate signal causes processors resynchronize clocks satisfy rts 
second agreement protocol disseminate processor clock ensure arguments corresponding positions evaluations cf performed different processors equal enhancing precision cf helping satisfy rts 
agreement dolev allows designated processor called transmitter disseminate value way correct processors know transmitter faulty agree value 
transmitter correct correct processors agree value 
agreement potentially partitions processors classes faulty correct know transmitter faulty correct agreed value ones sent transmitter 
agreement simple inexpensive implement distributed system fewer processors faulty reliable communications possible 
lo byzantine agreement lamport stronger expensive achieve agreement correct processors agree value transmitter faulty correct processors agree value 
transmitter correct set correct processors know transmitter faulty empty 
communications failure viewed failure sending receiving processor 
assuming reliable message delivery merely convenience 
transmitter correct correct processors agree value 
literature contains numerous protocols establishing byzantine agreement 
early survey area appears fisher tutorial schneider 

agreement clocks protocols implement agreement byzantine agreement usually proceed series rounds 
round transmitter sends value processor 
subse quent rounds processor sends copy value received processor 
eventually processor selects set values received 
criteria selection depend protocol median mode unusual 
relaying messages different paths seemingly inefficient necessary prevents correct processors confounded inconsistent values sent different routes faulty processors 
agreement protocol intended disseminating values modified clocks 
operations making copies values sending copies network simple making copies clocks sending network 
key avoiding problem compute send clock differences clocks melliar smith 
differ implement scheme cx encoded triple proc offset specifies cx approximated processor proc set 
ence offset proc 
allows copy send processor executing send proc offset processor receives copy executing receive proc offset approximates cx time evaluating cq proc offset 
clock approximated manner error introduced passing clock cq proc approximation roc 
means copies traverse different routes received single processor identical 
consequently equality tests selection clock mode set clocks received clocks passed system fashion 
schemes devised modifying agreement protocol avoid problems inequality clock copies 
agreement protocol formulated way avoids equality tests select different clock copies received 
melliar smith technique byzantine agreement protocols clocks byzantine agreement protocols take median set values received equality values 
second way avoid inequality clock copies problem consider collection clocks equal clock value collection 
recall maximum clock reading error pair processes 
schneider approach modify agreement protocol dolev uses equality values handle clocks schneider 

obtaining faster convergence agreement convergence algorithm cf schneider result employing agreement disseminate values applying cff convergence processor employs agreement protocol disseminate clock 
value cf processor result applying cff set clocks received 
cf half precision cff convergence twice due agreement possible correct processors values differ ofp knows faulty case ignore completely 
cf accuracy degree fault tolerance cff interesting note cff iterated twice requires rounds message exchange agreement worst case precision clearly inferior precision achieved tw rounds message exchange agreement 
employing agreement cf results precision improve ments convergence functions 
byzantine agreement disseminate clocks correct processors agree approximation clock processor due error bounds approx clocks 
correct processors evaluating convergence function differ values corresponding argument positions 
define function returns gtn largest argument 
employ byzantine agreement protocol tolerate failures disseminate arguments obtain convergence function clock synchronization byzantine convergence processor employs byzantine agreement protocol disseminate clock 
value processor result applying set clocks received 
provided fewer failures correct selects clock guaranteed read clock selected 
means precision gay precision convergence function independent bound accu racy note correct clocks 
correct clocks new clock away correct clock conclude accuracy algorithm 
clock synchronization algorithms byzantine agreement described melliar smith analyzed melliar smith 

fireworks agreement optimization convergence function largest clocks needed 
st largest clock returned decide clock st largest est clocks needed 
performing byzantine agreement costly delay number messages exchanged avoiding byzantine agreements clocks desirable 
propose somewhat weaker form agreement take place byzantine agreements connection 
new form agreement call fireworks agreement effectively allows correct processors agree value single correct clock causing terminate protocol approximately real time fw correct processors terminate priori decided value real seconds 
name fireworks agreement analogy public fireworks display participants agree display 
fireworks display non zero observers different dis distributed system related message delivery times 
describing protocol implement fireworks agreement assume possible correct processor authenticate sender message receives determine message receives modified processors relayed message 
assumptions satisfied digital signatures employed sender message fewer processors faulty simulated authentication technique srikanth toueg transmit messages 
case faulty processors unable masquerade correct ii faulty unable modify retransmit messages received correct 
protocol implements fireworks agreement message value protocol specified processor described rules imple mented separate process 
term sufficient evidence rule defined 
processor signs broadcasts including 
receiving sufficient evidence broadcasts evidence ter protocol 
different schemes proposed determining sufficient evidence required rule 
turning details show scheme satisfying properties leads termination protocol correct fmax real seconds achievement sufficient evidence correct processor eventually determines sufficient evidence 
criterion sufficient evidence evidence considered sufficient correct processor rebroadcast considered sufficient correct processor receiving broadcast 
achievement sufficient evidence eventually correct processor deter mine sufficient evidence 
suppose terminate real time ts rule broadcast sufficient evidence 
case undelivered messages network broadcast 
sufficient evidence take long fm real seconds received correct processor received late real time ts 
criterion sufficient evidence consider sufficient evidence rule terminate protocol 
fm correct terminated fireworks agreement conclude ax 
independent refinement sufficient evidence fireworks agreement con convergence function follows 
tn fireworks agreement section min value 
associated th fireworks agreement cff 
ti note monotonicity translation invariance hold definition 
bound precision rw substituting definition precision get rv 

loss generality suppose due monotonicity simplifies 


get cf cn tq rm 
tb tq tb 
equation simplified follows 
cause tq due vir gil rate conclude cr 
tb tq cn tq tb 
wi yields cr 
tq 
definition mang previous equation results tq cr 

substituting gives und cf 

cf 
simplify obtaining sw fmax fmax 
sufficient evidence characterization sufficient evidence basis clock synchronization protocol exploits fact clock correct processor clock correct processor 
ll sei receipt message rn considered sufficient evidence iff rn correctly signed processors received real time trc rn show se satisfies criterion sufficient evidence suppose fireworks agree ment terminates time due receipt message holds 
show hold rn forwarded correct processor show nin trc holds trc time received copy rn forwarded correct trc rewrite terms ofq trc real time forwarded evidence definitions fm fm fmin fmax 
substitute tc obtain copy rn forwarded contains signature implies 
remains show se eventually satisfied achievement sufficient evi dence holds 
argument simple 
correct processor executing rule protocol receive copy message broadcast 
copy satisfy arrive fm clock seconds sent 
accuracy cs se illustrated follows 
suppose correct processor fastest clock faulty faster processor correct processor slowest clock suppose executes rule time broadcasts message rn 
definition 
message delivered protocol cristian uses variant form sufficient evidence 

test simpler discussed protocol tolerates omission full byzantine failures 
fmin cv find message sufficient evidence satisfies 
definition ofp 
receives copy message rebroadcast rule time rm rm 
message satisfies sufficient evidence terminate 
rmn rmn protocol 
set clock ahead set ahead rm 
conclude css fm fi 
accuracy cs reveals problem sei faulty processor fast clock cause clocks correct processors reset run faster 
consequences quantified appendix 
hand se fault tolerance degree necessary stipulate upper bound number faulty processors 
second characterization sufficient evidence clock synchronization proto col srikanth toueg fact processor broadcasts message clock reads provided faulty processors st message received correct follow message correct 
se receipt messages originated distinct processors considered sufficient evi dence 
easy see se satisfies criterion sufficient evidence forwarded processor messages sufficient evidence processor ori distinct processors considered sufficient evidence 
ing achievement sufficient evidence requires making assumption number faulty processors 
se guaranteed hold ifn processors correct ones 
fault tolerance degree 
similar scheme late protocol babaoglu drummond 
fact processor receives sufficient evidence se received message correct processor means accuracy se better se 
scenario achieves worst case accuracy se 
suppose 
pk correct processors fast clocks pk faulty processor fast clock correct processor slowest clock vi 
suppose processor pi lt messages sent time tsl received early time fmin 
set messages broadcast satisfy se advance clock imin tr cn fm conclude fm clearly accuracy se superior achieved se 
cost 
se requires fewer half processors faulty se assumptions number faulty processors 
clock synchronization algorithms fireworks agreement interesting pro cessor evaluate cf causing correct processor resynchronize clock 
convergence function provides implementation rts rts con vergence functions discussed earlier provided implementation rts 
hand inherent fireworks agreement processor clocks read accurate ways section 
possible achieve precision agreement algorithm come close 
precision depends maximum message delivery delay precision determined variance message delivery delay 

discussion discussed clock synchronization protocols viewed refinements sin gle paradigm 
paradigm postulating reliable time source periodically issues messages cause processors synchronize clocks 
implementing reliable time source involves solving subproblems 
different solutions subproblems yield different protocols 
subproblem defined paradigm generate events cause processors resynchronize 
solution subproblem characterized terms constants rmi rm bound real time interval elapse correct processor resynchronize tn time correct processor resynchronize tn time 
bounds real time elapse correct processor tn time correct processor tn time 
second subproblem defined paradigm program executed pro cessor read clocks 
solution subproblem characterized terms upper bound clock reading error 
final subproblem defined paradigm choice convergence function 
func tion satisfies properties monotonicity translation invariance precision enhancement accuracy preservation 
function characterized preci sion bounds closely bring values accuracy ct bounds far result argument 
processor clocks run close far real time clocks implemented algo paradigm remain synchronized diverge real time 
order construct clock synchronization algorithm keeps clocks close real time reliable time source remain close real time 
various standards organizations maintain highly accurate synchronized clocks 
united states khz radio broadcasts provide time signal accurate milliseconds satellite 
broadcasts mhz accurate milliseconds due uncertainty propagation delays 
employing radio receivers inject correct real times distributed system way provide needed source time 
algorithms clock synchronization source time available described marzullo owicki marzullo lamport 
fact clock synchronization algorithms viewed terms single para surprise 
previously clock synchronization algorithms viewed terms classes convergence agreement style 
pleasing discover published algorithms fact viewed terms single paradigm convergence functions 
addition viewing algorithms refinements single paradigm allows performance compared 
performance clock tion algorithm convergence functions characterized ct cost computing underlying convergence function 
defining notion convergence function giving framework performance quantified possible compare exist ing algorithms insight construction new algorithms 
appendix proof clock synchronization section gives sufficient conditions ensure clock synchronization protocol fig ure satisfies correctness conditions virtual synchronization virtual rate 
assume solutions subproblems left open proto col event generation 
rmi rmax lower upper bounds real time interval elapse correct processor resynchronize th time correct processor resynchronize th time 
bounds real time elapse correct processor th time 
clock reading 
upper bound error associated value obtained program executing processor reads clock 
convergence function 
cf precision accuracy ct satisfies monotonicity translation invariance precision enhancement accuracy preservation properties 
simplify exposition follows assumed range correct proces sors 
synchronization virtual clocks prove virtual synchronization satisfied start establishing correct processors started tn virtual clocks time correct processor starts st virtual clock 
necessary order able execute assignment proto col lemma min 
proof min tf 
definition rain rts rmin tq adding ti tx rmin ti transi sides get hypothesis tivity rmin etx tq definition rts transitivity prove virtual clocks employ instantaneous resynchronization satisfy virtual synchronization 
define ci 
value satisfies tit 
proof virtual synchronization steps 
step lemma shows correct processor start th virtual clock th virtual clocks correct processors close second step lemma extends showing implies correct virtual clocks remain close 
ii iii gs max tj tq cq tj cp tx proo base case vi induction tx max tq cq tx ct 
due hardware initial value 
see 
argument processor tq max tq iq due hypothesis ii 
vi max tq cq cp tx 
induction case 
induction hypothesis assume max tj tq 
protocol definition 
fact reading clock processor associated error cf 
cf 
tq jq arguments cf defined computed due ri lemma hypothesis 
loss generality assume sors conclude tp tq due hardware rate 
monotonicity cf substitute cq uq obtain tp 
due rts simplified cf 

ows te moved cf 
tp cf 
cision cf show establish induction ce 
max tb tq assumption ti suffices prove establish induction case 
flint 
note due rate fact ti ti tp tq ctp tp 
deflation vb tween vue equation tn ment cf equation processor 
note induction processors max 
loss assume 
tn tn cf cs iz cs tp get due hardware rate ti tp 
algebra definition 
due 
cf cn precision enhancement property hypothesis iii 
completes induction case 
lemma ii iii iv ot vt 
proof lemma equivalent vi vi vt max tq tq icq cq vt mn tq cq ti cq cp prove loss generality equivalent vi tq assume ti cq ct prove 
due hypothesis iii lemma conclude max tt tq cq cp 
hardware rate correct clocks drift apart clock seconds real second vi ls max 
implies vi tq tt tq cq ct max due rts 
hypothesis iv vi max tq tq implies desired 
suffices prove 
infer vi 
take definition accuracy ot gs accuracy preservation property obtain bound cq tq differs argument cf calculating argument cq 
vi mn tk tq implies vi cq rmax 
mn tj tq max min cq due hardware rate 
definition lb tj equation implies vi tq rmax 
substituting ot pl hypothesis yields vi 
tq required 
order prove 
rts previous lemma established virtual clocks instantaneous resynchronization satisfy virtual synchronization 
prove virtual clocks continuous ization satisfy virtual synchronization 
define ai maximum number real seconds takes adjustment interval elapse correct processor 
ai 
define clock function real time clock time satisfying fci vt ti ai cp fc vt ti ai 
cp outside adjustment interval value adjustment interval value guaranteed lie value 
cp fc fc conclude order prove vt notation denote rain vt ij vt tj ai definition virtual clock satisfies definition fixed clock choosing ai theorem proves virtual synchronization holds virtual clocks implement continuous resynchronization 
theorem vt vt ot ai 
proof result follows prove ai 
definition rewrite hypothesis theorem implies ai 
see ai note ai due 
remains prove 
due hardware rate drift apart seconds second 
extend range follows vt ai 
definition ai ai 
conclude vt ai ai 
property ai ai vt ai ai 
tt accuracy preservation property ai due argument change range get conclude vt ai ai ai vt ai ai ai combine obtaining ai completes proof 
rates virtual clocks prove virtual clocks satisfy virtual rate require lemma 
lemma max min min proof suppose 
implies min quently min means min min suppose 
implies min 
min min min min min max lemma follows 
able prove virtual clocks rates satisfy virtual rate 
theorem ii iq proof satisfy 
observe imply starred virtual clock ticks contrary protocol 
interested bounding ix ix derive upper bound 
correct ct ct hardware rate 
definition min ct fix ct min ct ct tiv ai ai ix ix min ct ct ai min ct ct ai ai letting ct due hypothesis fact hardware clocks non decreasing 
apply lemma infer fix ct fix ct ai ct ai substituting fig get il ct ct hypothesis ii stipulates virtual clocks synchronized 
hypothesis iii transitivity get desired 
derive lower bound 
hardware rate conclude fz argument lower bound value due get hypothesis iv get desired 
appendix glossary notation section term defined appears parenthesis entry term 
ai ai cp mi max cx rm maximum number real seconds adjustment interval resynchronization spread appendix 
number clock seconds adjustment interval resynchronization spread 
adjustment interval 
hardware clock 
virtual clock 
th virtual clock 
virtual clock instantaneous resynchronization appendix 
fixed clock appendix 
correction factor spread transform 
minimum real time successive events produced reliable time source 
maximum real time successive events produced reliable time source 
resynchronization interval clock seconds 

real time starts real time reliable time source generates th event 

value provided reliable time source starting accuracy convergence function 
maximum real time delay generation event reliable time source detection correct processor 
maximum delay clock correct processor send message processor 
minimum delay clock correct processor send message processor 
tx correct virtual clocks 
bound instant started difference identi cally superscripted correct virtual clocks instantaneous 
real time tick width cp 
real time width tick 
bound error approximation 
maximum clock reading error pair processors 
upper bound 
precision convergence function 
upper bound drift rate 
upper bound drift rate 
approximation cq tj cp 
acknowledgments discussions babaoglu steve leslie sam toueg helpful 
addition am grateful jacob babaoglu david giles keith marzullo mike merritt rick schlichting useful comments earlier versions 
notions accuracy precision developed jointly steve consulting agreement bell laboratories 
babaoglu drummond babaoglu drummond 
cost clock synchronization 
proc 
seventeenth symposium fault tolerant computing pittsburgh penn july ieee computer society 
philip data reduction error analysis physical sciences 
mcgraw hill book new york 
cristian 
clock syr presence omission performance faults processor joins 
proc 
sixteenth international symposium fault tolerant computing vienna austria july ieee computer society 
dolev dolev ti byzantine generals strike 
journal 
dolev dolev lynch pinter stark weihl 
reaching approximate agreement presence faults 
proc 
third symposium reliability distributed software database oct ieee computer society 
fisher fischer consensus problem unreliable distributed systems brief survey 
proc 
international conference foundations computation theory sweden august 
halpern halpern simons strong dolev 
fault tolerant clock synchronization 
proc 
third acm sigact sigops symposium principles distributed computing vancouver canada august 
kopetz kopetz 
clock synchronization distributed real time systems 
ieee transactions computers august 
time timeout fault tolerance distributed systems 
acm toplas april 

notes time service 
preliminary report palo alto ca nov 
melliar smith 
melliar smith 
byzantine clock synchronization 
proc 
third acm sigact sigops symposium principles distributed computing vancouver canada august 
lamport melliar smith lamport melliar smith 
synchronizing clocks presence faults 
acm lan 

lamport lamport shostak pease 
byzantine generals problem 
acm toplas july 
lynch lynch 
new fault tolerant algorithm clock synchronization 
proc 
third acm sigact sigops symposium principles distributed computing vancouver canada august 
schneider schneider 
inexact agreement accuracy precision graceful degradation 
proc 
fourth acm sigact sigops symposium principles distributed ontario canada august 
marzullo owicki marzullo owicki 
maintaining time distributed system 
proc 
second acm sigact sigops symposium principles distributed computing montreal quebec canada august 
marzullo marzullo maintaining time distributed system 
example loosely coupled distributed service 
ph thesis department electrical engineering stanford university 
mills mills experiments network clock synchronization 
arpanet rfc sept 
schneider schneider paradigms distributed programs 
distributed systems 
methods tools specification paul 
eds 
lecture notes computer science vol 
springer verlag berlin 
srikanth toueg srikanth toueg 
simulating authenticated broadcasts derive simple fault tolerant algorithms 
technical report tr department computer science cornell university ithaca new york july 
srikanth toueg srikanth toueg 
optimal clock synchronization 
proc 
fourth acm symposium principles distributed computing ontario canada august 
