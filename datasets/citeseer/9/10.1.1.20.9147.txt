decidability complexity petri net problems javier esparza institut fur informatik technische universitat munchen 
munchen germany 
collection rules thumb helps determine decidability complexity large number petri net problems 
topic decidability complexity verification problems petri nets 
provide answers questions algorithm decide petri nets bisimilar time needed worst case decide safe petri net deadlock free 
intended audience people development algorithms tools analysis petri net models basic understanding complexity theory 
precisely assume reader familiar notion undecidable problem definitions deterministic nondeterministic complexity classes np pspace notion hard complete problems complexity class reductions prove hardness completeness results 
theoreticians acquainted topic warned won find didn know 
hand interested unified view complexity questions safe general petri nets simplifications presentation proofs 
invited write 
remembered statement greek exists exist known knowledge 
imagined greek chorus advising write opinion results decidability complexity petri nets obtained early eighties partially supported und methoden fur die 
result published pspace algorithm modelchecking problem ctl safe petri nets section 
new results included sure decidability issues petri nets survey wrote mogens nielsen haven included survey interest specialists results just show interesting problems intractable finer classifications np pspace expspace hardness practical relevance 
see decided write anticipate answer possible criticisms 
important developments decidability complexity questions interest petri net community 
late seventies early eighties theoretical decidability complexity problems place transition petri nets 
known computer scientists rabin rackoff lipton mayr meyer kosaraju just mention obtained impressive collection results 
decidability problems boundedness liveness reachability language equivalence settled cases tight complexity bounds obtained 
results obtained developments computer science opened new problems late seventies temporal logic proposed query language specification reactive distributed systems years model checking introduced technique verification arbitrary temporal properties 
howell yen study decidability complexity modelchecking problems petri nets second half eighties 
today questions research field answered :10.1.1.1.9920
early eighties process algebras introduced formal description concurrent reactive systems 
seen language equivalence adequate equivalence notion class systems instance may consider deadlock free systems equivalent systems deadlocks 
new equivalence relations introduced bisimulation failures equivalence 
early nineties decidability equivalences systems infinite state spaces started receive lot attention led renewed interest petri nets 
proved years ago fundamental result showing undecidability petri nets equivalence notions described literature 
developments effect 
eighties researchers started study relationship process algebras petri nets 
net models place carry token condition event systems elementary net systems turned particularly useful studies 
nets definition finite number states interesting automatic model checkers realised model large number interesting systems reach automatic verification 
questions asked solved place transition nets asked models 
years complexity classical properties reachability liveness model checking problems different temporal logics equivalence problems different equivalence notions completely determined 
different approach survey written complement 
research decidability complexity verification problems petri nets produced papers 
published known journals available library 
survey mogens nielsen summarises results provides comprehensive list 
petri net researchers need information complexity particular problem petri net mailing list receives postings kind requests 
cases similar problem studied literature pointers relevant papers 
familiar number basic techniques easy apply existing results new problem 
acquiring familiarity moment hard task specially ph 
students go papers distill understanding explicitly contained papers 
purpose pages task bit easier 
listing results concentrate general results broad applicability 
provide rules thumb think useful formal theorems 
researchers interested development implementation analysis algorithms petri nets greatly profit basic knowledge computational complexity analysis problems 
researchers regularly confronted problem having prove disprove conjecture 
try find proof counterexample 
wrong choice lose precious time 
complexity theory help showing truth falsity conjecture implies fact np np pspace 
examples form stories taken personal experience story graduating physics ph 
student computer science 
time knew little theoretical computer science theoreticians environment 
started analysis free choice petri nets net class hope finding efficient verification algorithms precisely began investigate liveness problem 
hope efficiently transform problem set linear inequations solved linear programming 
efficiently meant number size equations grow quadratically say size net 
months find encoding read textbooks theoretical computer science 
came garey johnson book theory np completeness problem working precisely complement list np complete problems book 
exist polynomial algorithms linear programming complement liveness problem free choice nets np complete existence efficient encoding imply np highly 
np completeness non liveness problem free choice petri nets proved section 
story ii 
years ago refereed submitted petri net conference 
contained conjecture reachability problem petri nets stated follows 
net markings reachable conjecture reached sequence transition firings visits intermediate markings size sizes respectively 
author constructed random generator nets markings tested conjecture cases positive answer 
certainly possible disprove conjecture exhibiting counterexample faster complexity argument 
show argument section 
story iii 
come containing characterisation set reachable markings safe petri nets 
simple complexity analysis shows characterization probably wrong haven counterexample 
order formulate characterisation need definitions notations 
siphon net subset places satisfying trap subset places satisfying net set define net nu result removing transitions belonging removing places connected transition anymore 
net markings petri net safe 
characterization states reachable exists mapping satisfying properties place 
nonempty siphon tx marked nonempty trap tx marked tx set transitions 
strongly believe proof result contains mistake counterexample exists 
show section 
classification problem np pspace expspace hard practical relevance complexity petri nets studied seventies np complete problems really intractable computer scientists unable deal small instances due lack computing power theoretical results 
time probably didn difference practitioner problem pspace hard np complete 
opinion today picture different wrote publication stephan counterexample places transitions 
np complete problems longer intractable 
certainly true known algorithms solve exponential worst case complexity 
today exist commercial systems standard np complete problems satisfiability propositional logic formulas integer linear programming problems routinely solve instances large size 
years witnessed proliferation model checking tools cospan pep prod smv spin see comprehensive information problems solve pspace complete successfully applied verification interesting finite state systems 
commercial versions starting appear 
experimental tools analysis timed systems starting emerge 
examples hy tech kronos uppaal 
problems solved tools expspace complete 
size instances handle certainly smaller case model checkers results promising 
theorem provers hol isabelle pvs applied success verification systems infinite state spaces 
heuristics try solve particular instances undecidable analysis problems 
old tractable intractable classification rough 
finer analysis provides valuable information size instances handled automatic tools possibility applying existing tools particular problem 
organisation divided parts 
devoted safe petri nets place transition petri nets having property reachable marking puts token place 
nearly results hold safe petri nets tokens place assuming algorithms receive part input implies particular known advance 
second part devoted general place transition nets 
parts divided sections 
section contains rules thumb 
general informal statements try summarise number formal results concise necessarily informal informative way 
called useful lies statements tell truth truth useful complicated formal theorem ifs 
total rules thumb help solve complexity questions come research 
rules thumb displayed text rule thumb find rules thumb look pieces text box 
rule thumb pieces text surrounded box fact double box 
fundamental formal results derive rules thumb 
fundamental results displayed double box 
section contains universal lower bound interesting petri net problems 
second section deals upper bounds safe petri nets possible give universal upper bound case general petri nets delicate 
third section deals equivalence problems nets equivalent respect equivalence notion 
upper lower bounds considered simultaneously 
fourth section gives information far go polynomial time algorithms 
results mentioned proved reader referred literature 
results proof fulfilling conditions general applicable variety problems admit relatively simple non technical proofs 
devoted special effort presenting proofs simplest possible way 
goal produce read straight 
don know goal achieved tried best 
table contents decidability complexity petri net problems javier esparza safe petri nets ii general petri nets preliminaries assume reader acquainted basic notions net theory firing rule reachable marking liveness boundedness basic computation models turing machines 
section just fixes notations 
petri nets 
net triple finite sets places transitions flow relation 
identify characteristic function 
preset postset place transition denoted respectively 
set denote marking mapping place transition petri net pair net initial marking 
transition enabled marking enabled fire occur firing leads successor marking defined place expression denotes enables transition marking reached occurrence finite infinite sequence 
called firing sequence 
maximal firing sequences petri net infinite firing sequences plus finite firing sequences marking enable transition called runs 
sequence denotes exist markings mn mn petri net safe place reachable marking encode net jsj jt binary matrices pre post entry pre arc 
entry post arc 
size net number bits needed write matrices jsj 
jt 
size petri net size net plus size initial marking 
markings encoded vectors natural numbers 
size marking defined number bits needed write vector component written binary 
observe size safe petri net jsj 
jt initial marking size jsj 
labelled net net mapping associates transition label taken set actions act act denote transition labelled petri net pair labelled net initial marking 
turing machines 
single tape turing machines way infinite tapes tape cell 
purposes suffices consider turing machines starting empty tape tape containing blank symbols 
define nondeterministic turing machine tuple set states set tape symbols containing special blank symbol fr lg transition function initial state set final states 
size turing machine number bits needed encode transition relation 
linearly exponentially bounded automata 
times turing machines finite tape fragment equivalently turing machines tape cell 
call bounded automata 
bounded automaton tries move right tape cell just stays cell 
function induces class bounded automata contains bounded automata size tape cells 
notice deviate standard definition says automaton bounded tape cells input word length consider bounded automata working empty tape standard definition appropriate 
get classes linearly bounded exponentially bounded automata respectively 
complexity classes reductions 
basic complexity classes np pspace 
class expspace defined expspace dspace polynomial reductions instance problem construct polynomial time instance problem results hold logspace reductions log lin reductions address point 
notice books instance define expspace dspace 

part safe petri nets study complexity analysis problems safe petri nets 
safe petri net say possible markings just markings set markings put token place 
clearly jsj possible markings 
markings identified set places marked 
observe size marking linear size net 
universal lower bound section obtain universal lower bound complexity deciding safe petri net satisfies interesting behavioural property rule thumb interesting questions behaviour safe petri nets pspace hard 
notice rule thumb theorem 
behavioural properties safe petri nets solved polynomial time 
instance question initial marking deadlock answered efficiently trivial hardly anybody consider really interesting 
careful formulation rule thumb questions described literature interesting pspace hard 
examples petri net live 
reachable marking deadlock 
marking reachable initial marking 
reachable marking puts token place 
reachable marking put token place 
reachable marking enables transition 
reachable marking enables transition 
initial marking reachable reachable marking 
infinite run 
exactly run 
run containing transition 
run contain transition 
run containing transition infinitely 
run enables transition infinitely contains finitely 
pspace hardness problems consequence single fundamental fact observed jones landweber lien linearly bounded automaton size simulated safe petri net size 
polynomial time procedure constructs net 
notion simulation strong safe petri net simulates turing machine bijection configurations machine markings net machine move configuration configuration step petri net move marking marking firing exactly transition 
linearly bounded automaton size computations visit cells set cells 
simulating petri net contains place state place cell place symbol cell token signals machine state token signals machine reads cell token signals cell contains symbol total number places jqj 

transitions determined state transition relation cell transition input places output places cell right signals tape head moved right cell case cell exception assumption machine move right 
add similar set transitions time cell exception 
total number transitions 
jqj 

size jqj 

initial marking puts token place denotes blank symbol 
total size petri net 
follows immediately definition move corresponds firing transition 
configurations reached computation correspond markings reached corresponding run 
markings put token exactly places fs qg exactly places fs cg exactly places fs cell safe 
order answer question linearly bounded automaton construct net polynomially larger solve corresponding question runs instance question computations terminate corresponds petri net deadlock 
turns questions computations linearly bounded automata pspace hard 
empty tape acceptance problem pspacecomplete linearly bounded automaton decide accepts empty input 
pspace hardness problem robust remains pspacecomplete restrict deterministic bounded automata bounded automata having single accepting state bounded automata having single accepting configuration 
problems easily reduced acceptance problem polynomial time pspace hard 
examples halt visit state visit configuration 
visit configuration infinitely 
obtain way large variety pspace hard problems 
polynomially larger corresponding petri net problems 
instance reduction problem visit configuration proves pspace hardness reachability problem safe petri nets 
furthermore pspace hard problems safe petri nets obtain new ones reduction 
instance problems easily reduced problem deciding reachable marking puts token place reachable marking concurrently enables transitions transition occur 
run containing transition infinitely 
problems section easily proved pspace hard techniques 
liveness problem list bit complicated 
interested reader find reduction 
solution story iii recall conjecture story iii net markings petri net safe 
reachable exists mapping satisfying properties place 
nonempty siphon tx marked nonempty trap tx marked tx set transitions 
show conjecture true reachability problem safe petri nets belongs np 
know problem pspace hard truth conjecture implies np pspace highly 
probably conjecture false look counterexample trying prove 
need known result see instance polynomial time nondeterministic algorithm feasible problem deciding system linear equations integer coefficients solution natural numbers 
easy decide siphon net marked marking deterministic algorithm due 
computes largest siphon contained set places marked clearly nonempty marked empty 
algorithm marked variable type set places set places unmarked fsg od return true return false algorithm traps marked similar just change loop condition clearly algorithms run polynomial time 
nondeterministic algorithm checks conditions 
guesses set tx transitions checks hold 
checks condition holds vector tx ft 
checks system equations containing equations condition plus equation tx equation solution 
algorithm check conditions guess subset transitions tx marked tx traps marked tx feasible return true fi system equations linear size net feasible runs polynomial time size net 
check conditions runs polynomial time problem checking conditions hold belongs np 
didn know marked algorithm conclude conjecture probably false 
existence procedure feasible conclude reachability problem safe nets belongs second level polynomial time hierarchy see instance 
general opinion complexity theorists pspace np pspace 
nearly universal upper bound section obtain nearly universal upper bound matching pspace hard lower bound section rule thumb nearly interesting questions behaviour safe petri nets decided polynomial space 
observe rule thumb says nearly longer 
reason literature contains interesting question requiring polynomial space 
exception rule described section 
substantiate rule thumb help temporal logics 
application computer science late seventies pnueli temporal logics standard query languages express properties reactive distributed systems 
application temporal logics computer science 
temporal logics linear time branching time linear time logics interpreted single computations system branching time logics interpreted tree possible computations 
popular linear branching time temporal logics ltl linear time propositional temporal logic ctl computation tree logic 
safety liveness properties interest practitioners deadlock freedom reachability liveness petri net sense starvation freedom strong weak fairness expressed ltl ctl 
show properties expressible ltl ctl decided polynomial space 
show uniformly decided polynomial space prove degree polynomial depend property consider 
precisely jn denote size petri net denote length formula number symbols 
ltl ctl give algorithm accepts input petri net formula answers net satisfies formula algorithm uses jn space polynomial independent 
linear time propositional temporal logic formulas ltl built set prop atomic propositions syntax prop holds state holds holds usual abbreviations true eventually 
ltl formulas interpreted computations 
computation finite infinite sequence sets atomic propositions 
intuitively set propositions hold computation steps 
computation point computation iff iff iff iff exists point computation iff say computation satisfies formula denoted 
atomic propositions intended propositions states system 
chosen class systems logic applied fixed 
case safe petri nets states system markings atomic propositions predicates possible markings net 
natural atomic proposition place 
markings satisfying atomic proposition put token observe computation sequence sets places sequence markings 
particular sequences markings obtained runs removing intermediate transitions computations 
abusing language call particular computations runs 
define petri net satisfies runs satisfy 
ltl formulas interpreted petri net models variation lamport bit mutual exclusion algorithm processes runs infinite true net 
runs mark place cs infinitely false gf cs 
runs place req marked place cs eventually marked true req cs 
formula expresses deadlock freedom formula expresses requests process critical section eventually granted 
model checking problem ltl safe petri nets consists safe petri net formula deciding satisfies 
solution model checking problem give automata theory 
introduce automata infinite words 
req cs idle req cs idle process second process id nid id fig 

petri net model lamport bit mutex algorithm nondeterministic automaton finite alphabet finite set states initial state transition relation set finite states 
language denoted defined set finite words accepted define language infinite words accepted denote 

word belongs 
infinite sequence states 
interested language infinite words automaton call uchi automaton 
important result ltl formula build finite automaton buchi automaton 
exactly set computations satisfying formula 
computations sequences sets atomic propositions alphabet automata set prop case prop set places net alphabet automata set markings 
construction exceeds scope see instance 
purposes suffices know facts states sets subformulas states pairs sets subformulas 
exponentially sets subformulas may exponentially states states marking algorithm decides polynomial space need automata qn bn qn obtained petri net follows qn set reachable markings initial marking contains triples markings transition set deadlocked reachable markings set reachable markings loosely speaking automata correspond reachability graph peculiarity edges labelled marking come 
bn differ final states 
clearly set finite runs 
bn set infinite runs 
order solve model checking problem input product automata product automata bn product automata defined usual way clearly 


bn 
union 
set runs satisfy words satisfies 

reduced model checking problem decide 
empty 
solve problem polynomial storage space size 
natural idea construct standard algorithms emptiness automata finite infinite words 
unfortunately may exponentially states jn point complexity theory helps means savitch construction 
recall nondeterministic decision procedure problem algorithm return fail satisfies property answer problem necessarily execution algorithm returns 
deterministic decision procedure answers 
product buchi automata doesn accept intersection languages case 
savitch construction nondeterministic decision procedure problem space savitch construction yields deterministic procedure problem space 
construction life easier suffices give nondeterministic algorithm emptiness problem running polynomial space 
suffices give nondeterministic algorithm nonemptiness problem savitch construction exists deterministic algorithm nonemptiness problem reversing answer algorithm obtain emptiness problem 
nondeterministic algorithm nonemptiness problem constructs fly 
algorithm keeps track current state initially set initial state 
algorithm repeatedly guesses state checks transition leading current state state updates current state 
case algorithm returns true reaches final state algorithm nonempty variables type state type state type marking final state choose state marking transition od return true order estimate space nonempty observe operations tests performed polynomial space 
recall states algorithm decides polynomial space algorithm needs store state marking states sets subformulas quadratic size linear size jn polynomial space suffices 
case bit complicated 
finitely states 
nonempty exists reachable final state loop 
algorithm proceeds case point guesses current final state revisited stores current state able check guess true 
rest algorithm checks guess nondeterministically 
algorithm nonempty variables type state bn type marking type state flag type boolean lag false ag false choose state marking final state choose lag false lag true fi od repeat choose state marking return true nonempty uses polynomial space 
deterministic algorithm obtained application savitch construction nonempty nonempty needs polynomial space model checking problem ltl belongs pspace 
observe properties safe nets order obtain result state polynomial size linear jn markings decided polynomial space transition conditions weak pspace result extended number models 
observed conditions hold petri net classes condition event systems elementary net systems process algebras certain limitations recursion models finite number state machines communicating finite means 
conditions hold bounded petri nets assuming bound nonempty nonempty part input 
assumption necessary bound bounded petri net maximal number tokens place contain reachable marking bigger size net may need polynomial space order just write reachable marking 
pspace result extended general logics linear time mu calculus translation automata works see instance 
computation tree logic interesting properties petri nets expressed ltl 
example liveness petri net sense 
recall transition live occur 
possibility express allow existential universal quantification set computations starting marking 
ctl introduces quantification top ltl syntax syntax ctl prop ex existential operator ax universal operator existential operator universal operator disjunction implication defined usual 
abbreviations true ef possibly ag ef af eventually af holds state computation ctl formulas interpreted computation trees possibly infinite trees node labelled set atomic propositions 
path computation tree extended larger path called computation notice computation ltl sense 
intuition nodes tree correspond states system state may arbitrary number successors corresponding different computations 
set atomic propositions hold node state tree node iff iff iff ax iff child ex iff child child iff computations exists iff computation exists tree clear context shorten 
say tree satisfies formula root 
observe ax equivalent ex ex ax dual operators 
remove ax syntax losing expressive power 
existential universal operators dual true 
dual operator universal existential weak syntax wu semantics wu iff holds wu order ctl specify properties safe petri net choose places atomic propositions 
choice computation tree tree sets places set markings 
associate computation tree follows root labelled initial marking children node labelled labelled markings transition say satisfies tree satisfies 
computation tree corresponding net shown 
essentially tree just unfolding tree reachability graph net 
different nodes tree labelled marking subtrees idle id idle id req nid idle id idle id req nid req nid req nid req nid req nid cs nid idle id idle id cs nid 
fig 

computation tree petri net roots labelled marking isomorphic 
formula marking nodes labelled satisfy 
sense say satisfies meaning nodes labelled satisfy 
ctl queries petri net reachable marking puts tokens cs cs true ag cs cs 
output transition place req live true req id 
initial marking reachable reachable marking true idle id id idle eventually place cs marked false af cs run marks cs true cs req marked eventually cs marked false ag req af cs show model checking problem ctl pspace 
follows discussion suffices give polynomial space algorithm syntax ex wu give deterministic algorithm check marking formula parameters answers true satisfies false 
modelchecking problem solved check 
check recursive procedure structure check op op operator logic calls check check 
algorithm check return true return false fi elseif return check elseif return check check elseif ex transition check return true fi od elseif return eu elseif wu return fi remains define procedures eu 
start eu 
possible deterministically explore infinitely computations starting check directly satisfies reader feel tempted give nondeterministic algorithm explores computations apply savitch technique 
idea fact doesn 
subtle problem 
consider formulas places 
obtain checking algorithm applications savitch technique 
easy give jn space nondeterministic algorithm 
unfortunately deterministic algorithm obtained savitch technique requires jn space algorithm jn space algorithm jn space 
degree polynomial jn depends formula considering 
proceed different way 
fist step reduce problem exploration finite number finite paths 
extend syntax ctl new operators natural number loosely speaking node satisfies computations starting find node satisfying steps nodes satisfy formally iff computation exists follows immediately definition satisfies number satisfies 
arbitrary node number places prove suffices prove implies 
assume satisfies 
contains computation satisfying computation satisfies consider case sequence markings corresponding safe places reachable markings 
indices markings labelling successors node completely determined marking labelling node contains computation starting labelled loosely speaking sequence markings new computation obtained old sequence cutting piece glueing ends new sequence marking appears position closer original computation 
iterate cutting glueing procedure appears th position 
computation obtained satisfies solved problem potentially infinite number computations suffices explore finitely paths containing nodes check satisfies precisely extended computation satisfying 
construct eu help algorithm path designed specification path returns true path labelled labelled take algorithm eu constant number places marking path return true od return false iteration loop reuse space space eu space path plus space needed store path polynomial space backtracking algorithm obvious choice meet requirement stores nodes computation currently explored having unexplored branches exponentially 
trick frequently applied complexity theory helps problem 
loosely speaking reachable marking explore paths leading containing nodes reusing space paths leading containing nodes 
trick splitting paths parts applied recursively paths having nodes reached 
algorithm path constant number places check return true fi fi transition check check return true fi fi marking path true path return true fi od return false order estimate space complexity path maximum markings space needed check maximum pairs markings space needed path 
maxfc particular maxfc 
jn maxfc jn remains construct 
interested reader easily prove node wu wu fact trick lies heart savitch technique 
semantics wu wu iff exists path take algorithm constant number places eu return true marking path true return true od return false completes definition check 
easy see runs polynomial space jn determine space complexity bit precisely 
jn maxfc jn jn maxfc jn uw maxfc true jn maxfc jn get 
jn 
exception interesting exception rule thumb controllability property 
subset transitions safe petri net nt say controls sequence occurrence sequence projection transition occur intuition control sense sequence occurred possibly interleaved transitions nt occur transitions occur 
say control control sequence 
controllability problem defined follows safe petri net set transitions decide control jones landweber lien show controllability expspace complete 
action temporal logics defined ltl ctl state logics order know run satisfies property needs information states markings visited execution transitions lead marking 
possible define action versions logics identities markings visited execution run irrelevant information carried sequence transitions occur 
action versions particularly useful labelled petri nets 
action version ltl tailored labelled petri nets looks follows set basic propositions contains element proposition true 
operators replaced set relativised operators xk uk subset certain finite set actions act 
computation finite infinite sequence actions 
true xk iff uk iff order interpret logic safe labelled petri net choose act set labels carried transitions say satisfies formula sequences transition labels obtained runs removing markings satisfy 
similarly action version ctl operators logic ex ax replaced sets relativised operators uk uk 
computation trees trees edges labelled actions 
semantics exactly expects 
easy prove model checking problem new logics reduced model checking problem state versions 
precisely labelled safe petri net formula action ltl ctl construct polynomial time unlabelled safe petri net formula state ltl ctl satisfies satisfies follows model checking problem action ltl ctl pspace 
section study model checking problems temporal logics arbitrary petri nets 
distinction state action logics plays important role 
deciding equivalences section investigate complexity deciding labelled safe petri nets equivalent respect equivalence notion 
early eighties different equivalence notions literature 
van glabbeek classified papers 
equivalences fit called trace equivalence process theory counterpart classical language equivalence formal language theory bisimulation equivalence 
equivalence notion fits trace bisimulation equivalence bisimilar systems equivalent equivalent systems trace equivalent 
trace bisimulation equivalences defined follows 
labelled petri net transitions labelled elements set actions act 
set traces denoted set words act exist markings mn satisfying mn petri nets trace equivalent 
relation sets markings nets strong bisimulation pair action act marking marking petri nets strongly bisimilar exists strong bisimulation containing pair initial markings rule thumb equivalence problems safe petri nets harder solve model checking problems need exponential space 
provide piece evidence rule thumb showing equivalence problem safe petri nets equivalence notion fitting trace bisimulation equivalence pspace hard 
turns concrete equivalences mentioned literature dexptime hard equivalence problems general pspace hardness lower bound possibly improved 
proceed reduction pspace hard problem safe petri net place decide reachable marking puts token start labelling transition label say labelled net 
put side side labelled net consisting loop containing single place marked token single transition labelled denote resulting petri net consider labelled nets 
second small modification obtained adding new output transition place new transition unique input place output places carries label different say holds reachable marking puts token nets trace equivalent second 
recall denotes transition labelled reachable marking puts token nets bisimilar relation containing pairs reachable marking net reachable marking second net clearly bisimulation 
equivalence notion fitting trace bisimulation equivalence solve pspace hard problem constructing nets deciding equivalent 
equivalence problem notion pspace hard 
apart little result real evidence supporting rule thumb rabinovich jategaonkar meyer 
contains table complexity equivalence notions 
bisimilarity variants dexptime complete trace equivalence failures equivalence variants expspace complete 
consider called partial order equivalences concurrent execution actions equivalent interleaved execution system executes parallel considered equivalent system chooses executing 
complexity results open problems similar 
done polynomial time 
seen interesting problems arbitrary safe petri nets pspace hard little hope finding polynomial algorithms 
natural question ask important subclasses safe petri nets solve problems polynomial time 
section get general answers form rules thumb 
rule tends surprising people rule thumb interesting questions behaviour acyclic safe petri nets np hard 
section word warning required meaning interesting 
liveness certainly interesting question arbitrary safe nets acyclic ones safe acyclic petri nets non live transition fire 
interesting questions safe acyclic petri nets np hard marking reachable initial marking 
reachable marking marks place 
reachable marking mark place 
reachable marking enables transition 
initial marking reachable reachable marking 
run containing transition 
run contain transition 
prove np hardness second problem reachable marking marks place 
polynomial time construction associates boolean formula conjunctive normal form acyclic safe petri net 
net nondeterministically selects truth assignment variables formula checks formula true assignment 
construction illustrated means example 
true fig 

acyclic net corresponding formula order obtain classes polynomial decision algorithms impose local constraints net structure 
local constraint means constraint shown hold looking small part net 
instance transition exactly input place local constraint constraint hold point particular transition net input places show constraint satisfied transition 
constraint net acyclic local smallest circuit net may net 
local constraints intensely studied literature conflict freeness constraint place output transition case safe petri nets constraint equivalent place output transition nearly purposes don know formal proof 
free choice constraint arc place transition place transition unfortunately possible summarise results research free choice petri nets concise general rule thumb 
say rule thumb interesting questions safe conflict free petri nets solvable polynomial time 
interesting questions live safe free choice petri nets solvable polynomial time liveness safe free choice petri nets decidable polynomial time 
interesting questions safe net classes substantially larger free choice petri nets solvable polynomial time 
interesting polynomial questions conflict free nets expressed fragment ctl syntax ex ef see 
interesting polynomial questions live free choice nets reachable marking marks place 
reachable marking mark place 
reachable marking enables transition 
initial marking reachable reachable marking 
run contain transition 
interestingly reachability problem safe live free choice nets np complete added list 
part ii general petri nets second part consider arbitrary finite place transition petri nets 
possible markings net just markings set mappings set places observe contrary safe case priori relation size net size markings 
notice set reachable markings may infinite 
universal lower bound section counterpart section place transition petri nets 
rule thumb rule thumb interesting questions behaviour place transition petri nets expspace hard 
precisely require space 
particular questions asked safe petri nets reformulated petri nets turn space complexity 
case safe petri nets consequence single fundamental fact deterministic exponentially bounded automaton size simulated petri net size 
polynomial time procedure constructs net 
order answer question computation exponentially space bounded automaton construct net simulates size solve corresponding question 
original question requires space case properties corresponding question nets requires space 
fundamental fact proved lipton 
mayr meyer proved possible simulating net reversible net reversible transition reverse transition undoes effect 
reversible nets equivalent commutative semigroups construction mayr meyer important applications mathematics 
mayr meyer construction involved lipton reversibility main concern consider lipton construction detail 
easier refer lipton unfortunately exists old yale report quite difficult find 
bounded automata general place transition petri nets fit 
appropriate model cell bounded automaton place safe case cell contains finite number possible symbols place contain infinitely tokens information nonnegative integer variable 
intermediate model counter programs 
wellknown called bounded counter programs simulate bounded automata see show petri nets simulate bounded counter programs 
counter program sequence labelled commands separated semicolons 
basic commands form labels addresses taken arbitrary set instance natural numbers variable natural numbers called counter goto unconditional jump goto conditional jump goto halt program syntactically correct labels commands pairwise different destinations jumps correspond existing labels 
convenience require command halt command 
program executed variables received initial values 
assume initial values 
semantics programs suggested syntax 
point remarked command fails causes abortion program 
abortion distinguished proper termination corresponds execution halt command 
observe particular counter programs deterministic 
counter program bounded step unique execution contents counters smaller equal known construction computability theory polynomial time procedure accepts deterministic bounded automaton size returns counter program commands simulating computation empty tape particular halts halts 
exponentially bounded bounded 
suffices show bounded counter program size simulated petri net size 
goal rest section 
direct description sets places transitions simulating net confusing introduce net programming notation simple net semantics 
easy obtain net corresponding program execution command corresponds exactly firing transition 
look programming notation compact description language petri nets 
net program similar counter program possibility branch zero branch nondeterministically 
possibility transferring control subroutine 
basic commands follows goto unconditional jump goto goto nondeterministic jump subroutine call return subroutine halt syntactical correctness defined counter programs 
assume programs structured 
loosely speaking program structured decomposed main program calls level subroutines turn call second level subroutines jump commands subroutine commands subroutine destinations 
formally define structured programs suffices know programs section structured 
sketch place transition petri net semantics structured net programs 
petri net corresponding program place label place variable distinguished halt place additional places store calling address subroutine call 
transition assignment unconditional jump transitions nondeterministic jump shown 
illustrate semantics subroutine command means program halt goto goto return return corresponding petri net shown 
observe places calls calls remember address subroutine called 
clearly petri net corresponding net program commands places transitions initial marking size 
size 
bounded counter program commands 
show simulated net program commands corresponds petri net size 
unfortunately construction requires quite bit low level programming 
reward worth hacking effort 
notion simulation strong case safe petri nets 
particular net programs nondeterministic counter programs deterministic 
net program simulates counter program property holds halts executes command halt computation halts computations may fail 
variable variable auxiliary variable auxiliary complement variable takes care setting consider main program zero level subroutine jump commands main program commands main program destinations 
halt 
goto halt goto goto fig 

net semantics assignments jumps halt return calls calls fig 

net semantics subroutines program 
call code takes care init 
rest called sim simulates takes care keeping invariant design sim 
program obtained replacement command adequate net program 
commands form replaced net program 
unconditional jumps replaced 
design program test zero nonzero replace conditional jump form goto zero goto nonzero specification test follows execution program leads zero nonzero computation leads nonzero zero program side effects execution leading zero nonzero variable changed value 
easier design program test zero nonzero specification side effect execution leading zero values swapped 
test designed take program test zero nonzero test continue nonzero continue test zero nonzero values swapped times twice test side effects 
key design test lies observation exceeds testing replaced nondeterministically choosing decrease succeed know decrease succeed know 
choose wrongly instance holds try decrease program fails problem guarantee program may 
terminate terminates provides right answer 
decreasing easy 
decreasing difficult part 
leave routine decn designed satisfy specification recall definition variables initial value 
need initially design preprocessing code 
executions leading nonzero free side effects 
initial value smaller execution decn fails 
value greater equal executions terminating return command effect particular side effects 
executions fail 
test proceeds transferring value special variable calling routine decn decreases way need single routine decn different variable decreased leads smaller net program 
program test zero nonzero initially goto nonzero goto loop nonzero goto nonzero loop goto exit goto loop exit dec goto zero routine called dec decn easy see test meets specification may choose nonzero branch reach nonzero 
looping times loop values swapped 
values swapped subroutine decn program moves zero 
execution reaches nonzero branch program fails 
execution reaches zero branch reach value decn fails 
step design decn proceed induction starting dec easy suffices decrease 
take subroutine dec return design dec assumption dec known 
definition dec contains copies program test called different parameters 
define program substituting test test calls routine dec address dec notice correct assuming routine dec defined 
key design dec decreasing amounts decreasing times 
decreasing implemented nested loops executed times body inner loop decreases 
loop variables initial values termination loops detected testing loop variables 
done test programs 
subroutine dec initially initialisation carried init outer loop inner loop test inner exit inner loop inner exit test outer exit outer loop outer exit return observe instances test call routine label 
dec swaps values side effect contrary specification 
case 
swaps compensated side effects zero branches test programs 
notice branches inner exit outer exit branches 
program leaves inner loop test swaps values program leaves outer loop test swaps values concludes description program test description program sim 
remains design init 
list carried 
sim contains variables initial value complementary variables initial value variable initial value complementary variable initial value variables initial value complementary variables initial value 
specification init simple init uses variables list successful execution leads state variables correct initial values 
init calls programs vm specification successful executions effect vm vm particular side effects 
programs defined induction similar family dec programs 
start program vm vm vm vm vm give inductive definition program vm initially outer loop inner loop vm vm test inner exit inner loop inner exit test outer exit outer loop outer exit easy see programs satisfy specifications 
consider init 
apparently face problem order initialise variables vm variables initialised fortunately find solution just carrying right order program init concludes description time analyse size 
consider sim 
contains assignments assignment unconditional jump unconditional jump different instance test conditional jump 
contains single instance routines decn decn dec notice test calls decn calls decn 
test routines constant length 
number commands sim 
init contains single instance programs programs constant size initialise constant number variables 
number commands initialises variables 
proved contains commands 
follows corresponding petri net size concludes presentation lipton result 
solution story ii recall conjecture story ii net markings reachable reachable sequence mn markings mn size sizes respectively 
constant mn size 

conjecture true nondeterministic algorithm solves reachability problem may answer true reachable algorithm reachable variable type marking choose marking size 
transition marking od return true algorithm visits markings size 
runs linear space 
savitch construction deterministic algorithm uses quadratic space 
reachability problem requires exponential space conjecture false 
upper bounds general exponential space lower bound section best hope rackoff gave matching exponential space upper bound covering boundedness problems petri nets 
precisely upper bound log space close lower bound 
covering problem consists deciding exists reachable marking marking exists reachable marking covering boundedness problem consists deciding number reachable markings finite 
yen showed years upper bound holds problem deciding exists firing sequence satisfying predicate constructed syntax syntax general see details 
place transitions constant denotes number times occurs 
covering boundedness problem reduced yen problem 
covering problem marking mn corresponds deciding exists firing sequence mn boundedness problem easily shown equivalent problem deciding exists sequence 
observe reachability problem reduced yen problem predicate belong syntax 
reachability problem shown decidable mayr shortly simpler proof kosaraju known algorithms non primitive recursive 
closing gap exponential space lower bound non primitive recursive upper bound relevant open problems net theory 
possible give general results properties decidable properties decidable exponential space 
particular show properties certain temporal logic decidable decidable exponential space 
going see significant difference state logics action logics consider separately 
state case general rule thumb rule thumb model checking problems interesting state logics undecidable 
safe case choose set atomic propositions 
take prop atomic propositions places say marking satisfies proposition marked observe computation longer sequence markings computation sequence sets places safe case markings general place transition nets sets places anymore 
choice atomic propositions express place marked say number tokens contains 
unfortunately restricted expressive power model checking problems ltl ctl turn undecidable 
proof cases reduction problem known undecidable counter program counters initialised 
decide halts 
simulate counter programs net programs 
counter program obtain net program replacement counter command goto goto net program goto test goto test test goto test goto commands replaced 
net program simulates weaker sense section 
honest run exactly mimics unique execution executes command chooses branch runs cheat runs point choose wrong branch 
labels test test correspond places test program cheated executing conditional jump 
suppose exists temporal logic formula halt property satisfies halt honest execution halts 
honest run exactly mimics execution counter program satisfies halt halts 
problem deciding halt satisfied petri net undecidable 
follows model checking problem logics halt expressed undecidable 
construct ctl ltl simple formulas ltl halt ctl halt 
define formula cheat temporal operators 
cheat conjunction conditional jumps goto goto formulas test test run visits marking satisfying cheat know dishonest marking satisfies test conditional jump run taken branch test run taken branch 
define ltl halt cheat halt halt place net semantics corresponding halt commands 
run satisfies ltl halt point cheats halts 
satisfies ltl halt iff run satisfies ltl halt 
honest run doesn cheat satisfies ltl halt iff honest run halts 
formula ctl halt ctl halt af cheat halt just shorthand description petri net sense ask satisfies property formalised temporal formula 
follows immediately semantics formulae satisfies satisfies ltl halt 
formula ctl halt contains operator af fragment ctl extends propositional logic operators ef dual ag decidable 
unfortunately different proof shows case :10.1.1.1.9920
action case mentioned action case different state case rule thumb model checking problems interesting branching time action logics undecidable 
model checking problems interesting lineartime action logics decidable 
undecidability branching time logics action case immediate consequence fact unlabelled petri net formula state ctl labelled net formula action ctl satisfies satisfies net obtained labelling transitions label say adding place new transition having input place output place labelled formula obtained replacement atomic proposition ex true temporal operator ex ax ex fag ax fag fag fag respectively 
observe holds iff transition occur iff ex true holds 
technique prove undecidability model checking problem ltl problem decidable 
safe case modelchecking algorithm automata theory 
ltl formula build finite automaton buchi automaton 
exactly set computations satisfying formula 
action case automata alphabet act 
safe case net formula constructed automata 
exactly set computations violating formula 
general case proceed exactly way 
second step construct finite automata bn petri net essentially equal reachability graph net 
problem automata bn defined just safe case may infinitely reachable markings guaranteed finite 
solution problem easy constructing automata bn petri net construct labelled petri nets na nb automata obvious way places na states transition add transition na labelled input output place 
nb constructed analogously 
construct products na nb product petri nets petri net defined way set places union sets places pair transitions labelled action product contains transition labelled input output places union input output places results easy prove 
bn holds petri net nb run marks place corresponding final state infinitely 
holds petri net na reachable dead marking marks place corresponding final state finding run nb marks place set fs final places infinitely equivalent deciding exists firing sequence net nb fs denotes set places 
yen result introduced section problem solved exponential space size nb detailed analysis shows problem size pspace complete length 
finding dead reachable marking na marks place set fs final places reduced hard reachability problem 
exist far primitive recursive algorithms 
safe case results generalised logic translation automata theory holds :10.1.1.1.9920
equivalence problems undecidable section rule thumb negative flavour rule thumb equivalence problems petri nets undecidable 
rule supported nice result due showing equivalence notion trace bisimulation equivalence undecidable petri nets 
result clearly slightly different way 
proceed reduction problem result bit stronger bisimulation replaced finer equivalence 
counter program decide halts recall counters initialised 
known undecidable 
result directly constructing petri nets way proof goes prefer net programming language simple net semantics time language guarded commands 
program sequence instructions instructions expressions form guard action command guard action command guard action label action action actions guard special string true conjunction expressions form guards form allowed possible commands skip goto halt sequence assignments xn xn pairwise different 
operationally instruction executed follows guards evaluate true current state nondeterministically selected guard evaluates true program aborts 
things happen action selected guard sent environment command executed command contains assignment holds program aborts 
command jump goto execution continues instruction label command skip assignment execution continues instruction 
observer see actions executed program values variables label instruction currently executed 
guarded command programs easily translated labelled petri nets 
shows labelled net corresponding instruction true goto true halt assume instruction program labelled 
place variable label plus special place halt 
transition alternative labelled alternative action 
semantics program obtained merging places nets corresponding instructions carrying label 
identify program corresponding labelled petri net 
particular programs trace bisimulation equivalent corresponding labelled nets 
counter program construct net programs satisfying properties halts trace equivalent halt fig 

net corresponding instruction halt bisimilar 
proof properties useful characterise trace bisimulation equivalences terms person games 
describe features common trace bisimulation games 
board games programs initial states 
games played players alice bob alternate moves 
alice move 
move execution alternatives instruction named action corresponding executed alternative 
move execution alternative form guard command 
alice move programs bob answer move program 
may help intuition imagine alice wishes programs non equivalent bob wishes equivalent 
winner game decided follows alice move available bob wins bob answer alice move alice wins game terminate bob wins 
find idea non terminating game awkward think chess move rule 
position kings board reached game goes forever 
trace bisimulation games situation draw win bob 
bob wins infinite time game tedious problem winning condition defined game winner 
describe differences trace bisimulation games surprisingly small 
trace game alice chooses programs game moves program bob moves program 
bisimulation game alice chooses programs move move program 
instance bisimulation game alice move program bob answer second second move second program bob answer 
strategy player function gets list moves played far yields player move 
strategy winning player sticks wins games 
nice result see instance case trace game intuitively plausible trace bisimulation games alice winning strategy programs equivalent bob winning strategy programs equivalent 
properties constructed satisfy reformulated follows halts alice winning strategy trace game halt bob winning strategy bisimulation game 
time start definition 
things bit simpler assume loss generality counter program contains single halt instruction instruction 
programs look follows program start true start halt halt halt program start true start halt halt halt program defined 
observe programs differ instruction 
instruction executed 
program obtained replacing command unique halt command instruction new language 
instructions corresponding assignments jumps replaced true replaced true dec goto replaced true jump goto conditional jumps delicate part 
command form goto zero goto nonzero replaced sequence instructions halt instructions replace jumps new label program place unique halt command 
nonzero goto nonzero true zero skip zero zero true zero goto zero completes description 
going observe program honest run mimics execution looks follows executes command executes corresponding instruction 
command conditional jump takes nonzero branch chooses nonzero alternative corresponding instruction takes zero branch chooses zero alternatives true zero skip executes goto zero instruction 
important difference 
assume execute start action followed honest execution 
honest execution terminates execute halt action set start action execute value 
ready describe winning strategies alice bob different games 
assume halts 
strategy alice trace game 
alice chooses play bob forced play 
alice sticks sequence moves completely disregarding bob answers plays start move continues moves honest execution honest run terminates finishes halt move 
show place alice follows strategy second move bob forced play exactly moves alice exactly alternatives commands 
alice plays nonzero move bob answer unique nonzero move case easy 
alice plays zero move bob choose zero answers true zero skip zero zero remember alice playing honest run plays zero move 
alice plays zero move bob observes guard evaluates false move true zero skip 
see alice strategy winning 
halts honest run terminates eventually alice plays halt move 
game bob patiently incidentally observe alice play halt set start move touched honest execution 
repeated alice moves waiting chance efforts vain reply alice halt move program variable value guard halt move evaluates false 
bob loses 
assume halt 
strategy bob bisimulation game 
alice play start move programs bob just replies start move program 
long alice plays honest run possibly switching programs bob patiently repeats moves program 
alice deviates honest run playing zero zero programs bob replies true zero skip program 
alice deviates honest run playing true zero skip programs point bob replies zero zero program depending guard enabled 
move bob goes playing exactly moves alice 
see bob wins games 
alice sticks honest execution halt plays halt move moves mimicked bob problems game terminates win bob 
alice chance win deviate honest run point 
observe just deviating 
show deviating alice grave allows bob reply way move variables exactly value 
bob wins easily playing moves alice 
alice deviate honest run different ways 
play zero bob replays true zero skip programs 
play zero choice anyway 
observe exactly guards enabled start action assertion true actions keep assertion invariant 
bob reply programs 
play true zero skip state bob reply programs depending answer 
partial order equivalences undecidable mentioned section literature contains called partial order equivalence notions fit trace bisimulation equivalence 
result apply 

say transitions concurrently enabled marking place say petri net sequential reachable marking enables transitions concurrently 
easy see petri nets constructed sequential 
just proved equivalence relation fits trace bisimulation equivalence class sequential petri nets undecidable 
partial order equivalences turn fit trace bisimulation equivalence sequential nets 
expect partial order equivalences distinguish concurrency interleaving concurrency distinguish 
done polynomial time 
general hardness bound section raises question better results pspace np polynomial problems classes place transition petri nets 
complete treatment question scope concentrate far go polynomial algorithms 
obviously expect go safe petri nets 
question problems conflict free nets free choice nets necessarily safe solved polynomial time 
answer qualified 
contain polynomial algorithms conflict free petri nets important problems classes np hard 
instance reachability problem conflict free petri nets np complete liveness problem free choice petri nets np complete complement np complete problem proof sketched solution story 
notice liveness reachability problems arbitrary petri nets harder np completeness results seen positive results 
interesting constraint leading polynomial algorithms problems essentially single non trivial place exactly input transition exactly output transition exactly generalised petri nets satisfying constraint called marked graphs synchronisation graphs systems 
oldest papers net theory show problems nets solved simple graph algorithms linear programming 
formulate rule thumb rule thumb interesting problems marked graphs solvable polynomial time 
interesting problems petri net classes substantially larger marked graphs solvable polynomial time 
solution story non liveness problem free choice petri nets formulated follows free choice petri net decide non live 
membership np non trivial follows theorem 
contrary easy prove reduction satisfiability problem boolean formulas conjunctive normal form 
shows petri net corresponding formula explain construction example 
loosely speaking petri net works follows variables nondeterministically assigned truth values firing transition variable variables assigned value transition enabled assignment clause false 
instance enabled transitions fired corresponds assignment false true false assignment making false 
place false gets tokens formula false assignment 
formula satisfiable assignment making formula true assignment place false gets marked 
petri net live 
contrary formula unsatisfiable place false get marked net live 
formula satisfiable petri net non live 
conclude listing rules thumb 
find table 
allowed suppress word interesting rules longer lead confusion 
acknowledgments eike best peter ernst mayr richard mayr peter thiagarajan antti valmari frank wallner helpful suggestions discussions informations 
serge haddad mistake version appeared lncs programs section incorrect 
suggested correct programs version 
mistakes 
ctl section joint peter 
interesting compare reduction section 
false fig 

petri net corresponding formula rules thumb 
questions behaviour safe petri nets pspace hard 

nearly questions behaviour safe petri nets solved polynomial space 

equivalence problems safe petri nets harder solve model checking problems 
need exponential space 

questions behaviour acyclic safe petri nets np hard 

questions safe conflict free petri nets solvable polynomial time 
questions live safe free choice petri nets solvable polynomial time liveness safe free choice petri nets decidable polynomial time 
questions safe net classes substantially larger free choice petri nets solvable polynomial time 

questions behaviour petri nets expspace hard 

model checking problems petri nets state logics undecidable 

model checking problems petri nets branching time action logics undecidable 
model checking problems petri nets linear time action logics decidable 

equivalence problems petri nets undecidable 

questions marked graphs solvable polynomial time 
questions petri net classes substantially larger marked graphs solvable polynomial time 
table 


structural complexity volume monographs theoretical computer science 
springer verlag 

cheng esparza palsberg 
complexity results safe nets 
theoretical computer science 

holt pnueli 
marked directed graphs 
journal computer system sciences 

dam 
fixpoints buchi automata 
proceedings th international conference foundations software technology theoretical computer science volume lecture notes computer science pages lfcs report ecs lfcs university edinburgh 

desel esparza 
free choice petri nets volume cambridge tracts theoretical computer science 
cambridge university press 

emerson 
temporal modal logic 
handbook theoretical computer science volume pages 

esparza 
model checking net unfoldings 
science computer programming 

esparza 
reachability live safe free choice petri nets np complete 
technical report sfb bericht nr 
technische universitat munchen 
appear theoretical computer science 

esparza 
decidability model checking infinite state concurrent systems 
acta informatica 

esparza nielsen 
decidability issues petri nets survey 
bulletin eatcs volume pages journal information processing cybernetics 

formal methods page www virtual library www comlab ox ac uk archive formal methods html notations 

garey johnson 
computers intractability guide theory np completeness 
freeman 



acta informatica 


complexity linear time mu calculus petri nets 
balbo editors application theory petri nets volume lecture notes computer science pages 
springer verlag 

hack 
analysis production schemata petri nets 
thesis cambridge mass mit dept engineering 

hopcroft ullman 
automata theory languages computation 
addison wesley 

howell 
questions fairness temporal logic conflict free petri nets 
rozenberg editor advances petri nets volume lecture notes computer science pages 

howell 
algorithm decide boundedness vector replacement systems 
information processing letters 

howell 
problems concerning fairness temporal logic conflict free petri nets 
theoretical computer science 

howell yen 
taxonomy fairness temporal logic problems petri nets 
theoretical computer science 


action behavioural equivalences undecidable labelled petri nets 
bulletin eatcs 


undecidability bisimilarity petri nets related problems 
theoretical computer science 

jategaonkar meyer 
deciding true concurrency equivalences safe finite nets 
theoretical computer science 

jones landweber lien 
complexity problems petri nets 
theoretical computer science 

kosaraju 
decidability reachability vector addition systems 
th annual acm symposium theory computing pages san francisco 

lamport 
mutual exclusion problem 
part ii statement solutions 
journal acm 

lipton 
reachability problem requires exponential space 
technical report yale university 

mayr 
algorithm general petri net reachability problem 
siam journal computing 

mayr meyer 
complexity word problems commutative semigroups polynomial ideals 
advances mathematics 

www page petri net tools www daimi aau dk tools 

rabinovich 
complexity equivalence problems concurrent systems finite agents 
information computation 

rackoff 
covering boundedness problem vector addition systems 
theoretical computer science 


analyse von petri modellen 
teubner 

stirling 
bisimulation model checking games 
notes instructional meeting games computation edinburgh june 
available www dcs ed ac uk home cps 

valmari 
state space generation efficiency practicality 
phd thesis tampere university technology 

van glabbeek 
linear time branching time spectrum 
proceedings concur volume lecture notes computer science pages 

vardi 
automata theoretic approach linear temporal logic 
logics concurrency structure versus automata volume lecture notes computer science pages 

yen 
unified approach deciding existence certain petri nets paths 
information computation 

yen 
polynomial time algorithm decide pairwise concurrency transitions bounded conflict free petri nets 
information processing letters 
