limits parallel computation limits parallel computation completeness theory raymond greenlaw university new hampshire james hoover university alberta walter ruzzo university washington new york oxford oxford university press book dedicated families know life inherently sequential 
preface book rapidly growing theory branch complexity theory focuses identifying hardest problems class problems solvable polynomial time 
complete problems interest appear lack highly parallel solutions 
algorithm designers failed find nc algorithms feasible highly parallel solutions take time polynomial logarithm problem size polynomial number processors 
consequently promise parallel computation applying processors problem greatly speed solution appears broken entire class complete problems 
state affairs succinctly expressed question equal nc organization material book organized parts theory catalog complete open problems 
part book thorough theory completeness 
informal 
discuss major parallel models computation describe classes nc notions reducibility completeness 
subsequently introduce fundamental complete problems followed evidence suggesting nc equal discuss detail primary complete problem evaluating boolean circuit 
examine sequential paradigms parallel versions 
describe model classifying algorithms inherently sequential 
finish part general practical parallel computation 
viii preface broad range topics rapidly growing field parallel computation unable provide detailed treatment related topics 
example unable discuss parallel algorithm design development detail 
important broad topics provide reader available literature 
second part book provides comprehensive catalog complete problems including unpublished new results 
problem try provide essential idea underlying complete reduction information additional related problems possible 
addition complete problems catalog provide list open problems list problems class cc list problems class rnc book course book designed suitable text semester graduate course covering topics parallel computation 
part book provides introductory material problems easily converted numerous exercises 
book ideal seminar course focusing completeness theory 
supplementary text graduate level course complexity theory 
chapters book covered graduate level course book courses theory computation 
rich source sample problems variety different courses 
motivated student researcher interested learning completeness book effectively self study 
additional problems corrections producing book period years tried accurate thorough possible 
undoubtedly errors omissions lists problems 
anticipation possible correct errors incorporate additional problems 
welcome suggestions corrections new problems 
complete problems interested papers provide preface ix best known parallel algorithms problem 
please send general comments corrections new problems bibliography entries copies relevant papers ray greenlaw greenlaw cs unh edu additions directory pub hoover complete ftp cs ualberta ca world wide web jim hoover home page research support www cs ualberta ca authors gratefully acknowledge financial support organizations ray greenlaw research supported part national science foundation ccr 
jim hoover research supported natural sciences engineering research council canada ogp 
larry ruzzo research supported part nsf ecs ccr ccr nsf darpa ccr 
portion performed visiting university toronto hospitality gratefully acknowledged 
acknowledgments extra special martin tompa helped keep project alive close dying 
martin provided useful suggestions years helped better book 
special anne condon alex sch carefully reading drafts book 
suggestions helped improve specific sections 
wish contributing new problems pointing appropriate literature providing corrections suggestions drafts manuscript richard anderson jos zar david barrington paul beame erik anne condon stephen cook derek corneil de la torre larry sergio de agostino john ellis arvind gupta john preface hershberger david johnson marek karpinski tracy dexter kozen luc mike luby jon andrew pierre mckenzie satoru miyano christos papadimitriou teresa john reif alex sch roger simons jack snoeyink paul spirakis iain stewart larry stockmeyer ashok subramanian eva tardos shang hua teng martin tompa joachim von zur gathen thomas 
want reviewers provided general comments organization book detailed comments 
tried incorporate suggestions possible feasible 
want don jackson oxford university press 
don helpful step production book great person 
mike garey david johnson book computers intractability guide theory np completeness served model 
november ray greenlaw jim hoover larry ruzzo preface xi authors addresses raymond greenlaw department computer science university new hampshire durham nh mail address greenlaw cs unh edu world wide web home page www cs unh edu james hoover department computing science university alberta edmonton alberta canada mail address hoover cs ualberta ca world wide web home page www cs ualberta ca walter ruzzo department computer science engineering fr university washington seattle wa mail address ruzzo cs washington edu world wide web home page www cs washington edu contents preface vii part background theory design informal background feasible highly parallel inherently sequential problems completeness important 
history related works overview book parallel models computation pram model boolean circuit model uniform circuit families circuits prams complexity search decision problems complexity classes nc fp fnc classes nc fnc random nc reducibility reducibility xiv contents turing reducibility nc compatible nc turing reducibility logarithmic space reducibility completeness basic complete problems generic complete problem circuit value problem evidence nc equal general simulations fast fast simulations general natural approaches provably fail summary circuit value problem circuit value problem complete restricted versions circuit value greedy algorithms lexicographic greedy algorithms generic greedy algorithms complete algorithms inherently sequential algorithms applications model notions completeness strong completeness strict completeness approximating complete problems approximating hard approximation schemes closing remarks contents xv part ii compendium problems complete problems circuit complexity graph theory searching graphs combinatorial optimization local optimality logic formal languages algebra geometry real analysis games miscellaneous open problems graph theory combinatorial optimization logic formal languages algebra geometry real analysis cc rnc notation complexity classes definitions relationships complexity classes bibliography problem list index part background theory chapter design subject book best illustrated scenario 
suppose employed halls industry 
decade ago entered highly competitive market 
companies thought design intractable problem spent millions supercomputers search possible designs foresight employ theoretical computer scientists 
discovered feasible algorithm designing directly specification 
take word specification steps test specification reasonable design optimal meets 
algorithm typical word specification takes month design 
construction takes week design dominates building process 
competitors hand fast algorithm producing optimal designs 
best exhaustive search approximately possible different designs meet specification looking best 
exhaustive search typical size specification take say years assuming design microsecond 
fleet creature dangerous propensities immune fast flee vaguely suggest creature qualities 
lewis carroll looking glass 
chapter 
competitors content suboptimal designs produce time 
yesterday 
seeing value research competition formed consortium invested computer science 
discovered feasible optimal design algorithm 
design dominates production process decide way regain competitive advantage reduce design time 
give task dramatically speeding design process 
modern computer scientists working problem reading news net 
day ad catches eye 
speed 
single processor slow 
machine mark parallel computer just 
matter problem solve faster mark processors working parallel 
fact promise processors reasonable problem run exponentially faster machine 
send mail information 
machine trade processors speed sensing corporate orders machines 
arrives unpack discover architecture simple 
large collection identical processors attached large shared memory 
processors read write simultaneously shared memory essentially unit cost 
input output performed loading data memory computation reading afterward 
decide try simple problem occurs design items sort keys 
algorithm uses simple divide conquer strategy 
divide items evenly processors sort subset processor merge 
sure 
design processors parameterize algorithm number processors function number items lots processors long small polynomial exhaust capacity new machine 
order processors rate expansion reasonable 
assume items sorted shared memory stored locations labeled 
xn 
phase algorithm assigns disjoint equal size subsets items subset processor 
second phase processor parallel sorts subset sequential algorithm time log 
final phase merge sorted subsets ordered set items 
complicated part algorithm 
idea simultaneous merges pairs subsets items increasingly larger ordered subsets 
stage uses processors merge pairs subsets size 
stage uses processors merge pairs subsets size 
final stage uses processor merge pair subsets size 
merge done sequentially turns time stage dominates phase algorithm time 
adding times phases algorithm get asymptotic terms parallel sort processors takes time log actual performance parallel algorithm depends 
constant independent time simplifies log asymptotically faster sequential case 
consider happens number processors small relative problem size log case time simplifies log note parallel sort exhibits optimal speedup sense number processors parallel time sequential time 
unfortunately algorithm exceeds log time simplifies additional processors help little 
discouraging obtain speedup produce dramatic reduction sorting time 
chapter 
certainly kind exponential reduction promised ad 
able sort items log time steps happy polynomial version log 
thinking bit problem sorting realize essence compute position rank item final sorted list 
items stored locations 
xn ranks 
rn parallel step processors rearrange items having processor assignment xi assuming items distinct 
ranking done independently item 
time compute rank item time compute rank item 
time sort reduce time rank item 
realize ranking quickly processors 
lots unreasonable number apply problem sorting large set 
ranking algorithm phases 
processor assigned pair processor determines value stored location xi greater stored xj stores location ci 
second phase item processors 
compute sum ci sum rank item stored ri 
sum computed processors mimic fast addition tree 
ranking takes log time 
processors new algorithm sort items time log 
dramatic speedup exponential kind promised ad 
summarize discoveries table 
suffice story visit local university library assuming closed latest wave budget reductions uncover better parallel sorting algorithms see leighton example 
success sorting go develop fast parallel algorithms problems 
notice solutions common characteristics polynomial number processors polylogarithmic running time 
input size algorithms nk processors take time log constants algorithms feasible sense poly 
design algorithm processors time sequential sort log naive divide log log log conquer sort log parallel ranking log table summary sort subroutines 
nomial numbers processors highly parallel sense running times polynomial log polylogarithmic short 
notice problems polynomial time sequential algorithms feasible sequential solutions 
formulate question 
problem feasible sequential solution feasible highly parallel solution 
confidence gained initial successes developing parallel algorithms core design problem 
weeks office filled develop fast parallel algorithm design 
appears design problem contains inherently sequential component defeats sophisticated algorithmic tricks obtaining highly parallel computations 
faced prospect announcing failure boss 
discussing troubles colleague lunch observes need theory parallel computation similar theory npcompleteness sequential computation 
theory showing problem np complete evidence fast exact sequential algorithm probably possible 
similar method show fast parallel algorithm probably possible 
fortunately colleague just read book 
need says show design complete 
doing showing probably inherently sequential fast parallel solution instance prob chapter 
lem probably possible 
evidence go boss suggest design problem relaxed somewhat interest speed sense continue employment 
informal background book distinguished ancestor computers intractability guide theory np completeness garey johnson published complexity theory part algorithm designer toolkit 
today graduating computer scientist aware problems worst case time complexity class feasible solutions problems np complete probably difficult solve general 
accordingly relegated standard definitions appendix concentrate formal definitions basic notions relevant parallel computation 
embarking detailed treatment introduce material informal way 
feasible highly parallel inherently sequential problems general rule want algorithms feasible 
feasible mean ability solve desired instances problem available resources 
practice feasibility dependent context particularly portable different problems situations 
common principle holds situations exponential growth rate consumption resource required computation limits application method smallest instances 
feasibility come mean growth rate resource bounded polynomial input size 
gives common notion problem feasible sequential solution polynomial time algorithm size instance problem solved time widely acknowledged simplistic dichotomy polynomial time algorithms proved powerful discriminator computations feasible practice 

informal background broad notion applies parallel computations processors considered resource 
consider parallel algorithm feasible find solutions size problem instances time processors 
definition feasibility universally accepted primarily hardware appears qualitatively different resource time 
allowed polynomial numbers processors allowed 
compelling justification polynomial notion processor feasibility comes considering involved trading processors speed 
parallel computation provides potential achieving qualitative change time required solve problem reducing polynomial sequential time parallel time 
goal parallel computation develop algorithms reasonable number processors extremely fast 
regardless number processors available goal fundamentally limited speedup equation best sequential time number processors parallel time 
obvious consequence achieve time algorithm polynomial number processors 
term highly parallel sense willing invest conceptually number processors roughly equal best sequential time algorithm 
constitutes reasonable number processors fast remain debatable issues 
tend think time easily obtainable resource sense machine capable arbitrary amounts time willing wait 
handle bigger problem simply algorithm run longer 
clearly case processors 
machine finite add processors means acquire integrate interconnection network machine 
glance unreasonable entertain model number processors fixed 
closer inspection viewpoint instructive 
useful analogy memory requirements sequential complexity theory 
reality computers memories fixed finite size 
virtual memory may stretch bound bit chapter 
practice budget permitting memory chips bought installed fundamentally memory fixed resource quantity subject algorithmic control 
hard reality proved fruitful study space complexity algorithms space time arbitrarily flexible commodity 
patently unrealistic assumption theory wrong irrelevant just means application theory slightly indirect 
space consumption algorithm problem exceeds available memory usually mean jog corner hardware store buy 
means scale back problem size expect solve find better space efficient algorithm 
similarly fruitful view processor requirements parallel algorithms growing functions machines flexible viewpoint allows focus important intrinsic issues parallel decomposition problems able translate insights answers pragmatic questions big problem solve amount time number processors debate appropriate models undoubtedly continue 
opinions related issues sanz 
fortunately ignore debate concerned problems apparently time feasible parallel algorithms 
words highly parallel problems appear inherently sequential reasonable model parallel computation 
creating controversy adopt informal definitions 
problem feasible solved parallel algorithm worst case time processor complexity problem feasible highly parallel solved algorithm worst case time complexity log processor complexity problem inherently sequential feasible feasible highly parallel algorithm solution 
note class feasible parallel problems synonymous class terms interchangeably 

informal background completeness important 
faced problem appears inherently sequential 
demonstrate single instance problem solution parallel algorithm requires log time 
bad instance provide lower bound worst case time complexity problem 
unfortunately nontrivial lower bounds notoriously difficult establish 
fact know provably inherently sequential problem 
alternative approach understanding difficulty problem usual experience problem solving 
rarely solve problem scratch 
usually attempt break problem subproblems know solve answers suitably combined give solution original problem 
reduce original problem simpler ones know solve 
example introductory scenario reduced problem sorting set items problem computing rank item set 
absence absolute lower bound exploit idea reduction counter normal problem solving role establish relative lower bounds 
suppose worked highly parallel algorithms solving problem failed 
general unproven consensus problem inherently sequential 
suppose working new problem know feasible seek fast parallel algorithm 
small amount fail show highly parallel solution suspect inherently sequential 
unfortunately small efforts hardly convincing evidence difficulty just slow seeing parallel solutions 
suppose observe hard problem reduced case inherent sequentiality follows difficult solve solve resisted numerous attempts experts 
strongly argue difficulty provably inherently sequential reduction irrefutable proof inherently sequential 
answer depends reduction performed 
usually describe reduction terms algorithm calls procedure solving complexity reduction chapter 
defined complexity reducing algorithm assumption cost procedure calls solving significant 
reduction highly parallel highly parallel algorithm translate highly parallel algorithm contradict inherent sequentiality inherently sequential 
argument fail reduction merely feasible accomplished polynomial time sequential algorithm 
case reduction composed solution produce highly parallel algorithm unfortunately proof inherent sequentiality exists fact reducible weak case difficulty reducing fact route better parallel algorithm solving weakness argument lies fact reduced specific problem suppose capture nature seemingly inherently sequential problems 
problem reducible argument favoring difficulty stronger 
example finding highly parallel solution imply inherently sequential problems 
way showing contains important characteristics problem inherently sequential prove feasible problem reduced highly parallel reduction 
inherently sequential problem feasible definition show inherently sequential problems 
equivalently shows highly parallel solution inherently sequential problems 
show problem having feasible sequential algorithm transformed instance problem established complete class feasible parallel problems 
complete leave details reductions completeness chapter remarks implications establishing body complete problems order 
time shows problem complete get larger body problems diverse equivalent difficulty 
entire body complete problems provides rich characterization difficult parallel problems 
hope common essence inherent sequentiality extracted 
history collection 
optimistically hope show fact inherently sequential 
algorithm designer important implication guiding search parallel solutions 
particular difficult problem component larger problem 
knowing subproblem complete strongly suggests decomposition larger problem reformulated 
example linear programming problem maximum flow problem maximum matching problem play role key subroutines solution complex combinatorial optimization problems 
problems complete feasible highly parallel probabilistic algorithm 
algorithm designer seeking highly parallel solution novel combinatorial optimization problem advised avoid formulating solution terms linear programming maximum flow subproblems cast matching problem 
alternatively may particular instances wishes solve weaker general complete problem may highly parallel solutions 
example linear programming maximum flow complete restrictions variable linear programming problem maximum flow problem highly parallel solutions 
additionally completeness theory guide algorithm designers cases particular function highly parallel solution certain algorithmic approaches computation amenable solutions 
computing breadth level numbers queue versus stack algorithms example see chapter details 
history notion completeness appeared roughly time np completeness different reason 
motivation study relationship sequential time space 
particular cook raised question computable polynomial time polylogarithmic space 
motivation ask turing machine running time general simulated operating space log cook answer question chapter 
conference show question equivalent question single specific language path systems problem recognized space log showed path systems complete obtaining completeness result 
fundamental complete problems reduction cook gave generic simulating polynomial time bounded turing machine path systems specific case 
exact relationship polylogarithmic space remains open know polylogarithmic space equal see johnson details 
space complexity focus cook space bounded form reduction logarithmic space reduction independently introduced cook jones stockmeyer meyer 
required algorithm accomplishing reduction restricted log space inputs length subsequent followed lead parallel time bounded reductions discussed section introduced 
discuss reductions detail chapter 
year cook jones galil complete problems motivated issue polynomial sequential time versus polylogarithmic space 
ladner showed circuit value problem cvp complete 
savage shown turing machine time bound simulated boolean combinational circuit size 
ladner proof observation transformation turing machine circuit accomplished logarithmic space 
ladner remarked cvp provided simple example complete language type identified galil 
goldschlager showed restricted monotone planar versions cvp complete 
cvp variants turned useful complete problems discussed extensively chapters 
results established relationship polynomial time sequential computations parallel model polynomial size circuits 
time period numerous parallel models computation introduced evidence accumulating pippenger fischer improved result size log depth 

history parallel computation thesis states sequential space polynomially related parallel time 
words computed sequential space computed parallel time vice versa 
thesis appeared chandra stockmeyer 
stated elaborated goldschlager 
addition goldschlager dissertation place connection complete problems problems parallelize 
light parallel computation thesis complete problems solved polylogarithmic time parallel problem solved polylogarithmic space 
weakness parallel computation thesis standpoint formally capturing notion feasible parallel computation fast parallel simulation sequential log space came expense superpolynomial number processors 
similarly log depth circuit required superpolynomial time simulate small space sequential machine 
borodin raised question sharpening parallel computation thesis consider simultaneous resource bounds 
example class problems simultaneously polynomial time polylogarithmic space equivalent class simultaneously polynomial numbers processors polylogarithmic parallel time 
pippenger answer question directly showed similar simultaneous resource bounds fact hold turing machine time reversals compared circuit size depth turing machine time space compared circuit size width 
important contribution borodin introduce notion uniformity conditions construction families circuits 
various notions uniformity subsequently explored allender barrington immerman goldschlager pippenger ruzzo 
considerable interest raised class problems polylogarithmic time polynomial size circuits originally due nick pippenger 
cook indicates pippenger studied types circuits visit university toronto 
prompted naming class cook nick class nc short 
question chapter 
feasible problems highly parallel algorithms succinctly stated equals nc flurry works soon appeared showing various polynomial time sequential algorithms corresponding nc algorithms 
goldschlager shaw staples authors state importance completeness parallel setting 
usual completeness arguments problems defy attempts place nc issue sequential computation transformed parallel reduction changed sequential logarithmic space parallel nc 
render previous logarithmic space reductions obsolete borodin showed log space computation simulated log depth size transitive closure circuit 
reduction nc cases direct depth efficient reductions exist 
phrase inherently sequential frequently connection hard parallelize problems appeared reif entitled depth search inherently sequential 
explosion results parallel computation book necessary 
note early papers applied term complete called np complete problems 
additionally term complete domain involving projections see example valiant ger szemer di 
related works goal book provide comprehensive overview theory completeness 
sheer size subject unable cover important aspects parallel computation detail 
topics parallel algorithm design analysis warrant books 
list topics 
intention complete simply note familiar 
book efficient parallel algorithms gibbons rytter brief discussion parallel models computation followed substantial material parallel algorithms 
short 
overview book chapter describing completeness 
book parallel algorithms devotes chapter discussing parallel models extensively parallel algorithms 
book brief section completeness 
large parallel algorithms architectures arrays trees hypercubes leighton contains detailed discussion different types parallel models algorithms 
synthesis parallel algorithms edited reif contains chapters organized parallel algorithms particular types problems introductory chapter greenlaw surveying pram models 
chapter parallel algorithms shared memory machines karp ramachandran handbook theoretical computer science describes variety highly parallel algorithms shared memory machines 
handbook chapter catalog complexity classes johnson thorough overview basic complexity theory current state knowledge complexity classes 
excellent establishing context class established relationships 
miyano surveys theory providing catalog known complete problems 
papers lenstra provide extensive bibliographies papers parallel algorithms parallel algorithm development combinatorial optimization problems 
overview book remainder book organized main parts 
part devoted theory completeness 
second part compendium complete open problems 
part directed reader may familiar notions np completeness parallel computation seen completeness theory 
reader familiar topics probably find skipped 
part chapter 
divided chapters 
chapter introduces main models parallel computation parallel random access machine pram uniform boolean circuit family 
chapter gives precise complexity class definitions notions feasibly parallel inherently sequential problems formalizes notions reducibility completeness 
chapter deals prototypical hard problems parallel computation generic machine simulation circuit value problem 
chapter discusses evidence suggesting complete problems sense inherently sequential chapter addresses original circuit value problem described ladner detail giving restricted versions complete 
chapter examines greedy algorithm simple sequential paradigm gives rise complete problems 
chapter motivated experience greedy algorithm presents model deals inherently sequential algorithms 
chapter introduces notions strong strict 
chapter discusses approximations complete problems 
chapter provides wrap part book addresses developments contains 
part ii book contains collections problems appendix open problems appendix part self contained possible provide definitions background material problem 
cases provide brief sketch completeness reduction 
sketch reader familiar completeness theory able deduce full reduction necessary track original 
addition number reductions previously unpublished appear time 
various notations collected appendix complexity classes briefly defined appendix chapter parallel models computation discuss difficulty solving problem choose suitable machine model describe computations 
machine model parameterized description class machines 
machine class obtained model giving specific values parameters 
example turing machine specified giving number tapes symbol set program 
choice model depends wish balance factors simplicity generality historical novelty plausibility actual implementation ease programming 
flexibility inevitably leads proliferation different models parallel computation exception tendency diversity 
parallel models includes bit vector machines pratt stockmeyer boolean circuits borodin parallel random access machines prams fortune wyllie goldschlager prams savitch alternating turing machines chandra kozen stockmeyer parallel pointer machines cook cook aggregates goldschlager large variety machines fixed interconnection networks grids hypercubes shuffle exchange see leighton 
variety difficult compare competing models 
chapter 
parallel models computation qualitative level models distinguished processor granularity interconnection pattern 
important distinction models granularity treat parallel operations 
model fine grained treat bit operations basic unit parallel computation coarsegrained example treat local subcomputations processors fundamental unit 
addition model structured case machine manipulate atomic data objects access representations bits example 
important qualitative difference models nature communications processing elements 
models allow unrestricted communication processing elements time 
models require fixed communication pattern 
models charge communication pathway elements kinds qualitative distinctions difficult precise useful way comparing models mutual simulation 
machine model simulated machine model know problem solvable model machine solvable model machine 
need know resources model compare model fortunately despite diversity models parallel model computational resources correspond intuitive notions running time processing hardware 
enables compare simultaneous time processor requirements machine model simulation model vice versa 
requirements roughly consider models essentially equivalent 
feasible highly parallel computations parallel models equivalent polynomial time hardware resources simultaneously 
mean size instances problem solved time log processors machine model exists machine model solve size instances problem time processors 
problem feasibly highly parallel model models theory completeness robust insensitive minor variations computational model 
parallel models possess property described 

pram model models limited interconnection schemes weak simulate models 
example tree connected parallel machine processors communicate short paths bottleneck root limits bandwidth communication processors 
mesh connected parallel machine communicate directly neighbors results average path length processors see leighton 
hand models parallel computation simply powerful simulated common models 
includes machines generate exponentially long values activate exponential numbers processors polylogarithmic time 
discussion relationships various models excellent surveys cook karp ramachandran 
additional papers surveying aspects parallel models parallel computing include johnson lenstra spirakis van emde boas vishkin 
choice model relatively unimportant discussion inherently sequential problems chose simply basis convenience 
high level discussions preferred model parallel random access machine pram 
concerned detailed questions implementability small resource bounds low level uniform boolean circuit model 
models subsections 
pram model sequential algorithm design favorite model computation random access machine ram 
ram consists computation unit fixed user defined program read input tape write output tape unbounded number local memory cells 
cell capable holding integer unbounded size 
computation unit simple 
operations moving data memory cells directly indirectly comparisons conditional branches simple arithmetic operations add subtract multiply divide 
ram program sequence instructions 
execution starts instruction ends halt instruction encountered 
typically operations ram model assessed unit chapter 
parallel models computation cost regardless length numbers manipulated operation 
usual complexity measures interest ram computations time form number instructions executed space form number memory cells accessed 
prevent notion time distorting notion feasibility model prohibits fiat careful choice instruction set rapid generation large numbers 
example model prohibit numbers superpolynomial length generated tested polynomial time 
aside considerations power ram model essentially unchanged broad range variations instruction set 
natural generalization ram model parallel computation parallel random access machine introduced independently fortune wyllie goldschlager 
pram model consists collection ram processors run parallel communicate common memory 
basic pram model consists unbounded collection numbered ram processors 
unbounded collection shared memory cells 
processor pi local memory knows index instructions direct indirect read write access shared memory 
tapes inputs outputs computation placed shared memory allow concurrent access 
instructions executed unit time synchronized active processors 
typical pram instruction set table addressing modes described table 
note simple machine local memory cell serves accumulator read write shared memory occurs instruction 
observe multiply divide instructions take constant operand order prevent rapid generation testing large numbers 
important technical issues dealt model 
manner finite number processors potentially infinite pool activated computation 
common way unstated literature processor special activation register specifies maximum index active processor 
non halted processor index smaller value register execute program 
initially processor active sus 
pram model instruction description move data cells ident load processor number const load constant add add contents sub subtract contents mult multiply contents constant div divide contents constant truncate goto branch instruction branch instruction contents halt execution processor table sample pram instructions 
address description ri ci cri address local cell ri local cell address contents ri address shared cell ci shared cell address contents ri table sample pram addressing modes 
waiting execute instruction 
computes number processors required computation loads value special register 
computation proceeds halts point active processors halt 
goldschlager model example pram convention 
common approach example fortune wyllie pram active processors explicitly activate new ones fork instructions 
issue relatively little difference power model provided numbers allowed grow quickly 
chapter 
parallel models computation second technical issue concerns way simultaneous access shared memory arbitrated 
models assumed basic instruction cycle separates shared memory reads writes 
pram instruction executed cycle phases 
read shared memory performed computation associated instruction done write shared memory performed 
eliminates read write conflicts shared memory eliminate access conflicts 
dealt number ways including crcw pram concurrent read concurrent write pram permits simultaneous reads writes memory cell 
method arbitrating simultaneous writes cell required 
example priority version write lowest numbered contending processor succeeds 
goldschlager model type 
common version write succeeds processors writing value arbitrary version writes succeeds 
crew pram concurrent read exclusive write pram permits simultaneous reads memory cell processor may attempt write cell 
fortune wyllie model type 
crow pram concurrent read owner write pram commonly occurring restriction crew pram 
owner common memory cell 
simultaneous reads memory cell allowed owner write cell 
restriction ensures exclusive write access 
model introduced ruzzo 
erew pram exclusive read exclusive write pram requires processors simultaneously access memory cell 
variants pram deterministic arbitrary crcw pram 
model possible repeated executions identical inputs result different outputs 
taxonomy originates vishkin 
see depth discussion pram models 
pram computation specific time 
pram model hardware resources 
complexity measure corresponding time simply time taken longest running processor 
measure corresponding hardware maximum number active processors computation 
standard pram model crew pram processor activation register processor 
means processor guaranteed run duration computation largest value activation register upper bound number processors 
note explicit accounting local shared memory computation 
pram prevented generating large numbers log number may exceed bits steps computation time processors store pt bits information 
purposes adequately characterize memory requirement computation need parameterize separately 
compare models introduce notion reduction important identify mean computation machine 
means specifying inputs provided computation outputs extracted cost computation accounted 
prams adopt conventions 
definition pram 
input output conventions follows 
input placing integer shared memory cell bits 
xn shared memory cells 
cn 
displays output similarly integer shared memory cell bits 
ym shared memory cells 
cm 
computes parallel time processors input machine halts time steps activates processors presents output computes sequential time computes parallel time processor 
conventions place having decided version pram model computations talk function computed parallel time processors 
chapter 
parallel models computation definition function function computable parallel time processors pram input outputs time processors 
various pram models polynomially equivalent respect feasible highly parallel computations suitable defining complexity classes nc chapter 
subclasses nc nc defined prams require boolean circuit model described subsection 
reasons largely historical note set functions computable parallel time log probably different pram types listed 
defining nc terms circuits avoids sensitivity details pram model arguably making definition firmly technological realities 
final important point note pram model generally difficult see principle translate informally described parallel algorithm pram algorithm 
consider example parallel sorting algorithms described informally 
typically done assume input specified integers bits 
significance point pram convenient vehicle parallel algorithm design just ram proved convenient model sequential algorithm design 
boolean circuit model pram model natural parallel extension ram model obvious model reasonable 
pram model correspond capability cost physically implementable device 
fair allow unbounded numbers processors memory cells 
reasonable unbounded size integers memory cells 
sufficient simply unit charge basic operations 
possible unbounded numbers processors accessing portion shared memory unit cost 
synchronous execution instruction processor unit time realistic 
expose issues useful primitive model convenient program closely related realities physical implementation 

boolean circuit model model boolean circuit borodin 
model simple describe mathematically easy analyze 
circuits basic technology consisting simple logical gates connected bit carrying wires 
memory notion state 
circuits avoid issues machine organization instruction repertoire 
computational components correspond directly devices fabricate 
circuit model idealization real electronic computing devices 
ignores host important practical considerations circuit area volume pin limitations power dissipation packaging signal propagation delay 
issues addressed accurately complex vlsi models lengauer purposes boolean circuit model provide excellent compromise simplicity realism 
example feature pram models widely criticized unrealistic assumption unit time access shared memory 
consideration bounded fanin circuit models exposes issue immediately simple fanin argument provides lower bound log time combine bits sources say trivial problem unit cost crcw pram 
circuit simply formal model combinational logic circuit 
acyclic directed graph edges carry unidirectional logical signals vertices compute elementary logical functions 
entire graph computes boolean function inputs outputs natural way 
bk denote set ary boolean functions 
refer informally functions strings 
sake readability frequently common descriptive words 
definition boolean circuit labeled finite oriented directed acyclic graph 
vertex type 
vertex indegree called input 
inputs tuple 
xn distinct vertices 
vertex outdegree called output 
outputs tuple 
ym distinct vertices 
vertex bi indegree called gate 
notation lower bounds analogously upper bounds see appendix chapter 
parallel models computation identity sample boolean circuit 
note fanin equal fanout unrestricted 
inputs gates outputs 
see example 
circuit depicted inputs outputs 
input fanout 
gate fanin 
circuit computes defined function input bits specified definition 
definition boolean circuit inputs 
xn outputs 
ym computes function way input xi assigned value xi representing th bit argument function 
vertex assigned unique value obtained applying value vertices incoming value function tuple 
ym output yj contributes th bit output 
logical function associated gate symmetric order incoming edges gate important 
see example gate 
orientation ignored usual case symmetric functions computed gates 

boolean circuit model resource measures interest circuit size depth 
definition size denoted size number vertices 
depth denoted depth length longest path input output 
circuit shown size depth 
circuit described string denoted 
description thought blueprint circuit alternatively parallel program executed universal circuit simulator 
case speak circuits generate manipulate circuit descriptions exactly manipulate programs turing machines 
need circuit description language 
adopt described alternative descriptions equally 
ruzzo discusses number different ones 
definition standard encoding circuit string grouped sequence tuples tuple vertex followed sequences vertex numbers 
xn 
ym encoding vertices uniquely arbitrarily numbered range 
size tuple describes vertex oriented connections vertices follows 
vertex number gate 
left right input numbered respectively 
vertex number th input xi th output yj 
main point definition circuit descriptions simple objects generate manipulate 
note tuple binary string ease presentation described string alphabet consisting parentheses comma decimal digits 
tuple encoded binary string log size bits 
length size log size 
note boolean circuits defined gates fanin priori upper bound fanout gate 
hoover pippenger show conversion bounded fanout entails constant factor increase size depth 
hand consider circuits allowing gates unbounded fanin 
case common restrict set allowable gate functions elementary symmetric chapter 
parallel models computation functions threshold functions majority 
usually size unbounded fanin circuit defined number edges 
unbounded fanin circuits conversion bounded fanin entails great size increase worse squaring size may increase depth factor proportional logarithm size 
direction bounded fanin circuit may replaced unbounded fanin circuit slightly smaller depth factor log log size polynomially greater size stockmeyer vishkin 
greater depth reduction possible way depth expense superpolynomial increase size converting circuit disjunctive conjunctive normal form 
uniform circuit families individual circuit inputs outputs finite object computing function binary strings length binary strings length consequently different circuits required different length inputs 
contrast usual notion computation algorithm handles possible lengths inputs 
notion circuit generalized functions strings arbitrary length 
simplest generalization occurs output length function possibly constant length input 
considering simple case functions length bit inputs call length 
case represent function infinite sequence circuits circuit computes restricted inputs length sequence called circuit family 
definition boolean circuit family collection circuits computing function function computed denoted function defined 
special case length output particularly important defining formal languages 

boolean circuit model definition boolean circuit family computes function 
language accepted denoted set 
say recognized 
output length varies value length input additional output bits computed circuit indicate remaining output bits valid data 
technical complication explore 
describe infinite collection circuits 
constraints whatsoever get called nonuniform circuit families 
nonuniform circuit families unexpectedly powerful compute non computable functions 
example consider circuit family circuit consists inputs ignored single output gate constant function 
gate defined constant function th turing machine halts description defined gate 
circuit family computes function uncomputable usual sense solve halting problem 
nonuniform circuit families widely objects lower bound proofs unexpected power merely serves strengthen significance lower bounds 
example shows somewhat unsatisfactory model consider upper bounds 
particular effective way obtain description th circuit obvious approach addressing difficulty provide algorithm generating members family 
circuit family defined giving program computational model takes input outputs encoding th member 
doing infinite object family effectively described finite object program 
question computational power permitted producing description guided intuition circuit constructor computational power object constructs borodin introduced notion uniformity 
example weak circuit constructor turing machine limited log space inputs length problems interest solved limited amount space machines describe wide class useful circuit families 
chapter 
parallel models computation definition family boolean circuits logarithmic space uniform transformation computed log size space deterministic turing machine 
note complexity producing description expressed terms size resulting circuit usual method expressing terms input length 
polynomial size circuits technical device supplying unary complexity logarithmic terms length input 
logarithmic space uniformity called borodin cook uniformity mentioned cook 
notion uniformity desirable property description produced polynomial time sequentially polylogarithmic time parallel polynomial number processors 
circuit constructor reasonable sequential parallel perspectives 
just general agreement best model sequential parallel computation general agreement best notion uniformity 
different notions appropriate different purposes 
example willing give fast parallel construction circuit descriptions essence trading construction time circuit size depth uniformity 
introduced beame cook hoover examined allender family uniform transformation computed deterministic turing machine time example logarithmic space sequential computations logarithmic space uniformity simulated efficiently parallel known simulated parallel time log 
logarithmic space uniformity generally considered inappropriate circuit families depth log 
depths log definitions proposed ruzzo preferable subsume logarithmic space uniformity log depth 
definitions alternating turing machines reasonable parallel model chandra kozen stockmeyer 
smaller depths including constant depth unbounded fanin circuits definition barrington immerman preferred 
definitions virtue having natural uniform characterizations completely divorced circuits 
circuits prams ancillary notions uniformity 
example ruzzo defines ue uniformity shows language recognized ue uniform family polynomial size log depth circuits accepted logarithmic space log time bounded alternating turing machine 
barrington immerman give similarly clean characterization uniform constant depth unbounded fanin circuits terms order definability 
definitions uniformity considered goldschlager pippenger 
conflicting definitions 
practice rarely matters definition interest precision choose logarithmic space uniformity simplest understand definitions cited preferable technical grounds 
unqualified term uniform mean logarithmic space uniform 
circuits prams alluded fact parallel models equivalent consider feasible highly parallel algorithms 
problem feasible highly parallel solution model equivalent model 
originally notion feasible highly parallel came observations certain problems polylogarithmic time polynomial processor solutions different models 
triumph circularity models support feasibly highly parallel algorithms reasonable parallel models 
order new parallel model considered reasonable able simulate existing reasonable model vice versa 
give reader feel simulation arguments constructed sketch equivalence crew prams logarithmic space uniform boolean circuit families 
kinds simulation results quite technical sensitive precise details models involved 
actual details subsidiary algorithms simulations parallel prefix computation karp ramachandran example 
result concerns simulation circuit family pram 
chapter 
parallel models computation lemma logarithmic space uniform boolean circuit family computes function depth log size exists crew pram computes parallel time log processors proof sketch 
simulation consists phases 
phase takes size input constructs standard encoding circuit second phase simulates input 
phase phase generate feasible highly parallel algorithm 
circuit family logarithmic space uniform turing machine input uses tape space log generates meaningful input consists assume turing machine way read input tape 
assume way write output tape encoding written 
convenience assume tape heads advance cell right input output operation 
machine simulated quickly parallel 
thing observe state meaning configuration completely described tuple ipos specifies internal state input head position binary relative start position tape head position binary relative start position tape contents 
size state tuple log bits distinct states 
call set states construct state transition function 
note input output tape contents explicitly included state tuples 
constructing state transition function ignore input tape contents simulate input read deliver head position 
ignore output tape contents affect computation described deduce written examining sequence states occurring computation 
constructing done quickly assigning processor state tuple initial state simulate exe 
circuits prams cution steps computing qt 
compose state transition function times apply initial state 
logarithmic space bounded run polynomial time polynomial length state sequence 

sequence computed efficiently parallel prefix algorithm ladner fischer compute functions applying 
encoding extracted sequence locating qi writes bit output tape doing parallel list contraction produce single string composed bits 
second phase simple task crew pram simulate circuit encoding basic idea gate numbered circuit assigned processor output value gate written shared memory cell 
renumbering function allocate processors cells circuit gates 
simply 
processor executes simple loop reads shared memory value inputs gate computes logical function associated gate writes result 
takes time correct logical values propagate inputs output loop run depth iterations 
point loop halts values output gates compacted list ranking memory cells 

recall output size easily obtained circuit encoding 
value placed 
problem phase needs know depth circuit 
computed feasibly highly parallel way doing max transitive closure circuit graph 
alternatively algorithm simulation state gates longer changing 
complexity phases feasible highly parallel simulation 
chapter 
parallel models computation pram simulated circuit 
main problem pram potentially unbounded number memory cells contents potentially unbounded length 
lemma crew pram computes parallel time log processors exists constant logarithmic space uniform boolean circuit family input 
xn computes output 
yi yi value bit shared memory cell time 
furthermore depth log size proof sketch 
combinational circuits memory simulate computation step step output step input step 
circuit layers time step computation input length additional information circuit designed handle worst case estimate number local shared memory cells processor number bits cell 
time processor bounds guarantee local memory cells processor shared memory cells total accessed 
cases bits generated cell 
layer simulation maintain information local memory cells shared memory cells containing bits 
problem indirect addressing accessed memory cells spread address space size possible simulate cell accessed 
simulation dynamically allocate memory cells pool cells cell tagged address 
stockmeyer vishkin show done feasible highly parallel way see karp ramachandran 
sake simplicity assume indirect addressing occurs outside cells 
layer consists copies circuit simulates step single processor 
circuit simply implements basic operations pram processor done log log depth polynomial size 
circuit single step processor takes input local memory bits previous layer shared mem 
circuits prams ory bits previous layer 
shared memory bits processors merged tree allows bits processor wrote shared memory cell replace existing bits 
total depth simulation worst log circuit polynomial size 
claim description generated logarithmic space turing machine 
circuit regular main issue picking simple numbering scheme blocks form layer individual layers 
results combine give theorem 
theorem function computed logarithmic space uniform boolean circuit family depth log size computed crew pram inputs length time log processors similar simulation results various models parallel computation allow observe problem inherently sequential reasonable parallel model inherently sequential reasonable models 
chapter complexity goal chapter provide formal basis key concepts book 
include notions problem definitions important complexity classes reducibility completeness 
search decision problems far term problem somewhat vaguely 
order compare difficulty various problems need concept precise 
problems typically come flavors search problems decision problems 
consider search problem find value maximum flow network 
example maximum flow value maxflow directed graph edge labeled integer capacity distinguished vertices problem compute value maximum flow source sink problem requires compute number value maximum flow 
note case computing function 
consider variant problem 

search decision problems example maximum flow bit maxflow directed graph edge labeled integer capacity distinguished vertices integer problem th bit value maximum flow source sink 
decision problem version flow problem 
asking computation value problem asking answer specific question 
decision problem maxflow equivalent search problem maxflow sense solved efficiently parallel 

consider solving instance maxflow reduced solving instance maxflow 
suppose asked question maxflow bit maximum flow easy answer question solving maxflow looking bit flow 
examine bit output maxflow quickly parallel feasible highly parallel solution maxflow yields feasible highly parallel solution maxflow 
consider solving instance maxflow reduced solving number instances maxflow 
suppose instance maxflow solve 
compute upper bound maximum flow sum capacities edges done quickly parallel 
resulting limit flow gives limit number bits maximum flow 
solve instances maxflow bits maximum flow obtain value bit 
combine bits compute value maximum flow 
highly parallel solution maxflow implies highly parallel solution maxflow 
maxflow reduced efficiently parallel maxflow 
interested studying intrinsic parallel complexity maximum flow sufficient look particular decision variant 
idea generalizes situation computing function 
example function induces associated bitwise decision problem bit equal provided bound length determine value bit bit 
consequently complexity computing chapter 
complexity tially greater deciding value particular bit 
comes assessing difficulty problem usually sufficient simply consider problem associated bitwise decision variant 
related decision problems somewhat careful 
example consider variant maximum flow 
example maximum flow threshold maxflow directed graph edge labeled integer capacity distinguished vertices integer problem value maximum flow source sink 
possible reduce computation maxflow decision problem maxflow reduction impossible feasible highly parallel way 
suppose flow bits 
flow determined steps binary search 
example high order bit flow determined asking flow answer question bit flow 
assuming negative answer bit determined asking flow way solving instances maxflow yields bits flow 
results reasonably fast sequential algorithm 
unfortunately give fast parallel algorithm particular instance decision problem solved depends answers previous ones apparently solved parallel 
conceivable maxflow feasible highly parallel algorithm maxflow maxflow see problem 
reader referred abrahamson fellows wilson karp upfal wigderson discussion parallel self reducibility determining parallel complexity search problem assuming availability oracle corresponding decision problem 
possible area concern specification problem functional 
instance unique solution admits possible solutions 
case maxflow problem functional 
special case search problem solution unique called function 
complexity classes problem 
provide example search problem function problem 
example maximum flow pattern maxflow directed graph edge labeled integer capacity distinguished vertices problem compute flow pattern 
flow particular edge achieves maximum flow source sink may flow patterns attaining maximum flow maxflow produces just 
possible successive solutions instance maxflow result different flow patterns 
reductions maxflow carefully designed 
assume example parallel solutions deliver answer done maxflow maxflow reduction 
technique recomputing solution order save space 
simple way making kinds relational problems functional ones require additional property solution lexicographically solutions 
complexity classes complexity class collection problems usually decision function characteristic worst case difficulty famous class decision problems polynomial time sequential solutions 
class problems may easier problems solved resource bounds associated class 
important consideration defining complexity class type objects contain 
convenient compare complexity classes usual terminology sets speak class proper subset class intersection classes 
possible want complexity classes contain kind object 
want perform computations manipulate members class reducing problem class 
additional consideration defining class members class easy code strings reasons complexity classes defined terms chapter 
complexity formal language acceptance problems 
means members complexity class languages language set strings complexity class contains kind object set strings 
jump decision function problems language recognition problems alphabet 
issues need confront 
problems encoded binary alphabet second view decision function problems languages 
address coding issue 
decision function problems normally phrased alphabet having symbols 
example convenient delimiters digits expressing problem 
passing usual informal description problem language recognition question preserve amount information contained original description 
introduce informal notion size problem 
size instance problem naturally measured number symbols full problem specification 
ways coding specific decision problem maxflow language recognition problem 
encoding meets guidelines acceptable 
easy produce encoding instance problem 
prevents encodings containing answer problem part encoding 
coding compact 
length binary encoding roughly correspond size problem instance say polynomial original instance size 
way express complexity problem terms size problem instance length instance encoding measures equivalent polynomial factor 
example directed graph vertices coded adjacency matrix roughly bits 
complexity algorithm finding spanning tree expressed terms terms length encoding case complexity polynomial time 
hand size integer usually expressed terms number digits binary decimal representation 
encoding integer 
complexity classes unary possible factor time polynomial input length know coded binary 
cases length encoding exponentially larger instance size considered unreasonable 
encodings considered interconvertible computational resources studying 
encoding contains computational hints 
return issue view decision function problems language recognition questions 
problems expressed decision form immediately provide associated language consisting strings encode answers problem 
membership binary string equivalent affirmative answer question decision problem original unencoded version suppose language corresponding particular decision problem 
may think coding instance problem answer 
example means means consider language 
language provides alternative view want consider function problems language recognition questions approach described turns useful 
fix encoding instances specific problem 
function problem viewed language recognition question language bit function value note compute solution function problem easily recognize corresponding language vice versa 
reader may noticed descriptions languages delimiter 
applying homomorphism coding obtain language specify precisely complexity decision problem associated language need definitions 
reader may wish refer definition 
definition language characteristic function function fl defined fl fl chapter 
complexity definition language decidable sequential time characteristic function computed sequential time 
definition language decidable parallel time processors characteristic function computable parallel time processors 
single sequential processor running polynomial time easily simulate polynomial number processors running polynomial time conversely 
wanted restrict attention simply prams lemma indicates 
lemma language decidable sequential time decidable parallel time processors nc nc define class polynomial time sequential problems class feasible highly parallel problems nc 
origin name nc see section definition class set languages decidable sequential time deterministic complexity classes closed complement 
aside notice implies complement complete language complete 
definition class nc set languages decidable parallel time log processors lemma know nc important question parallel computation inclusion proper 
seen decision problem form expressed function problem computing characteristic function similarly function associated decision problem form bit define complexity function complexity associated language recognition question 
expressing complexity classes terms languages convenient noted previously useful talk complexity computing function directly 
seen 
complexity classes possible convert easily notions 
analogous function computation classes fp fnc sets functions languages 
definition class set functions computable sequential time definition class nc set functions computable parallel time log processors classes stable sense composition functions class remains class 
property ensures classes define easily establish transitivity 
lemma classes fp fnc closed composition 
proof 
proof left exercise reader 
point authors symbol nc denote fp respectively nc fnc relying context meaning clear 
classes nc nc uniform boolean circuit family model nc divided subclasses differ logarithmic factor depth 
definition integer class nc set languages recognized uniform boolean circuit family size depth log 
observe nc nc examples note determining th bit multiplication bit numbers nc problem determining rank matrix nc similar manner fnc partitioned function classes fnc 
see appendix formal definition 
example problem multiplying bit numbers fnc note analogous lemma fnc closed composition 
chapter 
complexity random nc search problems known fnc algorithm randomized algorithms find solution high probability feasible highly parallel way 
example problem computing maximum matching problem problem computing depth search tree problem 
cases mentioned appendix 
define rnc probabilistic version nc need notion probabilistic circuit 
definition probabilistic circuit boolean circuit ordinary inputs 
xn random inputs 
zr outputs 
ym distribution random inputs probability input output equals written defined fraction random input strings outputs input 
xn 
zr say computes error probability 
notions circuit family uniformity carry directly types circuits 
class rnc defined follows 
definition random inputs obtained uniform distribution 
integer class rnc set languages recognized uniform probabilistic boolean circuit family size depth log having error probability 
class rnc rnc define rnc terms randomized prams 
corresponding function classes important 
definitions provided appendix reducibility section alluded notion reducing problem problem expressing solution terms solutions precise concept reducibility lets compare problems relative difficulty characterize hardest problems complexity class 

reducibility reducibility common forms reducibility 
transforming instance problem single instance transformation called reduction 
usual kind reducibility associated np completeness results karp garey johnson 
called distinct instances original problem mapped single instance new problem suppose languages want determine string member suppose transform string function way member exactly member reduced sense know test membership test membership function called reduction 
notation ml denote reducible know decide membership complexity testing sum complexity computing complexity testing course interested complexity reduction case reductions simply complexity computing follow convention denote resource bounded reduction name decision problem complexity class associated complexity reducing function 
follows provide formal definitions ideas just 
definition language reducible language written ml function say reducible written ml function fp 
say nc reducible written function fnc say nc reducible written nc function fnc reductions usually complicated repeated 
notion allows 
chapter 
complexity definition suppose reducibility say transitive 
reducibility transitive 
language reducible furthermore fp fnc fnc closed composition lemma remarks section resource bounded reductions transitive 
lemma nc transitive 
proof 
proof left exercise reader 
definition useful equating problems complexity 
definition suppose reducibility say equivalent 
reducing language language exact complexity unknown 
gives absolute information computational complexity provides useful information relative difficulties languages 
particular assuming reduction powerful implies difficult decide important note reduction allowed power mask complexity extreme example polynomial time allowed reduction problem reduced trivial problem problem deciding string member set 
note replaced set lemma 
ml nc 
nc nc 
nc nc nc proof 
proof left exercise reader 
just defined reductions give way comparing decision problems 
notion extended search 
reducibility problems search problem reduced search problem transforming instance instance solving transforming result solution practice need solve single instance search reductions nearly useful generalization turing reductions defined 
turing reducibility turing reducibility generalization reducibility 
performing transformation input followed asking just single question allow multiple questions new questions possibly function answers previous questions 
way turing reducibility corresponds usual notion subroutines solve larger problems solve problem calls subroutine solving problem reducibility turing reducibility compare problems intrinsic difficulty unknown 
consequently notion complexity turing reductions cost subroutine solve problem time accounting call way get result analogous lemma 
way achieving isolation hide solutions problem interface called oracle count cost placing questions obtaining answers interface 
example reducing language reduction done machine provided oracle answering membership questions oracle call charged unit cost 
way complexity reduction captures difficulty reducing independently true complexity oracles added pram model slightly modifying input output conventions computations definition adding new instruction 
oracle pram search problem pram additional instruction oracle behaves follows integer placed shared memory cell cs bits 
xk encoding instance placed shared memory cells cs 
cs instruction oracle executed integer placed shared memory cell cs bits 
yl answer instance chapter 
complexity placed shared memory cells cs 
cs different processors may simultaneous oracle calls responsible preventing conflicts shared memory access 
turing reduction simply computation oracle pram 
definition search problem turing reducible search problem written oracle pram solves say turing reducible written oracle pram inputs length uses time processors say nc turing reducible written nc oracle pram inputs length uses time log processors discuss nc turing reducibility section 
general case search problem oracle returns possible solutions instance repeated calls instance guaranteed return answer 
case search problem functional unique answer instance speak function turing reducible function case decision problem oracle pram gives way turing reducing language oracle call invoking computation cost oracle call function length question resulting answer 
require result stated lemma sufficient simply charge oracle call instruction 
setup bit oracle call requires processor time unit interpreting bits result length oracle call processor time product 
input length feasible highly parallel reduction oracle calls length lemma nc transitive 
proof 
proof left exercise reader 
note concepts especially turing reducibility expressed equivalent forms models oracle turing machines 
worth observing reducibility implies turing reducibility 

reducibility lemma 
ml 
ml 
nc nc proof 
just supply oracle implement reducing function oracle pram ask question oracle 
focus nc reducibility interested transforming problems quickly parallel 
nc reducibility lets preserve complexity sense lemma 
lemma nc nc nc respectively 
proof 
consider nc suppose pram decides time log processors 
suppose oracle pram decides furthermore suppose input length uses time log processors oracle calls length simultaneous oracle calls 
replace oracle calls direct execution resulting machine uses processors takes time log nc similar argument works nc replaced lemmas illustrate choosing reducibility compatible complexity classes studying important 
notion precise 
definition resource bounded reducibility complexity class 
reducibility compatible problems lemma nc reducibility compatible classes nc fp fnc proof 
proof left exercise reader 
details refer interested reader article johnson 
chapter 
complexity nc compatible comparing problems nc reduction compatible nc 
describe useful reductions 
nc turing reducibility suppose problems nc suppose solved log time crew pram 
reducibility nc compatible fnc know gorithm implement feasible highly parallel algorithm examine details reduction know actual time complexity resulting algorithm 
reduction takes time log know algorithm time log worst log oracle calls time log 
replacing oracle call actual solution increases time log worst 
obtain precise time estimates reasonable consider subclass nc reducibility time reduction limited 
unfortunately definition nc reducibility section stated terms prams 
logarithmic factor different versions pram model really interested fine details reductions need precise model boolean circuit families 
definition search problem 
oracle circuit family boolean circuit family augmented oracle gates problem oracle gate vertex sequence 
xk input vertices sequence 
yl output vertices 
input encoding instance problem oracle gate outputs encoding solution provided bits sufficient contain full encoding 
purpose defining complexity oracle gate counts depth log size 
note output encoding oracle gate usually designed indicates output encodes complete partial result due lack sufficiently output bits 
oracle circuit families serve purpose oracle prams 

nc compatible definition search problem nc turing reducible search problem written uniform oracle circuit family solves depth log size lemma search problems 
nc proof 
proof left exercise reader 
cook originally introduced notion nc turing reducibility purposes studying subclasses nc functions reducible problem computing determinant integer matrix 
nc turing reducibility advantage preserving circuit depth nc nc nc nc compatible nc 
nc turing reducibility establish depth equivalence problems precise complexities may unknown 
example beame cook hoover show binary division powering iterated product equivalent nc reducibility 
solved log depth uniform boolean circuit family 
fail find polynomial size log depth logarithmic space uniform family circuits problems 
relaxing notion uniformity somewhat construct logarithmic depth circuit family iterated product 
nc equivalence places problems small depth 
note nc reduction nc reduction 
worth noting nc reductions literature fact nc reductions consider requiring nc reductions turing order ensure depth preserved reduction 
advantage sticking nc reducibility 
firstly circuits describe reductions pram models 
addition ruzzo shows different notions uniformity class nc stable may difference nc 
avoids issue completely nc reducibility obtains stable notion reduction 
chapter 
complexity logarithmic space reducibility original completeness results motivated question unresolved equals polylogarithmic space cook jones 
results logarithmic space reducibility results currently appearing literature 
definition language logarithmic space reducible language denoted log exists function computable logarithmic space turing machine reason choosing logarithmic space reducibility reductions compatible polynomial time polylogarithmic space combined 
example logarithmic space reducible polynomial time polylogarithmic space simultaneously corresponding complexity class 
noted logarithmic space reduction nc reduction precisely nc reduction consequence small space transitive closure simulation borodin 
completeness introduced reductions relate problems 
relate problem entire complexity class 
variants turing reductions far involve logarithmic space nc compatible nc consequently nc turing reductions hardness results 
practice state results weakest form reducibility possible nc reducibility 
suppose languages nc lemma tells nc tells nc attempting understand actual complexity take approaches show nc membership test finding nc upper bound show nc membership test possible say proving parallel polynomial time lower bound 
course stronger statement complexity nc 
completeness equivalent 
case upper lower bound gives upper lower bound 
consider question nc equals distinguish classes need find problem provably solvable nc unfortunately attempts finding problem failed 
candidates problems interesting properties 
equivalent nc turing reductions 
consequently proof inherently sequential results entire class inherently sequential problems 
second property problem nc turing reducible candidate hard problems 
means feasible highly parallel algorithm problem imply nc equals call problems capture difficulty intrinsic class complete problems class 
definition language hard nc reducibility nc language complete nc reducibility hard 
say problem hard indicating difficult solve problem stating complete adds additional information problem fact problems decision problems decision problem complete 
search problems polynomial time solutions property language reduced 
hard 
problems complete classified indicate capture essential difficulty polynomial time computations 
search problems functions classified fp complete follows 
definition function problem hard nc reducibility nc function problem complete fp hard 
search problems stated relations 
example problem finding spanning tree 
solutions unique problems fp problems named complexity class 
call problems quasi complete 
chapter 
complexity definition search problem hard nc reducibility nc search problem quasi complete polynomial time solution 
key result allowing relate completeness fast parallel computation theorem 
theorem complete problem nc nc equals proof 
proof left exercise reader 
considerable evidence chapters illustrate leading belief nc distinct classes 
say problem complete say nc solution 
chapter shown circuit value problem definition complete 
question feasible sequential problem highly parallel solution equivalent problem 
polynomial size boolean circuit output computed polylogarithmic time polynomial number processors 
nc equals chapter basic complete problems provided sufficient machinery address question posed problem feasible sequential solution highly parallel solution 
asking dual question 
inherently sequential problems 
try develop intuition answer question closely examining basic complete problems generic machine simulation problem circuit value problem introduced 
generic complete problem canonical device performing sequential computations turing machine single processor serial access memory 
course usual machines call sequential nearly primitive fundamentally suffer bottleneck created having just processor 
say problem inherently sequential say solving parallel machine substantially better solving turing machine 
sequential problem simulating turing machine computation 
just discover simulate efficiently parallel turing machine uses polynomial time feasible sequential computation chapter 
basic complete problems translated automatically highly parallel form 
interested problem 
see problem part ii related problems remarks 
definition generic machine simulation problem string description turing machine integer coded unary 
precise input string delimiter character string 
problem accept steps 
intuitively easy see problem solvable polynomial time sequentially just interpret program step step input accepts steps simulated whichever comes 
step step simulation arbitrary turing machine fixed exactly essence famous result universal turing machines exist 
reasonable encoding simulation universal machine take time polynomial lengths turn polynomial length universal machine input 
insist encoded unary 
see example hopcroft ullman details universal machine construction 
reducing arbitrary language generic machine simulation problem easy 
ml turing machine recognizing polynomial time easy compute upper bound running time 
accomplish reduction string simply generate string ml instance generic machine simulation problem transformation easily performed nc circuit see definition follows 
note string ml constant independent string constant fixed 
fixed circuit accomplishes transformation inputs length simply outputs copy input followed fixed string ml done input bounded fanin circuit small depth fact constant depth 
basically consists sequence input gates computes identity function followed fixed sequence constant gates computing successive bits ml followed gates computing constant gate output gate 
note circuit family 
circuit value problem highly uniform 
difficult part constructing compute easy chosen simple form say log integer power 
note log just number bits needed express binary 
binary representation single bit followed number zero bits number determined appending log zeros log 
uniformity computations reduced little counting shifting 
summary shown theorem 
theorem generic machine simulation problem nc reductions 
circuit value problem obvious drawback tackling generic machine simulation problem directly generality 
hard see take arbitrary turing machine program hints problem solving produce highly parallel simulation 
useful study simple problem captures computational power turing machines addition obvious parallel aspects potentially exploited 
analogy theory np completeness consider generic nondeterministic machine simulation problem versus satisfiability 
np complete simplicity problem valuable starting point wide variety investigations 
complete problem analogous satisfiability circuit value problem cvp proposed ladner 
see problem related problems part ii 
definition circuit value problem cvp encoding boolean circuit inputs 
xn designated output problem output true input 
xn 
formal statement cvp requires language describing boolean circuits 
variety suitable choices 
definiteness standard encoding specified definition 
worth noting formulation cvp permits chapter 
basic complete problems ask value gate just outputs simply designating gate output 
easy see circuit value problem solvable sequentially polynomial time 
simply pass circuit inputs outputs topological order evaluating gate values computed immediate predecessors 
fact polynomial time computation represented circuit evaluation problem easy see intuitive level 
ordinary digital computers essentially built boolean logic circuits polynomial time computation activate polynomial number gates 
reduction arbitrary polynomial time computation instance circuit value problem basically involves unrolling machine wiring diagram produce circuit activated computation 
outline shown basic result 
theorem ladner circuit value problem nc reductions 
formal proof fact find easier simulate turing machines circuits realistic digital computers 
proof somewhat technical deferred chapter 
armed basic complete problems introduced chapter answer fundamental question raised 
believe problem feasible sequential solution feasible highly parallel solution specifically believe complete problems inherently sequential 
explanation answer subject chapter 
chapter evidence nc equal believe nc equal 
form evidence people tried failed show equal 
persuasive way failed character limited successes 
specifically known approaches consistently leave large gap know solve highly parallel algorithms general problems outline state art follows 
general simulations fast best known parallel simulations general sequential models give modest improvements basically reducing sequential time parallel time log depending parallel model 
furthermore processors needed achieve modest improvements 
fast simulations general rapid simulations sequential models highly parallel models known weak sequential models 
natural approaches provably fail certain natural approaches highly parallel simulation provably insufficient 
equivalently certain natural structured models computation borodin prove analogs nc equal separated nearly exponential gap suggested points 
chapter 
evidence nc equal chapter evidence detail 
nature available evidence renders chapter especially section somewhat technical rest part reader may wish skim skip reading 
general simulations fast consider generic machine simulation problem introduced section 
intuitively expect problem hard parallelize 
notice defined problem terms turing machines technical convenience way fundamental result 
theorem remains true rephrase generic machine simulation problem program fortran pascal lisp reasonable programming language 
universal machine proof simply interpreter language 
highly parallel solution generic machine simulation problem precisely programming language interpreter able achieve highly parallel execution completely arbitrary programs 
highly parallel interpreter 
believe 
general program code remarkably opaque ability mechanically deduce nontrivial properties programs just text program severely limited 
questions undecidable decidable ones provably computationally infeasible 
feasible properties exploited optimizing compilers tend syntactic local relatively simplistic 
particular compiler optimizations rarely radical alterations set intermediate values computed program method computed order computed 
transformations certainly necessary achieve highly parallel generic simulation 
additionally experience date highly parallel algorithms known large number interesting problems cases algorithms strikingly different sequential algorithms problem 
excellent survey karp ramachandran contains number examples nature 
particular automatic generation parallel algorithms sequential counterparts far current state art parallelizing compilers 
empirically compilers usually attain speedups small constant 
fast simulations general factor say reaching factor rare occasions 
achievements impressive undeniable practical importance fall far short satisfying demand highly parallel algorithms exploit potentials machines hundreds thousands processors commercially available answering theoretical question posed 
best methods known speedup general sequential computations give limited speedup high cost 
paterson valiant shown bounded fanin boolean circuit size exists equivalent circuit depth log requiring size log 
tompa analogous results turing machines showing turing machine running time simulated uniform circuit depth log requiring size log 
bounded fanin parallel models best results known 
noted chapter unbounded fanin models faster bounded fanin ones 
example tompa show turing machine running time simulated crew pram running time cost enormous number processors 
simulation involves precomputation parallel huge table giving step transition function simulated turing machine simulated rapidly repeated table look ups 
complex table building idea mak shows simulate unit cost sequential random access machine ram crew pram time log cost increase number processors exponential time bound 
see reif earlier somewhat weaker results form mak section related results 
case number processors simulating parallel machine feasibly bounded little known 
case pram results tompa reif modified give constant factor speedups stronger results known 
fast simulations general perspective difficulty parallelizing generic machine simulation problem obtained looking classes chapter 
evidence nc equal gorithms automatic parallelization known possible 
words restricted classes sequential machines problem known nc handful results flavor known 
describe 
examples general characteristics remaining example specialized 
class machines allows running times polynomial computations class certain special characteristics exploited allow highly parallel simulation 
case machine class defined simultaneously restricting resources example time space 
true case relaxing constraint resources nearly exponential amount polylogarithmic polynomial gives class known equal conclude nc equals nearly exponential increase resource adds power model 
case known highly parallel simulation degrades polynomial time worse applied relaxed variant 
difficult give simple intuitive characterization features making machines amenable parallelization fact different portions computations loosely coupled common thread 
feature evident generic machine simulation problem 
table summarizes results discussed 
example finite state machine language accepts nc generally output string produced way finite state transducer constructed nc application parallel prefix algorithm ladner fischer see blelloch kruskal rudolph snir 
specialized example alluded simple generalizations finite state machines accept languages languages 
second example turing machine uses logarithmic space language accepts nc borodin 
results similar intuitive justification carries little state information performs computation second halves computation loosely coupled 
precisely afford simulate recursively second half computation parallel trying parallel states state midpoint select 
fast simulations general model resource resource max min nc dtm time space log dtm time reversals log space log time log alternating tm space log log uniform circuit size depth log pram procs time log class languages accepted machines type column resource polynomially bounded simultaneous bound resource 
max gives maximum consumption resource nc known 
min gives minimum consumption resource known 
cases shown independent resource implies cases row resource usage log nc table gap generic nc simulations ing correct second half state resulting half known 
related idea underlies savitch theorem 
logarithmic space bounded turing machine necessarily runs polynomial number steps infinite loop machines accept languages accept languages 
long standing open problem 
note polynomial time algorithms polynomial space question affirmative answer polynomial time polynomial space algorithm converted polynomial time logarithmic space 
third example log space log time bounded auxiliary pushdown automaton log space log bounded alternating turing machine ruzzo 
define classes suffice say generalizations logarithmic space bounded turing machines 
example power chapter 
evidence nc equal machines polynomial time case consider exponents cases log essentially corresponds context free language recognition 
cfl parse trees major motivating example investigation bounds alternating turing machines 
connections pushdown automata known 
containment bounded classes nc basically generalization method described machine space bound small different subtrees loosely coupled large tree decomposed trees half size solved recursively parallel recombined solve global problem 
tree contraction miller reif bottom method essentially equivalent top 
see abrahamson cole vishkin miller teng karp ramachandran kosaraju delcher mayr 
restricted storage access regimen pushdown automaton allows analogous efficient solutions 
stated resource bounds classes characterize nc language nc accepted machine 
allowing time bound increase log allows machines recognize language chandra kozen stockmeyer cook 
running time parallel algorithm sketched roughly logarithm algorithm polynomial time simulate alternating turing machine larger bound 
similar remarks apply auxiliary pushdown automata 
algorithm suffices provide highly parallel simulation feasible sequential computations clearly suffice 
nearly exponential gap remains simulated nc required simulate fourth final example polynomial time polylogarithmic reversal bounded turing machine pippenger 
turing machine computation reversal occurs tape head moves moves direction opposite move 
key observation reversals phase machine acts finite state transducer example phase simulated quickly parallel 
pippenger shows converse result polynomial processor polylogarithmic time parallel algorithm simulated polynomial 
fast simulations general time polylogarithmic reversal turing machine class exactly characterizes nc key observation direction simulation parallel time step simulated log reversals sorting subroutine gather operands distribute results independent operations performed step 
returning question class equal note general polynomial time turing machines polynomial number reversals polylogarithmic powerful 
notion reversal generalized models including rams hong basic result remains unchanged nc equals polylogarithmic reversals equals polynomial reversals nc equals nearly exponential increase reversals adds power 
summary known cases class sequential machines accepts languages nc machines restricted 
related class known accepts arbitrary languages machines consume exponentially resource recognize languages 
historical note recognition pippenger surprising characterization polynomial size polylogarithmic depth uniform circuits stephen cook class nc nick class return nicholas pippenger dubbed class languages recognized polynomial time polylogarithmic space turing machines sc steve class recognition cook surprising demonstration deterministic contextfree languages class cook von hl 
part motivation interest sc anomaly table 
conjecture row polynomial time logarithmic space case behave polynomial time polylogarithmic space provide characterization nc support conjecture comes fact turing machine time circuit size polynomially related pippenger fischer savage turing machine space circuit depth borodin natural suspect relations hold simultaneously 
cook conjectures case directed connectivity example problem nc sc 
chapter 
evidence nc equal natural approaches provably fail line evidence supporting conjecture nc different 
certain approaches highly parallel simulation arbitrary polynomial time sequential computations occurred naturally people studied problem 
date approaches fruitless 
cases prove failure approach intrinsic 
precise formulate model embodies essence approach fairly general setting prove model impossible achieve result strong show nc equals prime examples style evidence concern results borodin nc algorithm simulated small polylogarithmic space basically doing depth traversal circuit 
relationship sequential space parallel time aspect called parallel computation thesis 
see section chandra stockmeyer goldschlager cook 
nc circuit value problem solvable small space 
naive algorithm cvp evaluates gates topological order obviously uses large amount space eventually stores value gate 
savings may attained discarding gate value immediate successors evaluated improvement asymptotically significant worst case 
natural approach achieve greater space savings expense time discard certain values successors evaluated recompute needed 
models process 
circuit directed acyclic graph proceeds rules 
pebble placed gate represents fact value gate stored 
pebble may removed gate time corresponding discarding associated value freeing storage placed input time may placed gate immediate predecessors corresponding re evaluating gate stored values predecessors 
goal process pebble circuit output vertex 
space model maximum number pebbles simultaneously circuit time number pebble 
summary placements 
natural model algorithms circuit evaluation 
model restricted represent situations combinations gate values stored single location known algorithms exploit potential behavior substantive way essentially known algorithms cvp fit model variants 
pebbles suffice solve cvp 
clearly vertex graph pebbles time topological order 
paul tarjan shown vertex graphs fewer log pebbles 
furthermore lengauer tarjan extended results show pebble graphs log pebbles requires time 
note just lower bounds specific algorithm 
show algorithm broad class potential algorithms follow paradigm necessarily uses large amount space worst case 
algorithms avenue attaining small space solutions cvp proof nc distinct 
similar lower bounds known variants model including black white cook sethi person tompa 
extensive literature 
see survey pippenger papers pippenger tompa results variants model 
summary summary known speedups arbitrary sequential models modest come cost enormous number processors 
sequential models know highly parallel simulations face comparatively weak relatives polynomial time turing machines 
models discussed finite state machines provably compute polynomial time computable functions models require nearly exponential increase resource prove equivalence intuitively large gulf nc date approaches bridging gulf failed broad classes appealing natural approaches algorithms provably fail 
chapter 
evidence nc equal compelling evidence may ultimately inconclusive 
prove feasible highly parallel solution generic machine simulation problem impossible 
know space hierarchy theorem nc pspace possible example nc equals np ph safe say result significant breakthrough potentially dramatic practical implications 
chapter circuit value problem chapter return circuit value problem introduced section 
give formal proof theorem cvp complete sketched previously 
show number useful variants restricted versions cvp complete 
circuit value problem complete recall definition circuit value problem definition encoding boolean circuit designated output values inputs 
xn ask output true 
show cvp complete nc reducibility requires showing cvp language nc reducible cvp 
easy see encoding circuit values inputs compute value gate number steps polynomial size 
random access machine done linear time considering gates topological order computed linear time see cormen leiserson rivest example 
deterministic turing machine process bit clumsy done polynomial time 
pippenger shows time log suffices length encoding 
lemma 
chapter 
circuit value problem lemma circuit value problem difficult step proving cvp complete reducibility showing nc reduction nc language cvp 
ladner proved simulating turing machines circuits 
idea follows 
recall language tape turing machine input 
xn halts time output equal note machine uses space tape 
entire computation captured answers questions 
time contents tape cell tape head positioned cell state 
easy questions answer isolation answer simple function answers questions tape cells time 
functions easily computed boolean circuit size entire computation described boolean circuit size input input single output bit indicates accepts input 
key reduction produce parallel efficiently 
lemma shows done 
lemma ladner nc cvp 
proof 
customary assume input adjacent positions input tape tape head initially positioned 
loss generality assume moves left initial position input head halts head back initial position output bit written initial position 
consider input length runs time head touch tape cells 
construct circuit simulates tape cells 
associated tape cell time step representation consisting quantities contents state 
contents indicates value stored tape cell 
state specifies head positioned cell specifies internal state time 
suppose tape alphabet state set 
representation cell encoded bits obvious way bit true contents 
circuit value problem complete ri ri ci ri ri ci 
rq true head positioned cell internal state bit true head positioned cell 
circuit simulating compute representation ri cell time 
convenient handle certain boundary conditions introducing dummy cell representations ri 
representation ri contents blank tape symbol head positioned 
true bits ri false 
similarly representations directly computed input contents th symbol xn head positioned initial state 
representations remaining cells computed array identical ci connected regular way follows 
ci simulates th step tape cell computing ri inputs ci ri 
depicts ci 
ci performs follows transition function 
ri indicates head positioned th cell start th step contents portion ri dictated transition function state contents chapter 
circuit value problem portions ri contents portion ri ri set pairs writes state reading 
computed follows 


state portion ri computed similarly 
start th step head positioned th cell move result th transition state portion ri indicate head th cell indicate resulting internal state 
likewise head positioned cell moved right respectively left ci computes new state 
cases state portion ri indicate head 
specifically bq set triples state reading enters state moves head direction means move left means move right means sit 
computed follows 
bq 
convention state halt state successor defined state regardless input symbol 
way ensure machine defined state simulation halts earlier 
head position component state computed follows 
set triples state reading move head direction 
restricted versions circuit value size circuit compute state change cell specifically fanin fanin plus fanin 
straightforward induction verify representations ri correctly encode configuration steps 
final step construction establish nc computable 
circuit consists replicas single fixed main tasks constructing compute value generate correct number copies basic constituent gates appropriately numbered unique connect neighboring appropriately 
tasks easily accomplished nc algorithm nc computable 
leave details exercise 
lastly written tape square true 
combining lemmas obtain theorem 
circuit value problem remains input circuit fixed 
replacing input bits appropriate fanout depending input straightforward 
alternatively see circuit fixed replace arbitrary machine construction polynomial time turing machine solving generic machine simulation problem universal polynomial time turing machine 
gives essentially single circuit fixed respects size evaluation complete 
circuit consists array copies single fixed size arising construction single universal machine 
language reduced evaluating circuit appropriately chosen input appropriately chosen interesting question see just simple cvp retaining completeness 
example cvp balanced binary trees gates depth log complete nc cvp grid connected nearest neighbors previous level complete 
restricted versions circuit value circuit value problem plays role completeness theory satisfiability sat cook np completeness chapter 
circuit value problem theory 
sat cvp fundamental complete problem sense frequently show problems complete 
analogously sat cvp variants complete 
section describe prove complete 
described section 
restricted variants problem simplify reductions case example cnf sat cnf sat variants sat theory np completeness 
versions cvp novel characteristics help simplify reductions 
additionally proofs nicely illustrate number techniques frequently reductions 
cvp variants describe chapter listed 
formal specifications problems may easily traced cross provided 
topologically ordered cvp problem topological ordering directed acyclic graph numbering vertices directed edge 
succeeding variants cvp additionally restricted circuit topologically ordered furthermore string encoding circuit list vertices order 
key properties circuit value problem circuit simple sequential algorithm input circuit evaluates individual gates circuit fixed order evaluating exactly arriving circuit designated output value polynomial time 
virtue topologically ordered circuit value problem valuation order transparently specified cvp instance 
problem special case circuit value problem circuit contains nand gates 
reductions simplified type gate needs simulated 
monotone cvp problem restricted version circuit value problem circuit contains monotone gates problem useful common situation negations hard simulate directly 

restricted versions circuit value alternating monotone cvp special case previous problem 
monotone circuit alternating path input output gates path alternate gates 
additionally require inputs connect gates outputs gates 
reductions replace individual gates certain small gadgets alternating property reduces number kinds interactions gadgets considered simplifies reductions 
fanin fanout am cvp problem restriction previous problem 
case vertices circuit restricted fanin fanout obvious exception inputs outputs definition fanin zero fanout zero respectively 
potential advantage simpler gadgets reduction fewer cases consider establishing correctness 
synchronous am cvp sam cvp problem circuit define level vertex denoted level zero input vertices maximum level predecessor input equivalently level length longest path input circuit synchronous inputs gate come vertices level level 
furthermore require output vertices level highest 
vertices partitioned layers edges going layer higher outputs layer 
sam cvp restriction am cvp synchronous circuits 
notice circuit alternating synchronous gates level type 
fanin fanout restrictions imply level contains exactly number vertices 
structural regularity simplifies reductions 
construction proof lemma yields circuit properties 
specifically formulas gave disjunctive normal form monotone literals term literal term 
circuit synchronous alternating monotone fanin fanout 
modify construction pedagogical reasons chapter 
circuit value problem prefer show completeness variants starting general form circuit value problem 
topological ordering 
general problem topologically ordering directed acyclic graph nc cook known nc topologically ordered cvp complete nc reductions 
theorem circuit value problem restricted topologically ordered instances remains complete nc reductions 
proof 
construction prove cvp complete proof theorem see lemma easily modified produce circuit topological order 
specifically number input vertices circuit 
number 
suppose basic template ci gates constant 
number gates 
topological order 
give gate ci th gate th instance template number topological numbering easily computed nc useful gate numbering tricks gates need numbered consecutively starting need listed numerical order 
encoding lacking properties converted nc possessing sorting gate numbers replacing number rank sorted list 
tricks allow reductions chapter preserve topological order input circuit 
cvp variants considered chapter remain complete nc reduction restricted topologically ordered instances 
generally mention topological order subsequently 
consider monotone circuit value problem 
observed basic simulation turing machine circuit proof theorem monotone 
general direct monotone reduction interesting right 
argue detail book reduction fact nc computable reduction sim 
restricted versions circuit value ple provides convenient example techniques commonly portion completeness proofs 
theorem goldschlager monotone circuit value problem complete nc reductions 
proof 
reduce cvp instance instance constructing double logic 
value computed compute vertex vk original circuit construct pair vertices uk uk new circuit 
property uk true vk true uk false 
vk input xi uk xi uk negation xi 
note twice inputs xi computed machine performing reduction xi xi provided inputs 
monotone circuit course compute xi xi 
gate vk vi vj original circuit construct gate uk ui uj gate uk ui uj 
gate dual 
add new inputs having value gate vk vi construct gates uk ui uk ui 
easy show induction vertex depth vk evaluates true original circuit uk true uk false new circuit 
argue detail construction accomplished nc carefully specified circuit encoded 
assume reasonable formulation standard encoding scheme 
vertex circuit represented bits log 
string viewed blocks bits block block specifying vertex block number vertex number 
bits block indicate type vertex input remaining bits encode single input bit vertex number vertices predecessors vertex circuit 
case reductions key point devise scheme numbering vertices new circuit allows vertices edges easily computed vertices edges circuit 
purpose vertex vi simply assign numbers vertices ui ui derived vi 
new input vertices receiving values simulating gates numbered chapter 
circuit value problem respectively 
encoding easy see nc transform encoding encoding 
compute log 
simply build replicas circuit depth log input bits output bits performs obvious transformation block bits describing vertex produce blocks bits describing corresponding vertices 
note arithmetic necessary recode vertex numbers example easily accomplished circuit depth log especially considering vertex numbers log bits long 
remaining details omitted 
usually give proofs reductions fact nc nc computable 
usually tedious conceptually difficult 
known nc algorithms see karp ramachandran variety basic operations arithmetic sorting ranking parallel prefix prove useful 
show cvp remains complete restricted ways circuit monotone inputs connect gates outputs gates paths input output gates strictly alternate gates vertices indegree outdegree exactly obvious exceptions definition circuit input vertices indegree zero outputs outdegree zero 
show am cvp complete 
course implies restricted problem mentioned complete 
theorem alternating monotone circuit value problem fanin fanout gates restricted am cvp nc reductions 
proof 
accomplish starting monotone circuit series transformations assures additional property destroying properties achieved previous steps 
transformations follows 
phrase nc algorithm means algorithm polynomial hardware log running time regardless type problem solves decision search 

restricted versions circuit value xi gd 
xi xi gd 
connecting inputs gates theorem step 
replace input vertex xi fanout gate fanin fanout connected vertices 
gd xi 
new gate receive inputs new input vertices fanout receiving value copy xi 
see 
inputs fanout connected gates 

fanout zero gate create new vertex fanin receiving input output vertices replace gate fanout greater fanout tree consisting plus new gates fanin 
gates fanout 
types new gates arbitrary definiteness say vertices fanout 
see 
split edge connecting gates type inserting fanin fanout gate opposite type 
types strictly alternate paths 

gates fanin create new input vertex receiving value connect fanin replacement gates fanin create new vertices 
input vertices receiving value 
connected third fanin fanout gate turn connected fanin replacement gates fanin exactly 
note took care preserve properties introduced steps 
chapter 
circuit value problem 
gd gd gd fanout tree theorem step 
replicate circuit excluding input vertices replicas fed set inputs 
precisely circuit step 
form new circuit follows 
addition original gates edges gates input vertices add copy edge input vertex add edge add edge 
vertex outdegree create new vertex outdegree zero indegree inputs vertex outdegree create new vertices 
gate fanin fanout gate receiving inputs vertex new input vertex receiving value 
gates gates outdegree zero indegree connected gates outputs fanout 
see 
resulting circuit desired properties 
known nand complete basis set boolean functions 
reduction arbitrary instance circuit value problem instance easy 

restricted versions circuit value replication theorem step 
straightforward reduction am cvp nand cvp 
theorem nand circuit value problem complete nc reductions 
proof 
reduce am cvp complementing inputs relabeling gates nand gates 
correctness follows laws 
examine synchronous version circuit value problem 
natural approach transforming circuit synchronous identify fix edge violates synchronous restriction edge level level greater 
offending edge fixed inserting level level new vertices 
approach workable simple 
particular level function depends knowledge global structure graph 
level numbers known nc computable nc computable preclude nc 
chapter 
circuit value problem reduction approach 
case completeness reductions able take approach achieves goal synchrony globally applying simple local transformation 
theorem greenlaw hoover ruzzo synchronous alternating monotone circuit value problem fanin fanout gates restricted sam cvp nc reductions 
proof 
show am cvp nc sam cvp 
am cvp complete follows sam cvp complete 
number gates instance am cvp number inputs 
copies vertices input vertices gate vertices circuit 
th copy organized levels 
level th copy level new circuit consists copies input vertices copies gates called level 
level vertices input vertices level greater vertices gates 
second level th copy level new circuit consists copies gates called level 
gates levels gates 
odd numbered levels gates respectively gates obvious exception input level 
edges connect adjacent levels synchronous alternating properties easily follow 
instance am cvp fanin exactly input vertices fanout exactly true number gates equals number inputs plus number gates 
level new circuit exactly vertices 
similar reasoning number output vertices equal number input vertices need fact shortly 
describe connect copies new circuit equivalent 
vertex label copies vi 
edges gates preserved copy 
edge gate edges ui vi 
edges gates go copy corresponding vertex copy 
edge gate 
restricted versions circuit value edges ui vi 
input vertices vertices level zero assigned values follows 
copies input vertices input values 
copies gates input arbitrarily 
copies output vertices recall gates level circuit correct outputs argue shortly 
copies input output vertices levels handled specially 
need deliver input bits copy corresponding input vertex th level 
copies output vertices level connected satisfy synchrony restriction 
recall number inputs outputs pair arbitrarily 
suffices add replicas gadget shown luc personal communication 
gadget deliver copy input bit numbered level greater zero providing sink useless output paired output vertex previous odd numbered level 
completes construction 
clear circuit satisfies restrictions synchrony alternation fanin fanout 
correctness established induction assertion 
vertex level level copies vk compute value 
depth odd depth output gates correct value 
omit straightforward argument showing reduction performed nc close chapter technical remarks 
reductions performed theorems increased size original circuit constant factor 
reduction theorem produces circuit size size reduction provides alternative proof theorem showed cvp nc reducible topologically ordered cvp topological numbering directed acyclic graph known nc computable 
price pays quadratic increase size 
chapter 
circuit value problem level xn gadget 
copies input propagation gadget theorem 
chapter greedy algorithms consider selection basketball teams neighborhood playground illustrate greedy method 
usually top players designated 
players line alternate choosing player time 
usually players picked greedy strategy 
choose best unclaimed player 
system selection choosing best obvious convenient remaining candidate called greedy method 
greedy algorithms lead easily implemented efficient sequential solutions problems 
unfortunately sequential greedy algorithms frequently lead solutions inherently sequential solutions produced algorithms duplicated rapidly parallel nc equals subsections examine phenomenon 
lexicographic greedy algorithms illustrate important aspects greedy algorithms constructs maximal independent set graph 
independent set set vertices graph pairwise nonadjacent 
maximum independent set set largest cardinality 
known finding maximum independent sets np hard 
independent set maximal vertex added maintaining independent set property 
contrast maximum case finding maximal independent sets easy 
depicts simple polynomial time sequential algorithm computing maximal independent set 
algorithm chapter 
greedy algorithms greedy maximal independent set algorithm input undirected graph vertices numbered 

output lexicographically maximal independent set vertex connected vertex 
greedy maximal independent set algorithm 
greedy algorithm processes vertices numerical order attempting add lowest numbered vertex tried 
sequential algorithm having processed vertices 
easily decide include vertex notice decision potentially depends decisions earlier vertices included maximal independent set adjacent excluded 
algorithm highly sequential 
intuition valiant conjectured algorithm difficult parallelize 
cook showed natural decision problem derived complete take strong evidence support valiant conjecture 
valiant cook considered dual problem finding maximal clique problem general graph may maximal independent sets 
algorithm deterministic finds unique maximal independent set candidates 
solution finds dictated way vertices numbered finds solution sense 
take maximal independent set 
suppose 
list elements ascending order vertex number 
call sequence 
lexicographic greedy algorithms signature maximal independent sets lexicographically ordered signatures 
signature signature compared strings 
algorithm finds lexicographically maximal independent set 
define natural decision problem maximal independent sets 
see problem part ii related problems remarks 
definition lexicographically maximal independent set problem undirected graph ordering vertices designated vertex problem vertex lexicographically maximal independent set 
theorem cook lexicographically maximal independent set problem complete nc reductions 
proof 
membership follows algorithm 
completeness follows reducing circuit value problem modifying construction due anderson richard anderson personal communication 
loss generality assume instance gates numbered starting topological order inputs numbered outputs 
suppose designated output gate instance 
construct instance undirected graph graph exactly graph underlying circuit add new vertex numbered adjacent inputs 
easy verify induction vertex included lexicographically maximal independent set equals new vertex gate value true 
choice equal completes reduction 
proof reduction performed nc left reader 
show chapter simpler problem computing just size lexicographically maximal independent set difficult 
decision problems greedy algorithms known complete 
examples chapter 
greedy algorithms lexicographically depth search problem lexicographically vertex coloring problem fit decreasing bin packing problem 
examples fit common framework section 
generic greedy algorithms problems formulated independence systems consequently solved greedy methods 
independence system pair ordered set elements 
en collection subsets called independent set 
require independent sets property independence hereditary subsets computational problem interest compute lexicographically maximal independent set precisely compute greedy set ej 
jk jk set gi ej 
independent ji ji gi el independent 
example graph set vertices fg set subsets members pairwise nonadjacent ig fg independence system 
furthermore lexicographically maximal independent set ig precisely lexicographically maximal independent set problem graphs special case lexicographically maximal independent set problem independence systems 
difficult general problem independence systems 
sequentially simple straightforward modification greedy algorithm solves problem easily 
true setting explicitly oracle membership independence oracle 
explicit listing quite large may assume underlying structure may assume fg graph 
oracle simply lets test subset 
generic greedy algorithms easy solve sequentially problem provably parallelizable 
karp upfal wigderson show deterministic parallel decision tree algorithm finding maximal independent set independence oracle take time log number processors 
randomized algorithm requires log np 
natural restrictions general problem highly parallelizable 
important class restrictions set independence system vertex set graph set subset included just case vertex induced subgraph determined special property 
example take independence system ig corresponding problem case vertex induced subgraph contains edges 
special cases parallelizable 
know parallelizable equals nc complete 
surprisingly shown result miyano essentially special cases form complete 
terminology necessary explaining result 
graph property simply predicate graphs 
property nontrivial graph family infinitely graphs satisfying graph violating 
property hereditary induced subgraphs graph satisfies vertex induced subgraphs 
examples nontrivial hereditary properties planarity acyclicity 
problem compute lexicographically maximal vertex induced subgraph satisfying 
example property problem just problem 
note simple greedy algorithm shows problem fp polynomial time computable hereditary property 
miyano shown problem highly sequential graph property matter simple provided nontrivial hereditary 
theorem miyano polynomial time testable property nontrivial graphs respectively bipartite graphs planar graphs hereditary vertex induced subgraphs 
lexicographically maximal subgraph problem property respectively restricted bipartite graphs restricted planar graphs complete fp 
chapter 
greedy algorithms parallel greedy matroid maximal independent set algorithm rank oracle input matroid elements 
en rank oracle 
output lexicographically maximal independent set 
parallel rj rank 
ej rj rj include ej 
parallel greedy algorithm rank oracle 
foregoing results suggest greedy algorithms difficult impossible parallelize 
pessimistic view 
restrictions independence system relaxed requirements solution possible obtain highly parallel algorithms 
idea order elements unimportant part problem specification 
examples discussed 
study independence systems motivated part greedy algorithm matroids 
matroids independence systems additional property maximal independent sets cardinality lawler 
maximal sets maximum independent sets greedy algorithm obtains optimal solution 
construction minimum weight spanning trees classic application matroid theory 
application elements independence system edges graph set edges called independent acyclic 
forest 
cook gives fast parallel greedy algorithm matroids rank oracle function rank 
ej giving size maximal independent set 
ej 
see 
notice algorithm computes lexicographically maximal independent set 
cook applies algorithm show 
generic greedy algorithms finding minimum weight spanning tree graph nc accomplished sorting edges graph weight directly applying algorithm 
value rank 
ej simply minus number connected components vertex subgraph induced 
ej nc computable function 
general case independence system necessarily matroid finding maximum independent set rank oracle difficult 
karp upfal wigderson show deterministic parallel decision tree algorithm maximum independent set rank oracle requires time log np 
randomization allowed feasible highly parallel algorithm exists takes time log processors 
clear example power randomization parallel computation 
subject reader referred survey article rajasekaran reif 
second example shows cases problem solved greedy algorithm complete may possible obtain highly parallel solution related problem 
specifically finding lexicographically maximal independent set graph complete nc algorithm find maximal independent set luby 
summary history development results regarding independent set problem see karp ramachandran 
example fitting group consider fit decreasing algorithm bin packing 
known greedy heuristic guaranteed find packing optimal fit decreasing 
anderson mayr warmuth show complete construct packing fit decreasing algorithm problem nc algorithm giving packing optimal 
examples problems greedy solution complete naturally related problems known nc rnc include depth search see problems vertex coloring see problem maximal path see problems 
chapter complete algorithms focus point primarily problems decision search function 
chapter shift directions apply completeness theory study algorithms 
theory extended properly allow statements certain sequential algorithms parallelize 
phrase inherently sequential algorithm appears frequently research literature 
general intent phrase obvious 
pressed details come different possible formal meanings 
chapter describe approach gives phrase precise interpretation 
complete algorithms began anderson continued greenlaw 
discussion contained chapter taken 
problem complete evidence small space sequential solutions fast parallel solutions polynomial amount hardware 
course complete means problem polynomial time algorithm 
complete decision problems algorithm appears explicitly implicitly statement problem 
example asking vertex lexicographically maximal clique essentially asking vertex maximal clique obvious greedy algorithm greedy algorithm shows problem specification particular polynomial time algorithm addition nonalgorithmic properties desired solution occurs 
search problems section problems greedy lexicographically nature numerous graph problems section 
completeness results say difficulty parallelizing associated sequential algorithm intrinsic difficulty decision problem 
cases particular sequential algorithm adapt parallelism 
may case modified version problem avoids mentioning sequential algorithm highly parallel solution 
example consider bin packing problem 
problem anderson mayr warmuth show computing fit decreasing bin packing complete 
show nc algorithm producing alternative bin packing achieves performance fit 
problem description specifies performance bound associated algorithm 
associated sequential algorithm efficiently parallelized 
problem variant breadth search implemented stack complete alternative implementation queues parallelized run nc greenlaw 
ways interpret fact problem complete 
statement problem mention associated sequential algorithm reasonable say problem inherently sequential 
second statement problem involves associated sequential algorithm appropriate say algorithm inherently sequential 
second situation indicates need sophisticated way compare relative parallel complexities sequential algorithms just making statement decision problems underlying algorithms 
anderson took step proposing definition complete algorithm 
definition anderson algorithm search problem complete problem computing solution complete 
suppose graph wanted compute spanning tree algorithm computing spanning tree complete algorithm find different spanning tree run nc conceivable algorithms fact find tree different parallel chapter 
complete algorithms complexities 
anderson observed shortcoming definition failure directly tie internal computations algorithms 
suggests including trace algorithm part result computes way incorporate internal computations 
greenlaw proposed model focus directly algorithms 
section summarize description model 
inherently sequential algorithms model satisfy issues raised needs incorporate detail permit classification algorithms respect parallel complexities 
anderson pointed intermediate values algorithms compute distinguish parallel complexities 
model capable capturing trace algorithm 
base model chosen random access machine ram 
idea assign value step algorithm 
examining sequence values algorithm generates input classify algorithm parallel complexity 
preliminaries terminology taken greenlaw 
ram algorithm ram program statements numbered sequentially 
corresponding ram algorithm statement associated value 
value associated statement simply valuation left hand side statement 
instruction assumed executed 
sample values couple instructions shown table 
full table 
explanation notation 
notation aho hopcroft ullman 
table denotes contents register customary register ram serves accumulator 
register computation performed 
denotes value operand follows 
values associated indirect addressing instructions 
second value determines cell read written 
corresponding step ram algorithm executed associated 
inherently sequential algorithms value generated 
statement generates values number times executed 
instruction associated value load store add write halt table sample ram instructions associated value 
definition illustrates function associated particular ram algorithm 
definition ram algorithm alphabet statements numbered sequentially starting ram flow function fa corresponding defined fa xn 
vt vi represent ordered pairs consisting statement numbers value pairs associated execution statements input xn 
xn 
algorithms halting inputs define fa fa denotes maximum running time algorithm inputs length length flow function algorithm input denoted fa related running time definition statement numbers values generated statement represented integers reasonable encoding scheme 
logarithmic cost model assumed fa times running time flow function plays important role classifying algorithm respect parallel complexity illustrated definition 
chapter 
complete algorithms definition ram algorithm flow function fa 
ram algorithm inherently sequential language la bit fa associated flow function complete 
algorithm considered inherently sequential flow function difficult compute complete problem 
furthermore definition theorem shows polynomial time algorithm computing solution complete problem inherently sequential 
theorem polynomial time ram algorithm decides language inherently sequential 
proof 
proof left exercise reader 
applications model results illustrating model section 
example involves 
easy see ordered depth search algorithm standard depth search algorithm fixed ordered adjacency lists inherently sequential sense defined 
prove apply theorem result problem 
observation follows algorithm biconnected components ordered depth search algorithm inherently sequential 
contrast fact known parallel algorithm computing biconnected components graph runs time log time processors crcw pram tarjan vishkin 
algorithms described output inherently sequential nc role model case highlights individual steps algorithms 
allows compare parallel complexities meaningful way 
search problems algorithm may find solution problem nc approach inherently sequential 
usually solutions computed algorithms different 
problems interesting usually important specific solution 
finding alternative inherently sequential algorithm useful 
example problem involves maximal paths 
problem 
applications model computing lexicographically maximal path complete anderson mayr 
follows directly theorem result greedy algorithm compute path inherently sequential 
known different approach taken obtain maximal path rnc see problem additional details 
final example involving gaussian elimination simply note numerous examples 
gaussian elimination partial pivoting solve system equations process inherently sequential problem complete vavasis 
approach solution system nc illustrates idea intermediate values algorithm computes just final answer important determining algorithm parallel complexity 
see problem gaussian elimination partial pivoting 
results strongly suggest inherently sequential algorithms amenable automatic parallelization compilers problems solve may fact nc solutions 
due fact compilers sophisticated discover alternative parallel approach 
proving algorithm inherently sequential step showing problem parallelizable showing different algorithmic approach needs problem 
example problem approach taken fill slots problem 
chapter notions completeness strong completeness usual conventions algorithm analysis express complexity finding solution terms length problem input 
generally complexity sensitive encoding scheme describe problem instances 
extreme example complexity factoring positive integer encoded binary quite different factoring number encoded unary encoded product prime factors 
realistic complexity analysis assumes encoding conventions problem reasonable trivial evidence difficulty see section 
sensitivity encodings particularly significant number problems 
problems numerical values parameters problem instance larger size problem description 
example description size represent network vertices edges edge capacities size 
flows network described problem instance exponentially larger size definition captures concept 
definition instance problem max denote maximum magnitude numbers encoding scheme problem denote length encoding instance 
problem number problem 
strong completeness exists encoding scheme problem exist polynomial instance max 
typical characteristic number problem binary encodings parameters instance replaced unary encodings size encoding increases exponentially 
unary encoded version large permit problem solved efficiently terms input length 
definition algorithm associated encoding scheme solves problem called pseudo nc algorithm variable polynomial single variable polynomial instance problem solved parallel time log log max processors 
key feature pseudo nc algorithm execution time sensitive size numbers problem instance 
example helmbold mayr show general list scheduling problem pseudo nc algorithm 
notion similar pseudo nc expressed terms size numbers output applied problems run time sequential algorithm polynomial size result 
example knows lexicographically maximal independent set graph size log nc algorithm find simply run obvious greedy algorithm parallel see log steps cost log step 
similarly maximum flow network log standard augmenting path algorithm converges log iterations 
log cost iteration bounded flow determined nc problem number problem encodings numbers instance polynomially bounded terms efficiently encoded unary 
means pseudo nc algorithm problem nc algorithm 
observation direct analogy case np completeness theory 
observation problem complete number problem problem solved pseudo nc algorithm nc equals completeness proof decision problem may involve reduction numbers generated magnitudes chapter 
notions completeness exponential original problem size 
large numbers occur common problem instances argue particular proof completeness weak evidence problem hard practice 
reduction small numbers provide convincing argument common cases problem difficult 
fact restriction small numbers problems solutions easier parallel 
example general list scheduling problem complete job times restricted small integers helmbold mayr give nc algorithm problem 
considerations give rise notion strong anderson analogous strong npcompleteness garey johnson 
definition decision problem complete strong sense alternatively strongly complete problem complete exists polynomial problem remains complete restricted instances satisfy max 
remarks section pertaining type reducibility employed apply 
example strongly complete problem linear inequalities problem variation linear programming problem 
linear inequalities remains complete coefficients restricted stephen cook personal communication 
problems strongly complete gaussian elimination partial pivoting problem fit decreasing bin packing problem 
known maximum flow problem strongly complete 
problems involve numbers automatically strongly complete 
example circuit value problem strongly 
notion strong completeness useful differentiating number problems 
observation decision problem complete strong sense problem solved pseudo nc algorithm nc equals 
strict completeness strict completeness section describes material 
tried cover main results regarding strict completeness theory omitted numerous technical details presentation 
language solved sequentially time 
say parallel speedup parallel algorithm reasonable model takes time function 
say polynomial speedup parallel speedup exists 
existence complete problems means problem sequential time parallel speedup log constant dramatic speedup impossible polynomial speedup useful 
example parallel speedup feasible number processors dramatic improvement problem practice 
kruskal rudolph snir vitter simons observed limited polynomial speedup possible number problems 
example second set authors considered exhibited speedups non sparse versions circuit value problem depth search path systems unification 
see problems additional remarks 
set authors introduced class sp defined page semi efficient parallel time algorithms polynomial speedup 
polynomial speedup possible problem 
condon introduced notion strict complete identify problems exhibit parallel speedup improvement performance imply problems possessed polynomial speedup 
believes problems polynomial speedup strict problems polynomial lower bounds parallel performance 
definition strict complete somewhat technical requires notions 
problems considering speedups sufficient produce nc solutions smooth differences parallel models computation dropping powers log preserving dominant polynomial terms running times 
expressed soft chapter 
notions completeness oh notation defined 
definition functions domains natural numbers ranges positive real numbers 
precisely exist constants log natural numbers 
secondly reductions require properties 
reduction honest exist constants function eventually nondecreasing exists 
eventually nondecreasing polynomial function useful upper lower bound property see condon proof 
lemma eventually nondecreasing function rational number natural number 


key idea strict completeness find problems complete additional property simulate way preserves polynomial speedup 
problem strict complete polynomial speedup performance parallel solution implies problems polynomial speedup 
turing machine program polynomial speedup pram ram matter notion strict complete useful model sequential time stated comparable single processor instance model parallel time stated 
reason sequential time complexity strict complete problems stated terms ram algorithms 
definition captures idea 
suppose nc reduction language language means nc solution results nc solution means parallel solution say time results parallel solution resulting parallel time testing requires performing reduction testing testing takes time 
quite large possible parallel time 
strict completeness obtained reduction worse sequential time worst parallel running time solving parallel reduction worse solving sequentially 
example suppose parallel time reduction parallel time 
sequential time order parallel time worse sequential time 
definition language complete language sequential ram running time eventually nondecreasing exists honest nc reduction 
definition contains number technical considerations important mask polylogarithmic factors 
say language sequential running time complete says parallel time language reducible long parallel time 
known parallel running time result 
definition language strict complete complete parallel running time 
fundamental strict complete problem solving square version sam cvp problem 
definition square circuit value problem encoding synchronous alternating monotone fanin fanout boolean circuit inputs 
xn designated output circuit additional restriction square 
number gates level equals depth 
problem output true input 
xn 
condon shows square circuits efficiently simulate ram computations stated theorem 
theorem requires technical notion time 
function time constructible nc value computed nc chapter 
notions completeness theorem ram runs time simulated family square circuits depth 
furthermore specific ram input time constructible nc corresponding circuit constructed nc careful reader notice reasons various technical considerations definition strict complete 
theorem square circuit value problem strict 
proof 
easy see size square circuit evaluated parallel time processors 
language sequential running time eventually nondecreasing 
ram accepts time 
need show honest nc reduction 
lemma rational number natural number 
computable nc implies apply theorem machine running input obtain square circuit depth 
inputs circuit correctly decides membership function produces corresponding square circuit 
order size circuit 
equation lower bound get honest 
equation get 
required 
known example strict complete problem finite horizon markov decision process problem 
assumption finite horizon time satisfies number states condon shows strict complete 

strict completeness problems known strict complete complete synchronous alternating monotone circuit value problem fanin fanout restrictions problem lexicographically maximal independent set problem lexicographically depth search ordering problem stack breadth search problem fit decreasing bin packing problem unification problem 
lexicographically maximal clique problem example problem parallel algorithm problem known complete 
chapter approximating complete problems suppose finding solution problem complete 
natural ask easier obtain approximate solution 
decision problems mean considering corresponding combinatorial optimization problem 
problem try minimize maximize quantity 
expect theory np completeness answer example case bin packing problem example case lexicographically maximal independent set size problem see lemma 
motivations developing nc approximation algorithms 
likelihood complete problems solved fast parallel 
may useful approximate quickly parallel 
second problems complete approximated special boundary cases 
examining types problems closely improve understanding parallelism 
third important build theoretical foundation studying classifying additional approximation problems 
may possible speed sequential approximation algorithms np complete problems fast parallel approximations 
goal section develop basic theory parallel approximation algorithms 
showing certain complete problems amenable nc approximation algo 
approximating hard rithms 
examples complete problems approximated parallel 
approximating hard start considering lexicographically maximal independent set problem introduced definition proven complete problem 
defined directly amenable approximation 
phrase problem terms computing size independent set 
definition lexicographically maximal independent set size undirected graph ordering vertices integer problem size lexicographically maximal independent set equal 
lemma shows computing just size lexicographically maximal independent set complete 
lemma greenlaw hoover ruzzo lexicographically maximal independent set size problem nc reductions 
proof 
reduce 
instance 
assume vertices numbered 
form new graph adding set new vertices 
adjacent output pair 
size lexicographically maximal independent set respectively 
holding lexicographically maximal independent set lexicographically maximal independent set equal evident reduction nc computable 
result natural ask nc algorithm approximating size consider approximation algorithm graph having size computes estimate se 
hope approximate estimate se worst poly nomial estimate 
se chapter 
approximating complete problems appropriate constants 
note imagine requiring approximation algorithm deliver solution achieved estimate 
course sense underestimating maximization problem produce lexicographically independent set smaller maximal finding larger impossible 
general setting approximation algorithm possible nc equals theorem greenlaw hoover ruzzo size lexicographically maximal independent set graph 
nc equals nc approximation algorithm compute estimate se se 
proof 
modify construction proof lemma 
independent set added producing new graph lexicographically maximal independent set smaller equal lexicographically maximal independent set contains designated vertex greater 
independent set chosen greater producing separation determine answer instance 
larger construct integer size greater lk add lemma form note size polynomially larger size 
se integer obeying bounds statement theorem 
equal se 
hand greater se 
se equal se greater 
consequently approximating hard 
reductions frequently scaled way defeat polynomial time approximation algorithm 
additional problems nc approximation algorithms completeness proofs scaling process unit resolution problem problem 
approximation schemes path systems problem circuit value problem serna serna spirakis 
problems exhibit threshold type behavior 
consider maximization problem need compute maximum possible size quantity 
problems existence nc algorithm approximates maximum factor better implies nc equals factor nc algorithms exist solving problems 
examples problems possessing behavior high degree subgraph see problem high connectivity subgraph see problem 
kinds algorithms give rise approximation schemes generate class algorithms nc analogy case np completeness 
approximation schemes suppose combinatorial optimization problem maximize minimize quantity 
example deliver flow maximum schedule minimum length 
approximation scheme takes instance optimization problem delivers candidate solution near optimal 
measure performance optimization scheme takes ratio performance candidate solution optimal 
formalize notion adapting definitions garey johnson framework 
definition suppose approximation algorithm instance minimization maximization problem delivers candidate solution value 
opt denote value optimal solution 
performance ratio ra opt respectively ra opt 
absolute performance ratio approximation algorithm ra infimum ra instances 
definition problem 
algorithm inputs approximation scheme delivers candidate solution instance performance ratio ra 
algorithm nc approximation chapter 
approximating complete problems scheme fixed runs parallel time log processors note definition inputs algorithm general time processor bounds depend value size instance nc approximation scheme parameter fixed resource requirements depend 
nc approximation scheme exponential 
behaves nicely fully nc approximation scheme 
definition problem 
algorithm inputs fully nc approximation scheme variable polynomial variable polynomial candidate solution instance ra computed parallel time log log processors log 
example problem fully nc approximation scheme bin packing problem 
anderson mayr warmuth observe sequential approximation algorithm achieves packing factor converted nc algorithm 
see mayr 
example knapsack problem 
mayr shows solution profit log log log time processors erew pram 
mayr shows makespan problem list scheduling problem fully nc approximation schemes 
theorem integer valued combinatorial optimization problem 
exists variable polynomial instances satisfy opt max existence fully nc approximation scheme implies existence pseudo nc algorithm 
proof 
proof similar theorem garey johnson 
translate proof setting 
suppose fully nc approximation scheme suppose loss generality maximization problem 
pa qa polynomials corresponding consider choice max 

approximation schemes computes candidate solution instance parallel time pa log log pa log log max log log max appropriate polynomial 
uses processors qa log qa log max appropriate polynomial log max 
ra follows opt 
opt 
opt original assumption opt get opt opt 
integer valued implies opt 
combining existence polynomials see pseudo nc algorithm exists 
steps compute quickly parallel run input corollary stated follows theorem observation 
corollary suppose integer valued combinatorial optimization problem satisfies hypothesis theorem 
problem strongly complete solved fully nc approximation scheme nc equals chapter closing remarks previous chapters laid history foundations mechanics theory completeness 
shown theory plays roughly role parallel complexity domain np completeness sequential domain 
having devoted effort establishing notion feasible highly parallel algorithms arguing completeness captures notions inherently sequential problems algorithms appropriate temper case bit additional observations 
problems depending relevant input size may worth effort search feasible highly parallel algorithm assuming example time parallel algorithm 
table shows relationship square roots logarithms various input sizes 
course small input sizes constants running times play major role 
table values log extremely risky predict hardware trends safe say massively parallel computers containing billions processors just corner potentially feasible machines millions processors soon commodity personal computers 
highly parallel algorithms feasible processor requirements input size greater probably log sufficient numbers processors problems interest algorithm may tyranny asymptotics 
example parallel algorithm uses time probably preferable uses log time values table illustrates really practical polylogarithmic parallel time algorithms log 
limit feasible highly parallel algorithms run log time processors 
search nc algorithm leads new insights problem effectively parallelized 
problem frequently exhibit unexpected parallelism limits parallelism pushed 
development feasible highly parallel algorithms viewed useful step practical parallel algorithm development 
forces consider different methods splitting recombining solutions subproblems consider alternative approaches merely parallelizing existing sequential algorithms 
balance theory completeness extremely rich important terms foundations parallel computation 
theory needs applied interpreted correctly 
parallel computers widely available see widely theory applied practice 
theory helped greatly increase understanding parallel computing guide algorithm designers suggest new approaches problem solving 
evidence follows appendices systematically categorize known results 
believe utility field continue grow rapidly 
fact field grown rapidly years difficult keep problem lists date finish book 
appreciate readers supplying copies papers works inadvertently omitted copies chapter 
closing remarks new research papers subject available 
nc versus question difficult open problem 
appears new mathematical proof techniques required solve 
having shown design problem search sublinear time parallel algorithm secure knowledge continuing employment 
part ii compendium problems second part book divided main appendices 
intention provide comprehensive list complete problems provide date list open problems 
goal provide lists problems classes cc rnc appendix contains list complete problems 
variations problems counted probably closer entries list 
problems classified dozen different subject areas 
grouping precise tried put related problems category 
problems ordered defined reductions 
possible way categories defined ordered cross problem definition 
include cross similar problems 
appendix contains list open problems problems known nc complete 
problems split different subject areas 
appendix lists problems classes cc rnc appendix describes notation book 
appendix groups complexity class definitions 
appendix complete problems appendix contains compendium complete problems 
entry give description problem input provide source papers showing problem complete give hint illustrating main idea completeness reduction mention related versions problem 
remarks include variation problem known nc problems variations complete described 
problems marked hard known problems marked fp 
distinctions decision problems search problems 
note word computation problem synonymously search problem 
problems usually omit proofs demonstrating 
proofs usually accompanying problems 
problems originally shown complete respect logarithmic space reductions 
logarithmic space computation immediately nc borodin simulation 
problem logarithmic space complete nc complete cases reduction done nc problem nc complete noted exceptions exhaustive 
word caution order regarding proof hints 
hints vary greatly amount detail provide 
expert able construct completeness proofs directly hints 
fact problems completely reduction involved 
problems may possible appendix complete problems deduce entire reduction hint 
complex reductions decided reproduce entire reduction 
cases reader refer back original provided 
lastly similar hint different problems involve simple reduction extremely complex 
problems divided categories 
circuit complexity graph theory searching graphs combinatorial optimization flow local optimality logic formal languages algebraic geometry real analysis games miscellaneous complete list complete open problems problem list page 
addition index entries problem name acronym 

circuit complexity circuit complexity circuit value problem cvp plays role theory satisfiability problem npcompleteness theory 
section variants cvp complete particularly useful proving problems complete 
see chapter details regarding cvp chapter boolean circuits 
circuit value problem cvp encoding boolean circuit inputs 
xn designated output problem output true input 
xn 
ladner 
hint proof chapter 
remarks input basis boolean functions known cvp complete basis consists solely consists solely consists xor equivalence goldschlager 
topologically ordered circuit value problem encoding boolean circuit inputs 
xn designated output additional assumption vertices circuit numbered listed topological order 
problem output true input 
xn 
folklore 
hint proof theorem 
see remarks proof theorem 
remarks reductions chapter section preserve topological ordering restrictions variants circuit value problem topologically ordered instances remain complete 
appendix complete problems monotone circuit value problem encoding boolean circuit inputs 
xn designated output additional assumption monotone 
constructed solely gates 
problem output true input 
xn 
goldschlager 
hint reduce circuit value problem 
proof section 
vitter simons give time parallel algorithm non sparse version problem 
alternating monotone fanin fanout cvp am cvp encoding monotone boolean circuit inputs 
xn designated output path input output gates required alternate gates 
inputs required connected gates outputs come directly gates 
circuit restricted fanout exactly inputs internal gates distinguished gate output 
problem output true input 
xn 
folklore 
hint proof section 
remarks goldschlager shaw staples gave completeness proof monotone fanout cvp 
nand circuit value problem encoding boolean circuit inputs 
xn designated output circuit constructed nand gates restricted fanout inputs nand gates 
problem output true input 
xn 
folklore 
hint reduction am cvp 
proof section 
remarks complete basis gates suffices obvious simulation nand gates basis 
example gates form complete basis 
defined analogously nand cvp 
see post characterization complete bases 
see 
circuit complexity remarks problem bases necessarily complete associated circuit value problem complete 
synchronous alternating monotone fanout cvp sam cvp encoding monotone boolean circuit inputs 
xn designated output addition restrictions problem version requires circuit synchronous 
level circuit receive inputs gates preceding level 
problem output true input 
xn 
greenlaw hoover ruzzo 
hint proof section 
reduction am cvp problem 
planar circuit value problem encoding planar boolean circuit inputs 
xn designated output planar circuit graph drawn plane edges crossing 
problem output true input 
xn 
goldschlager 
hint reduce circuit value problem 
lay circuit cross circuits replace crossing lines planar 
planar xor circuit built gates planar cross circuit built planar xor circuits 
gate cvp instance embedded grid follows 
gate cell value sent wire th row left right 
gate inputs delivered wires th column data flowing wires 
gate inputs outputs gates suppose happens cell happens point horizontal output wire crosses respectively vertical input wire insert input output planar discards value entering passes value entering left right 
input appendix complete problems treated similarly obvious changes orientation greater wire crossings insert copy planar cross circuit 
note wiring cell easily determined input 
reduction performed nc original circuit topologically sorted 
remarks easy see monotone planar cross networks exist reduction done monotone case 
fact monotone version logcfl nc inputs appear face planar embedding cook goldschlager mayr 
general problem inputs may appear nc delcher kosaraju kosaraju 
complete characterization bases possible construct planar cross circuits mccoll 
arithmetic circuit value problem encoding arithmetic circuit dyadic operations inputs 
xn ring 
problem input 
xn output 
personal communication 
hint reduce follows true false denotes additive identity denotes multiplicative identity ring 
remarks problem necessarily fp infinite rings intermediate values need polynomial length 
fp finite ring remains hard ring 
hard decide gates arithmetic circuit small values say values magnitude look related problems 
problem nc circuits degree log degree vertex inputs max vertex product respectively sum values computed vertices degree miller ramachandran valiant 

circuit complexity min plus circuit value problem encoding min circuit rational inputs 
xn 
problem input 
xn output nonzero value 
personal communication 
hint reduce monotone circuit value problem min follows true false min min 
remarks reduction works ordered semi group additive identity element 
nonzero element reduce min 
ordered semigroup minimum element cases holds 
semigroup infinite problem may circuit depth ones encoding boolean circuit plus inputs 
xn number 
denote maximum depth true value propagates input 
problem find integer spirakis 
hint problem stated computation problem 
technically reduction showing problem hard problem 
easy construct deeper circuit approximate depth ones new circuit determine output 
remarks extension constructed preserve properties monotonicity fan alternation planarity spirakis serna 
circuit true gates encoding boolean circuit plus inputs 
xn number 
denote number gates evaluate true 
problem find integer serna 
hint problem stated computation problem 
appendix complete problems technically reduction showing problem hard cvp 
easy construct larger circuit approximate output new circuit determine output 
remarks extension constructed preserve properties monotonicity fan alternation planarity 
inverting nc permutation perm input output nc see definition page circuit computing bijective function problem bit equal 
astad section 
hint reduction cvp problem 
problem called straight line program 
instance cvp 
xn denote inputs bn 
bm denote gates 
gate bm output gate 
notation bk represents value gate bk indicates gate bk receives inputs outputs gates circuit permutation constructed 
zm collectively denote input bits 
gm output bits 
defined follows 
gk zk 

gk zk bk zik zjk 
hard see th bit 
xn 
value gate bm 
remarks problem known general family permutations show hardness polynomial time invertible 
see boppana lagarias additional remarks way functions 

circuit complexity circuit evaluation monoids cem finite monoid containing group finite set associative binary operation elements acts identity element encoding circuit gates type inputs 
xn designated output problem evaluate input 
xn 
mckenzie 
hint reduction circuit value problem 
remarks solvable problem det class problems nc turing reducible computing integer determinants see page 
see problems 
appendix complete problems graph theory lexicographically maximal independent set undirected graph ordering vertices designated vertex problem vertex lexicographically maximal independent set 
cook 
hint proof section 
remarks instance lexicographically maximal subgraph problem 
complete bipartite planar graphs restricted degree miyano 
karp observed completeness implies determining th vertex chosen deterministic sequential algorithm problem complete 
computing approximating size lexicographically maximal independent set complete see section 
luby gave nc algorithm finding maximal independent set subsequently improved luby alon babai itai goldberg spencer 
algorithms compute lexicographically maximal independent set 
general result involving inference systems miyano shows forest solved crew pram log time polynomial number processors 
lexicographically maximal clique undirected graph ordering vertices designated vertex problem vertex lexicographically maximal clique 
cook 
hint finding maximal clique equivalent finding maximal independent set complement graph see problem 
stewart shows ordered greedy clique ordered remaining 
graph theory clique complete 
decision problems heuristic greedy algorithms computing cliques 
alternating graph accessibility problem directed graph partition vertices designated vertices problem apath true apath defined follows 
vertices universal existential graph called alternating graph graph 
predicate apath holds 

existential apath 
universal apath holds 
chandra kozen stockmeyer immerman 
hint reduce am cvp problem 
create existential vertices 
put edge xi input xi edge xi input xi 
gates universal vertices gates existential vertices 
inputs gate correspond children alternating graph 
output gate circuit apath holds output 
remarks original proof simulated alternating turing machine atm directly show complete atm logarithmic space 
showed complete 
problem generalized hierarchical graphs remains provided graph breadth ordered see lengauer wagner 
proof sketched shows problem remains complete partition induces bipartite graph 
restricted existential vertices problem equivalent directed graph accessibility problem variously called gap shown savitch complete nlog 
peterson gary peterson personal communication shows undirected version complete 
restricted undirected graphs appendix complete problems existential vertices problem equivalent undirected graph accessibility problem called known complete special case nondeterministic logarithmic space known symmetric logarithmic space lewis papadimitriou 
shows generalization complete reduction path systems problem 
considers graph reachability problem directed hypergraphs graphs edges consist subset vertices single vertex 
hierarchical graph accessibility problem hierarchical graph designated vertices hierarchical graph 
gk consists subcells gi subcell graph contains types vertices called pins inner vertices nonterminals 
pins vertices subcell connected outside 
inner vertices connected outside 
nonterminals stand previously defined subcells 
nonterminal inside gi name type 
name unique number string 
type number 

nonterminal type stands copy subcell gj 
neighbors correspondence pins gj mapping specified part 
problem path expansion graph 
expansion graph hierarchical graph expanded 
graph expanded expanding cell gk recursively 
expand subcell gi expand subcells 
gi recursively replace nonterminal type copy expansion subcell gj 
lengauer wagner 
hint reduction alternating graph accessibility problem 
remarks hierarchical versions problems complete graph accessibility undirected graphs determining directed graph contains cycle determining graph bipartite 
restricted versions hierarchical graph problems complete 
see details 

graph theory restricted chromatic alternating graph accessibility problem alternating graph natural numbers log coloring 
vertices note coloring unrestricted assignment colors edges 
may assign color edges incident common vertex 
see problem definition alternating graph 
problem different colors 
ik 
apath holds subgraph induced edges colors 
ik 
see problem definition apath 
lengauer wagner 
hint trivial reduction alternating graph accessibility problem 
membership follows membership possible sets colors try 
remarks problem remains complete vertices restricted breadth ordered 
generalized hierarchical graphs problem np complete 
lexicographically vertex coloring undirected graph equal maximum degree vertex ordering 
vn vertices designated color vertex problem vertex colored color lexicographically coloring vertices 
coloring assignment colors vertices adjacent vertices receive color 
coloring uses colors 
ci color vi ci 
coloring corresponds ary number coloring defined 
michael luby personal communication luby 
hint computing lexicographically coloring easily done polynomial time examining vertex order coloring smallest available color 
show completeness reduce problem 
coloring correspond evaluating circuit topological order 

vn gates circuit assume gates numbered appendix complete problems topological order 
gate circuit represented vertices order vertices induced order gates 
consider nand gate vi vj vk 
introduce new vertices appear vj vk appear vi topological ordering 
gate represented edges vj vk vi 
final fix necessary 
keep degree fanout tree may required output gate 
resulting graph colored colors order necessary different ordering 
remarks problem coloring np complete garey johnson 
graphs odd cycle complete coloring polynomial time brook theorem see brooks example bondy murty 
necessarily lexicographically coloring 
vertex coloring nc reducible finding maximal independent set michael luby personal communication maximal independent set algorithm karp wigderson produce lexicographically maximal independent set 
possible color graph colors nc coloring produced lexicographically hajnal szemer di naor karloff 
show tree structured graphs solved nc 
nc algorithms coloring planar graphs karloff naor 
karloff shmoys give nc algorithms edge coloring problems 
particular show multigraphs edge colored colors common crcw pram log time processors 
model multigraphs equal colors log time processors 
model simple graphs colors karloff shmoys obtain log time processor algorithm 
results nc algorithm polylogarithmic 
see problem 
high degree subgraph hds undirected graph integer problem contain vertex induced subgraph minimum degree 

graph theory anderson mayr 
hint reduce am cvp problem hds 
proof illustrated equals generalized fixed greater equal 
true input connected gate represented gadget vertices edges gadget 
connected vertex gadget gate described 
false input represented single vertex 
gate inputs outputs represented fourteen vertex gadget 
gadget composed gadgets represent true inputs additional vertices 
label vertices corresponding true input gadget 
label positions corresponding respective copy true input gadget 
additional vertices labeled 
connected clique 
connected 
inputs gate connected outputs connected appropriate input positions gates 
representation gate similar gadget omitting connecting directly 
binary tree leaves vertices corresponding true inputs vertex corresponding output vertex circuit root 
computation hds degree proceeds new graph hds nonempty output circuit true 
remarks stated lexicographically problem hds graph unique 
instance lexicographically maximal subgraph problem 
nc algorithm computing hds equals 
denote largest induced subgraph minimum degree fixed consider finding approximation ck 
nc algorithm finding greater problem finding complete 
complementary low degree subgraph problem see problem studied natural decision problems np complete greenlaw 
decision problems ordered vertex removal relating subgraph computations complete 
special case hds color index problem vishwanathan sridhar undirected graph appendix complete problems color index equal 
color index maximum subgraphs minimum degree asking color index equal complementary asking high degree subgraphs order 
original reduction color index ordered low degree vertex removal problem 
see remarks problem 
high connectivity subgraph hcs undirected graph integer problem contain vertex induced subgraph vertex edge connectivity 
serna spirakis serna 
hint reduction monotone circuit value problem similar prove problem high degree subgraph problem complete 
remarks approximation algorithms problem exhibit threshold type behavior 
certain value absolute performance ratio problem remains complete fixed ratio nc approximation algorithms problem serna spirakis 
specifically maximum size vertex connected induced subgraph possible find nc vertex induced subgraph size greater equal possible nc equals edge connectivity threshold equal 
khuller schieber algorithm arbitrary crcw pram undirected graph integer tests vertex connected 
vertex connected obtain set vertices removal disconnects algorithm runs log time uses processors number arbitrary crcw pram processors required compute connected components vertex edge graph logarithmic time 
polylogarithmic nc algorithm 
reliable connectivity failures incoming edges directed acyclic graph distinguished vertices additionally function assigns nonnegative integer vertex equal 
graph theory indegree choice failed edges vertex denoted 
consists set incoming edges cardinality equal 
problem directed path consisting edges 
spirakis 
hint reduction monotone circuit value problem 
idea consider circuit directed acyclic graph 
inputs represented vertices edges directed output gate vertex introduced connected true inputs 
value vertices corresponding gates value 
output circuit instance true remains connected set failure edges 
remarks general problem input graph required directed acyclic graph np complete 
spirakis point apparent reduction complexity due restriction directed acyclic graphs allowing failures edges 
show approximating complete 
define problem called feasible connectivity vertex causes edges fail 
question exists failure pattern path 
problem nc 
spirakis define problem called reliably long path 
problem exactly arcs leading vertex fails goal compute maximum number directed acyclic graph path source vertex length probability 
show problem complete 
ordered high degree vertex removal undirected graph numbering vertices designated vertices problem elimination order 
vn satisfying properties eliminated vi lowest numbered vertex maximum degree st remaining subgraph 
elimination order sequence vertices ordered corresponding edges deleted graph 
appendix complete problems greenlaw 
hint reduction problem fanin fanout restrictions 
circuit transformed directly graph 
vertices graph ordered gates evaluating false circuit deleted instance 
special vertex degree added removal order compared vertex corresponding output gate circuit 
ordered low degree vertex removal undirected graph numbering vertices designated vertices problem elimination order 
vn satisfying properties eliminated vi lowest numbered vertex minimum degree st remaining subgraph 
vishwanathan sridhar greenlaw 
hint complementary problem problem 
remarks problem defined restricted 
graphs required property appears minimum elimination sequence appears minimum degree elimination sequences 
ordered vertices remaining undirected graph numbering vertices designated vertex integer problem elimination order 
vn satisfying properties vj vi lowest numbered vertex maximum degree st remaining subgraph 
greenlaw 
hint reduction ordered high degree vertex removal problem 
remarks ordered low degree subgraph membership problem complete 
problem determine designated vertex remaining subgraph vertices remaining subgraph small degree 

graph theory neighborhood removal nr undirected graph numbering vertices designated vertices problem vertex removed vertex neighborhood removal algorithm run 
neighborhood removal algorithm processes maximum degree vertices remaining subgraph lowest vertex numbers 
iterates vertices deleting neighborhoods remaining subgraph 
greenlaw 
hint reduction ordered high degree vertex removal problem 
remarks neighborhood removal algorithm slight variant subroutine wigderson heuristic algorithm graph coloring problem heuristic algorithm minimum vertex cover problem lingas 
light fact nr complete heuristic algorithms neighborhood removal algorithm subroutine parallelize 
greedy dominating set gds undirected graph numbering vertices designated vertex problem vertex dominating set formed execution greedy dominating set algorithm 
dominating set subset exists vertex said cover greedy dominating set algorithm builds dominating set placing numbered vertex covers vertices dominating set 
procedure repeated vertices covered 
stewart 
hint reduction ordered high degree vertex removal problem 
remarks greedy heuristic find small dominating sets 
known general version problem called dominating set np complete garey johnson 
appendix complete problems nearest neighbor traveling salesman heuristic finite set 
cn cities distance matrix entries dij positive integers distinguished vertices problem nearest neighbor tour starting visit vertex completing tour 
nearest neighbor tour greedy heuristic chooses nearest unvisited vertex vertex tour 
lenstra shmoys 
hint reduce problem 
loss generality assume gates numbered topological order 
gate inputs outputs replaced gadget described 
gadget vertices triple mean distance triples gadget 
vertex gate connected vertex gate 
distances vertices left unspecified assumed large 
edges vertices vertices represent inputs outputs respectively 
edge included included tour represents true respectively false value 
true circuit inputs chained tour begins true input 
inserting new vertex vertex gadget connecting true input input chain tour constructed visited circuit evaluates true respectively false 
remarks nearest merger nearest insertion cheapest insertion farthest insertion heuristics complete 
double minimum spanning tree nearest addition heuristics nc 
see problem 
lexicographically maximal subgraph undirected graph ordering designated vertex polynomial time testable nontrivial hereditary property 
property nontrivial infinitely 
graph theory graphs satisfy property graph 
property hereditary induced subgraphs satisfies vertex induced subgraphs 
problem lexicographically maximal subgraph satisfies 
miyano 
hint property nontrivial hereditary ramsey theorem implies satisfied cliques independent sets vertices 
observation combined facts lexicographically maximal clique problem lexicographically maximal independent set problem complete show 
remarks examples properties meet criteria stated problem bipartite chordal clique comparability graph edge graph forest independent set outerplanar planar 
problems involving lexicographically solution complete 
example lexicographically topological order problem complete nlog lexicographic low degree subgraph membership problem np complete greenlaw 
additional remarks relating problem see chapter miyano 
minimum feedback vertex set directed graph cyclically reducible defined designated vertex problem contained minimum feedback set computed algorithm wang lloyd soffa 
de agostino 
hint review terminology 
vertex deadlocked directed path vertex lies directed cycle 
associated graph vertex respect consists vertex vertices deadlocked removed directed graph cyclically reducible exists sequence vertices 
yk graphs gi yi cyclic gi gi gi yi set called feedback vertex set contains vertex cycle karp 
minimum appendix complete problems feedback vertex set fewer elements 
wang lloyd soffa gave polynomial time algorithm computing feedback sets cyclically reducible graphs 
reduction monotone circuit value problem 

gk denote instance including inputs gk output gate 
graph constructed follows 
associate vertices gi 
input gi gi true false add loop edge respectively 
gate inputs add edges 
gate inputs add edges 
add edges 
easy see cyclically reducible 
set equal complete reduction 
remarks question general graph feedback vertex set size np complete karp 
de agostino give algorithm finding minimum feedback set cyclically reducible graphs requires log time processors crew pram denotes size minimum feedback set 
greenlaw proved related problem lexicographically maximal acyclic subgraph problem 
ramachandran proved finding minimum weight feedback vertex set reducible flow graph arbitrary weights complete 
proved problems nc equivalent finding minimum feedback arc set unweighted reducible flow graph finding minimum weight feedback arc set reducible flow graph unary weights arcs finding minimum weight feedback vertex set reducible flow graph unary weights vertices finding minimum cut flow network unary capacities 
edge maximal acyclic subgraph directed graph ordering edges designated edge problem contained edge maximal acyclic subgraph 

graph theory greenlaw 
hint edge maximal acyclic subgraph defined subgraph computed algorithm builds acyclic subgraph processing edges order 
adds edge subgraph inclusion introduce cycle 
reduction see problem 
gadget designed replaces gate circuit 
gadget gate inputs outputs vertices top mid bot 
edges gadget top mid top mid mid bot mid bot bot top top mid mid bot bot top bot top 
edges pointing edges ordered 
edges ordered gadget listed 
true input gate represented vertex edge top 
false input gate represented vertices forming cycle top 
edges ordered edge leading top put set algorithm constructs 
edges output gate grounded edges leaving bot designated edge remarks decision problem edge maximal subgraph size complete 
feedback arc set problem karp equivalent formulation maximum acyclic subgraph problem 
approximation algorithms problem important classes graphs problem known berger shor 
versions np complete garey johnson 
greenlaw proves decision problems natural approximation algorithms problem complete 
reasonable approximation algorithms nc see 
berger nc approximation algorithm assuming input graph contain cycles generates subgraph containing half arcs 
ramachandran ramachandran proved finding minimum weight feedback arc set reducible flow graph arbitrary weights arcs complete 
see problem 
general graph closure undirected graph subset designated edge problem general closure 
appendix complete problems graph obtained repeatedly joining nonadjacent pairs vertices degree sum edges called admissible edges 
khuller 
hint algorithm solving problem 
reduction monotone circuit value problem 
idea replace gates circuit gadgets 
describe gadgets inputs gates 
gadgets gates similar 
true false value associated output vertex gadget degree increased addition admissible edge respectively remained 
gadget constructed values propagate back circuit 
denote total number vertices contained gadgets 
additional vertices added connected double degrees vertices construction graph containing gadgets 
total degree graph constructed 
true input represented vertices admissible edge degree vertex false input represented similarly output side vertex degree 
gadget representing gate consists thirteen vertices 
describe upper left part 
consists vertices 
call vertices 
vertex connection inputs 
vertices degree vertices degree admissible edges 
upper right part gadget similar vertices playing roles 
vertices connected vertex admissible edges 
vertex degree 
vertex connected outputs gadget 
vertices 
degree gadgets connected obvious manner 
circuit evaluates true admissible edge gadget corresponding output gate added remarks complexity general graph closure problem open see problem 
generating random matchings grm bipartite graph designated edge 
mn denote set perfect matchings mn denote set near perfect matchings matchings size 
broder jerrum 
graph theory sinclair give probabilistic algorithms generating elements mn mn 
call algorithms broder algorithm jerrum sinclair algorithm 
problem matching generated broder algorithm 
problem matching generated jerrum sinclair algorithm 
teng 
hint problems complete 
reductions lexicographically maximal independent set problem 
remarks algorithms important approximating permanent 
see problems related open problems 
lexicographically maximal cycle free edge induced subgraph undirected graph ordering edges designated edge problem lexicographically maximal cycle free edge induced subgraph 
lexicographically maximal cycle free edge induced subgraph graph formed processing edge order adding subgraph built form cycle size miyano 
hint reductions different values variants circuit value problem 
remarks miyano proves problem complete different fixed values greater equal maximum degree respectively problem complete 
planar graph greater equal maximum degree respectively problem complete 
general graph maximum degree respectively problem nc 
see problems results similar flavor 
interesting contrast results edge induced subgraph problem vertex induced subgraph problem see problem 
see problem related open questions 
lastly note problem lexicographically maximal matching problem cc appendix complete problems searching graphs lexicographically maximal path undirected graph numbering vertices designated vertices problem vertex lexicographically maximal path 
maximal path path extended attempt extending result encounter vertex path 
lexicographically maximal path maximal path appear alphabetical listing paths done respect vertex numbers 
anderson mayr 
hint reduction version cvp consisting gates see problem 
key idea construction subgraph called latch 
latch consists vertices connected rectangular fashion 
latches hooked labeled clever manner 
latch traversed traversed construction lexicographically maximal path indicates true respectively false value corresponding gate 
vertex special vertex latch corresponding output gate 
remarks remains complete restricted planar graphs maximum degree 
maximum degree vertex algorithm find maximal path log time processors 
nc algorithm finding maximal path planar graphs 
complexity general problem finding maximal path open anderson shows rnc 
see problem 
maximal vertex disjoint paths paths undirected graph subset integer designated vertex problem vertex th path constructing paths greedily vertices 
paths formed lexicographically paths vertices set maximal 
searching graphs sense paths joining vertices added 
anderson 
hint reduction restricted version cvp 
result holds layered directed acyclic graphs complexity problem due construction lexicographically paths see problem 
remarks construction maximal sets vertex disjoint paths important developing fast parallel randomized algorithms depth search aggarwal anderson aggarwal anderson kao 
see problems 
lexicographically depth search ordering undirected graph fixed ordered adjacency lists designated vertices problem vertex visited vertex depth search induced order adjacency lists 
reif 
hint follows easily problem leftmost path lexicographically depth search tree lexicographically maximal path anderson 
reif gives direct reduction see problem advantage fixed order adjacency lists examined 
directed case undirected case easily derived 
loss generality assume gates numbered topological order 
gadget described replaces gate having inputs outputs gates 
gadget vertices enter exit 
triple denote directed edge appearing th adjacency list 
gadget triples enter enter exit exit exit enter 
additionally triples connected gadget 
true inputs chained 
appendix complete problems lexicographic dfs graph constructed visits vertex corresponds output gate circuit evaluates true respectively false 
remarks directed case reduced undirected case easily 
reduction dependent adjacency lists fixing order adjacent vertices examined 
problem remains open constraint relaxed 
example problem remains open graphs adjacency lists sorted order increasing vertex number 
problem remains complete input graph fixed vertex numbering search order numbering fixed ordered adjacency lists greenlaw 
anderson showed computing just branch lexicographically dfs tree called lexicographically maximal path complete see problem 
computing tree planar graphs complete 
planar directed depth search nc kao 
depth search tree constructed lexicographically 
hagerup shows depth search tree constructed planar graph priority crcw pram log time processors 
rnc possible find depth vertex numbering depth spanning tree corresponding see problem 
computing depth vertex numbering planar graphs nc yesha smith 
computing lexicographically depth numbering directed acyclic graphs nc de la torre kruskal greenlaw zhang 
determining directed spanning tree general graph valid dfs numbering nc schevon vitter 
vitter simons give time parallel algorithm non sparse version problem 
computing tree structured outerplanar graph nc 
breadth depth search bds undirected graph numbering vertices designated vertices problem vertex visited vertex breadth depth search induced vertex numbering 
breadth depth search horowitz sahni starts vertex visits children pushing stack search proceeds 

searching graphs children visited search continues vertex top stack playing role greenlaw 
hint proof sketched richard anderson personal communication 
reduce problem bds 
insert new vertex pair connected vertices original graph 
suppose original graph corresponding circuit vertex ui neighbors 
vk vertices listed order selected ui 

ck vertices inserted reduction ui ui vk respectively 
ci assigned numbers increasing order listed ck 

vertex numbers assigned vertices specified reverse breadth depth search new levels 
way depth search order original graph maintained 
vertex visited vertex instance vertex corresponding visited vertex corresponding constructed instance bds 
remarks reduction undirected directed graphs 
reductions problem described detail 
stack breadth search undirected graph numbering vertices designated vertices problem vertex visited vertex stack breadthfirst search induced vertex numbering 
stack breadthfirst search breadth search implemented stack 
vertices visited new level searched level 
greenlaw 
hint reduction sam cvp problem 
sort input vertices assign false inputs lower numbers true inputs 
increasing order 
fk 
tm denote ordering induced numbering 
new vertex introduced number fk 
gate vertex introduced connections circuit maintained graph constructed 
start vertex added connected inputs 
additionally new chain vertices starting added 
vertices chain 
ed denotes appendix complete problems depth circuit 
search order specified stack breadthfirst search vertex el odd corresponding respectively level instance sam cvp visited vertex gate corresponding vertex evaluates false respectively true circuit 
remarks lexicographic breadth search problem natural implementation queue defined follows graph fixed ordered adjacency lists vertex visited vertex breadth search induced order adjacency lists 
problem nc de la torre kruskal greenlaw 
alternating breadth search undirected graph partitioned sets designated vertex designated start vertex problem vertex get visited edge set alternating breadth search 
alternating breadth search applications matching algorithms breadth search edges set followed going respectively odd odd respectively levels 
anderson greenlaw hoover ruzzo 
hint anderson proof version cvp composed gates richard anderson personal communication 
new reduction problem 

tk denote true inputs 
fl denote false inputs 
gm denote nand gates 
new vertex created search originate 
ti new vertices introduced fi new vertex introduced gi vertex vi introduced 
connected edge vj connected input gate gj edge edge connected edge connected vj input gate gj 
gate gi outputs gates gj gh vi vj vi vh edges gates receiving inputs gi additional vertices 
gj called vij ij 
vi vij edge vij ij ij vj gate gh 
searching graphs similar vertices edges added 
circuit evaluates true false vertex corresponding output gate circuit visited edge respectively 
remarks matching constructed search necessarily maximal 
problem finding maximum matching rnc mulmuley vazirani vazirani 
problem finding perfect matching rnc karp upfal wigderson 
see problems 
appendix complete problems combinatorial optimization linear inequalities li integer matrix integer vector problem rational vector ax 
required find 
mean components nonnegative nonzero 
stephen cook personal communication valiant 
hint li 
see karmarkar 
reduction cvp li stephen cook personal communication 

input xi true false represented equation xi respectively xi 

gate input output computing represented inequalities 
gate inputs computing represented inequalities 
gate represented inequalities note gate inputs output 
determine output circuit add inequalities required force 
system solution output true output false 
remarks remains complete entries restricted 
see remarks problems 
linear equalities le integer matrix integer vector problem rational vector ax 
mean components nonnegative nonzero 
stephen cook personal communication valiant 
hint le nc reducible li ax ax 
combinatorial optimization ax le completeness instance li reduced le follows 
inequality li corresponding equality le additional slack variable inequality equality 
remarks le restricted coefficients le complete 
follows reduction itai 
restricted version le denoted le proving homologous flow problem complete 
proved problem deciding system equations degree greater equal solvable substitution complete 
linear programming lp integer matrix integer vector integer vector problem find rational vector ax cx maximized 
dobkin lipton reiss dobkin reiss valiant 
hint note problem stated computation problem 
lp technically fp 
see karmarkar 
reduce li lp picking cost vector say checking resulting linear program feasible 
remarks original reduction horn problem lp 
lp li shown logarithmic space equivalent reducing lp li rational binary search papadimitriou reiss find value maximum yields 
clear perform reduction nc lp li complete nc reductions nc reduction problems 
know lp li nc equivalent nc reduction obvious 
serna shows complete approximate solution approximation requires finding close optimal solution approximate value approximation requires finding cx close cx 
megiddo gives reduction lp serna approximate problem 
hard approximate cx constant fraction feasible solution anne condon personal communication reduction discounted markov decision process problem 
see lin pan appendix complete problems results variable linear programming 
dahlhaus observes equal values reals problem complete equal problem nc 
reader referred additional details 
maximum flow maxflow directed graph edge labeled integer capacity distinguished vertices source sink value problem feasible flow value value maximum flow sink greater equal 
goldschlager shaw staples lengauer wagner 
hint completeness proof decision problem derived maximum flow problem determining flow odd 
give reduction 
proof natural threshold problem stated similar 
reduction am cvp problem maxflow 
gates vi connections eij associated vertices edges ij additional vertices overflow edge edge eij capacity flow sociated 
capacity flow gate vi true 
vertex inputs maximum possible inflow outflow gates outdegree vi 
remaining flow absorbed overflow edge capacity overflow edge directed case vi gate case vi gate 
vertices topologically ordered output inputs output gate gate 
note edge capacities maximum flow odd outputs true 
remarks see dinic ford fulkerson basic definitions polynomial time algorithms 
reduction produces exponential edge capacities network edge capacities expressed unary computing magnitude maximum flow rnc feather method finding flow rnc known karp upfal wigderson 
network restricted acyclic maxflow remains complete ramachandran 
flows planar networks computed 
combinatorial optimization nc johnson johnson venkatesan 
commodity flow cf defined similar maxflow sources sinks separate flow functions commodities 
maxflow special case cf cf results itai follows cf complete 
itai defined variants cf complete 
defined 
cf restricted form cf lower upper bounds capacity edge 
selective cf defined cf lower upper bounds sum flows edge 
stein wein show rnc algorithm approximate maximum flow approximating minimum cost maximum flow complete 
homologous flow hf directed graph edge labeled lower upper bound flow capacity distinguished vertices source sink problem feasible flow network 
feasible flow flow assigned arc falls lower upper bounds arc homologous flow flow pairs edges required flow 
itai 
hint follows hf results 
describe reduction note logarithmic space reduction 
reduction le see remarks problem 
bi 
instance le 
aij 
formulation original equations xj xj bi 
sections flow network constructed vertices vi 
vi yi zi 
add vi edge lower bound upper bound network 
add zi lower upper capacities equal bi 
yi yi homologous edges 
zi yi edges 
additional vertex added source zn sink 

zn vn pairwise homologous edges 
denote flow 
solution appendix complete problems equations feasible flow xj zn feasible flow easy construct solution lexicographically blocking flow directed acyclic graph represented fixed ordered adjacency lists edge labeled capacity distinguished vertices source sink problem value lexicographically blocking flow odd 
blocking flow flow path saturated edge edge flow equal capacity 
lexicographically blocking flow flow resulting standard sequential depth search blocking flow algorithm 
anderson mayr 
hint reduction maximum flow problem easily modified show problem complete 
remarks problem finding lexicographically blocking flow layered network complete 
layered network source sink paths length 
maheshwari give rnc algorithm finding blocking flow layered network see problem 
goldberg tarjan give parallel algorithm finding blocking flow acyclic network 
algorithm runs parallel time log uses processors erew pram network vertices edges 
fit decreasing bin packing list items 
vn vi rational number distinguished indices problem th item packed th bin fit decreasing bin packing heuristic 
anderson mayr warmuth 
hint reduce am cvp problem 
loss generality assume gates 
numbered topological order 
reduction transforms sequence 
list items bins 
ti fi denote item size respectively 
describe construct list items bins 
gate outputs gates construct bins size items 
combinatorial optimization size 
gate outputs gates construct bins size items gate 
output gate treated specially bins size items size 
gates receiving constant circuit input ti fi removed gate receives false respectively true input 
lists bins concatenated order corresponding gate numbers similarly items 
get unit size bins 
uq non increasing list item sizes 
br list variable bin sizes constructed 
max bi set vi ib ib 
packing items bins size affect leaving bi space th bin 
concatenating item lists normalizing bin sizes fit decreasing bin packing items place item corresponding second tn list bin circuit evaluates true 
remarks problem remains complete unary representations numbers involved 
problem large numbers appear required completeness contrast see maxflow problem 
problem determining packing produced best fit decreasing algorithm complete 
nc algorithm produces packing optimal 
performance fit decreasing 
mayr describes nc approximation algorithms bin packing 
general list scheduling gls ordered list jobs 
jn positive integer execution time ji job non preemptive schedule jobs scheduled identical processors 
problem final offset produced list scheduling algorithm nonzero 
final offset difference total execution time processors 
helmbold mayr 
hint reduce see problem gls 
loss generality assume gates instance numbered reverse topological order 
input wires gate numbered output wire gate circuit output labeled 
vi sum labels appendix complete problems output wires gate gate seventeen jobs introduced execution times job fourteen jobs jobs vi 
initial job execution time equal sum labels true input wires 
remaining jobs listed descending order gate number 
final offset zero output gate true respectively false 
remarks problem nc job times small nc algorithms scheduling problems precedence constraints known helmbold mayr 
see problem additional scheduling results 
see mayr nc approximation algorithms 
sunder show list scheduling complete 
differences list scheduling gls jobs unit time number processors input problem 
fixed gls 
sunder prove result reduction height priority schedule problem 
show list scheduling nc precedence constraints interval order 
interval order partial order set intervals real line 
algorithm runs log time processors priority crcw pram 
version algorithm runs log time processors model 
height priority schedule hps directed specifying precedence constraints unit time tasks represented vertices nondecreasing profile designated task time slot define terms follow discussion 
graph task incoming edge 
profile function denotes number machines available th time slot interval 
profile value called straight 
schedule graph profile function vertices initial segment 



successor 

combinatorial optimization denotes length schedule 
minimum length schedule called optimal 
schedule greedy maximum number tasks scheduled slot implies greater successor vertex 
priority function set tasks schedule priority schedule vertices higher priority preferred vertices lower priority 
vertices priority ties broken arbitrarily 
priority schedule property greater greater imply successor vertex equal 
height typically priority function 
vertices successors height zero 
profile called nondecreasing slot problem task scheduled time slot height priority schedule 
dolev upfal warmuth 
hint reduction variant topologically ordered circuit value problem 
remarks dolev upfal warmuth show problems complete 
mention 
consult terms defined 
height priority schedule opposing forest straight line profile height priority schedule level order straight line profile weight priority different weights schedule straight profile greedy schedule lexicographically schedule straight line profile complete 
number machines fixed vary time precedence constraints collection dolev upfal warmuth give erew pram algorithms computing optimal schedules 
case algorithm runs log time processors case algorithm runs log time processors 
see problem additional scheduling results 
appendix complete problems local optimality maxflip verification encoding boolean circuit constructed gates plus inputs 
xn 
circuit output values 
ym 
problem circuit output local maximum neighbors viewed binary number 
neighbors boolean vectors length hamming distance differs 
obtained flipping bit 
johnson papadimitriou yannakakis 
hint problem easily seen reduction monotone circuit value problem 
denote instance input 
xn 
construct instance maxflip follows 
new circuit modification input 
add latch input ed inputs fed gates 
set latch input value 
output circuit constructed 
input 
xn locally optimal output latch input 
true output input 
remarks complementary problem called flip verification problem output minimized 
general problems maxflip flip pls complete 
pls stands polynomially local search 
class defined section 
note problems pls complete problem verifying local optimality turned complete 
shows case 
local optimality kernighan lin verification undirected graph unit weights edges partition equal size subsets problem cost partition local optimum neighbors partition 
cost partition 
local optimality defined sum costs edges going sets follow presentation johnson papadimitriou yannakakis define neighbors 
swap partition partition obtained swapping element element swap greedy swap minimized swaps 
lexicographically smallest greedy swaps said lexicographically greedy swap 
sequence partitions ai bi obtained swap preceding partition monotonic differences ai bi monotonically increasing 
partition neighbor occurs unique maximal monotonic sequence lexicographic greedy swaps starting 
johnson papadimitriou yannakakis savage wloka 
hint weights range solution values polynomial problem reduction variant monotone circuit value problem 
remarks reduction showed problem edge weights encoded unary 
problem called weak local optimum kernighan lin verification neighborhoods larger complete 
general versions problems local optimality kernighan lin weak local optimality kernighan lin weights encoded binary pls complete 
sch yannakakis deduce complete local search kernighan lin graphs unit weights complete 
result problem single neighborhood result implies 
unweighted equal clauses sat flip sat boolean formula cnf positive literals clause 
problem find locally optimal assignment assignment locally optimal maximum cost neighbors 
cost assignment number equals clauses satisfied assignment clause weight 
appendix complete problems truth assignment satisfies clause equals criterion true false literal 
neighbors assignment assignments obtained flipping value variable 
papadimitriou sch yannakakis sch yannakakis 
hint problem stated search problem technically fp complete 
reduction see problem 
remarks weighted version problem clause integer weight coded binary pls complete 
weights encoded unary problem 
unweighted maximum cut swap umcs undirected graph 
problem find locally optimal subset vertices 
subset locally optimal maximum cost neighbors 
cost sum number edges leaving vertices subset edge weight 
neighbor subset set size symmetric difference contains vertex 
papadimitriou sch yannakakis sch yannakakis 
hint problem stated search problem technically fp complete 
reduction sat problem 
remarks weighted version problem edge integer weight encoded binary pls complete 
edge weights encoded unary problem 
different majority labeling problem equivalent problem 
different majority labeling undirected graph labeling vertices vertex labeled differently half neighbors 
luby describes nc algorithm related problem 
show lexicographic version problem complete see problem 

local optimality unweighted satisfiability flip boolean formula cnf literals clause 
problem find locally optimal assignment assignment locally optimal maximum cost neighbors 
cost assignment number clauses satisfied assignment clause weight 
neighbors assignment assignments obtained flipping value variable 
papadimitriou sch yannakakis sch yannakakis 
hint problem stated search problem technically fp complete 
reduction umcs problem 
remarks weighted version problem edge integer weight encoded binary pls complete 
edge weights encoded unary problem 
unweighted graph partitioning swap undirected graph vertices 
problem find locally optimal partition equal size sets 
partition locally optimal number edges going minimum neighbors partition 
neighbor partition obtained swapping element element 
papadimitriou sch yannakakis savage wloka sch yannakakis 
hint problem stated search problem technically fp complete 
problem equivalent umcs problem 
reduction variant monotone circuit value problem 
remarks weighted version problem weights encoded binary pls complete 
weights encoded unary problem fp complete johnson papadimitriou yannakakis 
problem fiduccia mattheyses heuristic graph partitioning swap fm graph partitioning defined similarly neigh appendix complete problems solution 
neighborhood solution may obtained sequence swaps fiduccia mattheyses heuristic see 
fm graph partitioning 
fact simpler local search problem partition just neighbor obtained step fiduccia mattheyses heuristic fp complete 
problem called fm fm swap 
show simulated annealing swap neighborhood cooling schedule complete 
additional results proving graph partitioning strategies hard 
see details 
stable configuration connectionist model undirected graph vertices edges integer weights coded unary configuration see definition 
vertex edge weights denoted wi respectively wij 
called connectionist model associated properties 
vertex vi state associated 
authors consider states known model equivalent 
state vertex vi denoted si 
configuration refers vector vertex states 

influence function vertex vi defined follows ii wi 
vj state vertex vi stable configuration 
ii 
ii si 
ii si 
configuration stable states vertices configuration stable 
stable configurations coincide local maximum respect energy function vi vj vi 

local optimality problem find stable configuration connectionist model papadimitriou sch yannakakis sch yannakakis 
hint note problem stated search problem 
fp weights encoded unary 
reduction problem 
additional reductions versions problem 
remarks variants problem considered 
complexity problem changes depending types values positive negative positive negative weights allowed take depending encodings weights 
directed undirected versions problem considered 
versions problem np complete hard complete 
example problem restricted just positive weights monotone circuit value problem reduced 
version known complete 
variants general problem hard 
consider slight variant problem show restricted edge weights complete 
version problem weights encoded binary pls complete 
dasgupta describes parallel complexity results neural networks 
shows deterministic recurrent neural network stable state learn complete language gives conditions restricting thresholds weights result neural networks capable learning languages nc 
lexicographically different majority labeling undirected graph numbering vertices designated vertex different majority labeling labeling vertices vertex labeled differently half neighbors 
greedy sequential algorithm solving problem begins initially assigning value vertex 
algorithm iterates vertices order flipping vertex label correctly labeled 
flipping process repeated labeling appendix complete problems different majority labeling 
labeling produced algorithm called lexicographically different majority labeling 
problem vertex labeled lexicographically different majority labeling 

hint reduction problem 
remarks parallel complexity different majority labeling posed open question luby 
discussed problem reduced version connectionist model problem see problem 
sch yannakakis proved problem equivalent problem 
problem complete 
show remains complete restricted planar graphs 
give sequential algorithm problem state decision problem algorithm complete 
traveling salesman opt ts opt finite set 
cn cities distance matrix entries dij positive integers initial tour 
problem find sequence tours 
tm ti result opt ti cost ti cost ti tm locally optimal tour opt refers neighborhood transformation done tours see lin kernighan 
anderson 
hint reduction variant circuit value problem 
remarks see problem 
maximum satisfiability approximation msa boolean formula clauses 
cm variables 
xn plus integer problem variable xl get assigned value true maximum satisfiability approximation algorithm 
algorithm sketched 
input msa 

local optimality ft fraction truth assignments remaining variables clause satisfy clause xi set true ff ft mj mj ft ff xi true xi false update clauses 
crescenzi de agostino 
hint reduction variant circuit value problem consists gates 
remarks algorithm specified approximates msa 
result shows sequential algorithm approximating maximum satisfiability feasibly highly parallel 
minimum set cover approximation msca finite set collection subsets special subset integer problem subset th set chosen minimum set cover approximation algorithm 
set cover collection sets element contained set minimum set cover set cover smallest cardinality 
minimum set cover approximation algorithm outlined 
input msca 
solution uncovered uncovered choose remaining set maximized solution solution index uncovered uncovered remove elements remaining sets 
crescenzi de agostino 
hint reduction variant circuit value problem consists gates 
appendix complete problems remarks minimum set cover problem np complete garey johnson 
algorithm specified log approximates msca 
result shows sequential algorithm approximating minimum set cover feasibly highly parallel 
layer channel router column swap heuristic columns initial solution layer channel routing problem time bound reader referred background definitions concerning routing problems 
problem find solution rt obtained applying local search algorithm channel routing columns cost function swap neighborhood 
provide definitions 
columns cost function layer channel routing number overlapping vertical segments 
swap neighborhood channel routing solution set channel routings obtained swapping pair horizontal wires 
savage wloka 
hint reduction variant monotone circuit value problem 
remarks savage wloka pose open problems certain routing heuristics hard parallelize 
log time processor erew pram algorithm layer channel routing vlsi designs 

logic logic unit resolution unit boolean formula conjunctive normal form 
problem empty clause deduced unit resolution 
unit clause term 
example unit resolvent bm unit bm 
jones 
hint jones provide polynomial time algorithm unit resolution 
show follows assumption am negate add set clauses derive empty clause 
reduce cvp unit described 
gate circuit vk vi vj represented clauses vk vi vj 
vk vi vk vj vk vi vj 
similarly vk vi vj represented clauses vk vi vj vk vi represented clauses vk vi 
remarks see chang lee mechanical theorem proving 
appropriate definitions known approximating problem complete serna spirakis 
horn unit resolution horn horn formula conjunctive normal form cnf formula clause disjunction literals having positive literal clause 
problem empty clause deduced unit resolution 
dobkin lipton reiss jones 
hint reduce arbitrary turing machine cnf formula cook 
clauses horn clauses 
clauses form pi true time tape cell contains symbol symbol tape head cell turing machine state 
function depends turing machine 
cells containing symbols value cell time step 
alternatively reduce cvp horn unit problem 
clauses vk vi vj appendix complete problems vk vi horn form 
vk vi vj clauses vk vi vj horn form replacing gate associated gates laws results set horn clauses 
propositional horn clause satisfiability set horn clauses propositional calculus 
problem satisfiable 
kasif plaisted 
hint reduction straightforward alternating graph accessibility problem 
remarks problem remains complete literals clause 
plaisted shown problems involving proofs restricted depth complete 
literal horn clause unique matching problem literal horn clause problem 
kasif observes remains complete set clauses restricted implications atoms right hand side kasif 
monadic krom satisfiability monadic krom formula krom formula cnf formula 
formula cnf disjuncts clause 
predicate letters may preceded negation 
conjunct monadic form 
problem satisfiable 
lewis 
hint algorithm showing problem 
reduction problem pushdown automata see problem 

logic multivalued dependency set multivalued dependencies multivalued dependency 
follow discussion define concepts 
denote set attributes database denote sets attributes 
embedded multivalued dependency expression form disjoint sets attributes nonempty 
multivalued dependency equal xy set implies holds database member holds 
problem imply 

hint reduction variant horn unit resolution problem 
relaxed consistent labeling rcl relaxed consistent labeling problem consisting set variables 
vn set labels 
ln li consists possible labels vi 
binary predicate pij assignment label vi compatible assignment label vj 
designated variable designated label problem valid assignment label 
kasif greenlaw hoover ruzzo 
hint original reduction propositional horn clause satisfiability problem 
reduction sketch problem 
variable introduced circuit input 
variable label circuit input true respectively false 
view nand gate represented variables 
consider nand gate inputs outputs variables denoted lk rk 
possible labels nand gate variable denote true values denote false value 
possible labels variables lk rk 
constraints variable inputs follows pik pik pik pik appendix complete problems pjk pjk pjk pjk 
constraints lk rk 
label 
label 
possible labelings allowed 
constraints involving nand gate lk respectively rk 
notice inputs possible label assigned label 
remainder labeling done circuit gets evaluated topological manner 
denote number output gate instance 
valid assignment label vertex lo output gate true 
remarks general consistent labeling problem known np complete 
kasif shows decision problems arc consistency algorithms solving constraint satisfaction problems complete 
gen finite set binary operation table subset problem contained smallest subset contains closed operation 
jones 
hint reduction unit resolution problem 
define unit resolution clauses formula instance unit clauses 
empty clause 
remarks problem remains complete singleton set commutative barrington mckenzie 
associative gen complete nlog 
problem remains operation 
alternative reduction cvp showing gen nc complete complexities versions gen addressed 
appropriate definitions known approximating problem complete serna spirakis 
simons developed time parallel algorithm problem roger simons personal communication 

logic path systems path path system problem admissible vertex 
vertex admissible exists admissible cook 
hint jones reduce problem path defining 
remarks cook defined path systems 
problem shown logarithmic space complete original proof cook direct simulation turing machine 
appropriate definitions known approximating problem complete serna spirakis 
vitter simons give time parallel algorithm non sparse version problem 
unification unif symbolic terms term composed variables function symbols 
substitution term replacement occurrences variable term problem series substitutions unify 
gives 
terms called unifiable exists 
dwork kanellakis mitchell dwork kanellakis stockmeyer 
hint reduction monotone circuit value problem 
reductions problem 
reduction begins variant circuit value problem proceeds problem hypergraphs 
remarks robinson defined unification 
reader referred chang lee basic discussion mechanical theorem proving 
unrestricted unification problem complete 
unrestricted unification substitutions allowed map variables infinite terms 
convenient represent terms labeled directed acyclic graphs 
term linear appendix complete problems variable appears 
restricted versions unification complete terms linear represented trees function symbols arity equal terms represented trees variable appears terms variable appears twice term function symbols arity equal 
restricted problem called term matching solved nc 
term matches term exists substitution dwork kanellakis mitchell randomization reduce processor bound 
crew pram algorithm runs randomized time log processors denotes complexity matrix multiplication 
vitter simons give time parallel algorithm unification instances problem dense 
kuper give nc algorithm problem constructing specific anti unifier 
dual problem unification 
specific anti unifier terms 
tm term tg 
ti instance tg 

tg instance term property 
algorithm produces specific anti unifier terms size crew pram time log mn mn processors 
logical query program extended logic program ground clause form 
qk 
ground clause arguments constants 
extended logic program basic logic program plus extensional data base instance 
basic logic program finite set rules 
rule disjunction literals having exactly positive literal called head 
negative literals clause called subgoals 
set predicate symbols appear subgoals called extensional database edb 
edb fact edb predicate constants arguments 
edb instance finite set edb facts 
theorem head derivable subgoals 
logic problem theorem ullman van gelder 
hint reduce path systems problem 
instance path 
loss generality assume 
edb relation specifying vertex edb relation specifying triple vertices basic logic program consists rules 
relation models admissibility path system theorem admissible path system 
remarks remains complete restricted programs 
nc programs polynomial fringe property see details 
afrati papadimitriou classify simple chain programs parallel complexities 
show certain subclass simple chain programs nc simple chain programs complete 
afrati describes additional classes logic programs solved nc provides sufficient conditions single rule programs complete 
reader referred definitions details 
numerous open problems described 
left linear semi unification set pairs terms 
mk nk left linear 
follow discussion definitions 
ranked alphabet finite set function symbols arity function maps element natural number 
function symbol arity called constant 
set variables denumerable infinite set disjoint terms set consisting strings generated grammar 
function symbol arity greater constant variable appears times argument terms equal written identical strings 
substitution mapping identity finite set set variables identity domain 
substitution extended appendix complete problems defining 
mk 
mk 
term subsumes written substitution substitution semi unifier 
mk nk 
semi unifiable semi unifier 
problem semi unifiable 
henglein 
hint proof adopted dwork kanellakis mitchell show unification problem 
remarks define problem left linear exactly term inequalities monadic semi unification msu problem alphabet greater equal equals msu complete 
see problem related problems 
see problem open problem 
mostowski epimorphism founded relation mostowski epimorphism relation 
reader referred definitions 
problem 
dahlhaus 
hint reduction monotone circuit value problem 
remarks result indicates programming language setl may suited parallelism 
see problem related open problem 
corporate takeover query group companies 
cn partial relation owns ci cj distinct integers owns ci cj indicates ci owns cj stock 
problem ck bought cl 
logic bought controls stock 
controls controls stock controlled bought 
consens mendelzon 
hint reduction path systems problem 
remarks query languages considered 
numerous consens mendelzon show question posed language resolved nc incomplete table recovery itr collection functional dependencies finite attribute set 
am matrix tij called incomplete table aj value tij nonnegative integer null value reader referred definitions regarding problem 
problem uniquely recoverable domain attribute aj set nonnegative integers 
miyano miyano 
hint reduction alternating graph accessibility problem 
appendix complete problems formal languages context free grammar membership context free grammar string problem 
jones 
hint reduce problem 
instance gen construct grammar yz 
follows generated remarks goldschlager remarks presence productions input grammar membership question difficult 
lewis stearns hartmanis log space algorithm ruzzo ac nc algorithm general context free language recognition modified free grammar part input 
fixed grammar unbounded fanin size suffices 
rytter shows context free languages recognized cube connected computer log time processors 
provides log time processor common crcw pram algorithm recognition unambiguous context free languages 
klein reif give log time processor crew pram algorithm recognition deterministic context free languages 
ruzzo give somewhat simpler algorithm problem restricted crow pram 
prove parallel multiple context free grammar membership multiple context free grammar membership problems involving generalizations contextfree grammars designed model natural languages complete 
context free grammar empty context free grammar 
problem empty 
jones goldschlager 

formal languages hint reduction problem suffices 
reduction monotone circuit value problem martin tompa personal communication interest 
circuit construct grammar nonterminals vi vertex terminals start symbol vn output 
denote value gate productions form 

input vi vi true 
jk vi vj vk 
vi vj vk 
vi true remarks note reduction problem productions remain complete 
original proof jones reduced problem 
proof reduction problem checked empty 
context free grammar infinite context free grammar 
problem infinite 
goldschlager jones 
hint grammar similar proof problem production replaced productions ax added 
context free grammar membership cfg mem context free grammar 
problem 
goldschlager jones 
hint grammar similar proof problem production replaced 
appendix complete problems forward deterministic growing contextsensitive grammar membership forward deterministic growing context sensitive grammar string context sensitive grammar growing production 
context sensitive grammar forward deterministic derivations sentential form equals problem 
sang cho huynh 
hint techniques completeness proofs sketched problems apply problem involve grammars forward deterministic growing 
reduction version generic machine simulation problem 
remarks proof yields straightforward corollary nondeterministic growing context sensitive grammar membership np complete 
straight line program membership straight line program alphabet operations taken string problem member set constructed program 
set constructed program instruction involves set computed final instruction 
goodrich greenlaw hoover ruzzo 
hint noting logarithmic space alternating turing machine parses relative program problem easily seen reduce monotone circuit value problem true false 
remarks original reduction problem 
remains allowed 
analogous membership question regular languages regular expressions nondeterministic finite automata complete nlog 

formal languages straight line program nonempty straight line program alphabet operations taken string problem set constructed program nonempty 
see problem definition 
goodrich 
hint problem 
remarks added complete nondeterministic exponential time 
way dpda acceptance dpda way deterministic pushdown automaton string problem accepted 
cook galil ladner 
hint see example hopcroft ullman definition 
cook gives direct simulation polynomial time turing machine logarithmic space auxiliary pushdown automaton 
galil shows existence complete language accepted dpda effect showing logarithmic space tape crucial cook simulation 
see general reduction auxiliary pdas ordinary pdas 
ladner gives direct proof observing suitably encoded version cvp solvable dpda basically doing depth search circuit stack backtracking 
remarks remains generalized nondeterministic logarithmic space auxiliary pdas 
restricted way pdas polynomial time pdas logarithmic space tape problem nc specifically complete deterministic case logcfl sac nondeterministic case 
labeled gap fixed context free language alphabet directed graph edges labeled strings vertices problem path concatenation appendix complete problems edge labels 
ruzzo greenlaw hoover ruzzo 
hint reduce way dpda acceptance problem 
way dpda see hopcroft ullman details input string 
loss generality pda unique final state qf accepts empty stack head right input 

set containing special vertex surface configurations pda 

edge labeled reading xi pda move moves input head cells right pops pushes 
additionally edge special vertex initial surface configuration labeled initial stack symbol 
designated vertex qf semi dyck language letters harrison section language generated context free grammar productions 
remarks remains complete 
equivalent statement complete decide deterministic finite state automaton 
acyclic problem complete sac logcfl 
strong bisimilarity transition systems encoding finite labeled transition system designated states finite labeled transition system triple finite set states finite alphabet set transitions 
relation strong bisimulation implies 
state 
state strong bisimulation relation defined union strong bisimulations 
formal languages problem strongly bisimilar 
strong bisimulation relation 
zar 
hint reduction sam cvp problem 
key idea reduction modify instance sam cvp gate receives true input gate receives false input 
call input property 
construction accomplishes called alternating pattern 
consists alternating levels gates gates unbounded fan 
levels alternating pattern gate receives inputs true false respectively receives false respectively true 
outputs gates sent gates level achieve input property 
depth alternating pattern circuit depth 
transition network consists modified circuit edges directed circuit output inputs 
vertices graph correspond states 
transition represented edge assigned character 
fact alphabet consist single character 
chosen state corresponding output gate circuit chosen true gate layer alternating pattern 
circuit evaluate true strongly bisimilar 
remarks notice construction transition system nondeterministic 
open question problem remains complete deterministic case see problem 
observation equivalence observation congruence related problems shown complete 
zhang smolka implement parallel algorithms equivalence checking 
propagating set systems pss set sf elements set system consists finite set productions ps form subsets set derives step set appendix complete problems written ps denotes reflexive transitive closure 
propagating set system set system element ps 
problem sf 
monti 
hint reduction variant generic machine simulation problem 
remarks general version problem pspacecomplete 
cellular tree automaton acceptance sublinear time bounded cellular tree automaton cta input string see ibarra jiang chang definition 
problem accept 
ibarra jiang chang 
hint trellis automaton accept complete language ibarra kim 
turn simulated linear iterative array turn simulated cellular tree automaton 
see definitions details 
remarks sublinear time way bounded cta accept complete language 
way cta communication vertices bottom 
language accepted oneway cta accepted deterministic turing machine log log log space size input 
iterative tree array acceptance real time log depth bounded iterative tree array input string length see ibarra jiang chang definitions 
problem accept 
ibarra jiang chang 
hint iterative tree arrays simulate cellular tree automata 
combining result problem proof fol 
formal languages lows 
remarks note appropriate resource bounds cellular tree automata simulate iterative tree arrays 
see problem 
relation coarsest set partition finite set initial partition designated set set binary relations 
rk problem member coarsest refinement pair blocks integer 
pii pii pii pre image set pii ri 
sang cho huynh 
hint observe kanellakis smolka showed nc equivalence relation coarsest set partition complete variant strong bisimilarity transition systems problem 
remarks single relation equals problem complete 
sang cho huynh give log time processor crew pram algorithm single function coarsest set partition problem log time processor erew pram algorithm problem 
see remarks problems 
iterated shuffle shuf language finite alphabet described terms operators denote concatenation kleene star union intersection shuffle iterated shuffle respectively plus designated word shuffle languages denoted xm ym xi yi 

iterated shuffle denoted appendix complete problems problem 

hint note certain restrictions placed order problem reduction variant see problem 
remarks known deterministic context free languages shuffle np complete ogden riddle rounds 
intersection operation force problem 

algebra algebra finite horizon markov decision process nonstationary markov decision process integer defining problem background markov decision processes 
term finite horizon refers time bound finite set states contains designated initial state 
st denote current state system time 
associated state finite set decisions ds 
cost incurred time making decision dst 
state probability distribution 
independent process said stationary 
policy mapping assigns time step state decision 
policy stationary independent time supplied input 
problem minimum expected cost st st policies equal 
papadimitriou tsitsiklis 
hint polynomial time algorithm problem uses dynamic programming howard 
reduction monotone circuit value problem 
ai bi ci 
denote encoding ai denotes gate type bi ci denote numbers gate inputs 
stationary markov process constructed circuit instance follows 
state qi additional state called ai bi ci corresponds circuit input corresponding state qi single decision qi cost qi ai false respectively true input 
costs process 
decision state 
ai gate decisions state qi 
associated probabilities qi qbi qi 
associated costs 
ai gate decisions state qi 
qi qbi qi associated costs 
initial state appendix complete problems corresponding output gate circuit 
time horizon easy verify expected cost process circuit evaluates true 
remarks reduction shows finite horizon stationary version problem hard 
problem known deterministic version requires values nc 
note result holds stationary nonstationary versions problem 
discounted markov decision process stationary markov decision process real number 
see problem definitions 
problem infinite horizon time bound 
problem minimum expected cost st st policies equal 
papadimitriou tsitsiklis 
hint problem phrased linear programming problem solved polynomial time 
construction problem show problem complete 
remarks infinite horizon discounted deterministic problem nc 
deterministic problem requires values 
average cost markov decision process stationary markov decision process 
see problem definitions 
problem infinite horizon time bound 
problem minimum expected cost lim st st policies equal 
papadimitriou tsitsiklis 

algebra hint problem phrased linear programming problem solved polynomial time 
reduction synchronous variant monotone circuit value see problem 
construction modification problem 
having states corresponding circuit inputs going new state transitions initial state 
limit circuit instance evaluates true 
remarks infinite horizon average cost deterministic problem nc 
deterministic problem requires values 
gaussian elimination partial pivoting matrix entries rationals integer problem pivot value th column positive gaussian elimination partial pivoting performed 
partial pivoting technique obtain numerical stability rows matrix exchanged largest value column perform elimination 
vavasis 
hint standard gaussian elimination algorithm requires operations 
size numbers involved bounded polynomial see problem show completeness reduce problem 
loss generality assume inputs gates circuit numbered topological order numbers output gate 
matrix ai constructed instance 
entries described 
true circuit input contributes entry position entry position false input nand gate entry position position gate input gate entry position entry position entry 
unspecified matrix entries value 
pivot value eliminating column positive negative circuit evaluates false respectively true 
remarks reduction rely large numbers shows problem strongly complete 
decision appendix complete problems problem strongly complete gaussian elimination partial pivoting follows matrix integers pivot eliminate th column taken initial th row 
vavasis shows gaussian elimination complete pivoting complete 
complete pivoting rows columns interchanged largest remaining matrix entry pivot 
complete pivoting known numerically stable 
reduction complete pivoting show problem strongly complete 
question open 
additional regarding parallel complexities related problems borodin von zur gathen hopcroft ibarra moran mulmuley pan reif 
open questions see problems 
iterated mod im integers 
bn 
problem mod mod mod bn 
karloff ruzzo 
hint reduce problem im 
loss generality assume gates numbered reverse topological order output gate numbered 

yr denote inputs yl denote value input yl 
input wires gate numbered 
bit vector length jth bit yl edge incident input yl 
og represent set edge labels gate construct moduli 
follows og output gate instance value mod mod mod 
lin direct simulation turing machine im 
remarks polynomial iterated mod problem problem 
bn univariate polynomials field question determine mod mod mod bn 

algebra problem nc 
proof technique show im complete modified show knapsack problem complete 
knapsack problem defined analogously knapsack problem garey johnson weights 
wn wi wj 
see lin additional im 
mayr describes fully nc approximation scheme knapsack problem 
generalized word problem finite set free group generated denotes inverse denote set finite words 
um problem subgroup generated 
stewart 
hint stewart reported error 
reduction generic normal form turing machine 
reduces turing machine computation version countably infinite set 
stewart shows nielsen reduction algorithm problem stewart calls complete problem generalized word problem free groups 
shows logarithmic space reducible proving complete 
remarks natural number generalized word problems finitely generated subgroups countably generated free groups words involved length exactly respectively 
stewart shows complete greater 
equals problems complete symmetric logarithmic space 
word problem free group decide equals empty word problem solvable deterministic log space lipton 
appendix complete problems subgroup containment sc finite set free group generated denotes inverse denote set finite words 
um 
vp problem group generated subgroup group generated 
hint variant nielsen reduction algorithm show problem reduction generalized word problem 
observe subgroup remarks subgroup normal follows normal subgroup problem complete 
problem determining normal complete 
subgroup equality se finite set free group generated denotes inverse denote set finite words 
um 
vp problem 
hint variant nielsen reduction algorithm show problem reduction subgroup containment problem 
observe subgroup subgroup finite index sfi finite set free group generated denotes inverse denote set finite words 
um 
vp problem subgroup finite index index number distinct right cosets 

algebra hint variant nielsen reduction algorithm show problem reduction subgroup containment problem 
note subgroup finite index problem determining finite index complete 
group independence gi finite set free group generated denotes inverse denote set finite words 
um problem independent 
unique freely reducible representation 
word freely reducible contains segment form ss 
hint variant nielsen reduction algorithm show problem reduction arbitrary polynomial time turing machine 
group rank gr finite set free group generated denotes inverse denote set finite words 
um problem rank 
rank number elements minimal generating set 

hint variant nielsen reduction algorithm show problem reduction group independence problem 
observe independent rank number elements appendix complete problems group isomorphism si finite set free group generated denotes inverse denote set finite words 
um 
vp problem isomorphic 
hint variant nielsen reduction algorithm show problem reduction group independence problem 
independent 
isomorphic 
group induced isomorphism gii finite set free group generated denotes inverse denote set finite words 
um 
vp problem mapping defined ui vi 
induce isomorphism 
hint variant nielsen reduction algorithm show problem reduction group independence problem 
independent defined induces isomorphism 
intersection cosets ic finite set free group generated denotes inverse denote set finite words 
um 
vp problem nonempty 

hint polynomial time algorithm problem 
reduction arbitrary polynomial time turing machine 
remarks intersection right cosets problem intersection left cosets problem subproblems intersection 
algebra cosets problems complete 
example right coset problem complete nonempty xy nonempty denotes empty word 
intersection subgroups finite set free group generated denotes inverse denote set finite words denote empty word 

um 
vp problem 
hint polynomial time algorithm problem 
reduction straightforward intersection right cosets see problem 
group coset equality gce finite set free group generated denotes inverse denote set finite words 
um 
vp problem 
hint polynomial time algorithm problem 
reduction intersection subgroups see problem 
remarks decision problems equality right cosets equivalence cosets equivalence right cosets 

appendix complete problems conjugate subgroups cs finite set free group generated denotes inverse denote set finite words 
um 
vp problem 
hint polynomial time algorithm problem 
reduction equivalence right cosets see problem 
remarks problem determining subgroup complete 
uniform word problem finitely algebras finitely algebra pair terms finite set symbols defines arity symbol 
partitioned sets consists generator symbols consists operator symbols 
set terms smallest subset 
elements terms 
ary 
xm terms 
xm term 
denote set terms 
set unordered pairs terms called axioms 
smallest congruence relation satisfying axioms 
problem 
kozen 
hint polynomial time algorithm problem 
reduction monotone circuit value problem 
instance represented list assignments variables 
cn form ci ci ci cj ck ci cj ck provided value cn denotes output gate circuit 
reduction follows 
cn 

algebra cn 
finitely algebras triviality finitely algebra 
see problem definitions 
problem trivial 
contain element 
kozen 
hint polynomial time algorithm problem 
reduction monotone circuit value problem 
construct done proof hint problem 
cn 
notation problem fol lows instance cn 
trivial 
finitely generated subalgebra fgs finitely algebra terms 
xn 
see uniform word problem finitely algebras problem definitions 
problem contained subalgebra generated 
xn 
kozen 
hint polynomial time algorithm problem 
problem general formulation problem follows complete 
finitely algebras finiteness finitely algebra 
see uniform word problem finitely algebras problem definitions 
problem finite 
kozen 
hint polynomial time algorithm problem 
reduction monotone circuit value problem similar problem 
algebra constructed proof modified follows add generator axioms appendix complete problems obtain finite trivial infinite 
uniform word problem lattices set equations equation 
preliminary definitions defining problem 
lattice set binary operations satisfy lattice axioms 
lattice axioms follows 
associativity 
commutativity 
idempotence 
absorption countably infinite set symbols 
set terms defined inductively follows 



terms equation formula form 
valuation lattice mapping valuation extended defining 
lattice satisfies equation valuation denoted 
lattice satisfies set equations denoted satisfies member 
implies denoted lattice valuation follows 
problem 
cosmadakis 
hint polynomial time algorithm problem 
reduction implication problem propositional horn clauses jones 
see problems 
set propositional formulas form xi xj xk 
propositional variables 
formula 
problem test implies 
represent formula xj xj xk 
instance construct equation follows 
follows implies 
remarks problem remains complete inequalities 
algebra equations 
furthermore problem remains complete terms represented directed acyclic graphs trees 
terms represented trees problem dlog 
problem called identity problem lattices 
lattice generators lg lattice 
set equations 
gn terms valuation see problem 
preliminary definitions 
sublattice generated smallest subset contains closed operations generated 
gn denoted gen 
gn sublattice generated set gi 

implies generated 
gn denoted gen 
gn lattice valuation follows gen 
gn 
problem gen 
gn 
cosmadakis 
hint polynomial time algorithm problem 
reduction continuation reduction problem 
gen follows gpl complete 
remarks problem remains complete terms represented directed acyclic graphs trees 
terms represented trees problem dlog 
problem called generator problem free lattices 
boolean recurrence equation bre tuple boolean vector boolean matrix boolean vector integer range problem entry yj 
yj defined recursively yk yk 
denotes complement 
hint reduction alternating turing machine appendix complete problems uses log space 
remarks log problem complete ac 
class problems accepted alternating turing machines log space log alternations 
fill slots fill boolean matrix integers problem row cover values column highest row matrix procedure fill slots applied 
fill slots procedure basically processes rows matrix downward 
looks row contain 
inserted row covering column bits treated integer largest ties may broken arbitrarily 
bits covered zeroed 
process repeated bottom matrix reached 
de la torre greenlaw sch 
hint reduction version topologically ordered monotone circuit value problem 
sketch 
denote instance 
idea generate columns simulate gate 
unspecified matrix value 
gate associated disjoint set rows columns 
row associated gate column associated gate columns far left matrix correspond circuit inputs 
true false input denoted column single respectively 
gate associated consecutive rows consecutive columns 
topological ordering gates translated left right ordering gadget columns top bottom ordering gadget rows 
important part gadget depicted 
values occupy submatrix rows columns associated gate 
third column additional rows shown row left respectively right 
algebra output gate input 
left right input gate delivered separate column respectively third row gadget 
gadget similar consists lower left corner gadget 
inputs gate delivered separate columns second row gadget 
outputs gate handled similar 
assume output gate gate 
instance fill second column gadget corresponding row matrix constructed middle row remarks fill slots procedure similar prove edge ranking problem result suggests algorithm may parallelize 
fill interesting involves boolean values 
additional details de la torre greenlaw sch 
see problem 
multi list ranking mlr set 
lq lists list lj contains integers integer element list designated integer problem element receive rank equal 
rank element computed iteratively follows assign rank elements lists delete occurrences elements lists repeat procedure updated lists incrementing value rank 
procedure iterated long list nonempty 
lingas maheshwari 
hint reduction generic machine simulation problem 
remarks log lists problem solved sc authors show case problem hard class sc variant problem lists size provide log time processor crew pram algorithm 
restrictions problem considered polylogarithmic time pram algorithms 
see details 
original motivation looking problem investigate complexity successive convex hulls problem 
appendix complete problems aperiodic monoid membership variety set total functions 
ar designated function set 
property 
ar 

ar denotes set functions obtained composing functions ai 
restricted class aperiodic monoids 
reader referred definitions 
problem belong 
ar mckenzie th 
hint reduction variant problem 
remarks lattice aperiodic monoid varieties partitioned sublattices 
membership problem varieties described 
varieties problem ac npcomplete np hard pspace complete 

geometry geometry plane sweep triangulation pst vertex polygon may contain holes designated vertex problem vertical edge connecting plane sweep triangulation 
plane sweep triangulation triangulation produced sweeping horizontal line top bottom 
encounters vertex diagonal vertex cross previously drawn diagonal added triangulation 
atallah callahan goodrich 
hint easy see plane sweep triangulation algorithm runs polynomial time 
reduction variant planar cvp problem 
new version consists gates fanout gates fanout routing gates fanout gates take value produce copies 
instance required laid planar grid special manner alternating layers routing logic 
reduction involves constructing geometric gadgets routing left right shifts grid vertical wires fanout gates gates 
presence absence vertical edge triangulation denotes true respectively false value 
vertex special target vertex output gate circuit 
vertical line connected triangulation circuit evaluates true 
remarks problem finding arbitrary triangulation nc goodrich 
polygon allowed holes complexity problem open 
conjecture restricted version nc oriented weighted planar partitioning set nonintersecting line segments 
sn euclidean plane set associated integer weights 
wn designated segments segments oriented meaning different possible slopes appendix complete problems segments 
problem segments touch partitioning plane constructed extending segments order weights 
segments extended reach segment previous segment extension 
atallah callahan goodrich 
hint easy see process extending segments performed polynomial time 
reduction version problem 
gates instance numbered topological order 
gadgets constructed routing logic 
gadgets right left shifts fanout gates gates gates true inputs 
true values circuit transmitted vertical extensions segments 
interesting gadget gate describe 
gadgets constructs involve different segments simulate gates different slopes required 
instance laid grid 
consider gate numbered receives input channel output channel blocking segment prevent extension line segment weight large 
segments play active role simulating gate 
gadget consists blocking segments additional segments called indicating relative weights 
segment processed gadget followed 
segment horizontal segment potential extension spans channels blocked ends 
lies directly left channel segment vertical segment channel blocked segment possibility extended downward extension 
channel input gate blocked segment 
segment slope potential extension blocked ends 
segment lies completely left channel rightward extension cross channel segment extension 
describe gadget simulates gate 
input gate true false vertical segment channel respectively extended blocked 
prevents allows segment extended segment 
segment respectively extended right channel 
geometry prevents allows segment extended segment extension indicating false respectively true value output gate 
assignments weights construction gadgets accomplished logarithmic space 
segment vertical segment corresponding output wire circuit 
segment special output pad touch extended circuit evaluates true 
remarks complexity oriented version problem open 
problem reduced instance monotone circuit value problem restricted topology planar 
open version problem nc visibility layers vl set nonintersecting line segments euclidean plane designated segment problem label assigned segment visibility layering process congruent mod 
visibility layering process repeatedly compute delete upper envelope remaining set segments label segments current depth 
upper envelope consists segments visible point 
segment visible point ray cast hit segment hitting segment 
atallah callahan goodrich hershberger 
hint visibility layering process performed polynomial time 
reduction monotone circuit value problem 
sketch reduction 
gates instance assumed numbered topological order 
grid constructed consists rows columns number vertices respectively edges directed acyclic graph corresponding circuit 
gadgets constructed gates 
gadgets consist horizontal line segments varying lengths 
gadget gate inputs outputs consists horizontal segments situated row grid 
segment spans column segment spans column segment spans column column gadget gate inputs outputs consists appendix complete problems horizontal segments situated row grid 
segment spans column segment spans columns segment spans columns input associated column true false horizontal segment put respectively put span column row 
horizontal line segments spanning single columns grid sure gate input values arrive right time sure gate evaluated outputs affect desired gates 
segment third horizontal segment gadget output gate 
output circuit true segment label value congruent mod 
remarks reduction similar variant 
main difference way fanout treated 
version consists crossing fanout gates single output gates single output gates 
instance consists alternate routing logic layers 
gadgets constructed types gates similar decision problem posed determine output circuit 
length segments required complexity problem known 
conjecture version problem nc point location convex hull integer set points designated point problem convex hull 
long warmuth 
hint reduction monotone circuit value problem 
remarks result shows successive convex hulls problem arbitrary dimension complete 
see problem 
convex hull points euclidean plane computed optimally erew pram log time processors see lingas maheshwari 

geometry successive convex hulls sch set points euclidean plane integer designated point problem th remaining convex hull formed repeatedly finding removing convex hulls 
lingas maheshwari 
hint chazelle shows problem 
reduction multi list ranking problem 
remarks see problem closely related question 
appendix complete problems real analysis real analogue cvp feasible real function defined 
real function feasible sufficiently accurate fixed point binary approximation fixed point binary approximation absolute error computed time sufficiently accurate means error approx input fixes number input bits 
continuity limits range fixes number output bits 
polynomial problem compute absolute error hoover 
hint reduction circuit value problem 
function computes continuous analog circuit value function mapping circuit descriptions possible inputs real line 
evaluate circuit input treat encoding integer bits bit fixed point binary fraction add 
value rational number encodes values gates input continuous evaluation points simply linearly interpolated 
remarks function yields family fp complete polynomials pn computable feasible size magnitude circuits 
arithmetic circuit family feasible size magnitude th member polynomial size output interval computed generating intermediate values magnitude exceeding fixed points contraction mappings nc real function behaves contractor interval contained 
endpoints specified integers 
real function nc approximation absolute error computed nc input output conventions problem 

real analysis problem compute fixed point absolute error hoover 
hint reduction circuit value problem 
basic technique function evaluates circuit level level converging fixed point encodes final state circuit 
finding fixed point fp iteration contraction mapping reduces width interval constant factor 
remarks provides argument fast numerical methods fixed points probably contraction maps better linear rates convergence newton method 
inverting injective real function nc real function defined 
function increasing property 
unique root 
real function nc approximation error computed nc problem compute error ko 
hint map intermediate configurations logarithmic space deterministic turing machine real line 
remarks problem expressed originally terms logarithmic space computability reductions logarithmic space computable logarithmic space computable dlog equals problem remains hard required differentiable 
appendix complete problems games player game game player game defined 
pi set positions player turn move 
set immediate winning positions defined player starting position 
set allowable moves player respectively may move position position single step 
position winning player winning position winning move problem winning position player 
jones greenlaw hoover ruzzo 
hint reduce am cvp problem game 
gates circuit correspond winning positions player gates winning positions player 
set inputs having value true output 
winning output circuit true 
remarks original reduction jones problem game 
construct game allowable moves 
player attempts prove vertex generated exhibiting elements claimed generated player attempts exhibit element pair generated game instance graph solvability follows determining graph solution complete kasif 

games cat mouse cm directed graph distinguished vertices problem mouse winning strategy game 
game played follows 
cat starts vertex mouse vertex represents goal vertex 
cat mouse alternate moves mouse moving 
move consists directed edge graph 
player option pass remaining vertex 
cat allowed occupy goal vertex 
mouse wins reaches goal vertex caught 
cat wins mouse cat occupy vertex 
chandra stockmeyer larry stockmeyer personal communication 
hint reduction logarithmic space alternating turing machine assume starts existential configuration unique accepting configuration existential existential universal configuration exactly immediate successors universal respectively existential 
directed graph constructed number vertices graph proportional number configurations illustrate existential configurations simulated account cat mouse able pass move 
copies configuration denoted graph construct 
graph additional vertices 
consider existential configuration succeeding universal configurations assume cat mouse mouse turn move 
directly connected connected intermediate vertices 
connected respectively 
connected respectively 
connected mouse simulates existential move moving 
mouse moves cat move respectively 
mouse move respectively 
mouse move respectively universal move ready simulated 
simulation universal moves fairly similar cat moving 
game starts cat mouse edge accept input mouse appendix complete problems winning strategy 
acyclic geography game agg acyclic directed graph 
describe game chandra tompa 
acyclic geography game played players 
configuration game vertex players take turns choosing edge changing game configuration initial configuration 
player move left loses 
problem player winning strategy 
chandra tompa 
hint reduction monotone circuit value problem 
remarks chandra tompa show depth constrained version geography game called complete ac 
players token boolean matrix describe game played 
initially token placed position turn move current submatrix term current submatrix denotes portion game currently played 
turn consists moving token horizontally current submatrix entry mij 
point columns left columns right removed current submatrix depending causes fewer columns removed 
note token occupies corner current submatrix 
turn similar moves vertically rows removed 
player moves left loses 
problem winning strategy 
chandra tompa 
hint reduction acyclic geography game problem 
remarks game larger portion current submatrix thrown away 
complete ac 
variant games called complete logcfl sac 

games game life life initial configuration game life time bound expressed unary designated cell grid 
game life played infinite grid 
cells squares grid live dead 
cell neighbors 
initial configuration specifies certain cells live game 
rules game follows 
cell dead time live time exactly live neighbors time 
cell dies time live neighbors time problem cell live time berlekamp conway guy pages greenlaw hoover ruzzo 
hint berlekamp conway guy sketch reduction game life capable universal computation 
translated result statement complete problem 
time bound expressed unary decision problem answered polynomial time 
reduction cvp problem 
key reduction life forms guns simulate gates 
inputs represented streams thinned redirected copied 
suppose represents stream 
stream complemented gun cause vanishing reaction 
shot gun collide stream disappear 
particular point collide shot gun proceeds output stream 
performing function gate 
gate fanout built respectively gun eater 
streams copied guns 
cell live time output gate circuit evaluates true 
additional details reduction 
remarks game life example dimensional cellular automata see problem 
known dimensional version game life simulate turing machine 
see problem details dimensional cellular automata 
appendix complete problems zero sum bimatrix game matrices integer entries designated natural number game involves players 
simultaneously player chooses row player chooses column result choices player receives aij respectively bij points 
strategy player dominates strategy player aij ai 
strategy player dominates strategy player bij bij 
easy see dominated strategies removed matrix affecting outcome game 
reduced game dominated strategies eliminated 
game zero sum denotes matrix entries 
problem row matrix deleted reduced game 
bimatrix game reduced game unique row column permutations knuth papadimitriou tsitsiklis elimination order affect answer question 
knuth papadimitriou tsitsiklis 
hint give polynomial time algorithm general problem game required zero sum game 
reduction proving completeness variant monotone circuit value problem 
variant requires gates gates inputs gates allowed expect inputs gates output circuit come gate gates inputs fanout circuit inputs 
variant similar problem obviously complete 
instance restricted version 
reduction involves constructing matrix matrix equals game zero sum 
denote number gates number inputs plus gates 
matrix 
rows correspond circuit inputs gates 
columns correspond gates 
chosen row corresponding output gate 
description entries broken parts 
left submatrix row remaining right submatrix size describe submatrix entries aij 
aij row corresponds gate receives input gate represented column 
games 
aij row corresponds input gate represented column 
aij row corresponds false input input gate represented column 
aij falling categories entry 
row matrix entries ai 
follows 

false circuit input 

entries constructed row column eliminated corresponded gate input circuit true 
person pebble game fixed rank pebble fixed rank pebble game 
definitions adachi iwata 
pebble game tuple properties 

finite set vertices 

called set rules 
write 
move rule 
symbol denotes reflexive transitive closure 

subset 
terminal vertex 
pebble game fixed rank number vertices fixed 
person pebble game players alternate moving pebbles moving 
winner player pebble force player move situation 
problem player winning strategy 
adachi iwata 
appendix complete problems hint reduction logarithmic space bounded alternating turing machine 
remarks pebble game solvable exists person pebble game determine game solvable fixed ranked nlog complete 
questions similar flavor see problems 
additional remarks see section 

miscellaneous miscellaneous generic machine simulation problem string description turing machine integer coded unary 
precise input string delimiter character string 
problem accept steps 
folklore 
hint proof chapter 
remarks buss goldsmith show variant problem complete respect quasilinear time reductions pl subclass see appropriate definitions 
show variants problems complete setting 
general deadlock detection multigraph 
pn set process vertices 
rm set resource vertices set 
tm ti denotes number units ri 
bipartite multigraph represents state system 
edges form pi rj denoting request process pi resource rj form rj pi denoting allocation resource rj process pi 
problem deadlock state 
deadlock state nontrivial subset processes change state change state 
spirakis 
hint reduction monotone circuit value problem 

denote instance 
process pi associated additional special process 
representation gates follows 
input false true value edge pi rf respectively rti pi rf rti denote single unit resource vertices representing false respectively true 
appendix complete problems 
suppose gate fanout 
edges pi ri pi ri ri pj ri pk added edges pi ri pi ri ri pj ri pk added resource vertices single unit resources 

suppose gate fanout 
edges pi ri jk ri jk pj ri jk pk added edges pi ri jk ri jk pj ri jk pk added resource vertices unit resources 
subscripts resource vertices uniquely identify vertices meaning associated 
edges added special process follows add rf rti add 
graph deadlock state true 
remarks note reduction maximum number units resource 
problem nc ti equals 
unit resource 
system states expedient resource allocator satisfies soon possible request connected process time problem nc 
dimensional cellular automata ca initial configuration dimensional cellular automata time bound expressed unary state designated cell bi infinite lattice 
square dimensional bi infinite lattice called site 
site may take finite set values alphabet range site denotes number neighbors side site directly influence 
variables site denoted take values local transition rule 

value equal value time determined values neighbors time problem cell state time lindgren smith albert 
miscellaneous greenlaw hoover ruzzo 
hint known dimensional cellular automata capable universal computation 
translated result complete decision problem 
time bound expressed unary problem reduction direct simulation arbitrary turing machine 
idea sites cellular automata asleep site holds turing machine state position lattice reflects turing machine tape head position 
site simulates move awakens left right neighbor appropriate passes new state appropriate puts sleep 
cell automata state time turing machine accepts input 
remarks lindgren construct universal dimensional cellular automata tape symbol state universal turing machine minsky 
implying respectively neighbor rule construction requires respectively states 
results require periodic background 
uniform background constructions require states respectively neighbor rule 
fluid invasion fluid graph source sink distinguished vertex time nonnegative real conductances kij edge nonnegative real capacities vertex problem vertex filled invading fluid time fluid invasion algorithm 
informally fluid invasion algorithm proceeds adding vertices cluster time depending fill fluid inserted source cluster consists vertices filled invading fluid 
evolution fluid configuration governed law 
reader referred additional details fluid model 

hint reduction see problem 
gadget constructed simulate circuit vertex gadget fills fluid corresponding gate circuit evaluates true 
key ideas reduction fluid blocked preceding particular path appendix complete problems started 
terms circuit instance means values kept propagating forward circuit 
remarks fluid invasion remains complete restricted dimensional lattice connected sites face respectively opposite face lattice conductances equal 
proof restricted version complete complicated follow easily result fluid 
additional schemes designed model pattern formation processes studied computational complexity point view greenlaw 
provide nc algorithms compute percolation clusters different models invasion percolation invasion percolation trapping ordinary percolation 
eden growth undirected graph vertex fixed length label sequence distinct numbers 
designated source vertex designated vertex problem vertex added eden cluster formed 
initial cluster consists vertex step vertex adjacent current cluster th label smallest added cluster 
jonathan raymond greenlaw personal communication 
hint topological ordered see problem reduced directed space time version eden growth 
version converted instance eden growth stated problem definition 
remarks eden growth process studying tumor growth 
see greenlaw additional information parallel complexity eden growth related growth models 
lempel ziv data compression binary strings problem string added dictionary string encoded lz coding algorithm 
lz algorithm reads string left right 
dictionary initially empty 
prefix unparsed portion dictionary prefix 
miscellaneous added dictionary 
character prefix compressed replacing pointer dictionary 
de agostino 
hint reduction variant circuit value problem consists gates 
remarks de agostino shows standard variations algorithm yield complete problems 
character heuristic character heuristic 
proved complete reductions version cvp 
de agostino storer show advance dictionary containing strings appropriate assumptions compute optimal compression log time processors crew pram alternatively log time processors 
show techniques generalized sliding window method 
approach de agostino storer obtain log time algorithm processors crew pram 
greedy alphabet reducing gar finite alphabet 
greater sets positive integer equal problem size alphabet obtained greedy alphabet reducing algorithm 
greedy alphabet reducing algorithm 
repeat mapping obtained letting choose satisfying minimizing note denotes natural homomorphism associated remove replacements 
miyano 
appendix complete problems hint reduction problem 
remarks miyano show general alphabet indexing problem np complete alphabet indexing local search problem weighted case pls complete unweighted case complete 
network simulation fully connected undirected network vertices capacity link counted trunks list tuples specifying call arrival holding times designated call problem simulation network see greenberg wang details call blocked 
greenberg wang 
hint reduction monotone circuit value problem 
remarks prove multirate simulation call may require trunk link route complete equal 
see problem related question 
appendix open problems appendix contains list open problems 
open questions stated search problems general possible 
goal classify problem respect computational complexity example finding nc algorithm completeness proof problem 
question specify indicating best knowledge examined parallel complexity problem 
provide starting point research problem 
remarks provided explain known versions problem 
give additional 
problems listed divided categories 
graph theory combinatorial optimization flow logic formal languages algebraic geometry real analysis open problem list followed list problems complexity class cc list problems rnc classes related nc ways cc nc rnc far cc incomparable nc rnc rnc incomparable classes related appendix open problems relation 
conclude remarks open problems section noting knowledge remaining open problems garey johnson known hard 
problems follows graph isomorphism open see remarks problems precedence constrained processor scheduling open see remarks problems composite number open minimum length triangulation open 

graph theory graph theory bounded degree graph isomorphism undirected graphs 
vertices maximum degree constant independent sizes problem isomorphic 
isomorphic bijections edge furst hopcroft luks 
remarks luks showed problem 
degree bound problem np known known hard np complete 
lindell shows tree isomorphism problem nc see remarks problem 
subtree isomorphism rnc gibbons lingas karpinski 
see problem additional details 
edge ranking er tree 
problem find optimal edge ranking edge ranking tree labeling edges positive integers path edges label contains intermediate edge higher label 
edge ranking optimal highest label small possible 
de la torre greenlaw sch 
remarks problem proved 
give nc approximation algorithm problem finds edge ranking factor optimal 
nc algorithm constant degree trees 
similar problem called node ranking problem trees vertices labeled edges proved nc de la torre greenlaw de la torre greenlaw 
see problem related complete problem 
karloff shmoys give nc algorithms versions edge ranking multigraphs problem having similar flavor 
see problems description results 
appendix open problems edge weighted matching undirected graph positive integer weights edges 
problem find matching maximum weight 
matching subset edges edges share common endpoint 
karp upfal wigderson 
remarks rnc weights polynomially bounded 
restricted case problem known nc define rank position edge weight sorted list edge weights sorting done increasing order 
lexicographically maximal matching problem cc nc reducible assigning weight rank edge graph closure gc undirected graph designated edge 
problem closure 
graph obtained repeatedly joining nonadjacent pairs vertices degree sum 
khuller 
remarks modification problem complete see problem add set designated edges vertices degree sum corresponding edge may added closure 
low degree subgraph lds undirected graph integer problem find maximal induced subgraph maximum degree greenlaw 
remarks maximal independent set problem lds equal zero see problem 
shows lds angelo monti solved problem proving complete sergio de agostino personal communication 

graph theory viewed connectionist model problem edge weights value see problem 
decision problems low degree subgraph computations proved np complete 
maximal independent set hypergraph hypergraph elements subsets called hyperedges problem find maximal independent set set independent independent set maximal independent 
beame luby 
remarks edges element sets dimension problem maximal independent set problem known nc see problem 
beame luby give rnc algorithm dimension 
cites personal communication beame indicating beame luby analysis fact holds dimension 
beame luby give algorithm general problem conjectured rnc shows algorithm rnc constant dimension 
dahlhaus karpinski give nc algorithm dimension 
denote number vertices hypergraph number edges 
algorithm runs log time uses processors erew pram 
restricted lexicographically maximal independent set undirected planar bipartite graph numbering vertices problem find lexicographically maximal independent set 
miyano 
remarks see problem 
finding lexicographically maximal subgraph maximum degree planar bipartite graphs degree complete 
appendix open problems lexicographically maximal cycle free edge induced subgraph lf edge undirected graph ordering edges having maximum degree 
problem compute lexicographically maximal cycle free edge induced subgraph lexicographically maximal edge induced subgraph contain cycles size 
miyano 
remarks numerous variants problem complete 
see problem description 
lf edge nc degree restriction 
planar graphs complexity problem open 
known degree restriction lf edge problem complete clear problem nc combinatorial optimization optimal variable integer linear programming opt ilp linear system inequalities ax matrix vector ordered pair problem find vector denotes transpose ax ux maximum 
deng pan lin 
remarks problem nc equivalent problem computing remainders produced euclidean algorithm see problem 
pan lin illustrate reductions problems nc equivalent related problems 
see remarks problems 
variable linear programming linear system inequalities ax row nonzero elements 
matrix vector 

logic problem find feasible solution exists 
lueker megiddo ramachandran 
remarks polylogarithmic algorithm uses log processors crew pram 
see problems 
logic canonical labeling founded extensional relation founded relation 
reader referred definitions 
problem compute canonical labeling relation 
dahlhaus 
remarks see problem related complete problem 
left linear semi unification set pairs terms 
mk nk left linear 
see problem definitions 
problem semi unifiable 
henglein 
remarks complete see problem 
henglein conjectures complete 
formal languages strong bisimilarity deterministic transition systems encoding finite labeled deterministic transition system designated states finite labeled transition system triple finite set states finite alphabet set transitions 
system deterministic unique triple relation strong bisimulation implies appendix open problems 
state 
state strong bisimulation relation defined union strong bisimulations problem strongly bisimilar 
strong bisimulation relation 
zar 
remarks problem complete system allowed nondeterministic see problem 
complexity problem open states restricted indegree 
witness unambiguous finite automata unambiguous finite automaton integer encoded unary 
finite automaton unambiguous strings accepted machine unique accepting computation 
problem find lexicographically witness string lexicographically witness string lexicographically string witnesses inequality denotes language accepted denotes strings length equal sang cho huynh 
remarks problem proved deterministic finite automata problem nc complete nlog 
see results regarding related problems 

algebra algebra extended euclidean algorithm bit positive integers problem compute integers bt gcd 
borodin von zur gathen hopcroft 
remarks analogous problem th degree polynomials nc 
deng shows problems nc equivalent closely related problem 
expanding continued fraction ratio integers computing sequence integers 
see pan lin remarks problem 
gaussian elimination partial pivoting finite fields matrix entries finite field integer problem smallest row index th column nonzero gaussian elimination partial pivoting performed 
allan borodin personal communication 
remarks vavasis shows analogous problem unrestricted fields complete see problem 
integer greatest common divisor bit positive integers problem compute greatest common divisor gcd denoted gcd 
von zur gathen 
remarks th degree polynomials computing gcd nc nc reduction determinant cook sethi borodin cook pippenger 
nc reducible short vectors dimension problem 
kannan miller rudolph give sublinear appendix open problems crcw pram algorithm computing gcd bit integers 
algorithm requires log log log time log processors 
chor goldreich give crcw pram algorithm problem time bound log processor bound positive constant 
sorenson presents algorithm called ary gcd algorithm sequential version practical parallel version bounds match 
see deng lin pan pan lin additional research related problems 
lu decomposition lud matrix entries rationals 
problem find numerically stable lu decomposition allan borodin personal communication 
remarks vavasis shows lu decomposition arising gaussian elimination partial pivoting complete see problem 
problem find method constructing lu decomposition nc question important solves system equations multiple times 
having lu decomposition means solution different vectors easily obtained back substitution 
modular inversion bit prime bit positive integer divide problem compute ab mod 
tompa 
remarks reducible problem 
reduction compute pt gcd 
reducible problem restricted prime moduli 
idea compute mod apply fermat little theorem 
considers slight variant problem replaced smooth modulus 
number smooth prime factors small 
case gives logarithmic space uniform boolean family circuits solve problem log log log depth 
algebra size 
gives analogous results polynomials finite fields 
modular powering positive bit integers problem compute mod cook 
remarks complexity problem open finding single bit desired output 
problem nc smooth having small prime factors von zur gathen 
improves circuit depth required solve problem 
presents logarithmic space uniform boolean circuits depth log log log polynomial size 
similar results polynomials 
considers problem discrete roots shows smooth modulus problem solved logarithmic space uniform boolean circuits depth log log log polynomial size 
special case prime antithesis smooth problem open 
problem reducible restricted case 
analogous problems th degree polynomials finite field small characteristic modular polynomial exponentiation polynomial exponentiation nc tompa 
open finite fields having large superpolynomial characteristic 
note reduced polynomial version exponential characteristic simply considering degree polynomials 
relative bit positive integers problem relatively prime 
tompa 
remarks problem special case problem 
appendix open problems subgroups group problem find subgroups babai luks 
remarks problem known kantor nc question open solvable groups 
permutation group testing membership finding order finding center finding composition series known nc 
babai luks open questions involving group theory 
geometry limited reflection ray tracing set flat mirrors lengths 
ln placements rational points plane source point trajectory single beam emitted designated mirror problem hit beam emitted reflections 
mirrors angle incident beam equals angle reflection 
greenlaw hoover ruzzo 
remarks general ray tracing problem determine mirror hit beam 
mirrors points length general problem nc de la torre raymond greenlaw personal communication 
dimensions general problem pspace reif tygar yoshida 
dimensions mirrors placed rational points general problem pspace hard 
general problem open mirrors fixed size 
see detailed discussion 
restricted plane sweep triangulation sweep vertex polygon holes 
problem find triangulation computed plane sweep triangulation algorithm 
see problem description 
geometry algorithm 
atallah callahan goodrich 
remarks problem finding arbitrary triangulation nc goodrich 
polygon allowed holes problem complete 
see problem 
oriented weighted planar partitioning set nonintersecting segments 
sn euclidean plane set associated integer weights 
wn designated segments segments oriented meaning different possible slopes segments 
problem segments touch partitioning plane constructed extending segments order weights 
segments extended reach segment previous segment extension 
atallah callahan goodrich 
remarks oriented version problem different slopes allowed complete 
unit length visibility layers set unit length horizontal nonintersecting line segments euclidean plane designated segment integer problem label assigned segment visibility layering process 
visibility layering process repeatedly compute delete upper envelope remaining set segments label segments current depth 
upper envelope consists segments visible point 
atallah callahan goodrich 
remarks problem complete restriction unit lengths removed 
see problem 
appendix open problems real analysis short vectors sv input vectors 
zn linearly independent problem find nonzero vector module lattice zn norm 
von zur gathen 
remarks lenstra lenstra lov sz show problem 
problem nc reducible sv 
additional remarks related problems see kannan 
short vectors dimension sv input vectors linearly independent rational number 
problem find nonzero vector von zur gathen 
remarks problem nc reducible sv 
additional remarks related problems see kannan 
polynomial root approximation pra th degree polynomial integer 
problem real complex root zi approximation zi zi zi ben 
remarks roots real problem nc 

cc univariate polynomial factorization th degree polynomial 
problem compute factorization von zur gathen 
remarks nc reducible short vectors problem 
cc researchers including anderson cook gupta mayr subramanian suggested looking complexity comparator circuit value problem problem 
problem defined problem 
cc defined class problems nc reducible mayr subramanian 
problems section equivalent nc 
evidence compelling rnc problems see section generally considered problems complete lack fanout comparator circuits 
hand fast parallel algorithms known partial exception log algorithms related problems 
algorithms independently discovered danny unpublished mayr subramanian 
richard anderson unpublished improved algorithms processors 
mayr subramanian note algorithms complete sense chapter 
known nlog cc 
nc cc incomparable rnc cc classes related relation 
majority results described appendix come mayr subramanian 
see feder ramachandran wang subramanian research cc appendix open problems comparator circuit value problem encoding circuit composed comparator gates plus inputs 
xn designated output comparator gate outputs minimum inputs output wire outputs maximum inputs second output wire 
gate restricted output fanout 
problem output true input 
xn 
stephen cook personal communication mayr subramanian 
remarks cook shows nc equivalent computing lexicographically maximal matching bipartite graph 
mayr subramanian show matching problem nc equivalent stable marriage problem 
vitter tamassia address incremental complexity 
lexicographically maximal matching undirected graph ordering edges distinguished edge problem lexicographically maximal matching 
matching maximal extended 
stephen cook personal communication mayr subramanian 
remarks nc equivalent comparator circuit value problem 
problem resembles lexicographically maximal independent set problem complete 
completeness proof imply edge weighted matching problem complete 
stable marriage sm set men set women 
person ranking opposite sex preference marriage partner 
note preference list need include ranking member opposite sex 
problem called stable problem 
problem instance problem set marriages stable 
set stable set stable marriages 
cc unmatched pair prefer current partners 
mayr subramanian tarjan woods 
remarks see example gibbons background sm 
preference lists complete problem solution 
sm nc equivalent comparator circuit value problem 
variations sm known equivalent 
example male optimal stable marriage problem designated couple question asked man married woman male optimal stable marriage 

male optimal stable marriage formed algorithm 
finds matching man better stable marriage 
versions sm discussed problems 
stable marriage fixed pair set men set women person ranking opposite sex preference marriage partner designated couple alice bob 
problem alice bob fixed pair instance problem 
case alice bob married stable marriage 
mayr subramanian subramanian 
remarks reduction comparator circuit value problem 
stable marriage stable pair set men set women person ranking opposite sex preference marriage partner designated couple alice bob 
problem alice bob stable pair instance problem 
case alice bob married stable marriage 
mayr subramanian subramanian 
remarks reduction comparator circuit value problem 
appendix open problems stable marriage minimum regret set men set women person ranking opposite sex preference marriage partner integer problem stable marriage person regret 
regret person stable marriage position mate preference list 
mayr subramanian subramanian 
remarks goal problem minimize maximum regret person 
reduction comparator circuit value problem 
telephone connection tc telephone line fixed channel capacity integer sequence calls 
sn fn si fi denotes starting respectively finishing time th call 
th call serviced time si number calls served time call served discarded 
call completed channel freed 
problem th call serviced 
ramachandran wang 
remarks tc nc equivalent comparator circuit value problem 
ramachandran wang give min log time erew pram algorithm uses processors solving tc 
see problem 

rnc rnc problems appendix known rnc known nc fnc proof complete unexpected proof nc equals course nc rnc rnc incomparable 
classes related relation 
see section discussion issues 
rnc nc represent rnc respectively nc fnc depending context 
blocking flow layered network bf layered network edge labeled capacity ci distinguished vertices source sink layered network source sink paths length 
problem find blocking flow 
blocking flow flow path saturated edge edge flow equal capacity 
maheshwari 
remarks problem rnc 
problem finding lexicographically blocking flow layered network anderson mayr 
see problem 
problem finding blocking flow acyclic network open 
case goldberg tarjan give erew pram algorithm uses log time processors vertex edge network 
directed undirected depth search dfs graph vertex problem construct depth search numbering starting vertex aggarwal anderson aggarwal anderson kao 
remarks rnc algorithms known appendix open problems directed cases subsuming earlier rnc results planar graphs smith 
directed acyclic graphs dfs nc de la torre kruskal greenlaw 
edge coloring ec undirected graph equal maximum degree vertex problem find edge coloring uses equal colors 
edge coloring assignment colors edges incident edges receive color 
karloff shmoys 
remarks nc algorithm known polylogarithmic 
karloff shmoys give rnc algorithm common crcw pram uses colors running time log processors running time fixed processor bound independent 
see problems 
maximal path mp undirected graph numbering vertices designated vertex problem find maximal path originating path extended encountering vertex path 
anderson mayr anderson 
remarks anderson shows problem computing maximal path rnc 
lexicographically maximal path problem complete restricted planar graphs maximum degree 
maximum degree vertex algorithm find maximal path log time processors 
nc algorithm finding maximal path planar graphs 

rnc maximum disjoint paths mdp undirected graph set vertices problem find maximum cardinality set nontrivial vertex disjoint paths endpoints anderson 
remarks mdp reduced bidirectional flow problem turn reduced matching problem 
see problem 
maximum flow maxflow directed graph edge labeled unary capacity ci distinguished vertices source sink problem find maximum flow 
feather karp upfal wigderson 
remarks feather shows problem finding value maximum flow rnc 
karp upfal wigderson show construct maximum flow rnc 
problems remain rnc capacities polynomially bounded 
complete capacities arbitrary see problem 
karpinski wagner show vertex multiplicity graph representation unary network flow problem complete 
maximum matching mm undirected graph 
problem find maximum matching concept matching defined problem 
matching maximum matching larger cardinality exists 
feather karp upfal wigderson mulmuley vazirani vazirani 
remarks feather shows problem finding size maximum matching rnc 
karp upfal wigderson gave rnc algorithm finding maximum matching 
efficient algorithm mulmuley vazirani vazirani 
karloff shows rnc algorithm matching 
maximum edge appendix open problems weighted matching unary edge weights maximum matching binary vertex weights known rnc 
perfect matching existence pme undirected graph 
problem perfect matching 
perfect matching matching vertex incident edge matching 
karp upfal wigderson mulmuley vazirani vazirani 
remarks see remarks problem 
pme simplest matching problems known nc dahlhaus hajnal karpinski show perfect matching dense graph nc 
karpinski wagner show vertex multiplicity graph representation problem complete 
succinct graph representations able show perfect bipartite matching problem complete 
karpinski show permanent polynomially bounded decide perfect matching nc show construct matching nc 
see karpinski singer karpinski additional related 
akl designed erew pram algorithm solving maximum weight perfect matching problem complete weighted graphs 
algorithm runs log time number vertices graph number processors 
subtree isomorphism sti unrooted trees 
problem isomorphic subtree see problem definition isomorphism 
gibbons lingas karpinski 
remarks rnc algorithms problem developed independently 
uses randomization solely solve number bipartite matching problems see problem 
lindell shows problem determining unrooted 
rnc trees isomorphic tree isomorphism problem solved dlog erew pram log time processors 
appendix notation appendix describe notation book 
standard concepts definition simply explain notation 
items defined book familiar defined 
concepts defined book page concept defined 
ram random access machine 
pram parallel random access machine 
set real numbers 
set rational numbers 
set integers 
integers mod 
set natural numbers 
integer greatest integer exceeding log maximum log 
note include emphasis 
length string absolute value number norm vector cardinality set 
ordered pair consisting vertices graph pair directed edge function 
function 
exclusive denoted xor 
empty string 
finite alphabet 
finite strings alphabet 
strings alphabet length equal equivalent 
concatenation strings concatenation languages depending context 
set functions growth rate order 
functions domains natural numbers ranges positive real numbers 
precisely exist constants cf natural numbers 
example means bounded constant 
items special cases 
see graham knuth patashnik general discussion asymptotic notation 
set polynomially bounded functions 
means bounded polynomial 
set functions polynomial equivalently 
log polylogarithmic bounded function set functions polynomial log equivalently log set functions growth rate order 
functions domains natural numbers ranges positive real numbers 
exist constants cf natural numbers 
appendix notation functions growing asymptotically slower 
functions domains natural numbers ranges positive real numbers 
lim 
functions growing asymptotically faster 
functions domains natural numbers ranges positive real numbers 
lim 
set functions growth rate order log 
functions domains natural numbers ranges positive real numbers 
precisely exist constants log natural numbers 
nc log nc nc reducibility see page 
nc reducibility see page 
nc reducibility see page 
logarithmic space reducibility see page 
turing reducibility see page 
nc turing reducibility pram see page 
nc turing reducibility circuits see page 
nc turing reducibility circuits see page 
appendix complexity classes appendix provide list complexity classes mentioned book 
appropriate name class 
classes formally defined book give page definition 
classes mentioned defined text defined 
class defined terms different models just definition 
listing classes provide brief section exhibiting relationships classes 
excellent complexity class definitions alternative definitions broader view classes interrelate johnson 
definitions follows denotes size input 
ac class ac set languages recognized uniform unbounded fanin circuit family size depth log 
type uniformity usually applied definition logarithmic space uniformity ac usually defined uniformity 
circuit description computed random access deterministic turing machine log time 
appendix complexity classes ac cc det dlog class ac ac alternating logarithmic space denoted aspace log 
class set languages decidable alternating turing machines space bounded log 
comparator circuit value 
class cc set languages logarithmic space reducible comparator circuit value problem 
determinant class det set languages nc turing reducible integer determinant problem 
integer determinant problem problem computing determinant matrix having bit integer entries 
deterministic logarithmic space denoted dspace log dl 
class dlog set languages decidable deterministic turing machines space bounded log 
deterministic logarithmic time 
class set languages decidable random access deterministic turing machines time log 

definitions fnc fnc fp class fnc set functions computable uniform bounded fanin circuit family size depth log 
type uniformity usually applied definition logarithmic space uniformity fnc uniformity appropriate 
function nc class fnc fnc function class fp set functions computable sequential time class set functions computable uniform probabilistic circuit family size depth log having error probability 
type uniformity usually applied definition logarithmic space uniformity uniformity appropriate 
function rnc class logcfl class logcfl set languages logarithmic space reducible context free language 
appendix complexity classes nc nc nc nc nlog np class set languages logarithmic space reducible deterministic context free language 
nc see definition page 
nc see definition page 
nc zero class nc set languages recognized uniform boolean circuit family size depth 
nick class see definitions pages 
nondeterministic logarithmic space denoted log nl 
class nlog set languages decidable nondeterministic turing machines space bounded log 
nondeterministic polynomial time 
class np set languages decidable nondeterministic turing machine time number sharp 
definitions ph pls definition johnson 
counting turing machine ctm nondeterministic turing machine output input string number accepting computations input 
class set functions computable run polynomial time 
polynomial time see definition page 
polynomial time hierarchy 
class set languages decidable nondeterministic polynomial time oracle problem class ph pk polynomial local search 
definitions taken sch yannakakis 
local search problem ps computation problem search problem feasible solution instance set feasible solutions denoted integer measure 
maximized minimized 
solution set neighboring solutions denoted 
solution locally optimal strictly better neighbor 
larger smaller measure case maximization respectively minimization problem 
specification ps includes set instances local search problem input instance find locally optimal solution 
local search problem ps class pls polynomial local time search problems polynomial time algorithms exist 

algorithm input computes initial feasible solution belonging 
appendix complexity classes pspace rnc sac sac sc sc 
algorithm input computes 

algorithm input determines locally optimal finds better solution 
polynomial space 
class pspace set languages decidable turing machines space bounded random nc see definition page 
class sac set languages decidable uniform circuit family size depth log gates allowed unbounded fanin gates required bounded fanin 
type uniformity usually applied definition logarithmic space uniformity 
semi unbounded circuits 
class sac sac class sc set languages decidable deterministic turing machines space bounded log time simultaneously bounded steve class 
class sc sc 
definitions sp symmetric logarithmic space denoted sl 
class set languages decidable symmetric turing machines space usage input length bounded log 
semi efficient parallel time 
class sp consists problems sequential running time improved processors 
appendix complexity classes relationships complexity classes section mention relationships complexity classes discussed book 
note abused notation slightly include relations language classes ac function classes det sac ac nc sac ac nc sac ac nc sac ac nc dlog sc nlog logcfl sac dlog logcfl nlog det ac sc sc sc dlog nlog cc np ph pspace np pspace bibliography numbers parentheses entry bibliography page numbers item referenced 
abrahamson kirkpatrick 
simple parallel tree contraction algorithm 
journal algorithms 
abrahamson fellows wilson 
parallel 
lauer editors proceedings fourth international conference computing information pages toronto ont canada may 
ieee 
afrati 
parallel complexity single rule logic programs 
discrete applied mathematics december 
afrati papadimitriou 
parallel complexity simple logic programs 
journal acm september 
aggarwal anderson 
random nc algorithm depth search 
combinatorica 
aggarwal anderson 
kao 
parallel depth search general directed graphs 
siam journal computing april 
aho hopcroft ullman 
design analysis computer algorithms 
addison wesley revised edition 
albert ii 
simple universal cellular automata way versions 
complex systems 
allender 
uniform circuit complexity 
journal acm october 
bibliography alon babai itai 
fast simple randomized parallel algorithm maximal independent set problem 
journal algorithms december 
zar 
parallel complexity design analysis concurrent systems 
aarts van leeuwen rem editors parle parallel architectures languages europe volume volume lecture notes computer science pages eindhoven netherlands june 
springer verlag 
anderson 
complexity parallel algorithms 
phd thesis stanford university 
computer science department technical report stan cs 
anderson 
parallel algorithm maximal path problem 
combinatorica 
anderson mayr 
complete problem approximations 
technical report stan cs stanford university 
anderson mayr 
parallelism greedy algorithms 
advances computing research volume pages 
jai press 
anderson mayr 
parallelism maximal path problem 
information processing letters 
anderson mayr warmuth 
parallel approximation algorithms bin packing 
information computation september 
atallah callahan goodrich 
complete geometric problems 
proceedings acm symposium parallel algorithms architectures pages crete greece july 

nielsen reduction complete problems free groups 
theoretical computer science 

complexity intersection conjugacy free groups 
theoretical computer science 
babai luks 
permutation groups nc proceedings nineteenth annual acm symposium theory computing pages new york ny may 
bibliography kannan 
lattices basis reduction algorithm 
technical report cmu cs carnegie mellon university dept computer science 
zar 
deciding bisimilarity complete 
formal aspects computing 
barrington immerman 
uniformity nc journal computer system sciences december 
barrington mckenzie 
oracle branching programs logspace versus information computation november 
beame cook hoover 
log depth circuits division related problems 
siam journal computing november 
beame luby 
parallel search maximal independence minimal dependence 
proceedings annual acm siam symposium discrete algorithms pages san francisco ca january 
acm 
mckenzie 
circuits monoidal gates 
finkel pages 
mckenzie th 
membership problem aperiodic transformation monoids 
journal acm july 
ben kozen tiwari 
fast parallel algorithm determining roots polynomial real roots 
siam journal computing december 
berger 
fourth moment method 
proceedings second annual acm siam symposium discrete algorithms pages san francisco ca january 
acm 
berger shor 
approximation algorithms maximum acyclic subgraph problem 
proceedings annual acm siam symposium discrete algorithms pages san francisco ca january 
acm 
berlekamp conway guy 
winning ways mathematical plays volume games particular 
academic press 
bibliography 
characterizing classes efficiently parallelizable problems 
editors vlsi algorithms architectures proceedings international workshop parallel computing vlsi pages italy may published 
north holland 
blelloch 
scans primitive parallel operations 
international conference parallel processing pages 
blelloch 
prefix sums applications 
reif chapter pages 
bondy murty 
graph theory applications 
macmillan 
revised paperback edition 
crescenzi de agostino 
complete approximation algorithms 
manuscript submitted 
boppana lagarias 
way functions circuit complexity 
selman editor structure complexity theory volume lecture notes computer science pages berkeley ca june 
springer verlag 
borodin 
relating time space size depth 
siam journal computing december 
borodin 
structured vs general models computational complexity 
math july december 
pages 
borodin cook pippenger 
parallel computation endowed rings space bounded probabilistic machines 
information control 
borodin von zur gathen hopcroft 
fast parallel matrix gcd computations 
information control 
de agostino 
parallelism feedback vertex set problem 
information processing letters june 
karloff 
coloring planar graphs parallel 
journal algorithms 
broder 
hard marry random 
approximation permanent 
proceedings eighteenth annual acm symposium theory computing pages berkeley ca may 
errata proceedings twentieth annual acm symposium theory computing page chicago il may 
bibliography brooks 
coloring nodes network 
proceedings cambridge philosophical society 
buss goldsmith 
nondeterminism editors stacs th annual symposium theoretical aspects computer science volume lecture notes computer science pages hamburg germany february 
springer verlag 
chandra kozen stockmeyer 
alternation 
journal acm january 
chandra stockmeyer 
alternation 
th annual symposium foundations computer science pages houston tx october 
ieee 
preliminary version 
chandra tompa 
complexity short person games 
discrete applied mathematics november 
chang lee 
symbolic logic mechanical theorem proving 
academic press 
chazelle 
convex layers planar set 
ieee transactions information theory 
maheshwari 
parallel complexity finding blocking flow layer network 
information processing letters 
rytter 
parallel complexity lexicographically problems tree structured graphs 
editors mathematical foundations computer science proceedings th symposium volume lecture notes computer science pages por poland august september 
springer verlag 
chor goldreich 
improved parallel algorithm integer gcd 
algorithmica 
cole vishkin 
accelerated centroid decomposition technique optimal tree evaluation logarithmic time 
algorithmica 
condon 
theory strict completeness 
finkel editors stacs th annual symposium theoretical aspects computer science volume lecture notes computer science pages cachan france february 
springer verlag 
bibliography consens mendelzon 
low complexity aggregation graphlog datalog 
abiteboul kanellakis editors icdt 
third international conference database theory proceedings volume lecture notes computer science pages paris france december 
springer verlag 
cook 
path systems language recognition 
conference record second annual acm symposium theory computing pages ma may 
cook 
characterizations pushdown machines terms time bounded computers 
journal acm january 
cook 
complexity theorem proving procedures 
conference record third annual acm symposium theory computing pages shaker heights oh may 
cook 
observation time storage trade 
conference record fifth annual acm symposium theory computing pages austin tx april may 
cook 
observation time storage trade 
journal computer system sciences december 
cook 
deterministic cfl accepted simultaneously polynomial time log squared space 
conference record eleventh annual acm symposium theory computing pages atlanta ga april may 
see 
cook 
complexity theory synchronous parallel computation 
math january june 
pages 
cook 
taxonomy problems fast parallel algorithms 
information control january february march 
cook 
parallel pointer machines 
computational complexity 
cook sethi 
storage requirements deterministic polynomial time recognizable languages 
journal computer system sciences 
cormen leiserson rivest 
algorithms 
mit press 
cosmadakis 
word generator problems lattices 
information computation 
bibliography 
fast parallel matrix inversion algorithms 
siam journal computing 

complete problems theory reals 
journal complexity december 
dahlhaus 
setl suitable language parallel programming theoretical approach 
rger ning richter editors csl st workshop computer science logic volume lecture notes computer science pages karlsruhe west germany october published 
springer verlag 
dahlhaus 
complexity subtheories existential linear theory reals 
rger ning richter editors csl rd workshop computer science logic volume lecture notes computer science pages kaiserslautern frg october published 
springer verlag 
dahlhaus hajnal karpinski 
optimal parallel algorithm hamiltonian cycle problem dense graphs 
th annual symposium foundations computer science pages white plains ny october 
ieee 
dahlhaus karpinski 
efficient parallel algorithm computing maximal independent set hypergraph dimension 
information processing letters july 
dasgupta 
learning capabilities recurrent neural networks 
proceedings volume pages birmingham april 
ieee 
de agostino 
complete problems data compression 
theoretical computer science 
de agostino storer 
parallel algorithms optimal compression dictionaries prefix property 
storer cohn editors data compression conference pages snowbird ut march 
ieee 
de la torre greenlaw 
super critical tree numbering optimal tree ranking nc proceedings third ieee symposium parallel distributed processing pages dallas tx december 
ieee 
de la torre greenlaw 
optimal tree ranking nc parallel processing letters march 
bibliography de la torre greenlaw sch 
optimal edge ranking trees polynomial time 
technical report university new hampshire 
appear algorithmica 
de la torre greenlaw sch 
optimal edge ranking trees polynomial time 
proceedings fourth annual acm siam symposium discrete algorithms pages austin tx january 
acm 
de la torre kruskal 
fast parallel algorithms sources lexicographic search path finding problems 
technical report technical report cs tr university maryland 
appear journal algorithms 
de la torre kruskal 
fast efficient parallel algorithms single source lexicographic depth search breadth search topological search 
international conference parallel processing volume pages iii iii 
delcher kosaraju 
nc algorithm evaluating monotone planar circuits 
manuscript 

computational complexity logical problems 
phd thesis harvard university 
lewis 
complexity satisfiability problem krom formulas 
theoretical computer science 
deng 
parallel complexity integer programming 
proceedings acm symposium parallel algorithms architectures pages santa fe nm june 
lingas maheshwari 
multi list ranking complexity applications 
finkel pages 
dinic 
algorithm solution problem maximum flow network power estimation 
soviet math 
doklady 
dobkin lipton reiss 
linear programming log space hard information processing letters february 
dobkin reiss 
complexity linear programming 
theoretical computer science 
dolev upfal warmuth 
parallel complexity scheduling precedence constraints 
journal parallel distributed computing 
bibliography dwork kanellakis mitchell 
sequential nature unification 
journal logic programming 
dwork kanellakis stockmeyer 
parallel algorithms term matching 
siam journal computing august 

simultaneous resource bounds parallel computation 
phd thesis university toronto august 
department computer science technical report 
cook 
hardware complexity parallel computation 
st annual symposium foundations computer science pages syracuse ny october 
ieee 
cook 
complexity theory parallel time hardware 
information computation march 
ruzzo 
parallel random access machines owned global memory deterministic context free language recognition 
editor automata languages programming th international colloquium volume lecture notes computer science pages rennes france july 
springer verlag 
tompa 
speedups deterministic machines synchronous parallel machines 
journal computer system sciences april 
feather 
parallel complexity flow matching problems 
master thesis university toronto 
department computer science technical report 
feder 
new fixed point approach stable networks stable marriages 
journal computer system sciences october 

complexity computation parallel random access machine 
reif chapter pages 
tompa 
parallel complexity exponentiating polynomials finite fields 
journal acm july 
finkel wagner editors 
stacs th annual symposium theoretical aspects computer science volume lecture notes computer science germany february 
springer verlag 
bibliography ford fulkerson 
flows networks 
princeton university press 
fortune wyllie 
parallelism random access machines 
conference record tenth annual acm symposium theory computing pages san diego ca may 
furst hopcroft luks 
polynomial time algorithms permutation groups 
st annual symposium foundations computer science pages syracuse ny october 
ieee 
galil 
way deterministic pushdown automaton languages open problems theory computation 
th annual symposium switching automata theory pages 
published journal form 
galil 
open problems theory computation questions way deterministic pushdown automaton languages 
mathematical systems theory 
garey johnson 
computers intractability guide theory np completeness 
freeman 
miller 
teng 
optimal tree contraction erew model 
pages 
ger szemer di 
families symmetric boolean functions 
information processing letters january 
gibbons 
algorithmic graph theory 
cambridge university press 
gibbons rytter 
efficient parallel algorithms 
cambridge university press 
gibbons karp miller 
subtree isomorphism random nc discrete applied mathematics november 

computational complexity stable configuration problem connectionist models 
master thesis university toronto 
goldberg tarjan 
parallel algorithm finding blocking flow acyclic network 
information processing letters june 
bibliography goldberg spencer 
new parallel algorithm maximal independent set problem 
siam journal computing april 
goldschlager 
monotone planar circuit value problems log space complete sigact news summer 
goldschlager 
synchronous parallel computation 
phd thesis university toronto december 
computer science department technical report 
goldschlager 
space efficient algorithm monotone planar circuit value problem 
information processing letters 
goldschlager 
productions context free grammars 
acta informatica 
goldschlager 
universal interconnection pattern parallel computers 
journal acm october 
goldschlager 
construction parallel computers various bases boolean functions 
theoretical computer science 
goldschlager shaw staples 
maximum flow problem log space complete theoretical computer science october 
goodrich 
complexity finite languages 
phd thesis university washington 
goodrich 
triangulating polygon parallel 
journal algorithms 
graham knuth patashnik 
concrete mathematics foundation computer science 
addison wesley 
greenberg 
wang 
experience massively parallel discrete event simulation 
proceedings acm symposium parallel algorithms architectures pages germany june 
greenlaw 
complexity parallel computations inherently sequential algorithms complete problems 
phd thesis university washington december 
department computer science technical report 
bibliography greenlaw 
ordered vertex removal subgraph problems 
journal computer system sciences december 
greenlaw 
model classifying algorithms inherently sequential applications graph searching 
information computation april 
greenlaw 
parallel complexity approximation algorithms maximum acyclic subgraph problem 
mathematical systems theory 
greenlaw 
understanding effective parallelization sequential algorithms 
baeza yates manber editors computer science research applications chapter pages 
plenum press 
greenlaw 
polynomial completeness parallel computation 
reif chapter pages 
greenlaw 
breadth depth search complete 
parallel processing letters 
greenlaw hoover ruzzo 
limits parallel computation completeness theory computing science series editor galil 
oxford university press 

greenlaw 
parallel complexity algorithms pattern formation models 
canada france conference parallel computing volume lecture notes computer science pages montreal canada may 
springer verlag 
greenlaw 
parallel complexity eden growth solid solid growth ballistic deposition 
second european symposium algorithms volume lecture notes computer science pages utrecht netherlands september 
springer verlag 
karpinski 
matching problem bipartite graphs polynomially bounded nc th annual symposium foundations computer science pages los angeles ca october 
ieee 
karpinski singer 
fast parallel algorithms sparse multivariate polynomial interpolation finite fields 
siam journal computing december 
hagerup 
planar depth search log parallel time 
siam journal computing august 
bibliography hajnal szemer di 
brooks coloring parallel 
siam journal discrete mathematics 
harrison 
formal language theory 
addison wesley 
hartmanis lewis ii stearns 
hierarchies memory limited computations 
conference record switching circuit theory logical design pages ann arbor mi 
astad 
computational limitations small depth circuits 
mit press 
acm doctoral dissertation award series 
astad 
way permutations nc information processing letters november 

efficient parallel algorithms solving tree problems 
proceedings fourth annual allerton conference communication control computing pages monticello il september 
yesha 
nearly optimal parallel algorithm constructing depth spanning trees planar graphs 
siam journal computing 
helmbold mayr 
perfect graphs parallel algorithms 
international conference parallel processing pages 
ieee 
helmbold mayr 
fast scheduling algorithms parallel computers 
advances computing research volume pages 
jai press 
henglein 
fast left linear semi unification 
akl editors advances computing information volume lecture notes computer science pages niagara falls ont canada may 
springer verlag 
hershberger 
upper envelope onion peeling 
computational geometry theory applications october 

hong 
similarity duality computation 
information control 
hoover 
feasible real functions arithmetic circuits 
siam journal computing february 
hoover 
real functions contraction mappings 
information computation august 
bibliography hoover pippenger 
bounding fanout logical networks 
journal acm january 
hopcroft ullman 
formal languages relation automata 
addison wesley 
hopcroft ullman 
automata theory languages computation 
addison wesley 
horowitz sahni 
fundamentals computer algorithms 
computer science press 
howard 
dynamic programming markov processes 
mit press 
ibarra jiang chang 
iterative cellular tree arrays 
journal computer system sciences june 
ibarra kim 
characterizations computational complexity systolic trellis automata 
theoretical computer science 
ibarra moran 
note parallel complexity computing rank order matrices 
information processing letters december 
immerman 
number quantifiers better number tape cells 
journal computer system sciences 
immerman 
languages capture complexity classes 
siam journal computing 
institute new generation computer technology icot editor 
fifth generation computer systems proceedings international conference fifth generation computer systems tokyo japan november december 
ohmsha springer verlag 
itai 
commodity flow 
journal acm 

parallel algorithms 
addison wesley 
jerrum sinclair 
conductance rapid mixing property markov chains approximation permanent resolved 
proceedings twentieth annual acm symposium theory computing pages chicago il may 
bibliography johnson 
parallel algorithms minimum cuts maximum flows planar networks 
journal acm 
johnson venkatesan 
parallel algorithms minimum cuts maximum flows planar networks preliminary version 
rd annual symposium foundations computer science pages chicago il november 
ieee 
johnson 
np completeness column ongoing guide th 
journal algorithms 
johnson 
catalog complexity classes 
van leeuwen chapter pages 
johnson papadimitriou yannakakis 
easy local search 
journal computer system sciences 
jones 
space bounded reducibility combinatorial problems 
journal computer system sciences 
jones 
complete problems deterministic polynomial time 
conference record sixth annual acm symposium theory computing pages seattle wa april may 
jones 
complete problems deterministic polynomial time 
theoretical computer science 
nakanishi seki kasami 
universal recognition problems parallel multiple context free grammars subclasses 
ieice transactions information systems july 
kanellakis smolka 
ccs expressions finite state processes problems equivalence 
information computation may 
kannan miller rudolph 
sublinear parallel algorithm computing greatest common divisor integers 
siam journal computing february 
kantor 
theorem polynomial time 
journal computer system sciences 

kao 
graphs cycle separators planar directed depth search dnc reif pages 
naor 
fast parallel algorithm color graph colors 
journal algorithms 
bibliography karloff 
las vegas rnc algorithm maximum matching 
combinatorica 
karloff 
nc algorithm brooks theorem 
theoretical computer science october 
karloff ruzzo 
iterated mod problem 
information computation march 
karloff shmoys 
efficient parallel algorithms edge coloring problems 
journal algorithms 
karmarkar 
new polynomial time algorithm linear programming 
combinatorica 
karp 
reducibility combinatorial problems 
miller thatcher editors complexity computer computations pages 
plenum press new york 
karp 
talk university toronto 
karp ramachandran 
parallel algorithms sharedmemory machines 
van leeuwen chapter pages 
karp upfal wigderson 
constructing perfect matching random nc combinatorica 
karp upfal wigderson 
complexity parallel search 
journal computer system sciences april 
karp wigderson 
fast parallel algorithm maximal independent set problem 
journal acm 
karpinski 
boolean circuit complexity algebraic interpolation problems 
rger ning richter editors csl nd workshop computer science logic volume lecture notes computer science pages 
springer verlag duisburg germany october 
karpinski wagner 
computational complexity graph problems succinct multigraph representation 
zeitschrift operations research 
adachi iwata 
classes pebble games complete problems 
siam journal computing 
bibliography kasif 
parallel complexity constraint satisfaction problems 
proceedings aaai fifth national conference artificial intelligence pages philadelphia pa august 
american association artificial intelligence 
kasif 
parallel complexity discrete relaxation constraint satisfaction networks 
artificial intelligence october 
kasif 
analysis local consistency parallel constraint satisfaction networks 
symposium constraint reasoning spring symposium series pages 
aaai march 
extended 
spirakis 
complexity reliable connectivity problem 
information processing letters september 

computing maximal independent set hypergraph constant dimension parallel 
proceedings fourth annual acm symposium theory computing pages victoria canada may 

polynomial time algorithm linear programming 
doklady nauk sssr 
english translation soviet math 
dokl 

khuller 
computing graph closures 
information processing letters june 
khuller schieber 
efficient parallel algorithms testing finding disjoint paths graphs 
siam journal computing april 
lenstra 
parallelism combinatorial optimization 
van leeuwen lenstra editors parallel computers computation volume cwi pages 
center mathematics computer science amsterdam netherlands 
lenstra 
parallel algorithms 
lenstra rinnooy kan editors combinatorial optimization annotated bibliographies chapter pages 
john wiley sons chichester 
lenstra shmoys 
parallel complexity tsp heuristics 
journal algorithms june 
bibliography 
experiments parallel algorithms combinatorial problems 
technical report erasmus university rotterdam econometric inst 
serna spirakis 
parallel complexity connected subgraph problem 
siam journal computing june 
spirakis 
probabilistic log space reductions problems probabilistically hard karlsson lingas editors swat 
st workshop algorithm theory volume lecture notes computer science pages sweden july 
springer verlag 
klein reif 
parallel time log acceptance deterministic exclusive write ram 
siam journal computing june 
knuth papadimitriou tsitsiklis 
note strategy elimination bimatrix games 
operations research letters june 

ko 
binary search roots real functions 
buss scott editors feasible mathematics pages mathematical sciences institute workshop ithaca ny 
birkh user 
kosaraju 
parallel evaluation classes circuits 
madhavan editors foundations software technology theoretical computer science tenth conference volume lecture notes computer science pages bangalore india december 
springer verlag 
kosaraju delcher 
optimal parallel evaluation tree structured computations 
reif pages 
extended 
kozen 
complexity finitely algebras 
conference record ninth annual acm symposium theory computing pages boulder may 

finding verifying locally optimal solutions 
siam journal computing august 
kruskal rudolph snir 
power parallel prefix computation 
international conference parallel processing pages 
kuper mcaloon perry 
note parallel complexity anti unification 
journal automated reasoning 
bibliography ladner 
circuit value problem log space complete sigact news january 
ladner fischer 
parallel prefix computation 
journal acm october 
lawler 
combinatorial optimization networks matroids 
holt rinehart winston new york 
leighton 
parallel algorithms architectures arrays trees hypercubes 
morgan kaufmann 
lengauer 
vlsi theory 
van leeuwen chapter pages 
lengauer tarjan 
asymptotically tight bounds trade offs pebble game 
journal acm october 
lengauer wagner 
binary network flow problem logspace complete theoretical computer science october 
lenstra lenstra jr lov sz 
factoring polynomials rational coefficients 
mathematische annalen december 
lewis papadimitriou 
symmetric space bounded computation 
theoretical computer science august 
lewis ii stearns hartmanis 
memory bounds recognition context free context sensitive languages 
proceedings sixth annual symposium switching circuit theory logic design pages 
ieee 
lin kernighan 
effective heuristic algorithm traveling salesman problem 
operations research january february 
lin 
parallel computational methods integer linear programming 
phd thesis city university new york 
lin pan 
parallel complexity integer linear programming gcd iterated mod function 
proceedings third annual acm siam symposium discrete algorithms pages orlando fl january 
lindell 
logspace algorithm tree canonization 
proceedings fourth annual acm symposium theory computing pages victoria canada may 
bibliography lindgren 
universal computation simple dimensional cellular automata 
complex systems 
lingas 
note parallel heuristic minimum vertex cover 
bulletin european association theoretical computer science october 
lingas karpinski 
subtree isomorphism nc reducible bipartite perfect matching 
information processing letters january 

computational complexity finding connectionist model stable state vectors 
master thesis university toronto 
lipton 
word problems solvable log space 
journal acm 
logic algorithmic international symposium held honor ernst specker rich february 
de math universit de gen 
long warmuth 
composite geometric concepts polynomial predictability 
information computation september 
luby 
simple parallel algorithm maximal independent set problem 
siam journal computing 
luby 
removing randomness parallel computation processor penalty 
th annual symposium foundations computer science pages white plains ny october 
ieee 
lueker megiddo ramachandran 
linear programming variables inequality poly log time 
siam journal computing december 

computational complexity pattern formation 
journal statistical physics february 
greenlaw 
parallel complexity growth models 
technical report tr university new hampshire 
mak 
parallel machines faster sequential machines 
submitted publication august 
bibliography mak 
parallelism helps 
submitted publication august 
mayr 
dynamic tree expression problem 
pages 
mayr 
parallel approximation algorithms 
institute new generation computer technology icot pages volume 
mayr subramanian 
complexity circuit value network stability 
journal computer system sciences april 
mccoll 
planar crossovers 
ieee transactions computers 
megiddo 
note approximate linear programming 
information processing letters april 
miller ramachandran 
efficient parallel evaluation straight line code arithmetic circuits 
siam journal computing august 
miller reif 
parallel tree contraction applications 
th annual symposium foundations computer science pages portland october 
ieee 
miller reif 
parallel tree contraction part fundamentals 
micali editor advances computing research volume randomness computation pages 
jai press greenwich ct 
series editor preparata 
miller reif 
parallel tree contraction part applications 
siam journal computing 
minsky 
computation finite infinite machines 
prentice hall 
miyano 
parallel complexity complete problems 
institute new generation computer technology icot pages volume 
miyano 
parallelizable lexicographically maximal subgraph problem 
information processing letters february 
miyano 
lexicographically maximal subgraph problems completeness nc algorithms 
mathematical systems theory 
bibliography miyano 
approaches complexity subgraph problems 
journal information processing 
miyano 
computational complexity incomplete table recovery 
research report kyushu university research institute fundamental information science september 
miyano 
list complete problems 
technical report tr cs kyushu university research institute fundamental information science 
revised december 
pages 
monti 
complexity reachability problems 
crescenzi editors algorithms complexity second italian conference volume lecture notes computer science pages rome italy february 
springer verlag 
mulmuley 
fast parallel algorithm compute rank matrix arbitrary field 
combinatorica 
mulmuley vazirani vazirani 
matching easy matrix inversion 
combinatorica 
naor 
fast parallel coloring planar graphs colors 
information processing letters april 

algorithmic complexity discrete functions 
soviet physics doklady 
ogden riddle rounds 
complexity expressions allowing concurrency 
conference record fifth annual acm symposium principles programming languages pages tucson az january 
akl 
maximum weight perfect matching problem complete weighted graphs pc proceedings second ieee symposium parallel distributed processing pages dallas tx december 
ieee 
pan reif 
fast efficient parallel solution dense linear systems 
computers mathematics applications 
papadimitriou 
efficient search rationals 
information processing letters 
bibliography papadimitriou sch yannakakis 
complexity local search 
proceedings second annual acm symposium theory computing pages baltimore md may 
extended 
papadimitriou tsitsiklis 
complexity markov decision processes 
mathematics operations research 

parallel speedup sequential machines defense parallel computation thesis 
sigact news summer 

parallel complexity theory 
research notes theoretical computer science 
pitman wiley 
paterson valiant 
circuit size nonlinear depth 
theoretical computer science 
paul tarjan 
space bounds game graphs 
mathematical systems theory 
correction ibid 

pippenger 
fast simulation combinational logic networks machines random access storage 
proceedings fifteenth annual allerton conference communication control computing pages monticello il september 
pippenger 
simultaneous resource bounds 
th annual symposium foundations computer science pages san juan puerto rico october 
ieee 
pippenger 

proceedings fifth ibm symposium mathematical foundations computer science 
ibm japan may 
pippenger 
auxiliary pushdown 
journal computer system sciences october 
pippenger 
advances 
research report rj ibm research division thomas watson research center yorktown heights ny april 
pippenger fischer 
relations complexity measures 
journal acm april 
plaisted 
complete problems order predicate calculus 
journal computer system sciences 
tarjan woods 
notes introductory combinatorics 
birkh user boston 
bibliography post 
valued iterative systems mathematical logic 
number annals math 
studies 
princeton university press 
pratt stockmeyer 
characterization power vector machines 
journal computer system sciences april 
rajasekaran reif 
randomized parallel computation 
pages 
ramachandran 
complexity minimum cut maximum flow problems acyclic network 
networks 
ramachandran 
fast processor efficient parallel algorithms reducible flow graphs 
technical report eng act university illinois urbana champaign 
ramachandran 
fast parallel algorithms reducible flow graphs 
pages 
ramachandran 
wang 
parallel algorithms complexity results telephone link simulation 
proceedings third ieee symposium parallel distributed processing pages dallas tx december 
ieee 
reif 
synchronous parallel computations independent probabilistic choice 
siam journal computing february 
reif 
depth search inherently sequential 
information processing letters june 
reif editor 
vlsi algorithms architectures rd workshop computing volume lecture notes computer science corfu greece june july 
springer verlag 
reif editor 
synthesis parallel algorithms 
morgan kaufmann 
reif tygar yoshida 
computability complexity optical beam tracing 
proceedings st annual symposium foundations computer science pages st louis mo october 
ieee 
reiss 
rational search 
information processing letters 
robinson 
machine oriented logic resolution principle 
journal acm 
bibliography ruzzo 
complete pushdown languages 
unpublished manuscript 
ruzzo 
tree size bounded alternation 
journal computer system sciences october 
ruzzo 
uniform circuit complexity 
journal computer system sciences june 
rytter 
recognition context free languages 
editor computation theory fifth symposium volume lecture notes computer science pages poland december published 
springer verlag 
rytter 
parallel time log recognition unambiguous context free languages 
information computation 
vitter tamassia 
complexity theoretic approach incremental computation 
finkel pages 
sang cho huynh 
complexity membership deterministic growing context sensitive grammars 
international journal computer mathematics 
sang cho huynh 
parallel complexity coarsest set partition problems 
information processing letters may 
sang cho huynh 
parallel complexity finitestate automata problems 
information computation 
sanz editor 
opportunities constraints parallel computing 
springer verlag 
papers workshop december ibm almaden research center san jose ca 

complete graph partition problem 
theoretical computer science november 
savage 
computational time finite machines 
journal acm october 
savage wloka 
parallel algorithm channel routing 
van leeuwen editor proceedings international workshop graph theoretic concepts computer science volume lecture notes computer science pages amsterdam netherlands june published 
springer verlag 
bibliography savage wloka 
parallelizing graph partitioning heuristics 
paterson editor automata languages programming th international colloquium volume lecture notes computer science pages warwick university england july 
springer verlag 
savage wloka 
parallelism graph partitioning 
journal parallel distributed computing november 
savage wloka 
parallel complexity minimizing column conflicts 
editor proceedings second great lakes symposium vlsi design automation vlsi systems pages mi february 
ieee 
savitch 
relationships nondeterministic deterministic tape complexities 
journal computer system sciences 
savitch 
time bounded random access machines parallel processing 
journal acm 
sch yannakakis 
simple local search problems hard solve 
siam journal computing february 
schevon vitter 
parallel algorithm recognizing unordered depth search 
information processing letters june 
serna 
parallel approximability complete problems 
phd thesis universitat de catalunya barcelona 
serna 
approximating linear programming log space complete information processing letters february 
serna spirakis 
approximability problems complete editor optimal algorithms international symposium proceedings 
bulgaria volume lecture notes computer science pages 
springer verlag may june 
pan lin 
nc equivalence planar integer linear programming euclidean gcd 
proceedings th annual symposium foundations computer science pages palo alto ca november 
ieee 
bibliography miyano 
complexity finding alphabet indexing 
manuscript 

lexicographically topological order problem nlog complete 
information processing letters november 

complete language describable iterated shuffle 
information processing letters april 
smith iii 
simple computation universal cellular spaces 
journal acm 
smith 
parallel algorithms depth searches planar graphs 
siam journal computing 
sorenson 
ary gcd algorithm 
technical report university wisconsin madison wi april 
sorenson 
fast gcd algorithms 
manuscript department mathematics computer science university indianapolis january 
spirakis 
parallel complexity deadlock detection 
theoretical computer science 
spirakis 
fast parallel algorithms complexity parallelism basic issues advances 
wolf editors 
fourth international workshop parallel processing cellular automata arrays proceedings volume lecture notes computer science pages berlin east germany october published 
springer verlag 
stein wein 
approximating minimum cost maximum flow complete 
information processing letters july 
stewart 
complete problems symmetric logspace involving free groups 
information processing letters december 
stewart 
refining known results generalized word problem free groups 
international journal algebra computation june 
stewart 
parallelizing greedy heuristic finding small dominant sets 
bit 
stewart 
approximation algorithms clique problem 
international journal foundations computer science 
bibliography stockmeyer meyer 
word problems requiring exponential time 
conference record fifth annual acm symposium theory computing pages austin tx april may 
stockmeyer vishkin 
simulation parallel random access machines circuits 
siam journal computing may 
subramanian 
new approach stable matching problems 
technical report stan cs stanford university department computer science 
subramanian 
computational complexity circuit value network stability problems 
phd thesis stanford university 
department computer science technical report stan cs 

tape complexity deterministic contextfree languages 
journal acm 
sunder 
scheduling interval ordered tasks parallel 
finkel pages 
tarjan vishkin 
finding biconnected components computing tree functions logarithmic parallel time 
th annual symposium foundations computer science pages singer island fl october 
ieee 
tarjan vishkin 
efficient parallel algorithm 
siam journal computing november 

teng 
matching randomly parallel 
department computer science cmu cs carnegie mellon university pittsburgh pa 
dickinson schwartz editors 
concurrent computations algorithms architecture technology 
plenum press 
proceedings princeton workshop algorithm architecture technology issues models concurrent computation september october 
tompa 
unpublished notes nc reductions problems rp 
ullman van gelder 
parallel complexity logical query programs 
algorithmica 
valiant 
parallel computation 
technical report tr harvard center research computing technology april 
th ibm symposium mathematical foundations bibliography computer science japan may 
valiant 
reducibility algebraic projections 
math 
pages 
valiant rackoff 
fast parallel computation polynomials processors 
siam journal computing november 
van emde boas 
second machine class models parallelism 
van leeuwen lenstra editors parallel computers computation volume cwi pages 
center mathematics computer science amsterdam netherlands 
van leeuwen editor 
handbook theoretical computer science volume algorithms complexity 
press elsevier 
vavasis 
gaussian elimination pivoting complete 
siam journal discrete mathematics 

dynamic programming algorithms interpreted helps 
information computation 
tompa 
new pebble game characterizes parallel complexity classes 
siam journal computing june 
vishkin 
synchronous parallel computation survey 
preprint 
courant institute new york university 
vishwanathan sridhar 
results graph coloring parallel 
briggs editor proceedings international conference parallel processing pages volume university park pa august 
pennsylvania state university 
vitter simons 
new classes parallel complexity study unification complete problems ieee transactions computers tc may 
reprinted pages 
von hl cook mehlhorn verbeek 
recognition deterministic cfl small time space 
information control january february 
bibliography von zur gathen 
parallel algorithms algebraic problems 
siam journal computing november 
von zur gathen 
computing powers parallel 
siam journal computing october 
wah li editors 
computers artificial intelligence applications 
ieee computer society press washington dc 

wang lloyd soffa 
feedback vertex sets cyclically reducible graphs 
journal acm april 
wigderson 
improving performance guarantee approximate graph coloring 
journal acm 

white pebbles help 
journal computer system sciences april 

reachability problem directed hypergraphs computational complexity 
lab 
research report er department information science kyoto university november 

parallel computational complexity unification 
institute new generation computer technology icot editor fifth generation computer systems proceedings international conference fifth generation computer systems pages tokyo japan november 
ohmsha north holland 

computing large polynomial powers fast parallel 
editor mathematical foundations computer science proceedings th symposium volume lecture notes computer science pages 
springer verlag czechoslovakia august 

highly parallel computations modulo number having small prime factors 
information computation 
zhang smolka 
efficient parallelization equivalence checking algorithms 
fifth international conference formal description techniques distributed systems communications protocols forte pages france october published 
zhang 
parallel algorithms problems involving directed graphs 
phd thesis drexel university 
problem list complete list complete open problems appendices order appearance problem name page number 
problems listed alphabetically index name acronym 
complete problems circuit complexity circuit value problem cvp topologically ordered circuit value problem monotone circuit value problem alternating monotone fanin fanout cvp am cvp nand circuit value problem synchronous alternating monotone fanout cvp sam cvp planar circuit value problem arithmetic circuit value problem min plus circuit value problem circuit depth ones circuit true gates inverting nc permutation perm circuit evaluation monoids cem graph theory lexicographically maximal independent set lexicographically maximal clique alternating graph accessibility problem hierarchical graph accessibility problem restricted chromatic alternating graph accessibility problem lexicographically vertex coloring high degree subgraph hds problem list high connectivity subgraph hcs reliable connectivity failures incoming edges ordered high degree vertex removal ordered low degree vertex removal ordered vertices remaining neighborhood removal nr greedy dominating set gds nearest neighbor traveling salesman heuristic lexicographically maximal subgraph minimum feedback vertex set edge maximal acyclic subgraph general graph closure generating random matchings grm lexicographically maximal cycle free edge induced subgraph searching graphs lexicographically maximal path maximal vertex disjoint paths paths lexicographically depth search ordering breadth depth search bds stack breadth search alternating breadth search combinatorial optimization linear inequalities li linear equalities le linear programming lp maximum flow maxflow homologous flow hf lexicographically blocking flow fit decreasing bin packing general list scheduling gls height priority schedule hps local optimality maxflip verification local optimality kernighan lin verification unweighted equal clauses sat flip sat unweighted maximum cut swap umcs unweighted satisfiability flip unweighted graph partitioning swap problem list stable configuration connectionist model lexicographically different majority labeling traveling salesman opt ts opt maximum satisfiability approximation msa minimum set cover approximation msca layer channel router column swap heuristic columns logic unit resolution unit horn unit resolution horn propositional horn clause satisfiability monadic krom satisfiability multivalued dependency relaxed consistent labeling rcl gen path systems path unification unif logical query program left linear semi unification mostowski epimorphism corporate takeover query incomplete table recovery itr formal languages context free grammar membership context free grammar empty context free grammar infinite context free grammar membership cfg mem forward deterministic growing contextsensitive grammar membership straight line program membership straight line program nonempty way dpda acceptance dpda labeled gap strong bisimilarity transition systems propagating set systems pss cellular tree automaton acceptance iterative tree array acceptance relation coarsest set partition iterated shuffle shuf algebra finite horizon markov decision process discounted markov decision process average cost markov decision process gaussian elimination partial pivoting problem list iterated mod im generalized word problem subgroup containment sc subgroup equality se subgroup finite index sfi group independence gi group rank gr group isomorphism si group induced isomorphism gii intersection cosets ic intersection subgroups group coset equality gce conjugate subgroups cs uniform word problem finitely algebras finitely algebras triviality finitely generated subalgebra fgs finitely algebras finiteness uniform word problem lattices lattice generators lg boolean recurrence equation bre fill slots fill multi list ranking mlr aperiodic monoid membership variety geometry plane sweep triangulation pst oriented weighted planar partitioning visibility layers vl point location convex hull successive convex hulls sch real analysis real analogue cvp fixed points contraction mappings inverting injective real function games player game game cat mouse cm acyclic geography game agg game life life zero sum bimatrix game person pebble game fixed rank pebble miscellaneous generic machine simulation problem general deadlock detection problem list dimensional cellular automata ca fluid invasion fluid eden growth lempel ziv data compression greedy alphabet reducing gar network simulation open problems graph theory bounded degree graph isomorphism edge ranking er edge weighted matching graph closure gc low degree subgraph lds maximal independent set hypergraph restricted lexicographically maximal independent set lexicographically maximal cycle free edge induced subgraph lf edge combinatorial optimization optimal variable integer linear programming opt ilp variable linear programming logic canonical labeling founded extensional relation left linear semi unification formal languages strong bisimilarity deterministic transition systems witness unambiguous finite automata algebra extended euclidean algorithm gaussian elimination partial pivoting finite fields integer greatest common divisor lu decomposition lud modular inversion modular powering relative subgroups geometry limited reflection ray tracing restricted plane sweep triangulation sweep oriented weighted planar partitioning problem list unit length visibility layers real analysis short vectors sv short vectors dimension sv polynomial root approximation pra univariate polynomial factorization cc comparator circuit value problem lexicographically maximal matching stable marriage sm stable marriage fixed pair stable marriage stable pair stable marriage minimum regret telephone connection tc rnc blocking flow layered network bf directed undirected depth search dfs edge coloring ec maximal path mp maximum disjoint paths mdp maximum flow maxflow maximum matching mm perfect matching existence pme subtree isomorphism sti index index contains entries authors concepts problems 
concept entries lower case problems capitalized 
problems indexed ways 
forms indicate problem defined part ii indexed full title problem number parentheses indexed acronym problem number parentheses 
third form indexed problem acronym gives pages problem reduction related information 
see example 
marking problems fp maxflow maximum flow maximum flow maxflow left linear semi unification oriented weighted planar partitioning dpda way dpda acceptance oriented weighted planar partitioning oriented weighted planar partitioning oriented weighted planar partitioning alternating breadth search abrahamson karl absolute performance ratio ac average cost markov decision process acyclic geography game agg adachi addresses authors xi afrati alternating graph accessibility problem agg acyclic geography game aggarwal aho alfred akl albert rgen algebra finitely algorithm inherently sequential complete allender eric alon noga alphabet greedy reducing indexing index indexing local search alternating breadth search alternating graph accessibility problem alternating logarithmic space alternating monotone cvp alternating monotone fanin fanout cvp am cvp alternating turing machine alternation am cvp alternating monotone fanin fanout cvp aperiodic monoid membership variety anderson richard ix aperiodic monoid membership variety aperiodic monoid approximation maximum satisfiability minimum set cover approximation scheme fully nc nc arc consistency arithmetic circuit value problem arithmetic circuit value problem arithmetic circuit aspace complete atallah mikhail atm automaton auxiliary pushdown cellular cellular tree trellis way pda average cost markov decision process babai szl zar jos luis ix barrington david mix ix basketball bounded degree graph isomorphism bds breadth depth search beame paul ix martin ben michael berger bonnie berlekamp bf blocking flow layered network big oh big omega bin packing bisimulation strong blelloch guy blocking flow layered network bf bondy giancarlo boolean circuit family boolean function boolean recurrence equation bre boppana ravi borodin allan index borodin simulation bounded degree graph isomorphism daniele joan bre boolean recurrence equation breadth depth search bds erik ix broder andrei broder algorithm brooks buss jonathan ca dimensional cellular automata cake long short semi callahan paul canonical labeling founded extensional relation carroll lewis cat mouse cm categories cc viii comparator circuit value problem cellular automata dimensional cellular tree automaton acceptance cem circuit evaluation monoids context free grammar empty cfg mem context free grammar membership context free grammar infinite context free grammar membership chandra ashok chang jik characteristic function chazelle bernard cheapest insertion bogdan chor benny circuit comparator depth family fanin fanout feasible size magnitude arithmetic function computation function computed gate input language accepted language recognized oracle output probabilistic size unbounded fanin circuit evaluation monoids cem circuit value problem cvp square clauses equals canonical labeling founded extensional relation cm cat mouse codings cole richard color index problem index coloring edge columns layer channel router column swap heuristic communication comparator circuit class comparator circuit value problem comparator circuit comparator gate compatible complete basis composite number compression computation problem condon anne ix conjugate subgroups cs connectionist model connectivity consens mariano context free grammar membership cfg mem context free grammar empty context free grammar infinite context free grammar membership conway john horton cook stephen ix cormen thomas corneil derek ix corporate takeover query corrections viii cosmadakis counting turing machine cover minimum set crescenzi cross circuits planar cs conjugate subgroups forward deterministic growing context sensitive grammar membership cellular tree automaton acceptance corporate takeover query felipe karel ii cvp circuit value problem dahlhaus elias dasgupta bhaskar de agostino sergio ix de la torre ix deadlock decidable parallel time sequential time decision tree algorithm definition complexity classes delcher arthur laws larry ix deng dependency embedded multivalued multivalued depth search tree anders det determinant dfs directed undirected depth search index dickinson bradley different majority labeling krzysztof dinic directed undirected depth search dfs discounted markov decision process divide conquer division dlog discounted markov decision process dobkin david dolev danny dominating set problem double minimum spanning tree double logic dspace dwork cynthia patrick ec edge coloring eden cluster eden growth edge coloring ec edge maximal acyclic subgraph edge ranking er edge ranking problem edge weighted matching eden growth elimination order ellis john ix edge maximal acyclic subgraph patrice circuit depth ones circuit true gates circuit depth ones circuit true gates equivalent languages er edge ranking error probability eventually nondecreasing edge weighted matching existential exponentiation extended euclidean algorithm extended euclidean algorithm fanin unbounded fanout farthest insertion feasible highly parallel feasible connectivity feather feder tom feedback arc set problem feedback vertex set fellows michael fit decreasing bin packing fgs finitely generated subalgebra finite horizon markov decision process faith fiduccia fill fill slots index fill slots fill finite horizon markov decision process finitely generated subalgebra fgs finitely algebras finiteness finitely algebras triviality finkel alain fit decreasing bin packing complete problem fischer michael fixed points contraction mappings flip verification problem flow blocking feasible homologous lexicographically blocking maximum commodity unary maximum fluid fluid invasion fluid invasion fluid fnc ford fortune steven forward deterministic growing context sensitive grammar membership fp fp complete arithmetic circuit value problem cellular tree automaton acceptance fixed points contraction mappings inverting injective real function iterative tree array acceptance linear programming real analogue cvp stable configuration connectionist model traveling salesman opt layer channel router column swap heuristic unweighted graph partitioning swap unweighted maximum cut swap unweighted satisfiability flip unweighted equal clauses sat flip finitely algebras finiteness finitely algebras triviality fixed points contraction mappings fulkerson function growth rate polylogarithmic bounded polynomially bounded function nc function function complete function rnc furst galil zvi game life life game player game game zero sum gap gar greedy alphabet reducing index garey michael gaussian elimination partial pivoting finite fields gaussian elimination partial pivoting gaussian elimination hillel gc graph closure gce group coset equality general deadlock detection gds greedy dominating set gen gen general closure general deadlock detection general graph closure problem general graph closure general list scheduling gls generalized word problem generating random matchings grm generic machine simulation problem geometry gaussian elimination partial pivoting gaussian elimination partial pivoting finite fields ger ly general graph closure gi group independence gibbons alan gibbons phillip gii group induced isomorphism gun gls general list scheduling generic machine simulation problem gail goldberg andrew goldberg goldreich oded goldschlager leslie goldsmith judy goodrich glen goodrich michael gr group rank graham ronald grammar context free context sensitive forward deterministic graph alternating closure cyclically reducible expansion general closure hereditary property hierarchical induced subgraph isomorphic nontrivial property outerplanar partitioning property tree structured graph accessibility directed undirected graph closure gc index graph coloring problem graph solvability greatest common divisor greedy alphabet reducing gar greedy dominating set gds greedy method greenberg albert greenlaw raymond dina yu grm generating random matchings group cosets left cosets normal subgroup right cosets word problem group coset equality gce group independence gi group induced isomorphism gii group isomorphism si group rank gr gupta arvind ix guy richard generalized word problem astad johan hagerup torben hajnal ter halting problem hamming distance makoto harrison michael hartmanis hcs high connectivity subgraph hds high degree subgraph xin height priority schedule hps helmbold david henglein fritz hereditary hereditary graph property hershberger john ix hf homologous flow hierarchical graph accessibility problem hierarchical graph accessibility problem high connectivity subgraph hcs high degree subgraph hds hints problem proofs history homologous flow hf hong jia wei hoover james hopcroft john horn horn clause implication problem literal literal unique matching horn formula horn horn unit resolution horn unit resolution horn horowitz ellis howard hps height priority schedule huynh dung index hypergraphs ibarra oscar ic intersection cosets inverting injective real function im iterated mod immerman neil incomplete table recovery itr independence oracle independence system independent set maximal maximum inference system inherently sequential inherently sequential algorithm institute new generation computer technology icot integer greatest common divisor integer greatest common divisor intersection cosets ic intersection subgroups interval order inverting injective real function inverting nc permutation perm perm inverting nc permutation intersection subgroups isomorphism graph subtree tree iterative tree array acceptance itai alon iterated mod im iterated mod polynomial iterated product iterated shuffle shuf iterative tree array acceptance itr incomplete table recovery iwata joseph jerrum mark jiang tao johnson david johnson donald jones neil erich kanellakis paris kannan ravi kantor kao ming yang mauricio karloff howard karmarkar karp richard karpinski marek kasami kasif simon dimitris index pierre kernighan brian kernighan lin verification khuller samir kim sam tracy gerard kirkpatrick david maria klein philip knapsack knuth donald ko ker kosaraju rao kozen dexter mark krom formula kruskal clyde kuper william labeled gap labeling different majority general consistent ladner richard lagarias language dpda cellular tree automaton context free context sensitive iterated shuffle iterative tree array linear iterative array recognition semi dyck shuffle trellis automaton latch lattice aperiodic monoids variety generator problem free identity problem lattice generators lg lawler eugene lds low degree subgraph le linear equalities lee richard left linear semi unification leighton thomson leiserson charles lempel ziv data compression lengauer thomas lenstra lenstra jr lenstra jan level function level circuit lewis harry lewis philip ii lexicographically maximal independent set ordered lexicographically vertex coloring blocking flow depth search ordering different majority labeling maximal cycle free edge induced subgraph maximal acyclic subgraph problem index maximal clique maximal independent set maximal matching maximal path maximal subgraph maximal cycle free edge induced subgraph lf edge lf edge lexicographically maximal cycle free edge induced subgraph lexicographically blocking flow lexicographically depth search ordering lexicographically different majority labeling lexicographically vertex coloring lexicographically maximal cycle free edge induced subgraph lexicographically maximal clique lexicographically maximal independent set lexicographically maximal matching lexicographically maximal path lexicographically maximal subgraph problem witness unambiguous finite automata lg lattice generators labeled gap li linear inequalities li life game life limited reflection ray tracing lin lin lin yu lindell steven lindgren kristian linear equalities le linear inequalities li linear iterative array linear programming lp linear programming lingas andrzej john lipton richard list scheduling problem little oh little omega lloyd left linear semi unification local optimality kernighan lin verification local search problem logarithmic space reduction uniformity logcfl logic program logical query program index local optimality kernighan lin verification long philip luc lov sz szl low degree subgraph lds lower bound lp linear programming logical query program limited reflection ray tracing lu decomposition lud boris luby michael lud lu decomposition lueker george luks eugene lempel ziv data compression jonathan maheshwari anil maheshwari mak louis makespan problem andrew reduction markov process matching bipartite edge weighted lexicographically maximal bipartite maximal maximum maximum edge weighted maximum vertex weighted perfect perfect bipartite matroids mattheyses max maxflip verification maxflip verification maxflow maximum flow maximal maximal independent set hypergraph maximal independent set maximal path mp maximal vertex disjoint paths paths maximum acyclic subgraph problem maximum disjoint paths mdp maximum flow bit pattern threshold value maximum flow maxflow maximum independent set maximum matching mm maximum satisfiability approximation msa mayr ernst mcaloon mccoll william mckenzie pierre index monotone circuit value problem mdp maximum disjoint paths megiddo nimrod mehlhorn kurt mendelzon alberto meyer albert minimum feedback vertex set miller gary min plus circuit value problem minimum feedback vertex set minimum set cover approximation msca minimum vertex cover problem minimum weight feedback arc set feedback vertex set min plus circuit value problem minsky marvin maximal independent set hypergraph mitchell john miyano satoru monadic krom satisfiability mlr multi list ranking mm maximum matching models parallel modular inversion modular powering modular inversion modular powering monadic krom satisfiability monoid finite monotone monotone circuit value problem monti angelo moran shlomo mostowski epimorphism mostowski epimorphism mp maximal path msa maximum satisfiability approximation msca minimum set cover approximation mulmuley multi list ranking mlr multigraphs multivalued dependency murty multivalued dependency nakanishi nand circuit value problem nand circuit value problem naor joseph nc vii random algorithm reducible turing reducible nc nc nc index nc turing reducible nearest addition insertion merger nearest neighbor traveling salesman heuristic nearest neighbor tour neighborhood removal nr network simulation network simulation neural network newton method nick class nc nielsen reduction algorithm nlog nearest neighbor traveling salesman heuristic nondeterministic logarithmic space nonuniform mats notation np np completeness nr neighborhood removal number number problem observation congruence equivalence yu 
ogden william oh big little soft ordered high degree vertex removal ordered low degree vertex removal dimensional cellular automata ca left linear semi unification open problems garey johnson opt ilp optimal variable integer linear programming optimal variable integer linear programming opt ilp oracle circuit gate pram order ordered greedy clique ordered high degree vertex removal ordered low degree subgraph membership problem ordered low degree vertex removal ordered remaining clique ordered vertices remaining ordered vertices remaining vii index reducible turing reducible complete nc reducibility algorithm strong sense nc complete hard circuit depth ones circuit true gates arithmetic circuit value problem function inverting nc permutation language search problem stable configuration connectionist model nc reducibility uniformity pan victor papadimitriou christos parallel computation thesis parallel random access machine pram parallel speedup ian partition partitioning graph plane patashnik oren paterson michael path path systems path lexicographically maximal maximal maximum disjoint path systems path paths maximal vertex disjoint paths paul wolfgang planar circuit value problem pebble person pebble game fixed rank game person person pierre percolation perfect matching existence pme perfect matching performance ratio permanent perry peterson gary ph propositional horn clause satisfiability point location convex hull pippenger nicholas pivoting complete partial plaisted david planar planar circuit value problem planar directed depth search plane sweep triangulation pst pls pls complete pme perfect matching existence index point location convex hull george polylogarithmic polynomial local search number space speedup time hierarchy polynomial root approximation pra post emil powering pra polynomial root approximation pram addressing modes arbitrary common crcw crew crow erew fortune wyllie function computation input output conventions instructions oracle priority processors resource bounds time pratt vaughan probabilistic circuit problem decision function local search number search projections propagating set systems pss propositional horn clause satisfiability teresa pseudo nc algorithm pspace pss propagating set systems pst plane sweep triangulation quasi complete rackoff charles rajasekaran ram algorithm flow function ramachandran vijaya random access machine random nc rank oracle restricted chromatic alternating graph accessibility problem reliable connectivity failures incoming edges rcl relaxed consistent labeling relation coarsest set partition real analogue cvp real analysis real function feasible nc real analogue cvp recurrence equation reduction honest logarithmic space index notation quasilinear time resource bounded self transitive turing nc nc turing nc turing turing reif john reiss steven related works relation coarsest set partition relation founded relative relaxed consistent labeling rcl reliable connectivity failures incoming edges relative restricted chromatic alternating graph accessibility problem restricted lexicographically maximal independent set restricted plane sweep triangulation sweep reversal reversal bounded riddle rivest ronald restricted lexicographically maximal independent set rnc viii robinson alessandro louis rounds routing layer channel rudolph larry ruzzo walter rytter wojciech sac sahni sam cvp synchronous alternating monotone fanout cvp sang cho sanz jorge satisfiability problem saturated edge savage john savitch walter savitch theorem strong bisimilarity deterministic transition systems stack breadth search strong bisimilarity transition systems sc subgroup containment sc stable configuration connectionist model index sch successive convex hulls sch alejandro ix schedule best fit decreasing greedy height priority list precedence constrained processor weight priority scheduling schevon catherine schieber schwartz stuart se subgroup equality search alternating breadth binary breadth depth depth depth planar directed lexicographic breadth polynomially local pls problem rational binary stack breadth seki semi group ordered ordered semi unbounded circuits sequential time serna maria set cover set system sethi ravi sfi subgroup finite index david shared memory sharp shaw ralph shmoys david shor peter short vectors dimension sv short vectors sv shuf iterated shuffle shuffle si group isomorphism signature simons roger simulated annealing simulation borodin sinclair alistair sinclair algorithm singer michael size sven straight line program membership straight line program nonempty sm stable marriage stable marriage fixed pair smith ray iii smith justin stable marriage minimum regret smolka scott smooth stable marriage stable pair snir marc snoeyink jack soffa mary lou soft oh sorenson jonathan danny index sort rank sp space hierarchy theorem speedup speedup equation spencer thomas spirakis paul square circuit sridhar stable configuration connectionist model stable marriage sm fixed pair minimum regret stable pair stable problem stack breadth search standard encoding staples john stearns richard stein clifford steve class sc stewart iain sti subtree isomorphism michael stockmeyer larry storer james straight line program straight line program membership nonempty howard strict completeness strict complete strong bisimilarity deterministic transition systems transition systems strong np complete strong complete subgroup containment sc subgroup equality se subgroup finite index sfi subramanian ashok substitution subtree isomorphism sti successive convex hulls sch ivan hal sunder sv short vectors sv short vectors dimension sweep restricted plane sweep triangulation subgroups subgroups symmetric logarithmic space synchronous synchronous alternating monotone fanout cvp sam cvp szemer di endre tomasz tamassia roberto tardos eva tarjan robert tc telephone connection index telephone connection tc teng shang hua term matching stuart th denis time constructible tiwari tompa martin ix topologically ordered circuit value problem topological ordering topologically ordered circuit value problem transition system transitive closure traveling salesman opt ts opt traveling salesman heuristics tree isomorphism problem triangulation arbitrary minimum length plane sweep ts opt traveling salesman opt tsitsiklis john turing machine alternating counting random access turing reducible variable linear programming layer channel router column swap heuristic columns player game game variable linear programming person pebble game fixed rank pebble way deterministic pushdown automaton way dpda acceptance dpda tygar unweighted satisfiability flip unweighted graph partitioning swap ullman jeffrey unit length visibility layers umcs unweighted maximum cut swap sat unweighted equal clauses sat flip unary encodings unbounded fanin unif unification unification left linear semi monadic semi restricted term matching unrestricted unification unif uniform word problem finitely algebras uniform word problem lattices uniformity ue borodin cook logarithmic space unit index unit length visibility layers unit resolution unit unit unit resolution univariate polynomial factorization unweighted graph partitioning swap unweighted maximum cut swap umcs unweighted equal clauses sat flip sat unweighted satisfiability flip updates ix upfal eli univariate polynomial factorization upper envelope uniform word problem finitely algebras uniform word problem lattices valiant leslie van emde boas peter van gelder allen van leeuwen jan vavasis stephen vazirani umesh vazirani vijay venkatesan shankar verbeek vishkin vishwanathan visibility layers vl visibility layering process vitter jeffrey scott vl visibility layers von hl von zur gathen joachim wagner klaus wah wang ching chy wang li chung warmuth manfred wein joel wigderson avi robert wilson chris witness unambiguous finite automata wloka markus woods world wide web ix wyllie james yannakakis yesha yoshida zero sum bimatrix game thomas zhang zhang zero sum bimatrix game 
