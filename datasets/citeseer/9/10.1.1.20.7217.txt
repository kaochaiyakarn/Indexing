centrum voor wiskunde en informatica logic programming negation survey apt bol computer science department software technology cs logic programming negation survey krzysztof apt cwi box gb amsterdam netherlands faculty mathematics computer science university amsterdam tv amsterdam netherlands roland bol department mathematics computer science eindhoven university technology box mb eindhoven netherlands survey various approaches proposed incorporate negation logic programs 
concentrate proof theoretic model theoretic issues relationships 
mathematics subject classification 
cr categories 
keywords phrases negation general logic programs non monotonic reasoning 
notes 
author partly supported esprit basic research action 
second author partly supported netherlands organization scientific research nwo 
appear journal logic programming 
motivation non monotonic reasoning grew attempts capture essential aspects commonsense reasoning 
resulted number important formalisms known circumscription method mccarthy default theory reiter autoepistemic logic moore 
systematic comparison approaches see published marek truszczy nski 
striking features logic programming naturally support nonmonotonic reasoning means negative literals 
concepts introduced area non monotonic reasoning natural counterpart logic programming spite limited syntax 
dual interpretation logic programs computational mechanism formalism knowledge representation provided fertile ground study proof theory semantics programs support non monotonic reasoning 
attempts survey outcome research 
subject fragments discussed previous survey articles shepherdson shepherdson przymusinska przymusinski bidoit clark 
writing learned survey dix focuses nonmonotonic reasoning aspects logic programming 
field fast growing half cited published years survey justified 
provide alternative overview area concentrating main developments proof theory model theory relationships 
unified picture emerges 
number interesting proposals dealing proof theory semantics 
relationship revealed intricate mathematical arguments brings light complex nature logic programming non monotonic reasoning logic programming setting 
setting stage sld resolution kowalski allows derive positive consequences conjunctions atoms positive program 
circumstances useful derive negative consequences 
shall see subsection naturally leads non monotonic reasoning 
classic example usefulness negative consequences timetable states connections explicitly absence connections implicitly 
case positive programs approaches derive negative information known 
treated extensively case general programs called normal programs lloyd 

negation finite failure rule clark states consequence program finitely failed sld tree query exists short finitely fails 
program completion clark strengthens program informally interpreting implications equivalences 
closed world assumption short cwa reiter states ground atom consequence program proved relationships concepts positive programs understood see lloyd apt overview results 
negative consequences derived positive program natural extend syntax programs allow negative assumptions 
leads class general programs negative literals allowed bodies clauses 
trying extend approaches case general programs complications arise 
approaches self referential potentially paradoxical 
shall see naive amalgamation sld resolution negation finite failure rule yields unsound reasoning method completion general program inconsistent closed world assumption yield inconsistent theory 
treat subject carefully review concepts relies 
start discussing relevant aspects non monotonic reasoning 
non monotonic inference relations properties non monotonic inference relations extensively studied example kraus lehmann magidor 
overview topic see makinson 
dix defined proof model theoretic semantics logic programs viewed inference relation consequence relation 
particular semantics sem defined inference relation sem program relation sets ground atoms sets ground literals fa sem fl lm sem fa lm way classifying semantics logic programming studying properties satisfy property satisfied sem satisfied sem programs sem defined 
eventually agrees properties desirable ones study reasons considering semantics better example computability 
strong property inference relations monotonicity symbol denote arbitrary inference relation gamma set atoms atom literal 
definition monotonicity inference relation monotonic satisfies gamma implies gamma gamma classical logic monotonic inference relation determined subset classical logic 
negation finite failure rule program completion closed world assumption introduce non monotonicity deriving negative literals positive programs fp qg fqg fp qg consequently semantics logic programs negation considered non monotonic 
study non monotonic logics large area impossible give complete overview 
limit observations relevant logic programming 
may wonder inference relation logical monotonic 
kraus lehmann magidor considered properties desirable omit number simple properties satisfied logic programming semantics 
cut gamma gamma fag imply gamma cautious monotonicity gamma gamma imply gamma fag rationality gamma gamma imply gamma fag cautious monotonicity weaker rationality presence simple properties 
logic satisfies cautious monotonicity cut called cumulative 
shall properties sections 
dix calls properties strong principles opposed certain weak principles identifies weak principles specific logic programs satisfied reasonable semantics 
examples weak principles principle partial evaluation roughly means positive body literal replaced disjunctions ground atoms case disjunctive logic programs see section 
sem return single model set models theory 
case set models sceptical approach chosen sem true models sem 
definition relevance means truth value atom determined solely part program atom depends notion precise definition 
number reasons adopting non monotonic semantics negation 
ffl historically classical interpretation negation ruled result full order theorem proving high complexity 
argument hardly valid semantics logic programs negation studied highly undecidable various degrees order case see apt blair cadoli schaerf overview computed polynomial time propositional case see van gelder ross schlipf 
ffl situations example databases natural record positive information leaving negative information implicit 
ffl researchers artificial intelligence recognised commonsense reasoning non monotonic 
non monotonic logics logics non monotonic inference relation popular 
logic programs non monotonic negation constitute small quite expressive class non monotonic logics particular interest implementable 
observed motivating examples papers semantics negation logic programming taken commonsense reasoning 
distinguish reasons static respectively dynamic non monotonicity 
non monotonicity statically available information complete theoretically practically captured classical logic consequences theory 
standard example case mentioned timetable problem possible practical list existing connections absent connections 
form non monotonicity justifies directly closed world assumption introduced section 
non monotonicity dynamically jumping available information incomplete 
information available may turn longer justified withdrawn 
standard example case learn tweety bird jump fly subsequently find tweety penguin withdraw 
logic called belief revision clearly non monotonic 
example apparently default assumption birds fly evidence contrary 
reiter proposed default logic framework formalizing defaults 
example reasons beliefs agent moore proposed auto epistemic logic 
fact semantics negation logic programming closely related proposals 
way negation logic programming belief revision means abnormality relations 
example penguin tweety described addition fact penguin tweety program tweety bird tweety tweety bird 
fly bird abnormal fly bird normal birds fly 
abnormal fly bird penguin penguins abnormal birds flying return program section semantics mentioned coincide program derive fly tweety tweety tweety tweety plan organized follows 
section introduce syntax discuss choice underlying order language 
section introduce basic resolution procedure general programs sldnf resolution 
section discuss classical concept program completion discuss soundness completeness sldnf resolution program completion 
section return discussing variants extensions 
section study semantics general programs concentrating valued candidates natural model proposed literature 
section consider valued options 
section relate special models various modifications program completion 
section return study proof theoretic issues analyze form resolution called sls resolution 
particular discuss soundness completeness sls resolution semantics considered section issue implementation 
section discuss disjunctive logic programs programs built clauses heads disjunctions atoms relate various approaches semantics case general programs 
section summarize results indicating classes programs considered approaches coincide 
indicate topics treated 
preliminaries syntax recall usual definitions 
literal atom negation 
positive literal synonym atom negative literal negated atom 
literals denoted letters general query finite conjunction literals 
general queries usually considers general goals expressions query 
empty general query denoted 
adhere syntax logic programming write general query general clause construct form atom query called head body body empty general clause called unit clause 
general program finite set general clauses 
say relation defined occurs head general clause uses relation occurs body general clause shall deal exclusively general queries clauses programs omit qualification general confusion arises 
literals bodies program clauses positive call program positive 
case queries bold letters denote finite sequence syntactic objects 
sequences terms length abbreviate recall number auxiliary notions 
definition expression mean term atom literal query negation query clause 
var set variables occurring expression denotes universal closure existential closure substitution function variables terms finite domain 
domain denoted dom set variables occurring terms forming range ran restriction set variables expression abbreviate var write result applying substitution expression called renaming substitution substitution ffl denotes identity substitution 
application substitution set expression relation general substitutions defined usual way 
atoms substitution called unifier called general unifier short mgu unifier general unifiers mgu atoms called relevant dom ran ar ar 
studying programs relationship relations importance 
definition dependency consider program ffl dependency graph directed graph signed edges 
nodes relations occurring clause uses relation head relation positive resp 
negative literal body positive resp 
negative edge say uses positively resp 
negatively 
ffl say depends positively resp 
negatively path positive edges resp 
negative edge 
ffl say depends evenly resp 
oddly path resp 
odd number negative edges 
universal query problem simple completeness result sld resolution reads follows positive program atom substitution 
sld aoe substitution oe aoe general 
shall classical logic semantics general logic programs reasons explained section 
cases semantics program logical theory program completion 
cases semantics program canonical herbrand model herbrand model positive program relative merits approaches discussed wallace 
canonical model approach restricting ones attention herbrand models leads considerable technical simplifications 
statement false positive program atom substitution 
sld aoe substitution oe aoe general 
counterexample take fp ffl 
term herbrand universe fp 
essentially ways avoid problem 

ensure language consideration sufficiently terms 
done ffl adding clause program occur ross 
ffl postulating kunen infinite universal language programs queries expressed 

consider arbitrary models herbrand models 
approach taken kunen przymusinski termed problem universal query problem 
adopt universal language approach gives rise simpler formulations results approaches 
solves problem deal formally language elements occur query program 
approach merits drawbacks 
example case approach adopted program fp holds herbrand model universal language hold models opposite universal query problem program fp true 
leave problem aside detailed discussion issue refer shepherdson 
sequel denotes herbrand base herbrand model positive program ground set ground instances clauses considered universal language 
denote language defined program language constants function relation symbols occurring proof theory sldnf resolution discussion order compute general programs needs able resolve negative literals 
natural idea closed world assumption stipulate atom succeeds iff proved 
problem rule general undecidable atom proved restrict attention positive programs 
section shall consider ineffective form resolution formalizes idea 
rule effective clark proposed replace statement proved finitary version negation finite failure rule rule decidable 
clark statement proved interpreted finitely fails 
general programs considered trees query contain negative literals question arises literals fail 
natural idea stipulate atom fails iff proved 
interpreting statement proved exists successful derivation query resolution method called sldnf resolution appropriate general programs general queries 
mentioned interpretation statement possible leads form resolution 
shall consider section 
sldnf resolution selected literal positive usual sld procedure obtain new resolvent selected literal say negative rule obtain new resolvent succeeds iff finitely fails finitely fails iff succeeds 
succeeds deleted query finitely fails query fails 
case sld resolution notion resolution prove compute 
introduce notation 
sldnf exists successful sldnf derivation fqg computed answer sldnf exists finitely failed sldnf tree fqg 
restrictions notion sldnf resolution problematic concept 
take program numbers zero zero query zero succeeds zero finitely fails consequently positive finitely fails 
numbers sldnf positive 
ground term different zero finitely fails positive succeeds 
numbers sldnf positive 
excludes soundness results 
fact drawn prolog systems 
prolog sound 
problem caused variables nonground negative literals 
ensure soundness clark imposed restriction ground negative literals selected 
definition sldnf resolution sketched difficult formalize 
consider example program fp pg 
query succeeds finitely fails query succeeds finitely fails 
clear resolvent 
shows sldnf resolution incomplete sldnf sldnf holds 
problem success finite failure possible outcomes evaluation unsuccessful tree finitely failed generated 
problem properly taken care definition sldnf resolution clark reproduced lloyd 
lloyd revised definition sldnf resolution proposed sldnf trees constructed bottom induction number alternations negation 
unfortunately definition mentioned example problematic cases sldnf trees exist 
clearly undesirable especially reasons run time properties sldnf resolution termination 
problems tackled martelli proposed revision original definition subsidiary trees resolve negative literals built inside main tree 
solution due apt doets 
new definition definition resolvent say resolves ff sigma explicitly pair ff resolvent sigma notation ff sigma sigma occurrence positive literal program clause variant input clause ff mgu qff lff lff obtained qff replacing lff lff sigma occurrence negative literal ff ffl gamma sigmag obtained removing sigma 
ii clause called applicable atom variant head unifies atom 
definition pseudo derivation finite infinite sequence ff delta delta delta ff delta delta delta resolution steps pseudo derivation step involving program clause ffl standardisation apart input clause employed contain variable initial query input clause earlier step ffl relevance mgu employed relevant 
intuitively sldnf derivation pseudo derivation deletion ground negative literal justified means subsidiary finitely failed sldnf tree 
brings consider special types trees 
definition tree called ffl successful contains leaf marked success ffl finitely failed finite leaves marked failed 
sequel consider systems trees called forests 
definition forest forest system subs ffl set trees ffl element called main tree ffl subs function assigning nodes trees subsidiary tree path mean sequence nodes child tree root tree subs 
forest special directed graph types edges usual ones stemming tree structures ones connecting node root subsidiary tree 
sldnf tree special type forest built limit certain finite forests trees 
nodes trees labeled queries 
shall identify node label 
construction begins main tree consists just node original query 
construction new subsidiary trees added 
round branches trees extended parallel 
final object sldnf tree 
original definition clark subsidiary trees kept aside main tree 
difference construction longer viewed atomic step resolution process 
subsidiary tree successful finitely failed information round extension process determine status query originated construction rest section fix program definition crucial 
definition pre sldnf tree pre sldnf tree relative forest nodes possibly marked queries possibly marked literals 
queries markers failed success floundered literals marker selected 
function subs assigns nodes containing marked negative ground literal tree root class pre sldnf trees defined inductively 
ffl query forest consisting main tree single node pre sldnf tree initial pre sldnf tree ffl pre sldnf tree extension pre sldnf tree 
extension pre sldnf tree defined performing actions non empty query unmarked leaf tree literal marked selected mark selected 
selected literal ffl positive 
resolvents clause marked failed resolvents 
clause applicable choose resolvent ff add child resolvents chosen way branches remain pseudo derivations 
ffl negative 
nonground 
marked floundered ground 
subs undefined 
new tree single node added subs set subs defined successful 
marked failed subs defined finitely failed 
resolvent ffl gamma flg added child additionally empty queries marked success 
note tree unmarked leaves trivially extension extension process stationary 
pre sldnf tree tree types edges possibly marked nodes concepts inclusion trees limit growing sequence trees clear meaning 
definition sldnf tree ffl sldnf tree limit sequence initial tree extension ffl sldnf tree sldnf tree root main tree 
ffl pre sldnf tree called successful resp 
finitely failed main tree successful resp 
finitely failed 
ffl sldnf tree called finite infinite paths exist 
define concept sldnf derivation 
definition sldnf derivation pre sldnf derivation branch main tree pre sldnf tree set trees roots reached nodes branch 
called successful ends empty query 
sldnf derivation called finite paths fully contained branch trees finite 
define notion computed answer substitution 
definition computed answer substitution consider branch main tree pre sldnf tree ends empty query 
ff ff consecutive substitutions branch 
restriction ff delta delta delta ff jc composition ff delta delta delta ff variables called computed answer substitution short illustrate definitions depicting sldnf trees difficult cases 
example infinite sldnf trees consider problematic case fp pg mentioned section 
sldnf tree form delta delta delta fflffl fflffl ii important realize definition construction subsidiary tree go forever information status passed main tree 
program illustrates point 
consider fp qg 
sldnf tree looks follows failed success success delta delta delta fflffl subsidiary tree root grows forever 
extension initial subsidiary tree single node successful extension node marked failed 
consequently sldnf tree finitely failed finite 
note simple result 
theorem limit sldnf tree limit unique sequence pre sldnf trees 
ii sldnf tree limit sequence successful yields iff successful yields finitely failed iff finitely failed 
result allows associate successful finitely failed sldnf tree natural number rank corresponding equivalence ii holds ffl finitely failed 
measure useful carrying inductive proofs sldnf resolution 
mention straightforward show successful finitely failed sldnf tree exists definition lloyd definition 
floundering discussion useful introduce notion 
sldnf tree selection rule sequence pre sldnf trees limit markings literals selected performed selection rule function pre sldnf tree selects literal non empty unmarked leaf tree selection rule called safe selects nonground negative literal 
complications concerning sldnf resolution called floundering generation node consists exclusively nonground negative literals selection literal ends derivation abnormal way 
definition provided floundering treated differently arises soon nonground negative literal selected 
clearly small change effect theory sldnf resolution original notion floundering easily defined 
definition floundering ffl call query blocked consists exclusively nonground negative literals 
ffl say flounder sldnf tree contains blocked node 
note difference blocked node node marked floundered 
sldnf tree safe selection rule flounder 
borger see apt direct proof proved undecidable flounder 
literature number syntactic conditions proposed ensure program query flounder 
notion due lloyd topor see lloyd best known 
definition ffl query called allowed variable occurs positive literal 
ffl clause called allowed ffl program called allowed clauses 
new definition result lloyd topor refers larger class sldnf trees 
theorem suppose allowed 
ffl flounder 
ffl ground 
ground say ground computed answer substitution 
definition proposed lloyd topor slightly general considered 
stronger version excludes natural logic programs allowed unit clause ground computed answer grounding 
decker cavedon decker proposed general syntactic conditions prevent floundering 
kunen definition kunen provided simpler definition computed answer substitutions finitely failed queries sldnf resolution prove completeness sense discussed section allowed programs allowed queries 
definition compare 
definition set queries set pairs oe query oe substitution dom oe ar defined simultaneous inductive definition follows 
rffl resolves ff positive literal clause cr jc ground atom roe roe positive literal clause applicable exist ff ff ground atom recall query stands restriction substitution variables intention set pairs oe oe set queries finitely failed tree note formulation ensure resulting answer substitutions general 
consider program 
rffl rfy xg second clause consequently rfy xg resolves ffl clause 
fy xg fy order produces general answer substitutions amend follows yr resolves ff positive literal clause ar cff ar doe ar cr jc 
theorem apt doets shows equivalence kunen definition modified 
theorem equivalence query ffl cr iff ffl iff finitely failed sldnf tree 
termination natural ask definition sldnf resolution section 
show usefulness consider issue termination handled kunen approach 
definition terminating program program called terminating ground queries finite 
course general interested proving termination program ground queries class nonground queries constituting intended queries 
approach prove termination discussed allows identify program class nonground queries 
characterize terminating programs cavedon apt bezem introduce notions 
definition acyclic program ffl level mapping program function ground atoms natural numbers 
jaj level ffl level mapping extend ground negative literals putting aj jaj 
ffl clause called acyclic respect level mapping ground instance jaj jlj ffl program called acyclic respect level mapping clauses 
called acyclic acyclic respect level mapping 
definition boundedness ffl literal called bounded respect level mapping bounded set ground instances bounded define jlj level maximum takes 
ffl query called bounded respect level mapping literals 
bounded define jqj level multiset bag jl jl 
result explains bounded queries relevant 
lemma finiteness acyclic program bounded query 
sldnf tree finite 
leads 
corollary acyclic program terminating 
subject done ross termination programs sldnf resolution leftmost selection rule prolog apt pedreschi 
return acyclic programs section 
program completion definition order logic soundness completeness results equate notions semantic proof theoretic implication set formulas foeg oe iff oe similar result established sldnf resolution programs 
sldnf resolution prove ground negative literals false largest herbrand model program clark proposed solve problem strengthening program completion comp compare sldnf resolution comp 
intuitively completion implications replaced equivalences 
formal definition bit subtle replacement right moment equality relation interpreted appropriate way 
recall definition 
assume new binary relation symbol appearing write abbreviation 
interpreted identity models 
perform successively steps new variables 
step transform clause step transform formula obtained previous step yf variables original clause 
step yf yf formulas obtained previous step relation left hand side 
replace formula empty replace true 
step relation symbol appearing head clause add formula false step replace formula step formula replace 
additionally add free equality axioms eq enforce equality theory comp herbrand universe function symbol function symbols variable term occurs call resulting set formulas comp 
additionally interpret valued valued interpretations identity 
allows dispose usual equality axioms 
valued model theory program completion natural concept case positive programs case general programs things dramatically change due disturbing observation 
note fp pg comp inconsistent 
inconsistent program completion allows derive arbitrary order formulas program note rule program completion model negative information 
discuss ways resolving difficulty useful recall immediate consequence operator van emden kowalski acts herbrand interpretations program 
operator plays important role theory positive programs 
definition immediate consequence operator program herbrand interpretation define fh ground simple observation originally positive programs van emden kowalski explains interest operator characterizing herbrand models terms operator lemma herbrand interpretation iff bit complicated argument originally positive programs apt van emden characterizes herbrand models comp terms operator lemma fixpoint herbrand interpretation comp iff positive programs exhibits regular behaviour set inclusion monotonic implies continuous infinite sequence 
property herbrand model fixpoint second property model reached iterations starting empty herbrand interpretation 
general programs properties lost 
consider fp pg 
fpg fpg monotonic fortiori continous 
consequently general programs known knaster tarski theorem find fixpoint fact fixpoints need exist just take fp pg 
natural question conditions completion consistent 
result established sato 
definition call consistent program called call consistent relation depends oddly 
theorem call consistent comp herbrand model 
subject consistency comp kunen cavedon fil fil fages 
alternative solution valued logic 
valued model theory fitting proposed valued logic provide semantics programs completions 
idea query yield outcomes may succeed may fail may diverge 
third value meant capture possibility 
fitting approach logic due kleene values assumed representing false representing unknown representing true 
assume mapping 
define meaning programs put ground quantifier free formulas aj gamma jaj ja bj min jaj jbj ja bj jaj jbj jaj jbj identify program set ground 
note received valued interpretation 
fitting valuation 
interpretation differs kleene added przymusinski 
moment meaning connectives needed 
ground formula evaluates say true relative evaluates say false relative mapping conveniently form valued herbrand interpretation 
definition pair gamma gamma called valued herbrand interpretation 
atoms assumed true gamma atoms assumed false 
example fag fbg true false undefined definition ffl total gamma ffl consistent gamma 
note valued herbrand interpretation identified valued total consistent herbrand interpretation gamma sense truth falsity coincides interpretations formulas 
natural ordering valued herbrand interpretations iff gamma gamma formalizes intuition contains information determines status literals 
ordering usually called information ordering 
natural orderings considered see section 
note truth falsity behave monotonically information ordering sense 
lemma ground query true false implies true false implications hold valued herbrand interpretations interpreted set theoretical inclusion 
contrast valued herbrand interpretations consistent valued herbrand interpretations ordering form lattice 
total exist 
consistent valued herbrand interpretations form cpo partial ordering limits growing chains exist 
sufficient building valued models inductively 
fitting introduce valued analogue operator originally denoted phi acts valued herbrand interpretations program 
definition immediate consequence operator program valued herbrand interpretation define fh ground true fh ground implies false lemma summarizes relevant properties operator 
lemma ffl consistent consistent ffl monotonic ffl general continuous 
return program completion 
define meaning valued logic need assign meaning disjunction equivalence quantifiers 
follows ja bj max jaj jbj ja bj jaj jbj jaj jbj receives valued interpretation 
quantifiers interpreted standard way 
definition allows determine order formula oe true arbitrary valued interpretation written oe 
analogy valued semantics relation state formula true valued models theory comp 
fixpoint lemma counterpart valued case 
lemma fixpoint herbrand interpretation comp iff consequently lemma generalization knaster tarski theorem cpo get corollary fixpoint consistent valued model comp 
example program fp pg get valued model ground atom undefined consequently true 
valued logic approach offers solution problem possible inconsistency completion valued logic 
natural question programs valued valued semantics comp coincide 
answer provided kunen 
definition strictness consider program query say strict relation occurring depends evenly oddly relation defined program 
theorem equivalence suppose call consistent strict comp iff comp shown dix valued completion semantics satisfy cautious monotonicity valued completion semantics rational 
statement consider program fq rg 
comp fp rg comp fpg th fp rg fq rg 
discussion program completion refer reader section 
soundness completeness results relate sldnf resolution program completion 
clark proved soundness sldnf resolution valued semantics program completion 
fact see shepherdson sketch doets complete proof soundness holds valued semantics 
precisely result 
theorem soundness program query ffl comp ffl finitely failed sldnf tree comp lot effort devoted establish sort completeness sldnf resolution 
clark noticed comparing sldnf resolution comp restrictions necessary 
example fp qg comp successful sldnf derivation exists 
example depends positively negatively definition strictness designed avoid type situations 
cavedon lloyd established conjecture apt blair walker proved completeness valued semantics comp allowed strict stratified concept introduced section 
independently kunen established stronger result refers valued semantics 
theorem completeness suppose allowed 
ffl comp qr ffl comp crucial lemma establishing completeness theorem numerous generalizations discussed text result kunen allows set induction proper way 
lemma order formula oe containing comp oe iff oe finite denotes fold iteration operator starting empty valued interpretation 
lemma non herbrand models comp essential way 
noted shepherdson lemma critically depends existence infinitely function symbols counting constants ary function symbols property satisfied universal language adopted 
language finitely function symbols free equality axioms appropriately 
doets provided simpler presentation proof 
see stark proof 
comp resp 
comp say valued resp 
valued correct answer substitution additionally ground say ground correct answer substitution 
completeness theorem conjunction theorems equivalence theorem implies valued correct answer substitutions allowed programs queries ground 
shepherdson showed claim holds valued case allowed programs completion consistent 
problem completeness result mentioned section class allowed programs quite restricted excluded natural prolog programs 
natural question arises generalize completeness result larger class programs 
problem studied researchers 
providing general conditions preventing floundering decker cavedon decker generalized completeness theorem larger class programs 
cavedon proved completeness sldnf resolution acyclic programs subsumes early result clark essentially proved completeness valued completion recursion free programs satisfy syntactic condition prevents floundering 
numerous extensions completeness theorem obtained modifying underlying computation mechanism sldnf resolution 
proof theory ii sldnf resolution revisited explained section definition sldnf resolution ground negative literals allowed selected 
section discuss restriction imposed modified 
modifications sldnf resolution interesting theoretical alternative modify sldnf resolution allowing selection nonground negative literals certain circumstances 
consider modification definition sldnf resolution mentioned clark 
selected literal query exists empty query marked failed subsidiary tree subs defined finitely failed gamma flg child terms kunen definition definition modification simply amounts dropping clauses qualification ground 
call resulting notion resolution sldnf extended 
soundness theorem holds 
shepherdson generalized form resolution allowing preliminary substitution applied nonground negative literals trying build finitely failed subsidiary tree 
terms definition modification amounts changing clause atom roe roe dropping qualification ground clause 
called form resolution sldnf substitution established soundness sense soundness theorem 
proved completeness involved semantics 
stark observed soundness completeness results hold simple generalizations sldnf resolution called respectively 
resolution methods qualification ground dropped clause clause replaced atom renaming ar studied transformation proofs sequent calculus proofs resolution methods 
stark proved completeness resolution syntactically defined class decomposable programs includes positive programs allowed programs 
allowed programs allowed queries theorem flounder resolution selection negative literals delayed positive literals available coincides sldnf resolution 
consequently result generalizes completeness theorem 
stark proved stronger natural generalization completeness theorem 
point departure stark observation completeness depends certain closure properties 
definition gamma sets queries 
program called gamma program conditions satisfied inst denotes set instances clauses 
inst 
ak ground gamma 
gamma gamma 
gamma inst gamma 
gamma result stark explains importance notion 
modification sldnf resolution definition clause replaced 
theorem completeness ii suppose gamma program 
query ffl comp substitution oe qoe general ffl comp gamma result generalizes completeness theorem fq gamma set queries get allowed program gamma program theorems computed valued correct answer substitutions allowed programs queries ground 
stark systematic way reducing previous completeness results completeness ii theorem means modes input output specifications 
modification proposed di pierro martelli palamidessi 
approach rule termed negation instantiation case sld resolution query consisting possibly nonground atom fails branches sld tree fail instantiate atom 
rule incorporated resolution method general programs 
resulting method called resolution proved sound valued semantics program completion 
mention shepherdson extension sldnf resolution unification equality studied 
prolog variants consider prolog 
pure theoretical point view implementation sldnf resolution leftmost selection rule exception selection nonground negative literals allowed floundering ignored 
leads various difficulties 
noted section obtain undesired program numbers zero zero positive positive ground term different established 
completion comp numbers positive zero zero eq get intended comp numbers positive 
turn consider program sink finite graph sink constant query sink succeeds iff iff 
hand completion interpretation sink relation sink 
programs right interpretation provided completion computation mechanism 
general clear interpret negative literal clause stands sequence local variables natural solution find conditions prevent selection nonground negative literals prolog computations 
problem studied apt pellegrini independently 
notion modes introduced syntactically defined class programs queries proved absence floundering sldnf resolution leftmost selection rule 
useful note restricted situations choice nonground negative literals lead complications 
result direct consequence soundness resolution sldnf resolution mean sldnf resolution floundering ignored 
theorem positive program general query ffl sldnf comp soundness theorem states sldnf resolution sound safe selection rules selection rules select nonground negative literal 
mu prolog naish safe selection rule delaying nonground negative literals ground 
words mu prolog implements sldnf resolution leftmost admissible literal selection rule literal admissible negative ground positive 
complicated selection rules allowed nu prolog successor mu prolog naish godel language proposed hill lloyd 
languages called delay control declarations cause certain literals delayed sufficiently instantiated 
kappel provides thorough theoretical account delay declarations 
restriction sldnf resolution leftmost selection rule results loss completeness simple programs 
take fp pg comp sldnf derivation leftmost selection rule diverges 
limited forms completeness obtained restricting attention terminating programs see apt pedreschi 
lately issue proposed stark see section 
prolog negation applied arbitrary query atom sldnf resolution variants 
disjunction queries bodies clauses 
lloyd topor see lloyd modelled syntactic extensions means general syntax queries bodies clauses arbitrary order formulas 
generalized queries programs interpreted means syntactic transformation transforms general query general program combined sldnf resolution 
lloyd topor showed transformation preserves program completion defined generalized programs expected way 
syntactic extension general programs allows deal properly program sink discussed enforce right interpretation program completion suffices replace second clause sink 
extended syntax language godel hill lloyd mentioned 
constructive negation sldnf resolution positive literals generate computed answer substitution 
resolution negative literals generate answers 
unfortunately answer substitutions need guessed subsequently verified 
chan suggested modification sldnf resolution nonground negative literals selected generate answers contrast resolution answers effectively computed 
way negative literals called constructive negation resulting form resolution sld cnf resolution 
introduce helpful notation 
substitution fx denote formula sequence variables ran gamma dom 
departure point chan approach property sld resolution essentially proved clark 
consider finite sld tree query sld tree 
denote fq formula comp fq 
consequently comp fq suggests interpret fq computed answers generated problems solved interpretation 
formula fq interpreted set substitutions 
defined means apply formula query 
secondly fq defined 
solve problem chan extended language logic programs allowing equalities inequalities queries bodies clauses provided normalization algorithm transforms formula form fq disjunction simple equality formulas existentially quantified conjunctions equalities negations 
second problem chan definition original definition due clark noted noted section problematic cases sldnf trees exists 
adequately solved marchiori provided formal definition sld cnf resolution style apt doets 
chan noticed sld cnf resolution sound program completion valued semantics 
particular sld cnf resolution allows treat correctly previously mentioned program numbers query positive succeeds desired answer 
marchiori studied termination programs constructive negation proved completeness sld cnf resolution acyclic programs program completion bounded queries 
generalizations constructive negation proposed stuckey 
proved completeness results subsume completeness theorem 
valued alternatives herbrand model case positive logic programs herbrand model program exists 
model enjoys number natural properties 
example pre fixpoint operator fixpoint 
consequently customary view standard model program 
case general programs situation dramatically changes herbrand model 
just take fp qg 
fpg fqg minimal models 
lemma may pre fixpoint subsection noted may fixpoint 
standard model general program 
generally agreed answer question 
section review plausible answers suggested literature 
stratified programs standard model agree desired properties natural model 
clearly fact model explanation 
definition suggested apt blair walker bidoit froidevaux attempts formalize requirement 
definition supported interpretation herbrand interpretation called supported ground intuitively explanation clearly lemma supported model iff view observation behaviour operator see programs supported models exist 
possible approach accept programs natural supported model identify classes programs natural supported model exists 
notion considered context database queries chandra harel introduced area logic programming apt blair walker van gelder 
definition stratified program program called stratified cycle negative edge exists dependency graph 
words program stratified negative recursion recursion negation 
example program fp rg stratified fp pg 
note stratified program call consistent conversely 
equivalent formulation shows stratified program negation restricted known defined relations 
definition stratification consider program called stratification uses positively relations defined negatively relations defined gamma empty 
convenience relations defined assume defined empty set clauses lemma program stratified iff admits stratification 
note program admit 
intuition negation model defined stratified programs 
definition standard model consider stratified program assume stratification denote restriction interpretation relations defines set relations rel define sequence herbrand interpretations follows model model rel model rel gamma gamma call standard model example consider fp rg stratification fq rg fp qg 
fpg 
result apt blair walker explains model interest 
theorem standard model consider stratified program ffl depend stratification ffl minimal model ffl supported model fixpoint lemma completion stratified program herbrand model 
locally stratified programs perfect models theorem uniquely characterize standard model stratified programs supported model exists 
just take fp qg 
fpg fqg supported 
provide unique characterization model przymusinski introduced notion preferable models 
fix program founded ordering say higher priority definition perfect model herbrand interpretations call preferable write oe gamma exists gamma write oe call herbrand model perfect herbrand models preferable 
perfect model oe minimal herbrand model intuition definitions 
preferable obtained possible adding removing atoms addition atom compensated simultaneous removal atom higher priority 
reflects fact determined minimize higher priority atoms cost adding atoms lower priority 
model perfect form minimization higher priority atoms achieved 
lemma clarifies status perfect models 
lemma program founded ordering ffl perfect model minimal 
ffl relation preferable partial order 
standard model stratified program related perfect models theorem przymusinski 
theorem stratified program iff relation symbol depends negatively relation symbol unique perfect model words oe smallest herbrand model theorem provides alternative proof claim standard model theorem 
notion perfect model turns key concept assessing character previous result immediately suggests generalization concept stratification proposed przymusinski 
observed programs stratified intuitively clear meaning 
standard example program program clearly stratified relation depends negatively 
consider ground instances clauses see ground atom depends negatively 
words consider ground atoms proposition symbols instantiated program stratified albeit infinite 
program property locally stratified definition local stratification ffl local stratification program function stratum countable ordinals 
ffl local stratification stratum extend ground negative literals putting stratum stratum 
ffl clause called locally stratified respect local stratification stratum ground instance stratum stratum ffl program called locally stratified respect local stratification clauses 
called locally stratified locally stratified respect local stratification 
lemma ffl acyclic program locally stratified 
ffl stratified program locally stratified 
comparing ground atoms relation symbols local stratification program immediately induces founded ordering theorem due przymusinski shows perfect models unambiguously define semantics locally stratified programs 
theorem unique perfect model locally stratified program iff stratum stratum 
unique perfect model 
soon realised programs locally stratified clear meaning 
example rewrite program zero successor zero successor program change representation numbers changing clauses defining relation 
program longer locally stratified successor instance second clause 
course premise successor instance false part semantics program local stratification syntactic property 
proposals adapting local stratification perfect model semantics capture phenomenon weak stratification przymusinska przymusinski effective stratification bidoit froidevaux 
weak stratification observed iteration construction model lowest stratum identified 
truth values obtained atoms stratum discard clauses false premises 
turn may remove dependencies allowing identification lowest stratum 
omit formal definition 
program lowest stratum consists zero successor atoms 
discarding clauses false zero successor premises yields locally stratified program zero successor zero successor theorem przymusinska przymusinski locally stratified program weakly stratified 
bidoit froidevaux define notion effective stratification takes approach 
closely related introduced founded models discuss section 
supported stable models section noted program fp qg fpg fqg supported models 
support unfounded sense explanation true 
rule second supported model 
approach fages idea precise 
definition supported interpretation query denote pos sequence positive literals herbrand interpretation called supported founded ordering implies ground pos intuitively supported explanation example fp qg model fpg supported fqg 
noted programs supported models 
take example fp pg 
herbrand model fp qg supported 
intuition rational beliefs autoepistemic logic gelfond lifschitz introduced important notion stable model :10.1.1.24.6050
auxiliary notions 
definition gelfond lifschitz transformation query denote neg sequence negative literals program interpretation 
fh pos ground neg define gamma positive program obtained removing clauses contain negative literals false deleting negative literals true turn gamma herbrand model equal herbrand model positive program 
definition stable model herbrand interpretation program called stable gamma gelfond lifschitz explain intuition definition stable model follows :10.1.1.24.6050:10.1.1.24.6050
consider rational agent set beliefs set premises clause literal body useless removed 
literal trivial deleted 
yields simplified program 
happens precisely set atoms follow logically simplified set premises set beliefs stable 
stable models possible sets belief rational agent hold 
theorem fages shows concepts supported stable models coincide 
independently established elkan case propositional programs 
theorem suppose model stable iff supported 
fortiori stable models program supported models consequently fixpoint lemma models comp 
converse general true see section certain programs herbrand models comp stable models coincide 
corollary theorem due fages independently ben eliyahu 
corollary suppose cycle positive edges exists dependency graph herbrand models comp coincide stable models results gelfond lifschitz clarify relation stable models notions introduced sections :10.1.1.24.6050
theorem unique stable model consider program ffl stable model minimal model ffl locally stratified unique stable model coincides perfect model considered unique perfect model theorem 
particular stratified theorem unique stable model coincides standard model similarly notion perfect model concept stable model allows characterize notion standard model stratified programs unique way 
second result shows sufficient condition existence stable model program locally stratified 
dung proves call consistency sufficient 
results dung fages 
valued alternatives herbrand model stable model semantics allows stable model 
reflects uncertainty drawn program 
cases local uncertainty destroy information 
example stratified program relation symbol occur fp pg stable models 
information contained reflected stable model semantics related uncertainty truth value founded semantics wfs avoids problem producing valued model multiple valued ones 
contrast section valued logic valued interpretation connectives needed obtain valued models 
numerous characterizations founded semantics 
apart information ordering valued interpretations defined section truth ordering truth iff gamma gamma iterated fixpoint characterization wfs suppose prefers herbrand model closed world assumption completion classical negation decide negative literal holds positive program 
general program observe regardless semantics negative literals clause bodies atoms true semantics facts program false atoms unify head clause 
weaknesses proposals section information lost model produced 
guessing interpretation see stable model know guess atoms 
atoms simplify program example weak stratification 
result simplification atoms may certainly true certainly false 
truth value atoms decided way program called effectively bidoit froidevaux 
atoms remain undecided start guessing order find stable models 
interesting option just return valued model 
model shows atoms true respectively false regardless semantics negation atoms decided way 
called founded model 
original definition founded semantics usually attributed van gelder ross schlipf 
loosely follow somewhat constructive definition bidoit froidevaux 
significantly different characterizations founded model sections 
step definition derive program atoms certainly true respectively false semantics 
atom certainly true derived clauses contain negative literals 
atom possibly true derived ignoring negative premises 
atom certainly false possibly true 
collect certain atoms valued interpretation leaving uncertain atoms unknown 
definition program 
denote program obtained deleting clauses contain negative literal 
gamma denote program obtained deleting negative literals 
gamma 
denotes complement set ground atoms considered universal language larger language defined bidoit froidevaux call set defined atoms def gamma set potentially defined atoms 
van gelder ross schlipf call atoms founded gamma unfounded set see 
section simplification program set certain literals differs gelfond lifschitz transformation definition significant way negative literals positive literals considered simplification 
generalization definition valued interpretations considered section 
definition program valued interpretation 
pni denote program obtained ground deleting clauses contain literals false deleting literals true furthermore phi pni lemma przymusinski phi operator monotonic information ordering 
lemma implies fixpoint phi exists reached iterating phi operator pairwise union limit ordinals 
definition founded model information fixpoint phi called founded model wfm 
phi general continuous iterations usually needed reach fixpoint 
number atoms language finite say computation wfm way takes iterations shown van gelder ross schlipf 
original definition founded model van gelder ross schlipf slightly differs 
phi define iterate operator set facts pni pni gamma derivation positive facts goes slower phi define pni gamma non constructive way largest unfounded set unfounded set set ground atoms atoms instances clauses conclude premise assume atoms false clause derive remains applicable justifies assumption 
founded model related stable models models section way 
theorem extension van gelder ross schlipf stable models program extend founded model 
corollary founded model program total unique stable model 
converse implication true program fp pg fpg unique stable model founded model 
theorem implies founded model locally weakly stratified program total 
corollary founded model locally stratified program coincides unique perfect model 
define generalization notion weak stratification mentioned section due bidoit froidevaux 
definition effective stratification program effectively wfm total 
theorem bidoit froidevaux weakly stratified program effectively 
founded model lower information ordering stable model 
notion extension confused semantics defined class programs said extend semantics defined smaller class coincide avoid confusion shall word extend sense 
stationary models stationary expansions section alternative characterization founded model due przymusinski relies somewhat valued logic stays closer definition stable models 
characterization suggests interesting valued models program extend founded model 
definition presents function simplifies program respect valued interpretation fact function replaces negative literal program truth value interpretation 
result positive program logical constants true false occur 
considering semantics program herbrand model constants true ignored 
constant false clause body means clause applicable clause ignored 
syntactically removing parts program ignored bypassed logical constants defined result function positive program 
straightforward generalize function simplifies program respect valued interpretation 
result positive program constants true false unknown occur 
get rid constants true false constants unknown remain 
problem truth partial herbrand model programs defined 
definition program program positive program constants true false unknown may occur 
denotes truth valued herbrand model program program valued interpretation 
program obtained ground replacing negative literal truth value gamma analogously stable models section fixpoints gamma considered possible meanings program przymusinski called models partial extended valued stable models stationary models 
shall refer stationary models stable models shall mean valued ones 
definition stationary model program 
stationary model valued herbrand interpretation gamma contrast stable models program stationary model 
set stationary models program information element happens coincide founded model 
theorem stationary model przymusinski program 
information stationary model exists coincides wfm 
valued interpretation gamma obviously coincides gamma 
stable models program information maximal stationary models 
clarifies extension theorem 
note coincides get rid occurrences true false treat occurrences unknown negative literals 
considering information minimal stationary model consider information maximal ones plausible belief states associated program 
stable models program 
stable model semantics program easily destroyed local maximal stationary model semantics robust 
local impossibility simply means atoms remain unknown models affect global existence models 
definition stable model stationary model constructive involves guess interpretation checked stable respectively stationary model 
sacc zaniolo characterized stable models means fixpoints backtracking operator generates stable models program 
extended generalized characterized stationary models means fixpoints nondeterministic non monotonic operator 
characterization stationary models proposed przymusinski stays valued logic 
identify program program obtained replacing occurrence negative literal new atom gives positive program atoms form occur bodies clauses 
stationary expansion obtained adding program suitable set atoms fully determine stationary model 
definition stationary expansion positive program atoms bodies clauses 
set atoms 
ffl herbrand interpretation set atoms containing ordinary atoms atoms general 
ffl minimal models mean herbrand interpretations minimal set inclusion ordinary atoms necessarily atoms interpretations satisfy classical sense ffl negative literal min true minimal models ffl stationary expansion consistent theory satisfies fnot min ag ffl stationary expansion called stationary completion 
theorem correspondence przymusinski program 
correspondence stationary models stationary expansions ffl stationary model fnot ag stationary expansion ffl stationary expansion fa ag min ag stationary model way founded model corresponds stationary completion information stationary model founded model program computed iterating gamma 
corresponds theorem 
theorem przymusinski program 
successor ordinal ff ff ff fnot ff min ag 
limit ordinal fi fi ff fi ff sequence ff fixpoint coincides stationary completion shall discuss generalization stationary expansions class general disjunctive programs section 
alternating fixpoint characterization wfs characterization founded model van gelder 
solely valued interpretations combined valued model 
observed van gelder gamma antimonotonic operator valued interpretations truth ordering 
gamma gamma iterated twice monotonic lattice fixpoint say gamma greatest fixpoint gamma theorem alternating fixpoint van gelder program 
fixpoint gamma exists wfm gamma extension theorem corollary theorem 
theorem general version alternating fixpoint theorem 
theorem alternating fixpoint ii przymusinska przymusinski program valued interpretation 
gamma stationary model iff gamma gamma 
note fp qg gamma oscillates fpg fqg corresponding stationary model interpretations fpg fqg fqg fpg inconsistent 
pairs interpretations generalized finite sets baral subrahmanian 
definition stable class program 
stable class finite set valued interpretations gamma ag 
program stable model fmg stable class interpretation fixpoint gamma iff fi gamma stable class approach van gelder generalized direction fitting case programs interpreted valued models generally bilattices 
properties founded semantics extensions founded semantics drawback infer atoms expect true 
consider example program fp qg 
stable models true 
true 
unknown founded model 
numerous semantics proposed extend founded semantics wfs wfs dix baral lobo minker schlipf equivalent wfs hu yuan wfs chen kundu semantics pereira apar icio alferes 
properties semantics investigated dix dix 
theorem properties dix ffl founded semantics wfs wfs rational 
ffl semantics cautious rational 
ffl wfs satisfy cut rule 
ffl cautious satisfy principle partial evaluation 
program completion revisited previous sections defined semantics negation means canonical models stable models founded models 
question arises semantics characterized form completion stationary completion definition technically logical theory negative stated facts close model 
wallace answered question affirmatively 
section summarize results obtained defining simple program transformations considering completion transformed programs 
discuss briefly results stark 
tightened completion standard program completion discussed section results loose interpretation negation corresponding negation finite failure rule soundness theorem completeness theorem 
order obtain tight interpretation negation wallace encoded iterations operator program 
definition tightened program program 
tightened program derived follows variable ffl language consists augmented new relation symbol arity relation symbol arity new unary function symbol added 
ffl clause head replaced positive literal body replaced 
ffl relation symbol clause added 
tightened completion program defined completion result clarifies relation stable models program tightened completion 
theorem tightened completion wallace stable models program precisely restrictions herbrand models comp rounded completion special case previous theorem observe tightened completion program inconsistent program stable models 
motivations considering valued models completion section founded semantics section avoiding inconsistency 
program transformation suggested independently martelli wallace results call consistent program theorem completion consistent 
definition doubled program program 
doubled program called split program pd derived follows 
ffl language pd consists augmented new relation symbol arity relation symbol arity ffl clause replaced new clauses clause occurrence relation symbol negative literal replaced second clause occurrence relation symbol positive literal head clause replaced doubled completion called strict completion program defined completion pd close connection doubled completion program valued interpretation standard completion 
theorem doubled completion martelli program atom ground negative literal 
comp pd iff comp tightening doubling program transformations orthogonal pd called rounded program derived completion called rounded completion 
result clarifies relation founded model program rounded completion 
theorem rounded completion wallace founded model program consists exactly ground literals true herbrand models rounded completion intuitively explain relation rounded completion program founded model alternating fixpoint characterization 
split herbrand model rounded completion sets containing dashed atoms atoms 
removing dashes interpretations obtained 
easily seen gamma oscillates 
wallace describes completion full completion program obtained rounded completion dropping free equality axioms adding relation induction axiom result effect counter tightened program weakened loop leads failure infinite descending chain 
example full completion program fp entails ground term entail exists model infinitely individuals 
semantics coincides van gelder 
approaches conclude section mentioning modifications completion proposed stark 
called partial completion 
definition doubled program definition relation symbol new relation symbol arity introduced 
relations modified step building completion 
replacing formulas added 
behaves classical negation exception 
resulting theory called partial completion 
usual completion obtained adding axiom relation stark showed completeness ii theorem holds comp replaced 
result generalizes theorem stark showed queries iff comp iff comp stark modification approach dealing prolog proposed 
sldnf resolution leftmost selection rule related theory called comp 
theory modification comp obtained introducing relation symbol new relation symbols intuitive meaning succeeds finitely fails terminates 
comp built similar way construction involves operators transform queries original language formulas enriched language includes relation symbols typical crucial law fl tl fl intuitively expresses query finitely fails sldnf resolution leftmost selection rule 
corresponding result connects resolution method comp way analogous completeness ii theorem 
generalizes essential way completeness result terminating programs considered 
proof theory iii sls resolution sls resolution modified version sld resolution deal stratified programs just definite positive programs second replacing 
fact similar resolution methods general programs called sls resolution 
definition stratified programs due przymusinski precisely mild generalization locally stratified programs adapted bol 
main difference sldnf resolution computation oriented negation finite failure rule replaced idealistic negation necessarily finite failure rule 
consequence sls resolution effective implementation approximate 
contrast sldnf resolution implemented straightforward way sets sldnf successful finitely failed queries recursively enumerable building sldnf trees possibly infinitely selection rules 
example sldnf versus sls resolution fp query trees needed selected literals underlined denotes subs relation nodes trees 
fail fail 
sls tree sls tree unsuccessful sldnf tree successful sldnf tree see middle picture rightmost selection rule yields finite successful sldnf tree sls tree 
leftmost selection rule yields infinite unsuccessful sldnf tree left picture 
value completeness results sldnf resolution stating existence successful sldnf tree limited 
rightmost picture shows sls tree leftmost selection rule successful infinite 
sls resolution locally stratified programs provide formal definition sls resolution locally stratified programs concepts introduced section defining sldnf resolution 
definition stratum program locally stratified stratum 
ffl atom necessarily ground define stratum ag ag ground instance ag ffl negative literal necessarily ground define stratum stratum ffl define stratum query stratum definition sls tree sls tree forest nodes possibly marked queries possibly marked literals 
markers sldnf trees 
function subs assigns nodes containing marked negative ground literal tree root tree successful leaf marked success tree floundered leaf marked floundered tree may successful floundered 
tree failed successful floundered 
locally stratified program selection rule 
query define sls tree induction stratum 
root main tree node ffl empty query marked success children 
ffl selects positive literal children nodes obtained extending sense definition 
children obtained way marked failed ffl selects negative literal nonground children marked floundered ground stratum stratum sls tree subs defined 
set subs extend subs subs extend successful children marked failed floundered children marked floundered failed resolvent ffl gamma ag child 
contrast sldnf trees finiteness required 
definition computed answer substitution locally stratified program query 
consider branch main tree sls tree ends empty query 
ff ff consecutive substitutions branch 
restriction ff delta delta delta ff jq composition ff delta delta delta ff variables called sls computed answer substitution short saw section sldnf resolution sound program completion comp 
natural question arises semantics sls resolution sound 
answer provided przymusinski turns sls resolution proof theoretic counterpart perfect model semantics 
precisely established results 
theorem soundness locally stratified program query selection rule 
unique perfect herbrand model consider main tree sls tree ffl ffl failed corollary sls resolution locally stratified programs sound unique stable model semantics founded semantics 
theorem completeness locally stratified program query selection rule 
unique perfect model consider main tree sls tree suppose flounder 
ffl oe qoe general ffl failed 
corollary sls resolution locally stratified programs complete absence floundering unique stable model semantics founded semantics 
sls resolution general programs name suggests sls resolution stratified programs proposals top computation founded semantics called sls resolution 
ones literature discuss section disadvantage requiring selection rule 
means negative literal selected positive literals available 
przymusinski observed suitable variant iterated fixpoint definition founded semantics suggests dynamic stratification program ground atom decided true false iteration ff ff dynamic stratum sls derivation atom stratum ff defined induction ff consists phases 
phase positive literals selected derivation proceeds 
derivation fails finitely failed diverges 
derivation fail phase ends query negative literals possibly 
second phase ground negative literals stratum ff selected 
induction stratum sls tree defined 
case handled definition ffl contains empty query derivation fails ffl contains floundering derivation derivation ffl removed derivation continues remaining negative literals 
derivation completes phases possible outcomes ffl derivation ends empty query successful ffl derivation ends query containing nonground negative literal ffl derivation ends undefined leaf addition ineffective negation failure rule criteria selection rule ineffective compare strata atoms computing truth value founded model 
przymusinski remarks requirement translates negative recursion allowed derivation 
interpreter implementing form resolution may select wrong negative literal find leads negative recursion backtrack selection 
problem approach way part search interpreter represented resulting sls tree 
versions sequence sls trees rank ff created negative literals decided basis sls tree lower rank possible skipped 
skipping means literal selected 
selection rule explicitly required sls tree rank negative selected literals skipped effect selection rule 
sls tree rank ff extends tree rank ff nodes contain exclusively skipped negative literals 
hidden property selection mechanism negative literals effectively selected parallel tried rank resolved fails succeeded 
selection rule negatively parallel selects negative literals explicitly ross called preferential 
ross defines slp trees stands result phase described 
defines global sls resolution means global sls trees follows 
definition global sls tree global tree gamma query types nodes ffl tree nodes labeled slp trees intermediate goals ffl negation nodes labeled query negative literals possibly ffl nonground nodes label 
root gamma slp tree tree node gamma children negation nodes leaf contains negative literals child gamma negation node children ground child tree node slp tree child nonground node 
node global tree status successful failed indeterminate floundered 
definition status nodes consider global tree 
ffl nonground node floundered ffl negation node failed children successful successful children failed floundered children successful floundered 
ffl tree node failed children failed successful children successful floundered children floundered 
ffl nodes assigned status rules indeterminate 
tree node successful floundered pair status possible single node 
definition query 
root node global sls tree gamma slp tree 
successful branch branch ends leaf labeled corresponding negation node labeled successful 
computed answer substitution successful branch composition consecutive substitutions branch restricted variables ross proved results 
theorem soundness program query 
gamma global sls tree ffl computed answer substitution gamma wfm ffl root gamma failed wfm 
theorem completeness program query 
gamma non floundering global sls tree ffl wfm root gamma successful ffl wfm root gamma failed ffl wfm computed answer substitution oe gamma goe general 
sls resolution general programs selection rules section definition sls resolution deals general programs selection rules new best knowledge 
step define oracle sls trees trees resolve selected positive literals program clauses usual ground negative literals resolved founded model oracle 
eliminate negative recursion 
oracle produces answers true false unknown 
order record case properly substitutions may annotated definitions 
definition oracle sls tree program selection rule 
query define oracle sls tree follows 
root node ffl empty query marked success children 
ffl selects positive literal children nodes obtained extending sense definition 
children obtained way marked failed ffl selects negative literal nonground children marked floundered ground true wfm children marked failed false wfm resolvent ffl gamma ag child unknown wfm resolvent ffl gamma ag child definition oracle answer substitution program query 
consider branch oracle sls tree ends empty query 
ff ff consecutive substitutions branch 
restriction ff delta delta delta ff jq composition ff delta delta delta ff variables called oracle sls computed answer substitution short substitutions ff annotated called oracle sls unknown answer substitution short oracle sls tree query ffl successful gives ffl floundered contains leaf marked floundered ffl indeterminate successful floundered gives ffl failed 
results relate oracle sls trees founded semantics 
lemma soundness consider oracle sls tree program query ffl wfm ffl wfm ffl failed wfm lemma completeness consider oracle sls tree program query suppose flounder 
ffl wfm oe qoe general ffl wfm oe qoe general ffl wfm failed 
proving lemmas straightforward negative literals correct truth value definition positive literals treated sld resolution 
results allow second step construction sls tree 
nodes ground negative literal selected oracle justify outcome oracle subsidiary oracle sls tree tree produces answer oracle 
case descendants removed flounder leaf 
recursively adding subsidiary trees nodes oracle step involving selected ground negative literal remain unjustified 
definition sls tree program query selection rule 
sls tree defined limit sequence oracle sls trees depth 
defined induction 
oracle sls tree depth consists tree oracle sls tree oracle sls tree depth forest subs obtained follows 
main tree oracle sls tree nodes removed 
root follow branch ground negative literal selected node subs oracle sls tree depth gamma set subs extend subs subs floundered successful mark floundered remove children 
results relate sls trees founded semantics 
theorem soundness consider main tree sls tree program query ffl wfm ffl wfm ffl failed wfm theorem completeness consider main tree oracle sls tree program query suppose flounder 
ffl wfm oe qoe general ffl wfm oe qoe general ffl wfm failed 
founded model program stationary model oracle definitions 
oracle sls trees obtained stationary model oracle sound complete sense defined sls trees way sound complete founded semantics clear interpreter construct trees top way 
brings issue implementation 
implementation mentioned sls resolution effective fully implementable 
possible sound implementation complete limited class programs programs function symbols 
essential capture infinite derivations form loop 
done simple loop checking techniques tabulation known memo ization lemma resolution 
locally stratified programs loop checking studied bol 
tabulation stratified programs studied kemp topor sls resolution seki itoh sldnf resolution 
definition setting positive loops dealt 
approach remain close tabulation positive programs maintaining table stratum 
chen warren added tabulation mechanism form sls resolution proposed przymusinski warren order detect positive loops 
negative loops detected maintaining negative context set negative literals may assumed undefined encountered loop 
way tables constructed relevant negative contexts 
gives redundant computations complex result final construction forest forests 
bidoit proposed similar system computing defined atoms potentially defined atoms separately 
bol proposed simpler method uses tabulation detect positive negative loops 
table needs constructed definition failure somewhat complicated 
mentioned top computation founded semantics ground programs described pereira apar icio alferes tabulation uses positive negative contexts 
positive contexts generalize nonground case shown apt bol klop 
disjunctive programs disjunctive logic program heads clauses disjunctions atoms 
numerous semantics proposed programs 
classified dix 
positive disjunctive programs allow expression indefinite incomplete knowledge impossible definite programs 
examples consider natural statements mother father parent red blue green primary colour 
addition negation allows express indefinite knowledge may wonder allowing disjunctions general logic programs 
negation logic programming classical negation effect clause quite different pair fp pg better approximation retains symmetry adequate 
introduces loop negation renders semantics inapplicable causes obvious problems proof theory 
furthermore founded model program fp qg contain expect 
positive disjunctive programs lobo minker rajasekar published book foundations disjunctive logic programming larger part deals positive programs :10.1.1.124.9986
shall briefly recall semantics positive disjunctive programs elaborate discussion motivation proof theory refer book 
important distinction positive disjunctive programs inclusive exclusive interpretation disjunctions 
example program fp exclusive reading concludes false inclusive reading conclude recall definite programs negation finite infinite failure rule viewed application closed world assumption see section cwa iff rule rephrased disjunctive programs form gives rise inconsistencies 
cwa cwa cwa ag inconsistent 
generalized closed world assumption gcwa minker rephrasing says gcwa iff true minimal models gcwa gives rise exclusive interpretation disjunctions 
weak generalized closed world assumption developed independently lobo minker rajasekar ross topor 
originally defined computational simplification gcwa infers negative literals 
program obtained replacing clause yields clauses iff cwa gives rise inclusive interpretation disjunctions 
notice cwa gcwa coincide definite programs 
negative literals inferred completion disjunctive program defined lobo rajasekar minker :10.1.1.124.9986
consists augmented eq part completion theorem dix rational gcwa cumulative rational 
program fp rg counterexample rationality gcwa 
minimal models fp rg fqg gcwa gcwa frg minimal models fp rg fq sg frg gcwa notice locally stratified disjunctive programs definition locally stratified programs generalized disjunctive programs atoms disjuncts head ground instance program clause atoms stratum 
definition perfect models definition generalizes immediately locally stratified disjunctive programs 
course disjunctive program may perfect model 
definition perfect model semantics przymusinski perfect model semantics disjunctive program defined putting ground atom true false true false perfect models definition weak perfect model semantics dix weak perfect model semantics disjunctive program defined putting ground atom true false true false perfect models perfect model perfect model semantics interprets disjunctions exclusively weak perfect model semantics 
perfect model semantics extends generalized closed world assumption stratified programs defined rajasekar minker 
weak version called defined dix weak perfect model semantics extends 
notice locally stratified program locally stratified disjunctive program 
theorem dix ffl perfect model semantics coincide gcwa positive disjunctive programs 
ffl weak perfect model semantics coincide positive disjunctive programs 
ffl perfect model semantics weak perfect model semantics cumulative 
ffl semantics rational 
general disjunctive programs semantics general disjunctive programs coincide founded semantics general programs coincide perfect weak perfect model semantics locally stratified disjunctive programs proposed przymusinski dix 
przymusinski defines stationary expansions disjunctive programs generalizing definition ways 
ffl set atoms set disjunctions atoms added program ffl second condition interpretations considered determining minimal models generalized disjunctive inference rule empty disjunction interpreted false 
ffl negative disjunction min true minimal models particular notion minimality 
ffl fixpoint equation defines stationary expansions fnot min version semantics przymusinski min disjunctive inference rule implicitly definition min recursive 
dix reformulates compares versions third version essentially disjunctive inference rule restricted 
third version weaker perfect model semantics locally stratified disjunctive programs 
dix defines weak stationary semantics weak stationary extension satisfies fixpoint equation fnot min disjunctive inference rule third mentioned 
weak stationary semantics interprets disjunctions 
theorem dix ffl stationary semantics disjunctive programs cumulative 
ffl weak stationary semantics cumulative rational 
ffl locally stratified disjunctive programs weak stationary semantics decides atoms weak perfect semantics 
dix defines semantics coincides founded semantics general programs perfect model semantics locally stratified disjunctive programs 
weaker stationary semantics cumulative 
weak version coincides founded semantics general programs weak perfect model semantics locally stratified disjunctive programs 
stronger weak stationary semantics cumulative 
different approach taken ross defines semantics general disjunctive programs top procedure generalizing definition 
defines versions strong founded semantics exclusive interpretation disjunctions weak founded semantics inclusive interpretation disjunctions optimal founded semantics program mer defines inclusive exclusive nature separately clause 
general programs semantics coincide founded semantics 
restricted locally stratified disjunctive programs strong version weaker perfect model semantics weak version weaker weak perfect model semantics 
fixpoint semantics extend stationary semantics wf baral lobo minker respectively 
wf extends coincide general programs cautious satisfy properties defined section 
incomparable perfect model semantics locally stratified disjunctive programs 
sakama inoue defined gcwa extension stable models disjunctive programs 
semantics coincide perfect respectively weak perfect model semantics locally stratified disjunctive programs 
clearly issue right semantics general disjunctive programs far decided 
weaker semantics advantages ffl cumulative satisfy dix weak principles ffl complexity computing lower example lower complexity gcwa complexity perfect weak perfect model semantics see muller dix ffl uncertainty safe semantics draws program programmer intended results probably worse intended missed 
final remarks introduced lines research dealing semantics general programs 
considered section focused completion program 
second line considered sections focused various attempts extending concept special herbrand model general programs 
category studied number proposals resulted quite array possibilities 
reconciliation useful characterize class programs approaches coincide 
problem considered apt bezem showed acyclic programs practically approaches considered coincide 
specifically proved result 
theorem acyclic program 
ffl operator unique fixpoint ffl unique fixpoint operator ffl unique perfect model ffl unique herbrand model comp ffl sldnf sls trees coincide bounded queries 
consequently fixpoint lemma unique valued herbrand model comp 
additionally acyclic program locally stratified unique stable model theorem unique stable model consequently corollary founded model 
results generalized apt pedreschi larger class programs corresponding termination leftmost selection rule opposed termination selection rules sense terminating program definition 
fitting provided alternative proof results means metrics banach contraction theorem 
number interesting programs turn acyclic 
theorem approaches semantics coincide 
instance program tweety section programs sink numbers sections acyclic 
example natural formalization called yale shooting problem hanks mcdermott example temporal reasoning instance non monotonic reasoning 
problem extensively discussed literature formalizations various formalisms non monotonic reasoning studied 
relation logic programming note independent apt bezem proved translation yale shooting problem logic program results acyclic program elkan showed translation results locally stratified program evans observed sldnf resolution compute desired consequences original formulation problem order logic 
contrast program section locally stratified fortiori acyclic 
possible apply result apt pedreschi draw programs 
topics treated range topics fall logic programming negation enormous inevitably refrain treating 
follows short list topics left 
deductive databases form extension relational databases relations implicitly defined 
ignoring built relations syntax coincides logic programs 
area deductive databases negation formed important research subject 
parts research stratification perfect model semantics overlap logic programming 
topics intrinsic field particular query processing see kemp topor integrity constraint checking see lloyd sonenberg topor sadri kowalski handling updates see naqvi krishnamurthy comparison expressive power various query languages see chandra harel 
research area surveyed kanellakis bidoit 
classical negation called explicit strong negation introduced gelfond lifschitz 
involves second kind negation may occur head body clauses 
motivation capture logic programming complicated forms temporal reasoning exemplified usual formalization yale shooting problem 
kinds negation usually denotes classical negation negation failure denoted semantically classically negated atoms usually treated new atoms 
process selecting intended models inconsistent ones ones containing atom classical negation discarded 
overviews area alferes pereira wagner minker ruiz 
abductive logic programming views roughly speaking query observation explained means additional hypotheses 
explanations rules program backwards sld resolution generalizations 
survey abductive logic programming kakas kowalski toni appeared 
truth maintenance systems viewed extension propositional general logic programs clauses called constraints constant false head 
semantics proposed truth maintenance systems generalizing stable founded semantics deal constraints 
mention elkan giordano martelli jonker 
area related classical negation abduction 
relations non monotonic formalisms abundant see nerode przymusinski 
negation failure non monotonic inference rule cross fertilization semantics non monotonic logics logic programming 
direction stable expansions auto epistemic logic moore inspired gelfond define stable semantics 
parallel connections default logic reiter stable model semantics carried marek truszczy nski bidoit froidevaux 
przymusinski explained stationary semantics means auto epistemic logic see 
direction przymusinski introduced valued versions default logic auto epistemic logic founded semantics logic programs 
default logic semantics generalized baral subrahmanian li przymusinska przymusinski 
unifying framework semantics auto epistemic logic stationary semantics logic programs przymusinski 
relation logic programming circumscription mccarthy studied lifschitz gelfond przymusinski przymusinska 
recursion theoretic analysis concepts attracted lot interest 
complexity syntactic notions local proof theory semantics founded model studied propositional order case 
results surveyed cadoli en schaerf 
intensional negation approach negation transforms program local variables program defining relation relation succeeds iff finitely fails vice versa 
intensional negation mainly studied mancarella 
linear logic modification classical gentzen sequent calculus developed girard capture reasoning resources 
particular linear logic sensitive times formula hypothesis proof 
showed linear logic reason logic programs providing translation logic programs program completions linear logic theories soundness completeness sldnf resolution allowed programs established sldnf resolution leftmost selection rule adequately interpreted 
referees useful comments rachel jurgen dix extensive suggestions kees doets marco schaerf robert stark helpful discussions subject 
alferes pereira 
logic program semantics kinds negation 
apt pages 
apt 
logic programming 
van leeuwen editor handbook theoretical computer science pages 
elsevier 
vol 
apt editor 
proc 
joint international conference symposium logic programming washington 
alp mit press 
apt bezem 
acyclic programs 
new generation computing 
apt blair 
arithmetic classification perfect models stratified programs 
fundamenta informaticae 
addendum vol 
pages 
apt pedreschi 
reasoning termination pure prolog programs 
information computation 
apt pellegrini 
occur check free prolog programs 
technical report cs cwi amsterdam 
appear acm toplas apt van emden 
contributions theory logic programming 
journal acm 
apt blair walker 
theory declarative knowledge 
minker pages 
apt bol klop 
safe termination prolog programs 
levi martelli pages 
apt doets 
new definition sldnf resolution 
illc series ct department mathematics computer science university amsterdam netherlands 
appear journal logic programming port ramamohanarao 
efficient bottom computation queries stratified databases 
logic programming 
baral lobo minker 
generalized founded semantics logic programs 
stickel editor proc 
th international conference automated deduction lnai pages july 
baral lobo minker 
generalized disjunctive founded semantics logic programs 
ras editors proceedings fifth international symposium methodologies intelligent systems pages october 
baral lobo minker 
wf semantics negation normal disjunctive logic programs 
proceedings sixth international symposium methodologies intelligent systems charlotte nc 
baral subrahmanian 
stable extension class theory logic programs default logics 
automated reasoning 

models completion classes logic programs 
fundamenta informaticae 
mancarella pedreschi turini 
transformational approach negation logic programming 
logic programming 
ben eliyahu 
program completion default logic 
proceedings th israeli symposium artificial intelligence computer vision neural networks ramat gan israel december 
poster nd international workshop logic programming nonmonotonic reasoning lisbon portugal june 
bidoit 
negation rule database languages survey 
theoretical computer science 
bidoit froidevaux 
general logical databases programs default logic semantics stratification 
information computation 
bidoit froidevaux 
negation default logic programs 
theoretical computer science 
bidoit 
evaluation procedure logic programs 
proceedings international conference database technology pages 
bol 
loop checking negation 
logic programming 
extended eijck pages 
bol 
tabulated resolution founded semantics 
miller editor proc 
international logic programming symposium pages 

auto epistemic logics unifying framework semantics logic programs 
apt pages 
borger 
unsolvable decision problems prolog programs 
computation theory logic lecture notes computer science pages 
springer verlag 
cadoli schaerf 
survey complexity results non monotonic logics 
journal logic programming 
cavedon 
continuity consistency completeness properties logic programs 
levi martelli editors proceedings sixth international conference logic programming pages 
mit press 
cavedon 
acyclic programs sldnf resolution 
theoretical computer science 
cavedon lloyd 
completeness theorem sldnf resolution 
journal logic programming 

linear semantics allowed logic programs 
proceedings th symposium logic computer science lics pages philadelphia pa usa 

linear axiomatization negation failure 
journal logic programming 
chan 
constructive negation completed database 
kowalski bowen pages 
chandra harel 
horn clause queries generalizations 
journal logic programming 
chen kundu 
strong semantics logic programs 
ras editors proc 
sixth international symposium methodologies intelligent systems lnai pages charlotte nc 
springer verlag 
chen warren 
goal oriented approach computing founded semantics 
apt pages 
clark 
logic programming schemes implementation 
lassez plotkin editors computational logic essays honor alan robinson pages 
mit press cambridge massachussets 
clark 
negation failure 
gallaire minker editors logic databases pages 
plenum press new york 
fil 
classes programs consistent completion 
technical report universit di padova dip 
di matematica 
fil 
graph properties normal logic programs 
theoretical computer science 
decker 
generalized cover axioms 
furukawa pages 
decker cavedon 
generalizing retaining completeness sldnf resolution 
borger jager richter editors csl rd workshop computer science logic kaiserslautern frg lncs pages 
dix 
classifying semantics logic programs 
anil nerode marek subrahmanian editors logic programming non monotonic reasoning proceedings international workshop pages 
washington mit press july 
dix 
classifying semantics disjunctive logic programs 
apt pages 
dix 
framework representing characterizing semantics logic programs 
nebel rich swartout editors principles knowledge representation reasoning proceedings third international conference kr san mateo ca 
morgan kaufmann 
dix 
semantics logic programs intuitions formal properties 
overview 
andre fuhrmann hans rott editors logic action information 
proceedings konstanz colloquium logic information login 

dix 
classification theory semantics normal logic programs strong principles 
fundamenta informaticae forthcoming 
dix 
classification theory semantics normal logic programs ii 
weak principles 
fundamenta informaticae forthcoming 
doets 

journal logic computation 

failure 
approach constructive negation 
draft 
provisionally accepted acta informatica 
martelli 
strict completion logic programs 
new generation computing 
phan minh dung 
relation stable founded semantics logic programs 
theoretical computer science 
van eijck editor 
logics ai jelia lnai 
springer verlag 
elkan 
logical characterizations non monotonic 
editors mathematical foundations computer science lncs pages 
springer verlag 
elkan 
perfect logic reasoning action 
manuscript 
university toronto 
elkan 
rational reconstruction nonmonotonic truth maintenance systems 
artificial intelligence 
evans 
negation failure approach hanks mcdermott problem 
proceedings second international symposium artificial intelligence mexico 
fages 
new fixpoint semantics general logic programs compared ll founded stable model semantics 
new generation computing 
fages 
consistency clark completion existence stable models 
methods logic computer science 
appear 
fitting 
kripke kleene semantics general logic programs 
journal logic programming 
fitting 
family stable models 
logic programming 
fitting 
metric methods examples theorem 
logic programming 
appear 
furukawa editor 
proceedings eighth international conference logic programming paris france 
mit press 
van gelder 
alternating fixpoint logic programs negation 
proc 
symposium principles database systems pages 
acm sigact sigmod 
van gelder ross schlipf 
founded semantics general logic programs 
acm 
gelfond 
stratified auto epistemic theories 
proceedings aaai pages 
american association artificial intelligence morgan kaufmann 
gelfond lifschitz 
stable model semantics logic programming 
kowalski bowen pages 
gelfond lifschitz 
compiling circumscriptive theories logic programs 
de kleer ginsberg sandewall editors non monotonic reasoning lnai pages 
springer verlag january 
gelfond lifschitz 
logic programs classical negation 
warren szeredi pages 
gelfond lifschitz 
classical negation logic programs disjunctive databases 
new generation computing 
gelfond przymusinska przymusinski 
relationship circumscription negation failure 
artificial intelligence 
giordano martelli 
generalized stable models truth maintenance conflict resolution 
warren szeredi pages 
girard 
linear logic 
theoretical computer science 
hanks mcdermott 
nonmonotonic logic temporal projection 
artificial intelligence 
hill lloyd 
godel programming language 
technical report cstr department computer science university bristol 
revised may 
appear mit press 
hu yuan 
extended founded model semantics general logic programs 
furukawa pages 
jonker 
cautious backtracking founded semantics truth maintenance systems 
technical report ruu cs utrecht university 
kakas kowalski toni 
abductive logic programming 
journal logic computation 
kanellakis 
elements relational database theory 
van leeuwen editor handbook theoretical computer science pages 
elsevier 
vol 
kemp topor 
completeness top query evaluation procedure stratified databases 
kowalski bowen pages 
kemp topor 
completeness top query evaluation procedure stratified databases 
kowalski bowen editors proceedings fifth international conference logic programming pages 
mit press 
kleene 
metamathematics 
van nostrand new york 
kowalski bowen editors 
proc 
fifth international conference symposium logic programming seattle 
alp mit press 
kowalski 
predicate logic programming language 
proceedings ifip pages 
north holland 
kraus lehmann magidor 
nonmonotonic reasoning preferential models cumulative logics 
artificial intelligence 
kunen 
negation logic programming 
logic programming 
kunen 
signed data logic programs 
journal logic programming 
levi martelli editors 
proc 
sixth international conference logic programming lisbon lisbon portugal 
alp mit press 
li 
making default inferences logic programs 
computational intelligence 
lifschitz 
declarative semantics logic programs negation 
minker pages 
lloyd 
foundations logic programming 
springer verlag berlin 
lloyd 
foundations logic programming 
springer verlag berlin second edition 
lloyd topor 
making prolog expressive 
journal logic programming 
lloyd topor 
basis deductive database systems ii 
journal logic programming 
lloyd sonenberg topor 
integrity constraint checking stratified databases 
journal logic programming 
lobo minker rajasekar 
weak completion theory non horn programs 
kowalski bowen pages 
lobo minker rajasekar :10.1.1.124.9986
foundations disjunctive logic programming 
mit press 
kappel 
laziness logic programming 
phd thesis universitat bonn 
makinson 
general patterns nonmonotonic reasoning 
gabbay hogger robinson editors handbook logic artificial intelligence logic programming vol 
nonmonotonic uncertain reasoning chapter 
oxford university press 
mancarella 
intensional negation logic programs italian 
phd thesis universit di pisa 
mancarella pedreschi 
algebra logic programs 
kowalski bowen pages 
marchiori 
proving run time properties general logic programs constructive negation 
res 
report cs cwi amsterdam 
marek truszczy nski 
nonmonotonic logics context dependent reasoning 
berlin springer verlag 
marek truszczy nski 
stable semantics logic programs default theories 
lusk overbeek editors proceedings north american conference logic programming pages cambridge ma 
mit press 
martelli 
new sldnf tree 
information processing letters 
mccarthy 
circumscription form non monotonic reasoning 
artificial intelligence 
minker 
indefinite data bases closed world assumption 
proc 
sixth conference automated deduction lncs pages 
springer verlag new york 
minker editor 
foundations deductive databases logic programming 
morgan kaufmann los altos ca 
minker ruiz 
semantics disjunctive logic programs explicit default negation 
fundamenta informaticae forthcoming 
moore 
semantical considerations non monotonic logic 
artificial intelligence 
muller dix 
implementing semantics disjunctive logic programs fringes properties 
luis pereira anil nerode editors logic programming non monotonic reasoning proceedings second international workshop pages 
lisbon mit press july 
naish 
mu prolog 
technical report tr dept computer science univ melbourne 
naish 
negation quantifiers nu prolog 
third international conference logic programming pages london july 
naqvi krishnamurthy 
database updates logic programming 
proc 
seventh acm symposium principles database systems 
nerode marek subrahmanian editors 
proceedings international workshop logic programming non monotonic reasoning washington july 
mit press 
pereira apar icio alferes 
derivation procedures extended stable models 
proc 
th international conference artificial intelligence pages 
morgan kaufmann 
pereira apar icio alferes 
adding closed world assumptions founded semantics 
icot editor proc 
international conference fifth generation computer systems june 
di pierro martelli palamidessi 
negation instantiation 
technical report dipartimento di informatica scienze dell informazione universit di genova 
przymusinska przymusinski 
semantic issues deductive databases logic programs 
banerji editor formal techniques artificial intelligence pages 
north holland amsterdam 
przymusinska przymusinski 
stationary extensions default theories 
proc 
fourth workshop non monotonic reasoning plymouth vermont 
appear fundamenta informaticae 
przymusinska przymusinski seki 
soundness completeness partial deductions founded semantics 
voronkov editor proc 
international conference automated reasoning lnai st petersburg russia july 
przymusinska przymusinski 
weakly perfect model semantics logic programs 
kowalski bowen pages 
przymusinska przymusinski 
weakly stratified logic programs 
fundamenta informaticae 
przymusinski 
declarative procedural semantics logic programs 
automated reasoning 
przymusinski 
stationary semantics normal disjunctive logic programs 
delobel kifer editors dood proc 
second international conference lncs munchen december 
springer 
przymusinski 
founded completions logic programs 
furukawa pages 
przymusinski 
declarative semantics logic programs negation 
minker pages 
przymusinski 
relationship logic programming non monotonic reasoning 
proc aaai st paul pages 
przymusinski 
logic program natural stratification iterated fixed point model 
proc 
th symposium principles database systems pages 
acm sigact sigmod 
przymusinski 
non monotonic formalisms logic programming 
levi martelli pages 
przymusinski 
valued formalizations non monotonic reasoning logic programming 
brachman leveque reiter editors proceedings international conference principles knowledge representation reasoning pages toronto canada 
morgan kaufmann 
przymusinski 
extended stable semantics normal disjunctive programs 
warren szeredi pages 
przymusinski 
non monotonic reasoning vs logic programming new perspective 
partridge wilks editors foundations artificial intelligence 
pages 
cambridge university press london 
extended appeared 
przymusinski 
stationary semantics disjunctive logic programs deductive databases 
debray hermenegildo editors proceedings north american conference logic programming pages austin tx 
alp mit press 
przymusinski 
founded semantics coincides valued stable semantics 
fundamenta informaticae 
przymusinski 
auto epistemic logics closed beliefs logic programming 
nerode pages 
przymusinski 
stable semantics disjunctive programs 
new generation computing 
extended appeared 
przymusinski 
valued non monotonic formalisms semantics logic programs 
artificial intelligence 
extended appeared 
przymusinski warren 
founded semantics theory implementation 
draft 
rajasekar lobo minker 
weak generalized closed world assumption 
automated reasoning 
rajasekar minker 
stratification semantics general disjunctive programs 
lusk overbeek editors proceedings north american conference logic programming pages cleveland ohio usa 

fundamentals logical foundations truth maintenance 
phd thesis linkoping university 
isbn 
reiter 
closed world data bases 
gallaire minker editors logic databases pages 
plenum 
reiter 
logic default theory 
artificial intelligence 
ross 
founded semantics disjunctive logic programs 
proc 
international conference deductive object oriented databases pages kyoto japan december 
ross 
procedural semantics founded negation logic programs 
logic programming 
ross topor 
inferring negative information disjunctive databases 
automated reasoning 
ross 
modular acyclicity tail recursion logic programs 
proceedings tenth acm symposium principles database systems 
sacc zaniolo 
stable models non determinism logic programs negation 
proceedings acm symposium principles database systems page 
sadri kowalski 
theorem proving approach database integrity 
minker pages 
sakama inoue 
negation disjunctive logic programs 
warren peter szeredi editors proceedings th int 
conf 
logic programming budapest pages 
mit july 
sato 
completed logic programs consistency 
journal logic programming 
john schlipf 
expressive powers logic programming semantics 
proceedings ninth acm symposium principles databases pages 
seki itoh 
query evaluation method stratified programs extended cwa 
kowalski bowen pages 
shepherdson 
sound complete semantics version negation failure 
theoretical computer science 
shepherdson 
correct answers allowed queries ground 
journal logic programming 
shepherdson 
negation logic programming general logic programs 
minker pages 
shepherdson 
negation failure completion stratification 
draft appear handbook artificial intelligence logic programming 
shepherdson 
sldnf resolution equality 
automated reasoning 
stark 
complete axiomatization valued completion logic programs 
journal logic computation 
stark 
proof theory logic programs negation 
phd thesis university berne 
stark 
declarative semantics prolog selection rule 
technical report cis universitat munchen 
stark 
logic programs inductive definitions 
technical report cis universitat munchen 
stark 
input output dependencies normal logic programs 
journal logic computation 
appear 

completeness result sldnf resolution 
journal logic programming 
stuckey 
constructive negation constraint logic programming 
proceedings th annual symposium logic computer science lics pages amsterdam netherlands 

characterization stable models non monotonic operator 
pereira nerode editors proceedings workshop logic programming non monotonic reasoning pages 
van emden kowalski 
semantics predicate logic programming language 
journal acm 
van gelder 
negation failure tight derivations general logic programs 
minker pages 
wagner 
vivid logic knowledge reasoning kinds negation 
phd thesis freie universitat berlin 
wallace 
tight consistent computable completions unrestricted logic programs 
journal logic programming 
warren szeredi editors 
proceedings seventh international conference logic programming jerusalem 
mit press 

partial semantics truth maintenance 
eijck pages 

