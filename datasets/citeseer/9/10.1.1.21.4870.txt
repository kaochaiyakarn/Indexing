security composition multi party cryptographic protocols ran canetti september general definitions security multi party cryptographic protocols focus task evaluating probabilistic function parties inputs 
show respect definitions security preserved natural composition operation 
definitions follow general paradigm known definitions substantial modifications simplifications introduced 
composition operation natural subroutine substitution operation formalized micali rogaway 
consider standard settings multi party protocols including cases eavesdropping byzantine non adaptive adaptive adversaries information theoretic computational models 
particular computational model provide definition security protocols shown preserved composition 
keywords multi party cryptographic protocols security protocols secure function evaluation composition protocols 
appear journal cryptology 
ibm watson research center 
email canetti watson ibm com 
contents previous definitional efforts 
definitional approach taken 
modular composition 
related 
defining secure protocols general paradigm secure function evaluation 
secure function evaluation 
preliminaries non adaptive adversaries definition security non adaptive case 
discussion 
modular composition non adaptive case 
proof theorem 
proof outline 
detailed proof 
extensions 
adaptive adversaries definition security adaptive case 
discussion 
modular composition adaptive case 
proof theorem 
additional difficulties 
detailed proof 
computational setting definition security computational case 
discussion 
modular composition computational case 
definitions designing secure protocols central tasks cryptography 
security generally understood guaranteeing presence adversarial behavior parts system set correctness properties output values parties set secrecy requirements regarding local data parties 
general study secure protocols started pioneering works yao goldreich micali wigderson gmw 
top introducing fundamental notion works suggest general methodology solving cryptographic protocol problem secure way 
followed large body describe general constructions solving protocol problems various settings notably bgw ccd rb gl oy protocols specific tasks df 
contrast great advances constructing secure protocols understanding notion security protocols progresses slowly 
works field particular gmw contain intuitive exposition notion 
general definitions security protocols subsequently formulated notably goldwasser levin gl micali rogaway beaver micali rogaway considerably comprehensive 
definition gl 
definition closest approach 
general approach definitions roughly definitions differ substantial ways 
see details 
notion secure protocols intuitively obvious capturing security requirements cryptographic protocol problem way precise workable easy task 
particular large number constructions secure protocols appear literature including constructions mentioned rigorously proven secure 
exception detailed exposition analysis gmw available 
aims improving understanding nature secure computation ability prove cryptographic security protocols 
step definitions security protocols emphasis simplicity minimality 
minimality means definition aimed making minimal requirements secure protocols losing rigor relevance intuitive notion security 
build formalization convenient flexible 
particular approach underlying formalization number quite varied settings bcg cg hm bck 
consider composition protocols 
important obligatory property definition secure protocols guarantee protocol obtained properly composing secure protocols secure 
needed designing cryptographic protocols modular way proving security clear understandable manner 
particular property greatly simplify proofs security known constructions 
show definition security provides guarantee standard settings respect natural composition operation suggested 
previously definition known preserve security composition operation settings 
hope results techniques contribute writing easy follow proofs security known protocols gmw bgw bck 
gl concentrates general task evaluating probabilistic function parties inputs 
task known secure function evaluation 
addition definitional approach readily applied capturing security requirements variety tasks 
previous definitional efforts common paradigm underlying efforts define secure protocols guarantee running secure protocol just carrying idealized computational process security guaranteed 
context secure function evaluation ideal process consists having parties hand inputs trusted party locally evaluates function hands appropriate portion function value party 
definitional efforts differ method basic paradigm fleshed 
sketch approaches gl 
elaborate definitions appendix definition goldwasser levin gl explicit comparison ideal process 
definition viewed making comparison ideal process follows 
start defining legal behavior adversary behavior captures adversary limited capabilities ideal process 
define notion robustness protocols essentially means adversary emulated legal 
protocol securely evaluates function robust addition correctly evaluates function adversary limited legal behavior 
comparison ideal process serves strong motivation formulation micali rogaway definition 
explicitly actual definition contains additional technicalities 
technicalities definition restrictive 
micali rogaway define general natural composition operation protocols state definition preserved composition operation 
composition operation discussed essentially taken 
previously believed extra restrictiveness definition necessary proving composition preserves security 
show case 
consider protocols evaluate deterministic functions secure channels setting 
secure channels setting defined sequel 
micali rogaway manuscript quite comprehensive contains enlightening observations discussions examples regarding secure multi party protocols 
benefited lot reading attending 
beaver comparison protocol ideal process explicit 
general notion comparing security protocols formulated 
protocol evaluating function considered secure secure ideal process evaluating function 
approach similar taken technical differences explained sequel 
addition stated security definition preserved sequential composition 
secure protocols invoked inputs local outputs previous resulting protocol securely evaluates composed function long intermediate results part output 
seen composition operation special case considered 
definitional approach taken formalize ideal process mentioned 
process aimed capturing desired functionality task hand particular rules unwanted behavior 
task secure function evaluation ideal process formulated follows 
communication parties parties hand inputs trusted party locally computes desired outputs hands back parties 
ideal process adversary controlling set corrupted parties limited essentially learns modifies inputs outputs corrupted parties 
say protocol securely performs task hand executing protocol model distributed computation amounts emulating ideal process task 
emulating ideal process interpreted follows 
formalize output running protocol adversary distributed model output running ideal process adversary 
formalization key ingredient definition 
running protocol emulates ideal process adversary attacking protocol distributed model exists ideal process adversary manages induce essentially output distribution ideal process 
way assured adversarial effects occur running protocol distributed model explicitly allowed ideal process 
way approach generalization simulation approach rephrasing gm define security encryption functions gmr define zero knowledge protocols 
formulation complex applies complex domain parties 
approach course applied large variety adversary models 
concentrate salient models characterized parameters 
network assumed synchronous communication channels ideally authenticated 
distinctions 
distinction passive active adversaries 
passive adversaries called eavesdropping adversaries gather information modify behavior parties 
adversaries model attacks take place execution protocol completed 
active adversaries called byzantine cause corrupted parties execute arbitrary malicious code 
distinction non adaptive adaptive adversaries 
non adaptive static adversary controls arbitrary fixed set corrupted parties 
adaptive dynamic adversary chooses identities parties corrupted computation information gathered far 
non adaptive adversaries allow simpler formalization protocols 
considering adaptive adversaries forces protocols address security concerns important real world situations addressed non adaptive formalization 
see discussion preamble section 
distinction computational setting adversary learns communication parties restricted probabilistic polynomial time secure channels setting channels absolutely secure adversary unlimited computational power 
obtaining protocols secure secure channels setting regarded stepping stone way obtaining secure protocols realistic computational setting 
variations settings may course interesting 
instance works assume authenticated broadcast channel guaranteed message received party received parties 
setting adversary probabilistic polynomial time learns messages sent corrupted parties convenient designing protocols ch 
definitions easily adapted settings 
models concentrate case honest majority strictly half parties corrupted time 
half parties corrupted definition weakened somewhat 
essentially active adversary prevented interrupting computation time 
general definitional approach remain largely unchanged 
see gmw bg gl definitions protocols case dishonest majority 
differences previous definitions 
inspired micali rogaway approach quite closely formalization differs aspects 
highlight points difference 
longer necessary requirement ideal process adversary operates pass black box simulation real life adversary 
ideal process adversary restricted oracle access real life adversary 
importantly required simulated adversary run 
requirement quite restrictive particular case computationally bounded adversaries essentially prohibits zero knowledge proofs secure protocols 
removing requirement essential treatment computational model 
definition uses similar notion simulation 
fact bit restrictive 
modification relevant case adaptive adversaries treatment information flow single protocol execution external environment 
modeling information flow essential successful treatment secure protocol composition 
definition modeled introducing additional algorithmic entity representing external environment model 
better represent effect external environment single execution particular allows deal composition protocols case computationally bounded adversaries 
see details sections 
modular composition designing protocol task want able break task partial presumably simpler sub tasks design secure protocols sub tasks designed protocols subroutines solution task 
words want support design methodology secure protocols design high level protocol task assuming simpler sub tasks carried securely 
design protocols securely carry simpler sub tasks 
construct full fledged protocol task plugging simpler protocols subroutines high level protocol 
call technique combining protocols modular composition 
modular composition formalized context micali rogaway 
called reducibility protocols want security protocols preserved modular composition 
security full fledged protocol follow security high level design security subroutine protocols specified sub tasks 
words general goal suppose protocols ae ae securely evaluate functions respectively protocol securely evaluates function subroutine calls ideal evaluation protocol ae ae derived protocol replacing subroutine call ideal evaluation invocation protocol ae securely evaluates composition operations protocols considered literature 
instance sequential composition usually means simply running secure protocols parallel composition means running parallel time 
note composition operations regarded special cases modular composition appropriate high level protocol 
consequently consider modular composition main general tool modular protocol design 
achieve goal respect definitions non concurrent case single subroutine invocation execution time 
consider settings described non adaptive adaptive passive active adversaries secure channels computational settings 
particular computational setting time composition theorem stated respect definition 
fact demonstrate slightly general result protocol uses ideal evaluation calls maintains functionality ideal evaluation calls replaced invocations ae ae respectively 
related goldreich presents detailed exposition proof general construction gmw party multi party cases 
treats computational setting non adaptive adversaries 
definitions essentially ones non adaptive case 
general purpose composition theorems composes constructed protocols ad hoc manner 
notion security case deterministic functions non adaptive passive adversaries secure channels setting studied chor kushilevitz ck 
notion security somewhat weaker argued section reducibility protocols notion security ck discussed 
notion reducibility different communication allowed high level protocol invocations specified subroutines 
proofs composition theorem various settings follow adopt general structure sequential composition theorems zero knowledge proven goldreich oren go adapting techniques setting 
organization 
section motivate informally general approach taken definitions 
section reviews basic notions formalize definitions 
section concentrates case non adaptive adversaries secure channels setting 
includes definition security statement composition theorem full proof 
section generalizes treatment section case adaptive adversaries secure channels setting 
attempt keep section self contained possible expense repetition 
section deals adaptive adversaries computational setting 
treatment similar section section self contained read conjunction section 
case non adaptive adversaries computational setting inferred quite easily 
section develop cases passive active adversaries side side emphasis involved case active adversaries 
constructions cases quite different nature corresponding definitions similar best considered 
appendix briefly discuss definitional efforts gl 
text contains number long footnotes 
discuss issues vital main thrust main text fluent 
particular footnotes skipped reading 
defining secure protocols general paradigm section motivates sketches general definitional approach pursued 
approach common various adversary models passive active non adaptive adaptive adversaries secure channels computational settings 
concentrates task secure function evaluation approach carries tasks 
section presents approach task secure function evaluation 
case captures essence problem 
tasks briefly mentioned section 
secure function evaluation secure function evaluation general task parties inputs produce outputs specification cast function inputs 
function probabilistic input specifies distribution corresponding outputs 
focus case minority parties corrupted 
general approach capture security requirements case dishonest majority particular party case 
attempts 
basic requirements come mind trying capture notion secure function evaluation 
correctness parties parties corrupted adversary output correct value function evaluated inputs parties 
requirement somewhat complicated fact function may probabilistic output obey predefined distribution importantly fact adversary active corrupted parties general prevented arbitrarily changing inputs computation 
second requirement secrecy meaning adversary learn interacting parties original inputs corrupted parties correct function values corrupted parties obtain 
requirement call definition notion simulation adversary view case probabilistic encryption zero knowledge gm gmr clear point setting simulator operate required 
naive approach defining security may proceed separately requiring correctness secrecy 
observed decomposition problematic requirements intertwined hand secrecy requirement depends definition correct function value 
hand correctness requirement sure input values corrupted parties contribute computation chosen knowledge inputs uncorrupted parties 
sketch simple example demonstrates issue 
assume parties wish compute exclusive bit inputs protocol party sends input party announces result 
intuitively protocol insecure corrupted influence output choosing value contributes computation input 
protocol maintains secrecy holds vacuously problem party infer input party input function value certainly correct sense output fits input contributes computation 
example highlights problems associated active adversaries 
subtle examples definitions allow active adversary illegally influence outputs uncorrupted parties described 
additional problems arise dealing probabilistic functions 
interestingly problems arise adversary passive 
section contains example highlights problems 
may tempted try augment correctness secrecy requirements handle problems exposed 
approach may difficult errorprone possible 
consequently definition follows different approach blends correctness secrecy single security requirement 
envision ideal process secure multi party function evaluation 
process captures want secure computation particular requirements 
say computation secure emulates ideal process defined manner 
approach 
definition proceeds steps 
formalize real life computation straightforward way 
parties interact protocol specific model distributed computation synchronous asynchronous presence real life adversary controls set corrupted parties behaves adversarial model passive active non adaptive adaptive 
computation uncorrupted parties output specified protocol 
corrupted parties output special symbol specifying corrupted 
adversary controlling corrupted parties outputs arbitrary value value may include output information gathered adversary computation 
ideal process multi party function evaluation formulated order capture requirements secure function evaluation 
specifics ideal process correspond type adversary consideration passive active 
ideal process adversary gets control set corrupted parties fixed chosen adaptively learns inputs corrupted parties 
active adversaries modeled ideal process adversary modify inputs information gathered far 
parties hand possibly modified inputs trusted party 
trusted party evaluates function inputs hands party designated output 
evaluated function probabilistic case trusted party tosses necessary coins uses outcome determine function value 
uncorrupted parties output receive trusted party corrupted parties output special symbol adversary outputs arbitrary value 
adversary output may contain information gathered adversary ideal process 
information limited consists adversary random input identities corrupted parties inputs values received trusted party 
say protocol evaluating function secure emulates ideal evaluation process function sense effect real life computation achieved real life adversary class real life adversaries achieved ideal process ideal process adversary corresponding class ideal process adversaries 
requirement formulated follows 
define ideal real life models global output computation input 
random variable consists concatenation outputs parties adversary 
require real life adversary class attacking secure protocol exists ideal process adversary corresponding class input global output reallife computation presence distributed similarly global output ideal equivalent somewhat natural formalization corrupted parties output instructed adversary adversary output 
formalization convenient sequel 
process computation presence 
defining similarity equal distribution statistical closeness computational indistinguishability obtain different notions security 
requiring outputs corrupted parties distributed similarly ideal process real life computation forces ideal process adversary generate output looks output real life adversary spite fact sees information available ideal process 
guarantees secrecy sense information gathered real life adversary computable ideal process 
requiring output uncorrupted parties similarly distributed ideal process real life computation guarantees correctness sense real life adversary influence outputs corrupted parties possible ideal process 
furthermore combining outputs corrupted uncorrupted parties single random variable guarantees intertwined secrecy correctness requirement discussed satisfied 
see section notion protocol adversary model emulating ideal process naturally extended having protocol emulate protocol adversary model 
extended notion emulation quite useful 
particular plays key role presentation composition theorems 
enabling secure composition 
definitional approach sketched aimed capturing security requirements protocol simplified setting single protocol execution considered vitro 
order guarantee security setting protocol executions may exist particular order closed composition protocols definition security guarantee property adversaries gathered information current execution say protocol executions unable gather additional information current execution gain unwanted advantage 
case non adaptive adversaries property guaranteed letting adversary arbitrary auxiliary input onset interaction 
auxiliary input represents information gathered adversary protocol executions occurring current execution 
notion emulation sketched extended hold auxiliary input 
see details section 
auxiliary inputs introduced go context sequential composition zero knowledge proofs 
discussion appears 
case adaptive adversaries information flow single protocol execution executions fully captured piece information onset execution 
nutshell problem party gets corrupted adversary protocol execution execution completed adversary sees internal data party execution protocol executions run party 
model information flow introducing additional algorithmic entity representing external environment real life ideal models 
entity interacts adversary parties points execution 
points environment provides adversary additional information receives information adversary 
notion emulation adapted follows protocol emulates ideal process evaluating securely evaluates real life adversary class real life adversaries environment exist ideal model adversary corresponding class ideal process adversaries effect environment parties running emulated ideal model evaluating environment see details section 
secure function evaluation secure function evaluation general task capture interesting functionalities cryptographic protocols 
elaborate bit 
cryptographic tasks reactive sense phases output phase may part input phase security task imposes requirements outputs phases taken 
examples include commitment secret sharing complex tasks encryption signature schemes key processing messages 
addition requirement secure protocol evaluates predefined function inputs may restrictive cryptographic tasks securely carried protocols evaluate pre defined function inputs 
protocols guarantee input output relation satisfied 
definitional approach described section adapted capture security requirements tasks 
fact definitions literature capture security requirements tasks regarded examples adaptation 
examples include tasks distributed proactive signature schemes key exchange authentication bck distributed public key encryption cg 
sub section sketches general paradigm underlies definitions possibly capture security requirements cryptographic tasks 
idea proceed steps follows 
formulate ideal model executing task hand 
typically ideal model involves trusted party functionality captures security requirements task 
functionality typically involve repeated interaction parties 
important ingredient step defining global output execution ideal model 

formalize global output execution protocol real life model consideration 

say protocol securely performs task hand emulates execution ideal model usual way real life adversary exist adversary global output running real life model distributed similarly global output running ideal model 
case adaptive adversaries notion emulation extended include environment machine sketched 
preliminaries section review basic notions underlie formalization definitions 
distribution ensemble fx infinite sequence probability distributions distribution associated values domain 
typically distribution ensembles consider sequel outputs computations ideal real life model parameter corresponds various types inputs parameter taken security parameter 
complexity characteristics constructs measured terms security parameter 
particular interested behavior constructs security parameter tends infinity 
definition equal distribution say distribution ensembles equally distributed write distributions identical 
slightly abusing notations denote distributions identical 
say function ffi negligible large ffi gammac definition statistical indistinguishability ffi 
distribution ensembles statistical distance ffi sufficiently large sd ffi sd denotes statistical distance total variation distance sd gamma prob 
ffi negligible function say statistically indistinguishable write definition computational indistinguishability gm ffi 
say distribution ensembles computational distance ffi algorithm probabilistic polynomial time input sufficiently large auxiliary information gamma prob ffi chosen distribution chosen distribution probabilities taken choices random choices ensembles computational distance gammac say computationally indistinguishable write note definition gives distinguisher access arbitrary auxiliary information string making definition non uniform complexity 
stressed fixed random choices 
multiparty functions 
functions evaluated parties formalized follows 
party function probabilistic function theta theta input security parameter input taken random input 
interested functions computable time polynomial security parameter 
particular lengths inputs outputs assumed bounded polynomial security parameter 
see complete discussion conventions regarding functions 
extending treatment complex multiparty function requires small technical modifications 
intuitively party functions interpreted follows 
mean element drawn uniformly random domain denote ith component 
party input wishes evaluate value determined security parameter 
concreteness concentrate inputs random inputs domains finite infinite encoded standard ways 
non adaptive adversaries discussed preamble section non adaptive security security non adaptive adversaries considerably weaker adaptive security 
non adaptive case full 
done reasons 
definition especially proof composition theorem considerably simpler non adaptive case 
warmup adaptive case 
second important protocols literature gmw known secure non adaptive adversaries see 
treatment case independent interest 
section restrict secure channels setting adversary may computationally unbounded learns messages sent corrupted parties 
section show treatment adapted settings secure channels exist security provided probabilistic polynomial time adversaries 
section contains definition secure protocols 
discussion definition section 
section presents composition theorem proven section 
definition security non adaptive case define secure protocols non adaptive case 
definitions passive active adversaries developed side side noting differences presentation 
outline section formalize real life model describe ideal process notion emulation ideal process computation real life model 
real life model 
party protocol collection interactive probabilistic algorithms 
formally algorithm interactive turing machine defined gmr 
term party refer ith algorithm 
party computer executes ith algorithm 
party starts input random input security parameter informally envision parties connected private communication channel 
complete description communication parties 
non adaptive real life adversary interactive computationally unbounded turing machine describing behavior corrupted parties 
adversary starts input contains identities corrupted parties inputs 
addition receives additional auxiliary input value security parameter 
denote input 
auxiliary input standard tool allows prove composition theorem 
see section discussion 
addition random input 
say adversary limited controls parties 
formally limited adversary halts input contains identities corrupted parties 
view number parties independent security parameter allows discussing cases small respect security parameter constant cases tends infinity fixed relation furthermore note parties necessarily know advance 
adversary computationally unbounded need probabilistic 
fact formalization security requirement non uniform complexity 
setting deterministic adversaries powerful probabilistic adversaries comparable complexity 
find conceptually appealing formulate definition terms probabilistic adversaries 
concentrates limited adversaries threshold value 
assumed sequel slightly formal language describing participating entities computation 
formal description terms interactive turing machines easily extracted 
computation proceeds rounds round proceeds follows 
description captures fully connected ideally authenticated synchronous network rushing 
term rushing refers allowing corrupted parties learn messages sent uncorrupted parties round sending messages round 
uncorrupted parties generate messages round described protocol 
messages appear outgoing communication tapes uncorrupted parties 
messages addressed corrupted parties known adversary appear adversary incoming communication tape 
adversary generates messages sent corrupted parties round 
adversary passive messages determined protocol 
active adversary determines messages sent corrupted parties arbitrary way 
uncorrupted party receives messages addressed round messages addressed appear incoming communication tape 
computation parties locally generate outputs 
uncorrupted parties output specified protocol 
corrupted parties output special symbol specifying corrupted 
parties participate computation 
addition adversary outputs arbitrary function view computation 
adversary view consists auxiliary input random input followed corrupted parties inputs random inputs messages sent received corrupted parties computation 
loss generality imagine adversary output consists entire view summarizes real life computational process 
notation 
denote output real life adversary auxiliary input interacting parties running protocol input random input security parameter described party 
exec denote output party execution 
recall uncorrupted output specified protocol corrupted exec 
exec exec exec exec denote probability distribution exec uniformly chosen 
exec denote distribution ensemble zi 
zi denotes natural encoding single string 
ideal process 
ideal process parameterized function evaluated 
party function theta theta 
defined section 
party input security parameter random input needed 
recall parties wish evaluate value determined security parameter learns non adaptive ideal process adversary adversary corrupt subset parties 
type corruption structures chosen simplicity exposition 
definitional methodology holds respect general corruption structures hm cdm non adaptive adaptive cases 
different models representing different real life communication settings network topologies course possible 
particular concerned feasibility results concerned efficiency may simpler parties talk round robin communication round single party sends messages 
sake generality restrict simpler model 
execution party protocol parties adversary 
party starts security parameter input random input 
adversary starts random input input includes set ae corrupted parties inputs fx ji cg additional auxiliary input 

initialize round number 
long exists uncorrupted party halt repeat uncorrupted party generates fm jj possibly empty message intended party round 
adversary learns fm ji cg generates fm ji cg 
uncorrupted party receives messages fm jj 

uncorrupted party generate output 
output corrupted parties set 
summary non adaptive real life computation 
interactive computationally unbounded turing machine describing behavior corrupted parties 
adversary starts input includes identities inputs corrupted parties random input auxiliary input security parameter addition trusted party knows ideal process proceeds follows 
input substitution ideal process adversary sees inputs corrupted parties 
active may alter inputs information known far 
jcj vector altered inputs corrupted parties vector constructed input substituting entries corrupted parties corresponding entries passive substitution computation party hands possibly modified input value trusted party chooses hands value output uncorrupted party outputs corrupted parties output 
addition adversary outputs arbitrary function information gathered computation ideal process 
information consists adversary random input corrupted parties inputs resulting function values ff 
denote output ideal process adversary security parameter random input auxiliary input interacting parties having contrast real life adversary essential ideal process adversary probabilistic 
holds non uniform complexity setting 
need explicitly limit number corrupted parties ideal process 
definition guarantee identities corrupted parties ideal process identical identities corrupted parties real life model 
formalization means rf internal random choices remains unknown parties information provided value input trusted party evaluating random input vector ideal ideal ideal denote outputs parties inputs adversary random inputs described outputs ideal 
ideal denote distribution ideal uniformly distributed 
ideal denote distribution ensemble zi comparing computations models 
require protocol emulates ideal process evaluating sense 
limited real life adversary exist ideal process adversary ideal exec spelled requirement means value security parameter input vector auxiliary input global outputs ideal exec identically distributed 
require complexity ideal process adversary comparable polynomial computational complexity real life adversary introducing complexity issues seemingly information theoretic model may appear awkward place glance 
second inspection verify requirement desirable 
see section 
definition non adaptive security secure channels setting party function protocol parties 
say non adaptively securely evaluates non adaptive limited real life adversary exists non adaptive ideal process adversary running time polynomial running time ideal exec passive adversaries say non adaptively privately evaluates relaxed variants definition obtained requiring sides statistically indistinguishable computationally indistinguishable 
relaxation aimed case adversary assumed probabilistic polynomial time 
furthermore definition satisfied exception sides statistical resp computational distance ffi say protocol achieves statistical resp computational distance ffi 
discussion section contains discussion definition 
case inputs taken finite domain equal distribution required simpler formalization introduce ensembles sufficient 
basically simpler formalization fixes security parameter arbitrary value 
current formalization order accommodate infinite input domains indistinguishability ensembles computationally bounded adversaries 
implicitly assume complexity protocol run uncorrupted parties bounded polynomial complexity adversary 
case allowed polynomial complexity complexity ideal process adversary 
motivate requirement running time ideal process adversary polynomial real life adversary seemingly information theoretic setting 
ideal process adversary imaginary concept purpose formalize requirement gain adversary obtains interacting parties running obtained ideal setting trusted party 
arguably requirement means interacting allow adversary obtain gain free obtaining gain ideal process requires considerable computational resources 
aspect security requirement captured appropriately limiting computational power ideal process adversary 
seen failing results considerably weaker notion security 
weaker notion may interest studying purely information theoretic aspects secure computation 
illustrate distinction example 
phi way permutation phi denotes bitwise exclusive 
assume parties inputs respectively consider protocol evaluating party announces party announces parties evaluate 
intuition protocol insecure adversaries may corrupt party say gives away free computing may take adversary large amount time 
real life ideal process adversaries limited probabilistic polynomial time way permutations exist protocol secure adversaries corrupt party 
allowed unlimited computational power regardless complexity protocol considered secure invert distinction notions constructing protocols computational setting 
convenient design paradigm secure protocols setting proceeds follows design secure protocol secure channels setting 
construct protocol encrypting message 
readily seen secure secure channels setting definition appropriate encryption scheme secure computational setting 
weaker notion security transformation necessarily 
definitions secure protocols distinction 
examples include definition definition private protocols ck 
protocols described works secure definition 
fact aware protocols literature proven secure weaker definition insecure definition 
combining correctness secrecy 
requirement definition global outputs computations equally distributed imposes requirements ideal process adversary 
particular implies secrecy 
output real life adversary distributed equally output adversary 
correctness 
outputs uncorrupted parties equally distributed models 
definition weakened require global output ideal process satisfies 
argued section separately requiring secrecy correctness restrict instance semantically secure encryption gm sufficient non adaptive model provided different pair public private keys pair parties 
omit details 
influence adversary outputs uncorrupted parties resulting unsatisfactory definitions 
weakened definition proposed combine correctness secrecy extent ideal process adversary satisfy requirements 
example protocol section examples insecure weakened definition 
argue entire vectors describing global outputs computations identically distributed suffice separately require relevant projections global outputs identically distributed 
point demonstrated example consider parties wish evaluate party function 
parties empty input output random bit empty output 
course simply output random bit interaction consider protocol sends value output 
instructed ignore message output 
protocol clearly insecure satisfies weakened definition 
put words example highlights additional weakness separating correctness secrecy requirements top weakness discussed section 
discussion section concentrates problems related active adversaries example highlights problems related probabilistic functions 
particular insecure protocol suggested satisfies weakened definition adversary passive 
means dealing probabilistic functions secrecy correctness separately required passive adversaries 
pass black box simulation 
notion emulation restrictive respects 
required ideal process adversary restricted having black box access real life adversary 
substantially adversary run 
call type simulation pass black box 
second restriction quite limiting 
particular computational setting prohibits usage zero knowledge protocols secure protocols 
demonstrating zero knowledge property black box simulation requires adversary 
speculated implicitly restricting ideal process adversary pass black box simulation needed order prove general composition theorem 
show modular composition theorem holds non concurrent case ideal process adversary restricted black box simulation 
recall context zero knowledge existence black box simulator implies existence simulator adversaries arbitrary auxiliary input go 
technique seen similar result holds respect definition 
universal adversaries 
auxiliary input quantification auxiliary inputs quantification real life adversaries unnecessary suffices consider single real life adversary universal adversary adversary receive auxiliary input description arbitrary adversary machine run 
note complexity running slightly complexity sketch proof 
case corrupted straightforward 
corrupted real life adversary controls construct ideal process adversary run copy giving random bit output output outputs 
bit different probability half output execution equation satisfied 
long outputs parties considered separately simulation valid 

consequently order show security protocol suffices show single ideal process adversary satisfies definition respect consequence observation follows 
may wish strengthen definition require exists efficient transformation real life adversaries corresponding ideal process adversaries 
argument shows strengthening unnecessary 
initially adaptive adversaries 
consider variant definition 
having set corrupted parties adversary part input adversary real life ideal models choose identities corrupted parties adaptive way restriction corruptions communication takes place parties 
call model initially adaptive 
observe security initially adaptive model equivalent security nonadaptive model definition 
intuitively follows fact point message sent real life ideal models identical 
advantage non adaptive adversaries gained real life model ability adaptively corrupt parties interaction starts gained initially adaptive ideal model 
sketch proof follows 
clearly initially adaptive security implies non adaptive security 
argument similar section assume protocol secure definition initially adaptive real live adversary 
construct initially adaptive ideal model adversary emulates adversary standard non adaptive real life model gets auxiliary input internal state point done corrupting parties runs state 
ideal model adversary guaranteed definition emulates construct ideal model adversary follows 
follows ideal model corruption instructions oe state ready start interacting parties 
runs state oe auxiliary input 
seen valid initially adaptive ideal model adversary emulates related inputs 
definition requires protocol behave properly set inputs parties 
real world situations participants expect inputs correlated way say parties common input inputs taken certain distribution requirements protocol case inputs expected form 
definition relaxed accommodate weakened security properties placing appropriate restrictions domain inputs parties 
alternatively evaluated function re defined return error value cases inputs appropriate domain 
modular composition non adaptive case recall want break task protocol problem partial sub tasks design protocols partial sub tasks protocols subroutines solution task 
purpose want formalize prove informal goal stated 
non concurrent case subroutine call communication round 
section concentrates non adaptive adversaries secure channels setting 
formalization derivation composition theorem done steps 
state general theorem holds protocol protocols securely evaluate functions replacing ideal evaluation calls sub protocols securely evaluate corresponding functions results protocol essentially input output functionality composition theorem follows easy corollary 
hybrid model 
start specifying model evaluating party function assistance trusted party evaluating party functions define secure protocols model 
model called hybrid model ideal access short hybrid model obtained follows 
start real life model section 
model augmented trusted party evaluating trusted party invoked special rounds determined protocol 
simplicity exposition assume number ideal evaluation calls rounds ideal calls take place functions evaluated depend security parameter 
addition assume number different ideally evaluated functions fixed 
round function specified 
computation special round mimics ideal process 
parties hand inputs party hands 
ideal process active adversary decides input values corrupted parties hand trusted party 
adversary passive corrupted parties hand values protocol 
parties handed back respective outputs gets random input fresh randomness ideal evaluation call 
exec denote random variable describing output computation hybrid model protocol adversary security parameter inputs auxiliary input adversary analogously definition exec section 
stress hybrid real life protocol ideal evaluation calls exec denote distribution ensemble zi replacing ideal evaluation call subroutine call 
describe mechanics replacing ideal evaluation call protocol round invocation party protocol ae 
done straightforward way 
description round modified follows 
rounds remain unaffected 

onset round party saves internal state relevant protocol special tape 
oe denote state 

call trusted party replaced invocation code protocol ae 
party input random input ae determined follows 
input ae set value hand trusted party round protocol random input ae uniformly chosen appropriate domain 

completes execution protocol ae local output ae resumes execution protocol round starting state oe exception value received set ae restrictions circumvented number ways 
instance imagine round parties ideal evaluation call universal function defined follows 
party hands trusted party description party function input majority parties agree handed null value returned 
convention allows apply composition theorems protocols parties decide adaptive way say agreement protocol number ideal evaluation calls function evaluated different calls 
ae ae denote protocol originally designed hybrid model ideal evaluation call replaced subroutine call protocol ae stressed uncorrupted party resumes execution protocol current execution protocol ae completed 
furthermore assume uncorrupted parties terminate execution ae round 
parties may resume executing calling protocol execute subroutine protocol non concurrency condition violated 
theorem stated takes somewhat different approach composition operation informal theorem 
require security properties protocol essentially states input output functionality protocol hybrid model successfully emulated ae ae real life model 
top somewhat straightforward general statement relevant cases performs task secure function evaluation 
theorem non adaptive modular composition general statement party functions 
party protocol hybrid model ideal evaluation call round ae ae party protocols ae non adaptively securely resp privately evaluates ae ae composed protocol described 
non adaptive limited active resp passive reallife adversary exists non adaptive active resp passive adversary hybrid model running time polynomial running time exec exec ae ae completeness rigorously state informal goal stated 
define protocols securely evaluating function hybrid model 
done usual comparison ideal process definition party functions protocol parties hybrid model 
say non adaptively securely evaluates hybrid model non adaptive limited adversary hybrid model exists non adaptive ideal process adversary running time polynomial running time ideal exec passive adversaries say non adaptively privately evaluates hybrid model 
corollary non adaptive modular composition secure function evaluation party functions 
party protocol securely resp privately evaluates hybrid model consider instance example 
parties wish evaluate function output input output input empty output 
assume hybrid model ideal access function outputs input protocol evaluating hybrid model instructs parties ideally evaluate party instructed send input 
easy see securely evaluates hybrid model 
ae protocol securely evaluates protocol ae takes rounds complete party completes ae round 
assume sends input soon done execution ae particular completed execution ae 
case corrupted may able influence output ways depend input 
protocol ae insecure ae secure 
ideal evaluation call round ae ae party protocols ae non adaptively securely resp privately evaluates protocol ae ae securely resp privately evaluates proof non adaptive limited real life adversary interacts parties running ae ae theorem guarantees exists adversary hybrid model exec exec ae ae security hybrid model guarantees exists ideal model adversary simulator ideal exec corollary follows combining equalities 
proof theorem prove theorem case active adversaries security 
case passive adversaries privacy obtained appropriately current proof 
addition treat case trusted party called 
case multiple functions multiple non concurrent calls straightforward extension treated proof 
section contains outline proof 
body proof section 
section contains extensions proof theorem 
proof outline party function party protocol hybrid model ae protocol securely evaluates ae composed protocol 
non adaptive real life adversary interacts parties running ae wish construct adversary hybrid model simulates behavior satisfy exec ae exec plan carrying proof proceeds follows 

construct real life adversary denoted ae operates protocol ae stand protocol 
security ae guarantees ae simulator ideal process adversary ae exec ae ae ideal ae 
ae construct adversary operates protocol standalone protocol hybrid model 
show satisfies 
sketch steps 
way ae represents segment interacts protocol ae 
ae starts set corrupted parties inputs parties auxiliary input 
expects auxiliary input describe internal state controlling parties interacting parties running protocol ae round ae ae invoked 
auxiliary input improper ae halts 
ae interacts network simulating run state instructions 
interaction parties running ae adversary ae outputs current state simulated adversary represents segment interacts protocol interaction ae replaced interaction ae starts invoking copy instructions round ae point expects interact parties running ae interacts parties invoke trusted party ideal evaluation continue execution adversary runs ae purpose ae auxiliary input describes current state round ae information ae trusted party emulated trusted party recall output ae simulated internal state completion protocol ae 
protocol ae completes execution parties return running adversary returns running starting state ae output follows instructions terminates outputs outputs 
address detail regarding construction details left sketch 
adversary runs ae expects see inputs corrupted parties protocol ae know values 
fact values may defined execution ae answer apparent difficulty simple matter values hands ae inputs corrupted parties 
simulation valid inputs set arbitrary values say value 
intuitively reason construct ae way look input values 
output ae consequently output ae independent arbitrary input values 
detailed proof adversary interacting parties running ae 
constructions adversaries ae analyze showing 
inevitable terminology 
execution protocol real life hybrid model process running protocol adversary inputs random inputs auxiliary input adversary 
hybrid model execution determined random choices trusted party internal state configuration uncorrupted party round execution consists contents tapes party head position control state taken round 
particular internal state includes messages sent party round 
assume internal state includes entire random input party computation including unused parts 
internal state adversary defined similarly 
global state system round execution concatenation internal states parties adversary round 
denote internal state round adversary auxiliary input interacting parties running protocol input random input security parameter described party 
denote internal state party round execution 
corrupted 
gs gs denote probability distribution gs uniformly chosen 
note global state system round execution uniquely determines continuation execution round completion protocol 
particular global output system uniquely determined global state round 
assume encoding convention internal states strings 
string said internal state party round encodes internal state round 
loss generality assume string encodes internal state 
sequel distinguish internal states encodings 
running adversary internal state means simulating run starting internal state described recall contains information needed simulation particular contains necessary randomness 
construction ae construction follows outline described 
specifically adversary ae proceeds described adversary adversary ae adversary ae interacting parties pn running protocol ae starts value security parameter set corrupted parties inputs random inputs parties auxiliary input ae 
ignore input values corrupted parties 

ae round protocol ae starts running protocol ae 
round calls trusted party 
verify auxiliary input ae valid internal state controlling parties round ae gamma 
ae valid halt output 
run internal state ae denote imaginary set parties interacts 
uncorrupted party running ae sends message corrupted party ae lets simulated see message sent party running ae party 
instructs corrupted party send message uncorrupted party adversary ae instructs party send message party 
halts ae outputs current internal state halts 
description adversary ae non adaptive model follows security protocol ae exists ideal process adversary ae ideal ae exec ae ae note ae deterministic randomness provided auxiliary input ae simulator ae inherently probabilistic generate distribution ensemble equal exec ae ae particular mimic randomness uncorrupted parties running ae 
observe special structure ae implies ae additional property described follows 
recall ae ignores inputs corrupted parties sense actions output depend input values 
particular copy run ae affected values 
distribution output ae global output system running ae ae remains unchanged set input values corrupted parties 
consequently distribution global output ideal process evaluating ae property 
formalize discussion follows 
input vector ae ae denote vector obtained replacing inputs corrupted parties 
claim value security parameter input vector ae auxiliary input ae ideal ae ae ae ideal ae ae ae proof argued exec ae ae ae ae exec ae ae ae ae ideal ae ae ae exec ae ae ae ae ideal ae ae ae exec ae ae ae ae 
claim follows 
construction adversary follows outline described section 
specifically proceeds described 
adversary adversary interacting parties pn running protocol access trusted party evaluating starts value security parameter set corrupted parties inputs random inputs parties auxiliary input 
invoke follow instructions round ae gamma 
recall far ae identical 
addition keep piece random input side 
piece denoted ae 

onset round ae expects start interacting parties running protocol ae subroutine parties pn call trusted party ideal evaluation function order continue run invoke simulator ae follows 
ae set corrupted parties 
inputs parties set random input set ae 
recall inputs corrupted parties affect distribution global output evaluating ae auxiliary input ae ae set current internal state 
ae hands trusted party inputs corrupted parties asks evaluated values invoke trusted party input values corrupted parties hand value provided trusted party back ae 
recall output ae internal state execution ae 
output denoted generated run internal state return instructions completion protocol 
protocol completed output outputs halt 
description adversary non adaptive model 
analysis evident running time linear running time plus running time ae plus running time ae fix input vector auxiliary input parties adversary value security parameter 
particular set corrupted parties fixed 
steps iii demonstrate exec ae exec establishes theorem case single ideal evaluation call 
equation rest proof symbol denote equality distributions ensembles 
set additional notation 
recall ae round protocol ideal evaluation call protocol ae invokes ae 
vectors ae ae ae interpreted random input execution ae execution ae ae interpreted random input execution ae ae ae ae denote combination ae full random input vector execution ae 
party uses ae execution ae execution adversary uses ae execution ae rounds 
similarly interpreted random vector round ae hybrid model random input adversary round random input trusted party denote combination full random input vector execution hybrid model 
step round ae gamma protocols ae behave 
fix value random input system 
gs ae ae gamma gs ae gamma step ii 
show global state hybrid model round ae distributed identically global state real life model round protocol ae returns 
done sub steps follows 
recall value fixed step 

assert parameters set hybrid model ideal evaluation identical parameters set real life model invocation ae 
ae ae ae ae determined follows 
uncorrupted ae input value protocol ae determined gs ae ae gamma 
corrupted ae 
ae denote internal state round ae gamma execution 
similarly denote value party hands trusted party determined gs ae gamma denote internal state code round ae gamma execution 
follows equation ae ae 
assert global output execution ae implicit run ae adversary distributed identically global output ideal evaluation implicit round ae run hybrid model 
security ae step ii claim exec ae ae ae ae ideal ae ae ae ideal ae ideal ae 
show global state hybrid model round ae distributed identically global state real life model protocol ae returns 
denote round call protocol ae returns protocol ae 
follows definition ae constructions ae ae random input vector protocol ae 
gs ae ae obtained gs ae ae gamma exec ae ae ae ae ae simple deterministic process denoted 
essentially process combines updates internal states adversary parties 
precisely process modifies internal state ae ae gamma adding exec ae ae ae ae ae appropriate place 
outputs internal state appears ae output exec ae ae ae ae ae appends modified internal states uncorrupted parties 
random input vector ideal process evaluating global state gs ae obtained gs ae gamma ideal ae process real life model 
follows value vectors ae uniformly chosen respective domains gs ae ae gs ae 
randomly chosen domain 
follows gs ae gs ae step iii 
assert equation 
resumption protocol adversary returns instructions consequently distributions exec ae exec obtained applying process corresponding sides 
completes proof case single ideal evaluation call 
multiple ideal evaluation calls 
case multiple ideal evaluation calls straightforward generalization case single call 
sketch main points difference 
adversary ae constructed protocol ae ae identical adversary ae described exception protocol ae replaced ae 
ae ae ae ae 
construct adversary identical described exception round instructs parties ideally evaluate adversary runs copy ae way runs ae auxiliary input ae set current internal state simulated 
note may invocations simulator ae invocation corresponds different ideal evaluation call invocations different auxiliary inputs 
separate piece random input invocation ae 
case single ideal evaluation call evident running time linear running time plus sum running times invocations ae ae plus running time ae ae showing exec ae ae exec done steps follows 
denote round protocol jth ideal evaluation call hybrid model 
argument step demonstrates global states round gamma identical executions 
proceed steps apply argument step ii establish global state hybrid model round distributed identically global state real life model round jth subroutine call ae returns 
apply argument step iii establish global state hybrid model round gamma distributed identically global state real life model round th subroutine call 
execution completed making th subroutine call established exec ae ae exec required 
extensions propagation statistical distance 
somewhat relaxed versions definitions allows sides statistically indistinguishable equally distributed 
note composition theorem holds case 

theorem holds exception sides statistically indistinguishable 
specifically case single ideal evaluation call protocol ae achieves statistical distance ffi statistical distance sides ffi 
construction analysis remain unchanged exception leftmost distributions statistical distance ffi case multiple ideal evaluation calls total statistical distance sides sum statistical distances achieved individual protocol invocations composed protocol 
protocol ae achieves statistical distance ffi invoked times total statistical distance sides delta ffi 
corollary holds exception sides statistically indistinguishable 
specifically case single ideal evaluation call protocol ae achieves statistical distance ffi protocol achieves statistical distance ffi protocol ae achieves statistical distance ffi ffi case multiple ideal evaluation calls statistical distance achieved ae ae sum statistical distances achieved individual protocol invocations plus statistical distances achieved hybrid model 
assume protocol achieves statistical distance ffi hybrid model protocol ae achieves statistical distance ffi invoked times 
protocol ae ae achieves statistical distance ffi delta ffi computational indistinguishability 
composition theorem holds case sides computationally indistinguishable 
defer treatment case section 
black box simulation 
straightforward extension proof corollary shows additional result 
assume security protocol hybrid model proven black box simulation see section 
security protocol ae proven black box simulation 
furthermore simulator associated rewind adversary simulator associated ae rewind 
note additional requirements protocol ae 
particular security protocol ae need proven black box simulation 
reader may notice fact communication links ideally secure play central role proof theorem 
proof technique trivial modifications valid setting adversary sees communication parties 
see details section 
adaptive adversaries section defines secure protocols presents proves composition theorem case adaptive adversaries 
definition adaptive security protocols proof composition theorem case considerably complex non adaptive case 
furthermore proving adaptive security protocols typically harder 
start motivation complex model 
adaptive security looks natural extension non adaptive security second look reveals important differences models security concerns capture 
informally non adaptive model captures scenarios parties trust believe parties remain 
adversary imaginary concept represents collection bad parties 
contrast adaptive model captures scenarios parties may corrupted course computation accord realistically external break 
adversary models actual entity takes active part computation 
external attackers ability adaptively break parties impose viable security threat existing systems networks 
non adaptive security implied adaptive security see section 
converse hold 
particular non adaptive model captures security concerns regarding cryptographic protocols fails capture important concerns addressed adaptive model 
concern need deal fact adversary may communication decide parties worth corrupting 
see 
concern relates fact adversary may gain considerable advantage seeing internal data parties corruption break computational steps taken place 
means data kept uncorrupted parties regarded safe threat data exposed play important part security analysis protocol 
see section 
section attempts self contained possible price repetition 
cases text similar non adaptive case immediate modifications note changes corresponding parts section 
section restrict presentation secure channels setting 
computational setting dealt section 
section contains definition secure protocols 
remarks section footnotes section relevant repeated 
addition section holds remarks specific adaptive case 
section presents composition theorem proven section 
definition security adaptive case non adaptive case develop definitions cases active passive adversaries side side noting differences presentation 
describe real life model describe ideal process definition essentially notion emulation non adaptive case 
obvious difference definition non adaptive security adversary limiting advantage gained adversary exposing secret data parties called forward secrecy literature 
context key exchange instance forward secrecy refers preventing adversary learning corrupting party keys longer dow 
adaptive setting provides framework analyzing forward secrecy protocols 
chooses identities corrupted parties adaptive way corruption sees internal data corrupted party 
see discussion point sequel 
additional technical difference way interaction outside environment single protocol execution captured 
non adaptive case interaction captured parties inputs outputs plus auxiliary input adversary computation starts 
representation sufficed proving composition theorem 
adaptive case additional way external environment interacts protocol execution adversary corrupts party sees party entire internal state including state protocol executions involve party 
fact manifestations 
consider protocol execution part larger protocol involving protocol executions 
party corrupted execution adversary sees party internal state protocol executions completed uncompleted ones 
information flows execution outside environment 
second party corrupted protocol execution adversary sees party internal state relevant execution 
information flows execution outside environment 
particularly problematic case corruptions occur execution completed 
model information flow introduce additional entity representing external environment real life model ideal process 
entity called environment denoted interactive turing machine interacts adversary parties way described 
notion emulation extended include environment 
real life model 
multiparty protocols defined non adaptive case 
party protocol collection interactive probabilistic algorithms ith algorithm run ith party 
formally algorithm interactive turing machine defined gmr 
input random input security parameter informally envision parties connected private communication channel 
complete description communication parties 
adaptive real life adversary computationally unbounded interactive turing machine starts random input 
environment computationally unbounded interactive turing machine denoted starts input random input 
certain points computation environment interacts parties adversary 
points type interaction specified 
adversary limited corrupts parties 
onset computation receives initial information 
information corresponds auxiliary information seen non adaptive case 
computation proceeds computational model 
concreteness specify synchronous rushing model computation 
computation proceeds rounds round proceeds mini rounds follows 
mini round starts allowing corrupt parties adaptive way long parties corrupted altogether 
behavior system corruption party described 
chooses uncorrupted party activated round activates 
activation receives messages sent previous round generates messages round mini round begins 
learns messages sent corrupted parties 
uncorrupted parties activated generates messages sent corrupted parties activated round round begins 
party corrupted party input random input entire history messages sent received party known 
amount information seen adversary corrupting party important parameter definition 
see discussion section addition learns identity corrupted party hands additional auxiliary information 
intuitively information represents party internal data protocols run newly corrupted party 
point learns messages received party 
passive corrupted parties continue running protocol active byzantine party corrupted follows instructions regardless protocol computation say pre determined round parties locally generate outputs 
uncorrupted parties output specified protocol 
corrupted parties output 
addition adversary outputs arbitrary function internal state 
loss generality imagine adversary output consists information seen execution 
includes random input information received environment corrupted parties internal data messages sent received corrupted parties computation 
post execution corruption process begins 
process models information current execution gathered environment corrupting parties execution completed 
learns outputs parties adversary 
interact rounds round generates corrupt request hands request receipt request hands arbitrary information 
intuitively information interpreted internal data 
stressed parties corrupted requests corrupt parties case ignores requests interaction continues halts output 
loss generality output entire view interaction parties 
global output defined output said may include outputs parties adversary 
see discussion role environment section 
computational process real life model summarized 
notation 
global output exec denote output input random input security parameter interacting adversary parties running protocol inputs random input security parameter described party 
exec denote random variable describing exec uniformly chosen 
exec denote distribution ensemble exec zi 
formalization global output exec different non adaptive case global output contains output environment 
complex formalization global output contains concatenation outputs parties adversary yield equivalent definition environment sees outputs parties adversary 
choose current formalization simplicity 
ideal process 
ideal process parameterized function evaluated 
party function theta theta 
defined section 
party input random input needed 
recall parties wish evaluate value determined security sake simplicity restrict way computes data provided adversary corruption party 
note somewhat weaker definition data fixed computation starts remains unknown adversary party corrupted sufficient capturing security proof composition theorems 
execution party protocol parties adversary environment 
party starts security parameter input random input 
adversary starts random input environment starts input random input 
initialize round number 
receives initial message 
long exists uncorrupted party halt long exists uncorrupted party activated round long decides corrupt parties chooses party corrupt 
learns identity receives input random input messages received interaction 
addition receives message ii 
activates uncorrupted party receives messages fm gamma jj sent previous round 
generates fm jj possibly empty message intended party round 
adversary learns fm jp 
generates messages fm jp corrupted 

uncorrupted party generates output 
learns outputs 

long halt sends message interpreted corrupt uncorrupted party 
may corrupt parties step 
sends message interpreted internal data 

halts output 
summary adaptive real life computation 
parameter learns model involves adaptive ideal process adversary interactive turing machine random input security parameter environment computationally unbounded interactive turing machine starts input random input security parameter 
addition trusted party ideal process proceeds follows 
corruption stage real life model receives auxiliary information proceeds iterations iteration may decide corrupt party random input information gathered far 
party corrupted input known addition learns identity corrupted party hands extra auxiliary information denote set corrupted parties need explicitly restrict number parties corrupted definition security particular fact identities corrupted parties appear global output guarantee ideal model adversary emulating real life adversary corrupts parties 
fact guaranteed distribution ensembles describing parties corrupted identical 
stage 
computation stage completes previous stage parties hand values trusted party uncorrupted parties hand inputs computation 
corrupted parties hand values chosen information gathered far 
passive corrupted parties hand inputs jbj vector inputs contributed corrupted parties vector constructed input vector substituting entries corrupted parties corresponding entries receives 
passive 
chooses hands value second corruption stage learning corrupted parties outputs computation proceeds sequence iterations iteration may decide corrupt additional party information gathered far 
corruption learns identity corrupted party sees corrupted party input output plus additional information 
output uncorrupted party outputs corrupted parties output 
addition adversary outputs arbitrary function information gathered computation ideal process 
outputs known post execution corruption outputs generated engages interaction similar interaction real life model 
proceed rounds round generates corrupt request generates arbitrary answer view computation far 
purpose may corrupt parties described second corruption stage 
interaction continues halts arbitrary output 
ideal denote output environment input random input security parameter interacting described ideal process adversary parties having input trusted party evaluating random input ideal denote distribution ideal uniformly distributed 
ideal denote distribution ensemble zi comparing computations models 
non adaptive case require protocol emulates ideal process evaluating notion emulation slightly different 
require real life adversary environment exist ideal process adversary ideal exec note environment real life model ideal process 
may interpreted saying environment real life adversary exist ideal process adversary successfully simulates presence specific environment 
furthermore require polynomial complexity regardless complexity see section 
definition adaptive security secure channels setting party function protocol parties 
say adaptively securely evaluates adaptive limited real life adversary environment exists adaptive adversary running time polynomial running time ideal exec passive adversaries say adaptively privately evaluates spelled equation means value security parameter input vector auxiliary input global outputs ideal exec identically distributed 
discussion adaptive security implies non adaptive security 
intuitively non adaptive security appears restricted version adaptive security 
affirm intuition observing definition adaptive security implies definition non adaptive security 
sketch proof protocol adaptively securely evaluates function non adaptive limited adversary 
construct non adaptive ideal model adversary emulates adaptive limited real life adversary 
receives environment value interpreted set parties corrupt value corrupts parties runs set corrupted parties auxiliary input environment input provides adversary interaction value remains inactive point 
adaptive ideal model adversary emulates presence note eventually corrupt exactly parties set provided non adaptive ideal model adversary proceeds follows 
set corrupted parties inputs plus auxiliary input ideal model adversary proceed running addition plays environment provides value consists set parties corrupted plus value corrupts party provides input party 
outputs outputs 
evident emulates additional concerns captured adaptive security 
highlight aspect additional security offered adaptive adversary model need account fact adversary may learn communication parties worth corrupting 
demonstrated example taken 
consider secret sharing protocol run presence adversary may corrupt parties dealer chooses random small set say parties 
fact value log 
shares secret parties sharing scheme 
addition set 
concreteness assume protocol evaluates null function 
intuitively scheme lacks security public jsj adaptive adversary easily find secret corrupting corrupting parties non adaptive adversary corrupt learns secret happens identical pre defined set corrupted parties 
happens probability exponentially small 
consequently protocol secure presence non adaptive adversaries small error probability allowed 
particular polynomial definition satisfied exception sides statistically indistinguishable 
additional concerns captured adaptive security ii 
security concern addressed adaptive model remains unaddressed non adaptive model need limit information gathered adversary corrupts breaks parties sees internal data 
means internal memory contents honest parties regarded safe compromise security 
definition adaptive security addresses concern requiring essentially internal state seen adversary corrupting party ideal process adversary input party adversary view far 
demonstrate requirement affects definition example 
consider protocol party instructed commitment input halt null output 
concreteness assume party binary input commitment realized permutation pair known advance 
party chooses random element common domain broadcasts party input 
easy see non adaptive model protocol securely evaluates null function 
know prove adaptive security protocol 
fact number parties polynomial security parameter claw free permutations exist protocol securely evaluate null function adaptive model log 
proof appears slightly different form 
discussion may bring reader wonder justifiable assert protocol insecure 
glance protocol appears harmless sense apparent security weakness 
appearance may strengthened fact commitment perfectly secure messages sent parties statistically independent inputs 
argue appearance false protocol serious security flaw 
protocol provides adversary computationally binding commitment inputs parties commitment may useful conjunction additional information may available adversary say protocol executions 
commitment obtained interacting parties 
erasing local data 
natural method limiting information seen adversary corrupting party include special erasure instructions protocol enabling parties remove sensitive data local state data longer necessary 
timely erasures sensitive data greatly simplify design analysis protocols 
case encryption instructive example bh 
basing security protocol erasures problematic 
reason real world systems erasures system backups hard prevent protocol knowledge retrieving data stored magnetic media erased feasible 
severe reason trust erasure instructions verified outside observer 
settings parties mutually base security party competence parties effectively erase data instructed 
consequently protocol offers security data erasures general preferable bases security data erasures 
highlight important scenario putting trust internal erasures reasonable 
case threshold cryptography see df parties typically special purpose servers controlled single administrative authority erasures maintain security system face break ins outsiders 
particular case proactive security oy trust erasures unavoidable attacker may break parties time 
distinction trusting dis trusting data erasures manifested definition amount information seen real life adversary corrupting party 
trusting erasure instructions fulfilled successful modeled letting adversary see current internal state party 
dis trusting success instructions modeled allowing adversary see entire past internal states party 
amounts allowing adversary see party input random input messages received party 
concentrate case erasures trusted 
composition theorem holds cases 
exist additional potentially harmful ways parties deviate specified protocol manner undetectable outside observer 
instance party random input different way specified protocol 
proving security protocols model parties uncorrupted ones may carry deviations harder fact impossible settings 
consequently consider models mentioned studied depth 
motivation deal situations parties may deviate protocol long deviation remains undetected parties 
modeling environment 
recall environment machine generalization notion auxiliary input 
environment provide adversary auxiliary input onset interaction 
addition disclose information adversary adaptive way computation 
furthermore environment obtains information adversary adaptive way execution protocol completed 
informally adaptive model auxiliary information thought consisting components non uniform component represented input environment machine algorithmic component represented environment machine adaptively decides way information released adversary obtained computation 
address additional points regarding modeling environment need environment separate entity 
natural question possible simplify definition adaptive security merging adversary environment single adversarial entity 
argue separation essential 
particular roles played entities definition quite different 
stress main technical differences 
firstly environment remains real life computation ideal process adversary may modified 
secondly environment sees information adversaries particular input may contain inputs parties onset computation 
proof composition theorem uses environment machine sees information 
furthermore sees outputs parties computation 
environment machine simplified cases 
specifically definition security simplified follows case local data erasures parties allowed 
case discussed adversary sees current internal state newly corrupted party 
adopt convention party completes executing protocol erases internal data relevant protocol execution local output 
definition simplified steps note post execution corruption phase longer necessary 
corrupting party execution protocol completed reveals party local output 
environment learns local outputs parties soon generated 
consequently post execution corruption phase provide environment new information 
second notice role environment restricted providing adversary initial auxiliary input additional auxiliary input party corrupted 
auxiliary inputs represent information fixed current protocol began 
internal states corrupted parties protocol executions 
environment machine replaced set auxiliary inputs adversary obtains corruption party order quantifiers 
alternative formulation definition requires single ideal process adversary satisfy respect environment note seemingly stronger formulation fact implied equivalent definition 
choose current formulation appears bit natural 
proof composition theorem somewhat clearer 
modular composition adaptive case formalize composition theorem non concurrent case adaptive adversaries secure channels setting 
non adaptive case define hybrid model describe ideal evaluation call replaced subroutine protocol 
state composition theorem general form 
theorem follows easy corollary 
hybrid model 
adaptive hybrid model ideal access short hybrid model defined analogously non adaptive case 
start real life model section 
model augmented trusted party evaluating trusted party invoked special rounds determined protocol run uncorrupted parties 
round function specified 
computation special round mimics ideal process 
adversary adaptively corrupts parties learns internal data corrupted parties 
addition corrupted party adversary receives information environment parties hand inputs values handed uncorrupted parties determined protocol 
values handed corrupted parties determined adversary 
adversary passive corrupted parties hand values protocol 
receives values parties value party hands respective outputs back parties receives 
adversary adaptively corrupt parties 
exec denote random variable describing global output computation output environment hybrid model protocol adversary security parameter inputs parties analogously definition argument similar section assume protocol secure definition real life adversary 
zu universal environment takes input description environment value runs input definition guarantees exists ideal model adversary su emulates presence zu follows su emulates presence environment 
su satisfies stronger formulation 
non adaptive case assume rounds ideal evaluations take place functions evaluated fixed known 
restriction circumvented 
exec section 
stress real life protocol uses ideal calls exec denote distribution ensemble zi replacing ideal evaluation call subroutine call 
mechanics replacing ideal evaluation call protocol call subroutine real life protocol ae identical non adaptive case section 
recall ae ae denotes protocol ideal evaluation replaced call ae theorem adaptive modular composition general statement party functions 
party protocol hybrid model ideal evaluation call round ae ae party protocols ae adaptively securely resp privately evaluates adaptive limited active resp passive real life adversary environment machine exists adaptive active resp passive adversary hybrid model running time polynomial running time exec exec ae ae non adaptive case theorem assume security properties protocol essentially states input output functionality protocol hybrid model successfully emulated ae ae real life model 
rigorously stating informal composition theorem adaptive setting define protocols securely evaluating function hybrid model definition party functions protocol parties hybrid model 
say adaptively securely evaluates hybrid model adaptive limited adversary hybrid model environment machine exists adaptive ideal process adversary running time polynomial running time ideal exec passive adversaries say adaptively privately evaluates hybrid model 
corollary adaptive modular composition secure function evaluation party functions 
party protocol adaptively securely resp privately evaluates hybrid model assume ideal evaluation call round 
ae ae party protocols adaptively securely resp privately evaluate respectively 
protocol ae ae adaptively securely resp privately evaluates proof adaptive limited real life adversary interacts parties running ae ae environment machine 
theorem guarantees exists adversary hybrid model exec exec ae ae security hybrid model guarantees exists ideal model adversary simulator exec ae ae ideal satisfying definition 
proof theorem non adaptive case prove theorem case active adversaries security 
addition treat case trusted party called 
extension case multiple functions multiple calls non adaptive case 
section contains outline changes non adaptive case 
body proof section 
extensions section relevant 
additional difficulties proof outline similar non adaptive case 
sketch additional difficulties arising adaptiveness adversaries simulators 
full details appear section 
recall protocol hybrid model ae protocol evaluating ae composed protocol 
adversary interacts ae addition environment interacts ae constructed adversary interacts ae relevant instructions adversary follows instructions relevant interaction protocol interaction ae simulated ae simulator ae 
recall ae operates running copy adversary adaptive case ae accommodate corruption requests execution ae purpose ae access arbitrary environment machine proceeds follows 
corruption requests occur ae invoked answered initial data received environment machine 
simulated requests corrupt party execution ae adversary ae corrupts real life interaction hands internal data internal data suspended execution protocol obtained environment 
ae completed ae generates output post execution corruption phase starts ae receives corruption requests environment corrupts relevant parties provides environment internal data corrupted parties 

adaptive case specifying environment necessary obtaining simulator ae ae purpose environment machine denoted ae constructed follows 
note ae general different environment 
input ae describe global state execution ae round ae gamma 
ae orchestrate run ae global state exception ae ignore random inputs uncorrupted parties execution protocol ae 
ae provide ae necessary information interacting parties running ae extract necessary information resulting interaction 
specifically ae provides ae internal state ae invoked party corrupted execution ae ae provides ae internal state party suspended execution extracts ae internal state execution ae parties corrupted ae completed 

recall operates simulating copies ae done follows 
denote set simulated parties ae interacts denote set simulated parties interacts 
adversary runs simulator ae accommodate ae corruption requests ideal process 
done follows ae requests corrupt party ideal model adversary corrupts hybrid model learns value hand trusted party 
plays environment ae hands back ae input corrupted ideal call trusted party output value ae 
adversary accommodate corruption requests simulated execution ae completed 
done follows requests corrupt party adversary corrupts hybrid model obtains internal data protocol addition plays role environment ae asks ae corrupt combines internal data protocol ae answer obtains simulated internal data hands value simulated important point analysis way plays role environment ae identical interaction ae ae detailed proof adversary environment interacting parties running ae 
constructions ae ae show exec ae exec terminology 
notions executions internal states running adversary internal state non adaptive case section 
notions refer course adaptive model 
addition notion global state modified follows 
recall non adaptive case global state concatenation local states uncorrupted parties adversary 

global state augmented include information uncorrupted parties seen past 
internal history party round concatenation internal states execution round global state round concatenation internal histories uncorrupted parties internal state adversary 
convention needed maintain property global state execution round uniquely determines continuation execution completion 
recall corrupting party adversary gets access information party knew past see section discussion definitional decision 

global state augmented include local state environment 

global state extended rounds execution protocol completed environment halts 
gs ae denote global state round execution protocol ae real life model adversary environment security parameter inputs parties environment random inputs gs similarly defined respect protocol adversary hybrid model 
adversary ae ae denote environment pn denote parties running protocol ae value security parameter 
note ae uses code 

ae round protocol ae starts running protocol ae 
round calls 
receive value ae environment verify ae valid internal state round ae gamma 
ae valid halt empty output 

corrupt parties corrupted ae ignore inputs corresponding values received environment 
call parties priori corrupted parties 

continue run round ae follow instructions hand gathered information precisely denote simulated parties interacts 
message sent uncorrupted party corrupted party hand message coming 
instructs corrupted party send message uncorrupted party instruct send message 
corrupts new party execution protocol ae proceed follows 
corrupt real life model obtain internal history protocol ae 
addition needs provided internal history execution protocol information receives environment point 
information assumed provided environment ae corruption treat value ae received ae corruption concatenation values ae ha bi 
value treated internal history round ae gamma combined internal history pertaining protocol ae handed internal data pertaining protocol ae 
value handed value received environment corruption 
protocol ae completed output current internal state simulated interact environment ae follows environment asks corruption parties corrupted corrupt hand internal history environment 
parties corrupted ignore corruption request 
description adversary ae adaptive model 
construction ae adversary adversary ae proceeds outline 
complete description appears 
construction ae environment ae proceeds described outline 
detailed description appears 
follows security protocol ae exists ideal process adversary ae ideal ae ae exec ae ae ae special structure ae implies ae additional property described follows 
property related discussion similar non adaptive case 
repeat presentation full appropriate modifications adaptive case 
reader familiar environment ae environment ae proceeds follows value security parameter input interacting parties pn running protocol ae adversary ae 
note ae uses code 

input assumed describe global state round ae gamma execution ae adversary environment ae denote internal state denote internal state ae denote internal history ith party described input right format halt output 

instruction carried execution ae 
provide ae value ae furthermore ae corrupts party provide ae ae 
instruction carried completion execution ae 
denote output party denote output ae recall ae obtains values generated 
obtaining run simulated interaction adversary environment simulated parties running ae starting round protocol resumes 
adversary run internal state described environment run state party run state obtained output ae 
note may sufficient obtaining complete internal state round internal data execution ae 
long remains uncorrupted internal data ae needed simulated interaction 
internal data ae zeroed 
simulated corrupts party proceed follows issue corrupt request ae response denoted interpreted internal history execution ae 
obtain continuing simulation value hands corruption hand value 
combine current incomplete internal history obtain complete internal history ae hand data 
halt output value structured follows 
holds input followed un local outputs uncorrupted parties adversary completion protocol ae 
holds internal data uncorrupted parties obtained step 
description environment ae note ae completely ignores internal history priori corrupted parties 
parties corrupted protocol ae invoked 
distribution output ae global output system running ae ae remains unchanged set input value priori corrupted parties internal history null 
consequently distribution global output ideal process evaluating ae property 
formalize discussion follows 
ae denote vector obtained ae replacing entries correspond priori corrupted parties non adaptive case safely skip construction adversary 
claim input vector ae parties input ae ae ideal ae ae ae ae ideal ae ae ae ae proof argued exec ae ae ae ae ae exec ae ae ae ae ae ideal ae ae ae ae exec ae ae ae ae ae ideal ae ae ae ae exec ae ae ae ae ae 
claim follows 
construction adversary proceeds described outline 
detailed description appears 
analysis evident running time linear running time plus running time ae plus running time ae fix input vector environment input value security parameter 
show exec ae exec symbol denotes equality distributions ensembles 
shown steps follows 
steps analogous non adaptive case 
set notation 
notation analogous non adaptive case see section 
recall ae round protocol ideal evaluation call protocol ae invokes ae 
vectors ae ae ae ae interpreted random input execution ae execution ae ae interpreted random input execution ae ae ae ae denote combination ae full random input vector execution ae 
party uses ae execution ae execution adversary uses ae execution ae rounds environment uses ae execution ae rounds 
similarly interpreted random vector round ae hybrid model random inputs adversary environment round random input trusted party denote combination full random input vector execution hybrid model 
step round ae gamma protocols ae behave 
fix value random input system 
gs ae ae gamma gs ae gamma step ii 
show global state hybrid model round ae distributed identically global state real life model round protocol ae returns 
done sub steps 
show parameters set hybrid model ideal evaluation identical parameters set real life model invocation ae 
set priori corrupted parties determined 
set corrupted parties adversary adversary value security parameter interacting environment machine parties pn running protocol trusted party evaluating proceeds follows 
note uses code 

non adaptive case invoke input auxiliary input random input follow instructions round ae gamma 
recall far ae parties run addition keep piece random input side 
piece denoted ae 

onset round ae expects start interacting parties running protocol ae subroutine parties pn call trusted party ideal evaluation function order continue run invoke simulator ae follows 
denote set simulated parties ae interacts denote set simulated parties interacts 
random input ae set ae initial value ae expects receive environment set current internal state 
ae asks corrupt ideal process party corrupted ae input values 
recall priori corrupted parties inputs data environment affect distribution output ae 
ae asks corrupt party corrupted corrupt hybrid model value hand trusted party inform ae input addition set ae contain internal history hand ae ae information environment 
ae hands inputs corrupted parties trusted party asks values invoke trusted party input values corrupted parties hand value provided trusted party back ae 
ae corrupts step ae value received trusted party 

denote output ae starts post execution corruption phase 
recall internal state round execution resumes 
continue current run internal state completion protocol follow instructions 
corrupts party stage proceeds follow 
corrupt hybrid model obtain internal history pertaining protocol 
play role environment ae request corruption obtain simulated internal history pertaining protocol ae 
process ae may corrupt ideal process 
case hand ae input value environment described step 
combine data previous steps obtain internal history pertaining protocol ae add value received environment hand data 
protocol terminates output outputs continue simulate step post execution corruption phase 
description adversary adaptive model 
onset round ae set identical executions 
ae input value environment ae consist global state ae gs ae ae gamma 
ae denote input value uncorrupted party protocol ae determined gs ae ae gamma 
corrupted ae 
ae ae ae similarly denote value party hands trusted party determined gs ae gamma follows ae 
assert global output execution ae implicit run ae adversary distributed identically global output ideal evaluation implicit round ae run hybrid model 
validity ae step ii claim exec ae ae ae ae ae ideal ae ae ae ae ideal ae ae ae ideal ae ae ae note equation applies interaction environment ae respective adversaries ae completed 
fact plays central role step iii 

show global state hybrid model round ae distributed identically global state real life model protocol ae returns 
denote round call protocol ae returns protocol ae 
follows definition ae constructions ae ae ae random input vector protocol ae 
gs ae ae vector gs ae ae removing uncorrupted party internal states pertaining protocol ae output ae 
gs ae ae obtained gs ae ae gamma exec ae ae ae ae ae ae deterministic simple process denoted 
process essentially updates internal histories parties internal state adversary 
precisely recall def exec ae ae ae ae ae ae output ae execution 
process modifies internal history uncorrupted party adding appropriate portion gs ae ae gamma appropriate place 
outputs internal state appears ae output modified internal histories uncorrupted parties 
random input vector ideal evaluation process gs ae obtained gs ae gamma ideal ae ae process real life execution 
follows value vectors ae uniformly chosen respective domains gs ae ae gs ae step iii 
assert equation 

round vector gs ae ae obtained gs ae gamma def exec ae ae ae ae ae ae process continue execution round global state described gs ae gamma 
new corruption occurs round gs ae ae obtained 
case corrupts new party take internal history pertaining protocol ae 
guaranteed corrupted 
interaction environment completion execution ae determined gs ae similar process 
particular global output exec ae ae uniquely determined 

round vector gs determined gs ae gamma ideal ae ae ae ae ae process real life execution 
interaction environment completion execution determined way 
particular global output exec determined way 
follows value vectors ae uniformly chosen respective domains exec ae ae exec equation follows letting randomly chosen domain 
completes proof case single ideal evaluation call 
case multiple ideal evaluation calls treated way non adaptive case 
omit details 
computational setting section defines secure protocols proves composition theorem computational setting adversary sees communication parties restricted probabilistic polynomial time 
concentrate case adaptive adversaries 
simpler case non adaptive adversaries easily inferred 
treatment quite similar secure channels setting section 
section self contained assume familiarity section highlight differences 
section contains definitions secure protocols 
remarks sections relevant 
additional remarks specific computational setting appear section 
section presents proves composition theorem 
definition security computational case define adaptively secure multi party computation computational setting 
executing protocol real life scenario notation exec adaptive secure channels setting exceptions 
real life adversary environment probabilistic polynomial time ppt 
note weakening security offered model relative section 
running time adversary entities involved measured function security parameter accommodate convention running time measured length input envision string additional input 

sees communication uncorrupted parties 
consequently party gets corrupted new data learned adversary party input random input 
note strengthening security offered model relative section 
ideal process secure channels setting 
real life adversary ppt ideal process adversary 
notation ideal remains unchanged 
define emulation ideal process real life computation way exception require global outputs computationally indistinguishable defined section definition adaptive security computational setting party function protocol parties 
say adaptively securely evaluates computational setting ppt limited real life adversary ppt environment exists ppt ideal process adversary ideal exec passive adaptively privately evaluates computational setting 
discussion complexity stress definition quantifies environments ppt 
computational setting assume involved entities including environment represented ppt 
definition allows computational power hard satisfy powerful may able break cryptographic primitives parties distinguish real life computation ideal process 
recall model allows access communication parties view 
absolute vs computational correctness 
definition requires sides computationally indistinguishable 
required ppt distinguishing algorithm values algorithm distinguishes ideal exec probability negligible security parameter 
particular means ensemble describing outputs uncorrupted parties real life model required computationally indistinguishable ensemble describing outputs ideal process 
discuss consequences requirement case passive adversaries 
case active adversaries somewhat involved addressed 
case passive adversaries definition imposes different requirements depending evaluated function deterministic probabilistic 
deterministic output uncorrupted party protocol securely evaluates uniquely determined value corresponding set inputs 
case say definition guarantees absolute correctness 
probabilistic protocol securely evaluates guarantees distribution outputs uncorrupted parties computationally indistinguishable specified distribution 
guaranteed distribution outputs uncorrupted assume links ideally authenticated adversary alter communication 
assumption works cryptographic protocols analysis protocols easier 
removing assumption done modular way concentrates task message authentication 
see instance bck 
parties equal specified distribution 
case say definition guarantees computational correctness 
demonstrate point example 
assume function evaluated phi pseudorandom number generator phi denotes bitwise exclusive 
case protocols uncorrupted parties output value phi input sequence considered secure 
contrast assume evaluated function random value length delta 
probabilistic function chosen intrinsic randomness case protocol parties output pseudorandom value appropriate length secure 
case active adversaries distinction cases definition guarantees absolute correctness cases definition guarantees computational correctness drastic 
reason corrupted parties real life ideal model may contribute computation values chosen irrespectively input values particular contributed values chosen randomly distribution 
consequently definition guarantees absolute correctness functions output value uniquely determined inputs uncorrupted parties 
demonstrate point example 
consider function described 
function deterministic value consequently output parties defined inputs uncorrupted parties 
particular corrupted parties contribute randomly chosen values function value effect random independent inputs parties 
possible construct protocols securely evaluate definition parties output random value independently inputs parties 
contrast consider function 

output parties uniquely defined error value inputs uncorrupted parties 
consequently protocol securely evaluates uncorrupted parties output uniquely defined output value input 
discussion brings general issue formally cast intuitive task function evaluated 
seen seemingly similar formalizations result different security requirements protocols 
care taken formalize task way correctly captures desired security requirements 
modular composition computational case state prove composition theorem corollary case adaptive adversaries computational setting 
computational hybrid model 
computational adaptive hybrid model defined identically secure channels adaptive case section exception start computational real life model secure channels real life model 
notation exec remains unchanged applies computational setting 
mechanics replacing ideal evaluation call protocol call subroutine real life protocol ae identical case secure channels 
theorem adaptive computational modular composition general statement party functions 
party protocol computational hybrid model ideal evaluation call round ae ae party protocols ae adaptively securely resp privately evaluates computational setting 
ppt adaptive limited active resp passive real life adversary ppt environment machine exists ppt adaptive active resp passive adversary hybrid model exec exec ae ae protocols securely evaluating function computational hybrid model defined usual way definition party functions protocol parties computational hybrid model 
say adaptively securely evaluates computational hybrid model ppt adaptive limited adversary hybrid model ppt environment exists ppt adaptive ideal process adversary ideal exec passive adversaries say adaptively privately evaluates computational hybrid model 
corollary adaptive computational modular composition secure function evaluation party functions 
party protocol adaptively securely resp privately evaluates computational hybrid model assume ideal evaluation call round 
ae ae party protocols adaptively securely resp privately evaluate respectively computational setting 
protocol ae ae adaptively securely resp privately evaluates computational setting 
proof corollary identical corollary 
proof theorem prove theorem case active adversaries 
simpler case passive adversaries easily inferred 
case adaptive security secure channels restrict presentation active adversaries protocols trusted party called 
case multiple ideal evaluation calls treated proof 
constructions ae ae identical section adaptive secure channels case obvious exception simulated adversary messages sent uncorrupted parties 
complexities ae ae linear complexity complexity linear complexities ae show exec ae exec essentially difference proof secure channels case step ii exec ae ae ae ideal ae ae guaranteed computationally indistinguishable suffices show 
precisely distinguisher exec ae exec construct distinguisher exec ae ae ae ideal ae ae input value output ae distinguisher execution ae adversary inputs random inputs appearing data parties outputs ae 
global output execution generated runs outputs outputs 
arguments secure channels case seen distribution exec ae ae ae distribution exec ae 
similarly distribution ideal ae ae distribution exec 
consequently distinguishes exec ae exec probability negligible distinguishes exec ae ae ae ideal ae ae probability negligible 
multiple ideal evaluation calls 
secure channels model case multiple ideal evaluation calls straightforward generalization case single call 
construction generalized adversary secure channels model analysis uses hybrids argument 
sketch main points difference single call computational case 
points analogous ones discussed non adaptive secure channels case see section 
adversary ae constructed protocol ae ae identical adversary ae described exception protocol ae replaced ae ae ae ae ae 
similarly environment machine ae constructed protocol ae ae identical ae described exception protocol ae replaced ae 
ae ae ae ae 
construct adversary identical described exception round instructs parties ideally evaluate adversary runs copy ae way runs ae initial value ae set current internal state simulated 
recall may invocations simulator ae invocation corresponds different ideal evaluation call invocations different initial values 

case single ideal evaluation call evident running time linear running time plus sum running times invocations ae ae plus running time ae ae sketch proof exec ae ae exec denote total number ideal evaluation calls hybrid model 
define hybrid protocols hybrid model follows jth ideal evaluation call follows ae ae rest interaction 
similarly define adversaries adversary follows instructions jth ideal evaluation call follows instructions rest interaction 
denote ensemble exec seen exec ae ae exec furthermore similar argument single call case seen exists distinguisher exists distinguisher exec ae ae ae ideal ae ae function evaluated jth call 
distinguishing probability reduced factor 
non adaptive security computational setting 
definition non adaptive security computational setting easily derived definitions 
furthermore composition theorems similar ones hold case 
computational non adaptive case distinguisher described 
contrast adaptive case global output execution protocol ae include sufficient information orchestrating execution ae consequently receive information inputs random inputs parties protocol auxiliary input see definition 
see details non adaptive computational case 
acknowledgments coming definitions remotely possible devoted help oded goldreich period years 
oded contributed immensely shaping modular composition theorems 
people interacted helpful discussions inputs concerning definitions modular composition theorems 
rosario gennaro shafi goldwasser shai halevi hugo krawczyk eyal kushilevitz silvio micali moni naor ostrovsky charlie rackoff phil rogaway 
anonymous referees careful thorough reading manuscript helpful remarks suggestions 
beaver secure multi party protocols zero knowledge proof systems tolerating faulty minority cryptology springer verlag 
beaver foundations secure interactive computing crypto lecture notes computer science lncs springer verlag 
bg beaver goldwasser multi party computation faulty majority th symp 
foundations computer science focs ieee pp 

bh beaver haber 
cryptographic protocols provably secure dynamic adversaries 
advances cryptology eurocrypt lncs springer verlag pages 
bck bellare canetti krawczyk modular approach design analysis authentication key exchange protocols th symposium theory computing stoc acm 
bcg ben canetti goldreich asynchronous secure computations th symposium theory computing stoc acm pp 

case adaptive adversaries weaker version definition provide distinguisher auxiliary input sufficient composition theorem hold 
formulate stronger notion order compatible non adaptive computational case 
bgw ben goldwasser wigderson completeness theorems fault tolerant distributed computation th symposium theory computing stoc acm pp 

canetti studies secure multi party computation applications ph thesis weizmann institute israel 
canetti feige goldreich naor adaptively secure computation th symposium theory computing stoc acm 
fuller version mit lcs tr 
ch canetti herzberg 
maintaining security presence transient faults 
proceedings crypto lncs springer verlag 
cg canetti gennaro multi party computation th symp 
foundations computer science focs ieee 
canetti gennaro herzberg naor proactive security long term protection break ins cryptobytes vol 

cg canetti goldwasser threshold cryptosystem secure adaptive chosen ciphertext attacks proceedings eurocrypt springer verlag 
fuller version available line ucsd edu 
canetti halevi herzberg maintain authenticated communication issue 
preliminary version th symp 
principles distributed computing podc acm pp 

canetti kushilevitz ostrovsky rosen randomness vs faulttolerance issue 
preliminary version th symp 
principles distributed computing podc acm pp 

canetti ostrovsky 
secure computation honest looking parties truly honest 
st symposium theory computing stoc acm 
ccd chaum damgard 
multi party unconditionally secure protocols 
proc 
th annual symp 
theory computing stoc pages acm 
ck chor kushilevitz zero law boolean privacy siam disc 
math 

preliminary version symposium theory computing stoc acm 
cdm cramer damgard maurer span programs general secure multi party computation manuscript 
df desmedt frankel threshold cryptosystems brassard editor advances cryptology crypto lncs springer verlag pp 

dow diffie van oorschot wiener authentication authenticated key exchanges designs codes cryptography pp 

ddn dolev dwork naor non malleable cryptography siam 
computing appear 
preliminary version rd symposium theory computing stoc acm 
feldman practical scheme non interactive verifiable secret sharing th symp 
foundations computer science focs ieee pp 

galil haber yung cryptographic computation secure tolerant protocols public key model crypto lncs springer verlag pp 

gennaro jarecki krawczyk rabin robust threshold dss signatures eurocrypt lncs springer verlag pp 

goldreich uniform complexity treatment encryption zero knowledge journal cryptology vol 
springer verlag pp 

goldreich foundations cryptography fragments book weizmann inst 
science 
ucsd edu goldreich 
secure multi party computation 
ucsd edu gk goldreich krawczyk composition zero knowledge proof systems siam 
computing vol 

gmw goldreich micali wigderson proofs yield validity languages np zero knowledge proof systems journal acm vol acm pp 

preliminary version th symp 
foundations computer science focs ieee pp 

gmw goldreich micali wigderson play mental game th symposium theory computing stoc acm pp 

go goldreich oren definitions properties zero knowledge proof systems journal cryptology vol 
springer verlag pp 

preliminary version oren th symp 
foundations computer science focs ieee 
gl goldwasser levin fair computation general functions presence majority crypto lncs springer verlag 
gm goldwasser micali probabilistic encryption jcss vol 
april pp 

gmr goldwasser micali rackoff knowledge complexity interactive proof systems siam journal comput vol 
pp 

hm hirt maurer complete characterization adversaries tolerable secure multiparty computation issue 
preliminary version th symp 
principles distributed computing podc acm pp 

kushilevitz privacy communication complexity siam jour 
disc 
math 
vol 


preliminary version th symp 
foundations computer science focs ieee 
kilian kushilevitz micali ostrovsky reducibility completeness private computations siam 
computing appear 
preliminary versions rd symposium theory computing stoc acm kilian th symp 
foundations computer science focs ieee kushilevitz micali ostrovsky 
micali rogaway secure computation unpublished manuscript 
preliminary version crypto lncs springer verlag 
micali advanced class cryptographic protocols mit spring 
oy ostrovsky yung 
withstand mobile virus attacks 
proceedings th annual acm symposium principles distributed computing podc acm pp 

rabin simplified approach threshold proactive rsa crypto lncs springer verlag 
rb rabin ben verifiable secret sharing multi party protocols honest majority st symposium theory computing stoc acm pp 

yao protocols secure computation proc 
rd annual symp 
foundations computer science focs pages 
ieee 
yao theory applications trapdoor functions proc 
rd annual symp 
foundations computer science focs pages 
ieee 
yao generate exchange secrets proc 
th annual symp 
foundations computer science focs pages 
ieee 
definitions briefly review definitions secure multi party computation 
specifically review definitions micali rogaway goldwasser levin gl beaver canetti feige goldreich naor 
definitions vary level restrictiveness 
addition works vary level detail rigor definitions 
comprehensively rigorously set definitions appears 
definition micali rogaway 
micali rogaway envision ideal process similar secure function evaluation 
ideal process remains motivating intuition explicitly actual definition sketched 
definition deals secure channels setting protocols evaluate deterministic functions 
input party contributes computation output determined exclusively communication party parties 
functions determine input output called input awareness output awareness functions computable polynomial time 
adversary evaluate functions secure channels setting access entire communication uncorrupted party parties 
correctness guaranteed requiring execution protocol outputs uncorrupted parties determined applying output awareness function communication equal value evaluated function applied contributed inputs determined applying input awareness function communication 
security guaranteed requiring exists black box simulator generates probabilistic polynomial time simulated conversation real life adversary uncorrupted parties 
simulator restricted pass simulation rewind adversary receives external information regarding inputs corrupted parties outputs 
external information related values input output awareness functions applied simulated conversation 
furthermore received timely fashion simulator receives designated outputs corrupted parties appropriate function values certain pre specified round round inputs determined input awareness function applied addition party corrupted adversary simulator receive input value party 
definition security imply settings applies 
fact considerably restrictive 
highlight aspects extra restrictiveness 
requirement input output awareness functions computable communication implies protocols parts computation done locally interaction trivial protocol communication takes place party computes output locally considered insecure 
second limiting simulator pass black box simulation excludes proof technique essential proving security wide range protocols zero knowledge proofs gmr gmw 
third requiring simulator receives outputs corrupted parties inputs determined communication excludes additional set protocols 
definition goldwasser levin 
goldwasser levin take different approach 
formalize inevitable advantages adversary ideal process briefly sketch inevitable advantages 
say protocol robust adversary exists equivalent adversary limited inevitable privileges effect computation 
notion robustness protocols advantage independent specific function evaluated technical subtleties ignored 
inevitable privileges adversary extracted ideal process sketched follows 
adversary may choose corrupt parties adaptively non adaptively 
adversary active inputs corrupted parties may modified 
done knowledge inputs uncorrupted parties 
adversary may learn specified outputs corrupted parties 
may inevitably reveal information inputs uncorrupted parties 
furthermore adversary adaptive corrupt parties computation completed output computation 
difference gl approach may viewed follows 
directly comparing executions protocol real life ideal process specific function evaluated compare real life executions protocol executions protocol idealized model adversary limited described 
far need specify functionality protocol fulfilling 
second step implicit gl claims executing protocol idealized model equivalent ideal evaluation process specific function 
instance bit transmission function output party receiver equals input party sender 
consider protocol simply sends input private channel 
protocol rejected definition simulator required provide corrupted receiver value transmitted bit value known 
protocol securely evaluates bit transmission function definition 
majority parties corrupted addition privileges described adversary prevented quitting early disrupting computation time 
done knowing output certainty uncorrupted parties 
definition beaver 
beaver definition takes similar approach 
sketch approach terminology 
general notion comparing security protocols formulated follows 
consider protocols ff fi evaluating function 
protocol ff secure protocol fi exists interface turns adversary attacking ff adversary attacking fi inputs global output computations identically distributed 
global output defined similarly 
interaction interface apparently black box adversary allowed 
definition fully specify details interaction interface 
protocol evaluating function secure secure trivial protocol evaluating function ideal model similar 
allow secure sequential composition definition allows adversary receive additional auxiliary information corrupting party 
addition requires protocol post protocol 
adversary able respond sequence post execution corruption requests internal data relevant parties 
disallowing considerable limitation especially computational setting 
see section 
additional weakness definition required efficient 
see section 
compared notion environment machine requirement post protocol main drawbacks 
take account fact post execution corruption requests adaptive depend execution protocol data learned previous corruptions fixed advance 
second formalization generalize computational setting corruption requests generated ppt machine see section 
definition canetti definitions differs aspects 
definitions require ideal process adversary operate black box simulation 
incorporate auxiliary input definition include environment machine 
definitions additional structure purpose formalize amount internal deviation protocol allowed uncorrupted parties 
define means protocol semi honest protocol known protocol 
essentially allows uncorrupted parties internally deviate long deviation undetectable parties 
say secure semi honest protocol secure 

