evaluating context sensitive slicing chopping empirical evaluation contextsensitive slicing algorithms context sensitive chopping algorithms compare context insensitive methods 
algorithms reps agrawal investigate new algorithms variations call strings approximative chopping summary information 
turns chopping summary information may prohibitive complexity approximate algorithms precise faster 

slicing established technique reverse engineering analyses testing debugging available research prototypes commercial products 
main approaches slicing original slicing technique weiser traditional data flow analysis approach program dependence graphs 
extensive evaluations different slicing algorithms really done control flow graph algorithms data reported atkinson griswold 
evaluation program dependence algorithms author aware conducted agrawal guo just compare algorithms flaws shown 
slicing identifies statements program may influence statement slicing criterion answer question specific statement part slice 
focused approach help chopping reveals statements involved transitive dependence specific statement source criterion specific statement target criterion 
evaluation chopping algorithms done reports limited experience 
introduce different slicing section chopping section algorithms evaluated section 
drawn section 
jens krinke universit passau passau germany 
program dependence graphs program dependence graph pdg directed graph vertices represent statements control predicates occur program 
contains unique entry vertex 
edges represent dependences components program control dependence edge vertex represents evaluation predicate represented controlling execution component represented 
data dependence edge vertex represents component represented assigns variable may component represented 
extension pdg interprocedural programs introduces vertices edges procedure procedure dependence graph constructed basically pdg formal vertices formal parameter procedure 
procedure call represented call vertex actual vertices actual parameter 
call vertex connected entry vertex call edge actual vertices connected matching formal vertices parameter edges actual vertices connected matching formal vertices edges 
graph called interprocedural program dependence graph 
system dependence graph sdg summary edges actual actual added representing transitive dependence due calls 

context insensitive slicing slicing intraprocedural pdgs just simple reachability problem backward slice vertex slicing criterion set vertices criterion vertex reachable 
algorithm shown 
call context insensitive slicing cis 
forward slicing set vertices reachable criterion vertex 
algorithm sdgs resulting slices accurate calling context preserved algorithm may traverse ieee 
published proceedings international conference software maintenance montreal canada 
personal material permitted 
permission reprint republish material advertising promotional purposes creating new collective works resale redistribution servers lists reuse copyrighted component works obtained ieee 
slicing criterion mark visited empty remove element foreach marked mark visited return set visited vertices 
context insensitive slicing sdg slicing criterion mark empty remove element mw mark foreach mv mark mv parameter call edge mw mark elsif parameter edge mv mark elsif mv mw mark mw return set visited vertices 
context sensitive slicing sdgs parameter edge coming call site procedure may traverse edges may traverse parameter edge going different call site 
sequence traversed edges path called unrealizable path 
means impossible execution called procedure return call site 
consider interprocedural slice precise vertices included slice reachable criterion realizable path 

slicing summary edges accurate slices calculated modified algorithm sdgs 
benefit sdgs presence summary edges represent transitive dependence due calls 
idea slice criterion ascending calling procedures slice visited vertices descending called procedures 
algorithm shown call summary information slicing sis 

context sensitive slicing situations summary edges presence interference explicit parallel programs dependence longer transitive requirement summary edges 
interference dependence crosses procedure boundaries summarized summary edges 
circumstances calling context preserved explicitly traversal threaded 
different approach context sensitive analysis call strings calling context encoded explicitly analysis sequence call sites simulating call stack machine 
rest section show approach slicing chopping program dependence graphs 
call vertex actual vertices unique index si 
sequence call sites si sin called call string 
traversal parameter edge call site going called function generate new longer call string sc 
traverse parameter call edge back call site call site match current leading element call string 
call strings define context sensitive slicing method precise context sensitive slicing summary edges precise respect realizable paths 

explicitly context sensitive slicing show general slicing algorithm obeys calling context call strings 
variants algorithm come definition match 
simplest definition follows cons cdr match presence recursion doesn set call strings call strings finite 
agrawal guo improved algorithm named ecs call strings cycle free 
define follows match cons sk si si sk si si sk definition resulting slices correct leave vertices statements slice 
incorrectness observation soon call string form slicing criterion empty remove element foreach marked context match holds parameter call edge sv call site car sv mark elsif parameter edge sw call site sw mark mark return set visited vertices 
explicitly context sensitive slicing replaced remove cycle 
algorithm fails propagate effects call string includes effects call string back call site sy sy generated 
counter example procedures shown 
procedure contains entry vertex call site composed call vertex actual vertices actual vertex 
second procedure contains entry node formal vertices formal vertex vertex call site composed call vertex actual vertices vertex 
vertices inside procedures connected control data dependence edges 
procedure calls procedure call site procedure calls call site actual actual vertices properly connected formal formal vertices parameter parameter edges call edges shown 
backward slice initial worklist 
reachable worklist contain 
visited reachable leaves worklist 
vertex reached transitively marked call string reached recursion 
point worklist ba vertex marks ba 
vertex reachable call string matches point vertex marked 
reachable call string doesn match 
vertex call string ba propagated cd dd pi po 
counter example ecs 
vertex marked ba propagate tob visited time 
reachable vertex transitively 
point visited vertices marked marked ba andb marked worklist contains ba 
due recursive call new call string bba generated propagated vertex 
cycle folds bba ba previously vertex 
ecs algorithm terminates worklist empty generated slice doesn contain vertex wrong propagation bba 

limited context slicing popular approach circumvent infinity problems length limitation call strings call string suffix approximation 
call string allowed longer elements 
call string elements long concatenation oldest element removed cons sl ss sk general algorithm directly modifications 
call variant limited context slicing 
approach quite imprecise correct presence recursion consider call string maximal length call string propagated recursive procedure may propagated times called recursive procedure 
result call string contains call sites recursive procedure 
call string may propagated times back calling recursive procedure 
resulting call string empty procedures call recursive procedure marked empty call string 
result reduced precision 
slicing criterion empty remove element foreach marked context match holds parameter call edge sv call site car sv sv marked recursive marked context match holds mark mark elsif parameter edge sw call site sw marked recursive car sw mark sw mark mark return set visited vertices 
folded context sensitive slicing 
folded context slicing seen way call strings finite remove cycles 
removing explicitly different approach 
build calling context graph 
graph vertices call sites edges represent calls lead call site procedure contains call site graph strongly connected components folded single vertex call sites component replaced single call site 
process call sites marked recursive 
definitions adapted changed 
example cons sl sk modified algorithm obtain incorrectness agrawal 
presents corrected algorithm modified follows 
algorithm descends called recursive function propagates call strings call string generated actual call string possible recursion 

algorithm calling recursive function propagates actual call string actual call site element call string call string generated 
modified algorithm general unlimited version defined cons call variants unlimited folded context slicing limited folded context slicing 
evaluation show unlimited variant due combinatorial explosion set call strings 

evaluation slicing agrawal guo compared contextinsensitive slicing cis ecs implemented slicing algorithms previous sections evaluate fully 
infrastructure analyze programs implement slicing chopping algorithms flow insensitive context sensitive alias analysis similar 
details analyzed programs shown 
programs stem different sources ctags patch diff gnu programs 
rest benchmark database analysis framework 
loc column shows lines code measured wc column amount procedures number entry vertices pdg nodes column shows number vertices 
agrawal guo selected formal vertices slicing criteria results comparable amount resulting slicing criteria number formal vertices shown column slices 
limited size programs due amount slices done caused quadratic runtime complete test program 

precision precise new algorithms 
measure precision 
contextinsensitive slicing cis simple imprecise algorithm consider precision 
slicing summary edges sis precise respect realizable paths consider precision 
precision 
cis column gives average size cis slice sis column average size sis slice 
big variation average cis slice larger average sis slice 
programs high precision small 
cases shown bold precision loc nodes slices edges summary time assembler cdecl ctags simulator compiler football agrep bison patch flex diff 
details test programs cis sis lcs lcs lcs lcs lcs lcs fcs fcs fcs fcs fcs fcs higher 
case flex precision fcs slightly lcs shown italics 
limited amount memory time slices calculated tests marked needed mb core memory didn finish fewer hours ghz machines mb 

speed see runtimes test cases different slicing algorithms sec 
times complete set slicing criteria 
get average time single slice divide number slices column 
haven average time numbers sub second 
columns see time needed sis slices time cis slices sis slices higher precision quadratic 
precision avg 
size complexity sis compensated smaller amount vertices visited 
typical problem call string approaches combinatorial explosion generated call strings 
see see 
due increased precision smaller amount visited vertices experienced reduced runtimes higher see 
cases slightly slower resulting overhead propagating call strings 
cases faster suffer combinatorial explosion 
situations slower 
related problem stems higher precision cases see comparison 
increased shown causes test cases suffer combinatorial explosion point slicing longer possible cis sis lcs lcs lcs lcs lcs lcs fcs fcs fcs fcs fcs fcs test case 
previously described effect higher speed higher compensating combinatorial explosion share experience agrawal guo successfully unlimited call string slicing algorithm 
experience backed atkinson griswold reported control flow graph approach 
compare runtimes sis see runtimes higher sis 
leads persuasion long summary edges calculable sis slicing 
stays consider overhead calculate summary edges generation summary edges part analysis generate pdg expensive summary edge generation 
overhead situations slices done situations control flow graph slicing probably better anyway 
summary edges available revert limiting algorithm preferable 
limiting algorithms important chopping known context sensitive chopping algorithms expensive 

chopping applied approach problem chopping 
jackson rollins defined restricted form chopping chop chopping criterion set vertices part influence source vertex target vertex basically set vertices lying path pdg 
jackson rollins restricted procedure traversed control dependence edges data dependence edges summary edges parameter call 
runtimes sec 
edges 
resulting chop called level truncated chop truncated vertices called procedures included 
reps variants precise chopping 
level non truncated chop truncated chop includes vertices called procedures 
different level truncated non truncated chops call interprocedural vertices chopping criterion allowed different procedures 
due space limitations considering different level variants 
focusing non truncated level chopping challenging problem formulate variant call strings due limitations length limited call strings level property get lost graph traversal 

context insensitive chopping intraprocedural context insensitive case chop chopping criterion basically intersection backward slice forward slice algorithm intersection set operations expensive large sets slices 
algorithm uses phase approach phase backward slice done second phase forward slice done vertices visited backward slice phase considered 
call algorithm context insensitive chopping cic 

chopping summary edges precise context sensitive chopping algorithm uses summary edges depicted 
basically starts intraprocedural chop done algorithm 
slight modification chopping criterion wb mark visited backward phase wb empty remove element wb foreach marked wb wb mark visited backward phase marked backward phase marked forward phase wf mark visited forward phase wf empty remove element wf foreach marked backward phase wf wf mark visited forward phase return set forward phase visited vertices 
context insensitive chopping algorithm chop inside single procedure allowed traverse parameter call edges allowed required traverse summary edges 
calculated chop pairs actual vertices connected summary edge extracted initial worklist filled pairs corresponding formal formal vertices 
pair worklist new intraprocedural chop generated added starting chop 
summary edges extracted pairs corresponding formal formal vertices added worklist added 
repeated long elements worklist 
extended chop resulting precise interprocedural chop 
algorithm generates level non truncated chop vertices chopping criterion procedure 
call algorithm summary information chopping sic 
intraprocedural version algorithm level truncated chop 

mixed context sensitivity chopping chopping summary edges expensive due high complexity 
simple improvement combine context sensitive slicing summary edges contextinsensitive chopping 
phase approach context insensitive chopping contextsensitive slicing summary edges contextinsensitive slicing 
doing level chopping descend called procedures 
algorithm called mixed context sensitivity chopping mcc shown 
surprisingly precise see section 
sdg chopping criterion intraprocedural chop summary edge empty remove element corresponding formal vertex corresponding formal vertex marked mark visited intraprocedural chop summary edge return 
chopping summary edges sdg chopping criterion wb mark visited backward phase wb empty remove element wb foreach parameter call edges marked wb wb mark visited backward phase marked backward phase marked forward phase wf mark visited forward phase wf empty remove element wf foreach parameter edge marked backward phase wf wf mark visited forward phase return set forward phase visited vertices 
mixed context sensitivity 
limited folded context chopping adapt algorithm chopping 
phase approach backward slice done vertices marked encountered call strings 
second basically forward slice computed considering vertices marked matching call string phase 
unmarked matching context second phase 
definitions match 
call algorithm context chopping 
style adapt algorithm chopping 
straightforward due space limitations presenting algorithm implemented evaluated section 
call algorithm limited folded context chopping 
chopping criterion wb mark wb empty remove element wb foreach marked match holds parameter call edge sv call site car sv wb wb mark elsif parameter edge sw call site sw wb wb mark wb wb mark marked wf mark wf empty remove element wf foreach marked match holds marked match holds parameter edge sv call site car sv wf wf mark elsif parameter call edge sw call site sw wf wf mark wf wf mark return set forward phase visited vertices 
explicitly context sensitive 
improved precise algorithm improved precise chopping algorithm higher speed 
sic algorithm section calculates new chop pair formal formal vertices summary edge corresponding actual vertices included chop 
observation follows summary edges call site included chop chop corresponding pairs formal vertices separately 
single chop set corresponding formal vertices set sdg chopping criterion intraprocedural chop summary edge empty foreach call site foreach call site corresponding formal vertex corresponding formal vertex marked mark visited intraprocedural chop summary edge return 
merging summary edges corresponding formal vertices 
algorithm merging summary edges dependent call site called summary merged chopping smc 
calculating starting chop collect new summary edges visited call sites 
new chop call site set corresponding formal vertices set corresponding formal vertices 
resulting vertices added starting chop repeat procedure new resulting summary edges new summary edges left 
causes low runtimes doing smaller number chops 

evaluation ii chopping implemented previously chopping algorithms cic sic smc mcc fully evaluate 
chopping criteria chosen tenth level pairs formal formal vertices 
measured time needed complete set chops average time calculate chop sub second 
sketch proof set summary edges single call site included starting chop 
randomly chosen pair summary edges 
corresponding pairs formal formal vertices 
chop 
chop 
problem caused vertex included 
paths exist 
summary edge exist 
edges included starting chop starting chop 
summary edges include chop resulting chop added resulting chop 
chops cic sic smc mcc lcc lcc lcc lcc lcc lcc fcc fcc fcc fcc fcc fcc precision 
measure precision different algorithms follow approach section consider cic precision sic smc precision 
results shown column contains amount chopping criteria amount chops done columns give average size cic sic smc chops 
thing see cases impossible complete sic time boundaries 
simple mcc algorithm surprisingly precise normally precision precise lcc fcc 
shows main source imprecision chopping loss level property kept mcc 
experiences kind contrast experiences slicing algorithms algorithms sic smc mcc precise increased precision increasing slowly 
speed 
important observation comparing runtimes sic smc smc faster 
extreme test case smc needs runtime sic 
mcc algorithm surprisingly precise fast 
larger test cases may faster algorithms 
comparison terms runtime reveals results cases faster suffer combinatorial explosion 
increased may result lower runtime 
section saw sis normally slower cis 
case chopping test cases cic slower sic test cases cic faster smc 
due higher complexity chopping summary edges comparison slicing summary edges 
compare speed 
precision mcc sic smc experience different results slicing test cases faster chopping lcc fcc sic faster smc 
results chopping clear slicing lead recommendation due high precision smc preferable chopping algorithms 
call string approaches faster poor precision 

evaluated different algorithms known new slicing different algorithms known new chopping 
experiences summarized follows new specialized chopping algorithms smc mcc better previously known chopping algorithms cic sic 
smc preferable sic faster 
mcc algorithm surprisingly fast precise cases alternative smc 
limited approaches may suffer possible combinatorial explosions call strings 
higher precision definitely high influence speed may cause lower runtimes due smaller set visited vertices 
higher precision gained increased limit higher amount generated call strings may cause higher runtime 
summary information best solution long possible 
precise fast 
summary edges algorithms choice suffer combinatorial explosions due recursion 
cic sic smc mcc lcc lcc lcc lcc lcc lcc fcc fcc fcc fcc fcc fcc cases fcs fcc precise may lead higher runtimes 
context insensitive algorithms cause loss precision higher chopping slicing 
context insensitive algorithms cis cic regarded lcs fcs lcc fcc 
results interesting fully evaluate problems program analysis influence prerequisites pointer analysis precision speed different slicing chopping algorithms 
results sis 
second applications slicing chopping influenced different algorithms 
technique generate solve path conditions intensive chopping questions 
agrawal guo 
evaluating explicitly contextsensitive program slicing 
workshop program analysis software tools engineering 
atkinson griswold 
design program analysis tools 
proc 
intl 
conference software engineering 
atkinson griswold 
implementation techniques efficient data flow analysis large programs 
proc 
intl 
conference software maintenance 
bent atkinson griswold 
comparative study program technical report cs univer 
california san diego 
burke carini 
choi hind 
interprocedural alias analysis presence pointers 
lecture notes computer science 

ferrante ottenstein warren 
program dependence graph optimization 
acm trans 
prog 
lang 
syst 

runtimes sec 
horwitz reps binkley 
interprocedural slicing dependence graphs 
acm trans 
prog 
lang 
syst 
jackson rollins 
new model program dependences reverse engineering 
proc 
symposium foundations software engineering 
krinke 
static slicing threaded programs 
proc 
acm sigplan workshop program analysis software tools engineering paste 
krinke snelting 
validation measurement software application slicing constraint solving 
information software technology 
liang harrold 
efficient points analysis program analysis 
esec sigsoft fse 
sinha harrold 
effects pointers data dependences 
proc 
th intl 
workshop program comprehension 
ottenstein ottenstein 
program dependence graph software development environment 
proc 
software engineering symposium practical software development environments 
reps 
precise interprocedural chopping 
proc 
third acm sigsoft symposium foundations software engineering 
reps horwitz sagiv 
speeding slicing 
proc 
second symposium foundations software engineering 
robschink snelting 
efficient path conditions dependence graphs 
proc 
intl 
conference software engineering 
ryder landi philip stocks zhang 
schema interprocedural modification side effect analysis pointer aliasing 
acm trans 
prog 
lang 
syst 
sharir pnueli 
approaches interprocedural data flow analysis 
program flow analysis theory applications 
prentice hall 
weiser 
program slicing 
ieee trans 
softw 
eng 
