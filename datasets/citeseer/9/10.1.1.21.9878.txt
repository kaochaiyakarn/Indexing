consideration publication functional programming predicative analysis structural recursion andreas abel department computer science university munich munich germany mail abel tcs informatik uni muenchen de thorsten altenkirch school computer science information technology university nottingham nottingham ng bb uk mail cs nott ac uk introduce language lambda calculus products coproducts strictly positive inductive types allows definition recursive terms 
implementation foetus syntactical check ensures terms structurally recursive recursive calls appear arguments structurally smaller input parameters terms considered 
ensure correctness termination checker show structurally recursive terms normalizing respect operational semantics 
define semantics types structural ordering values semantics prove values accessible regard ordering 
point proof set operators 
lambda calculi inductive types standard means construct function inductive type recursor corresponds induction 
method drawbacks discussed coquand 
programs hard understand intuitively 
division function may coded natural numbers booleans follows oe 
oe oe oe oe oe oe half true false false alternatively presence products implemented involving auxiliary function returning pair 
cases additional constructs unavoidable 
concept parallel complete resp 
wellfounded induction investigated recursive definitions pattern matching common functional programming languages 
sml example written straightforward follows supported logik der informatik dfg office technology education carnegie mellon university 
abel altenkirch datatype nat nat fun half half half half recursive definitions pattern matching satisfy conditions define total functions 
patterns exhaustive mutually exclusive 
focus point foetus language introduce sect 
uses case expressions totality pattern 
discussion see coquand 

definition founded means arguments function value founded computation tree 
ensured give termination ordering function ordering respect arguments smaller input parameters recursive call function 
find termination orderings dealt comprehensively area termination rewriting dershowitz functional programs giesl 
restrict structural orderings lexicographic extensions sufficient cases focus theoretical foundation completeness 
structural ordering usually value considered structurally smaller value component resp 
subterm ordering 
defined transitive closure constructor inductive datatype 
basis structural ordering terms defined hold iff evaluates alternative pursue define structural ordering terms independently show evaluation maps ordering values 
axiom motivated term structure 
consider axiom motivated type structure oe 
informal justification axiom drawn set theory function defined set argument result pairs 
result seen component contains possible results 
verify detail order induced wellfounded major contribution article 
relies crucially type system 
case means inductive types strictly positive 
furthermore structural recursion exclude impredicative polymorphism destroys structural ordering exemplified coquand 
consider program written haskell nd order polymorphism data forall 

argument constructor polymorphic function type id id id id id id structural ordering longer wellfounded function applied id loops infinitely 
structural recursion define structurally recursive function recursively defined function calls directly indirectly structurally smaller arguments 
consider addition ordinal numbers implemented sml follows datatype ord ord lim nat 
ord fun lim lim fn nat 
structurally recursive recursive call second argument decreasing 
call axiom second call lim axioms 
shall syntactic conditions sufficient ensure function structurally recursive checked mechanically 
implemented termination checker language foetus accepts structural recursive definitions 
termination checker reimplemented coquand part 
lexicographic termination orderings foetus termination checker accepts functions structural recursive lexicographic extension structural ordering ackermann function implemented hugs see jones reid section 
abel altenkirch fun ack ack ack ack ack ack check recursive calls ack ack 
argument decreasing third nested call ack argument stays second decreased lexicographic ordering theta mutual recursion call graphs handle mutual recursion requires additional considerations 
shall sketch method means example fun flat flat ls aux ls aux ls flat ls aux xs ls aux xs ls function flat takes list lists returns list making auxiliary function aux processes list 
extract calls respective behavior arguments organize call graph solid arrows flat 
aux gg aa arrow labeled call matrix respective call rows represent input parameters calling function columns arguments called function 
cell call matrix expresses argument call strictly smaller ith parameter calling function denotes weak decrease stands increase absence information 
example call flat aux arguments ls structurally smaller input parameter ls flat 
continued combination adjacent calls obtain completion graph contains direct indirect calls function 
case yields flat dotted arrow flat flat 
function structural recursive apply default demand recursive call decrease argument structurally case flat 
treat call graphs formally sect 

structural recursion semantic analysis termination checker recognizes structurally recursive functions 
want know rely checker output want know structurally recursive functions terminate inputs 
case structural ordering founded fundamental assumption coquand 
sect 
give interpretation types systems monotone operators value sets 
introduce structural ordering values interpretation closed types prove ordering wellfounded 
show accepted terms normalize operational semantics 
predicative meta theory sect 
give semantic interpretation types impredicative metatheory show types depend strictly positively type variables give rise monotone operators values 
define interpretation recursively defined types oe theorem knaster tarski monotone operator complete lattice fixpoint 
construction extended types depend positively type variables occurring left hand side scope number arrow types give rise monotone operators semantically abel :10.1.1.21.9878
construct fixpoint monotone operator completeness subset lattice construct fixpoint intersection 
construction impredicative define new subset quantifying subsets infinite set 
contrast predicative construction refer concepts defined previously 
construct fixpoints strictly positive operators correspond founded possibly infinitely branching derivation trees 
induction principle justified refer smaller previously constructed trees constructing new trees 
examples predicative theories martin lof type theory martin lof nordstrom aczel constructive set theory aczel 
sect 
show possible interpret predicative type system predicative meta theory 
concept set operators introduced peter aczel context intuitionistic set theory 
need special case deterministically set operators 
intuitively set operator understood monotone operator phi comes binary relation case simple data structures lists trees note property structurally recursive undecidable hope complete decision procedure 
sense proof theory calls theories stronger gamma impredicative 
consider bottom theories predicative instance id 
abel altenkirch type relation coincides element relation 
relation enjoys properties 
starting value set construct value set phi element phi urelements elements base set 
element phi true true universal value set reconstructed urelements phi fv wg 
show strictly positive type interpreted set operator fixpoints set operators constructed strictly positive inductive definitions meta level 
idea predicative strong normalisation proof abel altenkirch 
notational conventions vectors simplify notation 
family expressions en write sequence 
denote length sequence ej 
fixed write ee ene en furthermore notations type variables ae oe types term variables terms values function identifiers values closures environments set notation define predicates write define new predicates notation set comprehension 
sets order citizens meta theory quantify sets power sets 
write relations infix notation write write projections partial applications fx yg 
foetus language introduce term language simply typed lambda calculus enriched finite sum products inductive types style functional programming language 
allow definition recursive terms 
define normal forms explicitly values introduce environments avoiding define substitution 
meaning terms defined big step operational semantics 
types foetus type system constructed base type variables type constructors sigma finite sum pi finite product 
function space structural recursion inductive type 
restrict strictly positive recursive types reasons firstly clear formalize structural recursion non strictly positive types 
secondly clear non strictly positive types understood 
system set natural numbers may expressed set lists natural numbers theta type variables 
assume countably infinite set type variables tyvar elements denote 
type variable appears strictly positive type iff appears left side 
enforce variables type satisfy condition restricting domains function types closed types see rule arr 
definition types inductively define family types ty indexed finite list distinct type variables tyvar appearing strictly positive follows var xn tyvar ty sum oe oe ty sigma oe ty prod oe oe ty pi oe ty arr oe ty ty oe ty mu oe ty oe ty restrict free type variables strictly positive ones girard system girard polymorphic types need type variables construct inductive types 
notation 
write oe express oe ty 
oe oe synonyms 
abbreviate set closed types ty ty 
binary sums sigma oe write oe ternary ae oe 
products 
empty sum sigma denoted empty product pi 
renaming convention types 
binds type variable type oe may replace appearances oe new variable altering denoted type 
distinguish oe oe 
style variable binding see rules var mu close implementation variables debruijn indices see de bruijn kept variable names better readability 
substitution 
provided type oe list free variables equally long list types ae ty define capture avoiding substitution oe ae abel altenkirch ty usual way 
write oe ae oe ae define substitution single variable oe ae oe ae abbreviate oe ae 
terms define terms inhabiting types defined 
definitions similar typed lambda calculus enriched sums products recursive terms allow 
decided type terms contexts simplify definition closures 
term variables contexts 
assume countably infinite set term variables denote elements set 
closed types oe oe form context gamma oe oe cxt list pairwise distinct term variables types 
write oe express assumption variable type oe 
definition terms define set typed terms tm oe gamma closed type oe context gamma inductively follows var gamma oe gamma cxt tm oe gamma oe gamma tm oe gamma oe tm sigma oe gamma case tm sigma oe gamma tm ae gamma oe case oe oe tm ae gamma tup tm oe gamma tm pi oe gamma pi tm pi oe gamma tm oe gamma lam tm gamma oe oe tm oe 
gamma rec tm oe 
gamma oe 
rec oe 
tm oe 
gamma app tm oe 
gamma tm oe gamma tm gamma fold tm oe oe gamma fold oe tm oe gamma unfold tm oe gamma unfold oe tm oe oe gamma main kinds term forming rules rules introducing types constructors tup lam fold rules eliminating types de structural recursion case pi app unfold 
remaining rules var rec structural 
renaming convention terms 
rules case binds variables terms binds rec binds types distinguish terms equal names bound variables differ 
notation 
similar type notation oe write oe express type oe gamma term context gamma oe gamma express tm oe gamma 
define set closed terms tm oe type oe set terms empty context tm oe 
omit type annotation fold unfold abstractions introduce ambiguity 
currying 
termination analysis convenient view function arguments uncurried form function argument product type 
support formulation functions arity introduce construct tm gamma oe oe oe oe tm pi oe 
gamma semantic point view just syntactic sugar pi oe result replacing instance oe interpreted oe theta example flat function clarify different constructs language give encoding list flattening function foetus 
function takes list lists natural numbers transforms list natural numbers 
required datatypes defined foetus fixpoint types nat listn nat theta listn theta identifiers bold font denote defined types terms part language mere abbreviations 
convenience define abbreviations constructors lists nil fold cons gamma fold gamma abel altenkirch natural number tm nat list tm listn construct extension cons list element follows tm nat tm listn tup tm nat tm nat fold fold nat thetax tm nat thetax defined abbreviations final line states cons tm listn recall definition flattening function fun flat flat ls aux ls aux ls flat ls aux xs ls aux xs ls main function flat recursive list lists returning list natural numbers 
denote identifier type listn 
pattern matching argument refer ll translates case construct flat rec listn ll case unfold ll nil listn aux ll fixpoint type unfold obtain sum type distinguish cases 
alternative unfold ll means injection unit type 
interested specific inhabitant unit type involved anonymous variable 
case ll encodes empty list return empty list nil 
second case unfold ll listn deal injection pair consisting list natural numbers list lists 
case handled auxiliary function denoted placeholder aux 
simultaneous recursion sml translated nested interleaving recursion foetus 
simply define aux recursion operator rec substitute occurrence placeholder aux flat 
way realize calls flat aux 
calls aux flat simply refer identifier aux scope omitting type annotations full program reads follows flat rec ll case unfold ll nil rec listn ls case unfold ls nat cons ls structural recursion definition aux assigned function identifier syntactic sugar 
obtain version replace listn ls listn ls readers familiar sml know fun core construct programming language replaced primitive val rec harper 
replacing simultaneous recursion interleaving recursion obtain version original program similar foetus encoding val rec flat fn ll 
val rec aux fn ls 
case 
flat ls xs 
aux xs ls case ll ls 
aux ls note rec conjunction sml appear position foetus programs 
values closures assign meaning closed terms tm oe evaluate syntactic values type oe 
going define semantic values see sect 
process evaluation defined operational semantics handle open terms environments assign values free variables 
entails define substitution terms 
term corresponding environment form closure seen completion open term 
values 
define val oe inductively follows 
write oe express val oe set environments val gamma defined simultaneously see definition 
tm gamma oe val gamma hx oe ei val oe 
tm oe 
gamma oe 
val gamma oe 
ei val oe 
vin val oe oe val sigma oe val oe val pi oe abel altenkirch val oe oe fold oe val oe rules correspond rules terms 
values represent evaluated terms need constructors destructors 
environments closures 
define set environments context gamma oe oe val gamma fx xn vn val oe write gamma environment val gamma delta empty environment 
set closures type define cl fht ei gamma cxt tm gamma val gamma ff val oe 
val oe syntactic function symbol val oe 
theta val oe cl closures form value applied value convenient define operational semantics casting values back terms implementation inefficient 
renaming convention closures 
closure variables term bound consider closures differ variable names equal 
operational semantics big step operational semantics defines closures evaluated values 
strategy call value see rule evaluate rec see rules 
furthermore deterministic closure computation tree 
definition operational semantics inductively define family relations oe cl oe theta val oe indexed ty 
type oe inferred type closure value generally leave 
reasons readability leave type context annotations possible 
hx opin ht ei hin ei structural recursion ht sigma oe gamma ei oe ht gamma oe wi ei ht ei ei ht ei ei hx ei hx ei ei ei ht ei hs ei ht ei ht ui hx ei ht eii ei ht ei ei fold ht ei fold ei proposition deterministic implies proof closures computation rule 
closures case analysis computation tree ht may evaluate fixed instance applicable 
foetus termination checker syntactic check recursive term structurally recursive consists phases 
function call extraction 
recursive term analyzed recursive calls gathered 
analysis dependencies new variables gained information new variable structurally smaller known 

call graph generation completion 
calls gathered organized call graph completed 

search termination ordering 
completed graph recursive calls function consideration extracted 
searched lexicographic ordering arguments ensures termination 
abel altenkirch termination checker major data structures dependencies calls minor data structure function stack 
dependencies delta set dependencies delta collection variables dependencies derive arguments decrease structurally recursive call 
generated learn information terms stepping case construct 
semantics term case xn yields constraints scope may safely assume calls call function arguments function formal parameters xm denoted ij ij refer ij call matrix elements indicate arguments behave function call ij shown strictly structurally smaller ij ensure equal ij previous alternatives holds 
denote sets calls function stack phi traverse term build function stack phi contains name functions formal arguments 
analyze rec xn push xn stack 
topmost element denotes function body currently inspecting 
procedure analyzes term finds function calls computes call matrices form judgments delta phi function call extraction delta structural ordering terms remainder section define judgments sect 
state properties call matrices sect 
give algorithm finds indirect calls graph completion sect 
show find lexicographic ordering ensures termination sect 

function call extraction foetus program termination checker extracts set function calls extraction process formalized follows definition function call extraction delta set dependencies phi function stack term set calls 
extracted iff delta phi structural recursion read dependencies delta functions phi term contains calls 
judgment established rules recursive functions calls delta phi xn delta phi rec xn delta phi delta ij delta phi xm ij delta phi delta phi delta ij delta phi phi rec ij dependencies delta phi delta phi delta phi case congruences delta phi delta ain delta phi delta phi delta phi delta phi api delta phi delta phi delta phi delta phi delta phi delta phi delta phi afold delta phi delta phi fold delta phi delta phi unfold note rules add new calls set calculate call matrix ij rely judgment inferring structural ordering terms describe section 
read upwards rules provide algorithm extracting function calls typed term stated non deterministic rules application exist 
stipulate override 
algorithm deterministic complete return function calls clarify algorithm example 
recall flattening function implementation foetus stripped type annotations abel altenkirch flat rec ll case unfold ll nil rec ls case unfold ls cons ls table gives snapshots extraction algorithm action 
display dependencies delta function stack phi points calls detected 
delta phi call delta unfold ll ll rec ls delta unfold ll ls ls delta unfold ll ls ls cases call matrices computed delta phi arguments call 
section 
structural ordering terms second integral part termination checker calculus allows determine set dependencies delta derive relation form restricted calculate function argument structurally smaller function parameter right hand side variable 
definition structural ordering terms delta set dependencies term variable 
judgment delta states dependencies delta term strictly structurally smaller variable 
defined rules motivation 
stated motivate structural ordering mainly fact constructor inductive datatype increases order 
example cons fold constructor inductive datatype involves fold outermost position sufficient term constructors pairing injection increase order weakly 
form chain fold term constructor oriented definition motivated observable values programming language 
come back sect 

program analysis perform consider term destructors 
consider structural recursion recursive function rec argument shown structurally smaller parameter derived involving destructors 
perspective destructors inequality looks follows nil tail case nil motivates rules refl delta delta delta case rpi delta delta rapp delta delta delta delta unfold process function call extraction step branch case construct case introduce new variable constrained dependency checking delta reduced variable destructor rules dependency transitivity 
delta delta delta delta arising calculus deterministic 
number rule applications necessary decide delta limited size delta sum sizes terms delta 
continuing example section show call second argument smaller parameter unfold ll ll 
furthermore show call unfold means argument decreased 
refl ll ll unf unfold ll ll trans unfold ll ll pi unfold ll ll refl unf unfold trans unfold pi unfold sake simplicity ignore fact constructors contained eliminated larger number destructors 
see 
abel altenkirch limitations limit rules destructors termination checker accept recursive calls constructors arguments 
consequence recognize termination functions computes sum list fun sum sum sum sum sum program mechanically transformed terminates lexicographic ordering 
deciding delta calculus decide delta delta purpose construct derivation delta undetermined 
time invoke rule unfold fix 
definition write delta iff delta call matrices behavior arguments call xm dependencies delta expressed matrix ij thetam define ij delta delta delta delta columns matrix stand input variables calling function rows arguments call 
operations delta defined table set forms commutative semi ring zero unit delta operation understood combining parallel information relation 
instance 
simplifies operation delta serial combination example combined 
delta simplified element neutral regarding provides new information dominant strongest information 
regarding delta relation neutral dominant destroys information 
semi ring define multiplication matrices structural recursion allows compute size change information combined call sense calls ym ij thetal ij thetam argument behavior indirect call captured matrix product ij ij ij ik kj thetal definition call matrix call matrix matrix element different row 
cm ij thetam ij ik reason define call matrices way ones foetus produces function call extraction 
definition structural ordering terms call argument depend function parameter 
calls example call matrices gamma delta proposition ensures matrices foetus deal call matrices 
proposition call matrix multiplication multiplication matrices induces multiplication call matrices delta cm theta cm cm operation defined 
proof ij cm ij cm ab ij thetal index element ith row different 
element exists 
rules semi ring ij ik kj consider ith row ij jl jl different element different 
cm 
abel altenkirch call graphs give formal treatment call graphs graph completion algorithm central part termination checker 
nodes call graphs function identifiers arity names function parameters longer relevance 
assume infinite supply ff identifiers functions arity edges call graph taken set calls calls cm calls contain call matrix source target function identifier arities simply identify call graph edges definition call graph call graph finite set calls calls 
operation consecutive calls put 
definition call combination partial operation combination calls ffi calls theta calls calls 
ba calls call matrix calls call matrix indirectly calls call matrix ba 
operation ffi applied calls common function partial 
call combination lifted sets calls ffi calls theta calls calls 
fc ffi calls dom ffi calls combine call call ffi calls applicable form set combined calls 
course ffi calls total monotonic function 
ffi ffi denotes set calls combinations exactly calls decide call graph sense witnesses termination involved functions complete include indirect calls check reflexive calls function decreasing 
completeness defined means combination operation ffi definition complete call graphs call graph complete ffi completion smallest supergraph complete 
completion graph computed saturation algorithm 
structural recursion theorem completion algorithm call graph sequence call sets defined recursively follows cn cn ffi exists cn proof finite number nodes number distinct calls nodes finite grow endlessly th 
cn implies cn ffi cn cn iteratively gives cn ffi cn 
cn infer cn ffi cn cn cn complete remains show minimality conclude proof 
complete supergraph ffi ffi iterating result obtain 
laws set union cn shows cn give completion example call graph 
added calls dotted arrows labelled call matrices square brackets 
flat aux delta delta gg gg gamma delta delta aa delta aa lexicographic orderings completing call graph foetus checks reflexive call function decreasing size arguments 
lexicographic orderings considered necessary order arguments computed 
provide formal description 
definition complete call graph function arity call delta cg recursion behavior function 
delta takes diagonal square matrices 
tuple set represents possible recursive call orders parameters altered call 
diagonals call matrices taken want know parameter relates old value call abel altenkirch identify lexicographic orderings parameters permutations sn arguments 
write kn gamma sn permutation 
parameters relevant termination listed lexicographic ordering appear permutation sequence 
write km gamma arbitrary representative subset gamma ae sn definition introduce abbreviations gamma gamma sn gamma kn gamma sn ae gamma gamma kn gamma gamma kn gamma fr gamma tuple result removing ith component set results removing relation tuples containing ith position shortening remaining tuples ith component 
definition recursion behavior sn permutation 
define relation lexicographic ordering inductively follows note definition gives direct algorithm computing lexicographic ordering recursion behavior find continue definition function arity call graph say sn termination ordering iff lexicographic ordering recursion behavior example flat recursion behavior termination ordering aux recursion behavior termination ordering 
impredicative semantic analysis having algorithm check terms structurally recursive want know rely output checker 
show definition structural recursion sound 
involves mutually recursive functions lexicographic extensions structural ordering generalized inductive types higher order functions 
consider evaluation application structurally recursive function structural recursion means evaluation evaluate requires evaluation structurally recursive know structural ordering 
surely evaluation terminates domain wellfounded infinite descending chains 
prove system domains wellfounded 
define semantics types sect 

semantics define structural ordering show wellfounded sect 

extend ordering lexicographically sect 

show soundness structural recursion induction typed terms sect 

interpretation types give semantics types foetus captures values values ensure termination 
sense function value evaluates result applied argument 
define semantics types prove monotonicity inductive definition 
definition semantics type oe ty closed types xj define semantics oe oe val theta theta val val oe induction oe simultaneously prove monotonicity oe val implies oe oe var assumption 
sum sigma oe fin oe induction hypothesis fin oe fin oe monotonicity sigma oe sigma oe prod pi oe oe ng pi oe pi oe ind hyp 
monotonicity cartesian product 
arr oe 
val oe oe vg abel altenkirch assume oe oe 
definition value ind hyp 
oe 
mu know oe gamma monotone theorem knaster tarski define oe smallest set closed rule oe oe fold oe monotonicity prove oe closed rule assume oe oe 
ind hyp 
monotonicity oe entails oe oe fold oe 
proposition substitution property oe oe proof induction oe 
cases sum prod arr immediately shown induction hypothesis look remaining var mu show fixed point right side closed rule defining left omit oe oe fold oe ind hyp 
get assumption oe oe infers 
analogously corollary subset property 
oe oe proof iterated application proposition monotonicity oe 
structural ordering semantic values define transitive structural pre ordering semantic values 
basic idea value structurally smaller value representing tree subtree approach order value decreased note different relations terms defined sect formalize behaviour termination checker 
structural recursion 
destructor unfold case analysis projection application keep level 
need ordering show function val oe 
terminates input oe terminates oe structurally smaller need compare values type oe 
injection pairing building functions enlarge type folding shrinks type need folding step obtain greater value type oe value sufficient unfolding decreases order strictly 
definition codomain define codomain function oe 
codom oe definition structural ordering define pair mutually dependent families relations oe oe oe theta inductively follows refl oe oe rin ae oe ae sigma oe ae oe ng ae pi oe ae codom ae oe 
fold oe oe fold fold oe oe fold notation 
indexes oe oe oe determined expressions omit better readability 
proposition properties relations transitive reflexive contained ae ae proof show closed rules defining case fold show fold assumption immediately fold cases apply respective rule induction hypothesis 
having shown theorem verify relation antisymmetric 
shall term ordering anticipation fact 
relation captures notion smaller values allows prove computation trees values 
abel altenkirch want show set semantic values wellfounded value accessible 
define sets accessible values show value accessible set type 
definition accessibility family relations oe oe theta indexed closed types oe ty define family accessible sets acc inductively follows 
acc oe oe oe acc oe acc rule acc invert obtain destructor acc gamma acc oe acc oe furthermore definition yields wellfounded induction principle oe family predicates values type oe 
oe ae ae ae oe acc oe oe notation 
abbreviate acc acc lists ae types abbreviation acc ae acc ae acc ae show semantic values accessible 
sufficient know semantic values closed types oe accessible 
prove types show stronger proposition semantic values open types accessible insert sets accessible values free type variables 
theorem semantic values accessible type oe ty closed type ae free variable oe relation holds oe acc ae acc oe ae prove theorem fact generation semantic values preserves accessibility see lemma 
show property need accessibility equal values lemma follows lemma 
lemma destructors acc value accessible component values accessible acc sigma oe acc oe acc pi oe acc oe acc oe 
codom acc fold acc oe acc oe oe structural recursion proof assumption acc sigma oe show acc oe acc refines acc ae assumption entails acc gamma obtain acc ae 
analogously tup show codom acc assume codom arr get acc gamma proves acc ae acc 
prove accessibility show acc ae assumption 
fold get fold fold accessible premise acc ae acc gamma 
lemma accessibility equal values values equal accessible value accessible 
acc acc acc oe proof show relation oe acc oe acc closed rules defining refl acc oe acc oe assumption 
ind hyp 
acc oe acc ae show acc sigma oe acc ae follows acc sigma oe acc oe 
way treat remaining rules pi arr fold propositions 
lemma constructors acc value accessible components accessible 
acc oe acc sigma oe acc oe acc pi oe oe 
codom acc acc oe 
acc oe oe fold acc oe proof propositions goal form gamma acc gamma refine gamma acc ae prove case analysis gamma 
generated acc gamma get acc ae abel altenkirch 
ng th 
acc oe acc ae holds 
generated arr codom 
assumption acc acc ae 
fold case fold matches acc get acc ae proof theorem show oe acc ae acc oe ae induction oe 
var acc ae acc ae acc ae sum sigma oe acc ae 
suitable ng oe acc ae 
ind hyp 
acc oe ae acc sigma oe ae 
prod pi oe acc ae 
oe acc ae ind hyp 
acc oe ae acc pi oe ae 
arr assume oe 
acc ae 
codom acc ae definition ind hyp 
entails codom acc ae corollary infers oe 
ae acc oe ae 
mu prove acc oe ae closed rule defining oe acc ae show oe acc ae acc oe ae fold acc oe ae applying ind hyp 
premise entails acc oe ae oe ae infers 
corollary semantic values coincide accessible ones 
oe acc ae acc oe ae proof theorem closed types ae lemma immediately get ae acc ae proposition acc oe ae oe ae oe ae oe acc ae 
lexicographic extension termination checker allows descent lexicographic orderings recursive functions define values prove wellfounded 
denoting tuples vector notation allow omit enclosing parentheses pi oe write just furthermore abbreviations shortened vectors permutations defined sect 

definition lexicographic ordering closed types oe oe oe permutation sn inductively define oe pi oe pi oe theta pi oe follows structural recursion lex 
oe pi oe lex oe pi oe oe pi oe proposition lexicographic ordering closed types oe oe oe relation holds pi oe acc pi oe oe show proposition need lemma lemma acc oe acc oe proof case analysis transitivity structural ordering show oe oe proof prop 
induction extensive wellfounded induction principle 
show acc oe refines oe acc oe true case matches oe 
goal oe oe acc pi oe oe theorem replace oe acc oe apply wellfounded induction 
gives hypothesis acc oe show oe acc oe ind hyp 
replace oe acc pi oe oe apply founded induction obtaining oe acc oe show acc oe prove oe acc oe case analysis generation oe case lex acc oe case oe lex hypothesis entails acc oe 
lemma acc oe corollary regard lexicographic ordering value tuples exactly accessible ones 
pi oe acc pi oe oe abel altenkirch soundness structural recursion show system sound prove normalization restrict recursive terms structurally recursive ones 
restricting environments ones containing semantic values show term normalizes regard operational semantics defined sect 

define terms tm environments gamma closures 
stating structurally recursive functions terminate normalization proof mechanically 
definition environments subset environments semantic values context gamma oe oe naturally defined gamma fx xn oe val gamma definition say closure cl oe terminates iff evaluates value oe oe definition structural recursiveness define set structurally recursive terms sr oe 
gamma type oe context gamma recursive terms applied value terminate environment condition terminate structurally smaller values oe sr oe 
gamma tm oe 
gamma gamma oe oe oe ei ei proposition structurally recursive functions terminate rec sr oe 
gamma 
ei oe proof assuming gamma expand premise oe oe oe ei ei applying wellfounded induction family predicates ae ae ae ty defined ae ae ei ae oe true yields acc oe oe ei equivalent claim values accessible acc oe oe oe see corollary 
sr oe 
semantical criterion structural recursion 
replaced syntactical criteria certain classes structurally recursive functions 
abel provided criterion captures non mutually recursive functions terminate lexicographic extensions structural structural recursion ordering 
course required give proof syntactically structurally recursive functions semantically structurally recursive 
definition terms inductively define set terms tm oe gamma ae tm oe gamma type oe context gamma terms ensure termination 
rules identical original term formation rules see def 
change tm tm label rule capital letters 
tup tm oe gamma tm pi oe gamma rule rec replaced rec tm oe 
gamma oe 
rec sr oe 
gamma rec tm oe 
gamma definition closures consequently set closures cl type defined cl fht ei gamma cxt tm gamma gamma ff oe oe cl cl operational semantics closures 
ready show normalization 
theorem normalization tm oe gamma term type oe context gamma gamma environment 
exists oe ht ei proof induction tm oe gamma 
overload definition gamma mean gamma 
var gamma oe gamma gamma oe gamma prove hx gamma oe gamma di oe ind hyp 
ht oe ei oe opin hin sigma oe ei sigma oe case show sigma oe gamma ae gamma oe xn ae gamma oe ei ae ind hyp 
hu sigma oe gamma ei sigma oe 
form oe ind hyp 
get ht ae gamma oe wi ae prove claim 
tup show oe oe ei abel altenkirch ind hyp 
ht ei oe ei pi oe definition 
pi ind hyp 
ht pi oe ei pi oe ei oe 
lam hx oe gamma hx ei 
show hx ei oe hx ei oe 
refinement reduces goal ht ui get induction hypothesis 
rec show ei oe true lemma rec sr oe 
definition 
app ind hyp 
ht oe 
ei oe hs ei oe ht ei fold ind hyp 
ht ei oe oe ei fold oe definition 
unf ind hyp 
ht ei fold oe ei oe oe 
note shown normalization mutual recursive terms instance example flat handled case rec 
terms accepted termination checker recursive subterms sr proposition 
predicative analysis set operators definition theorem knaster tarski construct interpretation types 
section shall show impredicative reasoning necessary replaced strictly positive inductive definitions 
inductive definitions set considered inductively defined fixpoint monotone operator phi 
knaster tarski theorem operator fixpoint defined fp phi pg structural recursion fixpoint satisfies rules intro phi elim phi rule expresses phi 
second implies phi fixpoint second rule implies subset fixpoint 
definition said impredicative defining set totality subsets member 
second predicative way defining fixpoint bottom 
define ff phi ff lim fl ff ff flg 
ff ff omega omega uncountable ordinal 
calling predicative theories inductive definitions conception construction sufficient justify rules 
theory needs syntactic means ensuring operator phi monotone 
classically ensure phi positive constructively desirable strictly positive operator 
fact constructive point view desirable phi take simple form phi fv set binary relation 
case say fixpoint phi accessibility inductively defined interpreted accessible wellfounded part accessibility inductive definitions deterministic unique founded deduction tree shows enters inductively defined set quote discussion inductive definitions buchholz accessibility inductive definitions enjoy privileged position informal conception subject 
direct picture members sets generated leads immediately recognize id axioms fixpoint elimination rule correct 
picture 
furthermore carry definition recursion accessibility sets 
axioms inductive definitions need justified impredicative principles set satisfying closure conditions require prior classical theory ordinals 
section show replace positive fixpoint definition previous section accessibility definition giving construction clear predicative character 
example operator defining accessible sets sect 
simplified clarity phi acc ae fv ae fixpoint phi acc ae set acc ae accessible values type ae 
variable appears right hand side arrow operator strictly abel altenkirch positive 
contrast operator phi oe strictly positive variable appears argument oe 
oe just notational definition expand check appears strictly positive unfortunately interpretation gamma defined recursion structure type oe know oe argument 
solution problem replace phi oe semantically equivalent operator strictly positive 
done peter aczel set operators show section 
alternative reformulate definition types th 
interpretation strictly positive inductive definition directly 
approach carried holger vector notation simultaneously inductive types interleaving inductive types 
proof implemented predicative theorem proving system considers vector notation primitive 
interpreting strictly positive types interpretation oe strictly positive inductive type oe monotone capture fundamental property strictly positive types 
show abel wider class types enjoy property positive types :10.1.1.21.9878
show strictly positive types interpreted operators set definition predicative inductive definition possible 
consider set characterizing property strictly positive types 
extend def 
semantics requirement operator come relation construction follows closely abel altenkirch 
verification simpler need closure rules achieve 
definition semantics oe ty closed types define oe val theta theta val val oe definition additionally require relations oe val theta val oe val oe val oe oe sb oe val sb oe oe vg 
definition oe cases var sum prod arr 
interpretation types replaced oe val oe oe oe fold oe structural recursion define relations oe show satisfy required properties 
rule sb read oe oe states relations sort urelements back sets came 
precisely holds came value set rule sb expresses value reconstructed urelements 
demonstrate relation case lists implements element relation 
lists element type defined list theta closed type set values val lists introduced rules list list list readability notational definitions fold fold 
relation defined rules list list list property sb list states lists elements come property sb states list constructed elements non trivial 
proposition set lists sb list 
sb list list 
proof sb induction 
sb induction list base case trivial 
induction hypothesis list 
definition lists holds 
monotonicity list derive list goal follows 
proofs serve models proofs general inductive case 
theorem illustrates benefit set interpretation strictly positive types strictly positive 
theorem fundamental property strictly positive types assuming sb sb hold oe equivalent predicate strictly positive val oe oe oe val oe proof assuming oe obtain oe val monotonicity oe sb 
abel altenkirch sb oe val entails oe oe assumption oe component wise derive oe monotonicity 
see glance new strictly positive operator interpretation inductive types def 
constructs semantics old def 
written oe oe fold oe premises old rule match left hand side equivalence theorem premises new rule right hand side 
complete def 
give definition relation oe induction type oe 
case defined inductively set strictly positive rules prove laws set 
case sb proven induction derivation sb shown induction oe val monotonicity operators set properties defined types 
give detailed proof non trivial case types 
var sum oej oe sigma oe prod oe oej pi oe arr codom oe 
mu oe defined inductively rules non rec oe oe fold rec oe oe oe fold sb show oe closed rules defining oe non rec fold oe oe oe sb oe entails oe implies structural recursion rec oe oe 
sb oe premise oe implies oe 
second premise conclude 
sb show set fv oe oe closed rule defining oe val 
assume oe val sb oe entails oe oe show fold suffices show oe oe fold oe oe fold derive mon leaves subgoals 
show oe oe fold follows non rec 

show oe oe oe fold assume oe assumption oe oe fold rec 
sb oe oe oe mon oe oe fold 
introduced termination checker foetus structurally recursive terms recognizes descent lexicographic ordering 
interpretation types transfered ordering interpretation shown mutually recursive terms accepted foetus sound 
abel continued introduce judgment implements syntactic check functions structurally recursive 
judgment description algorithm foetus uses decide functions structurally recursive 
prove syntactic check sound semantics 
proof restricted non mutual recursion proof mutual recursion preparation 
extend polymorphic coinductive dependent types 
handle functions especially interplay guarded structurally recursive considered 
introducing dependent types effort done check totality pattern 
abel altenkirch related publications termination numerous research area carried beginnings computer science 
done context term rewriting systems want cite seminal investigations christoph walther walther described reduction checking referred walther recursion mcallester 
estimation calculus examines functions terminating output function strictly smaller input 
information check termination nested recursive functions just functions decrease input previously defined function recursive call 
estimation calculus done bundy 
closely related area extensible term rewriting systems blanqui jouannaud okada 
define structurally recursive terms syntactically side conditions extended general schema 
handle mutually recursive functions approach strength formal system sect 

ez presents syntactic translation structural guarded recursive definitions dependently typed context coq system barras calculus constructions coquand huet 
avoid having introduce analyze type theory consider structural recursion primitive principle 
consideration play role ez coq impredicative anyway 
ez shown integrate termination checking type checking 
uses tagged version types indicate inhabitants guarded constructor 
technique yields partial reduction checking free type system capture function reducer 
type system contain sigma types handle lexicographic descent 
extension sigma types non trivial obvious incorporate lexicographic products subtyping calculus 
ez motivated new technique follows side conditions typing rules ensure termination undesirable difficult construct semantics types needed normalization proofs 
article manage construct sound interpretation types rigid normalization proof authors abel 
altogether consider ez approach promising deserves attention scientific community 
amadio analyze calculus coinductive types check woven typing rules 
give model types interpret terms untyped calculus contrast observable values interpretation 
furthermore give proof strong normalization restricted reduction rule constructed data 
structural recursion codata unfolded head position case construct corresponds approach expand recursive functions case application 
turner investigating elementary strong functional programming functional programming languages terminating functions defined 
technically interpretations ensure termination 
handle wider class functions keep track argument decreasing decreasing increasing allowing temporary growth compensated sufficient shrinkage 
consider technique promising alternative logical approach 
focus maximal completeness solid theoretical foundation 
lee jones ben introduce new paradigm reasoning termination program terminates inputs infinite call sequence 
cause infinite descent data values 
characterize terminating functions accepted certain buchi automata 
interesting result termination checking pspace complete 
practical implementation termination checking propose algorithm size change graphs translated call graphs 
algorithm performs graph completion complexity results apply 
pfenning implemented reduction termination checking logical framework lf harper 
algorithm infer termination orderings checks termination ordering user specifies 
formulation algorithm judgment justified cut admissibility argument soundness proof case 
authors thierry coquand inspiring mail exchange discussions 
predicative semantics section inspired thierry coquand proposal carried peter aczel set operators 
jeremy ralph matthes frank pfenning anonymous referee comments draft versions 
author creator universe gave mankind gift creativity thinking 
abel andreas 

semantic analysis structural recursion 
diplomarbeit university munich 
abel andreas 

specification verification formal system structurally recursive functions 
types proof programs international workshop types selected papers 
lecture notes computer science vol 

springer verlag 
abel andreas altenkirch thorsten 

predicative strong normalisation proof calculus interleaving inductive types 
types proof programs inter abel altenkirch national workshop types selected papers 
lecture notes computer science vol 

aczel peter 

notes constructive set theory 
published www 
amadio roberto 

analysis guard condition type theory 
nivat maurice ed foundations software science computation structures international conference fossacs 
lecture notes computer science vol 

springer verlag 
barras bruno 

coq proof assistant manual 
inria 
version 
holger 

interpretation typen 
diplomarbeit university munich 
blanqui fr ed eric jouannaud jean pierre okada 

inductive data type systems 
theoretical computer science 
buchholz feferman solomon wolfram 

iterated inductive definitions subsystems analysis proof theoretical studies 
lecture notes mathematics vol 

springer verlag 
coquand 

agda home page 
coquand thierry 

pattern matching dependent types 
proceedings workshop types proofs programs 
coquand thierry huet gerard 

calculus constructions 
information computation 
de bruijn 

lambda calculus notation nameless dummies tool automatic formula manipulation application church rosser theorem 
mathematicae 
dershowitz nachum 

termination rewriting 
journal symbolic computation 
giesl jurgen 

termination analysis functional programs term orderings 
proceedings second international static analysis symposium 
lecture notes computer science vol 

springer verlag 
ez eduardo 

codifying guarded definitions recursive schemes 
pages dybjer peter nordstrom bengt smith jan eds types proofs programs international workshop types sweden june selected papers 
lecture notes computer science vol 

springer verlag 
ez eduardo 

structural recursive definitions type theory 
pages automata languages programming th international colloquium icalp aalborg denmark july proceedings 
lecture notes computer science vol 

springer verlag 
girard jean yves 

interpr etation elimination des coupures dans arithm etique ordre sup erieur 
th ese de doctorat etat universit de paris vii 
jeremy bundy alan green ian 

extensions estimation calculus 
pages ganzinger mcallester voronkov 
eds proceedings th international conference logic programming automated reasoning lpar 
lnai 
springer verlag 
harper robert 

programming standard ml 
carnegie mellon university 
harper robert honsell furio plotkin gordon 

framework defining logics 
journal association computing machinery 
jones mark reid alastair 

hugs user manual 
yale haskell group oregon graduate institute science technology www haskell org hugs 
structural recursion lee chin soon jones neil ben amir 

size change principle program termination 
acm symposium principles programming languages 
acm press 
martin lof 

intuitionistic type theory 
bibliopolis 
mcallester david kostas 

walther recursion 
slaney 
eds th international conference automated deduction new brunswick nj usa july august proceedings 
lecture notes computer science vol 

springer verlag 
nordstrom bengt petersson kent smith jan 

programming martin lof type theory 
clarendon press oxford 
brigitte pfenning frank 

termination reduction checking logical framework 
workshop automation proofs mathematical induction cade pittsburgh pa usa 
tarski alfred 

lattice theoretical fixpoint theorem applications 
pacific journal mathematics 
alistair turner david 

ensuring termination 
th british colloquium theoretical computer science 
walther christoph 

argument bounded algorithms basis automated termination proofs 
pages lusk ewing overbeek ross 
eds th international conference automated deduction 
lecture notes computer science vol 

springer verlag 
