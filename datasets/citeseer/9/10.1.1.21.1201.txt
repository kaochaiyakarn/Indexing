proceedings th annual ieee conference computational complexity ccc ulm germany june pp 

complexity expressive power logic programming thomas eiter georg gottlob andrei voronkov surveys various complexity results different forms logic programming 
main focus decidable forms logic programming particular propositional logic programming datalog mention general logic programming function symbols 
classical results plain logic programming pure horn clause programs results various important extensions logic programming surveyed 
include logic programming different forms negation disjunctive logic programming logic programming equality constraint logic programming 
complexity unification problem addressed 

logic programming lp known declarative method knowledge representation programming idea language order logic suited representing data describing desired outputs 
lp developed early automated theorem proving particular robinson resolution principle 
pure logic program consists set rules called definite horn clauses 
rule form head body head logical atom body conjunction logical atoms 
logical semantics rule implication body head precise account see section 
note semantics pure logic program completely independent order clauses order single atoms rule body 
institute mathematics st petersburg st petersburg russia 
currently uppsala university 
email ras ru 
supported swedish institute 
ag informatik university germany 
email eiter informatik uni de 
information systems department tu vienna vienna 
email gottlob dbai tuwien ac 
computing science department uppsala university box uppsala sweden 
email voronkov csd uu se 
supported tfr 
advent programming language prolog paradigm logic programming soon ready practical 
applications different areas successfully implemented prolog 
note prolog sense approximation fully declarative lp 
fact clause matching backtracking algorithms core prolog sensitive ordering clauses program atoms rule body 
prolog popular programming language taught computer science curricula research focuses pure lp extensions thereof 
application areas knowledge representation subfield artificial intelligence databases predominant need full pure lp 
knowledge representation declarative extensions pure logic programming negation rule bodies disjunction rule heads formalize common sense reasoning 
database context query language datalog designed intensively studied see 
query language function free pure lp allows user formulate recursive queries expressed standard query languages sql 
interesting complexity results lp 
results limited classical complexity theory comprise expressiveness results sense descriptive complexity theory 
example shown slight extension datalog just express polynomially computable queries ordered databases 
datalog precisely expresses captures complexity class ordered databases 
similar results obtained variants extensions datalog 
turned major variants datalog characterized suitable complexity classes 
consequence complexity theory important tool comparing logic programming formalisms 
surveys various complexity expressiveness results different forms purely declarative lp 
aim twofold 
broad survey pointers literature 
second fundamental topics explained greater detail particular basic results plain lp section funda mental issues related descriptive complexity section 
sections written tutorial style contain proofs sections written succinct survey style 
note consist encyclopedic listing published complexity results logic programming subjective choice results 
interesting results mention space reasons results may surveys :10.1.1.47.4330
example results abductive logic programming intuitionistic logic programming prolog 
organized follows 
section short lp 
introduce datalog distinguish notions data complexity program complexity combined complexity classes datalog programs 
section presents main complexity results plain lp datalog 
section discusses complexity lp negated atoms rule bodies 
section deals disjunctive logic programming 
section discusses expressive power datalog various datalog extensions 
section reports complexity unification problem 
section deals lp extended equality 
section deals complexity constraint logic programming expressive power logic programming complex values 

preliminaries section introduce basic concepts logic programming 
due space reasons presentation necessarily succinct detailed treatment see :10.1.1.20.7217
letters predicate symbols variables function symbols constants bold face version letter denotes list symbols respective type 

syntax logic programs logic programs formulated language predicates functions nonnegative arity ary functions constants 
language function free contains function symbols arity greater 
term inductively defined follows variable constant term ary function symbols terms term 
term ground variable occurs 
herbrand universe denoted ul set ground terms formed functions constants atom formula predicate symbol arity term 
atom ground ground 
herbrand base language set ground atoms formed predicates terms ul horn clause rule form am atom 
parts left right head body rule respectively 
rule form body empty called fact ground atom called ground fact 
logic program finite set horn clauses 
clause logic program ground terms ground 
logic program associate language consists predicates functions constants occurring constant occurs add constant technical reasons 
stated underlying language simplified notation bp respectively 
herbrand interpretation logic program subset bp herbrand base 
intuitively atoms true false 
herbrand model herbrand interpretation rule am interpretation satisfies logical formula delta delta delta am list variables rule 
propositional logic programs logic programs predicates arity atoms propositional ones 
example example propositional logic program shut shut leak leak valve closed pressure loss valve closed signal pressure loss signal signal signal signal note propositional logic program bp set propositional atoms 
interpretation subset propositional atoms 

semantics logic programs notions herbrand interpretation model generalized infinite sets clauses natural way 
set finite infinite ground clauses 
set defines operator tp bp 
bp bp denotes set herbrand interpretations tp fa bp contains rule am fa am ig operator called immediate consequence operator intuitively yields atoms derived single application rule atoms tp monotone knaster tarski theorem fixpoint denoted limit sequence tp 
ground atom consequence set clauses write 
definition negated ground atom consequence denoted semantics set ground clauses defined set consisting atoms negated atoms fa ag ag bp example ctd program signal closed pressure fixpoint reached steps shut appears set clauses coincides unique herbrand model model smaller model proper subset 
semantics arbitrary logic programs defined follows 
grounding clause language denoted ground set clauses obtained possible substitutions elements ul variables logic program define ground ground write ground ground 
operator tp bp 
bp associated defined tp ground accordingly ground 
example program fa ground contains clauses 
fixpoint tp ground fp 
practice generating ground cumbersome case function free languages general exponential size necessary compute order determine particular atom reasons completely different strategies deriving atoms logic program developed 
strategies variants robinson famous resolution principle 
major variant sld resolution 
roughly sld resolution described follows 
goal conjunction atoms 
substitution function maps variables vn terms result simultaneous replacement variables terms expression denoted 
goal program sld resolution tries find substitution logically follows initial goal repeatedly transformed empty goal obtained 
transformation step application resolution rule selected atom goal bm clause tries unify head find substitution 
substitution called unifier unifier goal transformed gamma bm precise account see resolution general clauses see 
complexity unification dealt section 

datalog logic programming suitable formalism querying relational databases 
context lp query language datalog various extensions thereof defined 
traditional query languages relational algebra sql datalog advantage able express recursive queries 
context lp relational databases identified sets ground facts 
intuitively ground facts predicate symbol represent data relation 
set predicate symbols occurring database possibly infinite domain argument constants schema database 
database associate finite universe ud constants encompasses constants appearing possibly 
classical database context ud identified set constants appearing datalog context larger universe ud may suitable case wants derive assertions items explicitly occur database 
understand datalog works state clarifying example 
example consider database containing ground facts father john mary father joe kurt mother mary joe mother tina kurt schema database set relation symbols domain string alphanumeric strings 
database associate finite universe ud mary joe tina kurt 
note susan appear database included universe ud datalog program query computes ancestor relationships relative database parent father parent mother ancestor parent ancestor parent ancestor person program father mother input predicates called database predicates 
interpretation fixed input database predicates ancestor person output predicates predicate parent auxiliary predicate 
intuitively output predicates computed visible result query auxiliary predicates introduced representing intermediate results considered part final result 
datalog program input database computes result database schema containing ground facts ancestor mary joe ancestor john joe person john person susan 
fact susan included constant ud fact person harry harry constant finite universe ud database formally database schema consists finite set rels relation names associated arities possibly infinite domain dom 
database schema denote hb herbrand base corresponding function free language predicate symbols rels constant symbols dom 
database database instance schema finite subset herbrand base hb associated finite universe ud ud dom denotes set constants appearing abuse notation write hd ud denote extension relation rels inst denotes set databases datalog query datalog program function free logic program associated database schemas input schema output schema complete schema satisfied dom dom dom rels rels rels rels rels rels 
predicate symbol appearing contained rels predicate symbol appears rule head means input database modified datalog program 
formal semantics datalog program input schema output schema complete schema partial mapping instances instances universe 
result instance regarded result query 
formally mp inst 
inst defined instances inst constants occurring appear ud maps database mp ud ud relation rels jp fc ground ground defined section language extended constants universe ud ground atoms hb write mp write mp 
semantics datalog inherited semantics lp 
similar way semantics various extensions datalog inherited corresponding extensions logic programming 
interesting complexity issues connected plain datalog various extensions 
ffl data complexity complexity checking fixed datalog program variable input databases ground atoms ffl program complexity complexity checking variable datalog programs ground atoms fixed input database recall fixed set constants may appear fixed 
ffl combined complexity complexity checking variable datalog programs ground atoms input database note plain datalog versions datalog considered combined complexity equivalent program complexity polynomial time reductions 
due fact derivation ground atoms pair hd easily reduced pair hd empty database instance associated universe constants obtained straightforward encoding universe ud tuples fc je 
reason disregard combined complexity material concerning datalog 
due fixed universe program complexity may allow slightly sharper upper bounds combined complexity vs dexptime 
lp general generalization combined complexity may regarded main complexity measure 
speak complexity fragment lp mean kind complexity ffl complexity lp complexity checking variable programs ground atoms 
complexity plain logic programming section survey basic results complexity plain lp 
section written slightly tutorial style sections order help readers familiar lp readers familiar complexity theory grasp key issues relating complexity theory logic programming 

simulation deterministic turing machines logic programs formally deterministic turing machine dtm quintuple sigma ffi sigma finite alphabet tape symbols containing special blank symbol finite set states ffi theta sigma gamma 
sigma theta gamma theta transition function initial state set accepting states loss generality assume accepting state terminal state enters accepting state remains state stops running 
dtm semi infinite cells input initialized follows 
cells ji gamma contain symbols string ji length cells contain 
transition function ffi represented table rows hs ff ff meaning stated follows rule instant time state positioned cell cell holds symbol ff instant state cell holds symbol ff positioned assumed loss generality gamma moves left possible describe complete evolution dtm input string initial configuration time instant configuration instant propositional logic program lp 
achieving define various classes propositional atoms cc ff ff sigma 
intuitive meaning instant computation cell contains symbol ff 
wp intuitive meaning instant positioned cell number st intuitive meaning instant machine state accept machine reached accepting state 
denote th symbol string delta delta delta ji gamma initial configuration input reflected initialization facts lp cc ff ji ff cc ji wp st entry hs ff ff transition table ffi translated propositional horn clauses call transition rules 
clauses asserted value cc ff st cc ff wp wp st cc ff wp st st cc ff wp clauses perfectly describe happening state transition instant instant 
forgotten tape cells changed transition keep old values instant 
reflected term inertia rules 
rules asserted time instant tape cells form cc ff cc ff wp cc ff cc ff wp group clauses termed accept rules derives propositional atom accept accepting configuration reached 
accept st construction fixpoint lp logic program lp lp reached lp ground atoms added lp lp gamma lp describe configuration input time instant gamma 
fixpoint lp contains accept accepting configuration reached computation steps 
lemma lp accept machine accepts input string steps 

complexity propositional lp simulation dtm propositional logic program described section need order determine complexity propositional lp complexity deciding holds logic program ground atom theorem implicit propositional lp complete logspace reductions 
proof 
membership 
obvious fixpoint operator tp program computed polynomial time number iterations applications tp bounded number rules plus 
iteration step clearly feasible polynomial time 
hardness 
language decidable steps dtm polynomial transform instance corresponding logic program lp ji described section 
lemma lp ji accept reached accepting state steps 
translation lp ji simple clearly feasible logarithmic space rules lp ji generated independently size logarithmic input note numbers log ji bits syntactic constituents rule constant size 
shown language logspace reducible propositional lp 
logic programming hard logspace reductions 
obviously theorem proved simpler reductions complete problems monotone circuit value problem proof principles computational nature lp provides basic framework form results derived slight adaptations sequel 
notice standard programming environment propositional lp feasible linear time appropriate data structures follows results deciding horn satisfiability 
mean problems solvable linear time model computation ram machine second polynomialtime reductions may general polynomially increase input 
theorem holds stronger reductions 
fact holds requirement logspace reduction reduction plt 
briefly map pi 
pi problem pi problem pi plt reduction deterministic direct access turing machines jf bit th bit see details 
recall separate input tape cells indirectly accessed index register tape 
encoding dtm lp highly regular easily seen plt reduction 
syntactical restrictions programs lead completeness classes inside lp denote logic restricted programs clause atoms body 
results easily obtains theorem lp nl complete logspace reductions 
notice dtm encoding easily modified programs lp 
lp complete 
restrictions yield problems complete course reductions stronger logspace reductions omit 

complexity datalog turn datalog consider data complexity 
grounding input database yields polynomially clauses size complexity propositional lp upper bound data complexity 
analogous variants datalog shall consider subsequently 
complexity propositional lp lower bound 
theorem implicit datalog data complete fact result follows proof theorem 
alternative proof hardness writing simple datalog meta interpreter propositional lp constant 
represent rules tuples ha ary relation propositional atoms 
program lp stored way database evaluated fixed datalog program pmi contains relation rule intuitively means atom true 
precisely pmi 
hardness data complexity datalog immediate theorem 
program complexity exponentially higher 
theorem implicit datalog program complete dexptime 
proof 
sketch membership 
grounding leads propositional program size exponential size fixed input database theorem program complexity dexptime 
hardness 
order prove dexptime hardness show dtm halts steps input ji simulated datalog program fixed input database fact empty database universe 
employ scheme dtm encoding lp predicates cc ff wp st propositional letters cc ff wp st respectively 
time points tape positions gamma represented ary tuples functions realized means successor succ linear order inductive definition suppose succ tell successor element linear order arity rules succ succ succ succ succ provided 
reduction usual ordering provide relations ground facts succ 
initialization facts cc ff readily translated datalog rules cc ff represents position similarly facts wp st 
remaining initialization facts cc ji translated rule cc represents number ji easily defined succ clauses 
transition inertia rules easily translated datalog rules 
realizing resp 
body atoms succ 
example clause cc ff st cc ff wp translated cc ff sts cc ff wp succ 
translation accept rules straightforward 
resulting datalog program holds accept accepts input steps 
easy see constructed logarithmic workspace datalog dexptime hard program complexity 
note straightforward simplifications construction possible omit part reused 
generic reduction hardness part theorem obtained applying complexity upgrading techniques 
briefly outline rest section 
technique utilizes conversion lemma form pi reduces pi pi reduces pi pi succinct variant pi instances pi boolean circuit computes bits see details 
strongest form conversion lemma appears plt monotone projection reducibility 
conversion lemma gives rise upgrading theorem stated strongest form theorem complexity classes long pi hard plt reductions pi hard projection reductions 
long long observations section obtain lp dexptime hard projection reductions program stored database represented binary string standard way 
lp reduced evaluating datalog program fixed database follows 
succinct instance lp boolean circuit boolean circuits computing constructed negation merely input gates 
circuit simulated straightforward datalog rules 
gate input gates described rule gate described rules 
desired program comprises rules boolean circuits rules meta interpreter pmi adapted binary encoding domain ud database binary tuples arity dlog ju je 
construction feasible logspace dexptime hard program complexity datalog follows 
see details 

complexity lp functions see happens allow function symbols logic programs 
case entailment atom longer decidable 
prove example reduce hilbert tenth problem query answering full lp 
natural numbers represented constant successor function addition multiplication expressed simple logic program theta theta theta undecidability full lp follows undecidability diophantine equations 
reduction shows completeness lp 
theorem full lp complete 
course theorem may proved simple encoding turing machines similar proof theorem terms representing cell positions time instants 
theorem generalized expressive semantics semantics 
natural decidable fragment lp functions non recursive programs intuitively predicate depends syntactically see section definition complexity characterized theorem 
theorem non recursive lp nexptime complete 
membership established applying constraints 
size derivation turns exponential 
nexptime hardness proved reduction tiling problem square theta fragments lp function symbols known decidable 
example result established simulation alternating turing machines logic programs vice versa 
theorem lp function symbols pspace complete rule restricted follows body contains atom size head greater equal body number occurrences variable body equal number occurrences head 
investigations decidability subclasses logic programs see 
see material recursion theoretic issues related lp 

complexity lp negation 
stratified negation literal atom called positive negated atom called negative 
literals complementary literal denote complementary literal set lit literals lit 
normal clause rule form lm atom literal 
normal logic program finite set normal clauses 
semantics normal logic programs straightforward numerous proposals exist cf 
:10.1.1.20.7217
general consensus stratified normal logic programs 
normal logic program stratified assignment str delta integers 
predicates clause holds predicate head predicate body str str positive str str negative 
reduct normal logic program herbrand interpretation denoted obtained ground follows remove clause negative literal body remove negative literals remaining rules 
notice set ground horn clauses 
semantics stratified normal program defined follows 
take arbitrary stratification str 
denote set rules str head predicate define sequence herbrand interpretations herbrand model mk 
str semantics str depend stratification str 
note propositional case str polynomially computable 
theorem implicit stratified propositional lp complete 
stratified datalog data complete program complete dexptime 
full lp stratified negation yields arithmetical hierarchy 
theorem full lp levels stratified negation sigma complete 
see complexity results stratification 
particular case stratified negation non recursive logic programs 
stratified program non recursive stratification predicate occurs defining stratum str heads rules 
logic program produced dtm encoding non recursive 
theorem implicit non recursive propositional lp complete 
non recursive datalog uniform ac data complexity program complete pspace 

founded negation roughly founded semantics wfs assigns value unknown atom defined negation :10.1.1.121.6788
briefly wfs defined follows 
fp operator fp fp anti monotone monotone greatest fixpoint denoted respectively 
meaning program wfs notice stratified programs wfs stratified semantics coincide 
theorem implicit lp wfs complete 
datalog wfs data complete program complete dexptime 
deciding wfs done linear time open 
full lp known 
theorem full lp wfs pi complete 

lp stable model semantics interpretation normal logic program stable model herbrand model general normal logic program may zero multiple stable models 
example program sleep sleep stable models denote sm set stable models meaning stable model semantics sms st sm bp note stratified unique stable model stratified stable semantics coincide 
rules increase complexity 
theorem propositional logic program deciding sm np complete 
proof 
membership 
clearly polynomial time computable stable model guessed checked polynomial time 
hardness 
modify dtm encoding section nondeterministic turing machine ntm follows 
state symbol ff introduce atoms ff 
ff transitions hs ff ff add ff bodies transition rules hs ff ff rule ff ff ff gamma ff ff 
intuitively rules nondeterministically select precisely possible transitions ff time instant transition rules enabled ff 
add rule accept accept ensures accept true stable model 
stable models resulting program correspond accepting runs easy consequence theorem cf 
lp sms np complete 
datalog sms data complete np program complete nexptime 
full lp sms complexity wfs 
theorem full lp sms pi complete 
results stable models recursive finite logic programs 

inflationary semantics inflationary semantics inspired inflationary fixpoint logic 
place uses limit sequence tp tp inflationary operator 
clearly computable polynomial time propositional program coincides horn clause programs results theorem implicit lp complete 
datalog data complete program complete dexptime 
semantics version page uses place limit sequence tp tp exists undefined 
similar equivalent algebraic query languages described earlier 
particular datalog equivalent partial fixpoint logic 
easily seen propositional program computable polynomial space bound tight 
theorem lp pspace complete 
datalog data complete pspace program complete expspace 

semantics negation number interesting semantics partial maximal stable models regular models perfect models valued completion semantics fixpoint models remain see details complexity results 

disjunctive logic programming informally disjunctive logic programming dlp extends lp adding disjunction rule heads order allow suitable knowledge representation increase expressiveness 
male female person naturally represents person male female 
disjunctive general logic program set clauses delta delta delta lm background see :10.1.1.124.9986
semantics free disjunctive logic programs minimal herbrand models unique minimal model exist general 
example fp minimal models fpg fqg 
denote mm set minimal herbrand models generalized closed world assumption gcwa negation free amounts meaning fl mm lg 
example consider program describing behavior reviewer reviewing bad happy angry bad smoke happy smoke angry models minimal happy bad angry gcwa gcwa smoke gcwa gcwa theorem deciding gcwa np complete ii deciding gcwa pi complete 
proof 
easy see atom holds gcwa pc pc classical logical consequence 
known np completeness sat part obvious 
consider part ii 
membership 
holds gcwa exists mm clearly guess verified oracle np polynomial time membership problem pi follows 
hardness 
sketch show pi hardness encoding alternating turing machines atm 
recall atm set states partitioned existential universal states 
machine reaches state resp 
state run input accepted computation continued resp 
possible successor configurations accepting 
polynomial time bounded atms start state alternation precisely transition state state run reverse transition solve precisely problems pi 
adapting construction proof theorem show machine input simulated disjunctive logic program gcwa 
assume run polynomial time bounded 
start clauses constructed ntm input proof theorem drop clause accept accept replace clauses ff ff ff gamma ff ff 
logically equivalent disjunctive clauses ff delta delta delta ff intuitively minimal model precisely atoms ff means possible branchings followed run 
current clauses constitute propositional program derives accept gcwa iff accept states universal 
need respect states 
state time point set clauses state st st cc ff st wp st ff st 
intuitively rules state run enters state true relevant facts involving time point true 
way runs tilted 
set terminal state clauses st intuitively clauses state true run ends state 
resulting program minimal models contain correspond accepting runs seen minimal models contain correspond partial runs initial state state completion run accepting state possible 
implies minimal model containing precisely definition accept input consequently gcwa minimal model accepts input clear program constructed logarithmic workspace 
consequently deciding gcwa pi hard logspace reductions 
notice problems field nonmonotonic reasoning pi complete 
stable negation naturally extends disjunctive logic programs adopting stable model disjunctive logic program iff mm subsumes disjunctive stratified semantics 
founded semantics natural extension known 
clearly easily computed negation free 
theorem dlp sms pi complete 
disjunctive datalog sms data complete pi program complete nexptime np result derived utilizing complexity upgrading techniques described section 
case functions theorem full dlp gcwa pi complete 
theorem full dlp sms pi complete 
disjunction adds complexity gcwa sms finite herbrand universes np pi infinite ones 
intuitively explained fact dlp sms corresponds weak fragment pi recursively translated pi semantics dlp analyzed having lower complexity sms possible model semantics causal model semantics higher regular model semantics 
typically pi complete propositional case 
cf 


expressive power logic programming expressive power query languages datalog topic common database theory finite model theory attracted attention communities 
expressive power query language understand set queries expressible language 
note mention query languages database systems formalisms formal logic finite model theory second order logic finite structures fixpoint logic precise definitions consult 
general query defines mapping suitable input database fixed input schema assigns result database fixed output schema logically speaking query defines global relations 
reasons representation independence query addition generic invariant automorphisms 
means automorphism input database permuting elements universe names constants 
speak queries mean generic queries 
formally expressive power query language set mappings queries expressible language important research tasks context 
comparing query languages expressive power 
may prove instance ae means set queries expressible proper subset queries expressible strictly expressive may show query languages expressive power denoted 
second research task related complexity theory determining absolute expressive power query language 
achieved proving query language able express exactly queries evaluation complexity complexity class case say captures write simply evaluation complexity query complexity checking atom belongs query result case boolean queries query evaluates true 
note substantial difference showing query evaluation problem certain query language complete showing captures evaluation problem complete hard query expressible captures expresses queries evaluable including course hard queries 
usually proving captures involved proving evaluating queries hard 
note possible query language captures complexity class complete problems exist known 
example second order logic finite structures captures polynomial hierarchy ph existence complete problem ph imply collapse 
database theory finite model theory dealing description expressive power query languages related logical formalisms complexity classes called descriptive complexity theory 
early foundational result field fagin theorem stating existential second order logic captures np 
eighties nineties descriptive complexity theory discipline deep useful results 
prove query language captures complexity class usually shows machine encodings finite structures inputs computes generic query represented expression language slight mismatch ordinary machines logical queries 
turing machine works string encoding input database encoding provides implicit linear order particular elements universe ud turing machine take profit order order computations long genericity obeyed 
hand logic database theory universe ud pure set unordered 
powerful query languages inherent nondeterministic nature level np problem ordering ud nondeterministically guessed 
query languages particular corresponding complexity classes np generating linear order possible 
assumes linear ordering universe elements predefined explicitly input database 
specifically ordered databases ordered finite structures mean databases schemas contain special relation symbols succ interpreted succ successor relation linear order determines element element order 
importance predefined linear orderings evident theorems 
coming theorems highlight small mismatch turing machine datalog setting 
turing machine consider input bit independently value 
hand plain datalog program able detect atom part input database 
due representational peculiarity positive information database negative information understood closed world assumption 
compensate deficiency slightly augment syntax datalog 
section assume input predicates may appear negated datalog rule bodies resulting language datalog extremely limited form negation weaker stratified negation easily circumvented adopting different representation databases 
theorem fortiori datalog ae proof 
hint 
show exists datalog program tell universe input database number elements 
theorem implicit ordered databases datalog captures proof 
sketch theorem query answering fixed datalog program remains show polynomial time dtm finite input databases inst simulated datalog program 
show simplifying assumptions 

universe ud initial segment gamma integers succ natural linear ordering segment 

input database schema consists single binary relation plus predefined predicates succ words graph hu gi 

computes boolean ary predicate 

operates steps ju 
simulation akin simulation proofs theorems 
recall framework section 
spirit framework suffices encode time points tape cell numbers fixed datalog program 
achieved considering tuples hx variables ranging tuple encodes integer int theta gammai simulation starts time point contains encoding input graph 
recall section reflected initialization facts cc ff ji ff translating rules appropriate datalog rules shall spend word input graphs usually represented binary strings 
graph hu gi encoded binary string enc length ju true gamma bit number enc bit 
bit positions enc exactly integers gamma 
integers represented tuples gamma yi int gamma yi enc iff true input database 
initialization rules translated datalog rules cc gamma cc gamma intuitively rule says true time point int bit number int gamma yi true 
second rule states bit false false 
note second rule applies negation input predicate 
rule entire datalog program negation 
clearly rules simulate time point cells 
gamma contain precisely string enc 
initialization rules described section easily translated appropriate datalog rules 
see rules translated datalog 
linear order succ easy define datalog clauses linear order tuples succ see proof theorem succ succ succ transition rules inertia rules accept rules easily translated datalog proof theorem 
output schema resulting datalog program defined 
clear program evaluates true input hu gi accept true iff accepts enc 
generalization setting simplifying assumptions straightforward omitted 
state somewhat succinctly interesting results datalog 
prominent query language fixpoint logic fpl extension order logic fixpoint operator lfp jxj ary predicate occurring positively free variables intuitively returns fixpoint operator gamma defined gamma fa see details 
shown fpl expresses proper subset queries datalog relates fpl follows 
theorem datalog fpl coincides fragment fpl having negation restricted database relations existential quantifiers 
theorem implicit stratified datalog ae fpl 
previous theorem obvious 
fact time coincidence languages assumed 
non recursive fragment datalog coincides known database query languages 
theorem cf 
non recursive datalog relational algebra sql relational calculus 
negation yields higher expressive power 
theorem datalog wfs fpl fpl datalog 
shown previous result holds total wfs founded model total 
ordered databases theorem theorems section imply theorem ordered databases stratified datalog datalog datalog wfs capture syntactical restrictions allow capture classes datalog fragment datalog rule predicate body datalog fragment datalog predicate occurs rule head 
theorem ordered databases datalog captures nl datalog captures due inherent nondeterminism stable semantics expressive 
theorem datalog sms captures np 
note result order input database needed 
informally stable model ordering guessed checked program 
fagin theorem implies datalog sms equivalent existential fragment second order logic finite structures 
theorem ordered databases datalog captures pspace 
ordering needed 
interesting result context formulated terms datalog datalog datalog arbitrary finite databases pspace 
direction obvious proof direction involved 
rare examples translates open relationships deterministic complexity classes corresponding relationships query languages 
briefly address expressive power disjunctive logic programs full logic programs 
case input databases arbitrary necessary recursive relations genuine infinite herbrand universe program 
theorem disjunctive datalog sms captures pi theorem full lp wfs full lp sms full dlp sms express pi expressiveness results see 
particular classes polynomial hierarchy captured variants stable models modular logic programming 

unification complexity complexity query answering simple logic programs consisting fact 
problem leads problem solving equations terms known unification problem 
unification lies heart implementations lp automated reasoning systems 
atoms terms called unifiable exists substitution equal terms coincide substitution called unifier unification problem decision problem terms unifiable 
robinson described algorithm solves problem answer positive computes general unifier terms 
algorithm exponential time space complexity mainly representation terms strings symbols 
better representations example directed acyclic graphs robinson algorithm improved linear time algorithms 
theorem unification problem complete logspace reductions 
hardness unification problem proved reductions versions circuit value problem 
article stated complete nl gives counterexample proof 
quadratic time linear time unification algorithms proposed algorithms suitable applications generalizations see survey main unification algorithms 
mention martelli montanari algorithm ideas going back famous herbrand 
modifications algorithm widely unification equational theories rewriting systems 
time complexity martelli montanari algorithm na gamma gamma function inverse ackermann function gamma grows slowly 

logic programming equality relational model data deals simple values tuples consisting atomic components 
various generalizations formalisms proposed handle complex values nested tuples tuples sets 
formalisms expressed terms lp equality constraint logic programming considered section 

equational theories language containing equality predicate 
equation mean atom terms equational theory set equations closed logical consequence relation set satisfying conditions contains equation ii contains contains iii contains contains iv contains contains ary function symbol contains contains substitutions 
syntax logic programs equational theory coincides ordinary lp 
semantics defined generalization semantics lp terms identified equal example demonstrate logic programs equality logic program processing finite sets 
finite sets typical example complex values handled databases 
represent finite sets ground terms follows constant fg denotes empty set ii represents set ground term ft sg represents set ftg ftg need disjoint 
equality sets defined identity terms equality equational theory terms considered equal represent equal sets omit axiomatization theory 
consider simple program checks sets non empty intersection 
program consists fact non empty intersection fx fx example check sets common member ask query non empty intersection 
answer positive 
system equations fx fx solutions equational theory sets example 
note represent sets lists plain lp equality encoding non empty intersection require recursion 
complexity logic programs depends complexity solving systems term equations problem system term equations solvable equational theory known problem simultaneous unification 
substitution called unifier terms equation logical consequence theory unification problem mean problem exists unifier terms 
ordinary unification viewed unification contains trivial equations natural think unifier solution equation theory 
complexity unification practically impossible overview results complexity unification result solving equation systems viewed result unification solving equations traditional subject mathematics 
restrict survey cases closely connected lp 
general theory unification may 
equational theory delta binary function symbol written infix form 
call delta associative symbol contains equation delta deltaz delta delta variables 
similarly delta called ac symbol abbreviation associative commutative symbol delta associative addition contains deltay delta delta ac symbol contains delta call delta aci symbol stands idempotence 
delta called ac symbol aci symbol delta ac symbol aci symbol respectively contains equation delta constant belonging theorem equational theory defining function symbol delta associative symbol contains logical consequences delta delta delta delta equations 
upper lower bounds complexity unification problem hold problem nexptime ii problem np hard 
basically algorithms unification associativity algorithm word equations 
nexptime upper bound obtained 
theorem characterizes popular kinds equational theories 
theorem equational theory defining symbols ac symbols aci symbols ac symbol aci symbols kinds symbols 
theory assumed contain equations 
unification problem np complete 

complexity non recursive logic programming equality case ordinary unification simple way reduce solvability finite systems equations solvability single equations 
kinds solvability equivalent theories exists equational theory solvability problem equation decidable solvability systems undecidable 
simultaneous unification determines decidability non recursive lp theorem equational theory 
nonrecursive lp decidable problem simultaneous unification decidable 
equational theory called np solvable problem solvability equation systems np 
example equational theory finite sets mentioned equational theory bags finite multisets equational theory trees containing equations np solvable 
theorem non recursive lp np solvable equational theory nexptime 
theory trees bags finite sets combination non recursive lp nexptime complete 

constraint logic programming informally constraint logic programming clp extends lp involving additional conditions terms 
conditions expressed constraints equations disequations inequations terms 
semantics constraints predefined depend logic programs 
example illustrate clp standard example 
suppose solve puzzle letters variables ranging decimal digits 
usual different letters denote different digits 
puzzle solved constraint logic program domain integers theta 
informally program written follows 
find delta delta delta delta delta delta delta delta delta delta query find answered solution structure defined interpretation language nonempty set example shall consider structure defined standard interpretation language consisting constant successor function symbol equality predicate set natural numbers 
structure denoted 
examples structures obtained replacing sets integers rational numbers reals complex numbers 
denote structures similar way keeping mind standard interpretation arithmetic function symbols number sets 
symbols theta stand multiplication division respectively 
delta denote unary functions multiplication particular numbers corresponding domain similarly 
structures consideration assumed contain equality symbol 
structure 
atom terms language called constraint 
constraint logic program mean finite set rules xn constraints predicate symbols occurring language xn lists variables 
semantics clp defined natural generalization semantics lp 
contains function symbols interpreted tree constructors equality corresponding terms interpreted ordinary unification clp extension lp 
clp regarded extension datalog constraints 

complexity constraint logic programming sources complexity clp complexity solving systems constraints complexity coming lp scheme 
interaction components lead complexity higher merely sum complexities 
example datalog dexptime complete linear arithmetic constraints satisfiability problem np integers rational numbers reals undecidable 
theorem clp complete 
holds proof uses fact clp allows define addition multiplication terms successor 
diophantine equations expressed fragment clp 
hand simpler constraints constraints ordered infinite domains particular kind increase complexity datalog 
theorem clp sigma sigma dexptime complete 
holds decidable fragments clp complex structures obtained restrictions imposed constraint logic programs 
example consider conservative clp rules satisfy restriction variables occurring body occur head 
theorem conservative clp dexptime complete structures gamma delta linear inequations rational numbers gamma delta linear inequations reals gamma theta polynomial inequations reals gamma theta polynomial equations complex numbers 
proof known results complexity algorithms corresponding algebraic structures 
allow non ground queries dexptime completeness replaced nexptime completeness 

expressive power logic complex values expressive power datalog queries defined terms input output databases finite sets tuples 
extend notion expressive power logic programming complex values define mean input 
example case plain logic programming input may finite set ground terms finite set trees 
case logic programming sets input may set elements may sets 
various models languages dealing complex values databases proposed 
comparative expressive power formalisms studied example 
introduces model restricted combinations tuples sets corresponding query languages including algebraic logic programming ones 
proved languages define class queries 
absolute expressive power languages terms complexity classes studied example particular show expressive power depends way representing complex values 
natural representation hereditarily finite sets graphs logical query language called bounded set theory captures versions bounded set theory shown capture nl 
interesting results expressive power different forms lp constraints 
research expressive power datalog mainstream research expressive power lp complex values 
research yielded far number ad hoc results approaches 
explained reasons 
reason different kinds complex values require different computational models 
reason kind complex values admits different definitions input output 
extension declarative query languages complex values main problems database theory practice 
research required develop unifying paradigms understanding expressive power 
abiteboul beeri 
power languages manipulation complex values 
vldb 
abiteboul hull vianu 
foundations databases 
addison wesley 
abiteboul vianu 
datalog extensions database updates queries 
computer system sciences 
abiteboul vianu 
computing order logic 
computer system sciences 
preliminary version stoc 

generalized completeness horn clause logic seen programming language 
acta cybernetica 
apt 
logic programming 
van leeuwen editor handbook theoretical computer science volume chapter pp 

elsevier science 
apt blair 
arithmetic classification perfect models stratified programs 
kowalski editors proc 
fifth jicslp pp 

mit press 
apt blair walker 
theory declarative knowledge 
minker editor foundations deductive databases logic programming pp 

morgan kaufman washington dc 
apt bol :10.1.1.20.7217
logic programming negation survey 
logic programming 
apt van emden 
contributions theory logic programming 
jacm 
baader schulz 
unification union disjoint equational theories combining decision procedures 
kapur editor th cade lncs lnai pp 

baader siekmann 
unification theory 
gabbay hogger robinson editors handbook logic artificial intelligence logic programming 
oxford university press 
diaz 
structural complexity ii 
springer 
lozano 
complexity algorithmic problems succinct instances 
manber editors computer science pp 

plenum press new york 
baral gelfond 
logic programming knowledge representation 
logic programming 
baral subrahmanian 
dualities alternative semantics logic programming nonmonotonic reasoning 
automated reasoning 
kapur narendran 
complexity matching problems 
symbolic computation 
benedikt dong libkin wong 
expressive power relational constraint query languages 
proc 
pods pp 

berman schlipf franco 
computing wellfounded semantics faster 
marek nerode truszczynski editors proc 
lpnmr lncs lnai pp 

springer 
blair 
recursion theoretic complexity semantics predicate logic programming language 
information control july august 
blair 
complexity local stratification 
fundamenta informaticae 
bonner 
hypothetical datalog complexity expressibility 
theoretical computer science 
greco 
expressive power unique total stable model semantics 
proc 
icalp 
appear 
cadoli schaerf 
survey complexity results non monotonic logics 
logic programming 
canny 
algebraic geometric computations pspace 
proc 
th annual acm stoc pp 
chicago illinois 
ceri gottlob tanca 
logic programming databases 
springer 
chan 
possible worlds semantics disjunctive databases 
ieee transactions knowledge data engineering 
chandra harel 
structure complexity relational queries 
computer system sciences 
chandra harel 
horn clause queries generalizations 
logic programming 
chandra kozen stockmeyer 
alternation 
jacm 
chomicki subrahmanian 
generalized closed world assumption pi complete 
information processing letters 
colmerauer 
un systeme de communication machine en 
technical report groupe de recherche en intelligence artificielle universite aix marseille 
cosmadakis kuper 
expressiveness firstorder constraint languages 
technical report ecrc european computer industry research center 
cox mcaloon 
decision procedures constraint extensions datalog 
benhamou colmerauer editors constraint logic programming selected research pp 

mit press 
cox mcaloon 
computational complexity constraint logic programming languages 
extended 
debray hermenegildo editors proc 
pp 

mit press 
dahlhaus 
skolem normal forms concerning fixpoint 
borger editor computation theory logic lncs pp 

springer 
voronkov 
complexity query answering logic databases complex data 
nerode editors lfcs lncs 
appear 
voronkov 
complexity query answering logic databases complex data 
technical report uppsala university computing science department 
voronkov 
note semantics logics programs equality complete sets unifiers 
logic programming sept 

wurtz 
smallest horn clause programs 
logic programming 

computational complexity prolog programs 
theoretical computer science 
dix gottlob marek 
reducing disjunctive non disjunctive semantics shift operations 
fundamenta informaticae 
dowling gallier 
linear time algorithms testing satisfiability propositional horn theories 
logic programming 
dwork kanellakis mitchell 
sequential nature unification 
logic programming 
dwork kanellakis stockmeyer 
parallel algorithms term matching 
siam computing 

ebbinghaus flum 
finite model theory 
perspectives mathematical logic 
springer 
eiter gottlob 
complexity propositional knowledge base revision updates counterfactuals 
artificial intelligence 
eiter gottlob 
propositional circumscription extended closed world reasoning pi complete 
theoretical computer science 
addendum 
eiter gottlob 
computational cost disjunctive logic programming propositional case 
annals mathematics artificial intelligence 
eiter gottlob 
complexity logic abduction 
jacm january 
eiter gottlob 
expressiveness stable model semantics disjunctive logic programs functions 
technical report cd tr christian doppler laboratory expert systems tu vienna austria july 
logic programming appear 
eiter gottlob leone 
complexity results abductive logic programming 
marek nerode truszczynski editors proc 
lpnmr lncs lnai pp 

springer 
eiter gottlob leone 
abduction logic programs semantics complexity 
theoretical computer science 
appear 
eiter gottlob mannila 
adding disjunction datalog 
proc 
th acm symposium principles database systems pods pp 
may 
eiter gottlob mannila 
disjunctive datalog 
acm trans 
database syst september 
appear 
eiter gottlob veith 
modular logic programming generalized quantifiers 
proc 
lpnmr 
appear 
extended cd tr information systems department tu vienna 
eiter leone 
expressive power partial models disjunctive deductive databases 
proc 
international workshop logic databases lid lncs pp 

springer 
tcs appear 
fagin 
generalized order spectra polynomialtime recognizable sets 
karp editor complexity computation pp 

ams 
levi martelli palamidessi 
declarative modeling operational behavior logic languages 
theoretical computer science 
fitting 
computability theory semantics logic programming 
oxford university press 
flum 
total partial founded datalog coincide 
afrati kolaitis editors proc 
th intl 
conference database theory icdt lncs pp 
january 
gallier 
extending sld resolution methods horn clauses equality unification 
symposium logic programming pp 

gallier 
extending sld resolution equational horn clauses unification 
logic programming 
gelfond lifschitz 
stable model semantics logic programming 
logic programming proc 
fifth intl conference symposium pp 
cambridge mass 
mit press 
gottlob 
complexity results nonmonotonic logics 
logic computation june 
gottlob leone veith 
second order logic weak exponential hierarchies 
hajek editors proc 
th mfcs lncs pp 
prague 
full available cd tr information systems department tu wien 
gradel 
capturing complexity classes fragments second order logic 
theoretical computer science 
green 
application theorem proving question answering systems 
phd thesis computer science department stanford university june 

solving systems polynomial inequalities subexponential time 
symbolic computation 
gurevich 
logic challenge computer science 
borger editor trends theoretical computer science chapter 
computer science press 
gurevich shelah 
fixpoint extensions firstorder logic 
annals pure applied logic 
hanus 
integration functions logic programming theory practice 
logic programming 
herbrand 
logical writings 
harvard university press 
holldobler 
foundations equational logic programming lncs lnai 
springer verlag 

quantifier elimination theory algebraically closed field 
proc 
st annual acm stoc pp 
seattle washington may 
immerman 
relational queries computable polynomial time 
information control 
immerman 
languages capture complexity classes 
siam comp 
immerman 
descriptive complexity 
springer 
appear 
jaffar maher 
constraint logic programming survey 
logic programming 
jones 
complete problems deterministic polynomial time 
theoretical computer science 
kanellakis kuper revesz 
constraint query languages 
computer system sciences 
kapur narendran 
np completeness set unification matching problems 
siekmann editor proc 
th cade lncs pp 

kapur narendran 
complexity unification problems associative commutative operators 
automated reasoning 
kolaitis 
expressive power stratified logic programs 
information computation 
kolaitis papadimitriou 
negation fixpoint computer system sciences 

complexity algorithm 
jacm 
kowalski 
predicate logic programming language 
information processing pp 

northholland amsterdam 
kowalski 
linear resolution selection function 
artificial intelligence 

resolution calculus 
springer 
leivant 
descriptive characterizations computational complexity 
computer system sciences 
lewis statman 
complete 
information processing letters 
sazonov 
delta languages sets sub ptime graph transformers 
gottlob vardi editors data base theory icdt lncs pp 
prague 
springer verlag 
sazonov 
delta languages sets logspace computable graph transformers 
theoretical computer science 
lloyd 
foundations logic programming nd edition 
springer verlag 
lobo minker rajasekar :10.1.1.124.9986
foundations disjunctive logic programming 
mit press 

problem solvability equations free semigroups 
mat 
russian 
english translation american mathematical soc 
translations vol 

marek nerode remmel 
complicated set stable models recursive logic program 
annals pure applied logic 
marek nerode remmel 
stable models predicate logic program 
logic programming 
marek truszczynski 
autoepistemic logic 
jacm 
marek truszczynski rajasekar 
complexity extended disjunctive logic programs 
annals mathematics artificial intelligence 
martelli montanari 
unification linear time space structured presentation 
technical report university pisa 
martelli montanari 
efficient unification algorithm 
acm transactions programming languages systems 

recursively enumerable sets russian 
soviet mathematical doklady pp 

minker 
indefinite data bases closed world assumption 
loveland editor proc 
th cade lncs pp 
new york 
springer 
minker 
overview disjunctive logic programming 
annals mathematics artificial intelligence 
narendran otto 
results equational unification 
stickel editor proc 
th cade volume lnai pp 


testing logic programs local stratification 
theoretical computer science 
papadimitriou yannakakis 
note succinct representations graphs 
information computation 
papadimitriou 
note expressive power datalog 
bulletin eatcs 
paterson wegman 
linear unification 
computer system sciences 
przymusinski 
stable semantics disjunctive programs 
new generation computing 
renegar 
faster pspace algorithm deciding existential theory reals 
proc 
th ieee focs pp 
white plains new york oct 
ieee 
robinson 
machine oriented logic resolution principle 
jacm 

expressive powers stable models bound unbound datalog queries 
computer system sciences 
appear 

deterministic nondeterministic stable model semantics unbound datalog queries 
proc 
th intl 
conference database theory icdt lncs pp 
january 
sakama inoue 
alternative approach semantics disjunctive logic programs deductive databases 
automated reasoning 
sazonov 
hereditarily finite sets data bases polynomial time computability 
theoretical computer science 
schlipf 
complexity undecidability results logic programming 
annals mathematics artificial intelligence 
schlipf 
expressive powers logic programming semantics 
computer system sciences 
proc 
pods pp 

shapiro 
alternation computational complexity logic programs 
logic programming 


horn clause computability 
bit 
ullman 
principles database knowledge base systems 
computer science press 
van emden kowalski 
semantics predicate logic programming language 
jacm 
van gelder 
alternating fixpoint logic programs negation 
proc 
pods pp 

van gelder ross schlipf 
founded semantics general logic programs 
jacm 
gyssens van gucht 
expressive power relational constraint query languages 
proc 
nd intl 
conference principles practice constraint programming lncs pp 

vardi 
complexity relational query languages 
proc 
th stoc pp 
san francisco 
veith 
logical finite model theory 
master thesis information systems department tu vienna austria september 
veith 
succinct representation leaf languages 
th ieee conf 
comput 
complexity pp 
philadelphia pa may 
full version electronic colloquium computational complexity report tr cd tr 
voronkov 
computability logic programs 
annals mathematics artificial intelligence 

parallel computational complexity unification 
proc 
conference fifth generation computer systems pp 

icot 

