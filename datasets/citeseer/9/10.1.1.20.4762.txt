implementing fault tolerant services state machine approach tutorial fred schneider tr december revised january department computer science cornell university ithaca ny material supported part office naval research contract national science foundation nos 
dcr ccr digital equipment 
opinions findings recommendations expressed publication author reflect views agencies 
implementing fault tolerant services state machine approach tutorial fred schneider department computer science university ithaca new york november revised january state machine approach general method implementing fault tolerant services distributed systems 
reviews approach describes protocols different failure models byzantine fail 
system reconfiguration techniques removing faulty components integrating repaired components discussed 
categories subject descriptors computer communications networks distributed systems network operating systems software engineering operating systems reliability fault tolerance operating systems organization systems real time systems 
general terms algorithms design reliability additional key words phrases state machine approach client server distributed services material supported part office naval research contract national science foundation nos 
dcr ccr digital equipment 
opinions findings recommendations expressed th publication author reflect views agencies 

distributed software structured terms clients services 
service comprises servers exports operations clients invoke making requests 
single centralized server simplest way implement service resulting service fault tolerant processor executing server 
level fault tolerance multiple servers fail independently employed 
usually replicas sin gle server executed separate processors distributed system protocols employed coordinate client interactions replicas 
physical electrical isolation processors distributed system ensures server failures independent required 
state machine approach general method implementing fault tolerant service replicating servers coordinating client interactions server replicas approach pro vides framework understanding designing replication management protocols 
proto cols involve replication data software masking failures simply facilitate cooperation centralized control derived state machine approach 
protocols obtained manner viewing terms state machines helps understanding 
tutorial state machine approach 
describes approach imple mentation representative environments 
small examples suffice illustrate points 
approach successfully applied larger examples mentioned 
section describes system viewed terms state machine clients output devices 
coping failures subject 
important class optimizations time discussed 
section describes dynamic reconfiguration 
tory approach related discussed 
state machines services servers programming language structures supporting modularity define state machines 
state machine consists state variables encode state commands transform state 
command implemented deterministic program execution command atomic respect commands modifies state variables pro duces output 
client state machine request execute command 
request names state machine names command performed contains information needed command 
output request processing actuator process control system 
peripheral device disk terminal clients awaiting responses prior requests 
ithe terra state machine poor literature 
tutorial describe state machine simply listing state variables com mands 
example state machine memory implements time varying mapping locations values 
read command permits client determine value currently associ ated location write command associates new value location 
generality descriptions state machines deliberately specify command invocation implemented 
commands implemented collection procedures share data invoked call monitor single process awaits messages containing requests performs actions specify server collection interrupt handlers case request causing interrupt operating system kernel 
disabling interrupts permits command executed completion started 
example state machine implements commands ensure times client granted access resource 
denotes result appending list head denotes element list tail denotes list obtained deleting element list state machine probably implemented part supervisor call handler operating system kernel 
requests processed state machine time order consistent potential causality 
clients state machine assumptions memory state machine var store array word read command loc send store loc client read write command loc value word store oc value write memory 
memory mutex state machine var user client id init waiting lis client id init acquire command user send ok client user client user waiting waiting fi acquire release command waiting user waiting send ok head waiting user head waiting waiting tail waiting fi release mutex 
resource allocator order requests processed requests issued single client state machine sm processed sm order issued 
fact request state machine sm client caused request client sin sm processes 
note due communications network delays imply state machine process requests order order received 
keep presentation independent interprocess communication mechanism transmit requests state machines program client requests tuples form state machine command arguments postulate results processing request returned messages 
example client execute memory write memory read receive memory set value location request value location await value setting receipt 
defining characteristic state machine syntax specifies tic computation reads stream requests processes occasionally producing output semantic characterization state machine 
outputs state machine completely determined sequence requests processes independent time activity system 
collections commands necessarily satisfy characterization 
consider pro gram solve simple process control problem actuator adjusted repeatedly value sensor 
periodically client reads sensor communicates value read state machine pc delays approximately seconds monitor process true val sensor pc adjust val delay od monitor state machine pc adjusts actuator past adjustments saved state variable sensor reading control function pc state machine var real adjust command sensor val real sensor val send actuator adjust tempting structure pc single command loops reading sensor evaluating writing actuator value sensor time varying result satisfy semantic characterization state machine 
values sent actuator output state machine depend solely requests state machine addition depend execution speed loop 
structure problem avoided moving loop monitor 
practice having structure system terms state machines clients real restriction 
structured terms procedures procedure calls structured state machines state machine implements procedure requests implement procedure calls 
fact state machines permit flexibility system structure usually available procedure calls 
state machines client making request delayed request processed output request sent place client making request 
encountered application programmed cleanly terms state machines clients 

fault tolerance turning implementation fault tolerant state machines introduce terminology concerning failures 
component considered faulty behavior longer consistent specification 
consider representative classes faulty behavior byzantine failures 
component exhibit arbitrary malicious behavior involving collusion faulty components lamport 
fail failures 
response failure component changes state permits components detect failure occurred stops schneider 
byzantine failures disruptive anecdotal evidence failures occur practice 
allowing byzantine failures weakest possible assumption effects failure 
design assumptions behavior faulty com ponents runs risk failing assumptions satisfied prudent life critical sys tems tolerate byzantine failures 
applications suffices assume fail failures 
system consisting set distinct components fault tolerant satisfies specification provided components faulty interval interest 
fault tolerance traditionally specified terms mtbf mean time failures probability failure interval statistical measures siewiorek 
clear characterizations important users system advantages describing fault tolerance system terms maximum number com ponent failures tolerated interval interest 
asserting system fault tolerant explicit assumptions required correct operation mtbf statistical measures 
fault tolerance unrelated reliability components system measure fault tolerance supported system archi tecture contrast fault tolerance achieved simply reliable components 
mtbf statistical reliability measures fault tolerant system derived statistical reliability measures components constructing system particular probability fault tolerant system continue operate correctly failures occur correct operation guaranteed 
failures operating interval interest 
typically chosen statistical measures component reliability 

fault tolerant state machines fault tolerant version state machine implemented replicating state machine running replica processors distributed system 
provided replica run non faulty processor starts initial state executes requests order thing produce output 
assume failure affect processor state machine replica combining output state machine replicas ensemble obtain output fault tolerant state machine 
processors experience byzantine failures ensemble implementing fault tolerant state machine replicas output ensemble output produced majority replicas 
replicas majority puts remain correct failures 
processors experience fail failures ensemble containing replicas suffices output ensemble output produced members 
correct outputs produced fail pro cessors failures non faulty replica remain replicas 
key implementing fault tolerant state machine ensure replica coordination 
replicas receive process sequence requests 
decomposed requirements concerning dissemination requests replicas ensemble 
agreement 
non faulty state machine replica receives request 
order 
non faulty state machine replica processes requests receives relative order 
notice agreement governs behavior client interacting state machine replicas order governs behavior state machine replica respect requests various clients 
replica coordination partitioned ways agreement order partitioning natural choice corresponds existing separation client state machine replicas 
implementations agreement order discussed 
implementa tions assumptions clients commands 
generality useful knowledge commands allows replica coordination agreement order weakened allows cheaper protocols employed managing replicas ensemble 
examples common weakenings follow 
agreement relaxed read requests fail processors assumed 
processors fail request processing modify state variables need sent single non faulty state machine replica 
response replica definition guaranteed correct changes state variables state replica processes remain identical states replicas 
second order relaxed requests commute 
requests commute state machine sm sequence outputs final state sm result processing followed result processing followed example state machine order relaxed appears 
state machine tally determines set alternatives receive maj votes sends choice system 
clients vote number clients satisfies maj request commutes 
implementing order replicas state machine produce outputs process requests different orders 
hand clients vote maj change outcome election 
theories constructing state machine ensembles satisfy replica coordination proposed mancini 
theories proving ensemble state machines implements specification single replica 
approach taken uses temporal logic descriptions state sequences approach mancini uses algebra actions sequences 
detailed description scope tutorial 
tally state machine var votes array candidate integer init cast vote command choice candidate votes choice votes choice votes choice maj send choice system halt votes choice skip fi cast vote tally 
election 
agreement agreement requirement satisfied protocol allows designated processor called transmitter disseminate value processors way ic non faulty processors agree value 
ic transmitter non faulty non faulty processors value agree 
protocols establish ic ic received considerable attention literature times called byzantine agreement protocols reliable broadcast protocols simply agreement pro 
hard part designing protocols coping transmitter fails part way execution 
see strong dolev protocols tolerate byzantine processor es schneider significantly cheaper protocol tolerate fail processor failures 
requests distributed state machine replicas protocol satisfies ic ic agreement requirement satisfied 
client serve transmitter client send request single state machine replica replica serve transmitter 
client serve transmitter client ensure request lost corrupted transmitter request disseminated state machine replicas 
way monitor corruption having client pro cessors receive request transmitter 

order stability order requirement satisfied assigning unique identifiers requests having state machine replicas process requests total ordering relation unique identifiers 
equivalent requiring request defined stable smi request correct client bearing lower unique identifier subsequently delivered state machine replica smi order implementation 
replica processes stable request smallest unique identifier 
refinement order implementation requires selecting method assigning unique identifiers requests devising stability test assignment method 
note method assigning unique identifiers constrained imply request caused request rj uid ri identifier assigned request subsections follow give refinements order implementation 
clocks third uses ordering defined replicas ensemble 
logical clocks logical clock lamport mapping events integers 
time assigned event logical clock integer distinct events responsible causing 
simple matter implement logical clocks distributed system 
associated process counter 
addition timestamp included message sent timestamp value message sent 
updated lc incremented event lc receipt message timestamp process resets max 
alue event occurs constructed appending fixed length bit string uniquely identifies value occurs 
illustrates scheme implementing logical clocks system processors events depicted dots arrow drawn events ife responsible causing event 
example arrow events different processes starts event corresponding sending message ends event corresponding receipt message 
value event written event 
unique identifier associated request issuance corresponds event result total ordering unique identifiers satisfies 
logical 
logical clock example clock basis order implementation formulate way determine request stable state machine replica 
pointless implement stability test system byzantine failures possible process message delayed arbitrary length time considered faulty 
deterministic protocol implement agreement conditions fischer 
impossible satisfy agreement requirement point satisfying order requirement 
case relative speeds non faulty processors messages bounded equivalent assuming synchronized real time clocks considered shortly 
leaves case fail failures possible process message delayed arbitrary length time considered faulty 
turn ing stability test environment 
attaching sequence numbers messages pair processors trivial ensure property holds communications channels 
fifo channels 
messages pair processors delivered order sent 
fail processors assume failure detection assumption 
detects fail processor failed received message sent top failure detection assumption consistent fifo channels failure event fail processor necessarily happens message sent processor received messages 
assumptions stability test 
logical clock stability test tolerating fail failures 
client periodically possibly null request state machine 
request stable replica sm request larger timestamp received smi client running non faulty processor 
see stability test works show request stable smi request smaller unique identifier timestamp received 
consider clients smi detect faulty 
logical clocks generate unique identifiers request client larger unique identifier assigned previous request fifo channels assumption conclude request non faulty client received smi request smaller unique identifier uid received sml 
means requests larger unique identifiers uid result fischer stronger 
states icl ic achieved deter protocol asynchronous system single processor fails restrictive simply halting 
received non faulty client possible receive request smaller unique identifier uid clients 
client smi detects faulty failure detection assumption implies request received smi 
request stable smi request smaller timestamp received client faulty non faulty 
synchronized real time clocks second way produce unique request identifiers satisfying approxi mately synchronized real time clocks 
define value real time clock proces sor event occurs 
followed fixed length bit string uniquely identifies unique identifier associated request event client running proce 

ensure hold unique identifiers generated manner restrictions required 
follows provided client requests successive clock ticks 
processor clocks resolution seconds client request seconds 
follows provided degree clock synchronization better minimum message delivery time 
particular clocks different processors synchronized seconds take seconds message client reach violated request client unique identifier smaller request caused message sent 
unique request identifiers obtained synchronized real time clocks stability test implemented exploiting clocks bounds message delivery delays 
define constant request unique identifier uid received correct pro cessor time uid local clock receiving processor 
exist requests disseminated protocol employs fixed number rounds ones cited establishing ic ic 
definition clock reaches time subsequently receive request uid stability test 
real time clock stability test tolerating byzantine failures request stable state machine replica executed processor local clock reads number achieve clock synchronization tolerating byzantine failures proposed lamport smith halpern 
see schneider survey 
protocols require known bounds exist execution speed clock rates non faulty processors message delivery delays nonfaulty communications links 
practice requirements constitute restriction 
clock synchronization achieved protocols proportional variance message delivery delay making possible satisfy necessary ensure message delivery delay exceeds clock synchronization 
sin general function variance message delivery delay maximum message delivery delay degree clock synchronization 
see cristian detailed derivation variety environments 
ud 
disadvantage stability test forces state machine lag clients proportional worst case message delivery delay 
disadvantage avoided 
due property total ordering request identifiers communications channels satisfy fifo channels state machine replica received request client subsequently receive requests unique identifiers greater uid 
request stable state machine replica provided request larger unique identifier received client 
real time clock stability test tolerating byzantine failures ii 
request stable state machine replica smi request larger unique identifier received client 
second stability test passed faulty processor refuses requests 
combining second test request considered stable satisfies test stability test results lags clients faulty processors network delays force 
replica generated identifiers previous refinements order implementation clients determine order requests processed unique identifier uid request assigned client making request 
refinement order implementation state machine replicas determine order 
unique identifiers computed phases 
phase part agreement protocol satisfy agreement requirement state machine replicas propose candidate unique identifiers request 
second phase candidates selected unique identifier request 
advantage approach computing unique identifiers communications processors system necessary 
logical clocks synchronized real time clocks computing unique request identifiers processors hosting clients state machine repli cas communicate 
case logical clocks communication needed order requests stable case synchronized real time clocks communication needed order keep clocks synchronized 
replica generated identifier approach tion communication required processors running client state machine replicas 
illustrates advantage having client forward request single state machine replica serves transmitter disseminating request 
effect state machine replica client state machine communication need involve processors running state machine replicas 
constraining possible candidates proposed phase request unique identifier possible obtain simple stability test 
describe stability test terminology required 
say state machine replica smi seen request smi received proposed candidate unique identifier say smi accepted replica knows ultimate choice unique identifier define smi candidate unique identifier proposed replica smi request constraints lead simple stability test smi uid request seen replica sm accepted smi uid constraints hold execution test determine request stable state machine replica 
replica generated identifiers stability test 
request accepted smi stable provided request seen smi ii accepted smi iii cum smi prove stability test works show accepted request deemed stable smi request smaller unique identifier subsequently accepted smi 
request replica generated identifiers stability test stable replica smi 
due uid request seen smi uid transitivity uid uid identifier consider case request seen accepted smi stability test satisfied uid uid shown request satisfies replica generated identifiers stability test smi request accepted smi satisfy uid clock generated unique identifiers requests replica generated ones necessarily satisfy 
restrictions possible client request send message client causing request issued uid hold provided client starts disseminating request state machine replicas client performs communication state machine replica accepted request 
see works consider request client suppose request influenced delay ensures accepted state machine replica smj seen 
uid conclude uid uid uid complete order implementation devise protocols computing unique identifiers candidate unique identifiers uid uid satisfied 
uid uid request seen eventually accepted 
simple solution system fail processors 
replica generated unique identifiers 
state machine replica smi maintains vari ables largest smt assigned request far seen smi largest uid assigned request far accepted sm receipt request replica smi computes smi max notice means candidate unique identifiers unique 
replica disseminates agreement protocol smi replicas awaits receipt candidate unique identifier non faulty replica participating agreement protocol value 
nf set replicas didate unique identifiers received 
replica computes uid max smj smj nf accepts prove protocol satisfies follows 
uid follows assign ment compute uid uid follows assignment compute smt 
conclude holds argue follows 
agreement protocol disseminate candidate unique identifiers replicas receive values replicas 
replicas execute assignment statement compute value uid 
establish uid values unique request suffices observe disjoint subsets collection unique candidate unique unique 
order establish request seen eventually accepted prove replica smj replica smi eventually learns smj learns smj failed 
follows trivially agreement protocol distribute smj definition fail processor 
optimization replica generated unique identifiers protocol basis protocol isis toolkit birman joseph developed cornell 
optimiza tion candidate unique identifiers returned client disseminated state machine replicas 
client executes assignment compute uid 
agreement protocol client disseminating uid state machine replicas 
unique replica takes client client fails 
possible modify replica generated unique identifiers protocol systems processors exhibit byzantine failures synchronized real time clocks communications channels bounded message delivery environment assumed synchronized real time clocks generate unique identifiers 
changes required 
replica smi uses timeouts smi forever delayed waiting receive participate agreement protocol disseminating candidate unique identifier faulty replica smj 
second smi determine smj timed smi disseminates smj timeout replicas agreement protocol 
nf set replicas ensemble smj smj timeout received replicas 
notice byzantine failures cause faulty replicas propose candidate unique identifiers produced cause difficulty 
candidate unique identifiers small effect outcome non faulty replicas large satisfy uid uid 

tolerating faulty output devices possible implement fault tolerant system single voter combine outputs ensemble state machine replicas output 
single failure prevent system producing correct output 
solutions problem depend output state machine implemented ensemble system outside system 
outputs outside system output state machine sent output device device single component failure tolerated 
able tolerate faulty voter sufficient system able tolerate faulty output device 
usual solution problem replicate output device voter 
voter combines output state machine replica producing signal drives output device 
reads outputs system assumed combine outputs replicated devices 
reader con sidered part computing system implements critical voter 
output devices exhibit byzantine failures output produced majority devices fold replication permits faulty output devices tolerated 
example flap airplane wing designed actuators con trol agree flap moves direction majority twisting 
output devices exhibit fail failures fold replication necessary tolerate failures output produced fail output device ned correct 
exam ple video display terminals usually information redundancy treated fail failure detection implemented viewer 
output device human user look devices decide output faulty faulty look 
outputs inside system output state machine client client combine outputs state machine replicas ensemble 
voter part client faulty exactly client fact incorrect output read client due faulty voter irrelevant 
byzantine failures possible client waits received identical responses different member ensemble takes response fault tolerant state machine 
fail failures possible client proceed soon received response member ensemble output produced replica correct 
client executed processor state machine replicas zation client implemented voting possible 
correctness processor implies state machine replica client correct 
response produced state machine replica running locally client response fault tolerant state machine 
processor faulty entitled view client faulty matter state machine responses client receives 
summarizing dependent failures output optimization 
client state machine replica run processor byzantine failures possible client need gather majority responses requests state machine 
single response produced locally 

tolerating faulty clients implementing fault tolerant state machine sufficient implementing fault tolerant system 
faults result clients making requests cause state machine produce ous output corrupt state machine subsequent requests non faulty clients incorrectly processed 
section discuss various methods insulating state machine faults affect clients 

replicating client way avoid having faults affect client replicating client running replica hardware fails independently 
replication requires changes state machines handle requests client 
client replicated care exercised analyzing fault tolerance system single processor failure cause system components fail 
implicit discussions system components fail independently 
possible fault tolerant system clients state machine replicas independent failures share processors 
fold state machine interacts receive requests client replica received single request 
corresponding requests different client replicas necessarily identical 
differ unique identifiers 
second original client state machine methods coordinate replicas corresponding requests different replicas differ content 
example client requests value time varying sensor replicas read sensors slightly different times different requests 
consider modifications state machine sm case requests different client replicas known differ unique identifiers 
case modifications needed coping receiving requests single 
modifications involve changing operation processing request received requests buffered received corresponding operation performed single time 
effect voter added sm control invocation operations 
client replication invisible designer state machine including voter support software receives requests tests stability orders stable requests unique identifier 
modifying state machine case requests different client replicas differ content typically requires exploiting knowledge application 
idea transform multiple requests single 
example fault tolerant system different requests received containing value sensor single request containing median values constructed processed state machine 
byzantine faults median values reasonable bounded non faulty value 
general method transforming multiple requests con taining sensor values single request discussed marzullo 
method viewing sensor value interval includes actual value measured single interval sensor computed set intervals fault tolerant intersection algorithm 

defensive programming client fault tolerant replication 
circumstances due unavailability sensors processors simply possible replicate client 
circumstances application semantics afford reasonable way transform multiple requests client replicas single request needed state machine 
circumstances careful design state machines limit effects requests faulty clients 
example memory permits client write location 
fore faulty client overwrite locations destroying information 
problem sif byzantine failures possible fault tolerant client requires fold replication operation formed requests received restricted fail fold replication suffice operation performed single request received 
prevented restricting write requests client certain memory locations state machine enforce 
including tests commands way design state machine corrupted requests faulty clients 
example mutex specified execute release command client access resource 
consequently faulty client issue request cause mutex second client access resource relinquished access 
better formulation mutex ignores release commands client exclusive access granted 
implemented changing release mutex release command user client skip waiting user client user waiting user client send ok head waiting user head waiting waiting tail waiting fi release faulty client making request just catastrophic making erroneous request 
example client mutex failed stopped exclusive access resource client granted access resource 
course prepared bound length time correctly functioning process retain exclusive access resource little problem 
way state machine distinguish client stopped executing failed executing slowly 
upper bound interval acquire release acquire command mutex automatically schedule release behalf client 
notation schedule request specify scheduling request unique identifier greater identifier request processed 
request called timeout request stable time stability test client generated requests 
requests clients requests result executing schedule need distributed state machine replicas ensemble 
state machine replica independently schedule identical copy request 
modify acquire release operation automatically scheduled 
code follows time assumed function evaluates current time 
note mutex process release commands behalf client acquired access resource command client generated acquire request 
new state variable time granted acquire command user timeout ensures superfluous release commands ignored 
fi acquire send ok client user client time granted time schedule mutex timeout time granted waiting command granted integer granted time granted skip waiting granted time granted user waiting granted time granted send ok head waiting user head waiting time granted time waiting tail waiting fi timeout 
time requests client need explicitly send message request 
receiving request trigger execution command effect allowing passage time transmit request client state machine lamport 
transmitting request time messages advantageous protocols implement ic ic costly total number messages exchanged delay 
unfortunately time transmit requests limited applicability client specify parameter values 
time transmit request employed revised acquire com mand mutex foil clients failed release resource 
release request automat ically scheduled acquire behalf client granted resource 
client transmits release request mutex simply permitting logical clock real time clock time units pass 
increase utilization shared resource client messages transmit release request mutex time units passed 
dramatic example time transmit request illustrated connection tally 
assume clients state machine replicas logical real time clocks synchronized election starts time known clients state machine replicas 
time client cast vote default doing client casts vote different default require transmit request message 
transmitting default vote 
client request time request client default vote 
notice default need fixed known time vote cast 
example default vote vote client client casts non default vote 
case entire election conducted long client casts vote actual messages 

reconfiguration ensemble state machine replicas tolerate faults possible remove state machine replicas running faulty processors ensemble add replicas running repaired processors 
similar argument able add remove copies clients output devices 
total number processors time executing replicas state machine interest number faulty 
order ensemble produce correct output combining condition 
byzantine failures possible 
fail failures possible 
processor failure may cause combining condition violated increasing decreasing 
byzantine failures possible faulty processor identified removing ensemble decreases decreasing keep combining condition violated 
fail failures possi ble increasing number non faulty processors adding repaired way keep combining condition violated increasing way ensure holds 
provided conditions hold may possible maintain combining condition forever tolerate unbounded total number faults life system 
fi byzantine failures possible state machine replicas executed faulty processors identified removed ensemble combin ing condition violated subsequent processor failures 
state machine replicas running repaired processors added ensemble combining condition violated subsequent processor failures 
constrain rates failures repairs occur 
observe byzantine failures possible faulty client elected 
problems possible voters detailed knowledge candidates election 
removing faulty processors ensemble state machines improve system formance 
number messages sent achieve agreement usually proportional number state machine replicas agree contents request 
addition protocols implement agreement execute time proportional number pro cessors faulty 
removing faulty processors clearly reduces message complexity time complexity protocols 
adding removing client system simply matter changing state machine henceforth responds ignores requests client 
adding output device straightforward state machine starts sending output device 
removing output device system achieved disabling device 
done putting device state prevents affecting environment 
example crt terminal disabled turning brightness screen longer read hydraulic actuator controlling flap airplane wing disabled opening cutoff valve actuator exerts control surface 
suggested examples possible disable faulty output device turning brightness effect screen cutoff valve 
systems total actuator faults tolerated faulty actuators disabled 
configuration system structured terms state machine clients described sets clients state machine replicas output devices agreement protocol known clients state machine replicas 
output device determine send operations state machine replicas ignored 
state machine replicas determine clients requests processed devices output sent 
available state machine replicas 
problems solved support changing system configuration 
values available required 
second client state machine replica output device added configuration state element updated reflect current state system 
problems considered subsections 

managing configuration configuration system managed state machine system 
sets stored state variables changed commands 
configuration valid col lection requests uid range defined successive configuration change requests 
client state machine replica output device forms action connected processing uses configuration valid means configuration change request schedule new configuration point far clients state machine replicas output devices find new configuration comes effect 
various ways configuration information available clients output devices system 
information available state machine 
clients output devices query state machine periodically information relevant pending configuration changes 
obviously communication costs scheme reduced clients output devices share processors state machine replicas 
way configuration information available state machine include information configuration changes messages sends clients output devices course normal processing 
doing requires periodic communication state machine clients state machine output devices 
requests change configuration system failure recovery detection mechanism 
convenient think mechanism collection clients ele ment responsible detecting failure repair single object manages event detected making request alter configuration 
configurator part existing client state machine replica implemented variety ways 
elements fail configurator need check failure detection mechanism element 
elements exhibit byzantine failures detecting failures possible 
possible higher degree fault tolerance achieved reconfiguration 
non faulty configurator satisfies safety properties 
ci faulty element removed configuration 
non faulty element added configuration 
configurator satisfies 
changing configuration enhances fault tolerance hold 
hold configurator detect faults cause elements removed detect repairs cause elements added 
degree configurator enhances fault tolerance directly related degree achieved 
semantics application helpful 
example infer client faulty state machine compare requests different clients client period time 
determine processor executing state machine replica faulty state machine monitor messages sent state machine replicas execution agreement protocol 
monitoring aspects environment controlled actuators state machine replica able determine output device faulty 
elements processors internal failure detection circuitry read determine ele ment faulty repaired restarted 
configurator element imple mented having state machine periodically poll circuitry 
order analyze fault tolerance system uses failure configurator considered equivalent failure element configurator manages 
respect combining condition removal non faulty element system addition faulty element failing 
fault tolerant sys tem sum number faulty manage non faulty elements number faulty components non faulty bounded 
integrating repaired object element added configuration non faulty correct state actions consistent rest system 
define ri state non faulty system element processing requests elem ent joining configuration immediately request join state participate running system 
element self stabilizing dijkstra current state completely defined previ ous inputs processed fixed obviously running element long ensure processed inputs required put state 
unfortunately design self stabilizing state machines possible 
elements self stabilizing processors fail logical clocks imple mented cooperation single state machine replica smi sufficient integrate new element system 
state information obtained state machine replica sml correct 
order integrate request replica sm access state information assembled forwarded output device small amount device specific set information information changes infrequently stored state variables smi 
client information needed frequently sensor values read determined information provided smi clients 
state machine replica information needed stored state variables pending requests smi 
protocol integrating client output device simple join sent output produced processing request unique identifier larger uid 
proto col integrating state machine replica bit complex 
sufficient replica sml simply send values state variables copies pending requests 
client request received smi sending delivered repair 
request reflected state information forwarded smi sm received sm 
directly 
sm time relay sm requests received clients 
requests client received order sent ascending order request identifier received request directly relayed client need requests larger identifiers relayed 
informs smi identifier request received directly client sm know relaying requests complete integration protocol summarized 
integration fail processors logical clocks 
state machine replica smi integrate element request join running system follows 
client output device smi sends relevant portions state variables sending output produced requests unique identifiers larger 
state machine replica smi sends values state variables copies pending requests sends subsequent request received client uid received directly restarted 
existence synchronized real time clocks permits protocol simplified sml determine relaying messages passage time 
suppose exists constant request unique identifier uid received correct state machine replica time uid local clock ing processor 
sm join configuration time 
definition sm 
guaranteed receive request time requesting client clock 
unique identifiers obtained real time clock client making request guaranteed receive request uid 
request received smi time clock 
request received sm 
received directly 
clearly sml need relay requests fol lowing protocol 
integration fail processors real time clocks 
state machine replica smi integrate element request running system follows 
duplicate copies requests received sm 
client output device smi sends relevant portions state vari ables sending output produced requests unique identifiers larger 
state machine replica sm smi sends values state variables copies pending requests sm sends request received interval duration processors exhibit byzantine failures single state machine replica smi sufficient integrating new element system 
state information sml correct smi executing faulty processor 
tolerate failures system state machine replicas identical copies state information ident ical copies relayed messages obtained 
protocol described real time clocks 
stability revisited stability tests requests client received client relay 
interval messages relayed sm state machine replica integrated receive request directly receive request uid uid relayed smi 
solution problem consider requests received directly stable relayed requests arrive 
stability test changed stability test restart 
request received directly client restarting state machine replica stable request relayed processor received sm 
obvious way implement message sent requests relayed 

related state machine approach described environments failures occur 
generalized handle fail failures schneider class failures fail byzantine failures lamport full byzantine failures lamport 
various state machine implementations characterized agree ment order requirements stability test schneider 
state machine approach design significant fault tolerant process con trol applications 
design distributed synchronization including read write locks distributed semaphores schneider input output guards csp conditional ada select statements schneider design fail processor approximation processors exhibit arbitrary behavior response failure schlichting schneider schneider 
stable storage implementation described bernstein exploits properties synchronous broadcast network avoid explicit protocols agreement order employs transmitting default vote described 
notion common storage suggested cristian state machine implementation memory uses real time clock stability test 
decentralized commit protocol skeen viewed straightforward application state machine approach phase commit pro tocol described gray obtained decentralized commit simply making restrictive assumptions failures performing optimizations assumptions 
commit protocol lamport understood terms state machine approach 
similar cheaper execute standard phase commit protocol 
method implementing highly available distributed services liskov ladin uses state machine approach clever optimizations stability test agreement protocol pos sible due semantics application fail processors 
critique state machine approach transaction management database systems appears garcia molina 
experiments evaluating performance various ity tests network sun workstations reported garcia molina 
study reports performance request batching possible requests describe data base transactions null requests logical clock stability test tolerating fail failures 
primitives support agreement order requirements replica coordination included operating systems toolkits 
isis toolkit provides allowing applications programmer control delivery order messages members process group collection state machine replicas 
ensures state machine replicas process requests order allows flexibility mes sage ordering ensures causally related requests delivered correct relative order 
isis implement number prototype applications 
example replicated nfs file system network file system tolerant fail failures runs top nfs designed state machine approach marzullo schmuck 
primitive peterson implemented kernel son peterson similar isis 
available pro grammer graph message potential causality relation 
intended low level protocol implement protocols isis primitives intended applications programmers hide potential causality relation time including support group management failure reporting 
acknowledgments discussions babaoglu lamport past years helped formulate ideas 
useful comments drafts provided babaoglu bernstein birman brown gries marzullo simons 
am grateful sal march managing editor acm computing surveys thorough reading helpful com ments 
designing distributed services refinement mappings 
ph dissertation computer science department cornell university ithaca new york august 
available technical report tr 
bernstein bernstein loosely coupled system reliably storing data 
ieee trans 
software engineering se may 
birman replication fault tolerance isis system 
proc 
tenth acm symposium operating systems principles 
orcas island washington dec acm 
birman joseph joseph 
reliable communication presence failures 
acm tocs feb 
cristian cristian strong dolev 
atomic broadcast simple message diffusion byzantine agreement 
proc 
fifteenth international conference faulttolerant computing ann arbor mich june ieee computer society 
dijkstra dijkstra self stabilization spite distributed control 
cacm nov 
fischer fischer lynch paterson 
impossibility distributed consensus faulty process 
jacm april 
garcia molina garcia molina davidson 
application byzantine agreement database systems 
acm tods march 
gray gray notes data base operating systems 
operating systems advanced course lecture notes computer science vol 
springer verlag new york 
halpern halpern simons strong dolev 
fault tolerant clock synchronization 
proc 
third cm sigact sigops symposium principles distributed computing vancouver canada august 
hutchinson peterson hutchinson peterson 
design kernel 
proc 
sigcomm communication architectures protocols stanford ca august 
lamport time clocks ordering events distributed system 
cacm july 
lamport implementation reliable distributed multiprocess systems 
net works 
lamport time timeout fault tolerance distributed systems 
acm toplas april 
lamport part time parliament 
technical report digital equipment systems research center palo alto ca sept 
lamport lamport lamport lamport lamport melliar smith lamport melliar smith 
byzantine clock synchronization 
proc 
third acm sigact sigops symposium principles distributed computing vancouver canada august 
lamport lamport shostak pease 
byzantine generals problem 
acm toplas july 
liskov ladin liskov ladin 
highly available distributed services fault tolerant distributed garbage collection 
proc 
fifth acm symposium principles distributed computing calgary alberta canada august acm 
mancini mancini 
theory replicated processing 
formal techniques real time fault tolerant systems lecture notes computer science vol 
springer verlag new york 
marzullo marzullo implementing fault tolerant sensors 
technical report tr computer science department cornell university ithaca new york may 
mar schmuck marzullo schmuck 
supplying high availability standard network file system 
proceedings eighth international conference distributed computing systems san jose ca june ieee computer society 
peterson peterson schlichting 
preserving context information interprocess communication 
acm tocs august 
garcia molina garcia molina 
reliable scheduling tmr database system 
acm tocs feb 
powell presotto powell presotto 
publishing reliable broadcast communication mechanism 
proc 
ninth acm symposium operating systems principles woods new hampshire october acm 
schlichting schneider schlichting schneider 
fail processors approach designing fault tolerant computing systems 
acm tocs august 
schneider schneider ensuring consistency distributed database system distributed semaphores 
proc 
international symposium distributed data bases paris france march inria 
schneider schneider synchronization distributed programs 
acm toplas april 
schneider schneider byzantine generals action implementing fail processors 
acm tocs may 
schneider schneider paradigms distributed programs 
distributed tools specification lecture notes computer science vol 
springer verlag new york 
schneider schneider paradigm reliable clock synchronization 
proc 
advanced seminar real time local area networks france april inria 
schneider schneider gries schlichting 
fault tolerant broadcasts 
science computer programming 
siewiorek siewiorek 
theory practice reliable system design 
digital press bedford mass 
skeen skeen crash recovery distributed database system 
ph thesis university california berkeley may 
strong dolev strong 
byzantine agreement 
intellectual leverage information society digest papers compcon ieee computer society march ieee computer society 
sift design analysis fault tolerant computer aircraft control 
proc 
ieee oct 

