linda applicative imperative process algebras rocco de nicola rosario pugliese dipartimento di sistemi ed informatica universit di firenze firenze italy mail dsi appear theoretical computer science classical algebraic approach specification verification concurrent systems tuned distributed programs rely asynchronous communications permit explicit data exchange 
applicative process algebra obtained embedding linda primitives interprocess communication ccs csp language imperative obtained applicative variant adding construct explicit assignment values variables introduced 
testing framework define behavioural equivalences languages sound complete proof systems described fully denotational model variant strong acceptance trees 
keywords concurrency asynchronous communications process algebras formal semantics 
availability sophisticated parallel hardware limited costs led proliferation programming languages aiming advantage new computing capabilities 
languages equipped primitives communication permit designing concurrent distributed programs 
class programs difficult design debug 
possible interactions concurrent programs may give rise new unwanted behaviours may lead nondeterministic executions 
efforts model concurrent programs develop methods reasoning 
probably known approach process algebraic ccs acp csp 
basic idea process algebras distributed systems may modelled sets concurrent communicating processes main aim providing description languages techniques assessing correctness 
languages small sets elementary constructs permit describing systems different levels abstraction 
operators intuitive interpretations model basic notions parallel composition nondeterminism abstraction sequentialization process algebraic approach specifications descriptions expected behaviour systems terms reactions external stimuli implementations detailed descriptions systems information logical physical structures expressed language 
absolute distinction specifications implementations particular settings program may considered specification may implementation description 
relationships different levels assessed means behavioural relations systems 
check systems behaviour approximation see 
verification consists studying relationships descriptions implementations 
task may partially mechanized advantage sets laws consistent selected behavioural relation ad hoc efficient algorithms 
algebraic approach far mainly concentrated languages uninterpreted action symbols rely synchronous paradigm program interaction 
exchange information programs limited synchronization signals cases languages studied permit explicit data exchange 
take linda paradigm process interaction starting point defining asynchronous process algebra explicit data value exchange 
linda member relatively generation global environment parallel languages concurrent prolog unity shared prolog differ previous ones offer require explicit control interactions :10.1.1.113.9679
communication linda processes obtained accessing tuples sequences variables data shared memory called tuple space multiset tuples 
communication mechanism asynchronous send operations non blocking associative tuples retrieved referring part content read receive operations look tuples specific structure may cause block 
main objective developing semantic framework supports analysis programs written applicative assignment imperative assignment linda dialect 
languages consider process algebras linda programming dialects 
linda programming language coordination model primitives devoted coordinate interactions programs 
concurrent languages obtained embedding linda sequential functional imperative logic programming language see 
start introducing pal process algebra linda process algebra obtained interpreting actions linda primitives 
asynchrony modelled considering outputs elementary concurrent processes execution delay progress senders 
relying commutativity associativity operator parallel composition linda tuple space rendered means parallel composition processes correspond tuples 
testing preorders observational machinery abstracting away unwanted details programs assessing correctness comparing respect notion approximation 
choice observational machinery partially dictated language example operators modelling non deterministic situations bisimulation fail equivalence relation 
testing approach require adaptation language observation mechanism directly relies communication paradigm 
behavioural testing preorder defined observers ccs processes interact observed process report success 
equivalent interpretations pal processes equational interpretation sound complete proof system useful performing process verification symbolic manipulation denotational terms double labelled trees acceptance trees linda generalization acceptance trees 
generalize framework imperative version pal assignment command 
shall maintain information processes exchanged tuple space shall able model private stores processes explicit substitutions 
choice fact pal binders value variables process variables interfere enables reuse theory developed pal obtain sound complete proof system fully denotational model 
semantics significant simplification require explicitly modelling processes private stores adapting testing scenarios ccs value passing see pal see extensions assignment prefixes 
rest organized follows 
section briefly introduce linda 
sections introduce syntax operational semantics pal respectively 
testing theory pal described section section contains proof system small example illustrates proof system works 
section relying standard algebraic semantics techniques define denotational semantics pal fully respect testing preorders 
section define syntax operational semantics show results pal smoothly generalize new formalism 
section related research discussed 
brief presentation linda linda coordination language relies asynchronous associative communication mechanism shared global environment called tuple space ts multiset tuples :10.1.1.113.9679
tuple ordered sequence actual fields value objects formal fields variables field actual field usually referred logic name tag 
basic interaction mechanism pattern matching select tuples ts 
matching indivisible action permits nondeterministically selecting tuples ts tag number fields tuple corresponding fields matching values variables 
variables match value type values match identical 
operations manipulating tuple spaces possibly blocking operations accessing removing tuples non blocking operations adding tuples 
ffl triggers evaluation search tuple ts matches removed ts corresponding values assigned variables process continues 
matching tuple process suspended available 
ffl read similar require removal matched tuple ts 
ffl triggers evaluation adds tuple ts 
ffl eval similar forcing evaluation creates new process evaluate eventually add resulting tuple ts 
worth noting nondeterminism inherent definition linda primitives 
arises cases ffl different read operations suspended waiting tuple tuple available suspended operations nondeterministically selected proceed ffl read operation matching tuple arbitrarily chosen 
example borrowed simple linda solution dining philosophers problem 
example num represents number philosophers remainder integer division 
phil int think room ticket chopstick chopstick num eat chopstick chopstick num room ticket initialize int num chopstick eval phil 
num gamma room ticket actual fields argument tuple read instruction known structured naming 
ts content addressable sense processes may select collection tuples matching value component fields 
formal fields tuples tuple space updated tuples matching read operations 
linda model known generative communication :10.1.1.113.9679
tuple added ts generated life time independent producer process 
permits writing programs complex data structures distributed allow different programs simultaneously elements 
syntax pal mainly interested analyzing concurrent features language assume values type allow value expressions boolean expressions 
assume existence predefined syntactic categories 
ffl exp category value expressions ranged contains set variable symbols ar ranged non empty countable set value symbols ranged ffl bexp category boolean expressions ranged contains boolean values false denoted ff true denoted tt boolean expressions obtained usual boolean connectors applying relational operators value expressions 
ffl countable set process variables ranged rely standard notions closed expression variables substitution 
function ar exp identity 
write substitution oe defined oe non trivial domain denoted bv oe fx write oe denoting substitution oe mapped write denoting expression obtained simultaneously substituting occurrence pl ranged denote set input output tuples 
tuples sequences fields ranged denoting formal field contains variable denoting actual field contains value expression denoting field match fields kind 
sake simplicity shall require variables occur formal fields tuple different allow away evaluation ordering tuples 
apart basic linda coordination operators read eval language standard operators see building terms basic ones nil inaction omega undefined action prefix conditional external choice phi internal choice parallel composition bb left merge jj communication merge recx recursive definition 
variables occur formal fields input tuple bound read term bv denote set bound variables fv denote free variables substitutions value expressions variables extended terms 
term eoe denote term resulting simultaneously substituting free occurrences ar oe 
notions free bound process variables standard ones recx binding operator 
substitutions process variables ranged mappings process variables terms 
applications terms may require renaming bound variables avoiding captures 
definition set terms ranged generated grammar nil fi fi fi omega fi fi fi fi fi fi fi fi fi op fi fi fi fi fi fi rec fi fi fi fi fi fi read fi fi fi eval fi fi fi fi fi fi fi fi fi op phi fi fi fi fi fi fi fi fi fi bb fi fi fi jj pal process algebra linda denoting set terms free value variables variables formals tuple different body subterms rec preceded binders value variables free call processes pal terms contain free process variables 
process recursion called finite 
proc ranged denote set processes 
general pal terms range 
shall write nil denote syntactical identity sigma denote set operators read interplay process binders value variable binders put restriction pal terms 
restriction ensures free value variable bound unfolding rec rec 
terms different semantics 
example consider rec rec different operational semantics instantiated instantiated twice operational semantics rec 
notation tuple denote number fields length th field var set variables formal fields slight abuse notation ar var denote operational semantics pal operational rules language assume existence functions evaluating value expressions boolean expressions 
functions delta exp gamma 
delta bexp gamma 
fff ttg respectively 
denote values expression boolean expression provided closed variables 
single tuple evaluated differently depending argument read 
tuples resulting evaluations elements sets eot eit subsets pl defined follows 
definition set evaluated output tuples eot ranged ot set evaluated input tuples eit ranged generated grammar ot ot communication capability processes depend variables occurring formals tuples evaluating output tuples away variables whilst evaluating input tuples need perform substitutions successful matchings 
functions delta pl gamma 
eot output evaluations delta pl gamma 
eit input evaluations defined inductively syntax tuples table 
pattern matching evaluated input output tuples performed predicate match defined eit theta eot rules table 
pattern matching mechanism slightly different linda see section 
impose values input tuples match values output tuples match table tuple evaluation functions match match ar match match match ot match ot table pattern matching rules formal fields output tuples symbol input tuples match formal fields output tuples 
separation simplified semantic theory allows determine tuple accessed read express read terms law read table 
recover original communication capabilities linda input primitives making external choice operator 
example original linda operation matches tuples form pal followed rendered ready introduce operational semantics pal 
definition operational semantics pal characterized extended labelled transition system proc act gamma gamma ffl proc set pal processes set states ffl act eot theta ranged ff set actions labels ffl gamma gamma proc theta act theta proc action relation relation closed sos rules table ffl proc theta proc internal relation relation closed sos rules tables 
set act contains kinds actions 
action ot ot eot corresponds production tuple ot execution operation 
action ot ot eot corresponds selection tuple ot execution read operation 
shall ae range act sequences actions 
rules ir ir table complementation notation labels 
defined obvious way ot 
ot 
ot 
ot usual ff ff 
operational rules similar tccs acp 
commutativity associativity operator parallel composition enable model actual tuple space parallel composition processes representing single tuples 
fact ts modelled passive component allows represent states transition system purely syntactical objects 
asynchronous nature communication paradigm rendered allowing term proceed ar ot 
gamma gamma 
ot match ot ar read ot 
gamma gamma 
ot nil ot match ot ar nil 
gamma gamma gamma gamma 
nil ar ff gamma gamma 
ff gamma gamma 
ar ff gamma gamma 
jq ff gamma gamma 
jq ar ff gamma gamma 
ff gamma gamma 
jq ar tt ff gamma gamma 
ff gamma gamma 
ar ff ff gamma gamma 
ff gamma gamma 
table action relation symmetrical versions rules ar omitted ir omega omega ir recx recx ir tt ir ff ir nil nil ir eval jq ir ir ir jq jq ir jjq jjq ir bb bb ir ff gamma gamma 
ff gamma gamma 
jq jq ir ff gamma gamma 
ff gamma gamma 
jjq jq table internal relation symmetrical versions rules ir omitted tuple accessed 
rendered nil jp rule ir table tuples independently remainders producer processes 
table rule ar shows process consumes tuple ot matching tuple resulting evaluation causes substitution denoted ot free occurrences variables formals corresponding values ot 
corresponding label carries information tuple consumed 
rule ar shows process read differs leaves ts accessed tuple 
terminology pal operational rules adopt early instantiation scheme value variables bound read instantiated input transitions inferred communications take place late instantiation 
table rule ir shows eval causes dynamic process creation eval nil express original linda eval allowed tuples terms arguments eval 
rules ar ar ir ir show conditional term acts boolean expression evaluates true 
rules ir ir deal interprocess communication 
rules ar ir similar tccs acp 
shall summation represent general external choice operator arguments 
justified sos operational rules ar ir symmetrical ones imply associative commutative 
pp gamma 
pp read gamma 
pp gamma 
gamma 
pp gamma 
jq gamma 
pp gamma 
gamma 
pp tt gamma 
gamma 
pp ff gamma 
gamma 
table process input tuples symmetrical versions rules pp omitted convention denotes nil 
similarly ffi represents general internal choice operator 
basic properties transition system lts pal general finitely branching set initial actions process perform may infinite processes form infinite number derivations ot 
gamma gamma 
ot match ot 
finiteness results lts proved useful express interaction ability processes terms finite sets 
single set evaluated input tuples process initially accessing tuples unary relation gamma 
eit defined inductively syntax terms table 
definition process action ff define sets ffl input read tuples irt fit eit gamma 
ffl output tuples ot fot eot ot 
gamma gamma 
ffl output derivatives od fp ot eot ot 
gamma gamma 
ffl internal derivatives id fp ffl ff derivatives ff fp ff gamma gamma 
finiteness results established 
proposition process action ff irt ot od id ff finite 
proof proof goes structural induction 
consider significant cases 
remaining ones trivial similar explicitly considered 
recx irt od ot id fe recx ff ff act 
subcases ffl nil irt id od ot ot ff ot 
ff ff ffl nil irt od ot id fout ff ff act 
fv var definition irt fi od ot id ff ot 
ff fe ot ff 
jp 
irt irt irt 
od fp jp od fp jp od 
ot ot ot 
ff fp jp ff fp jp ff 
id fp jp id fp jp id fp jp od od ff gamma gamma 
ff gamma gamma 
induction sets cases finite number elements 
obviously true sets fp jp id fp jp id case 
set fp jp od od ff gamma gamma 
ff gamma gamma 
observe ff ff output action induction finite number pairs 
assume ff ot 
ff ot 
ot eot induction conclude number possible processes form jp finite 
testing semantics pal section show apply standard theory testing pal 
aim define set observers observation mechanism experiments computations criterion interpreting observations 
machinery give rise preorder pal processes formulated terms inability respond negatively test 
assume special action prefix success special label denote success 
operational rule corresponds new prefix success gamma gamma 
observers ranged processes contain special prefix success 
experiments terms form jo 
determine result experiment jo consider computations sequences jo jo jo jo jo infinite pair perform internal transition 
write computation exists gamma gamma 
write ust hold general predicate shall write denote hold 
definition testing preorder pal processes interested defined processes observer implies preorder extended terms may contain free process variables follows substitution processes denote equivalence obtained kernel preorder gamma 
simplify proofs shall introduce alternative characterization characterization provides observers independent method checking processes behaviourally related 
alternative characterization rely events processes engaged sequences actions perform 
start introducing notion patterns evaluated input tuples 
patterns differs input tuples away variables occurring formals 
variables affect communication capability processes 
instance processes initially access tuples 
definition set evaluated input tuples patterns ranged generated grammar fp fp fp function eit gamma 
return pattern evaluated input tuple 
essentially abstracts away variables formals evaluated input tuples represented notation tuples extended patterns obvious way 
predicate match defined theta eot means rules table axiom match replaced match 
set introduce notion event 
definition set events ev ranged defined ev ot ot 
predicate match extended events letting ot ev match ot match ot 
mt fot eot match ot mt set evaluated output tuples match patterns intuitively event corresponds set actions ot corresponds ot 
corresponds action ot 
ot mt fpg 
set actions corresponding event may strictly contained corresponding event example set actions corresponding contains corresponding 
comparing finite sets events generalize usual set inclusion relation 
notation ev shall notations ev ot ot ag ev fot ot ev ev ir ag ev ir fp ev ir definition finite sets events write delta ev ev mt ev ir mt ev ir 
intuitively deltab means action corresponding event corresponding event interaction capability fix standard notions 
definition ffl process ff gamma gamma 
called ff derivative internal derivative ffl ae act inductively define ae 
ffl 
ff ffl ff gamma gamma 
ae shall write ffl 
ffl ae act inductively define ae 
ffl infinite computation 
ff delta ae ffl ff ae write ae ae false 
ffl language fae act ae ffl set successors initial events gamma 
ot ot 
ffl acceptance set ae act ae fs ae acceptance sets ordered preorder defined exists delta property relies proposition proven induction ae proposition process ae implies ae finite 
define alternative preorder processes 
definition processes ae act ae 
ae 
ae ae 
prove coincide referred processes theorem 
structure actual proof similar corresponding process algebras due linda communication paradigm additional complications faced 
shall illustrate main steps proof 
proof proceeds shall omit details 
shall sets special observers testing processes 
con tests convergence second rej tests language generated ac tests contents acceptance sets 
tests rely ability observers determine tuple selected pattern matching 
possible adoption pattern matching mechanism defined rules table slightly differs original linda 
succ denote observer success nil observer eval nil succ 
difference immediately succeeds whilst perform internal transition succeeding 
definition ae act ff act finite subset ev observers con ae rej ae ff ac ae defined 
con ffl con ot 
delta ae ot con ae con ot 
delta ae ot ae 
rej ffl ot 
ot nil rej ffl ot 
ot nil rej ot 
delta ae ff ot rej ae ff rej ot 
delta ae ff ot ae ff 
ac ffl ac ac ot 
delta ae ot ac ae ac ot 
delta ae ot ae ev observer ac defined ac ot ot succ ac ot ot arbitrarily chosen value 
observers proving propositions 
proposition process con ae ae 
proposition process ae rej ae ff ae delta ff 
proposition process ae ac ae ae conditions holds ffl ev ev ffl ev ir ev ir ev match match 
theorem processes proof start showing implies assume ae 
proposition implies con ae 
hypothesis con ae proposition ae 
ae obviously ae finished 
means ae 
ae ffl ffl process obviously follows ffl 
ae ae delta ff 
proposition follows ust rej ae ff 
hypothesis ust rej ae ff proposition conclude ae 
proposition follows ae finite say ae fb show exists delta derive contradiction assumption index exist 
event corresponding action correspond event ev conditions holds ffl ot ev ir match ot ev ir match ot false ffl ot ot ev ev set proposition get ac ae 
construction ust ac ae unsuccessful computation ae 
ffl ae come contradiction hypothesis exist delta implies thesis 
show converse implies observer ust show ust 
various reasons ust basic existence finite unsuccessful computation jo interact sequence ae visible actions ae ae observers derivation ae able perform derivative 
ae exists subsequence ae ae ae straightforward obtain unsuccessful computation jo 
ae hypothesis implies exists process ae id delta 
interact delta interact 
derivations ae ae combined form unsuccessful computation jo jo ust alternative characterization easy show behavioural preorder precongruence sigma set pal operators read proposition operators sigma preserve ic phi phiy ic phiy phix ic phix ic phiy ec ec ec ec nil mix phi phiy mix phi table inequations sequential nondeterministic processes proof proof done exhaustive case analysis 
parallel operators bb jj considered remaining cases rely operators read take account substitutions may give rise 
proposition tuple ot eot match ot holds ot ot read read proof take advantage alternative characterization prove claim proof read similar 
ae ffl ffl ffl 
ffl ff gg ffl 
non empty sequence actions form ot delta ae ot eot match ot ae sequence ot ot 
hypothesis ot ot comparing acceptance sets convergence thesis follows 
proof system pal section define proof system pal processes prove sound complete respect behavioural preorder proof system call cp set equational laws plus induction rules handling recursively defined processes dealing input prefixes 
axioms inference rules proof system shown tables 
equation read standing pairs inequations shall write cp cp indicate derived cp table contains standard inequations testing 
laws table state process omega defined pal process und assert strictness binary operators strictness phi follows ic 
laws table essentially concerned pal parallel operators show parallel operators applied finite terms replaced primitive ones nil omega gamma phi left merge operator deserves und omega und omega jx omega und omega omega und omega omega und omega omega und omega jjx omega table inequations omega par phiy jz jz phi jz par jy phi jz par ot nil ot nil comm match ot match ot jy jjy phi jjy comm jy comm lm lm phiy phiy lm nil lm lm jy var free lm ot ot jy cm jjz jjz jjz ot nil bb cm phiy jjz jjz phi jjz cm jjy jjx cm nil cm jj ot nil bb ot jy match ot cm jj ot nil bb nil match ot cm jj nil cm ot nil bb jj ot nil bb nil table laws parallel operators specific attention completely replaced simpler form needed blocking output prefix 
par par taken 
par modification interleaving law take account communication paradigm pal 
interleaving law par weaker version standard acp axiom xjy applies stable processes processes initial internal transitions similarly cm weaker version corresponding acp axiom holds stable remaining laws obvious adaptations similar laws 
laws table new depend communication paradigm language 
rely notations 
general acp law sound respect instance take jq jjq nil nil nil letting success nil success nil get ust internally process satisfy 
condition syntactic structure necessary soundness law 
instance take nil nil nil nil letting success nil get jjr jjr ust notation eit pl 
pf denotes set positions formal fields pa set positions actual fields 
pf implies pf implies var 
pf pa implies 
pf pa pf pa implies 
bem pf pa var 
oe var pf pa comment notations introduced 

example consider tuple 
pf pa 

means obtained removing line variables formals transforming formals actuals 
example 

states output tuples match match variables occurring formals occur corresponding formals 
example hold 

states corresponding formals syntactically identical exist output tuples match example 
note implies 
bem understood boolean function evaluates true receives argument output tuple matches general bem form delta delta delta var bem scope operator bind subsequent free occurrences variables var 
usual tt 

oe substitution replaces variables occurring formals corresponding values 
assumption variables occurring formals tuple different important having simple definitions bem oe 
comment laws table 
laws eval assert ot eval non blocking operators 
particular says general output prefixing needed nullary process operators forms ot nil sufficient 
laws evident internal nondeterminism processes permit postponing internal choices 
ot ot nil ot ot ot nil bb phiy ot phi ot ot nil bb phiy eval eval read read nil bem phiy pf pa pf pa bem phi oe bem xoe phiy bem phi oe phi bem xoe phiy table linda laws read permits expressing operator read terms 
law relies ability determining tuple selected pattern matching 
note definition follows fv nil var 
simple application law get equation read nil cp permits deleting second summand external choice absorbing behaviour 
premise guarantees law applied choice internal summand may access tuples accessible second 
instance bem get equation nil nil cp nil phi nil nil permits introducing internal choice tuple accessed 
premises guarantee law applied summands external choice access common tuples case summand may access tuples summand may access pf pa pf pa 
law says summands possible access common tuple making commitment behaviour 
premise definition oe fact fv var fv var imply fv xoe var fv oe var 
example consider process nil nil 
pf pa pf pa bem bem oe oe follows derive equation cp nil nil nil nil nil nil ii op op op phi bb jjg iii ot ot match ot iv recx recx iv recx recx law vi vii tt vii ff viii viii ix var fresh table inference rules laws mutually exclusive sense applied 
rests ideas 
summand absorbed law evident internal nondeterminism due fact exist output tuples summands access 
allow derive laws similar see table 
rules proof system table 
borrowed self explanatory 
main addition iii similar rule 
infinitary eot infinite 
proof system infinitary rules vi handling recursively defined terms iii dealing input prefixes 
infinitary rules completeness result purely theoretical interest 
practice tractable forms induction needed forms shall example section 
vi denote nth finite syntactic approximant standard construction algebraic semantics actual definition 
basic idea term determines set finite terms recursion obtained unfolding finite number times recursive sub terms 
ranges substitutions process variables 
vii viii assume existence evaluation mechanisms expressions boolean expressions tuples 
ix ff conversion rule input prefixed terms substitutions applied tuples obvious way 
proven axiom independent removal affect relation provable cp 
sake space completeness proof point specific role axiom 
soundness completeness proof proceeds steps reduced proof system considered soundness completeness finite processes proven inference rules establish soundness completeness cp rp proof system obtained cp deleting rules iv vi table dealing possibly infinite terms 
shall write rp indicate derived rp 
theorem states soundness rp soundness cp rely partial completeness rp soundness proof cp completed theorem 
theorem value closed terms rp implies proof soundness proof consists checking preorder preserved rules laws satisfied rule states preorder 
soundness ii iii stating substitutivity pal contexts propositions 
soundness iv vii viii ix easily proven alternative characterization rule sound definition terms open respect process variables 
soundness proof system open process variables terms easy consequence soundness closed ones 
soundness reduces axioms rp axioms rp easily proven sound concentrate proving completeness rp finite pal processes 
proof rests existence standard forms see processes called head normal forms 
similar forms 
intuitively special forms aim describing processes internal nondeterministic choice set initial states 
framework initial state represented initial events process perform derivatives 
start introducing notions closed saturated set events 
defining partial order acceptance sets adapt standard saturation procedure basic preorder delta comparing finite sets events partial order 
definition finite subset ev closed exists fe delta feg 
cl pf pa implies ev proposition delta partial order set closed sets events 
proof show closed subsets ev delta delta obviously delta delta conversely suppose delta delta proceed contradiction 
assume loss generality may assume exists delta get exists feg delta fe hypothesis implies contradict fact closed 
delta deduce exits fe delta fe transitivity get feg delta fe contradicts fact closed 
hold 
corollary cl represents equivalence class respect delta 
proof definition cl closed 
cl definition cl delta cl exists cl feg delta fe delta cl 
proposition follows finite subset ev delta delta cl cl 
define notion saturated set framework applies finite collections sets events acceptance sets see section 
acceptance set ev denote set fa ag events ev ir denote set input events ev denote set output events definition finite collection closed sets events saturated saturated set conditions hold 
cl ev 
closed delta delta imply sat ev ranged set saturated sets ev 
possible transform acceptance set saturated set 
shall construction 
sat greatest subset fcl ag fcl ev 
cl ev sat 
fcl ev fag delta imply sat 
note saturating collection sets events adding elements collection delete sets collection 
similar minimization procedure essential obtaining finite collections 
saturation acceptance sets ff gg result infinite collection elements sets containing events form 
proposition acceptance set sat 
proof prove sat case analysis elements sat ffl cl ev definition delta ffl cl ev definition cl delta prove 
cl 
cases consider 
cl sat cl delta suppose cl sat 
sat greatest subset enjoys properties 

definition exist sat delta cl sat fcl enjoy previous properties transitivity delta proposition partial order sat ev 
proof show saturated sets obviously 
conversely suppose 
proceed contradiction 
assume cl ev cl ev delta cl ev cl ev cl ev delta cl ev 
loss generality may assume exists cl ev 
exists delta implies exists delta transitivity delta saturated cl ev proposition get contradicts hypothesis introduce standard forms processes 
definition head normal forms ffl denote equivalence relation induced rules tt ff ffl partial function ev gamma 
proc normal function nf ot dom implies ot ot dom implies imply eoe oe 
ffl process head normal form hnf conditions holds closed set events nf dom ffi saturated nf dom ev 
comment definition terminology introduced notations 
intuitively ff act ff gamma gamma 
ff gamma gamma 
derivatives obviously implies equivalent 
recall denotes nil nil hnf definition evident hnf ffl 
functional notation adopted pointing hnf event associated single term 
condition ensures initial action ff hnf perform ff derivatives equivalent testing equivalent 
checks tuple ot fot match ot match ot accessed obtained processes equivalent 
ff distinguish ff derivatives hnf sequel consistently notation ff denoting ff derivatives hnf counterpart head normal forms divergent finite processes omega gamma head normal forms 
definition process omega gamma head normal form omega gamma hnf short conditions holds phiy phi phiy phiy phiy phi phi phi phi ot phi ot ot phix phi ot phix phi bem phi oe phi bem oe phix table derived laws 
nil omega omega gamma hnf 
ffi omega gamma hnf form form ot proving completeness need special induction parameter largest number communications finite process perform 
parameter defined terms maximal number visible actions process derivation 
define depth finite process depth ae ae denote value open finite process 
generalize definition depth letting depth value closed instantiation 
confined finite terms process variables number finite 
propositions existence standard forms processes proof completeness theorem 
laws table eval table expressing parallel operators terms non deterministic ones laws tables crucial obtaining saturated sets events 
laws table derived rp laws easily derived respectively 
derived exactly way corresponding ones 
laws obtained similar fashion der page particular obtained laws correspond 
proposition finite process exists omega gamma hnf omega gamma rp omega gamma 
proof actual proof goes structural induction case jp relies depth jp omitted similar lemma 
proposition finite process ffl rp omega gamma proof previous proposition may assume omega gamma hnf ffl omega gamma nil form ffi definition diverge 
converse rp omega proof system rp sound respect get omega gamma particular means omega ffl 
simplify reduction convergent processes rp proposition introduce special form processes head sum form hsf 
show convergent process transformed hsf hsf transformed hnf roughly speaking hsf process top level operators phi ot order 
definition set head sum forms hsf set processes satisfies 
ot fv var 
hsf 
ffi hsf 
proposition finite process ffl exists hsf rp 
proof proof omitted similar proposition 
proposition process ffl exists hnf rp 
proof proposition may assume hsf say ffi case similar 
repeated law rewrite hsf ffi closed set events 
independent repeatedly laws mix mix 
resulting hsf form ffi condition definition general satisfied 
laws generalize law repeatedly obtain hnf ffi define ev normal function 
step consists saturating hsf ffi 
missing requirement hsf hnf satisfied laws 
relation going define permits syntactical comparisons top level 
bridge semantical relation proof theoretic cp shall ia denote set actions initially perform ia fff act ff proposition implies ff ff ff ia ia 
proof cases consider ff ot 
ff ot 
case ff ot hypothesis ff jo follows ff case ff ot 
proven similarly ot nil 
definition 
write oe ia ia conditions holds 

ffi ffi 
ffi delta proposition implies oe proof start proving ia ia 
show exists ff ia ia suppose ff ot 
ia ia take observer ot nil 
ffl hnf ff ia ff construct unsuccessful computation ot 
ust ff ot 
argue similarly observer ot nil 
ia ia left prove conditions definition holds 
suppose 
hypothesis implies ffl ffl fag ffl delta implies delta ev delta cl ev 
ia ia cl ev delta cl cl ev saturated cl ev delta delta cl ev fag form condition 
definition holds 
suppose ffi 
cases consider syntactic form assume ffi 
prove condition 
definition holds 
directly follows fact coincide 
definition hypothesis implies ffl ffl suppose 
prove condition 
definition holds delta syntactic form follows ffl fbg 
exists delta proposition oe rp ff ia ff rp ff proof ia ia delta 
normal functions associated respectively 
consider process defined substituting gamma 
proc notation defined follows ffl ot ffl eoe feg delta fe possibly applying rule ix hypothesis applying rule ii case bb ff form ot 
rule iii ff form ot straightforward show rp 
rule ii deduce rp form finished laws reverse direction saturation procedure described proposition rewriting form ffi anb phi ffi saturated sets associated respectively 
applying law ic immediately follows rp thesis proven 
prove partial completeness rp theorem processes finite implies rp proof ffl rp omega proposition thesis follows law und 
ffl exists hnf rp proposition 
soundness rp respect implies exactly traces depth depth 
hypothesis implies ffl proposition exists hnf rp 
left prove rp 
proceed induction depth 
depth nil 
soundness rp hypothesis implies 
nil thesis part proven 
suppose depth 
proposition oe 
particular means ia ia ia ia ia 
proposition deduce ff ia ff ff inductive hypothesis deduce ff ia ff rp ff proposition obtain thesis 
consider full proof system cp 
proposition relies partial completeness rp proving soundness cp denotes nth finite syntactic approximant proposition process observer exists proof prove thesis suffices show exists finite rp routine see show finite process process rp implies rp 
suppose consider computation tree jo branches pruned obtain tree leaves nodes perform call tree process id finite proposition finitely branching 
konig lemma follows finite 
proof proceeds induction maximal number communications path root leaf easily seen number change consider computation tree jo testing equivalent ffl gamma 
take omega gamma ffl partial completeness rp may suppose hnf reason case analysis 
suppose 
process built finite processes defined follows 
consider set airs ot ot 
gamma 
match ot gamma 
ot airs jo ot jo hypothesis implies ot ffi fo ot airs inductive hypothesis exists finite process ot ot rp ot ot ffi fo ot airs ot ot airs 
mt fot ot airs ot finite proposition mt finite say mt fot ot ot define bem ot ot bem ot ot omega rule vii easy check ot rp ot ot match ot 
ot ot set get ot fo ot 
gamma 
gamma 
empty ffi fo get ot inductive hypothesis exists finite process rp ffi fo get ot get ot 
case define get ot define omega gamma define 
construction rules ii iii easily seen rp suppose ffi 
repeating construction get exists finite process ra ra rp ra define ffi ra thesis follows rule ii 
theorem processes cp implies proof left show rules iv vi sound 
rule iv derivable axioms rules cp see sound 
soundness inductive rule vi easily follows proposition 
completeness full proof system established 
theorem processes implies cp proof suppose standard result algebraic semantics see states satisfies ii iii iv und completeness rp infer rp cp apply vi conclude cp proof system section show proof system proving correctness simple programs permit adding arrays elementwise 
assumed language parameterized countable set values require natural numbers 
arrays naturals 
shall consider pal processes add elementwise leaving result array better exploit parallelism intrinsic problem array represented distributed data structure 
shall tuple single element array 
represent shall tuples fields contains constant identifies array second index element value element 
processes consider add elements index exist finite length arrays 
consider pal processes ffl recx eval nil ffl qjp 
want show process obtained putting parallel copies provably equal cp may think process executes single processor able dynamically reproduce new element array accessed 
instance computes element array number instances concurrently active depends difference number elements elements accessed 
may think really distributed process consisting copies process simultaneously executed different processors 
sense may thought efficient fault tolerant solution problem full power cp simpler induction rule 
powerful simple form induction dealing recursively defined terms unique fixpoint induction expressed rule recx 
guarded 
derived cp see correctly terms examine guarded occurrences process variables preceded blocking prefix 
proceed induction firstly prove cp term recursively defined order show recx eval nil instance 
sufficient deduce eval nil applying eval jin nil may proven standard strategy consisting expanding recursive definitions applying laws parallel operators interleaving law par 
expanding recursive definitions applying eval get nil jin nil nil nil applying interleaving law par get nil nil applying ix renaming variables bound input prefixes ec coalescing summands get equation conclude cp prove inductive step 
assume cp applying ii hypothesis case operator get qjp similar way derive conclude cp 
denotational semantics pal section define denotational semantics pal prove fully respect testing preorders 
denotational model shall form natural interpretation 
slight variant usual algebraic semantics see introduced dealing languages value passing see 
notation borrowed 
notation write gamma 
denote function defined 
sets gamma 

denote disjoint union sets 
denote function functionality gamma 
defined function cpo complete partial order cpo dom refer domain support fd dom denote empty totally undefined function function dom support 
set elements cpo hd ti denoting upper bound lub respect exists 
gamma 
denote set partial functions set cpo hd finite domain gamma 
denote functions finite support 
sets non standard ordering theta iff dom dom support dom note defined partial function smaller theta holds hd algebraic cpo hf gamma 

theta hf gamma 

theta algebraic cpo proof done lines lemma 
model acceptance trees linda due computational nature choose interpret language cpo recursive definitions interpreted 
operators sigma associate continuous function appropriate arity 
exceptions eval prefixing derived operator denotational semantics parallel operator sake simplicity sigma gamma denote set pal operators exception prefixing read eval conditional construct input prefixes interpreted similarly binding operators value variables need extra structure interpreting 
example var take open term return process 
appropriate type input operation theta eot gamma 
gamma 
proposed interpretation processes 
read interpreted similarly 
definition natural interpretation pal quadruple hd sigma gamma ffl hd sigma gamma sigma cpo hd cpo defined continuous function operator signature sigma gamma ffl theta eot gamma 
gamma 
total function continuous second argument eot gamma 
inherits natural pointwise ordering denoted 
natural interpretation define denotational semantics pal 
cope open terms environments mappings set process variables env ranged represent set environments 
denotational semantics function delta pal gamma 
env gamma 
defined structural induction clauses 

omega omega 
nil nil 
op op op phi bb jjg 
eval 
ot ot 
tt ff 
recx 
match gamma 
read match gamma 
nil fixed point operator continuous functions rest section shall construct particular natural interpretation acceptance trees linda properly reflects testing preorder rests algebraic sigma cpo algebraic cpo countable set compact elements 
interpretation algebraic completely determined compact elements 
construction model rests description set fat compact elements description relative partial ordering fat definition compact elements define cpo fat ffl fat set satisfies requirements 
fat 
sat ev eot gamma 
fat dom ev ir eot gamma 
fat dom ir mt ev ir ha ir fat ffl fat defined follows 
fat fat 
ha ir fat hb ir ir theta fat ir theta fat shall write ir fat ir shorthand ir theta fat ir theta fat note deterministic process order 
turn poset fat sigma po algebra providing sigma algebra structure 
aim define monotonic function operator sigma gamma addition input function correct type monotonic second argument 
start defining special function fat input prefixes shall define functions sigma gamma fat fat define fat theta eot gamma 
fat gamma 
fat fat hff gg dom mt fpg ot dom ot ot 
nil fat nil fat tree hf omega fat omega fat tree 
ot fat ot eot define ot fat fat gamma 
fat ot fat hff ot gg fi dom ot phi fat internal choice define phi fat fat theta fat gamma 
fat ha ir hb ir ir ot ev sat fl ot mt ev ir sat fl ir holds fl ot fl ot phi fat fl ot ot dom fl dom fl fl ot ot dom fl dom fl fl ot ot dom fl dom fl fat external choice define fat fat theta fat gamma 
fat ha ir hb ir ir pointwise union set fa bg ir defined case phi fat operator 
fat parallel composition define fat fat theta fat gamma 
fat ha ir hb ir ffi fat bg tab int fat phi fat fat ext ffi fat int int ff ir ot fat ot ot ev mt ev ir ff ot fat ir ot ot ev mt ev ir ext fin fat ev ir dom dom ir ot dom ot ir ot fat ug fin fat ev ir dom dom ir ot dom ot fat ir ot fout ot fat ot fat ot ev fout ot fat fat ot ot ev jj fat communication merge define jj fat fat theta fat gamma 
fat ha ir hb ir ffi fat bg defined case fat operator 
bb fat left merge define bb fat fat theta fat gamma 
fat ha ir ha ir dom ir dom ir dom dom ot ev fl ot mt ev ir fl ir holds fl ot fl ot fat ordering partial functions distinction domain support partial function permit discriminating functions undefined functions evaluating 
show means simple example discrimination important theory 
consider processes nil nil omega gamma easily seen take observers success nil nil respectively 
adopt standard denotational approach look partial functions global functions evaluating outside domain dom fot eot ot theta fat iff dom dom ot dom fat hff gg hff gg functions extensionally equivalent gamma 
nil fat 
ff gg wrongly conclude fat 
approach dom gq mt eot jv alg mt dom theta fat fat 
proposition fat sigma gamma fat sigma predomain 
proof fat poset element definition omega fat bottom element fat left show function sigma gamma fat defined monotonic 
proofs routine 
proposition fat defined monotonic second argument 
proof recall definition eot gamma 
fat fat hff gg dom mt fpg ot dom ot ot 
obvious fat defined fat fat show fat monotonic second argument 
assume eot gamma 
fat fat recall fat pointwise ordering inherited fat 
define ffl dom mt fpg ffl ot ot ot mt fpg 
dom dom mt fpg ot support ot ot fat ot ot theta fat monotonicity fat second argument follows 
standard technique algebraic semantics known completion ideals obtaining algebraic cpo fat eot gamma 
fat unique continuous extensions previously defined monotonic functions theorem 
crucial point algebraic cpo eot gamma 
fat fat eot gamma 
fat fat isomorphic 
algebraic cpo completely determined compact elements suffices show hf eot gamma 
fat fat eot gamma 
fat fat comp eot gamma 
fat set compact elements eot gamma 
fat isomorphic partial orders follows fact fat comp fat isomorphic 
wanted process interpretation domain fat call extended functions give natural interpretation pal processes 
sake simplicity name continuous extensions monotonic functions extend replace subscript fat results follow directly standard algebraic semantics theory 
corollary hat sigma gamma sigma domain 
corollary hat sigma gamma natural interpretation 
full abstraction denotational interpretation section shall prove denotational model fully respect proof theoretic preorder cp processes cp 
proven soundness completeness proof system cp respect behavioural preorder enable conclude denotational model fully respect testing preorders 
start considering finite processes proving full abstraction result generalize result general pal processes 
compact elements model essential 
elements general correspond finite processes finite processes input infinite set tuples processes may finite breadth 
relying notation introduce notions finite breadth approximants compact processes 
show compact elements cpo semantic denotations compact processes recursively defined process semantically limit directed set compact processes 
definition finite process set finite breadth approximants fba inductively defined follows 
fba omega gamma omega fba nil 
fba fout fba 
fba eval fba fba 
fba op fq op fba fba op phi bb jjg 
fba fif fba 
fba fin fin mt ot ot fba ot fba read fread fin mt ot ot fba ot bem ot ot bem ot ot omega fot ot ot shall say finite process compact exists finite process fba 
construction finite process fba rp proposition states relevant properties proving full abstraction 
proposition finite processes 
fba implies fat compact 
fd fba directed fd fba 
compact rp imply exists fba rp 
fba rp implies rp proof outline 
directly follows structural induction definition finite breadth approximants process 

proof proceeds structural induction exploits continuity operators difficult cases read fv var 
consider dealt similarly 
definition fba delta structural induction fd fba read fd read fin mt ot ot fba ot fin gg process introduced definition fg eot gamma 
fat gamma 
fat nil fat fat fin mt fba fat 
definition fin mt imply match gamma 
fat nil fat fat gamma 
gamma 
fat nil fat fat 
inductive hypothesis mt fd fba fat nil fat fat fba directed directed eot gamma 
fd fba read directed continuous second argument fba read gg tg hand inductive hypothesis continuity operators read match gamma 
nil match gamma 
nil fba tk ff eot match gamma 
nil mt fba left show tg tk 
obviously tg tk 
hand consider chain functions fg defined gamma 
chain finite subsets eot mt 
easily seen deduce tk tg tg tk applying fact theory cpo subsets cpo tx ty exists ta 
proof proceeds induction depth proof rp proof system rp 
consider case iii applied rule 
iii applied rule deducing rp compact exist eit fin mt finite fv var fv var rp rp ot mt ot rp omega ot ot rp ot 
ot ot compact induction may assume ot ot fba ot ot rp ot consider process process introduced definition 
definition follows fba 
applying rule iii deduce rp fba rp imply exists fba rp conclude rp 
suppose fba rp paralleling proof proposition prove process observer exists compact rp compact rp part 
proposition deduce exists fba rp hypothesis rp implies prove full abstraction compact processes proposition shall alternative characterization fat definition fat ff act ae act ffl write ff gamma gamma 
conditions holds ff ot ha ir ot ev ot ff ot ha ir match ot ev ir ir ot 
ffl acceptance set ae 
ffl ha ir 
ff delta ae ae ff gamma gamma 
ffl write 
ffl 
ff delta ae ffl ff gamma gamma 
implies ae ffl write fat ae act ae 
ae 
ae ae 
propositions proven analogous results 
proposition fat fat ff ff gamma gamma 
imply exists ff gamma gamma 
fat proposition fat fat results proving full abstraction compact processes 
prove soundness reduced proof system rp respect fat soundness rp fat proven paralleling proof soundness rp notion hnf property 
proposition process ffl action ff act ff gamma gamma 
iff ff gamma gamma 

proof directly follows construction definitions delta partial function ff gamma 
fat proposition compact process ae act ae iff ae 
proof proof proceeds induction ae length ae 
ae ae ffl ffl hnf proof system rp sound respect fat 
interpreted non trivial trees 
conversely compact implies ffl 
assume ae ff delta ae ffl hnf rp 
ff ff gamma gamma 
ff proposition ff gamma gamma 
ff 
hypothesis ae implies ff ae induction may assume ff ae ff delta ae conclude ff delta ae conversely suppose ff delta ae definition ff gamma gamma 
implies ae case ae know result true ae ffl ffl implies exists hnf rp 
proposition deduce ff gamma gamma 
ff ff 
ae induction assume ff ae holds ff ff ff definition ff delta ae proposition compact process ae act ae implies sat ae ae 
proof proof proceeds induction ae 
assume ae 
implies hnf rp 
ae ffl 
rp means sat ffl sat ffl 
definition sat ffl ffl 
construction ffl ffl 
conclude sat ffl ffl 
ae ff delta ae induction ff delta ae ff delta ae non empty non empty 
assume non empty 
definition sat ff delta ae sat fa ff ae ff ff 
ff gamma gamma 
sat fa ff ae ff ff sat ae 
induction assume sat ae ae 
proposition ae ff delta ae 
sat ff delta ae ff delta ae 
proposition compact processes rp iff fat 
proof cp iff iff completeness cp fat iff fat compact acceptance trees proposition suffices show iff fat 
directly follows propositions 
consider finite processes 
theorem finite processes rp iff 
proof suppose rp proposition fba exists fba rp proposition implies fat 
proposition fd fba fd fba 
suppose 
proposition implies fba 
fba fd fba directed proposition compact proposition exists fba 
proposition rp definition fba implies rp rp proposition conclude rp full abstraction general processes proven finite breadth approximants 
definition non finite process fba fr fba theorem processes cp iff 
proof term env 

fd 
standard result algebraic semantics theory proven structural induction paralleling corresponding proofs theorem 
previous result proposition theorem directly follows fd fba directed fba processes cp iff cp standard result type systems similar 
proposition follows cp iff fba fba cp fd fba set compact elements follows iff fba fba 
proven cp iff compact processes conclude cp iff 
imperative pal section show framework defined pal easily accommodate addition imperative construct form action prefixing language 
particular show theory developed pal reused establish proof system sound complete denotational model fully 
assume individual process private store binding variables values accessed processes explicit communications 
assigning values free occurrences variables take advantage syntactic restriction definition value process variables binders differently explicitly model store explicit substitutions 
choice allows smoothly extend framework pal imperative variant 
example states lts characterizes operational semantics language purely syntactical objects pal avoid considering configurations pairs processes stores operators 
syntax obtained adding new prefixing operator assignment pal definition 
productions action prefixes fi fi fi fi fi fi read fi fi fi eval fi fi fi obviously unary operator binds variable argument term new binder value variables 
operational semantics characterized lts obtained adding lts pal rule ir accounts behaviour assignment prefixes 
rule ir models internal move updates store 
affects argument prefixing effect parallel processes free occurrences variables name variable left 
change directly observable explicit communications environment operation evident 
observers access private store tested processes gather information communication 
behavioural preorders defined pal coincidence theorem proven 
proof system obtained simply adding specific law assignment proof system pal 
stores investigated communication conditional choice introduce additional inference rule ensuring substitutivity value expressions rules vii viii table sufficient 
results related equational semantics pal proven 
particular normalization procedures law employed removing leading assignments 
paralleling proofs pal easy check proof system sound complete respect testing preorders theorem 
defining denotational semantics eval conditional operators specific operator fat assignment prefixes 
add clause definition interpretation function delta section 

finite breath approximants finite process form 
fba fq fba results concerning denotational semantics pal hold 
denotational model fully respect behavioural preorders proof theoretic theorem 
related studied impact theory testing process description languages permit writing programs manipulate values exchange asynchronously programs 
languages obtained substituting uninterpreted actions csp process algebra linda primitives process interaction pal adding pal assignment command 
sound complete proof systems testing defined fully denotational model natural interpretations 
instrumental development klaim programming language pal implementing interactive mobile agents 
asynchronous variants process algebras considered literature acp csp calculus ccs 
works followed main lines differ way non blocking output actions modelled rendered state transformers processes 
variants acp ccs csp model output actions state transformers associate buffers modelled state operators acp ccs processes csp channels 
variants naturally describe systems outputs modelled unblocked sending primitives messages available consumption 
asynchronous sending operations visible 
consequence processes differ sending order messages considered different 
ad hoc notion failure equivalence introduced correctly describe process behaviours respect deadlock 
usual testing scenario synchronous process algebras exploit different observation communication mechanism obtain different semantics 
sending operations visible auxiliary operator store messages sent processes 
messages linked sender process read 
approach suitable model linda communication paradigm 
shown csp processes asynchronous communications obtained attaching buffer input output channels csp processes 
scenario introduces centralized manager process communication channel asynchrony strongly relies fact sending messages channel managers possible 
point view asynchronous communications realistic assumptions distributed systems model class language primitives 
variants calculus ccs described model output actions processes bisimulation equivalences obtain observational semantics :10.1.1.53.4500
followed similar approach output actions modelled means internal moves take place non blocking change structure terms 
choice particular implies nil nil nil nil apparently contrast law nil nil nil nil denote outputs channels considered essential law models asynchronous communications 
difference due distinct choice operators languages 
operator describe internal external nondeterminism 
example term nil nil denote inputs channels sending permit rejecting setting corresponding term nil nil nil 
output actions dealt just silent action ccs translation ccs tccs 
setting sound version nil nil nil nil nil nil phi nil phi nil established theories process calculi explicitly manipulate values developed 
addition mentioned 
testing framework developed variant tccs value passing 
large methods similar tuples asynchronous communication calls different formal set 
apart presence non finitely branching transition systems face additional complications introduced inability observers perceive differences patterns access tuple 
take problem account introduced notion closed set events 
major impact communication mechanism denotational model sequel input action partial function defined tuples match pattern 
approach formal analysis semantics linda communication paradigms followed 
find example tuning process algebraic techniques dealing linda paradigm 
basic idea considering tuples atomic items unique identification name 
choice hand simplifies required mathematics prevents account subtleties linda communication model 
similar behaviour modelled framework introducing simplifying assumption tuples atomic items 
extension semantic set pal simpler ccs value passing assignment 
stores bindings variables values explicitly modelled operational semantics consider configurations pairs processes stores operators 
new proof system obtained extending applicative laws pal family laws process operator rewriting assignment normalization procedure inference rule ensuring substitutivity expressions assignments 
advantage syntactic restriction definition value process variables binders show single additional law sufficient complete equational characterization 
removed syntactic restriction parameterized process variables order avoid providing pal counterintuitive unsatisfactory semantics models recursive terms differently unfoldings 
action prefixing full sequential composition essential reusing semantical machinery introduced pal 
chosen sequential composition terms inherit stores equivalences congruences 
development similar framework deal full sequential program composition action prefixing progress 
studied imperative language obtained embedding linda primitives interprocess communication simple imperative language sequential composition 
succeeded defining testing scenario enabling observers test final store finite computations programs able obtain equational characterizations testing preorders richer language 
obviously difficult framework verifying programs 
additional needed deal properly left communication merge operators general external choice operator 
hand rendered definition alternative behavioural characterization proof system easier hand significantly increased discriminating power observers 
merge operators permit expressing causal dependencies output actions 
observation mechanism allows observers determine system consumed message 
outputs choice points require synchronizations implementation level 
may conflict idea asynchronous outputs intended take place immediately requiring availability corresponding input circumstances argued observers guaranteed message consumed 
consequence observational theory certain extent discriminating equational laws asynchronous bisimulation valid testing equivalence 
see possibilities weakening behavioural relations respect omitting merge operators general input guarded external choice operator modifying observation mechanism 
acknowledgments grateful michele boreale ferrari helpful comments discussions anna ing anonymous referees insightful comments allowed significantly improve 
benefitted comments ernst olderog palamidessi external referees ph thesis second author 
aceto 
theory testing acp 
concur proceedings baeten groote eds lncs pp 
springer 
amadio castellani sangiorgi 
bisimulations asynchronous calculus 
theoretical computers science 
brogi ciancarini 
concurrent language shared prolog 
acm trans 
programming languages systems 
boreale de nicola 
testing equivalence mobile processes 
information computation 
brookes hoare roscoe 
theory communicating sequential processes 
journal acm 
klein 
tuple space integrated modula implementation linda concept hierarchical multiprocessor 
proceedings ed cambridge university press 
bergstra klop 
process algebra synchronous communication 
information control 
bergstra klop tucker 
process algebra asynchronous communication mechanisms 
seminar concurrency proceedings brookes roscoe winskel eds lncs pp 
springer 
de boer klop palamidessi 
asynchronous communication process algebra 
proceedings lics ieee computer society press pp 

de boer palamidessi 
asynchronous nature communication concurrent logic languages fully model sequences 
concur proceedings baeten klop eds lncs pp 
springer 
boudol 
asynchrony calculus 
research report inria sophia antipolis 
carriero gelernter 
linda context 
communications acm 
carriero gelernter 
distributed data structures linda 
proc 
acm symposium principles programming languages acm new york pp 

chandy misra 
parallel program design foundation 
addison wesley massachusetts 
ciancarini gorrieri zavattaro 
calculus generative communication 
proceedings st ifip conf 
formal methods open object distributed systems pp 
chapman hall 
cleaveland hennessy 
testing equivalence bisimulation equivalence 
journal formal aspects computing science 
cleaveland 
operational framework value passing processes 
proceedings acm symp 
principles programming languages acm new york pp 

de nicola 
ferrari pugliese 
klaim kernel language agents interaction mobility 
ieee transactions software engineering 
de nicola hennessy 
testing equivalence processes 
theoretical computers science 
de nicola hennessy 
ccs 
tapsoft proceedings ehrig levi montanari eds lncs pp 
springer 
de nicola pugliese 
observational semantics linda 
strict proceedings desel ed series workshops computing pp 
springer 
de nicola pugliese 
process algebra linda 
coordination proceedings ciancarini hankin eds lncs pp 
springer 
de nicola pugliese 
testing semantics asynchronous distributed programs 
analysis verification multiple agent languages proceedings dam ed lncs pp 
springer 
gelernter :10.1.1.113.9679
generative communication linda 
acm transactions programming languages systems 

algebraic semantics 
lncs springer 
hansen 
bisimulations asynchronous mobile processes 
proc 
symposium languages logic computation appeared research hcrc rp univ edinburgh 
hennessy 
acceptance trees 
journal acm 
hennessy 
algebraic theory processes 
mit press 
hennessy 
theory communicating processes value passing 
information computation 
hennessy 
communicating processes value passing assignment 
journal formal aspects computing science 
hennessy plotkin 
term model ccs 
mfcs proceedings ed lncs pp 
springer 
hoare 
communicating sequential processes 
prentice hall international 
honda tokoro 
object calculus asynchronous communication 
ecoop proceedings america ed lncs pp 
springer 
honda tokoro 
asynchronous communication semantics 
object concurrent computing tokoro nierstrasz wegner eds lncs pp 
springer 

semantic models communicating processes value passing 
ph thesis university sussex department cognitive computing science 
jifeng hoare 
theory synchrony asynchrony 
ifip working conf 
programming concepts methods proceedings broy jones eds pp 
north holland elsevier 
milner 
communication concurrency 
prentice hall international 
milner parrow walker 
calculus mobile processes part ii 
information computation 
park 
concurrency automata infinite sequences 
theoretical computer science deussen ed lncs pp 
springer 
mcdonald 
inclusion linda tuple space operations pascal concurrent language 
computer science dept univ western australia 
plotkin 
structural approach operational semantics 
technical report daimi fn aarhus university dep 
computer science denmark 
pugliese 
process calculus asynchronous communications 
proc 
fifth italian conference theoretical computer science de santis ed world scientific 
pugliese 
semantic theories asynchronous languages 
ph thesis university rome la sapienza dipartimento di scienze dell informazione 
linda user guide manual 
scientific research associates 
shapiro 
concurrent prolog collected papers 
mit press 
sutcliffe 
prolog linda embedding linda 
tech 
report dept computer science univ western australia 

