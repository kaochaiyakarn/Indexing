programming paradigms andorra kernel language janson seif haridi swedish institute computer science box kista sweden mail sics se seif sics se andorra kernel language akl introduced 
show akl provides programming paradigms prolog ghc 
original goal design 
possible provide capabilities prolog ghc 
means structure search powerful plain backtracking 
possible encapsulate search concurrent reactive processes 
possible write multi way merger constant delay 
respects akl quite original 
andorra kernel language akl general concurrent logic programming language instance kernel andorra prolog control framework extended andorra model 
presents language design 
purpose illustrate possibilities provided akl familiar examples 
implementation set aside 
prototype implementation language showing promising results 
feel need explain properties language discussing implementation techniques 
akl concurrent language 
aspects language order dependent means ample possibilities parallel execution 
provide potential parallel execution writing programs 
organised follows 
section provides background 
section de nes akl computation model 
section shows programming paradigms prolog ghc available providing translations akl 
shown improve translation prolog ways 
section devoted nondeterministic computation 
rst discuss nite domain constraint programming akl 
shown produce cartesian product ect combining solutions goals 
cartesian product applied partially computed solutions improved behaviour result 
section shows encapsulated nondeterministic computation reactive computation multi way merge constant delay 
background related akl brings ideas di erent camps di erent people quest combine prolog committed choice languages constraint logic programming single uni ed framework 
warren proposed basic andorra model rst described parallelism dependent parallelism execution pure de nite clauses see section 
idea owes notion determinacy prolog 
basic andorra model implemented exploiting parallelism combination dependent parallelism execution prolog programs 
potential basic andorra model basis combining prolog committed choice languages rst advocated haridi brand 
independently gregory generalised basic andorra model allowing full parlog execution deterministic phase language 
extended andorra model developed joint ort warren 
set rewrite rules trees potentially uni es abilities prolog ghc 
sense akl de nite clause resolution prolog 
provides control andorra idea giving priority deterministic computation foundation di erent control principles proposed 
warren proposed implicit control regime goal provide behaviour prolog programs annotations cut commit sequential conjunction 
earlier developed formal computation model language framework kernel andorra prolog kap 
added guard operators delimit local execution model notion constraints constraint operations 
notions vijay saraswat uential 
language instance kap framework uses subset guard operators constraint operations may restrict control principles 
example ghc instance kap guard operator commit implicitly constraint operation tell 
akl instance kap guard operators proposed kap implicitly constraint operation tell 
control restricted allow quiet pruning 
instance chosen comparatively insensitive order execution goals 
careful preserve reactive aspects language providing means controlling search 
andorra kernel language section introduce andorra kernel language akl computation model 
thorough treatment akl rules logical properties see 
computation model generalises de nite clause resolution program clauses resolved goal clause 
nested goal expressions built atomic goals conjunction disjunction trees worked rewrite rules 
sections syntax akl de ned computation states nally formal rewrite rules form basis computation model 
language syntactic categories pertaining programs follow 
aggregate 
operator wait cut commit constraint atom formula constraint language de ned constraint system 
constraint system prolog ghc 
constraint atoms equalities terms usual 
constraint atom form called binding 
assume uni cation algorithm available establish consistency conjunction equality constraints consistent reducing conjunction bindings 
program atom atomic formula form di erent variables technical simplicity program atoms distinct variables arguments 
language description completely independent constraint system 
programs head uni cation may translated putting constraints corresponding head uni cation guard body 
conversely programs terms arguments guard body goals may translated putting corresponding constraints goal 
de nition nite sequence guarded clauses head atom guard operator de ning predicate head atom 
speak wait de nitions cut de nitions commit de nitions depending guard operator 
cut commit pruning guard operators 
wait operator delimits local execution discussed 
program nite set de nitions satisfying condition predicate program atom occurring clause program de nition program 
local variables clause variables formal parameters occur head 
akl support kinds aggregate constructs depending constraint system 
derived form bagof construct written prolog 
technical simplicity collected term restricted variable occurring clause goals solutions collected may pre xed existential quanti cation 
restrictions relaxed simple source source transformations 
adopt syntactic convention guard operator omitted clause default position neck clause 
clause de nition explicit guard operator default wait guard operator 
con gurations con gurations nested expressions built atoms components called boxes 
precise logical reading expressions declarative semantics akl 
roughly boxes guarded goals conjunctions boxes choice boxes disjunctions set abstractions 
variables box indexed existentially quanti ed box 
syntax expressions de ned follows 
hand hand hor goali choice guarded bagof goali operator 
goali goali goali goali letters stand sequences goals atom sequence atoms sequence constraint atoms 
sequence may empty 
letter goals sequence atoms guard guarded clause 
letters stand sets variables 
concatenation sequences written comma 
symbol fail denotes empty box 
constraint box conjunction constraint atoms appearing members box 
environment occurrence goal con guration conjunction constraints surrounding boxes 
avariable external box surrounding box 
box contains constraint atoms case may written box quiet solved constraint box restrict environment outside local variables box formally tc tc current theory constraints 
roughly box quiet doesn contain bindings external variables corresponding bindings environment 
computation model computation model transition system con gurations 
kind transition de ned conditional rewrite rule substitutes goal right hand side part con guration matches goal left hand side associated condition satis ed 
local forking rule choice vn rewrites program atom occurring body guarded goal de nition predicate arguments substituted formal parameters local variables th clause replaced variables set sets chosen disjoint set variables rewritten con guration 
determinate promotion rule choice may applied solved 
pruning guard operator required quiet 
nondeterminate promotion rule choice choice promote wait guarded goal solved guard non empty rewrite done stable box 
box rule applicable subgoal box ii box satis es constraint stability condition 
constraint stability condition condition follows possible changes environment applications rules subgoals global con guration lead situation non trivial environment synchronisation cut pruning commit pruning applicable box 
note top level box satis es constraint stability condition environment 
constraint system general constraint stability condition environment subgoal box may restrict variables outside box 
words means box contain bindings variables external box corresponding bindings environment 
cut rule choice choice prunes right guarded goal quiet solved guard commit rule choice choice prunes right left guarded goal quiet solved guard environment synchronisation rule fail fails box constraint ofr incompatible environment box 
guard distribution rule choice choice distributes guard operation branch tree guard guarded goal 
choice elimination rule removes failed guarded goal 
failure propagation rule choice fail choice choice fail fails box contains empty choice box 
de ne aggregating operation bagof applicable constraint system possible form lists 
related bagof prolog di erent attempt enumerate di erent solutions di erent constraints external variables 
solutions required quiet 
allow retain relation external variables 
result solution collecting operation reminiscent list comprehension operation functional languages 
bagof boxes introduced rule 
may rewrite bagof boxes bagof bagof fx bagof fail bagof bagof quiet 
sequence constraints variables local solution new names occurring con guration 
particular variable renamed completes description computation model 
basic logic programming paradigms section show basic logic programming paradigms ghc prolog available akl 
notion programming paradigm loosely de ned matter belief set convincing examples 
convinced adapting programs written languages running akl implementation 
prolog programs require moving output uni cation cut 
ghc programs require modi cation 
parlog programs easy 
subsuming ghc program written ghc subset akl execute exactly ghc 
akl commit operation delayed exists corresponding external binding local binding external variable 
ghc binding operation delayed moment 
di erence computational behaviour binding visible sibling goals guard ghc visible akl 
local bindings detect failure example true 

akl fail ghc suspend 
worse ghc arbitrarily fail suspend depending guard clause executed left right respectively 
true 
sane programmer write code situation appear result deep guard execution result program transformation 
problem immaterial theoretical ghc di erence suspension failure plays essential ole semantics program 
context guard goal failure detecting meta call facility kl problem course serious 
subsuming prolog rst goal section show prolog style execution pure de nite clauses easily achievable akl 
shown translate prolog de nitions contain cut 
shown simple improvement translation pure clauses introduces determinacy detecting dependent style execution andorra model 
way independent parallel execution 
data ow analysis possible translation prolog akl completely automatic lines outlined 
trivial translation pure de nitions rst translation considered completely ignores possibility putting goals guard 
pure de nite clause terms head 
translated true putting equality constraints corresponding head uni cation body 
note arguments akl clause distinct variables guard empty 
assume trivial translation de nitions predicates de nition clauses true 
true 
execution goal proceeds follows 
initial goal box containing goal 
computation begins local forking atomic goal computation resulting guarded goals 
guards guarded goals empty immediately solved 
choice true true choice choice assuming goals candidate clauses box stable 
goal single de ning clause reduced rst similar stable state reached shortly 
computation may proceed nondeterminate promotion body determinate promotion single remaining body 
state achieved computation may proceed promoted bodies branches 
choice choice choice choice obvious style translation leads computation resembles sld resolution basic programming paradigm pure prolog 
translating de nitions cut di erence cut prolog cut akl cut quiet akl 
output produced body part clause ghc 
prolog akl restriction essential parallel execution making cut insensitive order execution goals 
restriction cut akl intuitive logical interpretation see discussion proof 
important corollary sound negation failure available non ground goals akl 
unfortunately restriction pragmatically justi able programming tricks impossible possible prolog 
tricks depend sequential ow control resulting particular instantiation patterns arguments cut procedure speci execution states 
translating prolog language ghc arounds involve noisy pruning workarounds non trivial readily automated 
de nitive solution allowing fully automatic translation add noisy cut new guard operator language 
option kernel andorra prolog framework included prototype implementation akl 
noisy cut disadvantage concurrent quiet cut requires programs properly synchronised avoid problems back propagation values 
mainly intended backward compatibility doing automated translation prolog akl omitted presentation 
di erence prolog akl simplicity allows de nitions clauses kind 
mixed de nitions translated corresponding de nitions usually means adding cut clauses 
rarely prolog de nition 


translated akl de nitions follows true 
true 

true 
backtracking possible 
experience translating prolog programs suggests elegant translations available speci cases 
noted fully general translation cut inside disjunction 
opinion authors construct avoided anyway 
basic andorra model style translation basic andorra model seen computation rule pure de nite clause programs 
states atomic goals candidate clause determinate goals selected rst 
goals may goal selected nondeterminate goal 
appealing property determinate goals may executed parallel extracting implicit dependent parallelism pure programs 
example andorra implementation provides dependent parallel execution sequent symmetry 
akl underlying principle generalised language deep guards embodied stability condition 
basic model available special case 
implications discussed section 
section translation pure de nite clauses akl akl computation model translated programs behave exactly basic andorra model 
clause considered candidate clause goal sense head uni cation primitive test goals fail goal 
putting head uni cation primitive test goals wait operator local execution guard establish clause fails goal 
box failure determinate promotion rule priority nondeterminate promotion execution akl basic andorra model 
pure de nite clause tests body 
translated akl tests body 
suggested scheme 
user de ned tests course counted candidate clause detecting guard goals 
independent style translation known goals independent executed prolog interesting translation scheme possible 
implications related translations programming search problems discussed section 
assume prolog clause 
goals independent 
context restricted parallelism means program uses calls argument goals instantiate 
translation akl enables independent parallel execution su ciently instantiated producers 
true 


putting goals guards extracting output argument goals attempt restrict computation steps applicable 
style translation tools developed restricted parallelism compile time analysis independence making completely automatic 
meta interpretation logic programming languages allow compact meta interpreters written 
meta interpreters come di erent uses 
meta interpreter written akl traditional style 
call meta interpreter behave corresponding direct call 
prove true true 
prove prove prove 
prove prove guard operator wait try wait 
prove guard operator cut try cut 
prove guard operator commit try commit 
try wait clause prove prove 
try cut clause prove prove 
try commit clause prove prove 
guard operator append wait 
clause append true 
clause append append 
try procedures allow nondeterminate generation clauses guards independently restrictions imposed external variables nondeterminate promotion alternatives 
controlling nondeterminism akl subsumes prolog ghc provides new mechanisms controlling search nondeterministic programs 
finite domain constraint techniques examples showing strength andorra model akl particular nite domain constraint programming 
example queens problem 
program adapted nite domain constraints package written entirely akl 
queens 
queens fd domain queens 
xs xs 
nb 
ys nb fd nb nb nb nb ys nb 
chip program rewritten provide generalised forward checking akl delays nondeterminate goals determinate goals execute rst constraints available alternatives tried 
note domain prede ned akl solution provided parameter 
need declare domain variables 
necessary call domain generator 
local execution purpose example show execute goals independently completely collect combined solutions cartesian product manner 
simplicity familiar 
mentioned gained example compared prolog execution 
enumeration costly search problems illustrated functionality useful 
de nition member trivial akl translation 
member true 
member true member 
goal nd common members lists 
member member 
goals executed locally solutions combined cartesian product manner 
complete local execution goal achieved akl putting goal guard part clause shown section 
purpose introduce auxiliary predicate de ned member true 
encapsulates call member guard order execute locally 
previous goal restated 

execution proceeds follows 
initial goal box containing atomic goals 
rewrites done goals parallel 
local forking applied goals 
member goals appear guard wait guarded goal 
choice member true choice member true reasons space details execution guard omitted 
result completed local execution follows 
choice true true true choice true true true state stable 
apply nondeterminate promotion rst choice box promoting local solutions 
choice true true true choice true true true choice true true true grid cartesian product apparent 
applying environment synchronisation choice elimination determinate promotion rules yields nal answers 
hope example provided intuition style local execution available akl 
structured nondeterminism doing local computation sld resolution completely local computation previous section lies spectrum possible organisations nondeterministic computations 
tradeo side danger repeating little done locally advance danger wasting complete failure destroys local done 
done locally parallel execution multi processor 
example shows useful tradeo achieved adapted warren 
program nds common sublists lists 
rst formulation trivial local execution 
sublist 
sublist sublist 
sublist sublist 
sublist sublist 
trivial andorra model style translation local execution limited 
safe execute goal locally rst point execution goal fail interesting way 
happens rst element sublist generated 
achieve ect de nition transformed 
sublist 
sublist su sublist 
su 
su su 
illustrates state reached executing goal 
generation done members lists 
start initial goal sublist sublist get con guration 
choice true cjl sublist ajl sublist sublist sublist choice true sublist ajl sublist sublist sublist subsequent nondeterminate promotion combine solutions local trees producing tree independent alternatives 
ajl sublist sublist sublist sublist sublist sublist formulation share part computation second goal solutions rst goal 
controlling reactive computations ability encapsulate nondeterminate computation reactive computation opens new programming techniques 
encapsulated nondeterminism akl model possible encapsulate process doing nondeterminate search process doing determinate computation way allows processes proceed concurrently fair implementation language 
determinacy enforced encapsulating goal pruning operator bagof 
multi way merge constant delay realises multi way merger constant delay uses encapsulated nondeterminism 
called initial input stream initial output stream 
input stream split binding term split 
merger cooperating goals generator detects stream merged instantiated enters bagof stream server server instantiated stream removes message feeds rest generator splits stream feeds new streams generator closes stream 
merger server bagof generator 
generator procedure enters streams nondeterministic alternative solutions bagof goal 
requires streams instantiated bagof 
generator generator 
generator stream 
generator generator 
stream 
stream 
stream split 
server procedure expects stream instantiated streams bagof goal 
apart dealing mentioned way keeps track number merged streams closes output stream terminates bagof goal remain 
server server 
server split server 
server server 
server 
binding clause generator fail bagof terminated 
discussion akl implemented results far promising 
current implementation covers described 
akl environment public domain code originally written prolog keefe minor modi cations 
nondeterministic benchmarks easy adapt 
committed choice examples run modi cations simple changes syntax 
compared high performance prolog implementation machine emulated sicstus prolog current implementation executes deterministic code times slower 
experiments show guard optimisation bring factor 
machine substantially cient wam executing deterministic code 
expected performance close wam implementation prolog 
johan andorra group sics members esprit project especially david warren university bristol manuel hermenegildo university madrid contributions 
steve gregory 
non deterministic parallel logic programming 
proceedings iclp 
mit press 
francisco manuel hermenegildo 
translation algorithm prolog andorra kernel language 
internal report january 
santos costa david warren rong yang 
andorra engine parallel implementation basic andorra model 
proceedings iclp 
mit press 

formal aspects andorra kernel language research report sics may 
seif haridi brand 
andorra prolog integration prolog committed choice languages 
proceedings fgcs 
seif haridi janson 
kernel andorra prolog computation model 
proceedings iclp 
mit press 
vijay saraswat 
concurrent constraint programming languages 
phd thesis carnegie mellon university january 
pascal van hentenryck 
constraint satisfaction logic programming 
mit press 
rong yang 
prolog parallel logic langauge exclusive relation 
proceedings iclp 
mit press 
