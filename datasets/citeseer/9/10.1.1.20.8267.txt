expressing preferences default logic james delgrande school computing science simon fraser university burnaby canada jim cs sfu ca torsten schaub institut fur informatik universitat potsdam postfach potsdam germany torsten cs uni potsdam de march address problem reasoning preferences properties outcomes desiderata reiter default logic 
preferences expressed ordered default theory consisting default rules world knowledge ordering reflecting preference default rules 
contrast previous area rely prioritised versions default logic transform ordered default theory second standard default theory preferences respected defaults applied prescribed order 
translation accomplished naming defaults may default rule theory 
elaboration approach allow ordered default theory preference information specified default theory 
may specify preferences hold default particular context give preferences preferences 
approach essentially different orderings interact theory need rely metatheoretic characterisations 
immediately existing default logic theorem provers implementation 
theoretical point view shows explicit representation priorities defaults adds expressibility default logic 
keywords nonmonotonic reasoning default logic knowledge representation preference handling affiliated simon fraser university burnaby canada 
notion preference priority commonsense reasoning pervasive 
example scheduling deadlines may simultaneously satisfiable configuration various goals may simultaneously met 
preferences deadlines goals may allow acceptable non optimal solution 
decision making preferences clearly play major role 
buying car example may various criteria mind inexpensive safe fast desiderata preferences allow come appropriate compromise solution 
difficult envisage situations going simple preferences 
may preferences preferences 
example legal reasoning laws may apply default laws may conflict 
instance newer laws usually priority ones laws higher authority priority laws lower authority 
case conflict authority preference takes priority recency preference 
illustrates may preference orderings orderings different criteria recency authority specificity need preferences come global preferred outcome 
goals 
general framework default logic reiter preferences may expressed 
wide variety approaches proposed dealing preference sections framework provides uniform setting preference orderings expressed compared 
second number approaches preference framework 
considering preference orderings may encoded default logic address case default theory consists world knowledge set default rules external preference information default rules 
show default theory translated second theory preference information incorporated theory 
translation obtain theory standard default logic requiring machinery external default logic previous approaches 
generalise approach preferences may appear arbitrarily part default theory specifically preferences default rules may naming default rules part default rule 
allows specification preferences preferences preferences holding particular context preferences holding default 
allows axiomatise theory different preferences orderings interact 
consider elaborations approaches 
approaches formalise prescriptive notion preference ordering specifies order default rules applied 
contrast descriptive notion preference order reflects desirability rule applied 
previous approaches generally added machinery extant approach nonmonotonic reasoning 
contrast remain framework standard default logic building scheme top default logic 
advantages 
foremost approach flexible 
stated axiomatise preference order interacts knowledge including default information preference orders 
integrate different orderings setting arbitrary relationships meta orderings 
second easier compare differing approaches handling orderings 
third compiling preferences default logic standard machinery default logic obtain insight notion preference orderings 
instance doesn notion preference free axiomatise framework 
example implicitly show explicit priorities provide real increase expressibility default logic 
final point particularly important nonmonotonic reasoning systems find application practical reasoning systems explicitly dealing preferences may seen step developing knowledge engineering methods applying default reasoning technologies reasoning systems 
lastly exist theorem provers default logic 
consequently approach immediately incorporated prover 
approach implemented syntactic restriction extended logic programming implementation serves front logic programming systems dlv smodels 
default logic ordered default logic default logic reiter augments classical logic default rules form ff fi fi fl part deal singular defaults 
marek truszczy nski show default rule transformed set defaults non singular rule section notational convenience 
singular rule normal fi equivalent fl semi normal fi implies fl 
denote prerequisite ff default ffi prereq ffi justification fi justif ffi consequent fl conseq ffi 
accordingly prereq set prerequisites default rules justif conseq defined analogously 
empty components prerequisite justifications assumed tautological 
defaults unbound variables taken stand corresponding instances 
set default rules set formulas form default theory may induce single multiple extensions way 
definition default theory set formulas 
define gd ff fi fi fl fi fi fi ff fi fi th ffi ffi gd extension extension represents possible set beliefs world hand 
procedure constructive appears specification gd define gd gd set default rules generating extension enumeration hffi default rules grounded set formulas conseq fffi ffi gamma prereq ffi 
adding preferences default rules default theory usually extended ordering set default rules 
analogy baader hollunder brewka ordered default theory 
finite set default rules finite set formulas strict partial order theta default rules 
binary irreflexive transitive relation simplicity development assume existence default ffi rule ffi ffi ffi ffi ffi 
gives trivial maximally preferred default applicable 
default preference 
section discusses preference orderings general 
employ default logic discussion independent particular approach nonmonotonic reasoning 
assume ordered default theory 
write ff fi fl ff fi fl express preference defaults 
informally intent higher ranked default applied considered lower ranked default 
notion preference defaults broadly construed general restrictions place default rules preference ordering 
consider example defaults speak english qu eb speak french residents north qu ebec speak 
preference ordering expressed follows english english que french french resident north qu ebec didn speak reasonable assume person spoke french didn speak french english 
relation specificity subsumption default rule prerequisites 
consider variation north qu ebec language french english resulting preference ordering follows 
english english que french french specificity order implied rules prerequisites 
preferences need antecedent information 
prefers say car red green expressed green green red red general case defaults relation priori preference relation 
preferences may apply preferences 
legal reasoning example instance 
may different preferences different contexts preferences default 
may encounter quite variety different preferences reasoning process 
address possibilities default logic 
novel feature approach preferences dealt extant framework default logic 
introducing machinery application default rules may tightly controlled 
machinery show preference ordering may compiled standard default theory defaults applied ordering 
consequently freedom flexibility axiomatise theory different orderings interact apply argued delgrande schaub notion inheritance properties distinct preference 
default property inheritance ordering defaults reflects relation specificity default rule prerequisites 
informally conflicting defaults determines specific respect rule antecedents defaults candidates application 
consider example defaults concerning primary means locomotion animals normally walk birds normally fly penguins normally swim animal walk walk bird fly fly penguin swim swim learn thing penguin bird animal want apply highest ranked default possible highest ranked default 
significantly penguins swim default blocked say penguin question fear water don try apply default see fly 
interests lie solely preference see delgrande schaub encoding inheritance properties 
approaches dealing inheritance properties touretzky pearl geffner pearl specificity determined implicitly emerging property underlying formal system 
reiter etherington reiter delgrande schaub addressed adding specificity information default logic 
boutilier brewka baader hollunder consider adding preferences default logic mccarthy lifschitz grosof brewka zhang foo brewka eiter circumscription logic programming respectively 
return approaches section developed framework 
prescriptive descriptive preference ways preference order may interpreted 
prescriptive interpretation idea order defaults specifies order defaults applied 
applies possible preferred default preferred 
approach somewhat algorithmic feel 
descriptive interpretation preference order represents ranking desired outcomes desirable preferred situation preferred default applied 
distinction interpretations illustrated example brewka eiter assume initial world knowledge 
prescriptive interpretation fail apply preferred default viz 
antecedent isn provable 
expect apply lesser preferred defaults giving extension containing fa bg 
descriptive interpretation observe applying papers include examples best interpreted dealing property inheritance arguably fact implement distinct notion preference described 
isn intended cut distinction useful classification 
example brewka eiter contains elements 
instance obtained baader hollunder brewka marek truszczy nski approach section yields preferred extension 
preferred default preferred default applied yields extension containing fa bg 
led researchers advocate systems descriptive interpretation 
contrast advocate prescriptive interpretation 
elaborate section worth summarising reasons favouring approach 
descriptive interpretation require obvious implementation meta level approach failing expensive encoding object level section 
due fact wants find scenario extension preferred default applied enabled application arbitrary defaults 
contrast prescriptive approach may generate extension guaranteed represents scenario preferred default applied applied 
second interesting ordered default theories prescriptive interpretation guarantee existence preferred extension generated strictly iterative process see theorem 
reason believe prescriptive interpretation generally efficient descriptive interpretation respective complexity classes may specific instances guaranteed efficient 
addition descriptive interpretation uses meta level approach different preference orderings choosing preferences default generalities discussed determined meta level 
contrast prescriptive approach axiomatise theory want different preference orders interact 
lastly prescriptive interpretation arguably comes representational force allows tighter characterisation domain 
illustrated example 
prescriptive interpretation appears give curious result 
argue problem prescriptive interpretation se encoding example 
default highest priority default applied prerequisite proved way come applying default considered higher priority enables application default 
second situation applied 
default may pragmatically important theory inference structure default logic applied order stipulates 
analogy may proving theorem theorem analogy may important lemmas analogy may important way lemmas proved theorem proved 
argue syntactically formed questionable meaning 
generally prescriptive interpretation forces knowledge base designer explicit things applied order 
descriptive interpretation hand simply gives wish list preferences may may meaningful 
return elaborate points section compare approach 
grounded enumeration generating defaults definition applied static preferences defaults show ordered default theories translated standard default theories 
strategy add sufficient tags default rule theory enable control rule application 
comparable usage abnormality predicates circumscription mccarthy 
ordered default theory 
translated regular default theory explicit preferences compiled associating unique name default rule 
done extending original language set constants bijective mapping write ffi ffi abbreviate ffi ease notation 
default rule ffi name write ffi render naming explicit 
encode fact deal finite set distinct default rules adopt unique names assumption domain closure assumption respect name set fn add axioms name nm convenience write name oe 
names allows expression preference relations default rules object language 
assert default ff fi fl preferred ff fi fl oe oe new predicate object language 
discussions preference relations write ffi ffi ff fi fl ff fi fl show preference defaults kept mind expressions expressions default theory oe expressions default theory 
ffi ffi want ensure ffi applied ffi applied inapplicable 
translating default rules rule application explicitly controlled 
purpose need able detect rule applied rule blocked second control application rule antecedent conditions 
default rule ff fi fl cases applied may antecedent known true negation consistent may justification consistent negation known true 
detecting case introduce new special purpose predicate bl delta 
similarly introduce special purpose predicate ap delta detect case rule applied 
controlling application rule introduce predicate ok delta 
default rule ffi ff fi fl mapped ff ok ffi fi fl ap ffi ok ffi ff bl ffi fi ok ffi bl ffi rules abbreviated ffi ffi ffi respectively 
ffi image original rule ffi rules ffi ffi capture aforementioned situation non applicability 
mccarthy suggested naming defaults set aspect functions 
see brewka theorist poole uses atomic propositions name defaults 
wish exclude case ffi ffi gdm definition 
rules applied ok ffi true 
ok delta new predicate symbol expressly true order potentially enable application rules image translation 
ok ffi true rule translation may potentially applied 
rule applied indicated assertion ap ffi 
rules give conditions original rule inapplicable negation original antecedent ff consistent extension justification fi known false case bl ffi concluded 
translation says defaults considered ordering 
ffi ffi fully control order rule application ffi applied ap true known inapplicable bl true ok apply ffi ap bl oe ok adjusted allow fact rules higher priority ffi idea delay consideration preferred rules applicability question settled respective higher ranked rules 
account obtain translation mapping ordered default theories language standard default theories language obtained extending new predicates symbols delta oe delta ok delta bl delta ap delta set associated default names definition ordered default theory 
set default names fn ffi ffi dg define fi flap ok ff bl bl fi fi fi ff fi fl oe oe oe oe fn ffi oe ffi ffi ffi fok oe oe bl ap oe ok contains prior world knowledge assertions managing priority order defaults 
part oe specifies oe predicate positive instances mirror strict partial order 
ok asserts ok apply maximally preferred trivial default 
third formula oe controls application defaults derive ok oe ap bl true 
axiom allows derive ok indicating ffi may potentially applied ffi ffi ffi ffi applied applied 
gives necessary sufficient conditions rendering ffi potentially applicable 
ffi ffi oe oe formula oe properly able conclude extension oe 
addressed adding default rule oe renders resulting theory complete respect priority statements 
resulting extensions oe oe ffi oe 
rule ffi ffi definition ordered default theories 
strict partial order includes transitive closure oe oe note translation results manageable increase size default theory 
ordered theory translation constant factor larger 
example consider defaults 
obtain ok ap ok bl ok bl analogously ffi 
ffi ffi ffi obtain oe oe oe oe 
part oe oe get oe remaining combinations instructive verify ok ap bl oe ok ap bl ap bl oe ok obtained iterations definition see get taken account followed illustration provide traces extension constructions pseudo iterative specification definition fa obtain trace left column 
trace demonstrates successive ok literals allows navigating consecutive consideration rules preferences 
delay application individual rules due fact definition deductive closure determined consider contains oe oe corresponding trace middle column 
get ffi gd ffi gd bl ap suppose extension containing opposed obtain ok putative extension check consistency ffi inapplicable 
ffi inapplicable belongs facts 
ffi applicable derivable belongs putative extension 
derive ap bl pseudo iterative process interrupted derive ok belong behaviour nicely reflects fact rules precise justifications blocked higher ranked rules application lower ranked rules delayed applicability settled predecessors 
consider case prerequisite second default rule missing 
corresponding trace right column 
opposed previous scenarios get ffi gd assumes count default oe single default 
gd ok ok ffi ap ap ok ok ffi ap ap ok ok ffi ap ap ok ok ffi ap ap gd ok oe oe ok ffi ap ap ok ok ffi ap ap ok ok ffi bl ok ok ffi ap ap gd ok ok ffi ap ap ok ok ffi ap ap ok ffi bl ok ok ffi ap ap tracing pseudo iterative definition 
theorem summarises major technical properties approach demonstrate rules applied desired order theorem consistent extension ordered default theory 
ffi ffi 
ffi oe ffi iff ffi oe ffi 
ok ffi 
ap ffi iff bl ffi 
ok ffi prereq ffi justif ffi implies ap ffi max 
ok ffi prereq ffi implies bl ffi 
ok ffi justif ffi implies bl ffi 
ok ffi gamma ok ffi implies ap ffi bl ffi theorem guarantees consider default rules theorem reflects fact extensions contain complete knowledge application rules procedural propositions theorem shows approach allows detect blockage due non derivability prerequisite immediately having ok default hand 
remaining properties provide detailed account technical intuitions underlying approach default logics consider default rules consideration rules lower preference 
precise theorem adopting rule perspective 
extension generating default rules gd trivially ffi gd iff ap ffi ffi gd ffi gd iff bl ffi theorem consistent extension ordered default theory 
gd defined wrt 
ffi 
ffi gd iff ffi gd ffi gd default rules ffi ffi ffi ffi 
ffi ffi ffi gd implies ffi ffi ffi gd 
ffi gd ffi gd ffi gd implies ffi gd ffi gd ffi gd 
ffi gd ffi gd ffi gd implies ffi gd ffi gd ffi gd gamma 
series results focuses successive application lower higher ranked rules 
observable traces minimum delay rules stemming ffi originated ffi due formation deductive closure definition 
important consequence series results translation provides full control default application 
semantical underpinnings far described approach specific technical terms question general properties arises 
global systematic view machinery put forward translation obtainable combining previously results theorem 
ordered default theory set formulas 
consistent extension grounded enumerations hi gd ffi ffi ffi ffi ffi ffi fa grounded enumeration extension translated defaults conforms ordering initial set defaults 
turns translation amounts selecting extensions original default theory accord provided ordering 
expressed way 
definition default theory theta strict partial order 
extension preserving exists grounded enumeration hffi gd ffi gd 
ffi ffi 
ffi ffi prereq ffi conseq fffi ffi gamma justif ffi 
perspective ffi conditions distinguish absent rules 
case ordering prescribes preferred rule ffi applied ffi absence tolerable prerequisite derivable justification refuted higher ranked rules 
case applicability issue settled higher ranked default rules addressable lower ranked rules 
conception prescriptive preference mirrored translation ordered theories regular theories 
theorem default theory theta strict partial order 
set formulas 
preserving extension iff extension 
notion preservation provides semantics approach may seen general semantical account prescriptive preferences defeasible rules 
theorem clear extension translated default theory regular extension underlying unordered default theory cases ffi ffi apply 
corollary 
ordered default theory extension extension 
approach equivalent modulo original language standard default logic preferences corollary default theory set formulas extension iff extension 
existence extensions theorems expect ordered default theories enjoy properties standard default logic 
case important exception normal ordered default theories guarantee existence extensions 
example image ordered default theory translation gamma fn fffi ffi delta extension 
informally problem preference ffi ffi default ffi applicable applied ffi applicable 
ordering implicit form defaults world knowledge implicit ordering contradicted assertion ffi ffi surprisingly extension 
detail translation gives things information ok bap cap ok bl ap bl oe ok extension translated theory definition fact ok ok third default may potentially applied 
assumption leads immediate contradiction block application third default default applicable third default applicable conclude bl ok default applicable derive contradiction 
declarative point view see single regular extension viz 
th fb cg generated grounded sequence hffi ffi extension preserving sequence generating default rules violates preference ordering 
conversely sequence compatible hffi ffi grounded legitimate 
faced explicit preference order incompatible implicit application order 
example implicit order induced inferential relation default rule consequent prerequisite 
second source implicit ordering blocking rule 
rule consequent may imply negation justification 
see consider theory gamma fn fffi ffi delta precise violates condition definition 
theory preserving extension 
see note single regular extension viz 
th fbg generated hffi sequence violates condition definition higher ranked rule ffi justifiable absence lower ranked rule ffi way address problem replace rigid preferences preferences apply default 
approach permit detailed section 
suggest incoherent sense lack extension indicates problem specification original theory 
notion precise relating approach papadimitriou characterises class default theories extensions 
papadimitriou graph constructed default theory default rules nodes directed edges reflect positive negative influences rule 
main result default theory class guaranteed extension ordering conflict edge ordered default theory extension 
assume remainder section dealing propositional default theories 
original theory translated theory propositional formulas 
atomic formulas ok oe regarded propositional atoms 
assume finite set default rules finite set instances 
assume formulas expressed conjunctive normal form 
sure axiomatisation definition loses interest instance partial order oe set unrelated atomic sentences point remains characterise ordered theories having extensions 
papadimitriou results 
semi normal default theory define literal graph graph nodes consisting literals theory directed edge appear clause consequent indicates path 
intuitively graph indicates literals may contribute proof context default theory 
graph call dependency graph defined vertices default rules disjoint 
informally ffi ffi application ffi may help bring application ffi ffi ffi application ffi may help prevent application ffi formally 
ffi ffi literal appearing positively consequent ffi literal appearing positively prerequisite ffi 

ffi ffi literal appearing positively consequent ffi literal appearing negatively justification consequent ffi 
observe information provided underlying distinction amounts formalisation implicit application orderings discussed different sources 
edges assigned weight edges assigned weight 
default theory cycles total weight cycles odd number edges 
main result says default theory extension 
result obtain theorem 
propositional semi normal ordered default theory associated dependency graph cycle ffi ffi ffi ffi cycle extension 
ffi ffi ffi ffi new cycles incorporating elements 
dependency graph reflects dependencies default rules specifically rules may help block activate 
papadimitriou show theories obeying certain constraints extension show ordered theory ordering doesn contradict constraints extension 
precise consider theories incoherent 
observe underlying default theories 
standard theory underlying get dependency graph arc set ffi ffi preference ffi ffi obtain arc set ffi ffi includes new cycle formed ffi ffi ffi ffi 
consider reflected translated theory arc set dependency graph translated default theory proof theorem shows arcs sense redundant contribute cycle 
arcs crucial importance translated theory 
get ok bl ok bap resulting bl ok literal graph translated theory reflecting preference ffi ffi get ok bap ok bl virtue occurrences consequent negation justification rules 
edges form odd cycle cycle weight applicability condition papadimitriou fails 
note reflects earlier intuitions 
arc result preference ffi ffi second results possibility ffi activating ffi similar happens 
underlying standard theory get dependency graph arc set ffi ffi incorporating arc ffi ffi induced ffi ffi gives extended arc set possessing new cycle 
fact translated theory get edges ok bap ok cap ok cap ok bap yielding odd cycle 
edge result ffi canceling ffi second reflects preference ffi ffi useful consequence follows 
proof independent papadimitriou result relies fact normal default theories extensions 
pred set predicate symbols occurring set formulas theorem 
normal ordered default theory pred prereq pred conseq pred pred conseq extension 
class default theories default independent rule prerequisites represent new default information 
second condition excludes expression dependencies theory atomic sentences acceptable preference fp qg 
note proofs theorems show corollary extension purely iterative process 
select cases extensions ordered default theories may relatively efficiently generated 
dynamic preferences defaults consider situations presence preferences context dependent 
deal standard default theories language including predicate oe expressing preference relation means default names 
order keep finite domain closure axiom restrict finite set default rules correspondence finite name set preferences available dynamically inferences lack priori complete information ordering predicate oe 
priori complete information available rigid case positive instances explicit order rules closed world default negative instances 
leads problem allow positive preferences default 
consider preference intuitively preference information default applicable 
closed world default preferences oe asserts known derived preference rules preference exists 
instance oe simply defaults run risk potentially having unwanted extension applies obviously solve problem asserting approach circular 
address issue adding new binary predicate sigma indicating defaults ffi ffi ffi oe ffi ffi oe ffi extension add rule variables ranging default names oe oe sigma rule accounts situations oe oe derivable 
names time rule apply oe oe sigma introduced predicate time sigma default theory information defaults preference relation 
consider standard default theories language including set default names propositions formed binary predicate oe applied variables default names mapped theories language obtained extending new predicate symbols delta sigma delta ok delta bl delta ap delta definition default theory set default names fn ffi ffi dg define fi flap ok ff bl bl fi fi fi ff fi fl oe oe oe oe oe xyz oe oe oe oe 
oe oe 
fok phi gamma sigma oe oe bl ap delta oe ok psi contrast definition may contain preference information expressed oe applied default names 
axioms oe account information implicitly provided ordered default theories rigid case 
axiom straightforward extension rigid case accounting information provided default rule oe observe ordered theory translation constant factor larger 
note theorem theorem carry general case theorem 
get ffi oe ffi ffi oe ffi ffi sigma ffi fact ordered default theories treated way basic general approach different augmented languages theorem 
ordered default theory extension extension fn ffi oe ffi ffi ffi vice versa 
corollary result implies dynamic approach yields regular extensions modulo original language contain occurrence oe theorem default theory language excluding oe symbols set formulas extension iff extension 
notion preservation directly applicable dynamic case 
adequate counterpart regular extension original theory preference information fully developed extensions image translation 
provide analogous criterion invariantly satisfied extensions obtained translation theorem ordered default theory set formulas 
consistent extension grounded enumerations hi gd ffi ffi ffi oe ffi ffi ffi fa argued sensible correspondence regular extensions dynamic setting preferences original resulting theory 
counterpart corollary dynamic case 
advantage dynamic preferences static ones allow specifying context sensitive preferences context spanned encompassing extension 
fact dynamic setting necessarily furnish softer preferences obtainable static case 
dynamic preferences provide additional means canceling preferences certain cases 
clearly theory fn oen oen yields single extension containing adding oe fact results single extension adding default rule oen oen gives rise extensions important thing note additions gave rise alternative contexts cases oe derivable overriding way included alternative extension 
default alternative provided dynamic preferences rigid static ones 
see reconsider theories dynamic setting fn oen oen fn oen oen static case images theories possess extensions 
simply way refute preference imposed third default rule 
possible get unwanted preferences argued start section motivating oe clear wants suspend dynamic preferences certain contexts provide specification contexts 
way doing equip rules dynamic preferences predicates playing role abnormality predicates circumscription mccarthy 
implementing option examples replace yx nx nx nx ko nx supply corresponding blocking policy comparable circumscription policies 
case fix problem means ap ap oe ko canceling preferences non conflicting rules 
alternately adopt different strategy putting conseq ffi oe prereq ffi oe ko axiom ranks derivability preference see section 
similarly rank blockage preference addressing lack extensions conseq ffi oe justif ffi oe ko course axiomatic approach leaves room policies 
examples illustrate approach consider extended examples taken literature 
junker jim jane habits 
normally jim jane go attraction go evening 

jim prefers theatre night club 

jane prefers night club theatre 

jim invites jane respects preferences vice versa 

normally jim invites jane 

exception 
saturday 

exception 
jim birthday jane invites jim 
information conclude jim jane go night club 
learn jim birthday revise conclude go theatre 
day question saturday 
go attractions 
news tells theatre closed 
conclude go night club 
adapt junker modelling follows theatre goto theatre closed theatre goto theatre night club goto night club closed night club goto night club goto theatre goto night club party night goto theatre goto night club resemblance existing persons accidental accord intention authors 
jane invites jim jane theatre oe night club theatre oe night club jim invites jane jim night club oe theatre night club oe theatre invitation invites jim jane invites jim jane saturday oe party night birthday jim oe invites jane jim invites jim jane oe invites jane jim closed theatre oe goto theatre goto oe oe goto oe oe invitation recall simply abbreviation 
choice go formalised means default rules ffi theatre ffi night club spots supposed open known closed 
observe ffi jane ffi jim model combination statements 

respectively 
ffi jane tells jane preferences hold jim inviting 
junker give preference rules ffi ffi invitation talking go ffi theatre ffi night club simply indicating go 
easy see default theory gamma gamma extension standard default logic containing goto theatre containing goto night club including 
clearly application rules subject preferences extension contain ap ap jane ap jim ap invitation different rules application depends context spanned encompassing extension 
rules ffi theatre ffi night club depend applicability ffi ffi invitation interdependency subject presence corresponding preference literals theatre sigma night club theatre oe night club case ffi theatre reflected influence vice versa 
formulas common extension construction processes theatre sigma night club theatre oe night club oe ap night club bl night club ap bl ap invitation bl invitation oe ok theatre night club sigma theatre night club oe theatre oe ap theatre bl theatre ap bl ap invitation bl invitation oe ok night club image theory leads extension containing invites jim jane theatre oe night club night club oe theatre 
ap invitation ap get ok night club ap night club bl night club oe ok theatre 
result obtain goto night club goto theatre 
learn happens jim birthday adding birthday jim get extension containing invites jane jim night club oe theatre theatre oe night club 
analogously obtain goto theatre goto night club 
learning furthermore jim birthday falls saturday real party night 
fact conclude saturday party night blocks default rule ffi extension containing goto theatre goto night club 
note concluded presence invites jane jim night club oe theatre news tells theatre closed closed theatre blocks default rule ffi theatre conclude goto night club despite presence night club oe theatre consider example gordon discussed brewka person wants find security interest certain ship perfected legally valid 
person possession ship filed financing statement 
code ucc security interest perfected possession ship 
federal ship mortgage act sma states security interest ship may perfected filing financing statement 
ucc sma applicable question takes precedence 
legal principles resolving conflicts 
lex posterior gives precedence newer laws ucc sma 
lex superior gives precedence laws supported higher authority sma higher authority federal law 
apart ffi obtain default rules ucc possession perfected perfected sma ship perfected perfected lp newer oe oe ls oe oe preserve finiteness restrict attention name set fn flp ls corresponding default instances 
facts possession ship newer ucc sma sma ucc lp oe ls specification obtain single extension perfected ucc oe 
obtain xy ok ls 
get ok ls ucc sma bl ls ucc sma ap ls ucc sma oe ok lp sma ucc instances axioms eliminated deriving sigma 
conclude ls ucc sma ucc oe sma 
blocks lp sma ucc justification sma oe ucc refuted 
sma sigma ucc yielding ok sma subsequently perfected brewka solves problem generating entire extensions sma oe perfected sma oe ucc oe perfected ucc oe 
second step rules verify certain priority criterion 
remaining extension obtained approach 
extensions axiomatic approach preferences offers highly flexible framework specifying preferences 
instance fine grained approach distinguish source blockage replacing ffi ffi ok ffi ff bl ffi fi ok ffi bl ffi respectively 
accordingly obtain oe axiom oe oe bl bl ap oe ok encoding delgrande schaub argue property inheritance comprises mechanism distinct preference 
different substantive extensions discussed remainder section 
expressing generalised preferences important generalisation notion preference expressed section 
encode ok apply rule just greater rules blocked failure prove antecedent 
develop mechanism take far primary interest preference 
generalised preference preferences ffi ffi apply ffi possible apply ffi gamma possible continue fashion fixed defaults applied 
example student wishes take courses possible courses provides list preferences courses 
important subcases corresponding case maximum default applied 
second case attempts apply default 
predicates bl delta ap delta notably ko delta straightforward matter assert maximum default rules priority order applied 
modify definition ffi cf 
setting ffi ff ok ffi fi ko ffi fl ap ffi addition add axiom initial set facts oe ap oe oe ko abbreviate axiom states distinct rules applied remaining rules ko ed 
coherence furthermore convenient supply statement effect rules considered turn knocked 
done ko oe bl 
illustration consider student wishes take courses preference ordering available courses 
depending prerequisites courses open aren fully subscribed student preferences satisfied far possible 
variable students courses get prerequisite open canceled subscribe student preferences preferred course wants avoid prefers isn open anymore prefers smith giving course oe oe open oe oe lecturer smith oec oec assume student fulfills prerequisites course courses fully subscribed 
fortunately smith sabbatical 
fc get oe ap ap ap oe oe ko applying dynamic translation modifications corresponding default theory yields iterations definition ok ap bl oe ok ap bl ap bl oe ok ap bl ap bl ap bl oe ok 
account constraints get taken followed result obtain extensions containing containing contains extension containing due oe turned get single extension containing additionally canceled get student obliged take turns smith keeps despite sabbatical faced alternatives preferences sets defaults preferences may apply sets defaults 
consider example preferences buying car specifically situation ranks price safety features safety features power safety features power ranked price 
obvious extension preference sets defaults write phi psi phi psi phi psi phi psi intuitively desiderata satisfied es apply defaults highest ranked set conclude met 
approach described delgrande schaub related approach implementation framework extended logic programs described delgrande omit details methodology static dynamic preferences 
set approach default theory ordering sets defaults 
take ordered theory translate standard default theory 
consider general assertion informally prefer application set say applicable member defaults inapplicable members inapplicable 
consequently consider defaults applicable default inapplicable 
extend set names addition names individual default rules names sets rules mentioned ordering sets sure naive encoding see brewka gordon realistic formalisation 
note simply replace set defaults default consisting conjunction respective prerequisites justifications consequents defaults set doesn allow rule interactions 
example scheme set phi psi replaced meaningless default ps ps 
roughly speaking set name ok apply set rules ok apply individual rules set 
ap true rule ffi set set flagged applied ap 
bl true rule ffi set set flagged bl 
set greater set applied blocked ok apply set 
problem side effects naive implementation approach 
assume example jointly met 
expect single extension containing naive implementation try apply defaults highest ranked set 
applying default prove case applied vice versa 
find topmost nontrivial set isn applicable 
finding defaults highest ranked set applied want apply default lead incorrect result instance set applied try apply default set viz 
successful couldn apply default set viz 
incorrectly obtain extension containing fp 
determining defaults set applied avoid side effect defaults fact applied 
detecting set defaults going blocked 
occur just negation prerequisite consistent final extension set consequents denies justification default set 
cases set blocked side effects propagate lower ranked sets 
consult delgrande schaub details 
related section argued single notion treating prioritised information 
default logic argued reiter etherington reiter delgrande schaub address property inheritance exemplified example 
particular approaches idea resolving conflicts appeal specificity information 
non conflicting rules may produce inappropriate results preferences 
instance take expects single extension containing approaches replace rule respectively applicable providing preference descriptive prescriptive interpretations 
case wish list intent way highest ranked defaults applied 
case ordering reflects order defaults applied 
rintanen addresses descriptive preference orders normal default theories despite title examples indicate deals property inheritance 
order extensions defined follows 
default rule applied extension just extension preferred iff ffi applied ffi preferred ffi ffi applied applied addresses different notion preference worth noting sources inefficiency rintanen approach 
preference extensions terms total order preferences rules consequently partial order rules total orders preserve original partial order generated 
second extensions generated preferred extension filtering mechanism 
consider ordered theory just preference 
clearly number total orders resulting partial order exponential number instances similarly number extensions unordered theory exponential number instances 
contrast approach single extension produced translated theory constant factor larger original 
prescriptive approaches baader hollunder brewka prioritised variants default logic iterative specification extension modified 
default applicable iteration step cf 
definition greater default applicable 
primary difference approaches rests number defaults applicable step 
brewka allows applying single default maximal respect total extension baader hollunder allow applying maximal defaults step 
contrast translate priorities standard default theories 
distinguishing example consider normal default rules ffi ffi ffi ffi ffi ffi taken baader hollunder 
facts baader hollunder obtain extension containing fa cg curiously brewka obtains additional extension containing fa cg approach resultant default theory yields extension containing fa cg approach yields result baader hollunder 
second example baader hollunder consider rules ffi ffi ffi ffi ffi ffi ffi ffi baader hollunder show brewka approach extensions obtained containing fa bg containing bg additional extension obtained baader hollunder approach containing fa bg approach yields extensions 
opposed previous example approach yields result brewka approach 
observe examples approach yields fewer arguably intuitive extensions 
brewka baader hollunder deal context sensitive preferences sets preferences 
addition approach translate preferences standard default theories 
junker addresses static dynamic preferences restricted framework roughly corresponds ordered prerequisite free normal default theories 
preliminary report brewka gordon consider sets preferences default logic 
authors reverse order 
brewka eiter address static preference extended logic programs extended default logic brewka eiter common previous brewka eiter partial order rule base define preference respect total orders conform original partial order 
answer sets extensions respectively generated preferred answer sets extensions selected subsequently 
contrast approach deal original partial order translated object theory 
preferred extensions produced approach need meta level filtering extensions 
result relating approach brewka eiter instance framework captured translation theorem 
normal prerequisite free ordered default theory extension extension 
brewka eiter vice versa 
see result extend prerequisite free theories consider gamma phi psi fffi ffi jg delta theory single regular extension containing observe theory obtained applying translation yields preferred extension due interaction blockage preference described section 
differs approach brewka eiter accept extension preferred 
done imposing additional fixed point condition ordered default theory 
regular extension established respect theory fffi conseq ffi justif ffi turns theory gamma phi psi fffi ffi delta preferred extension contains see theorem 
theorem extend normal default theories 
observe yields preferred extension th fa bg approach brewka eiter due interaction groundedness preference 
interaction avoided brewka eiter fixed point construction eliminating prerequisites belong extension eliminating rules prerequisites belong extension 
initial approach captured seen refining set extensions obtained brewka eiter theorem 
ordered default theory extension preferred extension 
brewka eiter note theory illustrate interaction preferences blockage relations yields preferred extension approach brewka eiter see refinement sense consider example due baader hollunder penguin fly fly bird winged winged winged fly fly penguin bird bird fffi ffi theory single extension approach containing fly bird winged approach brewka eiter yields additional extension fly 
discussion dominated comparison specific translation approach brewka eiter 
fact framework general express strategy preference handling proposed brewka eiter 
instance framework described delgrande omitted brevity 
lastly note brewka eiter principles view provide meaning postulates term preference satisfied approach dealing preference 
show delgrande approach satisfies principles 
various approaches preferences extended logic programming central role played approach gelfond son avoids defining new nonmonotonic formalism order cope preference information 
gelfond son introduce special purpose language directly encoding preferences logic programming setting 
framework approach offers variety different preference handling instances 
gelfond son pursue level approach reifying rules preferences 
example rule terms logic programming expressed formula reification corresponding term inside holds predicate respectively default name rule 
semantics domain description defined terms set domain independent rules predicates holds 
rules regarded meta interpreter domain description 
interestingly approach notion defeat justifications contrast order preserving consideration rules approach 
specific strategy elaborated gelfond son differs ones considered stops application default defaults conflict default applicable 
gelfond son 
consider strategies companion delgrande schaub 
detecting conflicts approach necessities extra conflict indicating predicate 
state explicitly conflict indicate conflict 
precise framework extended logic programming 
underlying proofs lift default logic straightforward way 
brewka eiter claim erroneously approach violates principle claim extension th fa bg example 
approach case extension see discussion preceding theorem 
chosen setting viz 
answer set semantics corresponds default logic fragment extended logic programs gelfond lifschitz discussion described general framework incorporating preferences default logic 
naming defaults allow preferences appear arbitrarily default theory 
allows preferences preferences preferences default preferences holding certain contexts 
preferences axiomatised standard default logic approach may regarded providing formalisation notion preference 
intuition approach clear preference order specifies order defaults taken account see applicable 
argue prescriptive approach preferable descriptive approach point view representational force pragmatic computational considerations 
base approach standard reiter default theory strict partial order defaults 
allow preference information expressed default theory preference information appear world knowledge defaults delgrande schaub show preferences sets defaults similarly handled 
cases translate default theory second standard default theory explicit preferences defaults applied ordering 
notably cases translated theory larger original constant factor 
prove defaults applied appropriate order 
show developed set strict generalisations elaborations basic approach preference theory preferences translated theory modulo language gives result classical default logic 
addition formal results illustrate generality approach formalising examples due junker gordon context preference canceling preferences preferences preferences preferences default 
show capture approach brewka eiter 
argued complete information preferences generality may required doyle wellman building arrow argue preference default theory coherence requires dictator preferences 
complete system essentially way determining unique complete priority ordering 
sense needs called rigid approach section 
provide general framework section reasons 
realistic scenarios may complete information regarding preferences complete preferences may possible 
case obtain multiple extensions representing possible completions incomplete ordering 
second allows flexible specification preferences leaving user ensure ambiguity preferences 
illustrated gordon legal example see natural expression interacting types laws uses preferences preferences 
approach translating priorities standard default theories advantages previous phrased meta level alters machinery standard default logic 
translated default theory approach extension preferred sense preferred extensions specified ordering rules produced 
contrast previous approaches fashion select extensions preferred 
expect approach pragmatically efficient avoids generation unnecessary extensions 
advantage axiomatic approach allows formalise preference object theory 
particular allows combine orderings inside framework specify theory interact 
instance legal reasoning different principles prefer different laws 
saw lex posterior gives precedence newer laws lex superior gives precedence laws supported higher authority lex gives precedence specific laws 
reasoning principles explicit representation advantageous 
instance state lex applies lex posterior lex superior denies precedence oe oe posterior oe superior oe generally authority takes precedence time 
may exceptions account default rule oe superior oe posterior oe oe axiomatic approach easier compare differing approaches handling different preference orderings types orderings remain base framework 
default logic provides powerful tool express orderings 
result approach immediately implemented making existing default logic theorem provers preference theory translated straightforward efficient way default logic 
lastly compiling preferences default logic standard machinery default logic obtain insight notion preference orderings 
point theoretical interest show incorporating explicit priorities sets rules default logic fact provides real increase expressibility default logic 
lastly approach implemented syntactic restriction extended logic programming serves front logic programming systems dlv eiter smodels niemel simons 
current prototype available www cs uni potsdam de torsten plp url contains examples taken literature including discussed 
dynamic approach single preferences set approach implemented 
details implementation delgrande 
proofs theorems definition drawn proofs 
definition default theory 
set formulas gamma smallest set formulas 

th 
ff fi fl ff fi fl set formulas extension gamma proof 
consistency ffi oe ffi ffi oe ffi assume ffi ffi ffi oe ffi ffi oe ffi default rule ffi oen ffi ffi oen ffi oe applicable obtain ffi oe ffi contradicts assumption 
shown ffi oe ffi iff ffi oe ffi proofs observe complementary proposition 
lemma consistent extension ordered default theory 
ffi ffi ffi oe ffi iff ffi oe ffi proof clearly ffi oe ffi ffi oe ffi assume ffi oe ffi ffi oe ffi ffi oe ffi exist definition ffi oe ffi ffi oe ffi default rules consequents containing positive occurrences oe literals ffi oe ffi th 
due reason positive occurrences stem oe fact positive occurrences oe literals oe connected disjunctively positive ok literal 
form ffi oe ffi oe ok ffi formulas oe 
proof ffi oe ffi contain negative ok literal ok ffi 
negative occurrences ok literals contraction 

show induction ok ffi ap ffi bl ffi ffi base definition ok oe consistent 
implies ok ap gd ok 
bl gd ok bl gd 
ap bl step consider ffi assume ffi ffi ffi ok ffi ap ffi bl ffi prove lemma 
lemma induction hypothesis ok ffi proof induction hypothesis ap ffi bl ffi ffi ffi ffi definition oe lemma ffi oe ffi ffi ffi ffi ffi analogously get ffi oe ffi ffi ffi ffi 
ffi get means oe ffi oe ffi ffi ffi ffi ffi deductively closed contains oe oe bl ap oe ok deduce ok ffi consider ff fi fl distinguish cases 
fi flap gd 
consequently ok ap fi flap gd 
cases 
ff ok lemma fact deductively closed get ff lemma implies ok ff bl gd 
bl fi lemma implies bl gd 
bl demonstrates ap ffi bl ffi ffi ap ffi iff bl ffi 
ok ffi prereq ffi get ok ffi prereq ffi max justif ffi implies ffi gd max furthermore conseq ffi ap ffi max ap ffi max 
ok ffi prereq ffi get ffi gd furthermore bl ffi 
ok ffi justif ffi assume justif ffi minimal get ok ffi justif ffi max implies ffi gd max furthermore bl ffi max bl ffi 
ok ffi gamma ok ffi distinguish cases 
ap ffi consequently prereq ffi ok ffi justif ffi assume prereq ffi claim follows trivially 
prereq ffi ok ffi implying ffi gd conseq ffi ap ffi ap ffi accordingly ap ffi 
bl ffi may distinguish cases 
prereq ffi ok ffi implies ffi gd bl ffi bl ffi 
justif ffi assume justif ffi justif ffi ok ffi implying ffi gd bl ffi bl ffi considering cases obtain bl ffi proof 
corollary theorem 
ffi ffi ffi ffi ffi gd ffi ffi assume ffi gd ffi gd ffi gd holds ffi ffi ffi bl ffi conseq ffi ap ffi subsequently ap ffi ffi consider definition oe ffi oe ffi ffi ffi ffi ffi applying argument lemma obtain ffi oe ffi ffi ffi ffi 
ffi oe oe bl ap oe ok contains deductive closure deduce ok ffi ok ffi 
ffi ffi ffi gd 

assume ffi gd ffi gd ffi gd ffi ffi ffi ffi gd gamma ffi gd gamma ffi gd gamma ffi get bl ffi conseq ffi ap ffi subsequently ap ffi ffi reasoning employed implies ffi gd ffi gd ffi gd ffi gd ffi gd ffi gd 

assume ffi gd ffi gd ffi gd ffi ffi ffi ffi gd gamma ffi gd gamma ffi gd gamma ffi 
reasoning backwards lines get ok ffi gamma ok ffi gamma assume ok ffi gamma continuing reasoning backwards way yields bl ffi gamma ap ffi gamma ffi ffi ffi bl ffi gamma ffi gd gamma ffi gd gamma ap ffi gamma conseq ffi ap ffi gamma ffi gd gamma ffi gd ffi gd ffi gd gamma 
proof consistent extension 
assume enumeration hffi gd ffi ffi ffi ffi ffi ffi ffi ffi fa 
note ffi ffi hffi grounded conseq fffi ffi gamma prereq ffi implies conseq fffi ffi gamma ok ffi 
loss generality assume ffi ffi ffi ffi ffi ffi 
ffi ffi oe ffi lemma ffi ffi ffi oe ffi lemma conseq fffi ffi gamma ap ffi bl ffi 
suppose ffi default preferred ffi application settled 
means lemma ffi oe ffi ffi ffi definition literal ok ffi derivable means oe oe bl ap oe ok just supposed reducible conseq fffi ffi gamma ap ffi bl ffi oe ok ffi conseq fffi ffi gamma ap ffi bl ffi ffi ffi fa fact consistent contradiction 
proof default theory theta strict partial order default rules 
part extension define th ffi ffi gd obviously iff show extension second preserving 
construction 


th see 
ffi prereq ffi justif ffi conseq ffi true assume prereq ffi justif ffi prereq ffi justif ffi ok ffi theorem obtain ffi gd implies conseq ffi definition gamma minimality gamma 
show reversal assume gamma gamma gamma deductively closed ffi conseq ffi conseq ffi gamma 
definition conseq ffi implies ffi gd 
justif ffi equivalent justif ffi induction grounded enumeration gd shows ffi gd implies prereq ffi gamma 
definition conseq ffi gamma contradiction 
shown extension 
show preserves extension grounded enumeration hffi gd 
hffi enumeration obtained hffi removing default rules form ffi ffi replacing default rules form ffi original rules ffi note th ffi ig fffi ffi gd fffi ig 
furthermore fffi ig equals gd 
consider ffi ffi ffi ffi 
definition distinguish cases 
ffl ffi gd ffi ffi ffi ffi ffi ffi ffi ffi get theorem construction hffi implies ffl ffi gd ffi gd 
theorem implies ffi gd ffi gd ffi gd justif ffi equivalent justif ffi ffi gd prereq ffi precisely ffi ffi ffi kg prereq ffi ffi ffi theorem implies construction hffi obtain ffi ig prereq ffi 
part preserving extension 
exists grounded enumeration hffi gd satisfying conditions 

definition 
define th gamma oe delta oe defined definition fok ffi ffi dg fap ffi ffi gd fbl ffi ffi gd ffi oe ffi ffi ffi clearly iff show extension 
define gd defined definition respect part show note oe definition 
definition ffi oen ffi ffi oen ffi gd ffi ffi implies ffi oe ffi ffi ffi follows show inclusions 
fok ffi ffi dg ffi ap ffi ffi gd fbl ffi ffi gd draw reader attention fact individual membership aforementioned sets implies deductive closure deductively closed set 
proving inclusions define grounded enumeration hffi gd enumeration hffi ffi ffi ffi denote default rules say ffi gd prereq ffi conseq fffi ffi gamma justif ffi 
enumeration better underlying lexicographic order theta subject constraint ffi ffi stipulating compatibility theta feasible condition true ffi gd ii default rules gd arranged accordingly 
note enumeration encompasses default rules fffi jg 
concrete terms show induction lexicographic order induced theta 
ok ffi ffi 
ffi gd ffi gd ffi gd ffi clearly equivalent proving inclusions 
base definition ffi ffi 
definition ok clearly ffi gd argument default rules form ffi analogous 
step consider ffi assume 

hold ffi show lemma lemma induction hypothesis ok proof induction hypothesis ap ffi bl ffi ffi construction implies ap ffi bl ffi ffi ffi ffi definition oe fact oe ffi oe ffi ffi ffi ffi ffi fact oe oe bl ap oe ok deduce ok ffi deductively closed 
ffi distinguish cases 
consider ffi gd 
hffi grounded conseq fffi ffi gamma prereq ffi 
induction hypothesis assuring ffi ffi gamma gd holds get prereq ffi addition ok lemma 
prereq ffi ok ffi gd implies justif ffi equivalent justif ffi definition consequence obtain ffi gd ffi gd ffi gd distinguish cases ffl prereq ffi prereq ffi definition lemma get ok ffi gd ffi gd ffl conseq fffi ffi gamma justif ffi induction hypothesis assuring ffi ffi gamma gd holds implies justif ffi addition get induction hypothesis ok holds justif ffi ok max ffi gd max ffi gd part show prove induction base oe definition step assume consider ffl th get induction hypothesis fact deductively closed 
ffl ffi ffi gd distinguish cases ffi oe definition oe ffi ffi fi flap ffi ff ok ffi fi induction hypothesis fact deductively closed get ff equivalent ff correspondingly fi implies ffi gd fl fl ap ffi fap ffi ffi gd obtain ff ok ffi ffi ok ffi ff bl ffi ff ff ffi gd implies bl ffi fbl ffi ffi gd ffi ffi bl ffi fi ok ffi induction hypothesis fact deductively closed get fi equivalent fi ffi gd implies bl ffi fbl ffi ffi gd accordingly shown proof immediate consequence theorem 
proof conditions definition trivially true enumeration default rules 
case extension default theory preserving 
actual result immediate consequence theorem 
proof 
propositional semi normal ordered default theory 
consequently extension papadimitriou theorem 
associated literal graph associated dependency graph 
propositional simplify translation definition 
define translation ordered default theory 
propositional language set atomic sentences follows 
corresponding ground instances ok ap bl additional atomic sentences ok ap bl respectively 
corresponding ground instance oe additional atomic sentence oe sentence ff fol pr ff sentence ground instance form ok ap bl oe replaced corresponding atomic sentence translation follows fi flap ok ff bl bl fi fi fi ff fi fl oe oe fpr ffi oe ffi ffi ffi pr ffi oe ffi ffi ffi fok fpr oe oe bl ap oe ok ng ffi denote defaults image translation ffi ffi ffi respectively 
translation definition simplified removing default oe listing explicitly occurrences non occurrences oe represented jdj atomic sentences complete knowledge 
longer require formula oe definition replaced jdj explicit conjunctions 
consider image viz 

clearly respective literal graphs 
observe addition literal graph comes final formula oe viz 
jdj instances pr oe oe bl ap oe ok ffi associated formula oe oe bl ap oe oe bl ap oe oe bl ap oe ok written dnf oe bl ap oe bl ap oe bl ap nm ok complete knowledge partial order defaults equation logically equivalent respect oe oe bl ap oe bl ap oe bl ap ok ffi exactly oe oe oe oe oe oe oe oe turn equivalent respect oe bl ap bl ap bl ap ok ffi exactly oe oe oe oe formulas default formulas add edges literal graph 
formulas dnf edges added arrive consist pairs literals drawn distinct disjuncts formulas 
obtain edges 
default ffi obtain sets edges bl bl bl ap ap bl ap ap various jdj ok bl ok ap oe oe bl ok ap ok oe oe consider dependency graph 
edge types group contribute edges default rule bl ap consequent default rule bl ap prerequisite bl ap justification 

second set edge types group ok occur consequent default edges contribute edges 
leaves group 
ok appear negatively justification consequent rule contribute rule literals bl ap consequent rules literal ok antecedent image rule ffi ffi ffi means ffi ffi 
ffi ffi fa argued additions resulting weren 
defaults 

ffi ffi literal appearing positively conseq ffi literal appearing positively prereq ffi 
literal conseq ffi literal conseq ffi literal prereq ffi literal prereq ffi 
literal prereq ffi appearing positively appears negatively prereq ffi 
ffi ffi ffi ffi ffi ffi 
ffi ffi similar argument shows ffi ffi ffi ffi cases completely specified 
observe graph vertices edges 
subgraph vertices fffi jffi dg isomorphic 
ffi ffi edges form ffi ffi ffi ffi 
vertices ffi ffi outgoing edges part cycle 
observation conclude proof 
result follows easily propositional semi normal ordered default theory associated dependency graph fn ffi oe ffi ffi ffi cycles incorporating elements 
cycle fn ffi oe ffi ffi ffi cycle dependency graph ec ffi ffi fa ffi ffi ffi ffi ec subgraph ec 
assumption edge set fn ffi oe ffi ffi ffi cycles incorporating elements 
ec cycles incorporating elements image 
ec cycles incorporating elements image 
observation cycles 
proof 
normal ordered default theory pred prereq pred conseq pred pred conseq consider default theory defined fi fi fi fi fi ff fi fi ff lemma lemma assumptions extension iff extension 
proof clearly harmless replacing prerequisite default prerequisite implied pred prereq pred conseq default ffi prereq ffi extension ffi gd 
case prereq ffi prereq ffi equivalently conseq gd prereq ffi 
impossible conseq gd consistent assumption pred prereq ffi pred conseq gd pred pred conseq gd consequently ffi gd lemma follows immediately 
lemma assume loss generality ffi prereq ffi definition simplifies considerably 
obtain ok fi ok 
bl bl fi fi fi fi fi ok fi bl fi fi fi fi fi conclude noting impossible derive ok ffi impossible derive ap bl 
ok precisely effect ok fi bl bl precisely effect bl consequently translated default theory equivalent normal default theory guaranteed extension 
proof start fixing components different default theories define fffi ffi ffi ffi dg oe oe oe oe defined unindexed counterparts oe oe respectively definition 
accordingly define fn ffi oe ffi ffi ffi fffi ffi ffi ffi dg oe fn ffi oe ffi ffi ffi oe oe oe defined unindexed counterparts oe oe respectively definition 
part extension 
define th fok ffi ffi dg ffi ap ffi ffi gd fbl ffi ffi gd ffi sigma ffi ffi oen ffi ffi oen ffi gd show distinguish cases abbreviating ffi ffi gd conseq gd ffl consider implies iff ffl consider conseq gd 
conseq gd conseq gd implies iff ffl consider th conseq gd 
conseq gd conseq gd fact deductively closed imply furthermore th conseq gd iff th conseq gd shown iff draw fact sequel 
second show extension fn ffi oe ffi ffi ffi 
show propositions 
true definition 

th true definition 

ffi prereq ffi justif ffi conseq ffi show suppose prereq ffi justif ffi ffl ffi ffi oen ffi ffi oen ffi ffi sigman ffi ffi oe ffi ffi oe ffi definition fact ffi oe ffi imply ffi oe ffi ffi ffi 
implies ffi oe ffi oe ffi oe ffi implies lemma ffi oe ffi ffi oen ffi ffi oen ffi gd implies ffi sigma ffi definition ffl ffi ffi prereq ffi ok ffi justif ffi deductively closed prereq ffi obtain prereq ffi justif ffi extension obtain theorem ok ffi deductively closed prereq ffi ok ffi get ffi gd implies conseq ffi ap ffi definition ffl ffi ffi ok ffi prereq ffi obtain prereq ffi extension obtain theorem ok ffi get ffi gd implies bl ffi definition ffl ffi ffi justif ffi ok ffi deductively closed justif ffi obtain justif ffi extension obtain theorem ok ffi deductively closed prereq ffi ok ffi get ffi gd implies bl ffi definition shown conseq ffi definition get gamma minimality gamma 
show reverse assume gamma consider assume gamma 
distinguish cases 
ffl gamma gamma contradiction 
ffl ffi sigma ffi ffi oen ffi ffi oen ffi gd ffi oe ffi implies lemma ffi oe ffi ffi ffi 
definition ffi oe ffi ffi oe ffi ffi oen ffi ffi oen ffi ffi sigman ffi definition gamma ffi sigma ffi gamma contradiction 
ffl proceed induction grounded enumeration hffi gd fbl ffi ffi gd ffi ap ffi ffi gd show ffi ffi ffi ffi ffi ffi conseq ffi ap ffi gamma bl ffi gamma 
lemma 
lemma induction hypothesis ok ffi gamma 
proof analogous proof 
base definition ok gamma 
clearly ffi ffi implies conseq ffi ap gamma 
step consider ffi hffi grounded obtain conseq fffi ffi gamma prereq ffi 
prereq ffi oe ok ffi oe ffi justif ffi ffi ffi ffi ffi ffi clearly conseq fffi ffi gamma oe monotonicity conseq fffi ffi gamma oe 
definition gamma 
furthermore conseq ffi gamma induction hypothesis 
implies oe gamma gamma deductively closed 
lemma furthermore ok ffi gamma gives appeal gamma deductive closure oe ok ffi gamma 
consequence prereq ffi gamma 
ffi gd justif ffi implies justif ffi definition get conseq ffi gamma 
conseq ffi ap ffi gamma bl ffi gamma 
obtain gamma desired contradiction 
ffl fok ffi ffi dg draw just shown lemma theorem 
gives gamma contradiction 
gamma deductively closed get gamma 
completes proof showing extension fn ffi oe ffi ffi ffi 
part extension fn ffi oe ffi ffi ffi 
define th fok ffi ffi dg ffi ap ffi ffi gd fbl ffi ffi gd ffi oe ffi ffi oen ffi ffi oen ffi ffi sigman ffi gd rest proof continues analogy part omitted brevity 
proof result follows theorem corollary 
proof analogous proof 
proof part extension 
brewka eiter 
wlog 
stipulate ffi ffi gd iff conseq ffi condition easily enforced substituting default ffi ff fi fl ff fi flp ffi ffi new unique atom 
facilitates treatment generating defaults ffi gd inactive set consequent belongs viz 
conseq ffi ensure gd identical set applied rules brewka eiter definition 
definition regular extension show preserving 
consider application sequence hffi gd induced brewka eiter definition 
distinguish cases 
consider ffi ffi assume ffi gd ffi gd justif ffi justif ffi monotonicity get gamma justif ffi gamma justif ffi gamma assume wlog conseq ffi gamma conseq ffi gamma ffi ffi active brewka eiter 
applying ffi stage contradiction ffi ffi 
consider ffi ffi ffi gd 
brewka eiter proposition set ffi fffi gd ffi ffig total extension conseq ffi justif ffi clearly ffi ffi obtain conseq fffi ffi gamma justif ffi 
theorem extension part direction special case theorem 
proof preferred extension 
theorem preserving extension 
exists grounded enumeration hffi gd ffi gd 
ffi ffi 
ffi ffi prereq ffi conseq fffi ffi gamma justif ffi 
consider ffi prereq ffi conseq ffi clearly ffi gd 
minimal conseq fffi ffi justif ffi ffi 
ffi kg 
consider total extension ffi ffi kg 
regular extension ffi prereq ffi conseq ffi conseq fffi ffi justif ffi ffi ffi kg get brewka eiter proposition preferred extension 
brewka eiter 
total extension furthermore preferred extension 
brewka eiter 
baader hollunder baader hollunder 
prefer specific defaults terminological default logic 
proceedings international joint conference artificial intelligence pages 
baader hollunder baader hollunder 
prefer specific defaults terminological default logic 
technical report rr dfki december 
boutilier boutilier 
default priority 
glasgow hadley editors proceedings canadian artificial intelligence conference pages 
morgan kaufmann publishers 
brewka eiter brewka eiter 
preferred answer sets extended logic programs 
cohn schubert shapiro editors proceedings sixth international conference principles knowledge representation reasoning pages 
morgan kaufmann publishers 
brewka eiter brewka eiter 
prioritizing default logic 
st holldobler editor computational logic papers honour wolfgang bibel 
kluwer academic publishers 
appear 
brewka gordon brewka gordon 
buy porsche approach defeasible decision making 
aaai workshop computational dialectics pages seattle wa july 
aaai press 
brewka brewka 
adding priorities specificity default logic 
pereira pearce editors european workshop logics artificial intelligence jelia lecture notes artificial intelligence pages 
springer verlag 
brewka brewka 
reasoning priorities default logic 
proceedings aaai national conference artificial intelligence volume pages 
aaai press mit press 
brewka brewka 
founded semantics extended logic programs dynamic preferences 
journal artificial intelligence research 
delgrande schaub delgrande schaub 
general approach specificity default reasoning 
doyle torasso sandewall editors proceedings fourth international conference principles knowledge representation reasoning pages 
morgan kaufmann publishers 
delgrande schaub delgrande schaub 
reasoning sets preferences default logic 

lee motoda editors pacific rim international conference artificial intelligence volume lecture notes artificial intelligence pages 
springer verlag 
delgrande schaub delgrande schaub 
role default logic knowledge representation 
minker editor logic artificial intelligence 
kluwer academic publishers 
delgrande delgrande schaub tompits 
logic programs compiled preferences 
baral truszczy nski editors proceedings eighth international workshop non monotonic reasoning 
arxiv org print archive 
delgrande delgrande schaub tompits 
logic programs compiled preferences 
horn editor proceedings european conference artificial intelligence pages 
ios press 
doyle wellman doyle wellman 
impediments universal preference default theories 
artificial intelligence 
eiter eiter leone pfeifer scarcello 
deductive system nonmonotonic reasoning 
dix furbach nerode editors proceedings fourth international conference logic programming nonmonotonic reasoning volume lecture notes artificial intelligence pages 
springer verlag 
etherington reiter etherington reiter 
inheritance hierarchies exceptions 
proceedings aaai national conference artificial intelligence pages 
morgan kaufmann publishers 
geffner pearl geffner pearl 
conditional entailment bridging approaches default reasoning 
artificial intelligence 
gelfond lifschitz gelfond lifschitz 
classical negation logic programs deductive databases 
new generation computing 
gelfond son gelfond son 
reasoning prioritized defaults 
dix pereira przymusinski editors third international workshop logic programming knowledge representation volume lecture notes computer science pages 
springer verlag 
gordon gordon 
game artificial intelligence model procedural justice 
dissertation technische hochschule darmstadt darmstadt germany 
grosof grosof 
generalizing prioritization 
allen fikes sandewall editors proceedings second international conference principles knowledge representation reasoning 
morgan kaufmann publishers 
junker junker 
cumulative model semantics dynamic preferences assumptions 
pollack editor proceedings international joint conference artificial intelligence pages 
morgan kaufmann publishers 
lifschitz lifschitz 
closed world databases circumscription 
artificial intelligence 
marek truszczy nski marek truszczy nski 
nonmonotonic logic context dependent reasoning 
artifical intelligence 
springer verlag 
mccarthy mccarthy 
applications circumscription formalizing commonsense knowledge 
artificial intelligence 
niemel simons niemela simons 
smodels implementation stable model founded semantics normal logic programs 
dix furbach nerode editors proceedings fourth international conference logic programing nonmonotonic reasoning pages 
springer 
papadimitriou papadimitriou 
default theories extensions 
artificial intelligence 
pearl pearl 
system natural ordering defaults tractable applications nonmonotonic reasoning 
parikh editor proc 
third conference theoretical aspects reasoning knowledge pages pacific grove ca 
morgan kaufmann publishers 
poole poole 
logical framework default reasoning 
artificial intelligence 
reiter reiter 
interacting defaults 
proceedings international joint conference artificial intelligence pages vancouver 
reiter reiter 
logic default reasoning 
artificial intelligence 
rintanen rintanen 
specificity default logic 
proceedings international joint conference artificial intelligence pages 
morgan kaufmann publishers 
touretzky touretzky horty thomason 
clash intuitions current state nonmonotonic multiple inheritance systems 
proceedings international joint conference artificial intelligence pages milan 
zhang foo zhang foo 
answer sets prioritized logic programs 
editor proceedings international symposium logic programming ilps pages 
mit press 

