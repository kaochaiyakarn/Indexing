fast searching compressed text allowing errors silva de moura 
de ciencia da ao univ federal de minas brazil www dcc br gonzalo navarro 
de ciencias de la computaci univ de chile chile www dcc uchile cl ziviani 
de ciencia da ao univ federal de minas brazil www dcc br ricardo baeza yates 
de ciencias de la computaci univ de chile chile www dcc uchile cl fast compression decompression scheme natural language texts allows efficient flexible string matching searching compressed text directly 
compression scheme uses word huffman encoding coding alphabet byte oriented bit oriented 
compress typical english texts original size compress gzip respectively 
compression times close times compress approximately half times gzip decompression times lower gzip third compress 
searching algorithm allows large number variations exact approximate compressed string matching problem phrases ranges complements wild cards arbitrary regular expressions 
separators stopwords discarded search time significantly increasing cost 
algorithm word oriented shift algorithm fast boyer moore type filter 
uses vocabulary text available part huffman coding data 
searching simple patterns experiments show running algorithm compressed text twice fast running agrep uncompressed version text 
searching complex approximate patterns algorithm times faster agrep 
mention impact technique inverted files pointing documents logical blocks glimpse 
partially supported capes scholarship 
partially supported project 
partially supported cnpq project 
permission digital hard copy part personal classroom granted fee provided copies distributed profit commercial advantage copyright notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
sigir melbourne australia fl acm 
discuss efficient compression scheme algorithm allows search exact approximate patterns directly compressed text 
best knowledge attempt approximate string matching compressed text open problem abf 
compressed matching problem defined amir benson ab task performing string matching compressed text decompressing 
text corresponding compressed string pattern compressed matching problem consists finding occurrences naive algorithm decompresses string performs standard string matching takes time jt jp optimal algorithm takes worst case time jzj 
abf new criterion called extra space evaluating compressed matching algorithms introduced 
extra space criterion algorithms extra space optimally addition length compressed file 
optimal run time algorithm takes additional extra space may feasible practice 
apart efficient searching compression methods try minimize compression ratio size compressed file percentage uncompressed file 
compression scheme propose variant word huffman code mof 
huffman code assigned text word sequence bytes huffman tree degree 
show bytes bits significantly degrade compression ratios 
practice byte processing faster bit processing bit shifts masking operations necessary search time 
compression decompression fast compression ratios achieved better lempel ziv family zl zl 
searching algorithm word oriented shift algorithm byg uses fast boyer filter sun speed scanning compressed text 
vocabulary available part huffman coding data point 
vocabulary imposes negligible space overhead text collection large 
algorithm allows large number variations exact approxi mate compressed string matching problem 
result phrases ranges complements wild cards arbitrary regular expressions efficiently searched 
algorithm discard separators stopwords significantly increasing search cost 
approximate text searching problem find substrings text database distance pattern distance strings minimum number insertions deletions substitutions single characters strings needed equal 
case corresponds classical exact matching problem 
defined 
exact searching approach finds pattern occurrences time optimal near extra space 
approximate searching algorithms find pattern occurrences near time near extra space 
technique useful speed sequential search 
fact improve indexed schemes combine inverted files sequential search glimpse mw 
glimpse divides text space logical blocks builds inverted file list word occurrences points corresponding blocks 
searching done doing search inverted file sequential search selected blocks 
compression scheme text direct search done block improving search time factor 
notice context alphabet size number different words large working assumptions 
algorithms software package called 
exact approximate compressed matching tool large text collections 
software package available ftp dcc br pub research prototype version 
organized follows 
section related literature 
section compression decompression method followed analytical experimental results 
section show perform exact approximate compressed string matching followed analytical experimental results 
section directions 
related ft compressed matching algorithm lz classic compression scheme zl runs time log 
abf compressed matching algorithm lz compression scheme finds occurrence time space time log space 
approach differs ft abf aspects 
distinct theoretical framework 
second includes implementation proposed algorithms implement thoroughly evaluate algorithms 
third empirical evaluation considers compression scheme compressed matching exact approximate problem 
text compression scheme allows direct searching proposed man 
scheme packs pairs frequent characters single byte leading compression ratio approximately typical text files 
want keep search byte level efficiency 
approach leads better compression ratio half compression ratio man 
searching algorithm deal efficiently approximate compressed matching comparing favorably agrep wm fastest known software search exactly approximately uncompressed text 
compression scheme modern general compression methods typically adaptive allow compression carried pass need keep separately parameters decompression time 
natural language texts full text retrieval context adaptive modeling effective compression technique 
chose word semi static modeling huffman coding 
semi static modeling encoder pass text obtain parameters case frequency different text word perform actual compression second pass 
strong reason combination modeling coding 
data structures associated include list words compose vocabulary text derive compressed matching algorithm 
reasons important text retrieval applications decompression faster semi static models compressed text accessed randomly having decompress text adaptive methods 
furthermore previous experiments shown word methods give compression ratios natural language texts mof hc 
text composed words separators model chosen 
mof different alphabets words separators 
strict alternating property holds confusion alphabet known text starts word separator 
variant method deal words separators call words 
word followed space just encode word 
encode word separator 
decoding time decode word assume space follows symbol corresponds separator 
idea firstly 
show word model achieves slightly better compression ratios 
presents example compression huffman coding words method 
set symbols case fa rose tg frequencies respectively 
number huffman trees probability distribution quite large 
preferred choice applications canonical tree defined schwartz sk 
huffman tree canonical tree 
allows efficiency decoding time memory requirement 
properties canonical codes mentioned hl zm 
byte oriented huffman code original method proposed huffman binary code 
huff rose phi phi phi phi original text compressed text rose rose rose compression huffman coding words man code assigned text word sequence bytes huffman tree degree 
techniques efficient encoding decoding mentioned zm easily extended case 
show experimental results section significant degradation compression ratio experienced bytes bits 
hand decompression byte huffman code faster decompression binary huffman code 
practice byte processing faster bit processing bit shifts masking operations necessary decoding time searching time 
construction byte huffman trees involves details deal 
explained care exercised ensure levels tree empty nodes code binary 
illustrates case naive extension binary huffman tree construction algorithm generate non optimal byte tree 
example alphabet symbols probability 
root node empty spaces symbols second level tree changing code lengths bytes byte 
non optimal tree optimal byte tree phi phi elements 
phi phi elements 
empty nodes 

pp 
elements empty nodes phi phi elements 
xxx 
elements example byte huffman tree way ensure empty nodes go lowest level tree follows 
calculate previously number empty nodes arise 
compose empty nodes symbols smallest probabilities 
step sufficient guarantee empty nodes deepest level final tree 
remaining steps similar binary huffman tree construction algorithm 
fact coupling step consider gamma mod symbols total number symbols size vocabulary 
applying formula example elements coupled empty nodes step gamma mod shown 
remaining part section show length byte huffman codes grow text grows vocabulary 
key prove show distribution words text biased entropy show byte huffman code constant overhead entropy 
zipf law zip model frequency words appearing natural language texts 
law widely accepted information retrieval 
zipf law states order words natural language text decreasing order probability probability word times probability th word constant depends text 
means probability th word zipf law comes flavors 
simplified form assumes 
case log 
simplified form popular simpler handle mathematically follow real distribution natural language texts 
strong evidence real texts fact biased vocabulary 
performed thorough set experiments trec collection finding values roughly depending text gives experimental evidence favor generalized zipf law 
assumption 
tested distribution separators finding follow reasonably zipf distribution 
distribution biased words closer 
assume consider words proof hold separators 
analyze entropy distribution vocabulary words digits coding alphabet follows log ln ln ln ln ln ln log ln ln bounding summation integral ln ln gamma ln gamma gamma log gamma allows conclude 
huffman coding optimal inability represent fractional parts bits 
symbol probability exactly log bits represent symbol possible power 
effect gets worse bits numbers base give upper bound compression inefficiency involved 
worst case huffman encode symbol probability dlog digits 
worst case symbols encoded blog digits 
worst case average length code compressed text dlog log shows regardless probability distribution spend extra digit code due rounding overheads 
instance bytes spend byte word 
proves entropy remains constant text grows compression ratio degrade number different words separators increases 
simple zipf law result log average code length grows text grows 
fact happen gigabyte text independent experimental confirmation validity generalized zipf law simple version 
hand refined versions zipf law exist mandelbrot distribution 
law tries improve fitting zipf law frequent values 
mathematically harder handle alter asymptotic results 
compression decompression performance experimental results literary texts trec collection har 
chosen texts ap newswire doe short abstracts doe publications fr federal register wsj wall street journal ziff articles computer selected disks ziff davis publishing 
table presents statistics text files 
considered word contiguous string characters set fa separated characters set fa 
tests run sun sparcstation megabytes ram running solaris 
table shows entropy compression ratios achieved huffman byte huffman unix compress gnu gzip files trec collection 
space store vocabulary included huffman compression 
seen compression ratio degrades slightly bytes bits case gzip 
exception fr collection includes large part non natural language chemical formulas 
method files ap wsj doe ziff fr entropy huffman bits byte huffman compress gzip table entropy compression ratios achieved huffman byte huffman compress gzip 
empirically known vocabulary text words grows sublinearly hea large texts overhead storing vocabulary minimal 
storing vocabulary represents important overhead text small say megabytes 
compress vocabulary standard huffman characters 
shown compressor better gzip files megabyte 
need decompress vocabulary search time poses minimal processing overhead completely compensated reduced compression ratio file size megabytes byte huffman byte huffman compressed vocabulary compress gzip compression ratios wsj file compressed gzip compress byte huffman byte huffman coding compressed vocabulary table shows compression decompression times achieved huffman byte huffman compress gzip files trec collection 
compression times faster gzip slower compress achieves worse compression ratios 
decompression significant improvement bytes bits 
bit shifts masking necessary 
bytes faster gzip times faster compress 
method memory demanding compress gzip constitutes drawback 
algorithm near space complexity methods gzip compress constant space complexity 
example method needs megabytes memory compress megabytes memory decompress file wsj gzip compress need megabyte compress decompress file 
text searching systems interested advantages method allowing efficient search compressed text fast decompression fragments important space requirements 
searching huffman compressed text show search compressed text 
explain exact matching complex patterns filter speed search 
basic algorithm heavy vocabulary text available part huffman coding data 
huffman tree regarded trie leaves words vocabulary path root leaf spells compressed code shown left part word rose files text vocabulary vocab text size bytes words size bytes words size words ap doe fr wsj ziff table text files trec collection method compression decompression ap wsj doe ziff fr ap wsj doe ziff fr huffman bits byte huffman compress gzip table compression decompression times seconds achieved huffman byte huffman compress gzip example word rose byte codeword 

searching automata marks rose huffman tree vocabulary searching scheme pattern rose search pattern preprocess 
preprocessing consists searching vocabulary marking corresponding entry 
search efficient instance binary search hashing 
general patterns phrases 
preprocess phrase patterns simply perform procedure word pattern 
word vocabulary set bit mask indicates elements pattern word match 
shows marks phrase pattern rose indicates word second pattern indicates word rose pattern 
word pattern vocabulary immediately know text 
scan compressed text byte byte time traverse huffman tree downwards decompressing text 
report occurrence symbol reach leaf huffman tree 
word symbol obtained send corresponding bit mask automaton illustrated 
nondeterministic automaton allows move state state th word pattern recognized 
notice automaton depends number words phrase query 
reaching leaf return root tree proceed compressed text 
automaton simulated shift algorithm byg 
perform transition automaton text word 
shift algorithm simulates efficiently nondeterministic automaton operations transition 
bit architecture search phrase words single computer word bit mask 
longer phrases computer words needed 
show deal separators stopwords 
online searching algorithms efficiently deal problem matching phrase disregarding separators words spaces words 
happens elimination stopwords usually disregarded indexing schemes difficult disregard online searching 
compression scheme know elements vocabulary correspond fact separators correspond stopwords compression time mark searching algorithm ignores 
eliminate separators stopwords sequence search pattern negligible cost 
extending basic algorithm complex patterns entering details searching algorithms complex patterns mention types phrase patterns supported system 
word pattern allows single letters pattern set characters position 
addition system supports patterns combining exact matching parts approximate matching parts unbounded number wild cards arbitrary regular expressions combinations exactly allowing errors 
appendix detail type query supported system 
complex patterns preprocessing phase corresponds sequential search vocabulary mark words match pattern 
technique block oriented indexing schemes searching allowing errors uncompressed texts mw 
vocabulary small compared text size sequential search time vocabulary negligible additional cost allow complex queries 
difficult achieve online plain text searching take advantage knowledge vocabulary stored part huffman tree 
word pattern searched separately vocabulary sequential pattern matching algorithm 
corresponding mask bits matched word vocabulary set indicate position pattern 
illustrates phase pattern ro rose allowing error 
instance word rose vocabulary matches pattern positions 


huffman tree vocabulary marks rose road row general searching scheme phrase ro rose allowing error depending pattern complexity different algorithms search vocabulary 
phrase patterns allowing errors contain sets characters position algorithm byn 
size vocabulary length word algorithm runs time search complicated patterns allowing errors contain unions wild cards regular expressions algorithm wm runs kv time search compressed text scanning phase similar described section 
improving search boyer moore filtering show section search compressed text improved 
central idea search compressed pattern directly text fast boyer moore horspool sunday sun algorithm 
avoids inspecting bytes compressed text algorithm size bytes compressed text length compressed pattern 
search single word look word vocabulary obtain compressed code 
look rose search string 
code searched directly compressed text 
time match compressed text verify match corresponds word 
see verification necessary consider word ghost example 
avoid processing text verification divide text small blocks size compression time 
codes aligned blocks code ghost real word real word ghost compressed text original text word code example code word compressed text word original text crosses block boundary 
need run basic algorithm block contains match 
block size small slower basic algorithm small areas large extra space lost block boundaries significant 
run number experiments wsj file blocks sizes bytes 
worst search performance blocks bytes due overhead treating flags block 
performance improved blocks bytes decreased blocks bytes due overhead performing verification potential match 
time space tradeoff block size bytes 
order search complex queries search vocabulary explained section 
set words obtained search codes text extension algorithm handle multiple patterns byn byn 
order search phrase pattern simply take words phrase representative 
code element compressed text verification phase searches phrase 
free representative take longest code infrequent word searching improves longer patterns 
number matching words vocabulary large efficiency filter may degraded scheme filter preferable 
analytical results analyze performance searching algorithm 
analysis considers random text appropriate compressed text mainly random 
empirically known vocabulary text words grows fi hea 
analysis consider vocabulary fi words typically fi compressed search patterns length typically equal bytes original text characters compressed text characters complex query matches words vocabulary typically byn number errors allowed oe coding alphabet oe symbols pattern characters different words length 
align codes boundaries blocks bytes 
consider preprocessing phase 
looking exactly word length vocabulary done worst case trie average hashing 
looking exactly words pattern cost 
hand search complex pattern preprocess words cost ju fi ju fi fi fi depending algorithm 
reasonable cases preprocessing phase sublinear text size negligible cost 
taken constant preprocessing cost ju fi mu fi close 
consider text searching natural language texts 
basic algorithm works compressed byte search time worst case preprocessing costs 
worst case complexity independent complexity search 
hand algorithm filter inspect characters 
pattern phrase just look element phrase restrict attention single word queries 
query matches single word vocabulary search time close length compressed word 
case query matching words vocabulary formula holds algorithm provided length shortest code vocabulary words matching query 
alphabet size larger length codes 
case complex query generates different patterns search effectiveness filter degraded albeit constant smaller basic algorithm 
exact constant open problem 
filter blocks traversed basic algorithm verify matches filter 
searching codes length parallel probability finding block length gamma gamma oe total cost verifications gamma gamma oe gamma oe give idea real numbers involved consider search single word code bytes 
case filter inspects average bytes advance positions inspecting total bytes 
proportion bytes inspected due verifications smaller theta gamma close inspect bytes close algorithm run original text 
case cpu costs similar 
perform third required uncompressed searching search significantly faster 
accepted rule information retrieval queries uniformly distributed vocabulary 
queries large probable code length 
short code lengths correspond stopwords may forbidden 
search complex pattern filter unsuitable simply run shift algorithm inspecting bytes 
uncompressed version best original text character times cost 
times case third uncompressed searching 
searching performance performance evaluation algorithms previous sections obtained randomly chosen patterns 
fact considered patterns containing word patterns containing words patterns containing words submitted searching algorithms 
experiments run wsj text file results obtained confidence 
sizes wsj uncompressed compressed files megabytes respectively 
table presents exact approximate searching times agrep wm boyer moore filtering blocks bytes 
seen table insensitive number errors allowed pattern agrep 
happens version maps queries automaton depend shows exact searching filter twice fast agrep nearly times faster approximate searching 
times constant time factor approximately seconds read wsj compressed file approximately seconds agrep read wsj uncompressed file 
test different types patterns follows 
prob sign ance means character considered zero times possible answer problematic significance 
petroleum services lines 
table presents exact approximate searching times agrep boyer moore filtering blocks bytes 
investigated fast compression decompression scheme natural language texts algorithm allows search exact approximate compressed matches 
analyzed algorithms experimental results performance natural language texts 
showed achieve compression ratio compress gzip respectively 
typical texts compression times close times compress approximately half times gzip decompression times lower gzip third compress 
exact searching algorithm time optimal extra space size compressed text size pattern size uncompressed text 
approximate searching complex queries algorithm near time extra space 
fast boyer moore type filter speed search close average uses extra space length shortest code words matching pattern 
example power compressed matching algorithm search pattern containing words allowing error compressed file approximately megabytes corresponding wsj file megabytes 
runs megabytes second equivalent searching original text algorithm agrep sigma sigma sigma sigma sigma sigma sigma sigma filter sigma sigma sigma sigma table searching times seconds wsj text file 
pattern agrep agrep agrep filter filter filter table searching times seconds wsj text file 
megabytes second 
agrep searches original text megabytes second times faster agrep 
currently integrating results block oriented indexing schemes similar glimpse mw nicely applied 
working new compression scheme compressed text need decoded search time known sequential pattern matching algorithm exact search 
wish acknowledge helpful comments berthier ribeiro neto fruitful discussions ara helped particularly algorithms approximate searching text vocabulary 
ab amir benson 
efficient twodimensional compressed matching 
proc 
second ieee data compression conference pages mar 
abf amir benson farach 
sleeping files lie pattern matching files 
journal computer systems sciences 
ara navarro ziviani 
large text searching allowing errors 
baeza yates editor proc 
fourth south american workshop string processing carleton university press international informatics series pages 
byg baeza yates gonnet 
new approach text searching 
communications acm 
byn baeza yates navarro 
faster algorithm approximate string matching 
proc 
combinatorial pattern matching cpm springer verlag lncs pages 
byn baeza yates navarro 
multiple approximate string matching 
proc 
workshop algorithms data structures wads springer verlag lncs pages 

byn baeza yates navarro 
block addressing indices approximate text retrieval 
proc 
sixth acm international conference information knowledge management cikm pages las vegas nevada 
baeza yates 
average running time boyer moore horspool algorithm 
theoretical computer science jan 
elsevier science publishers 
bell moffat nevill manning witten zobel 
data compression full text retrieval systems 
journal american society information science 
bentley sleator tarjan wei 
locally adaptive data compression scheme 
communications acm 
ft farach thorup 
string matching lempel ziv compressed strings 
proc 
th acm annual symposium theory computing pages 
gonnet baeza yates 
handbook algorithms data structures 
addisonwesley 
har harman 
overview third text retrieval conference 
proc 
third text retrieval conference trec pages national institute standards technology special publication gaithersburg maryland 
hea heaps 
information retrieval computational theoretical aspects 
academic press 
hl hirschberg 
efficient decoding prefix codes 
communications acm 
hc horspool cormack 
constructing word text compression algorithms 
ieee proc 
second data compression conference pages 
huffman 
method construction minimum redundancy codes 
proc 
institute electrical radio engineers 
man manber 
text compression scheme allows fast searching directly compressed file 
acm transactions information systems 
mw manber wu 
glimpse tool search entire file systems 
tech 
report dept computer science univ arizona oct 
mof moffat 
word text compression 
software practice experience 
de moura navarro ziviani 
indexing compressed text 
baeza yates editor proc 
fourth south american workshop string processing carleton university press international informatics series pages 
de moura navarro ziviani baeza yates 
direct pattern matching compressed text 
tech 
report dept computer science univ federal de minas brazil apr 
sk schwartz 
generating canonical prefix encoding 
communications acm 
sun sunday 
fast substring search algorithm 
communications acm 
wm wu manber 
fast text searching allowing errors 
communications acm 
zip zipf 
human behaviour principle effort 
addison wesley 
zl ziv lempel 
complexity finite sequences 
ieee transactions information theory 
zl ziv lempel 
universal algorithm sequential data compression 
ieee transactions information theory 
zl ziv lempel 
compression individual sequences variable rate coding 
ieee transactions information theory 
zm zobel moffat 
adding compression full text retrieval system 
software practice experience 
appendix complex patterns types phrase patterns supported system 
word pattern allows single letters pattern set characters position exactly allowing errors follows ffl range characters xt means letter ffl arbitrary sets characters aei xt meaning words text ffl complements ab xt ab means single character xt means single character ffl arbitrary characters means character second character word ffl case insensitive patterns text text considered words 
addition single strings arbitrary size classes characters described system supports patterns combining exact matching parts approximate matching parts unbounded number wild cards arbitrary regular expressions combinations exactly allowing errors follows ffl unions ai xt means words text ai xt means words followed ai zero times followed xt 
case word seen regular expression ffl arbitrary number repetitions ab xt means ab considered zero times 
case word seen regular expression ffl arbitrary number characters middle pattern xt means character considered zero times 
case word considered regular expression efficiency 
note equivalent delta xt delta xt obtain matchings considered regular expression ffl combining exact matching parts approximate matching parts te xt meaning exact occurrence te followed occurrence xt error ffl matching nonuniform costs cost insertions defined twice cost deletions 
