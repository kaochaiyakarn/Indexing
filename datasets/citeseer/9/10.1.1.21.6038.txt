scalable replication database clusters mart jim enez peris kemme alonso technical university madrid facultad de inform atica del monte madrid spain fi upm es lml ls fi upm es lml ls fi upm es swiss federal institute technology ethz institute information systems eth zentrum ch zurich switzerland inf ethz ch www inf ethz ch department 
widespread clusters web farms increased importance data replication 
existing protocols typical distributed system solutions emphasize fault tolerance price performance database solutions emphasize performance price consistency 
explore data replication cluster configuration objective providing fault tolerance performance compromising consistency 
combining transactional concurrency control group communication primitives 
approach transactions executed site nodes incur overhead parsing optimizing producing results 
reduce latency optimistic multicast approach overlaps transaction execution total order message delivery 
techniques provide correct executions minimizing overhead providing higher scalability 
data replication considered proven technique enhance fault tolerance performance distributed applications 
practice wide gap theory practice 
conventional algorithms emphasize fault tolerance replication implement fail mechanisms bhg 
database designers purposefully ignore algorithms due poor performance 
database products lazy replication provides fault tolerance full consistency 
suggested ka ka pgs aaas gap bridged combining database replication group communication primitives br mainly total order broadcast ht 
line resulted efficient eager replication protocols guarantee consistency increase fault tolerance 
results especially suitable clusters computers large collections shared databases 
initial optimizations suggested optimistic techniques ps existing protocols major drawbacks 
amount redundant performed sites 
high abort rates created consistency enforced 
address issues 
protocol minimizes amount redundant system 
transactions replicated data executed site 
sites system need install final changes 
data replication protocols aggregated computing power system increases nodes added 
great advantage environments transaction processing represents significant overhead 
instance typical web farm transaction written sql results returned form web pages 
processing transaction involves parsing sql executing transaction generating web pages delivering client 
obviously done sites amount wasted resources high 
protocol exploits extreme form optimistic broadcast hides communication overhead transaction execution 
negative aspect protocol situations aborts transactions order guarantee serializability 
reduce amount aborted transactions propose second algorithm 
second algorithm uses transaction reordering technique avoids aborts optimistic total message orderings 
consistency guaranteed higher transaction latency throughput considerably increases decreasing abort rate 
organized follows 
section system model definitions introduced 
sections describe algorithms 
fault tolerance aspects algorithms discussed section 
section presents correctness proofs 
section concludes 
system model replicated database consists group nodes fn nn called sites communicate exchanging messages 
sites fail crashing byzantine failures excluded assume available node system 
site contains copy entire database 
communication model sites communicate group communication primitives br 
primitives classified attending order guarantees fault tolerance provided ht 
fifo ordering delivers messages sent site fifo order 
total order ensures messages delivered order sites 
regard fault tolerance reliable multicast ensures message delivered available sites 
uniform reliable multicast ensures message delivered site faulty delivered available sites 
assume virtual synchronous system br group members perceive membership view changes virtual time sites deliver exactly messages installing new view 
aggressive version optimistic total order broadcast ps 
message corresponds transaction 
messages optimistically delivered soon received definitive ordering established 
execution transaction overlap calculation total order 
initial order definitive order transactions simply committed 
final order different additional actions taken guarantee consistency 
optimistic broadcast defined primitives 
broadcast broadcast message sites system 
opt deliver delivers message optimistically application order guarantees 
delivers definitively application total order 
means messages opt delivered different order site total order sites 
sequence opt delivered messages tentative order 
sequence delivered messages definitive order total order 
furthermore optimistic multicast primitive ensures broadcast message eventually opt delivered delivered site system 
ensures site delivers message opt delivering 
transaction model clients interact database issuing transactions 
transactions partially ordered sets read write operations 
transactions conflict access data item write operation 
history committed transactions serial totally orders transactions 
histories conflict equivalent set transactions order conflicting operations way 
history serializable conflict equivalent serial history bhg 
replicated databases correctness criterion bhg 
criterion copy appear single logical copy execution concurrent transactions equivalent serial execution physical copies 
concurrency control conflict classes 
conflict class represents partition data 
transactions accessing conflict class high probability conflicts access data transactions different partitions conflict executed concurrently 
transaction access single basic conflict class 
generalize model allow transactions access compound conflict classes 
compound conflict class non empty set basic conflict classes fc 
assume compound conflict class transaction known advance 
site queue cq associated basic conflict class transaction delivered site added queues basic conflict classes accesses 
concurrency control mechanism simplified version lock table databases gr 
lock table queue data item whilst approach queue corresponds arbitrary set data items conflict class 
model may restrictive real applications practice 
instance commerce applications commonly implemented web farms transactions randomly access database 
typically access lines products 
partitioning data allocating partitions different nodes performance significantly improved 
protocols take advantage fact minimize overhead 
execution model conflict class unitary master site 
read write available approach 
queries read transactions executed site snapshot data interfere update transactions 
update transactions broadcast sites executed master site conflict class 
say transaction local master site conflict class remote rest sites 
instance assume sites master conflict class fc master conflict class fc transaction accessing executed transaction accessing executed conflict classes statically assigned sites case failures reassigned different sites 
increasing scalability algorithm extends described fine granularity locking executing transactions site allowing transactions access conflict class 
characteristics algorithm greatly improves scalability processing capability system increases sites added 
call algorithm non disjoint conflict classes optimistic multicast 
problem considering scalability data replication protocols important keep mind replication nature scale update ratio high 
illustrate point consider centralized system capable processing transactions second 
assume system nodes identical centralized 
assume fraction updates assume load local transactions node transactions second 
nodes process updates come nodes hold gamma node processes local transactions second plus percentage updates arriving nodes access replicated data times number nodes 
number transactions processed node gamma total capacity system times expression yields normalized gamma expression maximum updates minimum operations updates 
replicated application update factor approaches total capacity system tends single node independently nodes system 
note drop system capacity sharp 
nodes update factor updates causes total system capacity tenth nominal capacity 
solution key solve problem execute transactions local site reducing gamma factor expressions 
sites receive results updates install updates requires significantly running transaction 
order guarantee consistency total order established delivery primitive guideline serialize transactions 
sites see total order update transactions 
guarantee correctness suffices site ensure conflicting transactions ordered definitive order 
note transactions executed different orders different sites serialized respect 
update transaction submitted broadcast nodes 
message contains entire transaction opt delivered sites including local site proceed add corresponding entries local queues 
local site executes head queues corresponding operation executed shadow copy data 
way triggers consistency constraints internal read dependencies observed aborting transaction straightforward 
transaction delivered site site checks definitive tentative orders agree 
agree transaction committed execution completed 
agree cases consider 
lack agreement non conflicting transactions 
case ordering mismatch ignored 
mismatch conflicting transactions possible scenarios 
local transactions involved transaction simply rescheduled queues transactions opt delivered 
delivered transactions follow definitive order 
local transactions involved procedure similar local transactions aborted executing wrong shadow copy rescheduled putting back queues proper order 
transaction delivered completely executed local site broadcasts commit message containing updates called write set ws 
receiving commit message need ordering guarantee remote site installs updates certain basic class soon transaction reaches head corresponding queue 
updates installed transaction commits 
example assume basic conflict classes sites site master conflict classes fc fc denote conflict class transaction site master fc assume transactions fc fc fc local local tentative order definitive order transactions opt delivered queues site follows cq cq cq cq site start executing operations head corresponding queues 
delivered orders compared 
case definitive order tentative order commit 
finished execution send commit message corresponding updates 
commit remove queues 
done principle goes final total order 
transactions conflict mismatch ignored 
parallel receives commit message corresponding changes installed head queue cq changes installed committed removed cq site start executing local head queue 
delivered realizes executed order abort moving back queue 
moved head queues 
remote moving head queue cq require abort transaction queues remote transaction 
transaction executing commit message arrives executed committed removed queues 
start executing 
delivered completely executed commit message updates sent removed cq algorithm algorithm structured different phases transaction execution transaction opt delivered delivered completes execution commits 
usual assume access queue regulated locks latches gr 
restrictions certain events may happen 
instance transaction commit executed delivered 
transaction state variables ensure behavior execution state transaction active soon queued executed execution finished 
transaction executed site local 
delivery state pending delivered delivered 
transaction opt delivered state set active pending 
assume transaction local queues corresponding operations submitted execution 
opt delivery mark active pending conflict class cx ct append queue endfor complete execution marked broadcast commit message wst mark executed endif delivery mark executed broadcast commit message wst finished local cx ct local pending abort mark active endif schedule transaction marked pending endfor endif receiving commit message wst local delay cx ct irst apply updates wst corresponding cx database remove endfor remove ct endif commit assume phases done atomic step 
means instance adding transaction different queues opt delivery rescheduling transactions delivery interleaved action 
note aborting transaction simply involves discarding shadow copy 
transaction kept queues different positions 
commit message sent transaction delivered executed local site 
commit message arrive sites transaction delivered site 
case definitive order known transaction commit site prevent conflicting serialization orders 
reason processing commit message remote site delayed corresponding transaction delivered site 
transaction delivered head queues updates sent commit message applied database transaction committed 
reducing transaction aborts problem algorithm mismatch local optimistic order total order involving executed local transaction results local transaction aborted transactions conflicting 
note abort rate necessarily high happen transactions conflict appear system time site mismatch occurs local site aborted transaction executing 
cases transaction aborts 
network congestion high loads quickly lead messages spontaneously ordered increasing abort rates 
avoid problem algorithm optimized reducing number aborted transactions 
solution way avoid aborting local transactions take advantage fact certain extent master copy algorithm remote sites install updates proper order 
local site unilaterally decide change serialization order local transactions definitive order follow tentative order 
reduces abort rate increases throughput decreases transaction latency 
guarantee correctness local site inform rest sites new execution order 
extra messages needed information sent commit message 
special care taken transactions belong non unitary conflict class fc 
see site follow tentative order opt definitive order conflict class subset conflict class inconsistencies occur 
call new algorithm reordering serialization order imposed definitive order changed tentative 
example assume database basic conflict classes site master conflict classes fc fc master conflict class fc show reordering takes place assume transactions fc fc transactions local tentative order sites definitive order opt delivering transactions ordered follows sites qc qc site start execution local head queues 
assume delivered stage 
algorithm put head queues done aborting abort unnecessary controls execution transactions sites simply waiting told 
simply decide follow total order tentative order 
reordering occurs serializer transaction note done transactions local conflict classes subset conflict class 
site information reordering 
knowing better delivered reschedule described algorithm 
queues sites look follows queues site queues site qc qc qc qc need wait delivered 
head queue serializer transaction delivered commit message sent completely executed reducing latency 
commit message contains identifier serializer transaction receives commit message realizes reordering took place 
reorder ahead mark 
order ensure copy serializability 
rescheduling take place commit message arrives contain serializer transaction 
order prevent executed wrong order commit messages sent fifo order note fifo needed algorithm 
example suggests restrictions reordering take place 
see consider transactions fc fc fc local local assume tentative order definitive total order transactions opt delivered queues sites look follows queues site queues site qc qc qc qc local head queues starts executing reasons starts executing delivered reordered assume done 
commit commit message sent assume scenario receives commit message delivered 
local commit executed commit sent 
time commit message arrives produce serialization order receives commit committed serialization order contradicts serialization order situation arises fc subset fc serializer transaction order clarify subclasses reordered transaction conflict class subset subclass serializer transaction needed reordering assume accesses 
case queues queues site queues site qc qc qc qc subclass property guarantees conflicts transaction conflicts 
conflict delay execution commitment commit message delivered 
commit message reordered transaction arrive committed solving previous problem 
means produce serialization order reordering algorithm general reordering algorithm similar points omit actions opt delivery algorithm 
complete execution marked broadcast commit message ws serializer mark executed endif delivery transaction committed reordered local marked executed broadcast commit message wst finished ft ct ct ct cx ct ct pending local abort conflicting transactions reordered abort mark active endfor try reorder transactions rs ft ct opt pending local rs ft opt delivery order mark associate serializer transaction schedule transaction pending jt cx endfor endif remote transaction mark conflict class cx ct pending local abort mark active endif schedule transaction marked pending queue endfor endif transaction reordered ignore message endif receiving commit message wst local delay mark endif endif cx ct local reschedule just endif apply updates wst endif remove endfor commit commit message contain identifier serializer transaction follow fifo order 
transaction delivered transaction marked 
local site non delivered local transaction conflict class subset precedes queues reorder set rs marked commit order longer definitive tentative order 
possible reordered transaction delivered transaction marked committed 
case delivery message ignored 
local non delivered conflicting transactions reordered started execution aborted abort set 
delivered transaction remote algorithm behaves algorithm 
remote reordered transaction commit site serializer transaction delivered site 
happens rescheduled serializer transaction 
rescheduling fifo ordering ensure remote transactions commit sites order local site 
dealing failures view changes system site copy data 
site acts primary conflict classes owns backup conflict classes 
event site failures just matter selecting new master site conflict classes residing failed node 
mechanism load balancing nodes dynamically reassigning master node hot spot conflict classes 
simple policy assign conflict classes failed node site new view 
way nodes easy way know new master conflict classes 
new master node transactions failed node received execute commit transactions uncommitted view change including queued view change message delivered 
new master responsible execution sending commit message corresponding updates 
master replacement algorithm guarantees availability transactions presence failures 
transaction commit far available site 
consistency degree consistency sites failure case depends properties multicast messages send transactions sites 
algorithms transaction messages uniformly multicast 
case transaction messages just reliably multicast inconsistencies may arise 
reliable multicast possible master conflict class deliver transaction execute send commit message crash 
sites new view receive commit message transaction know process way 
possible uniform reliable multicast master execute transaction available sites received transaction able take event master crash 
algorithm commit messages uniform mere confirmation conflicting transactions committed total order 
order reduce transaction latency local transactions committed multicasting commit message committing commit message delivered 
worst happen scenario master commits transaction fails commit message reaches sites 
new master takes execute transaction send new commit message transaction commit system 
total order followed algorithm inconsistencies arise 
reordering algorithm commit messages uniform master sites reorder transactions 
commit message uniform master reorder transaction send commit message crash 
rest replicas see commit message different serialization order failed node optimistic order unknown sites 
uniform message delivery avoids master commit transaction commit message delivered sites 
recovery failed site synchronize state available sites 
practice accomplished installing snapshot database time view change 
recovered site receive messages delivered view change 
correctness section prove safety liveness properties algorithms 
safety property copy serializability bg 
liveness property states delivered transaction eventually commit 
basics facts help prove correctness algorithms 
transactions enqueued respectively rescheduled corresponding queues atomic step interleaving transactions 
sites produce serializable histories 
order conflicting transactions commit matches total order 
addition proofs follow assume histories encompassing views 
talking correctness conflict equivalence histories refer correctness available nodes 
correctness site produces serializable histories suffices show histories sites conflict equivalent 
done total order guideline 
definition direct conflict 
transactions direct conflict serialized respect gamma 
transactions serialized gamma 
gamma 
lemma total order serializability 
hn history produced site directly conflicting transactions hn gamma 
gamma 
hn proof lemma assume lemma hold pair transactions gamma 
hn gamma 
fact precedes total order means delivered direct conflict conflict class common 
words queue transactions entries 
gamma 
hn entry ahead queue 
transaction algorithm aborted rescheduled queue algorithm put ahead queue 
cases result gamma 
hn contradicts initial assumption 
lemma conflict equivalence 
sites running algorithm hn conflict equivalent hn proof lemma lemma pairs directly conflicting transactions hn hn ordered total order 
hn hn conflict equivalent set transactions order conflicting transactions way 
theorem 
history produced algorithm copy serializable 
proof theorem lemma histories available sites conflict equivalent 
serializable 
global history copy serializable 
liveness theorem liveness 
algorithm ensures delivered transaction eventually commits absence catastrophic failures 
proof theorem theorem proved induction position total order 
induction basis delivered transaction 
delivery site place head queues 
master execute commit send commit message remote sites 
remote sites apply updates commit induction hypothesis theorem holds delivered transactions positions definitive total order transactions gamma preceding transactions eventually commit 
induction step assume transaction position definitive total order delivered 
node places corresponding queues transaction delivered pending transaction delivered 
transactions ordered lower positions definitive total order 
commit induction hypothesis removed queues 
eventually queues induction basis eventually commit 
induction basis induction step master fails sites received commit new master transaction resend commit message 
consistency failed sites obviously receive transactions available sites 
subset transactions delivered node failed 
theorem consistency failed sites 
transactions committed failed node committed available nodes 
committed projection history conflict equivalent committed projection history available nodes history restricted transactions proof theorem show committed transactions committed available sites transaction committed delivered 
transactions delivered available sites know 
transaction local received commit message 
available sites received commit message commit transaction commit transaction new master takes executes transaction send commit message 
receive second message new master failed 
master take repeat procedure 
assuming available nodes eventually nodes master transaction commit 
transaction local argument applies 
equivalence histories follows directly lemma 
correctness reordering reordering algorithm possible total order guideline site decide reorder transactions 
site produces serializable histories 
prove histories conflict equivalent reordering algorithm produces copy serializable histories 
start proving transactions involved reordering get serializer transaction reordered 
serializer transaction transactions set ts lemma reordered 
reordered transaction serialized serializer transaction ts gamma 
proof lemma follows trivially algorithm 
lemma serializer 
reordering algorithm transactions ts transaction ts gamma 
gamma 
proof lemma assume master site reordering takes place 
serializer gamma 
opt gamma 
additionally lemma gamma 
cases consider gamma 
gamma 
case delivered reorder queues ahead queues committed commits 
serialized case delivered ts sites put ahead queues committed delivered case 
ts effectively prevents transactions getting transaction trying conflict delivered wait commits 
time committed master site commit message delivered processed sites final serialization order gamma 
gamma 
lemma conflict equivalence 
sites running reordering algorithm hn conflict equivalent hn proof lemma histories equivalent transactions order conflicting transactions way 
assume available see transactions 
see conflicting operations ordered way cases consider 
transactions involved direct conflict conflict classes 
distinguish cases ffl master assume gamma 
reorders respect total order lemma transaction serialized 
commit sent commit fifo order 
sites execute 
follows total order commit sites change order 
argument similar lemma revolves order transactions committed sites 
assume gamma 
cases apply exchanging 
ae case choice commit delivery order rules reordering apply 
type reasoning lemma follows sites commit order 
ffl master involved type reordering nodes lemma guarantees interleavings transactions involved reordering transaction 
transaction committed sites sites produce serialization order 
involved reordering delivery rescheduled total order sites committed 
follows sites produce serialization order 
ffl 
serialization order need considered equivalence 
serialization order indirect 
assume gamma 
gamma 
gamma 
pair transactions sequence direct conflict 
pair cases apply sites order pair way 
follows ordered way sites 
theorem reordering 
history produced reordering algorithm copy serializable 
proof theorem lemma histories conflict equivalent 
serializable 
global history copy serializable 
liveness reordering theorem liveness reordering 
reordering algorithm ensures delivered transaction eventually commits absence catastrophic failures 
proof theorem proof similar liveness proof algorithm induction position definitive total order 
induction basis delivered transaction 
delivery remote site place head queues 
local node reordered transactions ordered serializer 
executed committed eventually executed committed 
remote sites apply updates reordered transactions fifo order commit induction hypothesis theorem holds delivered transactions positions definitive total order transactions gamma preceding transactions eventually commit 
induction step assume transaction position definitive total order delivered 
cases reordered 
means serializer transaction position total order ordered induction hypothesis commits executed committed sites theorem holds 
reordered transaction 
rescheduled transaction pending transaction 
exist types transactions 
reordered transactions position commit removed queues induction hypothesis 
ii 
reordered transactions reordered transaction serialized transaction commit commit induction hypothesis 
transactions serializer ordered directly queues lemma 
reordered transaction set reordered transactions 
eventually commit induction hypothesis transactions 
failures lead masters reassignment introduce different cases ones 
consistency reordering subset transactions delivered node failed 
theorem consistency failed sites 
transactions committed failed node committed available nodes 
committed projection history conflict equivalent committed projection history available nodes history restricted transactions proof theorem transaction commit messages sent uniform reliable multicast transactions commit messages delivered available sites commit sites 
prove equivalence histories theorem follows directly lemma 
spite amount invested developing eager data replication protocols vast majority known protocols practice 
viable solutions started appear tighter synergy group communication primitives transaction management techniques 
approach entirely feasible crucial demonstrate improved optimized realistic application environments 
proposed replication protocols cluster applications 
protocols solve scalability problem existing solutions minimize number aborted transactions greatly improving throughput response time 
confident protocols form basis database replication techniques 
currently implementing experimentally evaluating protocols part deploy web farm replicated database built protocols 
aaas agrawal alonso el abbadi 
exploiting atomic broadcast replicated databases 
euro par conf passau germany august 
bg bernstein goodman 
failure recovery problem replicated databases 
proc 
nd symp 
principles distributed computing pages 
bhg bernstein hadzilacos goodman 
concurrency control recovery database systems 
addison wesley reading ma 
br birman van renesse 
reliable distributed computing isis toolkit 
ieee computer society press los alamitos ca 
gray neil shasha 
dangers replication solution 
proc 
sigmod pages montreal 
gr gray reuter 
transaction processing concepts techniques 
morgan kaufmann publishers san mateo ca 
ht hadzilacos toueg 
fault tolerant broadcasts related problems 
mullender editor distributed systems pages 
addison wesley reading ma 
ka kemme alonso 
new approach developing implementing eager database replication protocols 
acm transactions database systems appear 
ka kemme alonso 
suite database replication protocols group communication primitives 
proc 
th int 
conf 
distributed computing systems icdcs pages 
ieee computer society press 
kemme pedone alonso schiper 
processing transactions optimistic atomic broadcast protocols 
proc 
th int 
conf 
distributed computing systems icdcs pages 
ieee computer society press 
kemme pedone alonso schiper 
processing transactions optimistic atomic broadcast protocols 
technical report eth zurich department computer science 
pgs pedone guerraoui schiper 
exploiting atomic broadcast replicated databases 
reeve editors proc 
th international euro par conference volume lncs pages 
springer september 
ps pedone schiper 
optimistic atomic broadcast 
kutten editor proc 
th distributed computing conference volume lncs pages 
springer september 
