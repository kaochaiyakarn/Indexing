duality abduction model generation framework model generation equality marc denecker danny de schreye department computer science leuven celestijnenlaan heverlee belgium 
mail cs kuleuven ac duality relationship abduction definite abductive programs model generation part programs 
pointed console abductive solutions abductive program correspond models part 
extend observation showing procedural semantics abduction interpreted dually form model generation part 
model generation extends efficient treatment equality atoms occurring head rules 
illustrated duality allows improve current procedures abduction model generation transferring technical results known computational paradigms 
motivated progress field logic programming formalise abductive reasoning logic deduction 
kowalski presents intuition approach 
considers simple definite abductive logic program wheel flat wheel broken spokes flat punctured tube flat leaky valve predicates broken spokes punctured tube leaky valve abducibles 
query wheel abductive reasoning allows infer assumptions punctured tube leaky valve broken spokes supported belgian voor van contract rfo ai supported belgian national fund scientific research sets assumptions abductive solutions query sense kowalski points equally obtain solutions deduction transform abductive program fqg new logic theory transformation consists part definition non abducible predicate clark completion adding negation example obtain non horn theory wheel flat broken spokes flat punctured tube leaky valve wheel minimal models new theory wheel flat punctured tube wheel flat leaky valve wheel broken spokes restricting models atoms abducible predicates precisely obtain abductive solutions original problem 
observation points interesting issue possibility linking dual declarative semantics completely equivalent dual procedures 
shows duality sld abduction tree execution tree theorem prover model generation 
oe punctured tube lat broken spokes wheel leaky valve ff lat procedural duality abduction example illustrates potential deduction precisely model generation formalisation abductive reasoning obvious restriction example propositional 
approach hold general case definite abductive programs 
example non propositional program part 
theory consists part definitions predicates comprises axioms free equality feq known clark equality 
abductive solutions models displayed 
duals abductive solutions identical models 
example suggests duality level declarative semantics maintained 
abd fq feq 
predicate example delta fq fx ag delta fq fx bg delta fq sk fx fp fp fp sk abductive solutions models level procedural semantics difficulties arise 
sld abduction derivation tree 
residue obtain third abductive solution 
unification fails fx ag abductive derivation tree respect model generation problem clausal deal non clausal theories directly normalisation clausal form 
fortunately extension deal formulas directly 
second problem designed cope equality atoms occurring head generated models satisfy feq equality atoms occur head rules 
solution treat equality predicate add feq explicitly theory 
third problem arises feq range restricted form 
handle range restricted formulas 
theory transformed range restricted form 
performing transformation dealing technical details computation may obtain computation tree 
globally structure sld abduction tree seen tree 
striking duality variables abductive derivation skolem constants model generation 
difference tree comprises additional inference steps due application axioms feq 
abductive derivation additional steps correspond unification operation 
failure sk sk success sk sk substitution symmetry reflexivity 
symmetry transitivity oe sk sk fp sk sk sk sk sk bg execution tree left branches failure unification fx bg corresponds derivation inconsistency facts sk bg 
difference generated model fp sk sk sk sk sk sk sk sk sk sk sk sk sk larger model dual abductive solution 
generates atoms model logical implications feq comprising substitutions sk clear general lead exponential explosion 
observe obtain desired model contracting sk generated model 
extending methods dynamic contraction equal elements solve efficiency problem restore duality level declarative semantics 
contraction model done unique witness equivalence class equal terms replacing terms facts model witnesses 
turns techniques studied term rewriting useful implement 
idea consider set inferred equality facts term rewriting system trs transform set equivalent complete trs allows normalise terms model 
normalisation procedural way replace terms witnesses 
problem completion normalisation procedures term rewriting developed standard equality eq feq 
led develop framework model generation generic underlying equality theory section 
framework generalised notions completion normalisation wrt arbitrary equality theory 
instances framework implemented section 
instance model generator eq obtained embedding existing completion normalisation techniques term rewriting 
second instance model generator feq 
completion normalisation procedures developed feq section 
sight procedures may alien logic programming contrary true restore broken duality sld abduction ffl completion procedure corresponds dually unification 
dual mgu replacing variables skolem constants completion set equality atoms 
ffl normalisation corresponds dually applying mgu 
incorporating techniques restores duality level procedural semantics 
starting goal research reported investigate duality abduction model generation 
goal led second goal valuable right extension current techniques model generation efficient treatment equality 
presents answers goals 
spin offs 
illustration context planning abduction event calculus 
event calculus contains clause expressing property holds certain moment earlier event initiates property property terminated clipped holds happens initiates clipped planner uses clause introduce new events initialise desired property 
technically done happens goal 
requires explicit treatment equality predicate abducible satisfying feq 
techniques proposed allow efficient treatment abduced equality atoms provide declarative semantics 
structured follows 
section class theories model generation designed 
section recalls extends basic concepts term rewriting 
section framework model generation important semantic results formulated 
section duality abductive reasoning formalised 
section implementation framework 
section discusses related 
extended programs 
section introduce formalism model generation designed 
formalism contain theory obtained part definition clark completion definite logic programs 
extended clause formalism introduced generalises kind formulas clausal form 
definition order language 
extended clause rule closed formula type general form ym atoms non equality atoms definition extended program set extended clauses 
interestingly extended clause formalism proved provide full expressivity order logic 
order logic theory translated logically equivalent extended program sense share exactly models 
recall equivalence theory clausal form weaker theory consistent iff clausal form consistent 
refer appendix proof result 
sequel standard theory equality order language denoted eq 
theory functor non equality predicate symbol note extension constants eq identical eq 
theory free equality clark equality denoted feq 
extends eq constraints 
functor pair different functors xm xm term contains variable observe eq feq horn clause theories 
theory called theory equality comprises eq 
theory called equality theory theory equality predicate symbol formulas substitution axioms eq 
concepts term rewriting 
techniques intend develop dealing equality inspired term rewriting 
area restricted purposes concepts techniques assume general equality theory eq underlying term rewriting 
able deal feq extend basic concepts case arbitrary underlying equality theory sequel equality identity denoted distinctly ambiguity may occur resp 

overview basic notions tr see 
recall general ideas 
definition order language 
reduction rule form ffl terms ffl variable ffl variables contained logical meaning reduction rule 
procedurally axioms way direction term containing left hand term reduction rule reduced replacing subterm right hand term 
definition term rewriting system trs finite set reduction rules follows term rewriting systems denoted symbols fl ffi 
denote herbrand universe herbrand base language hu hb resp 
herbrand model theory lhm 
term rewriting system reduction relation terms associated 
definition reduction relation fl gamma 
binary relation set terms fl gamma 
iff exists reduction rule substitution occurs obtained replacing 
definition reflexive symmetric transitive closure fl gamma 
denoted fl restriction set ground terms hu denoted fl observe eq fl definite program herbrand model 
set ground atoms logical consequences eq fl 
property indicates relationship fl 
proposition fl lhm eq fl 
proof easy see fl satisfies axioms eq fl 
herbrand interpretation lhm eq fl 
fl 
vice versa interpretation lhm eq fl 
reflexive symmetric transitive fl gamma lhm eq fl 
fl lhm eq fl 
term rewriting system associates term reduction tree tree terms son iff fl gamma tree corresponds possible reductions root term 
noetherian term rewriting system property reduction tree finite 
confluent church rosser term rewriting system property pair nodes reduction tree exist paths leaving nodes leading identical term 
procedural point view noetherian church rosser trs satisfies desirable property reduction tree term finite leaves labelled term called normal form denoted fl 
normalisation operation extended atoms formulas sets natural way 
term reduced called normal 
term rewriting noetherian church rosser trs called complete 
extend concept underlying equality theory definition equality theory language fl term rewriting system fl complete wrt iff fl noetherian church rosser language extending constants fl 
herbrand model set ground atoms constructed terms hu fl 
extension third condition assures property complete language independent 
prove important remainder model generation skolem constants introduced dynamically 
definition extends normal definition term rewriting third condition 
eq proved condition implied noetherian church rosser properties see proposition 
case arbitrary equality theory feq 
example take language comprising constants take feq 
define fl fa bg 
fl noetherian church rosser feq fl inconsistent herbrand model 
term rewriting concentrates complete trss course eq underlying equality theory 
central themes tr validity problem trs fl terms decide eq fl 
general validity problem undecidable complete trs fl decidable eq fl fl 
interesting result motivated research tr develop methods transform trs logically equivalent wrt eq complete trs 
operation called completion 
best known oldest completion algorithm proposed knuth bendix 
problem finding complete trs set equations wrt eq general unsolvable validity problem solved 
completion ground trs wrt eq computed 
suffices purposes model generation ground instances rules applied equality sets completed ground 
remember section main goal introduce dynamic contraction model generation 
main reason introduce notion complete trs solve validity problem complete trs fl allows contract partially constructed model 
terms equal wrt eq fl normalisation term normalisation occur obviously equivalence class follows directly equivalence class contains precisely normal term 
normal terms taken unique witnesses normalisation procedure contract models replacing terms unique witnesses 
proposition basic properties complete trss explored 
proposition fl noetherian church rosser fl complete wrt eq 
fl complete wrt fl complete wrt eq 
fl complete wrt extending constants lhm fl 
lhm eq fl 
proof proof define fs tjs hu flg 
show fl 
observe fl gamma reduction tree occurs reduction tree fl 
subsumes fl gamma 
trivial see defines reflexive symmetric transitive relation fl vice versa clearly atom fl element fl 
symmetry transitivity fl pair terms fl implies fl 
fl 
proposition fl lhm eq fl find lhm eq fl 
iff fl 
fl complete wrt eq 
item direct consequence complete trs fl wrt noetherian church rosser fl complete wrt eq 
item follows directly 
fl complete wrt definition lhm fl 
lhm eq fl 
definition completion trs fl wrt ffl fl 
inconsistent ffl complete trs fl fl fl denote completion fl trs comp fl 
framework model generation developed logical theories consisting components extended program underlying equality theory distinction reflects fact model generation mechanism applies extended clauses dealt procedural way completion normalisation 
satisfy conditions definition 
definition equality theory completion language clausal equality theory equipped completion procedure ground trs extension constants produces ground completion 
section prove feq equality theory completion completion procedure dual unification procedure 
indicated earlier eq completion procedure variant knuth bendix procedure 
eq equality theory completion 
concept taken term rewriting unification 
definition terms fl trs 
unifier wrt fl substitution eq fl 
unifier atoms unifier tuples 
unifier set pairs atoms unifier pairs atoms 
framework model generation informally model generator constructs sequence cl cl ground instance rule applied th inference step index indicating cl selected increasing sequence sets asserted ground facts nonequality predicates sequence complete term rewriting systems fl denotes sequence 
equivalent set asserted equality facts increasing sequence sets skolem constants sk obtained existentially quantified variables 
substitution called normal wrt trs fl assigns normal terms variable 
normalisation substitution substitution obtained normalising right hand terms 
denote normalised substitution fl 
substitution called grounding open formula assigns free variable ground term 
instance extended clause obtained applying grounding substitution extended clause 
normal instance instance obtained applying normal substitution 
note imply terms normal instance normal 
terms assigned variables normal 
definition language sk infinite countable alphabet skolem constants occurring theory consisting extended program equality theory completion equipped completion procedure trs comp 
nondeterministic model generator equality nmge tuple sequences sk fl cl 
sequences satisfy conditions 
sk fg fl trs comp fg 
cl sk fl obtained sk gamma gamma fl gamma applying steps selection rule select nondeterministically rule substitution conditions hold form ffl grounding substitution normal wrt fl gamma sk gamma ffl exist atoms gamma unifier set wrt fl gamma define cl 
define sk fg fl select nondeterministically head cl define say rule cl applies th 
form ym replace ym fresh skolem constants sk skm sk gamma define sk sk gamma completion define fl trs comp fl gamma fs 
fl define 
normalisation assertion define gamma fl ff fl obtained computing normal form facts sets 
failed finite fl 
situation occurs cl negative clause fl gamma fs inconsistent 
failed called successful 
notice requires unifier body rule facts gamma proposition show feq underlying equality theory completion unification collapses unification unifier iff unifier 
example take eq underlying equality theory completion consider theory nmge obtained follows 
step rule selected completion computed 
returns fl ff ag 
second step derived third rule 
normal form fp third step derived second rule 
compute completion ff bg 
solution fl ff ag 
trs normalised fp point rules satisfied computation terminates finite model domain fag function maps fp identity relation notice model generator special treatment equality loop 
loop infinite number facts derived 
logical implications derived 
assume add axiom 
previous nmge extended fourth step 
fourth step unifier wrt fl computed 
empty substitution unifier atoms obtain failure 
notice model generator special treatment equality eventually derived application axioms eq 
general high number useless atoms derived 
observe feq underlying equality theory failure occur rule selected 
atom inconsistent occur check axioms 
example take feq underlying equality theory consider theory 

nmge selects clause 
variable atoms asserted 
produces model form fp sk sk sk second step second rule applied deriving equality atom sk sk sk 
completion atom obtained applying dual form unification yields fl sk normalisation obtain fp third step plugged third rule failure occurs 
language comprises functor feq comprises infinite number disequality axioms 
impossible model generator special treatment feq 
second theory consistent eq 
completion eq equality fact sk sk sk eq ff sk sk sk trs sk derived 
third rule applied 
lhm denotes herbrand model sk eq fl 
proposition lhm monotonically increasing sequence 
proof proposition uses lemma 
lemma equality theory completion fl term rewriting system ffi trs comp fl set ground non equality atoms normal wrt ffi fl ffi sk 
extension sk constants equalities hold lhm fl lhm ffi 
lhm ffi lhm eq ffi 
lhm eq ffi ffi hb ffi mg proof lemma follows straightforwardly equivalence fl ffi wrt proposition proposition substitution axioms predicates 
proof proposition lhm lhm sk eq fl lhm sk eq fl lhm sk fl 
lemma lhm sk ff fl fs 
lhm sk fl 
lemma lhm lemma nmge performs fixpoint computation result seen interpretation language show model 
definition skolem set nmge sk denoted sk 
lhm defines herbrand interpretation language sk denoted 
non herbrand interpretation obtained restricting symbols denoted defined follows ffl domain hu sk ffl functor function maps terms hu sk 
ffl predicate set facts 
corollary finite successful nmge length lhm generate models example empty nmge fg fg trs comp fg trivially satisfies definition nmge generate model contains positive extended clause extended clause empty body 
case empty nmge example unfair nmge exists rule true body applied 
definition nmge fair iff failed condition satisfied cl ground instance rule exists cl sk body cl holds lhm exists holds lhm procedural point view uninteresting apply rule head satisfied lhm gamma definition nmge redundant iff rule applied say step satisfied lhm gamma proposition establishes number basic results frequently section 
result assures head instance rule holds lhm holds lhm 
note head extended clause disjunction existentially quantified conjunctions atoms constitutes main difference proposition 
second result relates truth instance open formula truth normal instance formula 
third result indicates relationship fairness condition unification nmge body instance rule true wrt lhm iff instance obtained applying unifier body rule facts proposition herbrand interpretations extension resp closed formula negation universal quantifiers 

open formula grounding substitution lhm lhm fl 
fl denotes normalisation wrt fl 
ground instance rule sk unifier body atoms wrt fl iff body holds lhm proof items easily proved induction structure intuitively goes wrong negation universal quantifiers new fact ni may contradict negative fact new domain element hu may delete universal property item clarifies role unification appearing definition nmge 
assume body form unifier wrt fl pair arguments eq fl substitution axioms belongs lhm vice versa assume belongs lhm lemma exists fl pair terms follows unifier wrt fl theorem soundness fair successful nmge model consistent fortiori 
say model generated proof theorem proofs observation lemma extension theory interpretation restriction symbols model 
iff model 
proof lemma trivial validity formula wrt interpretation depends interpretation symbols formula 
proof theorem prove model 
lemma suffices show model sk 
consider sequences lhm lhm sk eq fl lhm sk eq fl sequences consist subsets herbrand base hb sk 
show union 
direction follows easily fact direction show lhm sk eq fl atom lhm sk eq fl 
contains finite number skolem constants hu sk 
fl fl lemma holds eq fl fl consequence occurs lhm 
monotonically increasing sequence herbrand models sk 
lemma 
known property clausal theories fixpoint monotonically increasing sequence models model 
clausal theory definition equality theory completion model sk 
remains proved model assume exists ground instance rule satisfied 
holds hold 
lhm monotonic exists lhm fair holds lhm proposition holds 
contradiction assumption 
state completeness result require additional concept nmge tree 
analogously concept sld tree nmge tree tree obtained applying different rule descendants node 
definition language equality theory completion extended program nmge tree tree ffl node labelled tuple sk fl sk skolem set set non equality facts sk fl ground trs sk 
ffl non leaf ground instance cl rule associated 
index head cl arc leaving labelled cl 
cl arc leaves label cl ffl sequence labels nodes arcs branch constitute nmge 
definition fair branch fair 
definition failed branch failed 
observe failed contains finite number nodes 
inconsistent soundness theorem fair failed 
completeness result want state model nmge contains branch generating smaller model 
context herbrand models smaller relation expressed set inclusion 
existential quantifiers resulting skolem constants restrict herbrand models 
order define smaller relation general models mechanism compare models different domain 
solution problem provided concept homomorphism 
definition interpretations language domains homomorphism mapping satisfies conditions ffl functor xji ji ffl predicate symbol intuitively homomorphism mapping domain positive information model maintained mapping 
homomorphisms class models theory represent contains positive information relation 
denote fact exists homomorphism interpretation notation captures intuition contains positive information prove powerful completeness result 
theorem completeness equality theory completion extended program 
exists fair non redundant 

model fair exists successful branch item proof concerned fairness condition 
condition fairness quite strong stated non constructive way 
proof provides construction fair nmge 
construction lemmas 
lemma states applying rule rule holds 
second lemma constructs sequence contains ground instance rule infinite number times 
sequence construct fair nmge 
starting clause element sequence tested rule violated satisfied 
violated rule applied 
way obtain fair nmge rule tested infinite number times applied violated 
lemma ground instance oe rule applied step oe holds lhm proof straightforward proof omitted 
lemma extended program sk countable alphabet skolem constants 
exists countable sequence contains ground instance rule sk infinite number times 
proof known result countable set set finite sequences set countable 
ground instance rule finite sequence countable set functor symbols sk logical connectors logical quantifiers brackets period 
set possible ground instances rules countable 
sequence contains ground instance rule sk time 
sequence easily transformed wanted sequence formally obtained concatenating finite sequences increasing proof theorem sequence lemma construct fair 
node starting root index associated points rule normalization applied obtain descendants obtained searching rule violated 
normalisation rule applied obtain descendants descendant defined technically construction proceeds induction depth nodes ffl root defined definition 
define gamma 
ffl non failed node depth index 
leaf branch associated sequences sk fl lhm cl look rule sk violated lhm exist anymore obtain finite fair branch leaf constructed tree 
form rule fl true body true body wrt lhm proposition 
proposition normal unifier wrt fl atoms body facts selected 
descendants obtained applying 
descendant define easy see non redundant violated rules applied 
fair rule cl language node violated rule reappears sequence time say th element 
strictly increases descendants non failing branch departing integrity restored gamma steps accident applying rules gamma applying normalisation lemma proposition 
prove second part completeness theorem 
idea proof follows 
construct induction path node path mapped th step selected rule true body selected rule hold extend path selecting descendant corresponding 
consequence mapped resulting branch returns fair nmge construct branch corresponding nmge sk fl cl sequence interpretations sk invariant relation holds extends assigning skolem sk element domain 
extends gamma assigning skolem sk gamma element domain 
model sk 
model sk fl 
branch induction depth ffl root defined clearly invariant relation holds 
ffl assume path length gamma gamma leaf definition descendants gamma obtained applying ground instance cl rule cl proposition hold herbrand model lhm gamma theory sk gamma gamma fl gamma 
invariant gamma model sk gamma gamma fl gamma hold wrt gamma gamma model model rule cl instance 
holds wrt gamma select th descendant gamma extend gamma ym variable assignment fy ym amg holds wrt gamma assigned skolem constant sk extend gamma defining sk clearly invariant relation hold 
direct consequence extension lemma 
holds seen follows 
extension gamma model sk gamma fl gamma 
lemma 
construction model fs ff easily verifies proposition holds gamma ff fl gamma fs fl model model fl construction returns successful branch fair fair nmge 
theorem model 
remains show homomorphism consistent predecessors sequence union sequence defines interpretation sk 
interpretation construct homomorphism define extending terms hu sk 
defined induction depth terms ffl constant sk 
ffl functor tuple terms hu sk 
construction trivially satisfies condition homomorphism 
second condition homomorphism atom hold 
assume 
exists lhm fl invariant 
extension 
equivalent definition truth atom wrt interpretation 
interpret relation holds 
construction fair theorem give clue implement fairness condition practical way 
problem dealt properly section 
corollary obtain reformulation traditional completeness result 
corollary consistent fair exists successful branch 
exists failed inconsistent fair failed 
completeness result imply models generated 
example fp qg model fp qg generated nmge 
example shows different theory generate different models 
example depending clauses applied get different non redundant 
applied holds applied anymore 
get branch length 
hand selected branches exist get solutions fpg fp qg 
interesting characterize class models generated 
second item completeness theorem gives indication model successful branch generates model positive information clausal case models redundant positive information minimal herbrand models 
observation expect clausal program fair generates minimal models 
completeness theorem holds theorem minimal herbrand models clausal fair minimal herbrand model generated branch proof easy clausal theory successful branch fair generates herbrand model necessary 
theorem follows minimal herbrand model exists branch herbrand models corresponds minimal follows return general case 
deal non herbrand models concept minimal model extended 
definition theory language model information content ic equivalent model exists homomorphism homomorphism model mm minimal iff model mm ic equivalent mm notion ic equivalence models weaker notion isomorphism 
consider fp exist different non redundant depending selection extended clause 
selecting rule obtains fp selecting rule yields fp sk models isomorphic ic equivalent ja defines homomorphism jh sk ja defines homomorphism straightforward ic equivalence defines equivalence relationship models model ic equivalent minimal model minimal 
definition generalization concept minimality herbrand models clausal theories easily prove theorem model minimal iff ic equivalent minimal herbrand model 
fair generates minimal models modulo ic equivalence modulo isomorphism theorem completeness minimal models fair class ic equivalent minimal models 
exists branch generating minimal model theorem straightforward consequence completeness theorem 
completeness theorem formulated complete finite satisfiability theory finite model generates finite model 
nmge satisfy property 
consider example theory theory infinite nmge generating model fp sk sk sk sk sk interpretation fp finite model 
generates finite infinite model 
distinction nmge caused distinct treatment existential quantifiers 
nmge existential variable 
hand keeps track domain interpretation assigns existing domain elements existential variable giving rise different branches computation introducing new skolem constant final alternative 
computation tree comprises equality atoms head occur consequence treatment existential variables nmge efficient showing inconsistency theory treatment suitable showing consistency theory 
noted main issue technique dealing equality stands orthogonal way existential quantifiers dealt 
techniques proposed incorporated procedure treats existential quantifiers 
duality sld abduction model generation 
nmge framework allows formalise observations 
prove feq equality theory completion completion procedure dual unification procedure 
introduce notion formally 
definition order language variables sk alphabet skolem constants occur mapping correspondence sk mapping extended mapping hu sk hb sk set terms induction depth terms ffl constant jc ffl term atom jf extended formula set formulas 
ground trs fl sk corresponds equation set fl terms definition ground trs fl said solved form iff fl equation set solved form 
equation set solved form iff consists equations distinct variables occur right side equation 
trs solved form left terms distinct skolem constants sk occur right 
trs solved form seen dual idempotent variable substitution 
proposition fl trs solved form 
fl complete wrt feq 
compound term holds fl fl constant 
proof item follows straightforwardly fact trs solved form contain compound terms left 
respect item intuitively clear term reduction tree finite leaves contain term 
said fl noetherian 
formal proof rely theorem term rewriting irreducible trss 
trs fl called irreducible iff fl normal form wrt fl normal form wrt tg 
clearly trs solved form irreducible 
proved irreducible trs noetherian church rosser 
proposition trs solved form complete wrt eq 
remains proved pair terms extension constants holds lhm feq fl 
iff fl 
define fs tjs hu flg 
fl complete wrt eq lhm eq fl 
feq extension eq holds lhm feq fl 
vice versa prove herbrand model feq fl 
suffices show satisfies axioms feq neq ffl assume fl 
item proposition directly follows fl 
belongs ffl item terms distinct main functors rewritten term fl 
ffl consistency occur check axioms proved 
assume exist pair terms fl contains item holds contains fl contains fl 
fl contains 
impossible 
theorem expresses procedural duality unification completion announced section 
notion procedural duality refers form isomorphism procedures 
procedure decomposable sequences basic operations 
isomorphism refers fact procedures activated dual input mapping resulting sequences basic operations input output corresponding operators dual 
theorem take unification procedure equality set input 
dual input ground trs obtained interpreting variables skolem constants dual unification completion 
theorem duality completion unification feq equality theory completion 
completion procedure dual unification 
dual completion ground trs fl extension constants mgu fl 
trs comp fl mgu fl 
proof algorithm dually reformulated 
symbol denotes skolem constant term denotes set equality atoms 
algorithm proceeds iteratively transforming trs fl applying rewrite rules skolem constant xj appears xj appear occurrence fx tg algorithm terminates rewrite rule applied 
termination follows directly termination dual algorithm 
returns trs ffi solved form 
proposition follows ffi complete 
see fl ffi equivalent wrt feq just verify rewrite rule maintains equivalence wrt feq 
call ffi solved form fl 
interesting property completion wrt feq incremental 
definition composition operation term rewriting systems solved form defined dual composition variable substitutions 
fl fl complete term rewriting systems dual substitutions fl ofl defined gamma 
proposition fl ffi ground trss fl completion fl ffi completion ffi fl ffi ofl completion fl ffi 
proof applying completion algorithm fl ffi possible transform fl solved form obtaining fl easily verifies transformation ffi transformed gradually ffi fl normalized form wrt fl result stage fl ffi fl completion proceeds bringing ffi fl solved form returns ffi similarly phase effect equations fl terms normalized wrt ffi total equation set fl ffi ffi fl notice result dual property unification mgu equation set oe mgu denotes set equations obtained applying sides equation oe mgu interesting practical point view unification wrt trs solved form collapses unification proposition fl trs solved form normal terms 
normal unifier wrt fl iff unifier proof assume normal unifier 
eq fl fl complete fl 
normal skolem constants left fl appear 
js 
unifier vice versa unifier trivial unifier 
direct consequence proposition step nmge process simplified replacing unification unification 
terms occurring gamma normal form wrt fl gamma terms body rule normal form wrt fl gamma observed duality unification completion extended complete process sld abduction 
procedure simple extension sld resolution definite abductive programs 
distinction defined predicates definition possibly empty set definite clauses head matching predicate abductive predicates definition 
sld abduction refutation finite sld derivation atoms defined predicates selected resolution final resolvent contains abductive atoms 
definite abductive program definite query describe sld abduction derivation length usual triplet sequences ffl resolvents ffl renamings program clauses sharing variables ffl substitutions derived gamma assume loss generality atom occurs body definite clause special predicate occur rename new predicate example eq definition consists unique clause eq sld abduction procedure takes input definite abductive program definite query 
define dual interpretation input 
recall query denotes formula form 
denotes formula 
definition definite abductive program definite query define dual pd extended program consists part definition completion feq fp abducible predicate pg 
example pair program query dual 
lemma pd range restricted extended program 
defined predicate rule occurs pd having unique atom body 
range restricted means universal variable occurs head occurs body 
lemma straightforward consequence definition 
duality sld abduction nmge suggested example section expressed formally 
informally selection defined atom corresponds dually selection instance rule having dual selected atom body 
clause definition corresponds associate selection clause selection rule 
unification selected atom head clause corresponds dually completion operation equality atoms selected 
application mgu resolvent corresponds normalisation 
lemma order language alphabet variables sk alphabet skolem constants disjunct sk mapping 
definite abductive program definite query sld derivation atom selected step unique rule pd corresponds clause corresponds 
oe unifier body gamma 
define cl sk fl follows cl cl oe sk fg sk gamma var fq fl fl fg fl gamma fg gamma fg atom tuple sequences sk fl cl defines nmge 
example consider successful sld abduction derivation 
sequence resolvents sequence fg fx ag sequence sk dual nmge fg sk sk sk sequence fl fg fg ag sequence derived facts dual nmge fg fp sk sk fp sk proof lemma checked straightforward case analysis operations occur resolution step nmge computation step 
correspondences easily shown 
selection atom resolvent clause correspond dually selection rule respectively 
need fact rule pd range restricted universal variable rule occurs body 
case additional choices instantiate variables occurring 
duality broken 
renaming program clause seen dual 
clauses query share variables 
computation mgu corresponds completion set equalities 
due fact completion computed incrementally lemma fact equation set solved unification corresponds exactly dual set equality atoms completed 
application mgu addition literals clause resolvent correspond normalisation assertion phase 
theorem definite query abductive refutation dually interpreted successful fair nmge set atoms generated model restricted abducible predicates dual abductive solution 
dual answer substitution restriction fl skolem constants dual variables query 
failed sld abduction derivation corresponds dually failed nmge 
fair sld abduction derivation corresponds dually fair nmge 
fair sld abduction tree corresponds dually fair nmge tree 
proof sld abduction derivation failed resolvent atom defined predicate empty definition chosen clause head unify atom 
case rule form 
nmge fails 
second case completion atoms returns nmge fails 
fair sld derivation atom occurring resolvent eventually selected 
implies dual nmge fair evident 
formally proof goes follows 
consider defined atom lhm corresponding definition define oe fx show lhm oe equivalent showing lhm oe fl proposition 
occurs lhm fl lemma 
possibilities exist lemma fl normalisation atom oe selected step earlier fl dual atom case lhm oe fl lemma proposition 
suffices prove oe fl joe fl oe fl fl fl oe fl 
identity oe fl oe fl follows straightforwardly equation fact substitutions domain 
find lhm oe fl take second case proven analogous way fairness sld derivation 
selection refutation fair refutation corresponds fair successful nmge 
previous results fair sld abduction tree corresponds fair 
happens drop feq 
case replace eq 
implies completion procedure feq dual interpretation unification replaced completion procedure eq example knuth bendix completion 
consequence declarative procedural duality model generation abduction ceases exist 
consider trivial program query sld abduction fail query corresponds dually fact feq inconsistent 
replace feq eq set fa extended model 
model corresponds abductive solution fa bg 
current abductive procedures return solution shows currently feq inherently current abduction lp 
corollary proved clark normal programs 
definite case follows immediately theorem 
corollary sld refutation query definite program abducibles consistency proof failed sld tree ground query inconsistency proof comp theorem indicates fair sld abduction tree branches correspond dually fair dually generate models 
finite branches generate abductive solutions 
case infinite branch duality broken 
trivial example situation 
consider definite program fp pg query sld refutation query exists sld tree consists infinite branch 
theory fp pg 
dual infinite fair nmge generates model fpg 
example shows infinite fair generate models correspond abductive solutions 
finite generate models corresponding abductive solutions 
unfortunately case 
consider nmge theory previous paragraph oe fpg 
finite fair nmge set abductive atoms model oe abductive solution 
important class definite abductive programs duality perfect definite abductive acyclic programs bounded queries 
programs queries sld abduction tree finite 
fact completeness theorem easy prove abductive atoms model dual theory form abductive solution 
implementing nmge implemented instances nmge framework feq eq 
model generator feq easy implement unification replaced unification proposition feq simple incremental completion procedure 
technical problems deserve special attention 
problem universal variables rule applied instantiated ground terms procedure matching bodies rules elements instantiates variables body 
circumvent problem requiring rules range restricted form universal variables occurring head occur body non equality atom transforming theory violating condition range restricted form 
done introducing domain predicate representing domain interpretation 
universal variable occurring body added body 
existential variable added 
addition rules form added functor 
second problem related fairness condition 
theorem proves fair exists clarifying implement condition 
solution adopted level saturation 
idea generate level level 
level associated fl normal instances rules violated lhm selected selected performed facts selected stored apart 
violated instances applied completion fl fl derived equality facts computed derived non equality facts added normalisation applied yielding second instance implemented eq underlying equality theory 
completion ground trs computed efficient algorithms exist 
eq equality theory completion 
prototype uses narrowing compute normal unifiers optimised form knuth bendix algorithm completion procedure 
model generator operates range restricted programs 
fairness condition implemented level saturation 
experiments systems promising 
show dynamic contraction implemented dynamic completion normalisation avoid exponential explosion looping due equality axioms 
discussion current limitation duality framework restriction definite abductive programs 
extend case normal abductive procedures 
extended framework describe duality sldnf abduction procedure form model generation 
sldnf abduction procedure proceeding definite case 
started pure sld definite programs abduction obtained nmge method yields sld abduction procedure 
performed informal basis sldnf normal programs abduction 
resulting model generation procedure gives natural extension sldnf abductive programs 
abductive procedure incorporates non ground abducibles goals efficient treatment abduced equality atoms methods earlier 
integrity constraints represented adding integrity constraint ic rule alse ic transforming rules normal program transformation lloyd topor adding literal false query 
prototype method implemented 
interesting experiment extension abductive planner event calculus 
prototype planner able solve hard problems context dependent events problems properly solved existing systems 
proved soundness procedure respect completion semantics sense query generated solution delta delta implies soundness procedure respect generalised stable model semantics generated solution extended natural way generalised stable model abductive program 
completeness result proved procedure generates minimal solutions computation tree finite 
related indicates relationship abduction model generation 
nature differs 
goal develop abductive procedure context updating deductive databases 
meta program proposed takes query abductive program input executed model generator generates abductive solutions 
takes alternative approach executing model generator directly 
allows explicit duality level abductive solutions generated models finegrained computational steps involved applied abduction model generation procedures 
meta approach part abductive program 
addition technical level equality atoms appear head meta program special treatment feq necessary 
approach taken abduction deduction 
abductive procedure normal abductive program query derives explanation formula equivalent completion comp explanation formula built abducibles predicates equality 
characterises abductive solutions sense set delta abducible atoms delta abductive solution iff satisfies approach departs concept completion totally different nature 
place approach aims contributing procedural semantics abduction 
case 
difference approach restricted queries finite computation tree 
computation tree contains infinite branch explanation formula computed 
abductive procedure normal abductive programs defined 
restriction method abducible goals selected ground 
poses serious problem applications planning 
methods allow overcome problem nonground goals efficient treatment abduced equality facts 
argued section planning non ground atoms introduce new events initiate desired goal 
planning system abduction event calculus proposed 
underlying abductive system incorporates negation failure non ground abducible goals efficient treatment abduced equality facts 
system shows problems respect soundness completeness 
experiments indicated problems solved prototype planner 
want draw attention unexpected application duality framework 
uncommon form abduction obtained feq replaced general equality eq equality predicate abducible 
form abduction 
take program fr program query successful abductive derivation 
delta fg delta fb ag succeeds abductive hypothesis fb ag 
duality framework provides technical support efficiently implementing form abduction 
difference normal abduction completion procedure feq dual unification replaced completion procedure eq example knuth bendix completion 
conclude duality computational paradigms 
duality allows transfer technical results paradigm vice versa 
application obtained efficient extension model generation equality 
transferring methods back abduction obtained techniques dealing non ground abducible goals efficient treatment abduced equality atoms 
discussed experiments indicating extension duality framework case normal programs useful obtaining abductive procedure normal abductive programs 
acknowledgments krzysztof apt eddy maurice bruynooghe francois bry helpful suggestions 
apt bezem 
acyclic programs 
proc 
international conference logic programming pages 
mit press 
bry 
intensional updates abduction deduction 
proc 
international conference logic programming pages 
clark 
negation failure 
gallaire minker editors logic databases pages 
plenum press 
console torasso 
relationship abduction deduction 
journal logic computation 
cox knill 
abduction logic programming equality 
proc 
international conference fifth generation computer systems pages 
cox 
causes events computation application 
proc 
th international conference automated deduction 
denecker de schreye 
family abductive procedures normal abductive programs soundness completeness 
technical report department computer science leuven 
denecker de schreye 
sldnfa abductive procedure normal abductive programs 
apt editor proc 
international joint conference symposium logic programming pages 
dershowitz 
completion applications 
proc 

dershowitz 
jouannaud 
rewrite systems 
handbook theoretical computer science vol chapter 
north holland 
eshghi 
abductive planning event calculus 
kowalski bowen editors proc 
international conference logic programming 
huet 
confluent reductions properties applications term rewriting systems 
journal association computing machinery 
kakas mancarella 
database updates abduction 
proc 
th large database conference pages 
kakas mancarella 
generalised stable models semantics abduction 
proc 
european conference artificial intelligence 
knuth bendix 
simple word problems universal algebras 
leech editor computational problems algebra pages 
pergamon press 
kowalski 
logic programming artificial intelligence 
proc 
ijcai 
lloyd topor 
making prolog expressive 
journal logic programming 
bry 
hyperresolution proof procedure implementation prolog 
proc 
th german workshop artificial intelligence pages 

martelli rossi 
algorithm unification equational theories 
proc 
symposium logic programming pages 
martelli montanari 
efficient unification algorithm 
transactions programming languages systems 

rewriting systems produced knuth bendix completion algorithm 
information processing letters 

localized abductive planning robot assembly 
proceedings ieee conference robotics automation pages 
ieee robotics automation society 
shanahan 
prediction deduction explanation abduction 
proc 
ijcai page 
shoenfield 
mathematical logic 
addison wesley reading mass 
snyder 
efficient ground completion log algorithm generating reduced sets ground rewrite rules equivalent set ground equations 
proc 
rd international conference rewriting techniques applications 
van emden kowalski 
semantics predicate logic programming language 
journal acm 
expressive power extended clause formalism 
prove order logic theory exists equivalent theory consisting extended clauses language extends finite set predicate symbols 
equivalence means model extended model vice versa restriction model symbols model implies conservative extension formula iff form equivalence stronger form equivalence proven theory clausal form consistent iff consistent 
result guarantee formula language iff hand formula language iff follows consistent iff consistent 
terminology 
denote tuples variables ym 
notation formula denote free variables denote fact sub formula strict sub formula set components formula defined set maximal strict sub formulas conjunction disjunction components negations universal existential formulas component 
sub formula exists linear chain formulas component notations explicit talking occurrences sub formulas sub formulas directly avoid problems case sub formula multiple occurrences 
set ff precisely set formulas depth depth formula recursively defined maximum depth components augmented 
occurs positive context occurs positively number formulas 
occurs negative context occurs negatively assume closed formula variable occurs precisely quantifier 
case renaming possible 
require formula contains connectors negation formula atom component 
known order logic formula transformed equivalent formula satisfies conditions 
section notion extended clause defined 
lemma gives characterisation 
lemma formula extended clause iff satisfies constraints ffl component negation atom ffl components conjunction atoms conjunctions ffl component existential formula atom conjunction existential formula ffl components disjunction atoms negations conjunctions existential formulas disjunctions ffl universal formula type component 
proof sketch proof 
extended clause formula form general form denotes atom 
straightforward extended clause satisfies syntactical constraints lemma 
vice versa assume satisfies syntactic constraints lemma 
proof induction depth formula 
idea follows induction hypothesis components known extended clauses 
satisfies constraints lemma type restricts type components 
simple case analysis suffices show extended clause 
example disjunction formula universal formula extended clauses 
form disjunction formulas form form strictly spoken commutativity associativity applied 
extended clause 
algorithm transforms theory extended program 
transformation proceeds iteratively replacing unwanted sub formula formula sub formula type allowed lemma atom new predicate adding formula relates new predicate replaced sub formula 
algorithm theory transformation algorithm defined follows 
initially set long contains unwanted formulas transformation step executed ffl select contains sub formula unwanted component 
ffl choose new predicate ffl define replacing 
ffl universal formula form universal formula define define ffl define ff theorem order theory 
transformation algorithm terminates 
produces extended program extension new predicate symbols 
equivalence holds model extended model 
restriction model symbols model 
sentence proof see algorithm terminates just check transformation step decreases number unwanted components 
resulting extended program trivial formula contains unwanted component 
proofs items simplify situation show obtained transformation step hold 
induction hold complete transformation process 
assume transformation step selects contains sub formula unwanted component free variables prove model 
extend extending truth function way variable assignment variables iff definition 
equivalence easy prove case universal formula proof relies equivalence holds disjunct 
prove lemma formulated proven assume contains sub formula positive context 
obtained replacing formula free variables 
tautology 
follows proof follows directly 
transformation procedure far optimal sense introduces large number new predicates 
general better result obtained pre processed distributing existential quantifiers disjunctions universal quantifiers conjunctions 
lemma formula containing sub formula 
formula obtained replacing occurs positive context implies 
occurs negative context implies 
proof proof induction depth wrt induction step implications easily proved example model theoretical way gamma gamma case occurs depth trivial 
assume lemma proved formulas occurs depth prove lemma formula occurs depth 
form occurs positively negatively depth negation occurs positively negatively depth induction hypothesis holds occurs negatively 
formula obtained substituting implications follows directly occurs negatively positively occurs positively negatively induction hypothesis holds occurs negatively 
implication negation implication switches 
lemma holds 

