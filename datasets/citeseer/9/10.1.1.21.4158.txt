incremental execution guarded theories giuseppe de giacomo universit di roma la sapienza hector levesque university toronto sebastian na university toronto comes building controllers robots agents high level programming languages golog congolog er useful compromise planning approaches low level robot programming 
serious problems typically emerge practical implementations languages evaluate tests program eciently open world setting appropriate nondeterministic choices avoiding full lookahead 
proposals literature suggest tackle rst problem exploiting sensing information tackle second specifying amount lookahead allowed explicitly program 
combine ideas demonstrate power presenting interpreter written prolog variant golog suitable eciently operating open world setting exploiting sensing bounded lookahead 
categories subject descriptors arti cial intelligence problem solving control methods search plan execution formation generation arti cial intelligence deduction theorem proving logic programming general terms theory languages additional key words phrases reasoning actions situation calculus agent behavior 
comes building controllers robots agents high level programming languages golog levesque congolog de giacomo er useful compromise planning approaches low level robot dedicate robert kowalski invented idea practice logic programming :10.1.1.54.7045:10.1.1.54.7045
golog descendants part family currently somewhat 
authors address de giacomo dipartimento di informatica sistemistica universit di roma la sapienza salaria roma italy dis uniroma levesque department computer science university toronto toronto canada hector cs toronto edu na department computer science university toronto toronto canada cs toronto edu 
permission digital hard copy part material fee personal classroom provided copies distributed pro commercial advantage acm copyright server notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior speci permission fee 
acm xxx acm transactions computational logic vol 
tbd 
tbd tbd tbd pages 

de giacomo levesque na programming 
high level program mean primitive instructions domain dependent actions robot tests involve domain dependent uents ected actions code may contain nondeterministic choice points 
serious problems typically emerge practical implementations languages evaluate tests program eciently closed world assumption cwa required appropriate nondeterministic choices execution trajectory entire program needs calculated ine 
de giacomo levesque guarded action theories require cwa permit ecient evaluation sensing information introduced de giacomo levesque incremental version golog proposed allow programmer specify parts program run ine explicit search operator run online foregoing full lookahead eciency purposes 
study amalgamation ideas version golog incremental deterministic golog language features congolog works open world setting guarded action theories ii allows programmer control online ine execution online case allows sensing information ect subsequent computation 
amalgamation propose simple implementation prolog interpreter incrementally execute programs guarded theories 
implementation provably correct suitable conditions 
structure rest follows 
section brie review situation calculus basic action theories 
section devoted guarded action theories section congolog programs 
section discuss programs executed incrementally 
section talk behaved histories programs sucient information executed 
section describe prolog implementation interpreter prove correctness section 
draw discuss section 
situation calculus basic action theories situation calculus mccarthy hayes second order language speci cally designed representing dynamically changing worlds changes result named actions 
language special constant denote initial situation actions occurred distinguished binary function symbol denotes successor situation resulting performing action relations truth values vary situation situations called uents denoted predicate symbols situation term argument special predicate oss state action executable situation instance uent loor may indicate elevator oor situation oss says possible go oor situation deal relational uents 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 
incremental execution guarded theories 
language formulate action theories describe world changes result available actions 
reiter action theories special form called basic action theories introduced 
basic action theories form set axioms describing initial situation contains precondition axiom action characterizing relation oss form oss oss occur 
set successor state axioms uent form state conditions holds function holds situation take place called ect axioms provide solution frame problem reiter 
una set unique names axioms actions 
set foundational domain independent axioms 
successor state axioms key theories provide axiomatization ects non ects actions encapsulate causal laws world 
example 
example successor state axiom states speci controller functioning doing action turning controller broken functioning action turning breaking 
fundamental tasks concerned reasoning actions projection task determining uent hold performing sequence actions 
projection clearly prerequisite planning high level program execution task levesque :10.1.1.54.7045:10.1.1.54.7045
observe basic action theories successor state axioms thought de ning truth value uent situation terms truth value uents previous situation 
characteristic notable impact reasoning basic action theories allows base projection special form evaluation regression reiter central computational mechanism ai waldinger plus inference initial situation 
result convenient way reasoning complete information initial situation 
free variables assumed universally quanti ed outside 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 

de giacomo levesque na 
guarded action theories basic action theories extended guarded action theories causal laws may complete sensing formalized explicitly theory de giacomo levesque 
assume robot number board sensors provide sensing readings time 
formally introduce nite number sensing functions unary functions argument situation 
syntactically sensing functions look functional uents assumed sensed values values returned sensing functions belong concrete domain possibly nite domain element domain unique term denotes 
examples sensing functions modeling available sensors robot thermometer returning readings onboard thermometer sonar returning values robot sonar returning depth measured onboard gauge observe approach change way look sensing moving known sensing actions see golden baral son levesque online board sensors data may may applicable 
de ne sensor uent formula formula language uses situation term variable term appears nal argument uent sensor function 
write sensor uent formula free variables formula results substitution vector terms situation term uent formula mentions sensor functions 
sensor formula sensor uent formula mention uents 
restrict attention sensor formulas easily evaluable values sensors 
guarded action theory basic action theory set successor axioms replaced new sets axioms set guarded successor state axioms axioms form uent formula called guard axiom relational uent uent formula 
set guarded sensed uent axioms axioms form sensor uent formula called guard axiom relational uent sensor formula 
guarded action theory uent number 
denote gssa gsfa sets uent observe completely general fact situation argument predecessor situation argument acm transactions computational logic vol 
tbd 
tbd tbd tbd 
incremental execution guarded theories 
example 
application elevator controller axioms reason state lights oor light light loor light sensor loor rst axiom gssa gives complete characterization uent light light controller working 
case oor light action turning oor light question action switching second axiom gsfa gives state light oor elevator uent loor interpreting value board sensor modeled sensor loor 
elevator oor possible conclude light oor checking value board sensor related sensing function sensor loor 
similarly uent loor gssa gsfa 
notice gssa solve frame problem compile restrictions loor functional 
observe general form guarded action theories allows ill formed theories 
restrict attention guarded action theories consistent acyclic 
de nition acyclic guarded action theories 
say depends exist gsfa mentioned guard 
gat said acyclic relation founded 
informally acyclic guarded action theories guards uent logically depend circularly 
allows safely consider evaluation guards sub projection tasks solved generalized regression see 
order take account values sensed sensors sensing functions called histories de giacomo levesque 
history sequence 

ground action term im vector sensed values ij understood reading th sensor th action 
history de ne ground situation term follows 

de ne ground sensor formula sensed ij sub history action 
th sensor function 
tells actions performed sensed tells sensing information 
de giacomo levesque form generalized regression roughly follows basic action theories takes account guards sensed values guarded action theories 
form generalized regression sensible compromise syntactic transformation history mean situation term extended encode sensing information 
confused similar notions narrative formalisms kowalski sergot baral 
fact situation calculus narrative approach hypothetical reasoning 
narratives situation calculus refer miller shanahan reiter 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 

de giacomo levesque na logical reasoning allows solve certain cases projection task ecient way 
prolog evaluation procedure mechanism 
general expect generalized regression complete form reasoning tautological sensor uent formula entailed entailed component uents regression applied 
practical setting imagine asking robot evaluate formula history knows component uents component uents 
general call history just time jit formula actions sensing readings contains guarantee suitable formulas including guards evaluated appropriate points determine truth value uents formula 
de nition just time histories formula 
history just time history jit history possibly open sensor uent formula background gat sensor formula directly evaluable history jit history jit history uent initial history uent gsfa jit history formula sensed uent 
gssa jit history sensed 
guarded action theories assumed open world jit history provides sort dynamic closed world assumption ensures truth value uent known part formula truth value need determine 
allows evaluate complex formulas normal closed world assumption 

congolog offline execution far considered kind theory intend model world dynamics 
addressed far strategy control sequence actions perform 
possibility de ne suitable goals planning achieve 
levesque argued high level program execution ered practical alternative complex domains plan synthesis :10.1.1.54.7045:10.1.1.54.7045
looking legal sequence action denote formula obtained quantifying universally free variables occurring 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 
incremental execution guarded theories 
achieving goal task nd legal execution high level program possibly includes nondeterministic steps 
high level programs provide blueprint just blueprint nondeterminism solution user gets control search ort required 
focus high level language congolog de giacomo extension golog levesque allows interleaved concurrency :10.1.1.54.7045:10.1.1.54.7045
congolog includes constructs possibly subscripted ranges congolog programs primitive action wait condition sequence nondeterministic choice actions nondeterministic choice arguments nondeterministic iteration proc recursive procedures synchronized conditional synchronized loop concurrent execution ii concurrency di erent priorities jj concurrent iteration interrupt primitive instructions congolog golog program primitive actions domain dependent ects non ects preconditions modeled background action theory 
nondeterminism achieved mainly programs form 
programs executed nondeterministically choosing executing 
programs executed nondeterministically picking individual performing program 
constructs synchronized versions usual 
synchronized sense evaluation condition rst action branch chosen executed atomic unit 
constructs behave similar way test set atomic instructions build semaphores concurrent programming 
construct denotes interleaved concurrent execution actions 
ii denotes concurrent execution actions having higher priority restricts possible interleavings processes executes done blocked 
observe general form prioritized concurrency 
full illustration various constructs refer de giacomo 
exogenous actions concurrent processes golog waiting amounts testing holds current state 
sake simplicity discuss recursive procedures 
fact interrupts de ned terms constructs language 
levesque non synchronized versions loops introduced :10.1.1.54.7045:10.1.1.54.7045
synchronized versions constructs introduced behave essentially non synchronized ones absence concurrency 
di erence striking concurrency allowed 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 

de giacomo levesque na example 
congolog golog involve concurrency program elevator serves lights light serve light 
nondeterministic choice arguments operator procedure nondeterministically picks oor tests light oor goes oor going nondeterministic number times serves opening door closing switching light 
program uses nondeterministic iteration operator repeat behavior zero times oor requesting served 
notice situation term removed uents high level programs assumed current situation happens conventional programming language 
formally congolog executions captured introducing predicates rans inal de ne single step transition semantics nielson nielson hennessy plotkin rans intended say program situation may legally execute step situation program remaining 
inal intended say program may legally terminate situation predicates de ne means execute program 
possibility de ne called ine interpreter interpreter searches successful execution entire program executing action levesque de giacomo :10.1.1.54.7045:10.1.1.54.7045
observe way execute program required example nondeterminism resolved favorably typically backtracking get program termination 
de ne ine interpreter rst de ne predicate follows rans inal rans second order de nition transitive closure rans considering binary relation pairs program situation 
ine interpreter looks situation logically implied action theory de nitions rans inal 
situation form sequence actions execute extracted 
say program admits successful ine execution situation exists ground situation term entailed action theory 

online execution usual congolog ine interpreter described actual sensed values exactly works ine 
alternative approach de ning form nondeterminism call nondeterminism see best 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 
incremental execution guarded theories 
called online interpreter searches legal step executes continues de giacomo levesque de giacomo 
clearly possible schema take account sensed values 
approach suitable context 
particular de ne online execution context follows 
de nition online execution programs gat 
online execution program starting history sequence axioms sensed rans 
sensor results online execution successful axioms sensed inal online execution unsuccessful axioms sensed inal program situation axioms sensed rans axioms denotes background theory plus set axioms de ning predicates rans inal see de giacomo 
shown absence sensing successful legally terminating online execution successful ine 
converse true example shows 
example 
consider simple program axioms axioms axioms oss 
admits successful ine execution axioms words ine interpreter may return sequence execute 
successful online execution single transition logically implied axioms axioms rans axioms rans 
usually interested nding successful executions interesting know unsuccessful sequence bad transitions derives dead 
successful online execution program form lookahead provision backtracking nondeterministic choice guarantee able follow words guarantee avoid reaching unsuccessful execution shown example 
example 
consider program 
assume axioms oss 
form lookahead prevents online interpreter choosing execute rst program execute action get blocked due fact hold resulting situation 
observe may happen spite fact second program admit successful online execution 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 

de giacomo levesque na observe backtracking question online executions actions performed real world 
concentrate form lookahead 
possibility perform full lookahead entire program de giacomo 
general appropriate put amount lookahead control programmer 
way programmer may ask explore search space signi cantly smaller possible nondeterministic executions entire program 
interleaving planning execution actions world sensing jonsson backstrom shanahan kowalski kowalski sadri baral suggests combination online ine execution programs arises practical powerful approach high level programs 
de giacomo levesque add congolog local lookahead construct looking successful ine execution parts program speci ed programmer 
construct called search operator rans inal de ned follows rans rans rans inal inal inal roughly speaking selects possible transitions situation exists sequence transitions leading nal con guration successful completion 
operator propagated remaining program restriction enforced execution example 
consider program light loor loor light 
says go nondeterministically chosen number times check highest oor light reached 
assume information axioms value test correctly determined reachable situation 
obviously unsuccessful online executions result getting oor satisfy test 
executing online result keeping going test satis ed result successful online execution 
observe principle nest search operators 
shown nesting search operators equivalent applying search operator 
assume nested search operators programs 
call incremental deterministic golog high level programming language resulting extending congolog search operator proviso programs designed executed online style 
study language background theories guarded action theories 

histories kinds histories sense purposes 
sequence actions particular action sequence acm transactions computational logic vol 
tbd 
tbd tbd tbd 
incremental execution guarded theories 
executed 
de nition 
history executable gat 
executable history sensed oss 
furthermore history executable consistent drawn 
may multiple axioms uent sure axioms consistent 
particular sensors provide information re ecting real state world robot knows door closed closing sensors tell door open closing action 
de nition coherent histories 
history coherent gat executable history sensed satis able 
coherent histories property rule possible sensor readings performing action preconditions satis ed 
legal sequence action reading sensors contradicting state world action 
proposition 
coherent history gat action sensed oss exists sensor reading vector history 
coherent model sensed oss gives interpretation sensors situation 
considering sensed oss sensed values interpreted concrete domains interpretation build sensor reading vector 
coherent observe consequence proposition guarded action theory consistent exists initial coherent history 
formalize meant guarded action theory reasoning sensors restricted situation 
situation sensors taken account 
de nition 
gat situation gat obtained replacing gsfa new gsfa relation means pre reiter 
observe kind allowed guarded action theories presence relation fact special form suitably restrict reasoning sensors needed 
de nition introduce notion jit histories revised version de nition 
note say action executable poss action holds 
considering possibility action fail executed real world 
see de giacomo ways deal failures 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 

de giacomo levesque na de nition just time histories formula revised 
history just time history jit history sensor uent formula sensor formula proviso mention sensing function jit history jit history uent initial history uent gsfa jit history formula sensed 
uent 
gssa jit history sensed 
de nition di ers de nition assume complete sensing information certain past situation 
agent may pre agent reasoning hypothetically feedback board sensors 
extend notion jit histories programs 
de nition just time histories program 
history jit history program gat action precondition axiom oss jit history formula 
jit history formula jit history jit history case sensed inal ii jit history programs jit history condition programs jit history program pair sensed rans extension jit history gat words history just time program jit history formula needs evaluated step 
search operator impose sophisticated requirement takes account search typically involves steps done ine sensed values available 
guarantees determine truth value test program needed regression avoiding general theorem proving 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 
incremental execution guarded theories 
particular performing lookahead require information needed search program 
words possible con guration reachable search just time belongs bad branch execution reaching nal con guration 

incremental interpreter developed simple incremental interpreter prolog implements online execution high level programs guarded theories action including sensing approximation search operator 
observe task fundamentally theorem proving certain rans inal formula follow logically axioms action theory sensing information obtained far 
exploit sort dynamic closed world assumption provided jit histories simplify theorem proving task evaluation 
interpreter divided parts evaluation test conditions implementation rans inal main loop 
evaluating test conditions said evaluation procedure compute projection task needed 
previous implementations levesque de giacomo de giacomo levesque procedure holds test held situation implementations relied cwa formulas evaluated :10.1.1.54.7045:10.1.1.54.7045
want rely strict cwa want correct execution programs 
de giacomo levesque evaluation procedure eval guarded theories 
give alternative prove soundness completeness section 
assume user provides set clauses corresponding domain description background guarded action theory fluent relational uent sensor sensor function init init neg uent 
closed 
gsfa gsfa 
assume sensor formula formed atomic formulas mentioning sensing function 
gssa gssa observe predicates gsfa gssa represent respectively situation argument suppressed 
deal sensing assume database sensor results history 
prolog database consists clauses sensor value sensor function history sensed practice ecient data structure storing changes sensor values 
represent sequence actions addition sensor database initial database progressed number actions 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 

de giacomo levesque na current history prolog lists 
predicates place code evaluation procedure follows deal negation conjunction existential quanti cation consider logical operators abbreviations eval neg true eval false 
eval neg false eval true 
eval true eval true eval true 
eval false eval false eval false 
eval bool eval bool 
eval true domain subv eval true 
eval false 
domain subv 
eval false 
fluent eval bool fluent bool bool 
relational operator eval bool rel op subf subf value op bool 
bool relational fluent value bool true init 
bool false closed init init neg 
bool gsfa eval true eval 
bool gssa eval true eval 
sensors replaced values subf sensor sensor 
subf sensor 
program predicate var sort provided user asserts variable var ranges set elements sort 
similarly predicate domain sort obj provided user denotes objects obj sort sort 
predicate subv implements substitution program formulas obtained substituting predicate rel op asserts term denotes binary prede ned relational operator op applied operands predicate value op asserts applying relational operator op operands gets truth value possible implementation predicates rel op op 
value op op call 
predicate eval determines truth value formula rst recursively reducing neg formulas atomic cases uents relational operator possibly involving sensors 
notice existential handled retrieving possible elements free variable 
uents eval uses acm transactions computational logic vol 
tbd 
tbd tbd tbd 
incremental execution guarded theories 
bool determine value uent history initial situation bool tries user provided value attempts nd gsfa gssa guard recursively evaluates true 
relational operators clause eval rst replaces sensing functions appearing operands values history 
note code deals relational uents straightforward accommodate functional uents modular way 
implementation rans inal clauses rans inal needed program constructs 
language constructs involve conditions evaluation procedure guarded action theories shown 
presence prioritized concurrency unsound transition may arise 
see consider program 
ii axioms axioms 
easy see execution program wait action 
succeed known hold know hold 
recall order execute lower priority program higher priority process completely blocked 
evaluation merely fails transition free execute allowing unsound transitions 
tackle problem secure evaluation procedure aborts execution top level determine truth value formula evaluated 
eval write unknown write abort 
consider code golog constructs 
sequence represented prolog list stands program star pi stands 
stands construct 
final 
final star 
final final final 
final final final 
final bool bool true final bool false final 
final bool bool false final 
final pi domain subv final 
trans final trans 
trans trans 
trans true 
trans trans 
trans trans 
trans pi domain subv trans 
trans bool bool true trans bool false trans 
trans star star trans 
trans true trans 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 

de giacomo levesque na trans prim action poss true 
restrict attention programs bounded sense evaluate open formulas 
restrict variables nondeterministic choice construct existential quanti cation range nite domain sort 
observe domain nondeterministic choice argument select possible element variable 
addition domain user needs give clauses prim action poss describe named actions corresponding precondition axioms 
list code congolog constructs 
conc stands program stands ii nally stands final conc final final 
final final final 
final 
trans conc conc ee trans ee 
trans conc conc ee trans ee 
trans ee trans ee 
trans ee trans ee 
trans 
trans conc trans 
show code interrupts easily de ned terms constructs 
tricky part rans inal search operator avoid potential presence sensing information inside local lookahead 
obtain simple quite ective version search operator 
prolog term search stands corresponding program 
final search final 
trans search search trans path 
look path path final 
path trans path 
brie implementation search operator tries nd nite sequence transitions leading successful execution 
search done ine actual action executed real world new sensing results acquired 
things means implementation able determine currently unknown uent known needed 
example suppose uent unknown performing action sensor provide correct value 
program search fail considered ine 
path nds cached reused long external actions intervene executed 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 
incremental execution guarded theories 
alternative program search ne sensor consulted search 
precisely deal issue practical way online execution 
relying fact usually limited amount sensing inside ine search think conditional plans calculated eciently suggested lakemeyer 
main loop top part interpreter deals execution actions world 
rans inal determine action perform execution 
indigo trans indigo 
indigo trans execute indigo 
indigo final 
step nd legal transition commit continue new history terminate successfully 
committing means execute new action world transition requires executing new action world implies getting new sensing results 
mentioned store values adding facts predicate sensor 
sample implementation just ask new sensing results user 
example may de ne predicate ask sensor asks value sensor situation history asserts new sensor fact code execute exec act ask sensors 
exec act write executed action write nl 
ask sensors sensor ask sensor fail 
ask sensors 
ask sensor write enter value sensor write nl write write nl write value read assert sensor 
observe retrieving sensor values action executed world may sensible ask required rst time demand execution program 
values typically useful 
observe easy modify interpreter deal exogenous events actions may occur part program instance actions performed agents nature 
particular may add de nition indigo clause indigo occurs act indigo act 
fact fully deal exogenous events de ne search operator anticipates exogenous events guaranteeing executability exogenous recall wait condition step involves new action 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 

de giacomo levesque na events turn 
de ning implementing search dealing exogenous events way remains open problem 

correctness interpreter nish show soundness completeness results interpreter 
proofs rely assumptions assume consistent guarded action theories coherent histories bounded programs nested search operators 
domain theory enforces unique name assumption una actions objects 
predicate subv correctly implements substitution programs formulas 
start centering attention soundness completeness results evaluation procedure 
set user provided clauses describing domain pd program union set clauses implementing evaluation procedure section pd plus clause td union rules implementing predicates rans inal rules section 
theorem soundness eval 
sensor uent formula free variable situation argument history 
assume sensors available sub history 
goal eval succeeds program pd computed answer true sensed ii false sensed 
includes clause corollary soundness 
assumptions theorem goal eval sound program state completeness result evaluation procedure 
recall notion jit histories formulas introduced section 
theorem completeness eval 
acyclic gat sensor uent formula free variable situation argument jit history sensors available sub history 
goal eval succeeds program pd answer true false 
corollary completeness 
stands true false goals program goal nitely sensing outcomes meaningless assume value outcomes 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 
incremental execution guarded theories 
fail may succeed abort top level 
succeeds answer true false goal succeeds nitely fails provided assumptions theorem apply 
important notice results relative slightly modi ed theories de nition determined availability sensor outcomes 
hard propagate soundness evaluation procedure trans final programs containing search 
theorem soundness rans inal search 
bounded program free variables mentioning search underlying gat 
history prolog variables 
assuming sensors available sub history program td trans succeeds sensed rans furthermore contain free variable 
trans nitely fails sensed rans final succeeds sensed inal final nitely fails sensed inal general programs executed online expect exactly 
exception arises search started sensing outcomes reason cases 
step understand search really behaves 
stated implementation just approximation de nition important capture sense sound 
lemma soundness search 
bounded program free variables underlying gat 
goal trans succeeds program td answer sensors available holds sensed rans sensed furthermore contain free variables 
goal final succeeds sensed inal goal final nitely fails sensed inal acm transactions computational logic vol 
tbd 
tbd tbd tbd 

de giacomo levesque na corollary generalizes theorem programs 
corollary soundness rans inal 
bounded program free variables underlying gat 
history prolog variables 
assume sensors available history program td goals trans final td sound sensed 
trans succeeds bound ground terms 
want study sucient conditions successfully evaluate tests programs 
recall concept jit histories programs de nition 
theorem weak completeness rans inal 
jit history bounded program underlying acyclic gat assume sensors outcomes available program td 
goal trans succeeds terminate sensed rans goal final succeeds sensed inal bounded programs sound weakly complete implementation rans inal 
observe non termination arise due search 
termination trans final guaranteed 

new high level programming language golog family main characteristics execution framework realistic previous languages large programs complex scenarios sensing information suitably exploited ii background theory allows open world theories causal laws need complete 
consider new step practical programming language agents 
interpreter described provably correct guarded action theories open world settings seen relies number assumptions 
serious limitation concerns bounded programs inconvenient dealing large sets elements added deleted dynamically enumerated 
instance may uent student denoting student situation students enroll withdraw dynamically 
cases clearly need evaluation procedure works free variables 
sucient guarantee soundness rans inal 
need drop prioritized concurrency construct evaluation complete free variables 
way non termination may arise nite sequence legal transitions 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 
incremental execution guarded theories 
add constraints new argument eval trans final 
procedures say things john mark peter student transition mark 
sound complete implementation rans inal keeping ability express open formulas 
observe search operator de ned essentially returns action execute guaranteed part successful execution 
alternatively may de ne search operator returns new program ready executed online containing search 
program resemble conditional plan constitute reasoned course action leading successful execution sensing information gathered 
lakemeyer general forms planning levesque may give insight tackle issue 
point way order exploit nondeterminism need form lookahead provided search operator 
apt krzysztof pedreschi 
reasoning termination pure prolog programs 
information computation 
apt bezem 
acyclic programs 
new generation computing 
apt pellegrini 
occur check free prolog program 
acm toplas 
baral gelfond 
representing actions laws observations hypotheses 
journal logic programming 
baral son 
approximate reasoning actions presence sensing incomplete information 
international logic programming symposium ed 
mit press port je erson ny 
best 
semantics sequential parallel programs 
prentice hall international series computer science 
clark 
negation failure 
logic data base gallaire minker eds 
plenum press new york 
de giacomo lesp erance levesque 
congolog concurrent programming language situation calculus 
arti cial intelligence 
de giacomo levesque 
incremental interpreter high level programs sensing 
logical foundation cognitive agents contributions honor ray reiter levesque pirri eds 
springer berlin 
de giacomo levesque 
projection regression sensors 
proceedingsof sixteenth international joint conference arti cial intelligence ijcai 
stockholm sweden 
de giacomo reiter soutchanski 
execution monitoring high level robot programs 
proceedings th international conference principles knowledge representation reasoning kr 

golden etzioni weld 
planning execution incomplete information 
tech 
rep uw cse department computer science engineering 
university washington 
april 
hennessy 
semantics programming languages 
john wiley sons chichester england 
jonsson backstrom 
incremental planning 
new directions ai planning rd european workshop planning ghallab eds 
ios press italy 
kowalski 
meta logic reconcile reactive rational agents 
meta logics logic programming apt turini eds 
mit press 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 

de giacomo levesque na kowalski sadri 
logic programming multi agent systems 
annals mathematics arti cial intelligence 
kowalski sergot 
logic calculus events 
new generation computing 
lakemeyer 
sensing line interpreting golog 
logical foundations cognitive agents contributions honor ray reiter 
springer berlin 
levesque 
planning presence sensing 
proceedings thirteenth national conference arti cial intelligence aaai 
american association arti cial intelligence portland oregon 
levesque reiter lesperance lin scherl 
golog logic programming language dynamic domains 
journal logic programming 
mccarthy hayes 
philosophical problems standpoint arti cial intelligence 
machine intelligence 
miller shanahan 
narratives situation calculus 
journal logic computation 
nielson nielson 
semantics applications formal 
john wiley sons chichester england 
plotkin 
structural approach operational semantics 
tech 
rep technical report daimi fn computer science department aarhus university denmark 
reiter 
frame problem situation calculus simple solution completeness result goal regression 
arti cial intelligence mathematical theory computation papers honor john mccarthy lifschitz ed 
academic press san diego ca 
reiter 
narratives programs 
principles knowledge representation reasoning proceedings seventh international conference kr 
morgan kaufmann san francisco ca 
shanahan 
sort computation mediates best perception action 
logical cognitive agents contributions honor ray reiter levesque pirri eds 
springer verlag 
waldinger 
achieving goals simultaneously 
machine intelligence 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 
incremental execution guarded theories 
proofs occur check free floundering free need terminology mode ary predicate symbol function mp ng positions mapped called input positions positions mapped called output positions intuitively queries formed predicate expected input positions occupied ground terms 
write mp form mp mp 
family terms linear variable occurs 
clause input output linear family terms occurring input output positions body linear 
input output speci cation program set modes predicate symbol clause goal moded variable occurring input position body goal occurs input position head output position earlier body goal variable occurring output position head occurs input position head output position body goal 
goal viewed clause head interested goals atom program called moded input output speci cation clauses 
de nition moded program constrains ow data clauses program 
lastly clause goal strictly moded moded output linear program strictly moded rule proved apt pellegrini corollary moded output linear programs input output speci cation occur check free goals 
proven corollary program occur check free goal strictly moded 
lemma 
program pd domain description occur check free queries form eval ground terms variable 
proof 
prove pd strictly moded 
select mode assume value sub rel correctly implemented 
eval domain rel value sensor subv subf bool fluent sensor init closed gsfa gssa mode pd moded strictly moded 
goal moded strictly moded ground terms 
generalization corollary apt pellegrini general programs pd occur check free goal lemma 
query eval pd tree nodes marked 
proof 
appeal theorem apt pellegrini pd moded predicate symbols occurring pd moded completely input pd fgg 
predicate symbols occurring pd init sensor moded completely input 
lemma 
program td domain description occur check free queries form trans final ground terms variables 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 

de giacomo levesque na proof 
extend input output speci cation proof lemma follows trans final path write poss prim action inspecting rule verify td moded extended mode 
clause td output linear goals clearly moded 
conditions apt pellegrini corollary satis ed td occur check free goals 
lemma 
queries trans final program td ground terms variables 
proof 
predicates occurring 
moded completely input 
second output position grounded 
soundness completeness section need terminology 
mapping ground atoms general logic program set natural numbers called level mapping ground refer set variable free instances clauses atom atom atom preceded respectively 
program acceptable exists level mapping 
model clause ln ground case jaj jl program acyclic level mapping 
clause ln ground case jaj jl proved acyclic programs acceptable 
goal bounded level mapping 
exists number denotes maximum 
takes set variable free instances constant called rigid bounded 
apt pedreschi theorem proved sldnf tree including course trees bounded goal acyclic program nite 
corollary showed acceptable program bounded goal derivations goal program nite prolog interpreter terminates proofs rely lemmas guarantee programs occur check free free corresponding goals 
proof theorem 
assume eval succeeds prove eval sound induction number calls eval nite tree 
allow sub history converse 
base case call eval goal call ground atomic sensor formula sonar relational uent initial history 
case distinguish di erent situations sensor formula mentions sensing function ii sensor formula mentions sensing function 
example action terms compared walk case soundness eval easily justi ed precisely model satisfy conditions deal properly negated atoms 
take advantage restrictions proofs explicit 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 
incremental execution guarded theories 
virtue clark theorem clark 
second case evaluation sensor formula succeeds due fact sensor nitely fails history extending eval replaces sensing functions values available soundness follows 
formula uent history initial soundness justi ed clauses init implementing induction step call eval new induction structure formula performed 
base case arise uent history initial 
case eval reduces bool 
means third fourth rule bool succeed 
case apply rst induction hypothesis evaluation guard condition gssa selected get soundness evaluation uent 
hand third clause bool applies induction hypothesis formulas selected gsfa 
case worth pointing evaluation sensor formula corresponding gsfa question succeeds evaluation done history 
recall sensor outcomes available history sensor formulas built atomic formulas mentioning sensing function 
induction step formula atomic performed rst rules eval complex formula decomposed atomic components 
clearly step number calls eval reduced rst induction hypothesis applied 
proof corollary 
direct theorem clause 
proof theorem 
prove theorem parts prove acyclic prolog terminates goal eval tree nite 
program mainly acyclic sense apt bezem forced subtle termination condition acceptable programs apt 
de ne level mapping 
program pd starting mapping formulas sequence actions jp jp jpj jpj jf level ground uent jaj jrj ground action term jtj ground atomic formulas including sensing functions level stands highest level mapping guards sensor formulas mentioned gsfa 
formally level max fj jg termination mean succeeding nitely failing 
words consider aborting legal termination 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 

de giacomo levesque na guard ground instance th gsfa uent situation variable suppressed corresponding sensor formula 
important level mapping formulas de ned theory action acyclic dependency relation uents founded 
de ne level mapping remaining atoms 
rst de ne constant gat denoting highest level mapping formulas involved theory 
formally max fj jg fj jg denotes number uent names theory guard ground instance th gsfa gssa situation variable suppressed th uent corresponding sensor formula uent formula axiom 
complete level mapping pd follows jpj jhj jpj jhj jpj jhj jpj jhj jpj jhj jtj atoms possible show program pd acceptable level mapping model stronger acyclic condition apt bezem satis ed clauses bool 
instance third rules eval true jhj jp jhj true jp jhj true jpj jhj rel jpj jhj jpj jhj op value op bool jsj jhj jsj jpj jvj jhj jvj jpj interesting cases arise rules bool 
need condition distinguishing acyclic programs acceptable ones 
consider ground instance clauses bool 
follows prove facts imply satis es appropriate requirement 
show existence model pd say just point gsfa gssa correspond gsfa gssa respectively domain theory notice gssa gsfa simply database clauses 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 
incremental execution guarded theories 
fact jaj jb follows trivially jf jhj ajh jf ajh fact suppose jaj jb jaj jb fourth bool rule inequalities ajh jf jhj jgj jhj true ajh jpj jhj notice gssa formulas gssa jgj jpj hold 
similarly inequalities rule bool jf jhj level jhj jgj jhj jgj jhj true jpj jhj jpj jhj gsfa formulas corresponding gsfa de nition level know level jgj level jpj 
intuitively key point due fact acyclic de nition de ne de ned level mapping level uent higher level guards sensor formulas mentioned 
shown program pd acceptable level mapping 
model easy check goal eval rigid bounded 
corollary apt argue prolog interpreter terminates goal relying fact program occur check free lemmas 
prove jit history formula call eval nitely fail 
proved induction number calls eval 
base case easy formula evaluated atomic sensor formula relational uent initial history 
induction step assume theorem holds tree calls 
cases formula compound ii formula relational uent 
rst case straightforward formula decomposed simpler formulas history remains jit subdivision 
interesting case formula relational uent jit 
applicable gsfa gssa sense jit history de nition de nition 
gsfa applicable induction hypothesis applied third rule bool 
similarly gssa applicable induction hypothesis applied fourth rule bool 
case bool succeed relational uent history call eval 
goal eval succeeds computed answer true false 
proof corollary 
direct theorem clause 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 

de giacomo levesque na proof theorem 
induction number calls trans final 
base case trans program primitive action check condition final program empty program non deterministic iteration program 
take rst case trans rule td trans prim action poss true rst sub goals refer database relations retrieve precondition axiom primitive action 
success third sub goal implies corollary action executable 
trans sound jh ground bound ground terms 
hand trans happens nitely fail primitive action precondition false 
third sub goal nitely failed corollary easy see false succeed 
induction step tree call program complex 
constructs prioritized concurrency proof simple relies theorem formula evaluated 
interesting cases happen trans final nitely fail case prioritized concurrency 
trans succeeds program ii case trans succeeds ii nitely fails trans succeeds induction applied easily 
ii nite failure allows state exists transition addition success trans induction hypothesis gives soundness program ii see case trans nitely fails 
suppose trans nitely fails program history 
inspecting eligible clause know true nitely failed 
argument case false soundness trans follows 
notice unknown call aborted top level nitely failing 
proof lemma 
assume goal trans search succeeds search clearly case trans succeeds follows theorem sensed rans contain free variables 
addition goal path succeed sensors available implies sequence zero successful calls trans ended successful call final 
length sequence zero final succeeds sensors available 
theorem search sensed inal sensed 
assume length sequence 
trans succeeds sensors available history theorem sensed rans 
path succeeds steps sensors available 
induction sensed sensed follows 
proof soundness inal direct final clause search theorem 
acm transactions computational logic vol 
tbd 
tbd tbd tbd 
incremental execution guarded theories 
proof corollary 
follows directly soundness programs containing search theorem soundness search lemma 
proof theorem 
divide proof parts start proving jit history program containing search prolog interpreter terminates goals trans final 
rst concentrate program td pd set rules search trans final path 
fortunately appeal acyclicity condition apt 
ground program term number primitive complex actions mentioned de ne level mapping 
program follows jpj jpj jpj jpj atoms mapped zero 
veri ed program acyclic goals form rigid bounded level mapping 
generalize result complete program td giving simple arguments safely include set rules rules implementing search search clause ii safely include program pd code evaluation procedure plus domain description formula needs evaluated corollary applies words eventually terminate legally 
lemmas assure programs goals occur check free 
weak completeness result proved search 
assume program form mentions search history sensor outcomes available jit history program 
hard part realize trans succeeds goal path terminates loops forever 
suppose path performed sequence consecutive transitions querying goal path soundness trans theorem sensed rans extension jit history program circumstance fact search know part goals final trans terminate legally nitely failing succeeding 
follows goal path terminates legally nitely failing succeeding loops forever result original goal trans 
putting parts assuming nested searches weak completeness result general programs follows 
received august revised february accepted march acm transactions computational logic vol 
tbd 
tbd tbd tbd 
