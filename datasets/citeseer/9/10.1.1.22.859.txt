ecient generation shared rsa keys dan boneh matthew franklin cs stanford edu franklin cs ucdavis edu describe ecient techniques number parties jointly generate rsa key 
protocol rsa modulus pq publicly known 
parties know factorization addition public encryption exponent publicly known party holds share private exponent enables threshold decryption 
protocols ecient computation communication 
results honest curious settings passive adversary 
keywords rsa threshold cryptography primality testing multiparty computation 
ecient protocols number parties jointly generate rsa modulus pq prime 
computation parties convinced product large primes 
parties know factorization show parties proceed compute public exponent shares corresponding private exponent 
techniques require number steps including new distributed primality test 
test enables parties test random integer product large primes revealing primes 
cryptographic protocols require rsa modulus pq participants know factorization 
example original fiat shamir authentication protocol parties modulus know factorization 
examples see 
usually modulus unknown factorization obtained asking dealer generate 
dealer trusted reveal factorization results eliminate need trusted dealer parties generate modulus 
threshold cryptography concrete example shared generation rsa keys useful 
give brief motivating discussion refer survey 
pq rsa modulus signing veri cation exponents respectively de mod 
threshold rsa signature scheme involves parties enables subset generate rsa signature message 
subset parties generate signature 
standard secret sharing signature generated having reconstruct private decryption exponent simple approach obtaining threshold signature scheme follows pick random satisfying mod give party high level sign message party computes mod sends combiner supported darpa contract holds secrets 
combiner multiplies obtains signature 
way parties able generate standard rsa signature having reconstruct private key single location 
clearly advantageous securing sensitive private rsa key certi cate authority 
constructions providing rsa threshold signatures schemes :10.1.1.134.1633:10.1.1.9.2061
important issue left discussion initial generation rsa modulus shares traditionally modulus shares private key assumed generated trusted dealer 
clearly dealer compromises dealer forge signatures 
results eliminate need trusted dealer parties generate private shares 
results previously known elgamal public key system rsa 
organized follows 
give high level description protocol section 
sections explain various stages generating modulus pq unknown factorization 
section describe protocols public exponent generate shares corresponding private key mod 
resulting sharing sharing shares needed private key 
defend loss shares shares scheme 
allows subset users apply private key explain obtain sharing section 
discuss various practical improvements protocol section 
note generic secure circuit evaluation techniques generate shared rsa keys 
primality test represented boolean circuit 
general techniques inecient 
communication privacy model number parties engaging distributed rsa key generation protocol 
assume 
communication privacy model assumed protocol follows full connectivity party communicate party 
private authenticated channels messages sent party party private tampered en route 
achieved having share secret key encryption integrity authentication 
honest parties assume parties honestly protocol 
protocol threshold parties information factor generated modulus 
called honest curious scenario 
frankel mackenzie yung showed protocol robust malicious parties 
collusion protocol private 
coalition size learns information factorization pq 
coalition recover factorization 
reason bound reliance bgw protocol steps algorithm 
bgw protocol provides information theoretic security limited achieving privacy honest parties model 
note considering static non adaptive adversaries 
stern gilboa showed achieve privacy rsa modulus generation replacing bgw steps protocol oblivious transfer 
bgw replacement protocols proven secure security underlying oblivious transfer mechanism 
protocols ecient bgw 
note achieve privacy rsa modulus generation replacing bgw steps heuristic protocol due cocks 
unfortunately cocks protocol slower security heuristic argument 
prove security properties privacy satis ed protocol provide simulation argument components 
simulation shows inputs outputs protocol participants simulate transcript protocol 
learn new transcript 
see information simulation arguments 
overview section give high level overview key generation protocol 
parties wish generate shared rsa key 
wish generate rsa modulus pq public private pair exponents 
mod 
factors bits 
computation public shared parties way enables threshold decryption signatures 
parties convinced product primes coalition parties information factors revealed 
high level protocol works follows pick candidates steps repeated twice 
secret choice party picks secret bit integer keeps secret 
trial division private distributed computation parties determine divisible prime bound details section 
step fails repeat step 
denote secret values picked rst iteration second iteration 
compute private distributed computation parties compute 
value step reveals information secret values details section 
public parties perform trial divisions test divisible small primes range bound 
test parties engage private distributed computation test product primes 
test fails protocol restarted step 
note test protocol private applies parties involved 
details section 
key generation public encryption exponent parties engage private distributed computation generate shared secret decryption exponent details section 
notation adhere notation 
rsa modulus denoted product bit primes denote share possession party similarly shared parties denote share sent party performance issues protocol generates random numbers tests pq product primes 
prime number theorem probability simultaneously prime asymptotically ln 
naively perform probes average suitable 
somewhat worse expected probes needed traditional generation rsa modulus rst generates prime probes second prime probes 
degradation performance usually unacceptable typically 
fortunately trial division things aren bad 
trial division step tests prime individually 
analyze protocol analyze ectiveness trial division 
suppose random bit number passes trial division test primes tested 
take 
constant prime 
classic result due debruijn shows asymptotically pr prime trial division ln ln ln bits ln probability prime approximately 
consequently traditional rsa modulus generation requires probes protocol requires probes 
eleven fold degradation performance unfortunate manageable 
discuss methods avoid slowdown section 
generation shares step protocol party uniformly picks random bit integer secret share 
prime taken sum shares 
sum uniform independent random variables uniformly distributed picked distribution slightly entropy uniform 
show problem 
sum log bit number 
easily show chosen distribution bits entropy signi cant bits uniformly chosen bit string 
log bits lost entropy help adversary easily guessed number parties small certainly 
formally stated lemma 
second issue fact shares leak information factors instance party knows argue information help adversary 
issues raised dealt lemma 
set rsa moduli pq output protocol parties involved 
assume log lemma suppose exists polynomial time algorithm random chosen distribution shares hp parties factors probability exists expected polynomial time algorithm factors integers assuming hardness factoring lemma shows adversary private shares parties factor modulus generated protocol 
proof lemma somewhat tedious appendix distract reader main thrust 
privately computing products group rst review simple protocol due benaloh 
nite group 
write group action multiplicatively 
suppose parties wish compute revealing information secret shares benaloh protocol private works follows step party chooses random elements example party pick random set step party sends party step party receives shares party computes sends parties 
step party receives computes required product observe protocol party correct product protocol private coalition users simulate transcript protocol 
kg coalition size symmetry may assume sg 
coalition view protocol hy hy simulator simulates transcript picking random elements picking random elements satisfying perfect simulation transcript coalition learns new 
see details 
distributed test detailed discussion protocol distributed test step section 
party secret bit integers parties know pq 
wish determine product primes revealing information factors refer test distributed test 
test probabilistic test carried quadratic extension section assuming mod resulting pq blum integer 
arranged ahead time having party pick shares mod 
parties pick shares mod 
describing test brie discuss structure quadratic extension 
working group tn zn suppose prime factors equal mod 
case irreducible zn zn quadratic extension zn linear polynomial zn invertible gcd 
follows elements tn viewed linear polynomials zn gcd 
linear polynomials zn represent element tn ag distributed test step parties agree random value known parties 
step party computes jacobi symbol protocol restarted step new random chosen 
step party computes mod parties compute mod parties protocol section compute mod check mod test fails parties declare product primes 
step parties perform fermat test group tn zn carry fermat test tn parties pick random tn party computes parties compute parties protocol section compute check test fails rejected 
declare success 
mod mod exponents computation step guaranteed integers division 
correctness privacy protocol proved lemmas 
lemma pq integer mod 
product distinct primes success declared invocations protocol 
parties declare product primes probability random choice 
proof observe step protocol test mod amounts testing mod suppose distinct primes 
step verify 
implies odd mod mod follows mod prime follows test step succeeds 
similarly show distinct primes test step succeeds 
mod polynomial root quadratic extensions respectively 
follows group order 
similarly jt 
chinese remainder theorem tn jt 
conclude tn satisfy 
consequently test step succeeds 
prove converse suppose pq product distinct primes 
prime 
ds factorization distinct primes 
set exponent step 
note odd mod 
de ne subgroups fg zn fg mod ng note subgroup set closed multiplication see observe mod odd follows mod 
prove lemma show jhj jgj 
prove rejected step probability subgroup suces prove proper containment prove existence cases consider 
case 
suppose 
distinct prime factors mod pair exist pigeonhole principle 
prime factor distinct quadratic non residue modulo de ne zn element satisfying mod mod mod mod mod 
observe odd mod mod consequently mod case 
suppose gcd 
exists odd prime divides divides implying divides 
follows exists element order odd divides know divide 
consequently mod implying mod case 
way pq fall cases distinct primes bigger case handles prime power 
symmetry may assume 
cyclic group order contains element order follows contains element order mod divisible consequently mod case 
left case pq mod mod know mod 
case may happen show case step test fail probability half choice tn 
de ne group fh tn 
show jh jt subgroup tn suces prove proper containment exhibit element tn group order 
contains element order follows exists element tn order assumption mod know divide 
divide 
proves tn nh completing proof lemma 
note step protocol needed lter integers fall case 
integers pass steps 
example consider integers pq 
odd prime 
integers de ned body proof 
consequently integers pass steps product distinct primes 
rejected step probability section give alternate approach ltering integers fall case 
lemma shows product distinct primes test protocol reveals information private shares participants 
lemma suppose distinct primes mod 
coalition parties simulate view testing protocol 
consequently protocol private 
proof prime know mod de ned step protocol 
de ned step 
coalition parties 
coalition view consists hn vi intermediate values generated protocol section 
construct perfect simulator coalition view follows 
simulator input coalition input protocol started 
simulator starts picking picking random 
sets 
mod mod follows quadratic non residue zn jacobi symbol 
uniformly distributed elements jacobi symbol 
distribution identical distribution induced protocol required 
note quadratic residue zn 
simulator picks random tn computes values values input 
simulator generate simulating trivial 
simulate recall rst part proof lemma mod implies mod implies sign determined quadratic residue modulo simulator simply sets established simulator protocol section simulate intermediate values generated protocol 
conclude product distinct primes set values hn vi produced simulator indistinguishable real transcript 
consequently coalition learns information protocol 
note step protocol crucial 
condition step fail reveal factorization prime 
note practice probability non rsa modulus passes iteration test far half 
alternative step step distributed protocol necessary lter integers fall case proof lemma 
describe alternative simpler approach lter integers 
requires computation communication parties 
observe falls case gcd 
alternative step directly test condition 
test condition information leakage parties 
party picks random zn keeps secret 
protocol section compute mod leaking information private shares parties check gcd 
rejected 
bgw method section approach private 
fall case rejected 
product distinct primes pass test overwhelming probability 
note alternate test eliminates valid rsa moduli moduli pq prime mod distributed computation describe computation step section 
party secret wish product public revealing information private shares revealed knowledge bgw method goldwasser wigderson describe elegant protocol private evaluation general functions parties 
full technique overkill simple function mind 
adapt protocol computation hand minimize amount computation communication parties 
prime 
stated arithmetic operations done modulo protocol works follows step party picks random degree polynomials satisfying words constant term set coecients chosen random similarly party picks random degree polynomial satisfying 
step party computes values party privately sends triple hp party note standard shamir secret sharings holds step point party hp party computes 
mod party broadcasts parties 
step point parties values polynomial mod observe de nition furthermore polynomial degree 
note de ned 
consequently parties points interpolate discover coecients 
party evaluates obtains mod parties learn correct value description protocol clear parties learn value note protocol requires parties involved 
case exactly parties linear polynomials protocol private 
lemma shows coalition parties learns information private shares 
statement holds information theoretic sense complexity assumptions needed 
completeness sketch proof lemma refer detailed discussion protocol 
lemma coalition parties simulate transcript protocol 
consequently protocol private 
proof sketch set symmetry may assume coalition parties 
follows consistently index vary index vary index vary coalition view consists hp ni 
simulate coalition view simulator input 
rst picks random 
degree degree 
computes 
picks random independent elements computes picks random degree polynomial satisfying completes simulation setting 
values perfect simulation coalition view 
protocol consists phase full bgw method 
di ers bgw protocol need degree reduction step 
combine addition multiplication stages phase 
resulting computation surprisingly ecient 
essentially multi precision multiplication performed party step 
bgw modulo non primes description bgw protocol arithmetic operations carried modulo prime coming sections useful run bgw protocol working modulo non prime parties wish compute mod integer necessarily prime 
easily show prime divisors smaller protocol lagrange coecients interpolation step exist 
lemma remains correct 
running protocol modulo containing small factors requires slight modi cation 
write 
prime factors smaller prime factors smaller mentioned protocol immediately works modulo problem working modulo shamir secret sharing basis bgw possible 
instance consider case 
possible shamir secret sharing parties contain points shamir secret sharing party unique point 
simple solution run entire protocol algebraic extension contains points 
simulation argument immediately extends case 
general factor prime factors run protocol large extension factor 
chinese remainder theorem recover value mod sharing nal outcome cases section wish parties evaluate function result additively shared parties publicly available 
computation party mod information revealed private shares nal result 
modi cation bgw order achieve goal immediate 
parties perform step protocol perform broadcast described step 
consequently point polynomial degree evaluates 
lagrange interpolation know mod appropriate lagrange coecient 
broadcast step party simply sets resulting additive sharing required 
simple simulation argument showing minority parties obtains information protocol 
trial division section consider trial division step step section 
integer shared parties 
small prime 
test divides party picks random bgw protocol described section compute qr mod 
qr divide furthermore unknown minority parties qr provides information note approach bad candidate rejected 
unfortunately candidate rejected 
divide possible qr mod 
alleviate problem repeat test twice small prime 
probability candidate rejected caveat approach bgw protocol described section applied test divisibility small reason small eld contain points shamir secret sharing parties 
small run bgw protocol extension eld contains elements explained section 
shared generation public private keys parties successfully construct rsa modulus pq may wish compute shares mod encryption exponent approaches computing additive shares rst works small say ecient requiring little communication parties 
second works ecient requires communication 
section set 
rsa exponent know gcd 
recall public modulus satis es observe party locally compute compute shares parties invert modulo exposing 
unfortunately traditional inversion algorithms extended gcd involve computations modulo know eciently perform modular arithmetic modulus shared participants 
fortunately trick computing mod reductions modulo 
compute inverse mod steps compute mod 
set 

observe mod 
set easily verify mod 
mod 
observation need reductions modulo 
methods rely observation 
small public exponent describing ecient technique generating shares public exponent small 
protocol private 
leaks value mod small 
step parties jointly compute value mod mod possible compute revealing information private shares 
benaloh protocol additive group described section 
step mod explained 
party locally computes 
result step sharing enables shared decryption equality mod party determine value trying possible values trial decryption 
approach leaks mod total log log bits 
information help opponent correctly guessed time ek 
value trial decryption party rst picks random message zn computes mod asks parties decrypt party computes mod sends result party 
performing multiplications party nds satisfying mod updates setting mod 
arbitrary public exponent previous technique second method generating shares works arbitrary public exponent ecient leaks log bits 
information help opponent easily guessed 
simple modi cation protocol shows generate leaking information 
modi cation protocol somewhat ecient 
exposing mod inverting show invert mod shared parties 
result information revealed 
protocol private 
step 
party picks random step 
protocol section parties compute 
mod computation known parties 
invertible modulo protocol restarted step 
step 
party locally computes mod observe mod parties share mod revealing information secret shares 
step 
parties agree prime ne 
view shares elements modi ed bgw protocol section compute additive sharing mod party minority parties learns information 
step 
regard integers objective ensure integers know step sp candidate value party set sp correct equality holds integers 
determine correct protocol proceeds step possible value trial decryption step succeeds 
step 
assuming equality holds integers know divides see observe mod party sets bt ec 
result mod party determine value trying possible values trial decryption 
protocol leaks value total log bits exposed 
player determines value updates described section 
determine procedure repeated candidate values recall typically small 
observe step protocol needed due fact bgw method carried modulo possible carry bgw protocol step directly integers avoiding step altogether 
done variant shamir secret sharing integers see 

party picks polynomials degree follows 
constant terms set coecients chosen random interacting parties party computes point polynomial integers 
points multiplied appropriate lagrange coecients additive sharing integers 
unfortunately approach resulting shares private key order protocol 
results factor slowdown threshold signature generation 
positive side need leak value need search repeating step multiple times 
computation mod steps technique due bar ilan beaver 
gennaro halevi introduced alternate protocol inverting number modulo shared modulus 
protocol leaks secret information ecient protocol 
cost resulting shares larger 
sharing previous subsections explain obtain sharing defend loss shares desirable sharing enabling subset parties apply private key 
simplest solution due rabin generic technique converting sharing private rsa key sharing scheme 
rabin approach immediately applies sharing obtained 
optimizations describe practical techniques improving performance distributed protocol 
optimizations incorporated implementation protocol 
sieving step protocol section parties repeatedly pick random shared integer nd divisible small primes 
engage interactive trial division protocol 
brie outline ecient approach 
product odd primes bound suppose parties generate additive sharing random integer party set share rm random number appropriate length bit integer 
resulting candidate prime random bit integer relatively prime need run trial division protocol primes question remains parties generate additive sharing random integer party generates random element mod random element parties bgw method modi cation described section convert multiplicative sharing additive sharing 
caveat bgw method zm eld 
done discussed section 
load balancing step test party computes mod parties compute mod notice roughly bits bits 
consequently party works twice hard parties 
things sense test candidate parallel 
tests role party played di erent party 
way mod computed di erent party results better load balancing improving performance factor 
parallel trial division recall computed parties perform trial division invoking distributed test step section 
parties perform trial division parallel party charge verifying divisible set small primes 
eciently done hard coding primes range list 
party charge testing divisible primes mod factor speedup enables larger bound increasing ectiveness trial division 
fermat lter need run full test section candidate modulus fermat test rst proceed perform full test fermat test succeeds 
refer test mod fermat test 
equality hold product distinct primes 
carry test zero knowledge parties locally compute mod protocol section compute mod test mod protocol easily shown private 
saves computation jacobi symbol integers avoiding quadratic slowdown section noted protocols su er quadratic slowdown comparison single user generation rsa key 
main reason primes generated 
brie outline potential solution 
consider case parties alice bob carol 
generate alice hp bit prime 
bob hq bit prime 
carol hr number probes prime just single user generation able avoid quadratic slowdown 
furthermore single party knows complete factorization resulting unfortunately approach doesn scale 
enable privacy product primes 
drawback parties perform distributed test verify product primes 
techniques easily generalize enable test 
results test modulus shared parties product primes revealing factorization 
summary open problems techniques allow parties generate rsa modulus pq parties convinced product primes factor method achieves privacy 
show show parties generate shares private decryption exponent allow threshold decryption 
test product primes distributed double primality test 
note test extended triple primality test enabling parties test product primes revealing information factors 
demonstrate ectiveness protocols implemented 
generating bits shared rsa key mhz pentium machines takes seconds 
total network trac mb 
communication encrypted authenticated ssl 
see description implementation detailed timing measurements 
protocol works parties involved key generation 
generate distributed key parties 
due reliance bgw protocol steps 
stern gilboa showed replace bgw steps alternate protocol achieves privacy 
techniques protocol generate shared rsa keys parties 
note frankel mackenzie yung showed protocol robust malicious parties 
important open problem generation shared rsa keys special form 
example modulus product strong primes prime considered security purposes technical reasons related threshold cryptography 
currently techniques enable shared generation moduli special form 
progress directions helpful 
shoup robust threshold rsa signature scheme 
distributed key generation algorithm generating shared secret key scheme 
unfortunately currently possible 
shoup scheme requires modulus product strong primes 
mentioned distributed generation modulus currently open problem 
strong primes inherently required shoup scheme 
modifying shoup scheme rely strong primes remove current requirement trusted dealer 
acknowledgments don beaver helpful discussions anonymous reviewers suggestions improved presentation 
alon galil yung dynamic veri able secret sharing proc 
rd annual european symposium algorithms esa springer verlag lncs pp 

bar ilan beaver non cryptographic fault tolerant computing constant number rounds proc 
th annual acm symposium principles distributed computing podc pp 

beaver security fault tolerance communication complexity distributed systems ph thesis harvard university may 
ben goldwasser wigderson completeness theorems non cryptographic fault tolerant distributed computation proc 
th annual acm symposium theory computing stoc pp 

benaloh cohen secret sharing homomorphisms keeping shares secret secret advances cryptology crypto springer verlag lncs pp 

blackburn blake wilson burmester galbraith shared generation shared rsa keys tech 
report corr available www math uwaterloo ca boneh franklin ecient generation shared rsa keys extended advances cryptology crypto springer verlag lncs pp 

boneh horwitz generating product primes unknown factorization proc 
rd algorithmic number theory symposium ants pp 

carter wegman universal classes hash functions comput 
syst 
sci 

gennaro halevi computing inverses shared secret modulus advances cryptology eurocrypt springer verlag lncs pp 

chaum cr damg ard multiparty unconditionally secure protocols proc 
th annual acm symposium theory computing stoc pp 

cocks split knowledge generation rsa parameters available author cliff cocks gov uk 
de bruijn number elements sieve eratosthenes proc 

akad 
vol 
pp 

reviewed leveque reviews number theory vol 
section 
desmedt frankel yung share function securely proc 
th annual acm symposium theory computing stoc pp 

desmedt threshold cryptography european transactions telecommunications related technologies vol 
july august pp 

desmedt di burmester multiplicative non abelian sharing schemes applications threshold cryptography advances cryptology asiacrypt springer verlag lncs pp 

desmedt frankel shared generation authenticators signatures advances cryptology crypto springer verlag lncs 
elgamal public key cryptosystem signature scheme discrete logarithm ieee transactions information theory 
feige fiat shamir zero knowledge proofs identity journal cryptology vol 
pp 

fiat shamir prove practical solutions identi cation signature problems advances cryptology crypto springer verlag lncs pp 

frankel practical protocol large group oriented networks advances cryptology eurocrypt springer verlag lncs pp 

frankel gemmell mackenzie yung optimal resilience proactive public key cryptosystems proc 
th annual ieee symposium foundations computer science focs pp 

frankel gemmell yung witness cryptographic program checking proc 
th annual acm symposium theory computing stoc pp 

frankel mackenzie yung robust ecient distributed rsa key generation proc 
th annual acm symposium theory computing stoc pp 

franklin haber joint encryption message ecient secure computation journal cryptology 
gemmell threshold cryptography cryptobytes technical newsletter rsa laboratories vol 

gennaro jarecki krawczyk rabin robust ecient sharing rsa functions advances cryptology crypto springer verlag lncs pp 

gennaro jarecki krawczyk rabin secure distributed key generation discrete log cryptosystems advances cryptology eurocrypt springerverlag lncs pp 

gilboa party rsa key generation advances cryptology crypto springer verlag lncs pp 

goldreich micali wigderson play mental game proc 
th annual acm symposium theory computing pp 

goldwasser micali knowledge complexity interactive proof systems siam computing vol 
pp 

gordon strong primes easy nd advances cryptology eurocrypt springer verlag lncs pp 

quisquater practical zero knowledge protocol tted security microprocessor minimizing transmission memory advances cryptology eurocrypt springer verlag lncs 
malkin wu boneh experimenting shared rsa key generation proceedings internet society symposium network distributed system security pp 

micali rogaway secure computation advances cryptology crypto springer verlag lncs pp 

ohta okamoto modi cation fiat shamir scheme advances cryptology crypto springer verlag lncs 
ong schnorr fast signature generation fiat shamir scheme advances cryptology eurocrypt springer verlag lncs pp 

pederson threshold cryptosystem trusted party advances cryptology eurocrypt springer verlag lncs pp 

stern generation shared rsa keys parties advances cryptology asiacrypt springer verlag lncs pp 

rabin probabilistic algorithm testing primality number theory vol 
pp 

rabin simpli ed approach threshold proactive rsa advances cryptology crypto springer verlag lncs pp 

shamir share secret comm 
acm vol 
pp 

shoup practical threshold signatures advances cryptology eurocrypt springer verlag lncs pp 

solovay strassen fast monte carlo test primality siam journal computing vol 
pp 

wegman carter new hash functions authentication set equality comput 
syst 
sci 

yao generate exchange secrets proc 
th annual ieee symposium foundations computer science focs pp 

proof lemma set rsa moduli pq output protocol parties involved party picks bit shares assume log lemma shows adversary private shares parties factor assuming hardness factoring non negligible fraction rsa moduli 
lemma suppose exists polynomial time algorithm random chosen distribution induced protocol shares hp parties factors probability exists expected polynomial time algorithm factors integers proof algorithm works repeating steps factored pick random independent bit integers hp run algorithm input hp show integers expected polynomial number iterations algorithm output factorization protocol generating rsa modulus pq induces distribution element generated picking random bit numbers hp hq outputting product sums 
slightly restrict choice disallowing values close boundaries largest smallest 
total weight elements disallow suciently small hurt probability factoring remaining 
show remaining algorithm succeeds factoring essentially algorithm shortest interval pr distribution choice random bit integers hp prime 
set contains possible prime factors produced protocol close boundaries 
de ne fp 
random chosen protocol pr random shares generate algorithm factor probability follows exists subset pr algorithm succeeds factoring probability choice random bits 
show algorithm factor expected polynomial time 
size contains elements consider hypothetical algorithm takes integer pq input 
algorithm identical algorithm invokes algorithm range range 
algorithm restarts iteration picking new random hp note assuming algorithm knows clearly succeeds causing algorithm factor di erence algorithm applies lter prior running runs 
show algorithm cause succeed expected polynomial time 
pq de ne distribution pn tuples bit integers hp follows distribution pn obtained uniformly picking tuple hp tuples sum outputting hp de ne qn similarly 
know pr pn qn factors observe distribution pn qn identical distribution algorithm feeds algorithm succeeds factoring polynomial time ltering step take long 
remains show ltering step take long 
integer range 

range possible values produced protocol 
question probability random tuple hp bit integers satis es range 
de nition implies probability ltering step applies expected number tries ltering step satis ed consequently algorithm runs polynomial time 

