guided tour approximate string matching gonzalo navarro dept computer science university chile blanco santiago chile dcc uchile cl www dcc uchile cl survey current techniques cope problem string matching allowing errors 
relevant issue fast growing areas information retrieval computational biology 
focus online searching edit distance explaining problem relevance statistical behavior history current developments central ideas algorithms complexities 
number experiments compare performance different algorithms show best choices case 
conclude directions open problems 
focuses problem string matching allowing errors called approximate string matching 
general goal perform string matching pattern text suffered kind undesirable corruption 
examples recovering original signals transmission noisy channels finding dna subsequences possible mutations text searching presence typing spelling errors 
problem general form find positions text pattern occurs allowing limited number errors matches 
application uses different error model defines different strings 
idea distance strings small strings erroneous variant error model 
goal survey overview state art approximate string matching 
focus online searching text preprocessed build index explaining problem relevance statistical behavior history current developments central ideas algorithms complexities 
consider variants problem interest 
number experiments compare performance different algorithms show best choices case 
conclude directions open problems 
unfortunately algorithmic nature problem strongly depends type errors considered solutions range linear time np complete 
scope subject broad forced specialize focus subset possible error models 
consider defined terms replacing substrings varying costs 
partially supported 
light problem minimizing total cost transform pattern text occurrence equal reporting text positions cost low 
best studied particular cases error model called edit distance allows delete insert replace simple characters different strings 
different operations different costs costs depend characters involved speak general edit distance 
operations cost speak simple edit distance just edit distance ed 
case simply seek minimum number insertions deletions replacement strings equal 
instance ed survey surgery 
edit distance received lot attention generalized version powerful wide range applications 
despite existing algorithms concentrate simple edit distance easily adapted generalized edit distance pay attention issue 
algorithms exist general error model consider generalizations edit distance algorithms 
hand algorithms designed edit distance easily specialized cases interest 
instance allowing insertions deletions cost compute longest common subsequence lcs strings 
simplification received lot attention variant allows replacements hamming distance 
extension edit distance transpositions replacement form ab ba cost 
transpositions important text searching applications typical typing errors algorithms exist handle 
algorithms edit distance easily extended include transpositions keep track fact 
edit distance far best studied case survey focuses basically simple edit distance 
pay attention extensions generalized edit distance transpositions general substring replacement simplifications lcs hamming distance 
addition pay attention extensions type pattern search algorithms allow mention possibility search extended patterns regular expression allowing errors 
point covering 
ffl cover distance functions fit model substring replacement 
different focus loose cohesion 
hamming distance short survey nav reversals ks allows reversing substrings block distance tic eh ukk lt allows rearranging permuting substrings gram distance ukk finding common substrings fixed length allowing swaps aal hamming distance despite simplification edit distance covered specialized algorithms exist go simplification existing algorithm edit distance 
ffl second consider pattern matching sequences symbols generalize pattern regular expression 
extensions approximate searching multidimensional texts short survey nby graphs nav approximate searching mm byn nav byn considered 
areas developed algorithms easy grasp approximate pattern matching simple model understood 
existing algorithms problems borrow 
ffl third leave aside non standard algorithms approximate probabilistic parallel algorithms tu kar ajs agm ll lv 
ffl important area leave aside survey indexed searching process building persistent data structure index text speed search 
typical reasons prevent keeping indices text extra space requirements indices approximate searching tend take times text size volatility text building indices quite costly needs amortized searches simply inadequacy field indexed approximate string matching quite immature speedup indices provide satisfactory 
indexed approximate searching difficult problem area quite new active ju gon ukk mye hs mw cob st byn nby nby 
problem important texts handle large applications online algorithm provide adequate performance 
virtually indexed algorithms strongly online algorithms understanding improving current online solutions interest indexed approximate searching 
issues left aside keep reasonable scope 
certainly deserve separate surveys 
goal survey explain basic tools approximate string matching extensions leaving aside built basic algorithms designed online approximate string matching 
organized follows 
section detail important application areas approximate string matching 
section formally introduce problem basic concepts necessary follow rest 
section show analytical empirical results statistical behavior problem 
sections cover interest trace approximate string matching edit distance 
divided sections correspond different approaches problem dynamic programming automata bit parallelism filtering algorithms 
section historical tour explain done show developed 
section presents experimental results comparing efficient algorithms 
give discuss open questions directions section 
exist surveys approximate string matching old fast moving area hd sk ag gg definitive form 
previous surveys lack coverage latest developments 
aim provide please confuse approximate algorithm delivers suboptimal solution suboptimality guarantee algorithm approximate string matching 
approximate string matching algorithms regarded approximation algorithms exact string matching maximum distance gives guarantee optimality case harder find approximate matches course motivation different 
long update 
partially nav coverage previous detailed 
subject covered albeit depth textbooks algorithms cr 
main application areas problem trace sixties seventies problem appeared number different fields 
times main motivation kind search came computational biology signal processing text retrieval 
largest application areas cover 
see sk lot information birth subject 
computational biology dna protein sequences seen long texts specific alphabets fa tg dna 
sequences represent genetic code living beings 
searching specific sequences texts appeared fundamental operation problems assembling dna chain pieces obtained experiments looking features dna chains determining different genetic sequences 
modeled searching patterns text 
exact searching little application patterns rarely matched text exactly experimental measures errors different kinds correct chains may small differences significant due mutations evolutionary alterations unimportant 
finding dna chains similar sought represent significant results 
establishing different sequences important reconstruct tree evolution phylogenetic trees 
problems required concept similarity algorithm compute 
gave motivation search allowing errors 
errors operations biologists knew common occur genetic sequences 
distance sequences defined minimum sequence operations transform 
regard likelihood operations assigned cost operations cheaper 
goal minimize total cost 
computational biology evolved developed lot special push years due genome projects aim complete decoding dna potential applications 
exotic problems structure matching searching unknown patterns 
simple problem pattern known believed np complete distance functions reversals 
applications approximate pattern matching computational biology sel nw sk agm mye mye wat gus 
signal processing early motivation came signal processing 
largest areas deals speech recognition general problem determine audio signal textual message transmitted 
simplified problems discerning word small set alternatives complex parts signal may compressed time parts speech may pronounced perfect match practically impossible 
problem field error correction 
physical transmission signals errorprone 
ensure correct transmission physical channel necessary able recover correct message possible modification error introduced transmission 
probability errors obtained signal processing theory assign cost 
case may know searching just want text correct error correcting code closest received message 
area developed respect approximate searching generated important measure similarity known levenshtein distance lev lev called edit distance 
signal processing active area today 
rapidly evolving field multimedia databases demands ability search content image audio video data potential applications approximate string matching 
expect years lot pressure human machine communication involves speech recognition 
strong error correcting codes sought current interest wireless networks air low quality transmission medium 
relations approximate pattern matching signal processing lev vin dm 
text retrieval problem correcting misspelled words written text old oldest potential application approximate string matching 
find mas older ones 
sixties approximate string matching popular tools deal problem 
instance errors corrected allowing just insertion deletion replacement transposition dam 
areas problem appears information retrieval ir demanding 
ir finding relevant information large text collection string matching basic tools 
classical string matching normally text collections larger web text surpassed terabytes lg heterogeneous different languages instance error prone 
large grow fast impossible control quality web 
word entered incorrectly database retrieved anymore 
pattern may errors instance cross lingual scenarios foreign name sought incorrectly spelled ancient texts outdated versions language 
instance text collections optical character recognition ocr contain nonnegligible percentage errors 
happens typing spelling errors 
experiments typing dutch surname reached spelling errors 
percentages obtained kuk 
experiments name levenshtein altavista gave errors allowing just deletion transposition 
nowadays virtually text retrieval product allow extended search facility recover errors text pattern 
text processing applications spelling checkers natural language interfaces command language interfaces computer aided tutoring language learning name 
extension possible word oriented text compression methods possibility perform approximate string matching word level 
user supplies phrase search system searches text positions phrase appears limited number word insertions deletions replacements 
possible disregard order words phrases 
allows query survive different idea extends applications approximate pattern matching recovery syntactic mistakes 
relation approximate string matching information retrieval wf lw nes om kuk zd fps 
areas number applications approximate string matching grows day 
solutions diverse problems approximate string matching instance handwriting recognition lt virus intrusion detection ks image compression ls data mining dfg pattern recognition gt optical character recognition el file comparison hec screen updating gos name 
applications mentioned sk kuk 
basic concepts section important concepts needed understand development follows 
basic knowledge assumed design analysis algorithms data structures basic text algorithms formal languages 
case refer reader books subjects ahu clr knu algorithms cr ag text algorithms hu formal languages 
start formal definitions related problem 
cover data structures widely known relevant survey explained cr 
comments tour 
approximate string matching discussion follows represent arbitrary strings represent letters 
writing sequence strings letters represents concatenation 
assume concepts prefix suffix substring known 
string sigma denote length jsj 
denote th character integer 
denote empty string 
empty string denoted 
defined problem approximate string matching finding text positions match pattern errors 
give formal definition 
sigma finite alphabet size sigmaj oe 
sigma text length jt sigma pattern length jp maximum error allowed 
sigma theta sigma distance function 
problem return set text positions exists note endpoints occurrences reported ensure output linear size 
reversing strings obtain start points 
restrict attention subset possible distance functions 
consider defined form distance strings minimal cost sequence operations transform sequence exists 
cost sequence operations sum costs individual operations 
operations finite set rules form ffi different strings nonnegative real number 
operation converted substring operations done note especially restriction forbids acting times string 
freeing definition condition allow rewriting system represented determining distance strings computable general 
operation form ffi exists respective operation ffi cost distance symmetric 
note strings holds 
distance symmetric space strings forms metric space 
general substring replacement correct phonetic errors zd 
applications set possible operations restricted gamma insertion ffi inserting letter gamma deletion ffi deleting letter gamma replacement substitution ffi replacing gamma transposition ffi ab ba swap adjacent letters position define commonly distance functions 
gamma levenshtein edit distance lev allows insertions deletions replacements 
simplified definition operations cost 
rephrased algorithms adapted infinite alphabets extra log factor cost 
pattern different letters rest considered equal purposes 
table size oe replaced search structure different letters 
minimal number insertions deletions replacements strings equal 
literature search problem cases called string matching differences 
distance symmetric holds max jxj jyj 
gamma hamming distance sk allows replacements cost simplified definition 
literature search problem cases called string matching mismatches 
distance symmetric finite jxj jyj 
case holds jxj 
gamma episode distance dfg allows insertions cost 
literature search problem cases called episode matching models case sequence events sought occur short period 
distance symmetric may possible convert case 
jyj gamma jxj 
gamma longest common subsequence distance nw ag allows insertions deletions costing 
name distance refers fact measures length longest pairing characters strings pairings respect order letters 
distance number unpaired characters 
distance symmetric holds jxj jyj 
cases episode distance think changes insertions deletions vice versa replacements strings match 
concerned simple edit distance denote ed 
transpositions interest especially case typing errors algorithms deal 
consider points note transposition simulated insertion plus deletion cost different 
point algorithms extended different costs operations special interest computational biology including extreme case allowing operations 
includes distances mentioned 
note hamming edit distance problem sense perform operations pattern match text position means replacements 
case corresponds exact string matching excluded 
distances call ff error level conditions satisfies ff 
value gives idea error ratio allowed match fraction pattern wrong 
finish section notes algorithms going consider 
string matching area suitable theoretical practical contributions 
exist number algorithms important improvements theoretical complexity slow practice 
course carefully built scenarios say algorithms practical alternative cases appear applications 
point parameters problem consider practical application say practice mean assumptions 
gamma pattern length short letters text retrieval long letters computational biology 
gamma number errors allowed satisfies moderately low value 
reasonable values range 
gamma text length short letters computational biology long megabytes gigabytes text retrieval 
gamma alphabet size oe low letters dna high letters compression applications 
reasonable think larger alphabets oriental languages word oriented text compression 
alphabet may may random 
suffix trees suffix automata suffix trees wei knu ag widely data structures text processing apo 
position string defines automatically suffix jsj essence suffix tree trie data structure built suffixes leaf nodes pointers suffixes stored 
leaf represents suffix internal node represents unique substring substring traversing path root 
node representing substring ax suffix link leads node representing substring improve space utilization trie compacted patricia tree mor 
involves compressing unary paths 
nodes root compressed path indication characters skip stored 
unary paths tree jsj nodes worst case jsj trie see 
structure built time jsj mcc ukk 
dawg deterministic acyclic word graph cro built string deterministic automaton able recognize substrings node suffix tree corresponds substring dawg suffix tree augmented failure links letters tree 
final nodes distinguished dawg smaller 
similar applications suffix trees need jsj space construction time 
illustrates 
suffix automaton automaton recognizes suffixes nondeterministic version automaton regular structure shown deterministic version seen 
tour sections historical tour main approaches online approximate string matching see 
historical discussions keep mind may long gap time result discovered gets published definitive form 
apparent inconsistencies explained way algorithms analyzed appear 
best bibliography trace earliest version works full corresponds generally final version 
suffix trie suffix tree string suffix trie suffix tree sample string 
special marker denote text 
suffix links exemplified trie bra ra 
internal nodes suffix tree show character position inspect string 
dawg suffix automaton sample string 
states final dawg 
nd th rightmost states final suffix automaton 
non deterministic suffix automaton recognize suffix 
dashed lines represent transitions occur consuming input 
dp matrix worst case bit parallelism filters long patterns dp matrix automaton average case moderate patterns automata taxonomy types solutions online searching 
sections give taxonomy help guide tour 
taxonomy acyclic graph nodes algorithms edges mean lower seen evolution upper developments fact independent 
specify notation regarding time space complexity 
say algorithm time refer worst case say explicitly 
cost average say explicitly 
say algorithm cost meaning time 
refer space complexity say explicitly 
average case analysis normally assumes random text character selected uniformly independently alphabet 
pattern normally assumed random 
statistics problem natural question approximate searching probability match 
question interesting essential average case analysis search algorithms seen 
existing results empirical validation 
section consider edit distance 
variants adapted results 
effort analyzing probabilistic behavior edit distance results general km 
exact analysis probability occurrence fixed pattern allowing replacement errors hamming distance rs result easy average possible patterns 
results apply edit distance model despite exact easier general 
result rs holds assumption characters text independently generated fixed probabilities bernoulli model 
rest consider simpler model uniform bernoulli model characters occur probability oe 
gross simplification real processes generate texts applications results obtained quite reliable practice 
particular analyses apply quite biased texts replace oe probability random text characters equal 
problem average edit distance strings closely related better studied lcs known results cs dek hardly applied case 
shown average edit distance random strings length tends constant fraction grows fraction known 
holds strings length gamma lcs ed gamma lcs ed edit distance lcs length longest common subsequence 
proved cs average lcs oe oe large oe average edit distance gamma oe gamma oe 
large oe conjectured true value gamma oe sm 
purposes bounding probability match allowing errors important average edit distance 
probability random pattern length matching text position errors edit distance text position reported match 
byn nav nby upper lower bounds maximum error level ff exponentially decreasing 
important algorithms search potential matches verified cost verifications polynomial typically 
event occurs probability fl fl total cost verifications fl verifications cost negligible 
show analytical bounds give new result average edit distance experimental verification 
upper bound upper bound ff comes proof matching probability fl fl ff gammaff gamma ff gammaff oe gamma ff gammaff note fl oe ff grows ff grows 
matching probability exponentially decreasing long fl equivalent ff gamma oe gamma oe gamma oe ff gamma oe conservative condition error level ensures matches 
maximum level ff satisfies ff gamma oe 
proof obtained combinatorial model 
observation gamma common characters appear order strings match errors possible alternatives select matching characters strings enumerated 
model take full advantage properties edit distance gamma characters match distance larger example ed abc bcd characters match distance 
lower bound hand optimistic bound know considering replacements allowed hamming distance 
distance simpler analyze matching probability lower 
combinatorial model shown matching probability ffi gamma ffi gamma ff oe gammaff upper bound maximum ff value ff gamma oe proved exponentially decreasing omega gamma gamma 
new result average edit distance prove average edit distance larger gamma oe oe recall result cs holds large oe 
define probability edit distance strings length note case match text suffix length gamma average edit distance pr ed pr ed gamma gamma increases larger gamma kp gamma gamma choice 
particular gamma oe fl fl 
choosing gamma oe gamma yields edit distance gamma oe oe 
see proofs converts conjecture average running time algorithm cl fact 
empirical verification verify analysis experimentally section taken byn nav 
experiment consists generating large random text mb running search random pattern text allowing errors 
text character record minimum allowed error text position match pattern 
repeat experiment random patterns 
build cumulative histogram finding text positions matched errors value 
consider low histogram values significant long text positions matched 
threshold set normal cost verifying match 
selection threshold important histogram extremely concentrated 
example hundreds moves zero just increments shows results oe 
left show histogram built matching probability undergoes sharp increase ff right show ff value grows 
clear ff essentially independent bit lower short patterns 
increase left plot ff sharp right plot plotted value average edit distance divided ff ffm ff left probability approximate match function error level 
right observed ff error level function pattern length 
cases correspond random text oe 
uses stable show ff value function oe 
curve ff gamma oe included show closeness experimental data 
squares give approximation ff gamma oe relative error smaller 
shows upper bound analysis eq 
matches reality better provided replace formulas 
theta theta theta theta theta theta theta pi pi pi pi pi pi oe ff theta upper bound gamma oe curve gamma oe experimental data exact lower bound fl eq 
pi conservative lower bound eq 
theoretical practical values ff different oe values 
shown matching probability sharp behavior low ff low low oe exact string matching exponentially decreasing exponent base larger oe 
ff value called ff sharply increases quickly 
point close ff gamma oe practice 
problem interest error level higher errors text positions match 
reason algorithms average behavior low error levels 
point ff gamma oe matches conjecture sm 
dynamic programming algorithms start tour oldest areas inherits directly earliest 
theoretical breakthroughs worst case algorithms belong category really competitive practice 
latest practical area dates back theoretical improvements 
major achievements kn worst case algorithms kn oe average case algorithms theoretical improvements worst case 
start presenting algorithm solved problem give historical tour improvements initial solution 
helps guide tour 
algorithm algorithm solve problem 
rediscovered times past different areas vin nw san sel wf lw ull sk kuk 
algorithm computed edit distance converted search algorithm sellers sel 
algorithm efficient flexible ones adapt different distance functions 
show compute edit distance strings extend algorithm search pattern text allowing errors 
show handle general distance functions 
computing edit distance algorithm dynamic programming 
imagine need compute ed 
matrix jxj jyj filled represents minimum number operations needed match computed follows gamma gamma min gamma gamma gamma gamma jxj jyj ed 
rationale formula follows 
represent edit distance string length empty string 
clearly cl sv time text searching edit distance space time theoretical practical sel mn search algorithm space nk ff log log space edit distance ukk mye analysis cl byn space edit distance sel wf lw vin nw san kn space mye gp gp uw gg kn time space kn time space kn time space kn expected space kn oe expected moe space cut heuristic ukk mp extra space nm log oe time russians lv kn time space lv suff 
tree patt 
space km time gp cl prefix matrix column partitioning time ch brute force diagonal transition partial tree patt 
period 
kn time mye matches space suf 
aut 
patt taxonomy algorithms dynamic programming matrix 
respectively deletions needed nonempty string 
non empty strings length assume inductively edit distances shorter strings computed try convert consider characters equal need consider proceed best possible way convert gamma gamma hand equal deal way 
allowed operations delete convert best way gamma insert convert best way gamma replace convert best way gamma gamma cases cost plus cost rest process computed 
notice insertions string equivalent deletions 
equivalent formula widely min gamma gamma ffi gamma gamma ffi 
easy see formulas equivalent neighboring cells differ just recall meaning ffi gamma gamma larger gamma gamma 
dynamic programming algorithm fill matrix way upper left upper left neighbors cell computed prior computing cell 
easily achieved row wise left right traversal column wise top bottom traversal see difference recurrence matrix filled upper left lower right diagonals secondary upper right lower left diagonals 
illustrates algorithm compute ed survey surgery 
dynamic programming algorithm compute edit distance survey surgery 
bold entries show path final result 
algorithm time worst average case 
space required min jxj jyj 
case column wise processing previous column stored order compute new just keep column update 
process matrix row wise column wise space requirement minimized 
hand sequences operations performed transform easily recovered matrix simply proceeding cell jxj jyj cell path sequence operations matches update formula multiple paths may exist 
case need store complete matrix area main diagonal 
matrix properties easily proved induction see ukk possible design better algorithms 
values neighboring cells differ upper left lower right diagonals nondecreasing 
text searching show adapt algorithm search short pattern long text algorithm basically proceeding column wise space required 
difference allow text position potential start match 
achieved setting empty pattern matches zero errors text position matches text substring length zero 
algorithm initializes column values processes text character character 
new text character column vector updated update formula gamma min gamma gamma text positions cm reported 
search time algorithm mn space requirement 
sort worst case analysis algorithms consider 
exemplifies algorithm applied search pattern survey text surgery short text errors 
case occurrences 
dynamic programming algorithm search survey text surgery errors 
column matrix value vector 
bold entries indicate matching text positions 
distance functions easy adapt algorithm distance functions mentioned 
operations different costs add cost adding computing min gamma gamma ffi gamma ffi gamma ffi assume ffi sigma gamma gamma distances allow operations just take minimization formula assign ffi cost 
transpositions allow fourth rule says gamma gamma gamma gamma lw 
complex case allow general substring replacements form finite set rules 
formula ukk 
min gamma gamma ffi interesting problem compute recurrence efficiently 
naive approach takes jrj sum lengths strings better solution build aho corasick automata ac left right hand sides rules respectively 
automata run advance strings left hand sides right hand sides 
pair states automata precompute set replacements tried ffi left right hand match suffixes respectively represented automata states 
know constant time cell set possible replacements 
complexity lower worst case cmn maximum number rules applicable single text position 
said dynamic programming approach unbeaten flexibility time requirements high 
number improved solutions proposed years 
edit distance adapted distance functions 
considering improvements mention exists way see problem shortest path problem graph built pattern text ukk 
reformulation conceptually useful complex variants problem 
improving worst case paterson interesting important worst case theoretical result area old sellers sel algorithm 
paterson mp algorithm worst case cost mn log oe requires extra space 
improvement mn classical complexity 
algorithm russians technique 
basically replaces alphabet sigma tuples sigma small considered algorithmically builds table solutions possible problems portions matrix size theta uses table solve original problem blocks size illustrates 
values inside theta size cells depend corresponding letters pattern text gives oe possibilities 
depend values column row upper left cells bottom right state upper left cell see 
neighboring cells differ choices adjacent cells current cell known 
adds possibilities 
total oe different cells precompute 
memory space log oe compute mn cells final complexity follows 
text pattern paterson algorithm partitions dynamic programming matrix cells example 
right shaded entries adjacent cells influence current 
algorithm theoretical interest authors estimate beat classical algorithm texts gb size need extra space 
adapting distance functions difficult dependencies different cells may complex 
ukkonen ukkonen ukk algorithm able compute edit distance strings ed time check time distance 
member called diagonal transition algorithms fact diagonals dynamic programming matrix running upper left lower right cells monotonically increasing fc 
algorithm computing constant time positions values diagonals incremented 
positions computed reach lower right decisive cell 
illustrates idea 
diagonal stroke represents number errors sequence strings match 
stroke errors starts continues adjacent gamma strokes continue keeps matching text 
compute stroke constant time need know matches text 
way constant time explained shortly 
landau vishkin landau vishkin worst case time improvements search problem 
thread followed diagonal transition algorithms 
lv show algorithm time space lv obtain kn time space 
main idea landau vishkin adapt text searching ukkonen diagonal transition algorithm edit distance ukk 
basically dynamic programming matrix left algorithm compute edit distance 
right way compute strokes diagonal transition algorithms 
solid bold line guaranteed part new stroke errors dashed part continues long strings match 
computed diagonal wise stroke stroke column wise 
wanted compute constant time length stroke point values diagonal incremented 
text position reported matrix row reached incrementing times values diagonal gave immediately kn algorithm 
way see diagonal abandoned soon th stroke ends diagonals nk strokes computed constant time recall 
recurrence diagonals number errors rows columns set way gamma gamma jdj gamma jdj gamma gamma gamma jdj gamma jdj gamma gamma gamma max max gamma gamma gamma gamma external loop updates internal updates gammae negative numbered diagonals virtually starting text position 
shows search example recurrence 
note matrix filled diagonals 
difficult part compute strokes constant time max delta delta delta 
problem equivalent knowing longest prefix matches data ben called matching statistics 
algorithms section differ basically manage compute matching statistics fast 
defer explanation lv galil park 
lv longest match obtained building suffix tree see section text concatenated pattern huge extra space comes 
longest prefix common suffixes visualized suffix tree follows imagine root leaf paths suffixes 
parts share path diagonal transition matrix search survey text surgery errors 
bold entries indicate matching diagonals 
rows values columns values 
share root 
suffix tree node common paths represents substring precisely longest common prefix 
literature common node called lowest common ancestor lca nodes 
despite conceptually clear easy find node constant time 
existing lca algorithm ht constant amortized time answered lca queries time 
case kn queries 
resulting algorithm quite slow practice 
myers myers algorithm kn worst case behavior mye 
needed extra space shared idea computing new strokes previous ones suffix tree text lca algorithm 
algorithms able report kn matching substrings text endpoints kn time 
algorithm suitable complex applications instance computational biology 
original technical report went press included larger lms 
galil giancarlo galil giancarlo gg obtained time complexity landau vishkin space 
basically suffix tree text built overlapping pieces size 
algorithm scans text times slower lv 
result theoretical interest 
galil park year galil park gp obtained kn worst case time space worse theory gg better practice 
idea rooted lv obtained time 
cases idea build matching statistics pattern longest match resembling sense basic ideas kmp 
algorithm slow practice anyway 
consider particular new stroke errors right 
stroke dictated neighboring strokes gamma errors longest ceases affect new stroke long continues dashed line depends similarity pattern text 
specifically dotted line suffix stroke diagonal spans rows means longest match length 
strokes computed algorithm give information longest matches text pattern 
difficult part information 
illustrates algorithm 
explained algorithm progresses strokes filling diagonally matrix stroke computed neighbors computed 
enclosed dotted triangle strokes may contain information longest matches relevant new strokes computed 
algorithm lv basically searches relevant information triangle time 
left way stroke wise algorithm progresses 
relevant strokes enclosed dotted triangle strokes computed bold 
right selection relevant strokes cover text area 
put bold parts strokes 
improved gp kn considering carefully relevant strokes 
call stroke stroke errors 
consider stroke 
full stroke suffix represents longest match pattern text 
previous strokes keep lasts text text position information need longest matches 
consider strokes 
despite suffix strokes really represent longest match pattern text know definitely true text position reached stroke stroke help stroke 
keep stroke lasts text define longest matches pattern text active strokes 
argument continues errors showing fact complete text area relevant covered just strokes 
right illustrates idea 
algorithm gp basically keeps list relevant strokes date time 
time new stroke produced compared current relevant stroke new lasts text old replaces old stroke 
algorithm progresses text old strokes naturally eliminated procedure 
problem indirect information relevant strokes compute longest matches pattern text 
set longest matches covering text area interest plus precomputed longest matches pattern starting position 
know dashed line starts say want compute length 
know longest match pattern text ends called triples 
find relevant stroke dashed line falls 
stroke represents maximal match know preprocessing longest match derive longest match extra complications take care longest matches position length zero sorted time diagonal matrix 
galil park show extra space needed store matrix longest matches reduced suffix tree pattern text previous lca algorithms add different entries note lv space 
galil park show add transpositions edit operations complexity 
technique extended diagonal transition algorithms 
believe allowing different integral costs operations forbidding achieved simple modifications algorithms 
ukkonen wood idea similar suffix tree pattern similarly slow practice independently discovered ukkonen wood uw 
suffix automaton described section pattern find matching statistics table 
algorithm progresses text suffix automaton keeps count pattern substrings match text moment 
despite report space suffix automaton take space 
chang lawler chang lawler cl repeated idea briefly mentioned gp matching statistics computed suffix tree pattern lca algorithms 
newer faster lca algorithm sv truly reported best time algorithms guaranteed kn performance 
algorithm competitive practice 
cole cole ch algorithm worst case pattern aperiodic idea pattern lot self repetition diagonals diagonal transition algorithm need computed 
algorithm thought filter see sections worst case guarantee useful small resembles ideas filters developed cl 
probably filters proved worst cases periodicity assumptions pattern thread explored 
algorithm evolution previous sv complex worse complexity nk ff log log 
case interest theoretical 
improving average case ukkonen improvement average case due ukkonen 
algorithm short note ukk improved dynamic programming algorithm definition aperiodic technical related number auto repetition occurs pattern 
patterns aperiodic 
kn average time space 
algorithm called cut heuristic 
main idea pattern normally match text values column top bottom quickly reach mismatch cell value larger result search depend exact value 
cell called active value algorithm simply keeps count active cell avoids working rest cells 
keep active cell able recompute new column 
new column active cell incremented check activated cell cost 
possible active cell inactive 
case search upwards new active cell 
despite column increments value process decrements 
active cell maintained amortized cost column 
ukkonen conjectured algorithm kn average proven chang cl 
proof refined baeza yates navarro byn 
result probably extended complex distance functions substrings active cell exceed ensure return value smaller particular value transpositions allowed 
myers algorithm mye diagonal transitions previous sections strokes simply computed brute force 
myers showed resulting algorithm kn average 
clear length strokes oe oe gamma average 
algorithm proposed galil park gp 
strokes need stored space 
chang chang cl gave new algorithm called column partitioning exploiting different property dynamic programming matrix 
consider fact column numbers normally increasing 
runs consecutive increasing cells run ends 
manage run column process 
update run constant time precompute loc min pattern positions characters needs moe space 
column matrix consider current text character current row know constant time run going character match 
run parallel run previous column ends 
empirical observations conjecture average length runs oe 
notice matches result average edit distance gamma oe number increments columns oe non increments runs 
clear run average length oe 
just proved chang conjecture 
uses cut heuristic ukkonen average search time kn oe 
practice fastest algorithm class 
algorithms section difficult adapt cl distance functions idea strongly relies unitary costs 
mentioned algorithm run average time kn log log oe practical 
algorithms automata area old 
interesting gives best worst case time algorithm matches lower bound problem 
time space exponential dependence limits practicality 
basic solution discuss improvements 
shows historical map area 
mp russians technique ukk definition dfa min moe states lazy automaton kur nav mel improved analysis gammak 
states replaces oe min oe wmm space mn log time taxonomy algorithms deterministic automata 
automaton approximate search alternative useful way consider problem model search nondeterministic automaton nfa 
automaton deterministic form firstly proposed ukk firstly non deterministic form implicitly wm 
shown explicitly byn 
consider nfa errors edit distance shown 
row denotes number errors seen row zero second row 
column represents matching pattern prefix 
horizontal arrows represent matching character pattern text characters match advance pattern text 
increment number errors move row vertical arrows insert character pattern advance text pattern solid diagonal arrows replace character advance text pattern dashed diagonal arrows delete character pattern transitions advance pattern advancing text 
initial self loop allows match start text 
automaton signals match rightmost state active 
care number errors occurrences consider final states full diagonal 
hard see state automaton active states column higher rows active 
text character collect smallest active rows column obtain vertical vector dynamic programming algorithm case compare 
errors errors error nfa approximate string matching pattern survey errors 
shaded states active reading text surgery 
types distances hamming lcs episode obtained deleting arrows automaton 
different integer costs operations modeled changing arrows 
instance insertions cost vertical arrows move rows rows 
transpositions modeled adding extra state pair states position arrows labeled state ij mel 
adapting general substring replacement needs complex setups possible 
automaton simply deterministic obtain worst case search time 
see main problem construction dfa deterministic finite automaton 
alternative solution simulating nfa making deterministic 
implementing automaton ukkonen ukkonen proposed idea deterministic automaton problem ukk 
automaton explicitly considered 
possible set values columns dynamic programming matrix state automaton 
set possible columns transitions built text scanned resulting automaton performing exactly transition character read 
big problem scheme automaton potentially huge number states built stored 
improve space usage ukkonen proved elements columns larger replaced affecting output search lemma design cut heuristic described section 
reduced potential number different columns 
showed adjacent cells column differed 
column states defined vector incremental values set gamma 
possible obtain ukk nontrivial bound number states automaton min moe 
size better obvious large short patterns low error levels 
resulting space complexity algorithm times value 
exponential space complexity added time complexity preprocessing time build automaton 
final comment ukkonen suggested columns partially computed say entries 
conjectured proved cl columns interest average normally affect algorithm reduce number possible states 
point states computed really needed algorithm compute dynamic programming 
notice incorporate transpositions substring replacements conception need consider state set columns dynamic programming matrix longest left hand side rule 
case better build automaton explicitly deterministic 
wu manber myers wu manber myers looked problem wmm 
idea trade time space russians technique 
cells expressed values gamma columns partitioned blocks cells called regions took bits 
precomputing transitions column transitions region region column precomputed current region depend previous regions see 
regions smaller columns space necessary 
total amount column worst case average 
space requirement exponential extra space algorithm kn log average mn log worst case 
notice shares mp russians approach important difference states case depend letters pattern text 
states automaton mp hand depend text pattern 
russians approach flexible extended handle regular expressions allowing errors wmm 
technique exact regular expression searching pack portions deterministic automaton bits compute transition tables portion 
transitions portions left nondeterministic simulated 
allow errors state anymore active inactive keep count minimum number errors active log bits 
mel studied size deterministic automaton 
considering properties nfa refined bound ukk min mt gammak min oe 
space complexity preprocessing time automaton times number states 
conjectured left automaton ukk column state 
right automaton wmm region state 
compute columns dynamic programming matrix 
automaton bigger periodicities pattern matches results ch section sense periodic patterns problematic 
fact property shared problems string matching 
kurtz kurtz kur proposed way reduce space requirements mn 
adaptation byg proposed hamming distance 
idea build automaton lazy form build states transitions reached processing text 
automaton starts just initial state states transitions built needed 
doing transitions ukkonen ukk considered necessary built fact need guess 
price extra overhead lazy construction versus direct construction idea pays 
kurtz proposed built initial part automaton commonly traversed states save space 
navarro studied nav nav growth complete lazy automata function value lazy automaton 
empirical results show lazy automaton grows text rate fi fi dependent oe replacement policies designed bounded memory proposed nav 
bit parallelism algorithms exploiting parallelism computer works bits 
new active area 
basic idea parallelize algorithm bits 
results interesting practical point view especially significative short patterns involved typical text retrieval 
may effectively error level 
section find elements strictly belong sections parallelize algorithms 
main trends parallelize non deterministic automaton solves problem parallelize dynamic program ming matrix 
explain technique results achieved 
shows historical development area 
birth bit parallelism parallelized dp matrix wri mn log oe time parallelize matrix wm bit parallel nfa kdm wen time mye optimal parall 
dp matrix mn worst case kn average byn nfa parallelized diagonals dkm wen worst case average parallelize automaton taxonomy bit parallel algorithms 
technique bit parallelism technique common string matching born phd 
thesis baeza yates 
consists advantage intrinsic parallelism bit operations inside computer word 
cleverly fact number operations algorithm performs cut factor number bits computer word 
current architectures speedup significative practice improves technological progress 
order relate behavior bit parallel algorithms works normally assumed theta log dictated ram model computation 
prefer keep independent value 
introduce notation bit parallel algorithms 
gamma length computer word bits gamma denote bits mask length 
mask stored inside computer word 
length computer word fixed hiding details store bits inside 
gamma exponentiation denote bit repetition 
gamma syntax operations bits computer words bitwise bitwise xor complements bits 
shift left operation moves bits left enters zeros right gamma 
gammar shift right moves bits direction 
perform arithmetic operations bits addition subtraction operate bits formed number 
instance gamma 
explain bit parallel algorithm shift byg basis follows 
algorithm searches pattern text errors parallelizing operation non deterministic finite automaton looks pattern 
illustrates automaton 
nondeterministic automaton searches survey exactly 
automaton states simulated non deterministic form mn time 
shift algorithm achieves mn worst case time optimal speedup 
notice convert non deterministic automaton deterministic search time get improved version kmp algorithm kmp 
kmp twice slow algorithm builds table character stores bit mask mask bit state search kept machine word dm matches text read state numbered active 
match reported dm 
set originally new text character updated formula 
gamma formula correct th bit set gamma th bit set previous text character new text character matches pattern position words gammai gammai gamma gamma possible relate formula movement occurs non deterministic automaton new text character state gets value previous state happens text character matches corresponding arrow 
patterns longer computer word algorithm uses dm computer words simulation active time 
algorithm average 
easy extend shift handle classes characters 
extension position pattern matches set characters single character 
classical real algorithm uses bits inverse meaning operation gamma necessary 
shifts direction ensure fresh zero fills hole left shift machine dependent right shift 
preferred explain didactic version 
string matching algorithms easily extended 
shift set th bit set 
instance search survey case insensitive form just set bit rest 
shift search multiple patterns complexity mn consider total length patterns enhanced wm support larger set extended patterns regular expressions 
online text algorithms seen implementations automaton classically deterministic form 
bit parallelism invention general way simulate simple non deterministic automata converting deterministic 
advantage simpler cases faster better usage registers computer word easier extend handle complex patterns classical counterparts 
main disadvantage limitation imposes regard size computer word 
cases adaptations cope longer patterns efficient 
parallelizing non deterministic automata wu manber wu manber wm published number ideas great impact practical text searching 
extended shift algorithm handle wild cards allow arbitrary number characters positions pattern regular expressions flexible pattern efficiently searched 
interest simple scheme combine preceding extensions approximate string matching 
idea simulate nfa bit parallelism row automaton fits computer word state represented bit 
new text character transitions automaton simulated bit operations computer words 
notice computer words structure bit aligned text position 
update formula obtain new values text position current values 
gamma 


start search gammai expected undergoes simple shift process rows receive ones active states previous rows 
formula expressed order horizontal vertical diagonal dashed diagonal arrows 
cost simulation kdm wen worst average case kn patterns typical text searching 
perfect speedup serial simulation automaton cost time 
notice short patterns competitive best worst case algorithms 
simplicity construction rows pattern changed different automaton 
long able solve problem exact string matching copies resulting computer word performs operations words plus arrows connect words algorithm find pattern allowing errors 
able perform approximate string matching sets characters wild cards regular expressions 
allow extensions unique approximate searching part pattern searched errors may forced match exactly different integer costs edit operations accommodated including allowing 
able search set patterns time capability limited patterns fit computer word 
great flexibility obtained encouraged authors build software called agrep wm capabilities implemented particular cases solved different manner 
software taken subsequent research 
baeza yates navarro baeza yates navarro new bit parallel algorithm able parallelize computation automaton byn 
classical dynamic programming algorithm thought column wise parallelization automaton wu manber wm proposed row wise parallelization 
algorithm able increase parallelism nfa states fit computer word transitions automaton caused call zero time dependencies 
current values rows columns depend computed parallel 
byn bit parallel formula diagonal parallelization 
packed states automaton diagonals rows columns run direction diagonal arrows notice totally different diagonals dynamic programming matrix 
idea mentioned earlier baeza yates bit parallel formula 
gamma complete diagonals really necessary numbered gamma number row active state diagonal subsequent states diagonal active transitions 
new values reading text position computed min gamma term represents insertions second term replacements term matches deletions implicit represent lowest active state diagonal 
main problem compute function defined min fk notice active state crosses horizontal edge propagate way diagonal 
solved byn nav representing values unary arithmetic operations bits desired propagation effects 
formula understood numerically operating logically simulating arrows automaton 
resulting algorithm worst case time fast practice bits automaton fit computer word wm keeps kn 
general dk gamma wen worst case time dk wen average ukkonen cut heuristic see section 
scheme handle classes characters wild cards different integral costs edit operations 
available ftp cs arizona edu 
parallelizing dynamic programming matrix wright wright wri bit parallelism dynamic programming matrix 
idea consider secondary diagonals run upper right bottom left matrix 
main observation elements matrix follow recurrence gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma shows new secondary diagonal computed previous ones 
algorithm stores differences gamma gamma represents recurrence modulo arithmetic 
algorithm packs pattern text characters computer word performs parallel number pattern versus text comparisons vector results comparisons update cells diagonal parallel 
store characters alphabet bits algorithm nm log oe worst average case 
competitive time small alphabets dna 
author recognizes quite difficult adapt algorithm distance functions 
myers myers mye better way parallelize computation dynamic programming matrix 
represented differences columns columns bits cell fact algorithm seen bit parallel implementation automaton deterministic wmm see section 
new recurrence cells dynamic programming matrix expressed horizontal vertical differences deltav gamma gamma deltah gamma gamma deltav min deltav gamma deltah gamma gamma deltah gamma deltah min deltav gamma deltah gamma gamma deltav gamma eq zero 
idea keep packed binary vectors representing current th values differences finding way update vectors single operation 
cell seen small processor receives inputs deltav gamma deltah gamma eq produces outputs deltav deltah theta theta possible inputs simple formula express cell logic wri approach logical arithmetical 
hard part parallelize column zero time dependency problem 
author finds solution despite different model similar byn 
result algorithm uses better bits computer word worst case dm wen average case dk wen uses ukkonen cut section 
update formula little complex byn algorithm bit slower adapts better longer patterns computer words needed 
difficult improve kn algorithms algorithm may word respect asymptotic efficiency parallelization possibility parallelize kn original wri errors 
worst case algorithm 
common expect bit parallel algorithms scheme able search extended patterns difficult adapt distance functions 
filtering algorithms category quite young starting active 
formed algorithms filter text quickly discarding text areas match 
filtering algorithms address average case major interest potential algorithms inspect text characters 
major theoretical achievement algorithm average cost log oe proven optimal 
practice filtering algorithms fastest 
limited applicability error level ff 
need non filter algorithm check potential matches 
explain general concept consider developments occurred area 
see 
concept filtering filtering fact may easier tell text position match tell matches 
instance sur appear text area survey error edit distance 
single edit operation alter halves pattern 
filtering algorithms take advantage fact searching pieces pattern errors 
exact searching algorithms faster approximate searching ones filtering algorithms competitive fact dominate large range parameters 
important notice filtering algorithm normally unable discover matching text positions 
discard hopefully large areas text contain match 
instance example necessary sur appears approximate occurrence sufficient 
filtering algorithm coupled process verifies text positions discarded filter 
virtually non filtering algorithm verification cases developers filtering algorithm care looking best verification algorithm just dynamic programming algorithm 
selection normally independent verification algorithm behave short texts started different text positions small text areas 
careful programming possible keep worst case behavior verifying algorithm avoid verifying overlapping areas 
performance filtering algorithms sensitive error level ff 
filters low error levels bad 
related amount text filter able discard 
evaluating filtering algorithms important consider time efficiency tolerance errors 
possible measure filtration efficiency total amount matches divided total amount potential matches pointed filtration algorithm sut 
term normally referring filters 
said filter sublinear inspect characters text boyer moore bm algorithms dynamic filtering moderate patterns long patterns cl ukk cl set nby hierarchical 
ff gammae oe mk time superimposition byn mk time horspool filter tu ff gamma oe nr suffix automata ff 
gammae oe gammae oe ff ff log oe gammaff ff gammaff nby ff log oe hierarchical 
wm byp byn partition pieces ff log oe ukk 
grams cm opt 

lower bound ff gammae oe ff log oe ff log oe tak text samples ff log oe ffn log oe time log oe time st samples ff log oe ffn log oe time oe kn time nav counting filter time ff gammam oe time ffn log oe time kn log oe oe time part 
errors byn mk time ff oe ff oe kn log oe oe time ff log oe ffn log oe time pieces shi taxonomy filtering algorithms 
complexities average 
exact searching best 
online algorithm truly sublinear independent achievable indexing algorithms 
divide area parts moderate long patterns 
algorithms areas normally different complex filters worthwhile longer patterns 
moderate patterns tarhio ukkonen tarhio ukkonen tu launched area publishing algorithm boyer moore horspool techniques bm hor filter text 
idea align pattern text window scan text backwards 
scanning ends bad text characters 
bad character match pattern position aligned match pattern character see correction algorithm 
distance characters 
formally assume window starts text position aligned bad bad bad precomputed fp gammak gammak idea bad characters know sure error match match byproduct inserting deleting characters 
characters errors sure current text window abandoned shifted forward 
hand window reached area gammak checked classical algorithm 
know shift window authors show point shifting new position text characters current window gammak match corresponding character gammar gammar gamma gammaj differences fixed replacements errors fixed operations aligned involved pattern text characters insertions deletions 
case obtained effect aligning matching characters start 
pattern position fm gamma mg text character aligned position sigma shift align pattern precomputed shif min fp gammas ag exists 
shift window computed min gammak shif 
minimum computed backward window traversal 
analysis tu shows search time kn oe gamma considering verifications 
appendix show amount verification negligible ff gamma oe analysis valid 
oe simplify search time oe 
algorithm competitive practice low error levels 
interestingly version corresponds exactly horspool algorithm hor 
horspool take proper advantage long patterns 
algorithm probably adapted simple distance functions define minimum number errors needed reject string 
jokinen tarhio ukkonen jokinen tarhio ukkonen adapted previous filter mismatches problem gl 
filter simple fact inside match errors gamma letters belonging pattern 
filter care order letters 
simple version cl see section filtering efficiency simpler implementation 
search algorithm slides window length text keeps count number window characters belong pattern 
easily done table character stores counter pattern seen text window 
counter incremented enters window decremented leaves window 
time positive counter decremented window character considered belonging pattern 
gamma characters area verified classical algorithm 
algorithm analyzed navarro nav model urns balls 
shows algorithm time ff gammam oe possible extensions studied nav 
original version variable size window 
simplification nav 
resulting algorithm competitive practice short patterns worsens long ones 
simple adapt distance functions just determining characters match approximate occurrence 
wu manber simple filter proposed wu manber wm ideas 
basic idea fact old riv pattern cut pieces pieces appear unchanged approximate occurrence 
evident errors alter pieces 
proposal split pattern approximately equal length pieces search pieces text check neighborhood matches length 
extension shift byg search pieces simultaneously mn time 
baeza yates byp suggested better algorithms search aho corasick machine ac guarantee search time excluding verifications walter cw 
improvement really implemented byn adapting boyer algorithm sun search trie patterns pessimistic shift table 
resulting algorithm surprisingly fast practice low error levels 
closed expression average case cost algorithm show appendix gross approximation kn log oe oe 
independent proofs byn byp show cost search dominates ff log oe 
simple way see consider checking text area costs done pieces length matches happens probability near oe ff result follows requiring average verification cost 
filter adapted care distance functions 
main issue determine pieces edit operation destroy edit operations surpassing error threshold 
example transposition destroy pieces operation need split pattern pieces ensure unaltered 
clever solution case leave hole character pair pieces transposition alter 
baeza yates navarro bit parallel algorithms section byn basis novel filtering techniques 
basic algorithm limited short patterns split longer patterns parts making short searchable basic bit parallel automaton computer word 
method general version partition pieces mye byn 
cut pattern pieces appears bk jc errors occurrence pattern 
clear piece needs errors match complete match needs errors 
pattern split pieces length searched errors basic algorithm 
time piece neighborhood verified check complete pattern 
notice error level ff pieces kept unchanged 
resulting algorithm mk average 
maximum ff value gamma em oe smaller gamma oe worsening grows 
may surprising error level ff subproblems 
reason verification cost keeps matching probability fl larger fl see section 
technique enriched superimposition byn 
idea avoid performing separate search piece pattern 
approximate searching designed ability bit parallelism search classes characters 
assume want search survey secret 
search pattern ue rc vr yt ab means fa bg 
nfa horizontal arrows traversable letter 
clearly match patterns match superimposed pattern vice versa matches zero errors 
filter weakened search faster 
superimposition allowed lower average search time ff gamma em oe mk maximum ff version 
value smaller necessary put automata single machine words intermediate scheme obtained softly adapted higher error levels 
algorithm kn log ff gamma oe 
navarro baeza yates final twist previous scheme hierarchical verification nby 
simplicity assume pattern partitioned pieces technique general 
pattern split halves searched bk errors 
half recursively split pattern short nfa fit computer word see 
leaves tree pieces searched 
leaf finds match checking pattern previous technique parent checked small area piece matched 
parent verification stops continues grandparent root pattern 
correct partitioning scheme applies level tree grandparent appear children appear grandchild appeared 
shows example 
searches pattern errors text split pattern pieces searched error piece bbb text 
original approach verify complete pattern text area new approach verifies parent immediately determine complete match 
orthogonal hierarchical verification technique nby include superimposition scheme 
superimposition patterns matches set split sets patterns checked match verifying patterns 
analysis nav nby shows average verification cost drops 
problem scales fl verification probability verification cost 
hierarchical verification verification cost keeps negligible ff gamma oe 
simple extensions bit parallel algorithms apply partition pieces may need redesign distances 
notice difficult break barrier ff gamma oe filter shown section real matches best filters check real matches 
authors nby nav added hierarchical verification filter splits pattern pieces searches zero errors 
analysis shows ccc ddd bbb aaa hierarchical verification method pattern split parts 
boxes leaves elements really searched root represents pattern 
pattern level match occurrence complete pattern 
bold box bold lines may verified 
technique verification cost dominate search time ff log oe resulting filter fastest cases interest 
navarro navarro nr nav novel approach suffix automata see section 
adapted exact string matching algorithm bdm allow errors 
idea original bdm algorithm follows ccg cr 
deterministic suffix automaton reverse pattern built recognizes reverse prefixes pattern 
pattern aligned text window window scanned backwards automaton pattern reversed 
automaton active long read substring pattern 
time automaton reaches final state seen pattern prefix remember time happened 
automaton arrives active states window pattern substring pattern pattern window 
case window position matched pattern prefix gives initial window position 
algorithm nr bit parallel implementation nondeterministic suffix automaton see faster practice allows searching classes characters modification nr nav build nfa search reversed pattern allowing errors modify match pattern suffix apply essentially algorithm automaton 
shows resulting automaton 
automaton recognizes reverse prefix allowing errors 
window abandoned pattern substring matches errors read 
window shifted pattern prefix errors 
matches start exactly initial window position 
window length gamma ensure occurrence starting window position substring pattern occurs suffix window abandon window reaching occurrence 
reaching window guarantee match check area computing edit distance window text characters 
appendix shown average complexity ff ff log oe gamma ff ff gamma ff filter works ff 
gamma oe gamma oe large alphabets original analysis nav inaccurate 
errors errors error construction search reverse prefix survey allowing errors 
tends 
result competitive low error levels pattern long bit parallel implementation 
notice trying deterministic bdm generated complex construction algorithm simple nondeterministic automaton 
deterministic automaton states just section 
simple extensions bit parallelism apply provided window length gamma carefully reconsidered 
long patterns chang lawler chang lawler cl algorithms better analyzed 
called linear expected time works follows text traversed linearly time longest pattern substring matches text maintained 
substring extended starts current text position 
illustrates 
set algorithms set 
covers text pattern substrings set works block beginnings finds differences 
crucial observation gamma text characters covered longest substrings text area match pattern 
evident match formed correct strokes recall section separated errors 
strokes need ordered required filter 
algorithm uses suffix tree pattern determine linear pass longest pattern substring matching text seen 
notice article year ukkonen wood suffix automaton uw see section 
filtering time 
authors lv verifying algorithm worst case kn 
authors show filtering time dominates ff log oe 
constants involved practical figures ff oe ff oe 
second algorithm called set sublinear expected time 
idea similar text split fixed blocks size gamma check contiguous strokes starts block boundaries 
shortest match length gamma blocks contained completely match 
able discard block occurrence contain 
illustrated 
clear proven log oe comparisons block discarded average 
gamma blocks considered average time ffn log oe gamma ff 
maximum ff level keeps complexity simplified ffn log oe 
proof limits comparisons block quite involved hard see intuitively true probability finding pattern stroke length limited oe detailed proof shows log oe average longest stroke 
contrast result mye section shows strokes add length 
difference take strokes pattern 
set effective long patterns overhead pay short patterns 
different distance functions accommodated re reasoning adequate values 
ukkonen ukkonen ukk independently rediscovered ideas chang 
filtering algorithms called maximal matches similar cl fact ukkonen presents new block distance computable linear time shows serves filter edit distance 
filter grams online searching older ones indexed searching ull 
gram substring length filter proposed counting number grams shared pattern text window terms new gram distance may interest 
pattern length gamma overlapping grams 
error alter grams pattern gamma gamma kq pattern grams appear occurrence 
illustrates 
notice generalization counting filter section correspond 
search algorithm similar course keeping table counter oe grams impractical especially gamma 
ukkonen uses suffix tree keep count linear time gram seen relevant information attached gamma important nodes depth suffix tree 
text window text samples ukk st grams grams gram algorithm 
left ukk counts number pattern grams text window 
right st finds sequences pattern grams approximately text positions put bold text sample possible grams match 
filter takes linear time 
analysis show maximum error level tolerated filter attempt gross analysis appendix valid large result filter works ff log oe optimal obtain log oe search algorithm complicated 
larger values pays larger patterns 
different distance functions easily accommodated recomputing number grams preserved occurrence 
takaoka takaoka tak simplification cl 
considered samples text non overlapping grams text taken characters 
idea sample pattern neighborhood area verified 
gamma gamma match 
easiest way see start 
clearly need gamma loose matches 
larger recall pattern split pieces appear errors 
filter divides ensure occurrence pieces assuming 
suffix tree pattern sample time filtering time qn ffn log oe gamma ff optimal log oe 
error level ff log oe time ffn log oe 
chang marr looks ffn log oe best complexity achievable filters ff log oe chang marr obtained algorithm log oe ff ae oe ae oe depends oe tends gamma oe large oe 
time proved lower bound average complexity problem algorithm optimal average 
major theoretical breakthrough 
lower bound obtained maximum sum simple facts log oe bound yao exact string matching second obvious fact order discard block text characters characters examined find errors kn lower bound 
maximum error level optimal section 
impressive algorithm complexity 
algorithm variation set cl 
polynomial space space constant depends oe 
splitting text contiguous substrings length log oe finding pattern longest exact matches starting blocks size gamma searches text substrings length pattern allowing errors 
algorithm proceeds follows 
best matches allowing errors inside precomputed tuple space 
starting block searches consecutive tuples pattern time total number errors exceeds time covered gamma text characters block safely skipped 
reason works simple extension set 
area contained possible occurrence covered errors allowing unordered portions pattern match 
algorithm practical long patterns extended distances ideas filtration gram methods 
interesting notice ff gamma oe limit discussed section firm barrier filtering mechanism 
chang lawler proved asymptotic result general bound proved byn 
filters cm nby reduce problem errors zero errors 
interesting observation filters partition problem exact search applied ff log oe order improve gamma oe partition problem smaller approximate searching subproblems 
sutinen tarhio sutinen tarhio generalized takaoka filter st improving filtering efficiency 
filter takes account relative positions pattern pieces match text previous matched pieces pattern order 
generalization force grams pattern match just 
pieces conserve relative ordering pattern characters away correct position need errors 
method illustrated 
case sampling step reduced gamma gamma reason reduction ensure pieces pattern match need cut pattern pieces 
search pieces forcing far away correct positions pattern divided pieces hashed set created piece 
set contains grams piece neighboring ones sample slightly misaligned 
search time single sample consider text windows contiguous sequences samples 
samples searched corresponding set area verified 
sort hamming distance authors resort efficient algorithm distance byg process text 
resulting algorithm ffn log oe average optimal log oe works ff log oe algorithm better suited long patterns reasonably applied short ones 
fact analysis done st 
shi shi shi proposed extend idea pieces explained section pieces pieces match 
idea implicit filter sutinen tarhio explicitly written 
shi compared filter simple finding filtering efficiency improved 
improvement noticeable long patterns 
online searching efficiency degraded pieces shorter affects boyer moore search verification logic complex 
analysis conjecture optimum complexity tolerance errors maintained 
giegerich kurtz ohlebusch general method improve filters developed 
idea mix phases filtering checking verification text area abandoned soon combined information filter number guaranteed differences left verification progress number actual differences seen shows match possible 
show improvement occurs narrow area ff 
consequence statistics problem discussed section 
experiments perform section empirical comparison algorithms described 
goal show best options hand depending case 
nearly algorithms surveyed existing implementation known impractical 
avoid excessively comparison algorithms known competitive left aside 
included excluded algorithms large group excluded algorithms theoretical ones dynamic programming matrix 
algorithm despite competitive practice represent represented time valuable contribution development algorithmic aspect problem 
dynamic programming algorithm sel excluded cut heuristic ukkonen ukk known faster cl internal tests algorithm mp argued worse dynamic programming quite bad gb lv bad complexity improved theory practice lv implemented better lca algorithm cl slow mye considered slow practice author wmm gg clearly slower lv gp fastest kn worst case algorithms shown extremely slow uw cl wri internal tests done uw shown slow kn algorithm implemented cl argued fastest group shown competitive practice sv ch clearly theoretical complexities show patterns long error level low practical application 
give idea slow slow gp times slower ukkonen cut heuristic similar result reported chang cl 
kn average time algorithms proposed mye gp shown similar ukkonen cut ukk cl 
cut heuristic competitive leave aside similar algorithms 
group dynamic programming consider cut heuristic mainly cl competitive practice 
algorithms automata consider dfa algorithm ukk prefer lazy version implemented nav equally fast small automata faster large automata 
consider russians algorithm wmm 
bit parallel algorithms consider wm byn mye leaving aside wri 
shown version byn algorithm wri competitive binary text shown hold anymore mye 
filtering algorithms included tu counting filter proposed simplified nav algorithm nr nav st tak seen case st implementation worked better 
included filters proposed byn nby nav preferring version incorporates twists superimposition hierarchical verification mixed partitioning 
previous versions outperformed 
included best version filters partition pattern pieces incorporating hierarchical verification nby nav 
publications shown version clearly outperforms previous ones proposed wm byp byn 
discarding filters cl ukk cm shi applicable long patterns case excluded experiments explained shortly 
comparisons carried chang cl showing equivalent cut algorithm time set ff times 
shown fastest patterns letters long errors recall modern filters included comparison 
list algorithms included relevant comments 
algorithms implemented represent best coding effort similar faster implementations 
implementations coming authors checked standards cases code improved better register usage management 
number parenthesis name algorithm number lines implementation 
gives rough idea complex implementation algorithm 
ctf cut heuristic ukk implemented 
clp column partitioning algorithm cl implemented 
replaced faster 
dfa lazy deterministic automaton nav implemented 
rus russians algorithm wmm implemented 
tried different values related time space tradeoff best option machine 
bpr nfa bit parallelized rows wm implemented restricted separate code 
continue writing separate versions considered reasonable point algorithm competitive anyway 
nfa bit parallelized diagonals byn implemented 
include filtering technique 
number corresponds plain technique second handling partitioned automata 
bpm bit parallel implementation dynamic programming matrix mye implemented author 
numbers meaning previous item 
adaptation horspool allow errors tu implemented 
algorithm faster improve register usage replace faster 
cnt counting filter simplified nav implemented 
exp partitioning pieces plus hierarchical verification nby nav implemented 
bpp bit parallel algorithms byn nby nav pattern partitioning superimposition hierarchical verification 
implementation packaged software downloaded web page author 
bnd algorithm adapted allow errors nr nav implemented restricted separate code 
continue writing separate versions considered reasonable 
qg gram filter st implemented algorithm tak see item worked long patterns 
code restricted gamma run performance poor 
improved register usage replaced management faster versions 
qg gram algorithm tak run special case previous item 
restrictions code apply 
best effort algorithms 
cases text read chunks kb improve locality optimum machine care taken lose repeat matches borders open fopen slower 
internal conventions final special character zero buffer help algorithms recognize number matches reported 
separate experiments filtering non filtering algorithms 
filters general non filter check potential matches best algorithm formed combination 
filtering algorithms experiments cut algorithm ukk verification engine bpp essence switch smoothly bnd uses reverse bpr search window forward bpr verifications 
experimental setup apart algorithms included details describe experimental setup 
measure cpu times show results tenths seconds megabyte 
machine sun ultrasparc mhz mb main memory run solaris texts local disk gb 
experiments run texts mb size repeated times different search patterns 
patterns algorithms 
considering applications selected types texts 
dna file formed concatenating mb dna chain obtaining mb 
lines cut characters 
patterns selected randomly text avoiding line breaks possible 
alphabet size save exceptions file results similar random letter text 
natural language file formed mb writings franklin filtered lower case separators converted space line breaks respected 
mimics common information retrieval scenarios 
text replicated obtain mb search patterns randomly selected text word beginnings 
results text roughly equivalent random text characters 
speech obtained speech files discussions law indiana university pcm format bits sample 
course standard edit distance take account absolute values differences characters 
simplified problem edit distance reduced range values quantization considering equal samples lie range 
mb resulting file 
results similar random text letters file shows smooth changes letter 
results different pattern lengths error levels flavors fix show effect increasing fix ff show effect increasing algorithm may appear plot times range interest restrictions intersect range interest 
particular filters shown ff 
remind applications error levels interest low 
results shows results short patterns varying non filtering algorithms normally fastest faster bpm 
dfa quite close cases 
specialized version bpr slightly faster recall bpr starts algorithm jump 
exception situation occurs dna text shows nonmonotonic behavior bpm fastest 
behavior comes gamma complexity texts larger alphabets noticeable cut heuristic keeps cost unchanged 
behavior totally stable chose problem fit computer word time 
bpm hand handles longer patterns keeping stability takes time 
respect filters see exp fastest low error levels 
value low increases larger alphabets 
point bpp starts dominate 
bpp adapts smoothly higher error levels slowly switching bpp alternative intermediate error levels exp ceases switch 
range void dna english text 
filters competitive exp bnd 
fact bnd fastest dna really filter works case 
qg appear worked worse qg 
best choice short patterns exp works switching best bit parallel algorithm higher errors 
verification algorithm exp bpr fastest exp dominates 
shows case longer patterns 
observations valid case 
algorithm bpm shows case advantage problem fits computer word bpm 
left plots best algorithm bpm low bpr better 
respect filters exp bnd fastest depending alphabet certain error level reached 
point bpp fastest cases faster bpm 
notice dna specialized version bnd fastest choice 
consider case fixed ff growing results repeat somewhat regard non filtering algorithms bpr best best certain pattern length varies dna speech bpm fastest 
note low error level number active columns quite small permits algorithms bpm keeping behavior patterns longer handle single machine word 
dfa quite competitive memory requirements unreasonable 
real change filters 
case pex star filter english speech texts far unbeaten 
situation dna hand quite complex 
bnd fastest extended implementation allowing longer patterns keep fastest points 
case handle errors specialized implementation fixed keep competitive performance 
determined specialized code worthwhile 
bnd ceases applicable pex fastest algorithm qg beats 
notice filters beaten bpm little sense dna 
final phenomenon deserves mention respect filters 
algorithms qg qg improve grows 
algorithms practical ones tested family algorithms suitable long patterns 
shows despite algorithms competitive tests reason behavior integer round effects produce nonmonotonic results 
theta theta theta theta theta theta theta theta theta pi pi pi pi pi ffl ffl ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi ffi ffi pi ffl ffl theta theta theta theta theta ffi ffi theta theta theta theta theta theta theta theta theta pi pi pi pi pi ffl ffl ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi ffi ffi pi pi pi ffl ffl ffl ffl theta theta theta theta theta ffi ffi ffi theta theta theta theta theta theta theta theta theta pi pi pi pi pi ffl ffl ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi ffi ffi pi pi pi pi pi ffl ffl ffl ffl ffl theta theta theta theta theta ffi ffi ffi ctf clp theta dfa rus pi bpr ffl ffi bpm qg qg theta bpp cnt pi ffl exp ffi bnd results varying left plots show non filtering right plots show filtering algorithms 
rows show dna english speech files respectively 
theta theta pi pi ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi pi ffl theta theta ffi theta theta theta theta pi pi ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi ffi pi pi ffl ffl ffl theta theta theta theta ffi ffi theta theta theta theta theta pi pi pi ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi pi pi pi ffl ffl ffl ffl theta theta theta theta ffi ffi ctf clp theta dfa rus pi bpr ffl ffi bpm qg qg theta bpp cnt pi ffl exp ffi bnd results varying left plots show non filtering right plots show filtering algorithms 
rows show dna english speech files respectively 
considered scenarios patterns longer error level keeps low 
scenario algorithms beat algorithms considering 
situation worse filters consider ff varying 
dna filter beat non filtering algorithms tricks keep active columns 
favors algorithms pack information bit bpm best cases better 
situation english text bpp works reasonably quite similar bpm periods dominates interleaved 
speech hand scenario similar non filtering algorithms pex filter beats errors low speech files 
note passing error level high qg qg applied short range yield bad results 
give idea areas algorithm dominates shows case english text 
information inferred previous plots area rus better bpm 
shown non filtering algorithms superimposed gray area filters dominate 
grayed area best choice corresponding filter dominating non filter verification engine 
non grayed area better dominating non filtering algorithm directly filter 
code implementing heuristic including exp bpp publicly available web page author combined code faster isolated algorithm course really single algorithm combination best choices 
reach tour approximate string matching 
goal explain main ideas exist existing algorithms classify type approach proposed show perform practice subset possible practical scenarios 
shown oldest approaches dynamic programming matrix yielded important theoretical developments general algorithms improved modern developments filtering bit parallelism 
particular fastest algorithms combine fast filter discard text fastest non filter algorithm check potential matches 
show plots summarizing contents survey 
shows historical order algorithms appeared different areas 
shows worst case time space complexity plot non filtering algorithms 
considers filtration algorithms showing average case complexity maximum error level ff 
practical assumptions order different functions oe approximate string matching active research area continue status foreseeable strong genome projects computational biology pressure oral human machine communication heterogeneity spelling errors textual databases just sample reasons driving researchers look faster flexible algorithms approximate pattern matching 
www dcc uchile cl 
apply exp option ep 
theta theta theta theta theta theta theta theta pi pi pi ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi pi pi ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl theta theta theta theta theta theta theta theta theta theta ffi ffi ffi theta theta theta theta theta theta theta theta theta theta pi pi pi ffl ffl ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi pi pi pi pi pi pi pi pi pi pi ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl theta theta theta theta theta theta theta theta theta theta ffi ffi ffi theta theta theta theta theta theta theta theta theta theta pi pi pi ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi pi pi pi pi pi pi pi pi pi pi ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl theta theta theta theta theta theta theta theta theta theta ffi ffi ffi ctf clp theta dfa rus pi bpr ffl ffi bpm qg qg theta bpp cnt pi ffl exp ffi bnd results ff varying left plots show non filtering right plots show filtering algorithms 
rows show dna english speech files respectively 
theta theta theta pi pi pi ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi pi pi ffl ffl theta theta theta theta theta theta ffi theta theta theta theta theta pi pi pi ffl ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi pi pi ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl theta theta theta theta theta theta theta theta theta theta ffi ffi theta theta theta theta theta theta pi pi ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi pi pi pi pi pi pi pi ffl ffl ffl ffl ffl ffl ffl ffl ffl ffl theta theta theta theta theta theta theta theta theta theta ffi ffi ffi ctf clp theta dfa rus pi bpr ffl ffi bpm qg qg theta bpp cnt pi ffl exp ffi bnd results ff varying left plots show non filtering right plots show filtering algorithms 
rows show dna english speech files respectively 
rus bpm bpr bpp pex areas algorithm best filtering algorithms 
interesting point theoretical practical questions open area 
ffl difficult open question exact matching probability average edit distance random strings 
new bound survey problem open 
ffl worst case lower bound problem clearly algorithms achieving space preprocessing cost exponential improvements worst case polynomial space complexity kn algorithms small 
possible improve algorithms find better lower bound case 
ffl previous question practical side possible find algorithm kn worst case efficient practice 
bit parallelism practical algorithms achieve kn average mn worst case 
ffl lower bound problem average case known log oe exists algorithm achieving theoretical point view problem closed 
practical side algorithms approaching limits long patterns simpler algorithm exp best moderate short patterns 
possible find unified approach practice theoretical complexity 
ffl practical question filtering algorithms possible practice improve current best existing algorithms 
ffl open questions related offline approximate searching mature area needing research 
sel mp algorithm lv ukk ukk best worst cases lv mye gg gp cl uw tu cl filter cl wmm wm wm byp ukk bit parallel wri cm tak avg 
lower bound mel st kur byn byn shi sv nav ch mye nby nby nr fastest practical dyn prog 
automata bit par 
filters historical development different areas 
author wishes top researchers area willingness exchange ideas share implementations amir ricardo baeza yates william chang udi manber gene myers erkki sutinen takaoka tarhio ukkonen wright 
aal amir aumann landau 
pattern matching swaps 
proc 
focs pages 
ac aho corasick 
efficient string matching aid bibliographic search 
comm 
acm 
dinic 
economic construction transitive closure directed graph 
soviet mathematics doklady 
original russian doklady nauk sssr 
sel lv cl gg uw gp gp mp lv exp ukk wmm oe mye byn wm kn mn mn log oe mye space time log ne mn log log ne ch worst case time space complexity non filtering algorithms 
replaced theta log 
ag apostolico galil 
combinatorial algorithms words 
nato isi series 
springer verlag 
ag apostolico 
longest common subsequence problem revisited 
algorithmica 
ag apostolico galil 
pattern matching algorithms 
oxford university press oxford uk 
agm altschul gish miller myers lipman 
basic local alignment search tool 
journal molecular biology 
ahu aho hopcroft ullman 
design analysis computer algorithms 
addison wesley 
ajs atallah jacquet szpankowski 
probabilistic approach pattern matching mismatches 
random structures algorithms 
amir 
pattern matching hypertext 
proc 
wads lncs pages 
springer verlag 
ara navarro ziviani 
large text searching allowing errors 
proc 
wsp pages 
carleton university press 
oe gammam oe gamma oe gammae oe cm nr cl st shi tak nby byn tu wm cl ukk nby byn kn log oe oe log oe ff ff log oe gammaff ff gammaff kn log byn byn gamma em oe km km woe max ff time gammae oe gammae oe ffn log oe log oe average time maximum tolerated error level filtration algorithms 
apo apostolico 
myriad virtues subword trees 
combinatorial algorithms words pages 
springer verlag 
blumer blumer haussler ehrenfeucht chen 
automaton recognizing subwords text 
theoretical computer science 
bm boyer moore 
fast string searching algorithm 
comm 
acm 
baeza yates 
efficient text searching 
phd thesis dept computer science university waterloo may 
research report cs 
baeza yates 
new results approximate string matching 
workshop data structures dagstuhl germany 

baeza yates 
text retrieval theory practice 
th ifip world computer congress volume pages 
elsevier science 
baeza yates 
unified view string matching algorithms 
theory practice informatics lncs pages 
springer verlag 
byg baeza yates gonnet 
new approach text searching 
comm 
acm 
preliminary version acm sigir 
byg baeza yates gonnet 
fast string matching mismatches 
information computation 
preliminary version tech 
report cs data structuring group university waterloo sept 
byn baeza yates navarro 
block addressing indices approximate text retrieval 
proc 
acm cikm pages 
extended version appear jasis 
byn baeza yates navarro 
multiple approximate string matching 
proc 
wads lncs pages 
springer verlag 
byn baeza yates navarro 
new faster filters multiple approximate string matching 
technical report tr dcc dept computer science university chile 
submitted 
ftp ftp dcc uchile cl pub users multi ps gz 
byn baeza yates navarro 
faster approximate string matching 
algorithmica 
preliminary versions proc 
cpm lncs proc 
wsp carleton university press 
byp baeza yates 
fast practical approximate pattern matching 
information processing letters 
preliminary version cpm lncs 
baeza yates 
fast algorithms dimensional multiple pattern matching 
proc 
swat lncs pages 
springer verlag 
baeza yates ribeiro neto editors 
modern information retrieval 
addisonwesley 
ccg crochemore rytter 
speeding string matching algorithms 
algorithmica 
ch cole 
approximate string matching simpler faster algorithm 
proc 
acm siam soda pages 
cl chang 
theoretical empirical comparisons approximate string matching algorithms 
proc 
cpm lncs pages 
springer verlag 
cl chang lawler 
sublinear approximate string matching biological applications 
algorithmica 
preliminary version focs 
clr cormen leiserson rivest 
algorithms 
mit press 
cm chang marr 
approximate string matching local similarity 
proc 
cpm lncs pages 
springer verlag 
cob 
fast approximate matching suffix trees 
proc 
cpm pages 
cr crochemore rytter 
text algorithms 
oxford university press oxford uk 
cro crochemore 
transducers repetitions 
theoretical computer science 
cs chv atal sankoff 
longest common subsequences random sequences 
journal applied probability 
cw walter 
string matching algorithm fast average 
proc 
icalp lncs pages 
springer verlag 
dam damerau 
technique computer detection correction spelling errors 
comm 
acm 
dek 
limit results longest common subsequences 
discrete mathematics 
dfg das gunopulos 
episode matching 
proc 
cpm lncs pages 
springer verlag 
dm dixon martin editors 
automatic speech speaker recognition 
ieee press 
eh ehrenfeucht haussler 
new distance metric strings computable linear time 
discrete applied mathematics 
el lancaster 
review segmentation contextual analysis techniques text recognition 
pattern recognition 
fps french powell schulman 
applications approximate word matching information retrieval 
proc 
acm cikm pages 
gonnet baeza yates 
handbook algorithms data structures 
addisonwesley nd edition 
gg galil giancarlo 
data structures algorithms approximate string matching 
journal complexity 
giegerich kurtz ohlebusch 
general technique improve filter algorithms approximate string matching 
proc 
wsp pages 
carleton university press 
preliminary version technical report universitat bielefeld germany 
gl grossi 
simple efficient string matching mismatches 
information processing letters 
gon gonnet 
tutorial computational biochemistry darwin 
technical report informatik switzerland 
gos gosling 
redisplay algorithm 
proc 
acm sigplan symp 
text manipulation pages 
gp galil park 
improved algorithm approximate string matching 
siam journal computing 
preliminary version icalp lncs 
gt gonz alez thomason 
syntactic pattern recognition 
addison wesley 
gus gusfield 
algorithms strings trees sequences 
cambridge university press 
hd hall dowling 
approximate string matching 
acm computing surveys 
hec heckel 
technique isolating differences files 
comm 
acm 
hor horspool 
practical fast searching strings 
software practice experience 
hs sutinen 
approximate string matching gram places 
proc 
th finnish symposium computer science pages 
university 
ht harel tarjan 
fast algorithms finding nearest common ancestors 
siam journal computing 
hu hopcroft ullman 
automata theory languages computation 
addison wesley 
jokinen tarhio ukkonen 
comparison approximate string matching algorithms 
software practice experience 
preliminary version technical report dept computer science university helsinki 
ju jokinen ukkonen 
algorithms approximate string matching static texts 
proc 
mfcs volume pages 
springer verlag 
kar karloff 
fast algorithms approximately counting mismatches 
information processing letters 
km kurtz myers 
estimating probability approximate matches 
proc 
cpm lncs pages 
springer verlag 
kmp knuth morris jr pratt 
fast pattern matching strings 
siam journal computing 
knu knuth 
art computer programming volume sorting searching 
addison wesley 
ks kumar spafford 
pattern matching model intrusion detection 
proc 
national computer security conference pages 
ks kececioglu sankoff 
exact approximation algorithms inversion distance permutations 
algorithmica 
kuk kukich 
techniques automatically correcting words text 
acm computing surveys 
kur kurtz 
approximate string searching weighted edit distance 
proc 
wsp pages 
carleton university press 
lev levenshtein 
binary codes capable correcting spurious insertions deletions ones 
problems information transmission 
lev levenshtein 
binary codes capable correcting deletions insertions reversals 
soviet physics doklady 
original russian doklady nauk sssr 
lg lawrence lee giles 
accessibility information web 
nature july 
lee kim park cho 
efficient algorithms approximate string matching swaps 
proc 
cpm lncs pages 
springer verlag 
ll lipton lopresti 
systolic array rapid string comparison 
proc 
chapel hill conference vlsi pages 
lms landau myers schmidt 
incremental string comparison 
siam journal computing 
ls szpankowski 
suboptimal lossy data compression approximate pattern matching 
ieee trans 
information theory 
lt lopresti tomkins 
electronic ink 
proc 
th international workshop frontiers handwriting recognition pages 
lt lopresti tomkins 
block edit models approximate string matching 
theoretical computer science 
lv landau vishkin 
fast string matching differences 
journal computer systems science 
preliminary version focs 
lv landau vishkin 
fast parallel serial approximate string matching 
journal algorithms 
preliminary version acm stoc 
lw wagner 
extension string string correction problem 
journal acm 
mas masters 
study spelling errors 
university iowa studies education 
mcc mccreight 
space economical suffix tree construction algorithm 
journal acm 
mel 
string matching differences finite automata 
proc 
icpr pages 
ieee cs press 
preliminary version computer analysis images patterns lncs 
mm muth manber 
approximate multiple string search 
proc 
cpm lncs pages 
springer verlag 
mor morrison 
patricia practical algorithm retrieve information coded alphanumeric 
journal acm 
mp paterson 
faster algorithm computing string edit distances 
journal computer system sciences 
mw manber wu 
glimpse tool search entire file systems 
proc 
usenix technical conference pages 
usenix association berkeley ca usa winter 
preliminary version technical report dept computer science university arizona oct 
mye myers 
incremental alignment algorithms applications 
technical report dept computer science university arizona 
mye myers 
nd difference algorithm variations 
algorithmica 
mye myers 
overview sequence comparison algorithms molecular biology 
technical report tr dept computer science university arizona 
mye myers 
sublinear algorithm approximate keyword searching 
algorithmica 
version technical report tr computer science dept university arizona sept 
mye myers 
algorithmic advances searching databases pages 
plenum press 
mye myers 
fast bit vector algorithm approximate pattern matching dynamic progamming 
proc 
cpm lncs pages 
springer verlag 
nav navarro 
multiple approximate string matching counting 
proc 
wsp pages 
carleton university press 
nav navarro 
partial deterministic automaton approximate string matching 
proc 
wsp pages 
carleton university press 
nav navarro 
approximate text searching 
phd thesis dept computer science university chile december 
technical report tr dcc 
ftp ftp dcc uchile cl pub users thesis ps gz 
nav navarro 
improved approximate pattern matching hypertext 
theoretical computer science 
appear 
previous version proc 
latin lncs 
nby navarro baeza yates 
improving algorithm approximate pattern matching 
technical report tr dcc dept computer science university chile 
submitted 
ftp ftp dcc uchile cl pub users dexp ps gz 
nby navarro baeza yates 
practical gram index text retrieval allowing errors 
electronic journal 
www cl nby navarro baeza yates 
fast multi dimensional approximate pattern matching 
proc 
cpm lncs pages 
nby navarro baeza yates 
new indexing method approximate string matching 
proc 
th annual symposium combinatorial pattern matching cpm lncs pages 
nby navarro baeza yates 
fast simple approximate string matching 
information processing letters 
nes 
accuracy approximate string matching algorithms 
journal computer instruction 
navarro moura ziviani baeza yates 
adding compression block addressing inverted indexes 
kluwer information retrieval journal 
appear 
nr navarro 
bit parallel approach suffix automata fast extended string matching 
proc 
cpm lncs pages 
springer verlag 
nr navarro 
fast flexible string matching combining bit parallelism suffix automata 
technical report tr dcc dept computer science university chile 
submitted 
ftp ftp dcc uchile cl pub users ps gz 
nw needleman wunsch 
general method applicable search similarities amino acid sequences proteins 
journal molecular biology 
om mcgregor 
fast approximate string matching 
software practice experience 
riv rivest 
partial match retrieval algorithms 
siam journal computing 
rs szpankowski 
approximate pattern occurrence text 
proc 
compression complexity sequences 
ieee press 
san sankoff 
matching sequences deletion insertion constraints 
proc 
national academy sciences usa volume pages 
sel sellers 
theory computation evolutionary distances 
siam journal applied mathematics 
sel sellers 
theory computation evolutionary distances pattern recognition 
journal algorithms 
shi shi 
fast approximate string matching blocks sequences 
proc 
wsp pages 
carleton university press 
sk sankoff kruskal editors 
time warps string edits macromolecules theory practice sequence comparison 
addison wesley 
sm sankoff 
common subsequences monotone subsequences pages 
addison wesley 
st sutinen tarhio 
gram locations approximate string matching 
proc 
esa lncs pages 
springer verlag 
st sutinen tarhio 
filtration samples approximate string matching 
proc 
cpm lncs pages 
springer verlag 
sun sunday 
fast substring search algorithm 
comm 
acm 
sut sutinen 
approximate pattern matching gram family 
phd thesis dept computer science university helsinki finland 
tech 
report 
sv schieber vishkin 
finding lowest common ancestors simplification parallelization 
siam journal computing 
sv vishkin 
approximate pattern matching locally consistent parsing 
manuscript university maryland institute advanced computer studies umiacs 
tak takaoka 
approximate pattern matching samples 
proc 
isaac lncs pages 
springer verlag 
tic tichy 
string string correction problem block moves 
acm transactions computer systems 
tu tarhio ukkonen 
greedy approximation algorithm constructing shortest common superstrings 
theoretical computer science 
tu tarhio ukkonen 
approximate boyer moore string matching 
siam journal computing 
preliminary version swat lncs 
ukk ukkonen 
algorithms approximate string matching 
information control 
preliminary version proc 
int 
conf 

comp 
theory lncs 
ukk ukkonen 
finding approximate patterns strings 
journal algorithms 
ukk ukkonen 
approximate string matching grams maximal matches 
theoretical computer science 
ukk ukkonen 
approximate string matching suffix trees 
proc 
cpm pages 
ukk ukkonen 
constructing suffix trees line linear time 
algorithmica 
ull ullman 
binary gram technique automatic correction substitution deletion insertion reversal errors words 
computer journal 
uw ukkonen wood 
approximate string matching suffix automata 
algorithmica 
preliminary version report dept computer science university helsinki april 
vin 
speech discrimination dynamic programming 
cybernetics 
wat waterman 
computational biology 
chapman hall 
wei weiner 
linear pattern matching algorithms 
proc 
ieee symp 
switching automata theory pages 
wf wagner fisher 
string string correction problem 
journal acm 
wm wu manber 
fast text searching allowing errors 
comm 
acm 
wm wu manber 
agrep fast approximate pattern matching tool 
proc 
usenix technical conference pages berkeley ca usa winter 
usenix association 
wmm wu manber myers 
sub quadratic algorithm approximate regular expression matching 
journal algorithms 
submitted 
wmm wu manber myers 
sub quadratic algorithm approximate limited expression matching 
algorithmica 
preliminary version technical report tr computer science dept university arizona 
wri wright 
approximate string matching word parallelism 
software practice experience 
yao yao 
complexity pattern matching random string 
siam journal computing 
yap frieder 
high performance computational methods biological sequence analysis 
kluwer academic publishers 
zd zobel dart 
phonetic string matching lessons information retrieval 
proc 
sigir pages 
appendix analyses source papers lack analysis analyze exactly interest provided simple analysis 
purpose survey rough figures 
particular analyses valid oe 
refer filters organized original paragraphs reader read algorithm description understand terminology 
tarhio ukkonen probability text character bad matching pattern positions bad gamma oe gamma oe try average bad characters finding bad 
bad characters bad abandon window 
hand probability verifying text window reaching 
approximate probability equating average portion traversed window bad obtain ff gamma oe wu manber sunday algorithm analyzed follows 
see far verify current window consider patterns fail 
fails average log oe character comparisons time fail longer 
yao bound yao log oe split test single pattern tests subpatterns fail log oe time breaking lower bound 
compute average shift consider characters different window character average shift oe final complexity kn log oe oe 
optimistic conjecture correct complexity 
upper bound obtained replacing adding times pieces fail 
navarro automaton matches text window errors surely ff characters inspected error level lower ff 
exponentially decreasing fl oe total steps 
point case exact string matching log oe characters inspected total ff log oe 
window shifted prefix matched errors ff distance window average 
window length gamma shift window gamma gamma ff average 
total amount ff ff log oe gamma ff ff gamma ff 
filter works probability finding pattern prefix errors window high 
say ff gamma gives ff 
gamma oe gamma oe 
ukkonen probability finding gram text window gamma gamma oe gamma gammam oe probability verifying text position finding gamma gamma kq grams pattern gamma gammaq kq delta gamma gammam oe gammaq interfere search time 
logarithms approximating stirling 
arrive kq log oe gamma log oe gamma gammam oe log oe gamma gammam oe log oe kq gamma log oe gamma replacing log oe obtain ff log oe log oe ff log oe log oe log oe quite common result type filters 
choice log oe result improves grows necessary log oe holds log oe gamma gammam oe zero result worsens 

