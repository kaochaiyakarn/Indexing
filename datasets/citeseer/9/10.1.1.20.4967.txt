fail processors approach designing computing systems richard schlichting university arizona fred schneider cornell university fault tolerant methodology facilitates design fault tolerant computing systems 
notion fail processor 
processor automatically halts response internal failure effects failure visible 
problem implementing processors high probability behave fail processors addressed 
axiomatic program verification techniques described developing provably correct programs fail processors 
design process control system illustrates methodology 
categories subject descriptors computer communications networks distributed systems network operating systems special purpose application sys tems real time systems operating systems reliability verification logics meaning programs specifying verifying reasoning programs general terms reliability verification additional key words phrases fail 
programming computer system subject failures difficult task 
malfunctioning processor perform arbitrary spontaneous state trans formations transformations specified programs executes 
correct program counted implement desired input output relation executed malfunctioning processor 
hand impossible build computer system operates correctly spite supported part nsf mcs 
authors addresses schlichting department computer science university arizona tucson arizona schneider department computer science cornell university ithaca new york 
originally submitted cm transactions programming languages systems 
responsible editor susan graham 
authors editor kindly agreed transfer acm transactions computer systems 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission association computing machinery 
copy republish requires fee specific permission 
acm acm transactions computing systems vol 
august pages 
fail processors failures components finite amount hardware goal implementing completely fault tolerant computing systems 
fortunately applications require complete fault tolerance 
sufficient system correctly provided predefined number failures occur time interval certain types failures occur 
modest goal attainable 
approach designing fault tolerant computing systems notion fail processor defined failure mode operating characteristics 
briefly approach follows 
software designed assuming existence computing system composed fail processors number processors required dictated response time constraints satisfied system 
computing system designed implements requisite fail processors 
proceed follows 
section describes characteristics fail processor considers processors approximated day hardware 
section discusses extensions axiomatic verification techniques facilitating development provably correct programs fail proc 
satisfying response time constraints presence failures subject section 
section discusses application approach nontrivial problem design fault tolerant process control system 
section contrasts approaches designing fault tolerant systems section presents 

fail processors definition processor characterized instruction set 
instruction causes defined transformation internal state processor connected storage peripheral devices 
effects executing instruction described precise semantic definition instruction set principles operation manual 
failure occurs behavior processor consistent semantic definition 
fail processor distinguished extremely simple failure mode operating characteristics 
internal state fail processor predefined portion connected storage assumed volatile contents volatile storage lost failure occurs 
remaining storage defined stable unaffected kind failure 
secondly contrast real processor fail processor performs erroneous state transformation due failure 
processor simply halts 
visible effects failure fail processor fsi stops executing 
fs internal state contents volatile storage connected lost 
sed quis 
shall guard guards vi 
acm transactions computer systems vol 
august 
schlichting schneider implementation notion fail processor useful abstraction impossible implement finite amount hardware 
finite amount hardware sufficient number failures disable error detection mechanisms allow arbitrary behavior 
possible con struct computing systems high probability approximate behavior fail processor 
approach construct system behaves specified failures occur specified time interval assump tions behavior 
fail processor computing system behaves fail processor failures occur components 
implementation fail processor described appears 
fail processor implemented exploiting solution byzantine generals problem interactive consistency problem 
protocol allows collection processors agree value sent potentially faulty transmitter commanding general nonfaulty processor agrees value sent transmitter transmitter nonfaulty nonfaulty processor receives value sent transmitter 
number real processors volatile memory units interconnected communications network form single fail processor attendant stable storage 
memory unit mi read processors written pi 
failures detected having processor run program comparing results 
copy variable stored memory unit 
execution value variable stable storage required value variable read memory unit solution byzantine generals problem employed distribute vector values read processor 
values identical failure occured signaled 
nonfaulty processors halt failure signaled 
total processors required order failures tolerated 
processors execute asynchronously execution replicated programs synchronized compare results 
accomplished assuming processor clocks run roughly rate associating logical clock program 
logical clock incremented variable supposed stored stable storage fail processor read written 
synchronize processor constructs vector values clocks solution byzantine generals problem marks time components vector value time period elapsed 
case failure occurred signaled 
collection fail processors interconnected implement system real time response constraints met despite failures 
case possible fail processor detect stopped read contents fail processor stable storage computation progress time failure continued 
acm transactions computer systems vol 
august 
fail processors accomplished follows 
fail processor connected communi cations network allows read contents memory units fail processors 
special location memory unit mi reserved record processor pi thinks fail processor part halted due failure 
fail processor fsp determines fsp halted computing vector values memory unit fsp solution byzantine generals problem 
components value true fsp deemed halted 
fsp require values variables stable storage fsp reconstructed follows 
processor fsp reads different memory units fsp 
solution byzantine generals problem values exchanged 
majority value taken value variable 
values read fsp wrong different memory units required implement stable storage 
feasibility implementing fail processors established argument practicality 
implementation highly reliable processors gives reason believe practical implement fail processor approximations 
sift configured behave collection fail processor approxima tions employ replicated processor memory units 
redundancy introduced lower levels variety ways 
level redundancy applied important issue treated 

programming fail processor recovery protocols program executing fail processor halted failure occurs 
execution may restarted correctly functioning fail processor 
may original processor cause failure repaired may fail processor 
program restarted internal processor state contents volatile storage unavailable 
routine needed complete state transformation progress time failure restore storage defined state 
routine called recovery protocol 
clearly recovery protocol execute correctly started intermediate state visible failure information stable storage 
addition code recovery protocol available failure kept stable storage 
associate recovery protocol sequence statements called action statement form fault tolerant action fta follows fta action recovery execution fta consists establishing recovery protocol effect executed executing execution fta interrupted acm transactions computer systems vol 
august 
schlichting schneider failure restart execution continues recovery protocol effect 
subsequent failures cause execution fta halted execution recovery protocol effect anew program restarted 
execution fta terminates execution performed entirety interruption 
time recovery protocol effect fta started reestablished fault tolerant action fta follows fta recovery protocol fta established 
syntactic abbreviation denote action statement serves recovery protocol fta action recovery fault tolerant action called restartable action 
program running fail processor times recovery protocol effect 
case program single fault tolerant action 
alternatively program structured sequence fault tolerant actions assuming establishment recovery protocol done way times old recovery protocol new effect 
assumption quite reasonable 
axioms fault tolerant actions floyd hoare axiomatic approach assertion boolean valued expression involving program logical variables 
syntactic object assertions programming language statement called triple 
triple theorem exists proof specified formal deductive system usually called programming logic 
programming logic consists set axioms rules inference relate assertions programming language statements triples 
particular interest logics sound respect execution programming language statements program state deductive systems consistent operation real machine 
notation usually taken mean execution begins state true terminates true resulting state 
numerous programming languages defined logics pas cal language extended guarded commands 
convenient write proof outline formal proof 
proof outline sequence programming language statements interleaved assertions 
statement proof outline preceded directly assertion called precondition denoted pre directly followed assertion called postcondition denoted post 
proof outline shall see fault tolerant action converted restartable action simply omitting action statement 
acm transactions computer systems vol 
august 
abbreviation proof fail processors poi statement triple pre post theorem programming logic adjacent proof outline provable fta fault tolerant action formed action statement recovery protocol wish develop inference rule allow derivation fta theorem preserving soundness programming logic respect execution fail processor 
assume fi proved 
execution establish need similarly recovery protocol establish hold recall invoked failure 
definition contents volatile storage undefined time 
program variables needed execution stable storage 
require program variables named stable storage 
ensure recovery protocol receives control stable storage state satisfies 
facilitated constructing replete proof outline proof outline contains assertions describing states visible failure 
require precondition recovery protocol satisfied states 
replete proof outline proof outline certain assertions deleted assertion appears adjacent fault tolerant actions 
rpo triple replete proof outline satisfies sequence fault tolerant actions invariant execution rpo rpo follow program state exists execution fault tolerant actions fta fta visible recovery protocol enclosing fault tolerant action recovery stronger wp variables may appear need stored stable storage 
interest minimizing amount stable storage proofs terms weakest assertions possible 
acm transactions computer systems vol 
august 
schlichting schneider protocol fta recovery protocol fta receive control 
rpo follows remains true executed true state visible recovery protocol failure occur appear assertions replete proof outline 
example proof outline fta fta pz 
fta fta fta 
fta pn replete proof outline 
assignment integer value variable performed executing single indivisible store instruction machines replete proof outline 
precondition postcondition true state occurs execution assignment 
assignment implemented execution single instruction val val replete proof outline assertion val destroyed assignment true execution val 
addition correct operation recovery protocol requires fault tolerant action action statement recovery protocol satisfying assertions appear replete proof outline rl rm assertions appear replete proof outline 
vi ai vi rl lastly guaranteed failures processors executing fta interfere invalidate assertions proof outline fta 
suppose assertion fta names variables stored volatile storage processor 
processor fail assertion longer true contents volatile storage lost 
require variables stored volatile storage may named assertions appearing programs executing processors 
fault tolerant action restartable action implements state transformation constructed recovery protocol 
proof follows 
theory action statement necessary actions concurrently executing processes synchronized 
example necessary assert collection processes executing phase time include assertions state 
see example reasoning 
acm transactions computer systems vol 
august 
fail processors unnecessary 
practice additional flexibility results having action statement different recovery protocol quite helpful 
ably failures infrequent recovery protocol consid amount extra order minimize amount expensive stable storage 
algorithms normal processing unacceptable 
fault tolerant programs simple example addition allowing axiomatic verification programs written terms fault tolerant actions permit programmer develop fault tolerant program proof hand hand proof leading way advocated 
allows variables stored stable storage identified mechanical way proof construction replete proof outline provides mechanical way determine intermediate states visible failure 
illustrate rules aid developing recovery protocol consider artificial problem 
substantial example treated section 
periodically variables updated previous values 
function routine called update desired runs fail processor satisfies specification update 
logical variables represent initial values respectively 
possibility failure ignored program suffice si xa sla pla plb ay note replete proof outline provided assignment implemented atomic operation pla invariant execution sla pla plb invariant execution 
things complicated possibility failure considered 
particular action statement restartable action violated assuming identity function pla plb false 
order construct restartable action find way progress compute destroying initial values values updated 
way modify new values computed stored temporary variables giving restartable action ui action recovery xnew xnew ulb xnew xnew acm transactions computer systems vol 
august 
schlichting schneider note order satisfy stored stable storage variables computing need 
having established simple matter establish xnew xnew xnew xnew replete proof outline provided xnew stored stable storage 
satisfied 
action recovery xnew xnew xnew xnew ay restartable action 
desired program 
termination response time statements programming notation guaranteed terminate started 
loops fault tolerant actions 
techniques variant functions founded sets proving loop terminate 
unfortunately knowledge frequency failures statement execution times termination program written terms fault tolerant actions proved 
failures occur sufficiently high frequency guarantee component fault tolerant actions terminate action statement recovery protocol fault tolerant action guaranteed run interruption recovery protocol continually restart 
liveness properties expressed hoare style programming logic 
resort informal means argue program terminate timely manner 
presumably point possible formalize arguments 
harter bernstein describe extensions temporal logic allow construc tion proof program meet specific response time goals 
extended deal stochastically defined events context 
execution program fault free processor maximum length time elapses execution statement begun execution fault tolerant action started 
define tmax max 
ses execution terminate sufficient intervals length vmax failures 
fault tolerant action forever restarted result high frequency failures 
acm transactions computer systems vol 
august 
fail processors course gives bound time elapse completes 
argued guaranteed terminate elapsed time successive failures long 
surprising 
provide insight structure program terms fault tolerant actions frequent failures expected endeavor minimize tmax 
achieved making entry fault tolerant action frequent event nesting fault tolerant actions composing sequence 
collection fail processors possible configure system implements relation input output performs state transformation timely manner despite occurrence failures 
failure fail processor fsp reconfiguration rule assign programs running fsp working fail processors 
recovery protocol effect time failure facilitates restart program 
processor failures transparent possibly increased execution times 
result failure execution delays sources incurred time elapse fail processor halts fact detected reconfiguration begun 
reconfiguration causes execution delays 
required determine appropriate assignment programs remaining fail processors 
required move program code contents stable storage 
worst case effects ta seconds execution action statement failure lost 
tr seconds worth execution repeated attempts perform recovery protocol result subsequent failure lost 
ta tr defined specific execution interrupted 
suggests strategy constructing fault tolerant systems continue behave correctly spite failures 
program developed implements desired state transformations run fail processors satisfies real time response constraints provided failures occur process respond event tf seconds tf tr 
tr ta 
fail processors required ensure hold 
computing system fail processors able tolerate fail processor failures meet response time goals 
obvious recon figuration nile 
note stable storage shared fail processors available 
precomputing various configurations negligible 
requires sufficient amount stable storage store possible configurations 
lastly tr restartable actions uniformly degrades execution speed failures occur 
acm transactions computer systems vol 
august 
schlichting schneider 
fault tolerant process control software turn substantial illustration application meth development fault tolerant process control program 
correct program fault free computing system developed 
program extended run correctly system fail processors 
fair amount detail details necessary derive establish correctness program 
sensors determine state environment actuators exert control environment 
correct operation process control system requires pc values written actuators related values read sensors application specific function 
correct operation involves liveness property sensors read actuators updated 
attempt argue program satisfies real time response constraints informal arguments developed section timing data available 
assuming failures process control system structured collection cyclic processes execute concurrently 
process pi responsible controlling set actuators acti 
reads sensors maintains statei vector state variables reflects sensor read actions taken 
interprocess communication accomplished disciplined shared variables process read write state variables read state variables maintained processes 
moment ignore problems arise concurrent access state variables 
process consist single loop 
execution loop body reads sensors computes new values actuators controls state variables maintains writes relevant values act updates statei 
presumably application dependent routines compute values written actuators values stored state variables 
loss generality assume state variable sensor read execution routines 
denote value read pi tth execution loop body sensors denote values read sensors tth execution loop body act denote values written acti tth execution loop body 
behavior satisfying pc characterized process pl 
pn 
values statei correctly encode past actions performed pi 
encoding denoted function code satisfies restriction written local variables store state variables sensor values state variable sensor value stored local variable read subsequent local variable 
acm transactions computer systems vol 
august 
st execution loop body fail processors cor statei sensors 
secondly values written actuators pi computed application specific function called sensor values read past actions processes 
pi updates act tth time cor acti sensors 

true 
ti auxiliary variable defined time ti executions loop body completed 
ti initialized implicitly automatically incremented immediately loop body executed 
correctness criterion pc satisfied true execution loop body process pi 
order construct loop variable newstate introduced 
necessary values update state actuators consistent 
newstate ffi sensors state 
loop process loop invariant pi process true 
calc newstate sensors statei state ti ti ti act acti newstate ti ti ti st state newstate ti ti ti od processes execute asynchronously access state variables synchronized 
process read state variables midst updated cause process perform wrong actions 
avoid problem state variables maintained process assumed characterized cci called consistency constraint statei 
cc kept true state updating variables performing st 
assume code compute application dependent functions works correctly long values satisfy consistency constraints read 
ensure values satisfying consistency constraints read read write locks implement reader writer exclusion state variables maintained process 
process trying read variables statei acquire read lock state 
lock granted write lock held state variables process delayed statei updated 
notation cor mean ifa true 
acm transactions computer systems vol 
august 
schlichting schneider process update statei delayed processes reading values 
lock operations explicitly included programs simplify exposition part routine compute calc st routine update state variables 
similarly assume code compute requires sensor values consistent 
natural laws govern physical world ensure time values sensors consistent 
process reads sensors simultaneously consistent values obtained 
simultaneous read operation implementable 
assume sensors change values slowly processes execute quickly consistent set values obtained reading sensors sequence normal execution speed 
allowing failures shall deal failures attempting mask effects 
endeavor preserve pc time state variables actuators values failure occurred 
recall characterizes values state variables actuators satisfy pc 
consequently possible modify loop body true state visible failure pc satisfied 
task modify loop body constitutes restartable action 
true execution statement act begins statement st completes 
mask intermediate states execution st act devise way execute st act atomic action 
option precluded hardware 
implement construct single fault tolerant action updates actuators state variables basis newstate ti ti ti ti long newstate saved stable storage replete proof outline satisfies accomplishes desired transformation 
action recovery ti act acti newstate ti ti st statei newstate ti ti ti replete proof outline code executed pi pi process action recovery true calc newstate sensors statei state ti ti acm transactions computer systems vo 
august 
od action recovery act acti newstate st statei newstate fail processors notice failure process attempt acquire read write lock granted 
example failure occurred st executed recovery protocol attempt acquire write lock statei owned pi 
clearly repeated requests process lock intervening release operations delay invoker 
implementation read write locks property binary semaphores suffice possible described 

discussion related general techniques developed aid design programs cope operational failures hardware support software 
paradigm state machines pioneered lamport 
program viewed state machine receives input generates actions output internal state 
reliable system constructed replicating state machines running parallel 
solution byzantine generals problem machine guaranteed receive input despite failures 
comparison state machine approach fail processors fault tolerant actions appears 
second general paradigm appears promising nested atomic transactions 
variety protocols specialized problems developed 
included protocols recovery database systems implementation highly reliable file systems checkpoint restart facilities operating systems 
despite apparent similarity recovery block construct developed university newcastle tyne fault tolerant actions constructs intended different purposes 
recovery block consists primary block acceptance test alternate blocks 
entry recovery block primary block executed 
completion acceptance test executed determine primary block performed acceptably 
test passed recovery block terminates 
alternate block generally different implementation algorithm attempted acceptance test repeated 
execution alternate block attempted sequence produces state acceptance test succeeds 
execution alternate block begun recovery block initial state 
recovery blocks mask design errors fault tolerant actions constructing programs cope operational failures lying hardware software 
recovery blocks cope operational acm transactions computer systems vol 
august 
schlichting schneider failures circumstances lead difficulties 
example recovery block finite number alternate blocks associated large number failures underlying system cause available alternatives exhausted 
secondly recovery block model admit possibility stable storage program variables 
fail processors definition fail processor underlying computational model followed partial correctness programming logic 
fail processor failures detected incorrect state transformations result failures 
execution statement terminates definition transformation specified statement occurred effect execution consistent programming logic 
hand failure definition prevents statements terminating 
partial correctness opposed total correctness nature programming logic subsumes consequences failures 
application methodology successfully employed methodology described verify existing fault tolerant protocols devise new ones 
phase commit protocol described verified 
process control example described section developed part project apply methodology design distributed computing system navigation airplane 
details discussed 
natural ask components proof rule fault tolerant actions restrictive 
case exist fault tolerant actions behave correctly proof possible 
proved relative completeness new rule success application way derived suggest restrictive allow proof correct fault tolerant action 

described methodology constructing fault tolerant systems 
notion fail processor processor simple defined failure mode operating characteristics 
fail processors appealing machines program approximated real hardware 
shown axiomatic program verification techniques extended proving correctness programs written fail processors 
allows programmer argue convincingly correctness program ex post facto 
important allows programmer develop fault tolerant program proof hand hand leading way advocated 
computing weakest precondition recovery protocol simple mechanical way determining program variables stored stable storage constructing replete proof outline similarly defines intermediate states visible failure states seen recovery protocol 
acm transactions computer systems vol 
august 
acknowledgments fail processors benefited discussions andrews conway constable dijkstra lamport levin reitman wall 
process control application suggested kemp comfort kushner ibm fsd 
gries helpful comments earlier draft 
referees careful reading 

avizienis fault tolerant systems 
ieee trans 
comput 
dec 

barlow mathematical theory reliability 
wiley new york 

denning fault tolerant operating systems 
comput 
surv 
dec 

dijkstra discipline programming 
prentice hall cliffs 

gray notes data base operating systems 
operating systems advanced course lecture notes computer science vol 

springer verlag new york pp 


gries science programming 
springer verlag new york 

harter bernstein proving real time properties programs temporal logic 
proc 
sosp asilomar california dec 

hoare axiomatic basis computer programming 
commun 
acm oct 

hoare wirth axiomatic definition programming language pascal 
acta inf 


hopkins smith highly reliable fault tolerant cessor aircraft 
proc 
ieee oct 

lamport time clocks ordering events distributed system 
commun 
acm july 

lamport time timeout fault tolerant distributed systems 
tech 
rep sri int june 

lamport shostak pease byzantine generals problem 
acm trans 
program 
lang 
syst 
july 

lampson atomic transactions 
distributed systems architecture implementation 
lecture notes computer science vol 
springer verlag new york pp 


lampson sturgis crash recovery distributed data storage system 
published 

owicki lamport proving liveness properties concurrent programs 
acm trans 
program 
lang 
syst 
july 

pease shostak lamport reaching agreements presence faults 
acm april 

pnueli temporal semantics concurrent programs 
semantics concurrent com putation lecture notes computer science vol 
springer verlag new york pp 


randell lee reliability issues computing system design comput 
surv 
june 

schlichting axiomatic verification enhance software reliability 
ph thesis dept comput 
sci cornell univ jan 

schlichting schneider understanding asynchronous message passing 
proc 
acm sigact sigops symp 
principles distributed computing ottawa canada aug acm new york pp 


schneider synchronization distributed programs 
acm trans 
program 
lang 
syst 
apr 

schneider fail processors 
digest papers spring compcon san francisco calif mar ieee computer society new york 

schneider schlichting fault tolerant process control software 
acm transactions computer systems vol 
august 
schlichting schneider proc 
eleventh ann 
int 
syrup 
fault tolerant computing portland maine june ieee computer society new york pp 


siewiorek theory practice reliable system design 
digital press bedford mass 

lamport goldberg green levitt melliar smith shostak weinstock sift design analysis fault tolerant computer aircraft control 
proc 
ieee oct 
received november revised july accepted february acm transactions computer systems vol 
august 
