draft empirical comparison java perl python rexx tcl search string processing program lutz prechelt prechelt ira uka de fakult ur informatik universit karlsruhe karlsruhe germany fax ira uka de eir technical report 
february implementations set requirements created different programmers various languages compared properties run time memory consumption source text length comment density program structure reliability amount effort required writing 
results indicate programming problem scripting languages perl python rexx tcl productive conventional languages 
terms run time memory consumption turn better java worse 
general differences languages tend smaller typical differences due different programmers language 
draft contents contents language comparisons origin programs non script group java 
script group perl python rexx tcl 
validity programs comparable 
programmer capabilities 
time reporting accuracy 
different task different conditions 
handling misunderstood requirement 
minor problems 
summary 
programming problem procedure description 
task requirements description 
hint 
results plots statistical methods 
number programs 
run time 
total data set 
initialization phase data set 
search phase 
memory consumption 
program length amount commenting 
program reliability 
time 
data 
validation 

program structure 
programmer self rating 
appendix raw data bibliography draft language comparisons comes pros cons various programming languages programmers computer scientists alike usually highly 
contrast relatively little high quality objective information available relative merits different languages 
scientific engineering literature provides comparisons programming languages different ways different restrictions purely theoretical discussions certain language constructs 
examples range famous letter go statement considered harmful comprehensive surveys languages 
non quantitative usually partly speculative 
works pure opinion pieces 
benchmarks comparing single implementation certain program language expressiveness resource consumption example 
comparisons useful extremely narrow slightly dubious implementations adequate 
done better language 
furthermore programs compared manner extremely small simple 
narrow controlled experiments focussing single language construct notational style 
empirical comparisons larger programs 
discuss instance defect rates productivity figures 
problem comparisons lack homogeneity language represented different programs unclear fraction differences lack differences originates languages fraction due different programmer backgrounds different software processes different application domains different design structures provides objective information comparing languages java perl python rexx tcl 
features ffl program implementation set requirements considered language 
comparison narrow homogeneous 
ffl language analyze single implementation program number separate implementations different programmers 
group wise comparison advantages 
smoothes differences individual programmers threaten validity comparison just implementation language 
second allows assess compare variability program properties induced different languages 
ffl different aspects investigated program length amount commenting run time efficiency memory consumption reliability 
origin programs programs analyzed report come different sources 
java programs produced course controlled experiment produced understood conditions submitted email 
programming task program called maps telephone numbers strings words dictionary fixed digit character encoding 
described section 
draft validity programs comparable 
non script group java java programs produced controlled experiment comparing behavior programmers previous psp personal software process training 
subjects computer science master students 
chose programming language freely 
subjects told main goal producing correct defect free program 
high degree correctness ensured acceptance test 
sample programs comprises passed acceptance test 
subjects decided give zero attempts passing test 
detailed information subjects experimental procedure 
script group perl python rexx tcl perl python rexx tcl programs submitted late volunteers posted call programs usenet newsgroups comp lang perl misc de comp lang perl misc comp lang rexx comp lang tcl comp lang tcl announce comp lang python comp lang python announce mailing list called fun perl org 
weeks call requirements description test data posted website viewing download 
participants told develop program test submit email 
registration way knowing participants started write program gave 
detailed information submission procedure section 
brevity brevity refer set languages perl python rexx tcl script languages respective programs scripts 
languages java correspondingly called non script languages programs non scripts 
validity programs comparable 
different conditions programs produced raise important question fair compare programs comparison say circumstances say programs 
put differently comparison valid 
subsections discuss problems threaten validity 
important threats usually occur language groups script non script caveats comparing particular script language non script language exist discussed necessary 
programmer capabilities average capabilities programmers may differ language 
plausible call programs attracted fairly competent programmers script programs reflect higher average programmer capabilities non script programs 
observations estimate difference small 
exceptions students created non script programs quite capable experienced see 
second script programmers described follows time spent learning language solving problem 
things learned 
language really know 
draft time reporting accuracy real application python 
th th python script 
programmer system administrator 
social scientist 
am vlsi designer programmer algorithms coding style may reflect 
tcl prog 
average intelligence tend hard 
insight think code 
lot time lost testing optimising bad approach 
taken expect script non script programmer populations roughly comparable ignore worst non script group counterparts script group probably submitted program 
keep mind interpretation results 
language groups modest differences languages occurred non script group java programmers tend experienced programmers reasons 
noticeably capable subjects chose second years java experience time experiment conducted java fairly young 
script group personal impression perl subjects tended capable 
reasons may perl language appears strange attraction highly capable programming fans fun perl mailing list posted call programs appears reach particularly high fraction persons 
time reporting accuracy times reported script programmers may inaccurate 
contrast non script programs controlled experiment know real programming time accurately kept script programmers rounding working times reported submitted program 
reported estimate time keep track actual programming mixing tasks breaks change watch files 
particular apparently read requirements days started implementing solution illustrated quotes design subconscious days total time include weeks reading requirements starting design code test subconscious may worked solution actual time spent pondering design bit indeterminate doing things eating cheese toast peering snow 
evidence described section average times reported reasonably accurate script group old rule thumb saying number lines written hour independent language holds fairly languages 
different task different conditions requirements statement materials provided conditions submission procedure different script versus non script group 
draft validity programs comparable 
requirements statement non script script programmers said correctness important aspect task 
announcement posted script programmers requirements description broader assignment mentioning programming effort program length program readability modularization maintainability elegance solution memory consumption run time consumption criteria programs judged 
focus difference may directed somewhat energy producing efficient program script group compared non script group 
hand things difference 
script group participants explicitly told please optimize program 
deliver reasonable solution 
second non script group highly inefficient programs filtered sent back optimization acceptance test test imposed time memory limit submission procedure script group 
difference regarding acceptance test reliability measurement procedures groups small dictionary test words small file inputs test correct outputs test program development initial testing plus large dictionary words 
acceptance test non script group performed randomly created input file different time medium large dictionary words 
failed acceptance test deduction compensation paid successful participation experiment dollars 
contrast script group input file corresponding correct outputs reliability measurement report perform tests data pleased 
possessing data arguably advantage script group respect time required 
note acceptance test non script group automatically flagged reported mistakes separately script group perform comparison correct output actual output 
web page mentioned unix utilities sort diff automating comparison 
serious problem probably different working regime mentioned script group participants thought solution days producing participants started solution right reading requirements 
probably advantage script group 
thirds non script group longer breaks night days occurred 
summing say tasks groups reasonably similar specific comparison clearly taken grain salt 
probably advantage script group respect conditions unmeasured thinking time actual implementation 
severe results differences relied 
handling misunderstood requirement important statement requirements third programmers groups misunderstood see section resulting incorrect program 
programmers able resolve problem help required 
help provided non script programmers follows failed acceptance test due problem respective sentence requirements pointed advice reading extremely carefully 
find problem approached experimenter help misunderstanding explained 
programmers able resolve problem 
cases correcting mistake faulty program trivial 
mb total seconds maximum output plus minutes loading mhz sparc ultra draft minor problems script programmers interaction possible requirements description posted web contained pointer hint direction re read requirements carefully open hint problem resolved 
exact wording organization shown section 
easier access hint may produced advantage respect time script group hard say extent happened 
hand members script group hard time understanding actual formulation hint 
personal impression observations non script group feedback received participants script group typical time penalty misunderstanding requirement similar script non script group 
minor problems non script programmers slight disadvantage forced implement particular computer 
complain major problem 
script programmers machine programming environment 
rexx programs may experience small disadvantage platform evaluated rexx implementation called regina platform originally developed 
java programs evaluated newer version jdk java development kit originally developed 
context changes probably major importance 
summary probably fair say ffl due design data collection data script groups reflect relevant modest priori advantages compared data non script groups ffl modest differences average programmer capability languages 
due threats validity discount small differences languages weaknesses data 
large differences just clearly valid 
programming problem problem solved participants study authors programs investigated called 
exact problem description subjects non script group printed appendix 
subsections reproduce description web page participants script group 
equivalent respect functional requirements program different respect submission procedure underlined parts text hyperlinks original web page 
draft programming problem procedure description paragraphs left purpose website collecting implementations program scripting languages comparing languages ones mentioned 
languages question ffl perl ffl python ffl rexx ffl tcl properties interest comparison ffl programming effort ffl program length ffl program readability modularization maintainability ffl elegance solution ffl memory consumption ffl run time consumption ffl correctness robustness interested 
interested participating study please create implementation program described send email 
collect programs december 
date evaluate programs send results 
effort involved implementing depends mistakes 
previous experiment programmers typically finished hours average ones typically take hours 
went badly wrong took longer course original experiment saw times hours percent participants 
hand problem easier scripting language compared java expect effort indicated 
interested 
great 
procedure follows 
read task description benchmark 
describes program 

download ffl small test dictionary test ffl small test input file test ffl corresponding correct results test ffl real dictionary ffl input file ffl corresponding correct results ffl single zip file 

fetch program header fill convert appropriate comment syntax language basis program file 
draft task requirements description 
implement program single file 
sure measure time take separately design coding testing debugging 
running test test test test works data 
start testing 
restriction necessary similar ordering imposed subjects original experiment helpful large data earlier anyway 

note testing ffl sure program works correctly 
fed produce contents ordering outputs 
compare actual output sort compare line line diff example 
ffl find differences convinced program correct wrong respect task description re read task description carefully 
people misunderstand particular point 
absolutely guarantee appropriate requirements 

don find problem re reading requirements carefully read hint 

submit program email prechelt ira uka de subject submission preferably inserting program plain text watch email software insert additional line breaks 


constraints ffl please sure program runs perl python tcl rexx regina respectively 
executed solaris platform sunos running sun ultra ii 
ffl please single source program file files give file name xx xx suffix common programming language 
ffl please optimize program 
deliver reasonable solution 
ffl please honest time report point cheating 
ffl please design implement solution 
cooperate somebody comparison distorted 
task requirements description consider mapping letters digits want mapping encoding telephone numbers words easier remember numbers 
functional requirements task writing program finds phone number possible encodings words prints 
phone number arbitrary 
string dashes slashes digits 
dashes slashes encoded 
words taken dictionary alphabetically sorted ascii file word line 
exactly encoding possible dictionary matches phone number exactly shall printed 
possibly printed 
words dictionary contain letters capital small draft programming problem difference ignored sorting dashes double quotes 
encoding letters words printed exactly form dictionary 
leading non letters occur dictionary 
encodings phone numbers consist single word multiple words separated spaces 
encodings built word word left right 
particular point word dictionary inserted single digit phone number copied encoding 
subsequent digits allowed 
put differently partial encoding currently covers digits digit encoded digit encoded digit second word dictionary encoding starting digit 
program series phone numbers encoding finds print phone number followed colon single 
space encoding line trailing spaces allowed 
remaining ambiguities specification resolved example 
remaining ambiguities intended degrees freedom 
dictionary file test blau bo boot bo da fee fern fort je mir mix mixer name neu ort tor phone number list file test program start command test test corresponding correct program output screen draft hint mir tor mix tor fort tor neu je bo je bo da tor fort tor output wrong different ordering lines 
wrong outputs example mix tor formatting phone number incorrect je bos formatting second word incorrect ort place digit words fort tor je bo da subsequent digits encoding tor encoding cover phone number mir encoding longer phone number 
data available files test dictionary test telephone numbers test program output 
quantitative requirements length individual words dictionary characters maximum 
number words dictionary maximum length phone numbers characters maximum 
number entries phone number file unlimited 
quality requirements carefully professional software engineer deliver correspondingly high grade program 
specifically thoroughly comment source code design ideas 
focus program construction shall correctness 
generate exactly right output format right start 
generate additional output 
automatically test program hundreds thousands phone numbers single mistake possible particular crash 
take time required ensure correctness 
program run time efficient far analyzes small fraction dictionary entries word appending step 
memory efficient times bytes storing dictionary contains shorter words 
dictionary read main memory entirely phone number file may arbitrarily large 
program need robust incorrect formats dictionary file phone number file 
hint hint referred procedure description shown section refers file containing hint please read hint preparation 
draft results read really find wrong program output conform think program correct 
situation read actual hint 
link refers file hint program finds superset encodings shown probably met pitfall 
people misunderstand requirements respect insertion digits follows 
insert digit inserted word point complete encoding phone number 
backtracking 
incorrect 
encodings built step step strictly left right decision insert digit point changed 
sorry confusion 
original test ambiguity able compare new times old ones spec remain ran problem please report time spent finding repairing put number minutes special events section program header comment 
lot 
results programs evaluated dictionary participants 
different input files contains non empty random phone numbers contains arbitrary random phone numbers empty ones allowed contains phone number measuring dictionary load time 
extremely slow programs stopped timeout minutes output plus minutes loading dictionary quarters programs finished run outputs minutes 
plots statistical methods plots statistical methods evaluation described detail give short description 
main evaluation tool multiple boxplot display see example page 
lines represents subset data named left 
small circle stands individual data value 
rest plot provides visual aids comparison subsets data 
shaded box indicates range middle half data quartile quantile third quartile quantile 
whiskers left right box indicate bottom top data respectively 
fat dot box median quantile 
dashed line indicate arithmetic mean plus minus standard error mean 
interesting observations easily directly plots 
quantifying provide results statistical tests medians compared wilcoxon rank sum test mann whitney test cases means compared test 
tests performed sided test results reported values probability observed differences samples accidental difference difference opposite direction underlying populations exist 
draft number programs table non script programming language number programs originally prepared progs number subjects voluntarily participated second time year second number programs pass acceptance test unusable final number programs study total 
script programming language number programs submitted progs number programs second number programs run unusable final number programs study total 
language progs second unusable total java perl python rexx tcl total points provide confidence intervals differences means differences logarithms means ratios means 
confidence intervals computed bootstrapping 
chosen open ended upper infinity 
bootstrapping described detail 
note due caveats described section quantitative statistical inference results merely indicate trends considered precise evidence 
explicitly describing variability group values bad ratio imagine data split upper lower half bad ratio median upper half divided median lower half 
boxplot just value right edge box divided value left edge 
contrast variability measure standard deviation bad ratio robust extremely high values occur data set 
number programs shown table set programs analyzed study contains programs language programs 
results rexx programs respectively coarse estimates reality languages programs broad base reasonably precise results 
note sample covers different programs different authors 
run time programs executed mhz sun ultra ii workstation mb memory running sunos solaris compilers interpreters listed table total data set global overview program run times input file shown 
see languages slow programs exist java rexx quarters programs run minute 
draft results table compilers interpreters various languages 
note java platform java evaluation uses jdk hotspot version performance tuned version 
avoid unfair disadvantages compared languages java run time measurements reflect modifications appropriate jdk solaris production version jit may short running programs tuned jit faster untuned hotspot compiler 
second programs measured special version java util vector dynamic array class enforcing synchronization 
similar java util arraylist jdk thing available jdk programs written 
language compiler execution platform gnu gcc gnu java sun jdk perl perl python python rexx regina tcl tcl oo java perl python rexx tcl run time minutes program run time data set 
programs timed output minutes 
tcl program took minutes 
bad ratios range tcl 
oo java perl python rexx tcl run time seconds program run time data set 
equivalent axis logarithmic indicates seconds minutes 
draft run time order see discriminate data points logarithmic plot shown 
interesting observations ffl typical median run time tcl significantly longer java sided wilcoxon test 
attention don confused median 
distance larger smaller points large unstable 
wilcoxon test takes sample account confirms median fact tends smaller java median 
ffl median run times python smaller rexx tcl 
tend smaller java 
ffl median run times perl smaller rexx tcl 
ffl mentioned doesn look median tends smaller java 
ffl slow programs tcl perl run times tend smaller variability run times languages 
example sided bootstrap test differences interquartile range logarithmic run times differences box width perl python indicates 
remember interpret plots rexx points 
aggregate languages groups shown find run time advantage statistically significant compared scripts advantage accidental probability median log mean test 
compared java advantage accidental median log mean 
oo java script run time seconds program run time data set logarithmic axis just samples languages aggregated larger groups 
bad ratios script java 
larger samples aggregate grouping allow computing reasonable confidence intervals differences 
bootstrap estimated confidence interval log run time means difference run time ratio indicates confidence script run times long program higher log run time variability 
java program expected run times long program 
significant difference average java script run times 
initialization phase data set repeat analysis case program reads stores dictionary programs preprocessing phase accelerate execution 
shows corresponding run time 
draft results java perl python rexx tcl run time seconds program run time loading preprocessing dictionary data set 
note logarithmic axis 
bad ratios range tcl python 
java script run time seconds program run time loading preprocessing dictionary data set just samples languages aggregated larger groups 
bad ratio script java 
find clearly faster situation programs 
fastest script languages perl python 
rexx tcl slower java faster 
aggregate grouping find compared program java program run times long script run times long confidence level 
compared java program script run times long 
search phase may subtract run time loading phase data set total run time data set obtain run time actual search phase 
note time differences separate program runs 
due measurement granularity zero times result 
rounded second 
shows corresponding run times 
find fast programs occur languages rexx tcl slow programs occur languages exception 
specifically ffl median run time tcl longer python perl shorter rexx 
ffl median run times python smaller rexx tcl 
tend smaller java 
draft memory consumption java perl python rexx tcl run time loading seconds program run time search phase 
computed time data set minus time data set 
note logarithmic axis 
bad ratios range perl fact unreliable due imprecise lower bound 
java script run time loading seconds program run time search phase 
computed time data set minus time data set 
just samples languages aggregated larger groups 
bad ratio script java fact unreliable due estimated lower bound 
ffl median run times perl smaller rexx tcl java 
ffl doesn look median significantly different sided tests yield 
aggregated comparison indicates significant differences groups pairs medians pairs means 
bootstrap test differences box widths indicates confidence run time variability scripts smaller java factor smaller factor 
memory consumption memory required programs 
shows total process size program execution input file 
observations interesting ffl memory efficient programs clearly smaller ones groups 
ffl memory efficient programs clearly java programs 
draft results java perl python rexx tcl memory consumption mb amount memory required program including interpreter run time system program static dynamic data structures 
bad ratios range python 
oo java script memory consumption mb languages aggregated groups 
bad ratios script java 
ffl tcl scripts consume memory worse half programs 
ffl tcl scripts require memory scripts 
ffl python perl relative variability memory consumption tends smaller particular 
ffl scripts high memory consumption 
ffl average see confidence java programs consume mb memory programs mb memory script programs 
script programs consume mb programs 
conclude memory consumption java typically twice high scripts scripts necessarily worse program written beat parsimonious program 
program length amount commenting long programs 
comments contain 
draft program reliability shows number lines containing contributes semantics program program source files statement declaration delimiter closing brace block marker 
oo oo java perl python rexx tcl program length statement loc program length measured number non comment source lines code 
bad ratios range java rexx 
see non scripts typically times long scripts 
longest scripts shorter average non script 
java perl python rexx tcl comment density stmt loc percentage comment lines plus commented statement lines relative number statement lines 
bad ratios range rexx tcl 
time scripts tend contain significantly higher density comments averaging median comment lines commented lines statement lines scripts averaging 
program reliability programs conform requirements specification 
reliable 
draft results programs data set processes correctly simple example dictionary phone number input file including file containing expected outputs participants program development 
large dictionary partially quite strange unexpected phone numbers larger input files programs behaved entirely correctly 
percentage outputs correct plotted 
oo java perl python rexx tcl reliability percent program output reliability percent input file 
programs perl python produced correct outputs unable load large dictionary timed load phase 
java programs failed near zero reliability reasons rexx program produced outputs incorrect formatting resulting reliability percent 
language programs tcl 
java script reliability percent program output reliability percent programs reliability percent languages aggregated groups 
ignore mentioned faulty programs compare rest programs reliability percent excluding programs java programs script programs language group find java programs tend reliable script programs tend better programs 
differences depend just programs showing small set different behaviors generalized 
instructive compare behavior evil minded input file disregarding programs known faulty described 
input set contains phone numbers length content random contrast allows phone numbers contain digits dashes slashes 
phone number correct encoding empty draft time usually think inputs reading requirements 
input file tests robustness programs 
results shown 
java script reliability percent program output reliability input file percent programs reliability percent languages aggregated groups 
programs cope situation half java programs script programs tcl python crash encounter empty phone number happens outputs usually due illegal string subscript array subscript 
note huge size box java data quite arbitrary completely depends position empty telephone number input file 
phenomenon large differences 
programs java perl python rexx fail exactly empty phone numbers resulting reliability 
summing appears warranted say scripts reliable non scripts 
time long programmers taken design write test program 
data figures show total time reported script programmers measured programmers 
see scripts take half long non scripts 
note meaning measurements exactly non script times include time required reading requirements script participants apparently count time 
second non script participants started working solution immediately reading requirements script participants started days include time thinking program design see quotes section 
third script participants estimated measured time 
know non script participants honest time reporting 
validation fortunately way check things correctness time reporting equivalence programmer capabilities script versus non script group 
note possible problems tend bias script group times downwards expect cheaters fake time smaller larger expect see capable programmers draft results java perl python rexx tcl total time programming hours total working time realizing program 
script group times measured reported programmers 
non script group times measured experimenter 
bad ratios range perl 
java times hours shown 
java script total time programming hours languages aggregated larger groups 
bad ratio script java 
capable ones script group compared non script group programmer capabilities different average 
check relies old rule thumb says programmer productivity measured lines code hour loc hour roughly independent programming language extreme exceptions apl assembler time required coding testing program determined amount functionality expressed line time required line roughly constant 
rule empirical explained cognitive psychology programmer reasonably fluent programming language line code important unit thinking coding debugging phases 
dominant capacity limit short term memory units plus minus suggests effort required constructing program longer lines may roughly proportional number lines time required correctly creating handling unit constant independent amount information represented unit 
widely effort estimation methods explicitly assume productivity lines code hour independent programming language barry boehm 
popular software estimation model uses software size measured loc input predicts cost schedule 
various called cost drivers allow adjusting estimate instance level domain experience level programming language experience required program reliability level programming language cost drivers boehm writes 
amount effort source statement highly independent language level 

cites independent research suggesting particular study ibm felix 
draft time table excerpt jones programming language table languages study 
ll language level loc fp number lines code required function point 
see main text explanation 
language ll loc fp java perl python rexx tcl second jones language list function point method 
function points software size metric depends solely program functionality independent programming language 
jones publishes list programming languages indicates language loc fp number lines typically required implement function point called language level ll productivity factor indicating number function points realized time unit language ll fp depends capabilities programmers list ll exactly inversely proportional loc fp concretely ll fp just different way saying productivity language fixed loc fixed time unit independent studies confirming language productivity differences respect function points time published 
table provides relevant excerpt language table relates data actual productivity observed study 
median time java perl rexx tcl actual language list actual median times language compared expect relative productivity jones programming language list normalized java times exactly predicted 
find language list underestimates productivity tcl problem 
problem suited contrast language levels indicated jones 
tcl language level may typo read 
languages prediction table fairly accurate 
accept statement number lines written hour independent programming language rule thumb study 
validation time data rule plotted 
judging productivity range java data points top tcl top perl quite believable 
particular python medians range 
loc productivity plot lends lot credibility reported times productivity values outside reliable range experiment non script programs 
median differences clearly statistically significant closest java versus perl python tcl 
draft results java perl python rexx tcl source text productivity loc hour source text productivity non comment lines code total hour 
bad ratios range tcl 
java script source text productivity loc hour languages aggregated groups 
bad ratio script java 
aggregated view larger groups difference scripts significant difference java scripts difference loc hour confidence 
comparison lends lot credibility time comparison shown 
times reported script programming probably modestly optimistic time advantage script languages factor holds 
java script non comment loc data program lengths times shown separately 
lines standard squares regression line prediction interval 
note logarithmic axes 
shows data dimensional plot including regression line draft program structure logarithmically predicting time expected size 
higher productivity script languages shows trend line lying lower plot 
line shows non linear increase effort programs twice long take twice time 
probably due fact best programmers productive wrote compact code 
program structure considers designs chosen authors programs various languages striking difference 
programmers script group associative arrays provided language stored dictionary words retrieved number encodings 
search algorithm simply attempts retrieve array prefixes increasing length remaining rest current phone number key 
match leads new partial solution completed 
contrast essentially non script programmers chose solutions 
simple case simply store dictionary array usually original character form corresponding phone number representation 
select test tenth dictionary digit phone number encoded digit key constrain search space 
leads simple inefficient solution 
elaborate case uses ary tree node represents certain digit nodes height representing th character word 
word stored node path root node represents number encoding word 
efficient solution requires comparatively large number statements implement tree construction 
java large resulting number objects leads high memory consumption due severe object memory overhead incurred current implementations language 
shorter program length script programs explained fact actual search done simply hashing algorithm internally associative arrays 
contrast non script programs array tree implementations require mundane elementary steps search process coded explicitly programmer 
pronounced effort lack data structure declarations 
interesting observation despite existence hash table implementations java class libraries non script programmers implemented tree solution hand script programmers hash tables built language obvious choice 
programmer self rating non script programmers asked questions previous programming experience described detail 
unfortunately questions predictive value aspect programmer performance experiment delve data 
script programmers asked single question tend rate follows compared programmers replace dot upper percent upper percent upper percent upper percent draft results lower percent lower percent lower percent scale programmers scripts rated upper percent top 
programmers scripts rated lower gave answer 
languages large self rating differences compare sets self ratings language wilcoxon rank sum test normal approximation ties significant difference language pairs 
correlations self rating actual performance higher self ratings tend somewhat associated lower run time illustrated rank correlation shorter time producing program rank correlation 
run time minutes relationship program efficiency higher self rating correlated faster programs 
uppermost boxplot represents non script programs 
note logarithmic axis 
oo time hours relationship working time writing program higher self rating correlated shorter time 
uppermost boxplot represents programs 
note logarithmic axis 
clear association memory consumption program length comment length comment density program reliability 
draft statements summarize findings comparative analysis implementations program different languages ffl designing writing program perl python rexx tcl takes half time writing java resulting program half long 
ffl significant differences program reliability language groups observed 
ffl typical memory consumption script program twice program 
java factor higher 
ffl initialization phase program reading mb dictionary file creating entry internal data structure programs strong run time advantage factor compared java compared script languages 
ffl main phase program search internal data structure advantage run time versus java factor script programs tend faster java programs 
ffl script languages python particular perl faster rexx tcl phases 
ffl program aspects investigated performance variability due different programmers described bad ratios large larger variability due different languages average 
due large number implementations broad range programmers investigated results taken grain salt probably reliable despite validity threats discussed section 
emphasized results valid problem generalizing different application domains haphazard 
problems results script group languages quite 
emphasize problem chosen script group languages look originally developed non trivial defined benchmark programmers ability writing reliable programs 
conclude things ffl jdk solaris platform memory overhead java huge compared run time efficiency quite acceptable 
ffl called scripting languages perl python rexx tcl reasonable alternatives conventional languages tasks need handle fair amounts computation data 
relative run time memory consumption overhead acceptable may offer significant advantages respect programmer productivity small programs problem 
ffl interpersonal variability capability behavior differences programmers language tends account differences programs change programming language 
draft appendix raw data appendix raw data find important variables raw data set analyzed report 
meaning variables left right subject id person programming language lang run time input file minutes run time input file minutes memory consumption run input file kilobytes mem program length statement lines code output reliability input file percent rel output reliability input file percent rel total subject time hours subject answer capability question consider top percent programmers caps 
person lang mem rel rel caps 















java 
java 
java 
java 
java 
java 
java 
java 
java 
java 
java 
java 
java 
java 
java 
java 
java 
java 
java 
java 
java 
java 
java 
draft java 
perl perl perl na perl perl perl perl perl perl perl perl perl perl python python na python python python python python python python python python python python rexx rexx rexx rexx tcl tcl tcl tcl tcl tcl tcl tcl tcl tcl draft allan albrecht jr john software function source lines code development effort prediction software science validation 
ieee transactions software engineering se november 
charles 
measuring productivity computer systems development activities function points 
ieee transactions software engineering se november 
barry boehm 
software engineering economics 
prentice hall englewood cliffs nj 
jean pierre briot rachid guerraoui klaus peter 
concurrency distribution objectoriented programming 
acm computing surveys september 
software productivity research jones 
programming languages table version 
www spr com library htm feb 
edsger dijkstra 
go statement considered harmful 
communications acm 

novice programmer errors language constructs plan composition 
intl 
human computer studies 
bradley efron robert tibshirani 
bootstrap 
monographs statistics applied probability 
chapman hall new york london 
les 
oo sync think 
ieee software march 
paul hudak mark jones 
haskell vs ada vs vs awk vs 
experiment software prototyping productivity 
technical report yale university dept cs new haven ct july 
watts humphrey 
discipline software engineering 
sei series software engineering 
addison wesley reading ma 
robert douglas bock 
third fourth generation language productivity differences 
communications acm september 
jurgen koenemann thomas scott robertson editors 
empirical studies programmers fourth workshop new brunswick nj december 
ablex publishing john lewis henry dennis kafura robert schulman 
relationship object oriented paradigm software reuse empirical investigation 
object oriented programming 
george miller 
magic number plus minus 
psychological review march 
michael philippsen 
imperative concurrent object oriented languages 
technical report tr international computer science institute university california berkeley ca august 
lutz prechelt barbara unger 
controlled experiment effects psp training detailed description evaluation 
technical report fakultat fur informatik universitat karlsruhe germany march 
ftp ira uka de 
scanlan 
structured flowcharts outperform pseudocode experimental comparison 
ieee software september 
draft richard shiffrin robert nosofsky 
plus minus commentary capacity 
psychological review 
felix 
method programming measurement estimation 
ibm systems journal 
