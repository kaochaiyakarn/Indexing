centrum voor wiskunde en informatica survey program slicing techniques tip computer science department software technology cs survey program slicing techniques frank tip cwi box gb amsterdam netherlands tip cwi nl program slice consists parts program potentially affect values computed point interest referred slicing criterion 
task computing program slices called program slicing 
original definition program slice weiser 
various slightly different notions program slices proposed number methods compute 
important distinction static dynamic slice 
notion computed making assumptions regarding program input relies specific test case 
procedures arbitrary control flow composite datatypes pointers interprocess communication require specific solution 
classify static dynamic slicing methods features compare accuracy efficiency 
possibilities combining solutions different features investigated 
discuss compiler optimization techniques obtain accurate slices 
concluded overview applications program slicing include debugging program integration dataflow testing software maintenance 
mathematics subject classification theory computing semantics theory computing specification verification programs 
cr categories software engineering tools techniques software engineering testing debugging software engineering programming environments software engineering distribution maintenance 
key words phrases program slicing static slicing dynamic slicing program analysis debugging data dependence control dependence program dependence graph 
slice thin flat piece cut wedge shaped blade serving fish flight ball golf curves direction dominant hand player slice vb sliced slic ing cut slice cut slices hit ball slice results merriam webster dictionary overview survey algorithms program slicing literature 
program slice consists parts program potentially affect values computed point interest referred slicing criterion 
typically slicing criterion consists pair line number variable 
parts program direct indirect effect values computed slicing criterion called program slice respect criterion task computing program slices called program slicing 
original concept program slice introduced weiser 
weiser claims slice corresponds mental abstractions people debugging program suggests integration program debugging environments 
various slightly different notions program slices proposed number methods compute slices 
main reason diversity fact different applications require different properties slices 
weiser defined program slice reduced executable program obtained program removing statements replicates part behavior common definition slice subset statements control predicates program directly indirectly affect values computed criterion necessarily constitute executable program 
important distinction static dynamic slice 
notion computed making assumptions regarding program input relies specific test case 
sections consider notions detail 
features programming languages procedures arbitrary control flow composite datatypes pointers interprocess communication require specific solution 
static dynamic slicing methods features classified compared terms accuracy efficiency 
addition investigate possibilities integrating solutions different language features 
slicing algorithms compared applying similar examples 
static slicing shows example program asks number computes sum product positive numbers 
shows slice program respect criterion product 
seen computations involving variable sum sliced away 
weiser approach slices computed computing consecutive sets indirectly relevant statements data flow control flow dependences 
statically available information computing slices type slice referred static slice 
alternative method computing static slices suggested ottenstein ottenstein restate problem static slicing terms reachability problem program dependence graph pdg 
pdg directed graph vertices corresponding statements control predicates edges corresponding data control dependences 
slicing criterion identified vertex pdg slice corresponds pdg vertices vertex consideration reached 
various program slicing approaches discuss utilize modified extended versions pdgs underlying program representation 
read sum product sum sum product product write sum write product read product product product write product example program 
slice program criterion product 
approach proposed carr define slices terms information flow relations derived program syntax directed fashion 
slices mentioned far computed gathering statements control predicates way backward traversal program starting slicing criterion 
slices referred backward static slices 
carr define notion forward static slice reps terminology 
informally forward slice consists statements control predicates dependent slicing criterion statement dependent slicing criterion values computed statement depend values computed slicing criterion values computed slicing criterion determine fact statement consideration executed 
backward forward slices computed similar way requires tracing dependences forward direction 
dynamic slicing exact terminology dynamic program slicing introduced korel laski dynamic slicing may regarded non interactive variation balzer notion analysis 
analysis interested information flows program obtain particular value user interactively traverses graph represents data control dependences statements program 
example value computed statement depends values computed statement user may trace back vertex corresponding statement vertex statement analysis implemented efficiently parallel programs 
case dynamic program slicing dependences occur specific execution program taken account 
dynamic slicing criterion specifies input distinguishes different occurrences statement execution history typically consists triple input occurrence statement variable 
alternate view difference static dynamic slicing dynamic slicing stated slice denote backward slice sequel 
read mod write read mod write example program 
dynamic slice criterion 
assumes fixed input program static slicing assumptions regarding input 
hybrid approaches combination static dynamic information compute slices described 
shows example program dynamic slice criterion denotes occurrence statement execution history program 
note input loop executed twice assignments executed 
example branch statement may omitted dynamic slice assignment variable iteration loop killed assignment second iteration contrast static slice program criterion consists entire program 
earlier number earlier frameworks comparing slicing methods earlier surveys slicing methods 
venkatesh presents formal definitions types slices terms denotational semantics 
distinguishes independent dimensions slices categorized static vs dynamic backward vs forward closure vs executable 
slicing methods literature classified criteria :10.1.1.50.4405
venkatesh introduces concept quasi static slice 
corresponds situations inputs program fixed unknown 
constructive algorithms computing slices 
lakhotia number static slicing methods program integration algorithm terms operations directed graphs 
presents uniform framework graph slicing distinguishes syntactic properties slices obtained solely graph theoretic reasoning semantic properties involve interpretation graph representation slice 
addresses static slicing methods stated dynamic slicing methods may modeled similar way 
fact argue construct may replaced statement body 
type slice discussed section 
gupta soffa generic algorithm static slicing solution related dataflow problems determining reaching definitions performing traversal control flow graph cfg 
algorithm parameterized direction cfg traversed backward forward ii type dependences consideration data control dependence iii extent search immediate dependences taken account transitive dependences iv dependences occur paths dependences occur cfg path taken account 
slicing criterion set variables certain program point set statements 
slices take data dependences account may choose values variables statement 
horwitz reps survey done university wisconsin madison slicing differencing integration single procedure multi procedure programs operations program dependence graphs 
addition discussing motivation considerable detail significant definitions algorithms theorems complexity results :10.1.1.49.3377:10.1.1.50.4405
earlier classification static dynamic slicing methods kamkar 
differences kamkar may summarized follows 
date complete instance kamkar address papers discuss slicing presence arbitrary control flow methods computing slices information flow relations 
second papers organized different way 
kamkar discusses slicing method applications separately organized terms number orthogonal problems problems posed procedures composite variables aliasing pointers 
approach enables address possibilities combining solutions different orthogonal problems 
third kamkar compare accuracy efficiency slicing methods attempt determine fundamental strengths weaknesses slicing method irrespective original presentation 
suggest number directions improving accuracy slicing algorithms 
organization remainder organized follows 
section introduce cornerstones slicing algorithms notions data dependence control dependence 
readers familiar concepts may skip section consult demand 
section contains overview static slicing methods 
simple case slicing structured programs scalar variables studied 
address algorithms slicing presence procedures arbitrary control flow composite variables pointers interprocess communication 
section compares classifies methods static slicing 
section addresses dynamic slicing methods organized similar way section 
section suggests compiler optimization techniques may obtain accurate slices 
applications program slicing discussed section 
section summarizes main survey 
start read sum product write product write sum sum sum product product cfg example program 
data dependence control dependence data dependence control dependence defined terms cfg program 
cfg contains node statement control predicate program edge node node indicates possible flow control 
cfgs contain special nodes labeled start corresponding program respectively 
sets def ref denote sets variables defined referenced cfg node respectively 
types data dependences distinguished flow dependence output dependence anti dependence 
flow dependences classified loop carried loop independent depending arise result loop iteration 
purposes slicing flow dependence relevant distinction loop carried loop independent flow dependences ignored 
node flow dependent node exists variable ffl def ffl ref ffl exists path intervening definitions alternatively stated definition node reaching definition node control dependence usually defined terms post dominance 
node cfg post dominated node paths pass node control dependent node ffl exists path post dominated ffl post dominated determining control dependences programs arbitrary control flow studied 
programs structured control flow control dependences determined simple syntax directed manner statements branches control dependent control predicate 
example shows cfg example program 
node flow dependent node node defines variable product ii node variable product iii exists path intervening definitions product 
node control dependent node exists path node post dominated node ii node post dominated node 
methods static slicing basic algorithms static slicing section study basic algorithms static slicing structured programs variables procedures interprocess communication 
dataflow equations original definition program slicing introduced weiser iterative solution dataflow equations weiser defines slice executable program obtained original program deleting zero statements 
slicing criterion consists pair node cfg program subset program variables 
order slice respect criterion subset statements program satisfy property halts input halts input computing values variables statement corresponding node executed 
slice exists criterion program 
slice statement minimal slice criterion contains fewer statements 
weiser argues statement minimal slices necessarily unique problem determining statement minimal slices undecidable 
approximations statement minimal slices computed iterative process computing consecutive sets relevant variables node cfg 
directly relevant variables determined data dependences account 
notation cfg indicates existence edge cfg node node slicing criterion set directly relevant variables node cfg defined follows ffl ffl cfg contains variables def ii ref def 
set directly relevant statements derived 
defined set nodes define variable relevant successor cfg fi def cfg jg variables referenced control predicate statement indirectly relevant statements body relevant 
range influence infl branch statement defined set statements control dependent branch statements relevant due influence nodes fb infl weiser definition branch statements indirect relevance slice contains error 
follow modified definition proposed 
agree statement clear weiser algorithm deals loops 
node def ref infl sum product product product sum sum product product product product product product product product sum product product product product product table results weiser algorithm example program slicing criterion product 
sets indirectly relevant variables determined considering variables predicates branch statements relevant 
ref sets indirectly relevant statements consist nodes nodes define variable relevant cfg successor fi def cfg jg sets nondecreasing subsets program variables statements respectively fixpoint computation sets constitutes desired program slice 
example consider program criterion product 
table summarizes def ref infl sets sets relevant variables computed weiser algorithm 
cfg program shown earlier 
information table definition slice obtain 
example fixpoint sets indirectly relevant variables reached set corresponding slice criterion product computed weiser algorithm identical program shown apart fact output statement write product contained slice 
fact output statement part slice def set empty statement data dependent ii statement control dependent output statement 
horwitz reps suggest way making output value dependent previous output values treating statement write assignment output output output string valued variable containing output program denotes string concatenation 
output statements included slice including output set variables specified criterion 
lyle presents modified version weiser algorithm computing slices 
apart minor changes terminology algorithm essentially 
ffl ffl ae ffl id vars theta ae vars theta id gamma ae delta delta ae ae ae delta ae vars theta theta defs ae vars theta defs ae id vars theta theta defs defs ae vars theta defs defs ae ae id ae delta vars theta theta defs delta ae delta vars theta defs id ae ae delta vars theta defs id definition information flow relations 
weiser algorithm style denotational semantics 
denotational semantics behavior statement sequence statements characterized defining transforms state 
denotational slicing function ffi characterizes language construct defining affects set relevant variables see 
function ff uses ffi express slices constructed 
information flow relations carr define number information flow relations programs compute slices 
statement sequence statements variable expression control predicate right hand side assignment occurs relations ae defined 
information flow relations possess properties iff value entry potentially affects value computed iff value computed potentially affects value exit ae iff value entry may affect value exit set expressions construct partial statements 
partial statement statement associated variable obtained replacing statements contain expressions empty statements 
information flow relations computed syntax directed bottom manner 
empty statement relations empty ae identity 
assignment contains variables occur consists ae contains variables occur variables expression potentially affected variables sum product sum product sum product sum product sum product sum product expression numbers correspond line numbers 
information flow relation example program 
shows information flow relations sequences statements conditional statements loop statements constructed information flow relations constituents 
ffl denotes empty statement delta relational join id identity relation vars set variables occurring expression defs set variables may defined statement convoluted definition constructs obtained effectively transforming infinite sequence nested branch statements 
relation ae definition transitive reflexive closure ae 
slice value variable arbitrary location computed inserting dummy assignment appropriate place variable previously occur slice final value modified program equivalent slice selected location original program 
static forward slices derived relation way similar method computing static backward slices relation 
shows information flow relation entire program relation follows set expressions potentially affect value product program 
corresponding partial statement obtained omitting statements program contain expressions set assignments sum write statements 
result exactly slice computed weiser algorithm see section 
dependence graph approaches ottenstein ottenstein define slicing reachability problem dependence graph representation program 
program dependence graph pdg static slicing single procedure programs 
statements expressions program constitute vertices pdg edges correspond data dependences control dependences statements see section 
key issue partial ordering vertices induced dependence edges carr define information flow relations statements 
purposes example assumed statement read treated assignment statements write sum write product treated empty statements 
entry write sum write product sum sum product product pdg program 
obeyed preserve semantics program 
pdgs horwitz distinction loop carried flow dependences additional type data dependence edges named def order dependence edges :10.1.1.50.4405
horwitz argue pdg variant adequate programs isomorphic pdgs strongly equivalent 
means started input state compute values variables diverge 
argued pdg variant minimal sense removing dependence edges disregarding distinction loop carried loop independent flow edges result inequivalent programs having isomorphic pdgs 
computation program slices flow dependences control dependences necessary 
consider dependences sequel 
dependence graph approaches slicing criterion identified vertex pdg 
weiser terminology corresponds criterion cfg node corresponding set variables defined consequently slicing criteria pdg slicing methods general methods dataflow equations information flow relations 
section discuss precise slicing criteria simulated pdg slicing methods 
single procedure programs slice consists vertices reachable 
related parts source text program maintaining mapping vertices pdg source text construction pdg 
pdg variant shows considerably detail 
particular vertex sub expression program file descriptors appear explicitly 
result read statements involving irrelevant variables sliced away slices execute correctly full input original program 
example shows pdg program 
pdg variant 
thick edges represent control dependences omit usual labeling control dependence edges irrelevant discussion 
furthermore omit loop carried flow dependence edges vertex edges irrelevant computation slices 
program example write procedure program example procedure program example write procedure example program 
weiser slice 
hrb slice 
thin edges represent flow dependences 
shading indicate vertices slice write product 
interprocedural static slicing dataflow equations weiser describes step approach computing interprocedural static slices 
slice computed procedure contains original slicing criterion 
effect procedure call set relevant variables approximated interprocedural summary information 
procedure information consists set mod variables may modified set variables may account procedures called call treated defines variables mod uses variables actual parameters substituted formal parameters 
fact weiser algorithm take account output parameters dependent input parameters cause imprecision 
shows example program manifests problem 
interprocedural slicing algorithm compute slice shown 
slice contains statement due spurious dependence variable call variable call 
horwitz reps binkley algorithm discussed section compute accurate slice shown 
second step weiser algorithm interprocedural slicing new criteria generated procedures called ii procedures call steps repeated new criteria occur 
new criteria consist pairs vq nq statement vq set relevant variables scope formals substituted actuals 
new criteria ii consist pairs nr vr nr call vr set relevant variables statement scope actuals substituted formals 
generation new criteria formalized way functions map set slicing criteria procedure set criteria procedures call set criteria procedures called respectively 
closure fc contains criteria necessary compute interprocedural slice initial criterion worst case assumptions program program example read sum product add sum multiply product add write sum write product procedure add procedure multiply add add example multi procedure program 
calls external procedures source code unavailable 
example assume slice computed final value product program 
slicing initial criterion product 
step weiser algorithm include lines main program line 
particular procedure calls multiply product add included slice variables product deemed relevant points ii interprocedural data flow analysis determined mod add add mod multiply multiply dg 
initial criterion main program product product contains criteria 
result slicing procedure add criterion procedure multiply criterion inclusion procedures entirety 
note calls add lines causes generation new criterion re slicing procedure add 
horwitz reps binkley report weiser algorithm interprocedural slicing unnecessarily inaccurate refer calling context problem 
nutshell problem computation descends procedure called procedure ascend procedures call corresponds execution paths enter exit different procedure execution paths infeasible consideration results inaccurate slices 
example exhibits calling context problem 
line slice new criteria generated calls add 
calls include included calls lines call add sum line 
new criterion sum generated cause inclusion lines slice 
consequently slice consists entire program 
conjecture calling context problem weiser algorithm fixed observing criteria sets needed include procedures program main delta delta delta delta delta delta delta delta delta xn delta delta delta xn gamma write procedure delta delta delta yn write write delta delta delta write yn example program procedure sliced times weiser algorithm 
transitively call procedure containing initial criterion done sets need computed 
reps suggested essentially corresponds passes horwitz reps binkley algorithm see section sets computed determining sets 
computation sets requires sets relevant variables known call sites 
words computation sets involves slicing procedures 
course doing new variables may relevant previously encountered call sites new call sites may encountered 
illustrated program shown 
subsequent discussion denotes line number statement write line number statement procedure computing slice criterion requires iterations body loop 
th iteration variables delta delta delta relevant call site causing inclusion criterion delta delta delta main 
precaution taken combine criteria main procedure sliced times 
hwang du chou propose iterative solution interprocedural static slicing replacing recursive calls instances procedure body 
slice recomputed iteration fixed point new statements added slice 
approach suffer calling context problem expansion recursive calls lead considering infeasible execution paths 
reps shown certain family recursive programs algorithm takes time exponential length program 
example program shown 
shows exponentially long path effectively traversed hwang du chou algorithm 
information flow relations carr explain effect procedure calls approximated 
exact dependences input output parameters determined slicing called procedure respect output parameter computation relation procedure 
procedure call replaced set assignments output parameter assigned fictitious expression contains input parame similar observation jiang 
explain approach works call procedure treated multiple assignment mod 
program example program 
exponentially long path traversed hwang du chou algorithm interprocedural static slicing 
ters depends 
feasible execution paths considered approach suffer calling context problem 
call side effect free function modeled replacing fictitious expression containing actual parameters 
note computed slices truly interprocedural attempt done slice procedures main program 
example program slice final value product include statements sum add sum write sum 
dependence graphs horwitz reps binkley introduce notion system dependence graph sdg slicing multi procedure programs 
parameter passing value result modeled follows calling procedure copies actual parameters temporary variables call ii formal parameters called procedure initialized corresponding temporary variables iii returning called procedure copies final values formal parameters temporary variables iv returning calling procedure updates actual parameters copying values corresponding temporary variables 
sdg contains program dependence graph main program procedure dependence graph procedure 
types vertices edges sdgs occur pdgs 
call statement call site vertex sdg actual actual vertices model copying actual parameters temporary variables 
procedure dependence graph entry vertex formal formal vertices model copying formal parameters temporary variables 
actual actual vertices control dependent call site vertex formal formal vertices control dependent procedure entry vertex 
addition intraprocedural dependence edges sdg contains interprocedural dependence edges control dependence edge call site vertex entry vertex corresponding procedure dependence graph ii parameter edge corresponding actual formal vertices iii parameter edge corresponding formal actual vertices iv edges represent transitive interprocedural data dependences 
transitive dependences computed constructing attribute grammar call graph system serve circumvent calling context problem 
accomplished enter example read sum product write sum write product add sum sum sum multiply product product product add enter multiply add add enter add sdg program 
traversing graph phases 
suppose slicing starts vertex phase determines vertices reached descending procedure calls 
transitive interprocedural dependence edges guarantee calls side stepped descending 
second phase algorithm descends previously side stepped calls determines remaining vertices slice 
interprocedural data flow analysis sets variables referenced modified procedure determined 
information eliminate actual formal vertices parameters modified resulting precise slices 
algorithm works call parameter passing provided aliases resolved 
approaches proposed transformation original program equivalent alias free program generalized flow dependence notion discussed section 
approach yields precise slices second efficient 
shows sdg program interprocedural dataflow analysis eliminate vertices second parameters procedures add multiply 
thin solid arrows represent flow dependences thick solid ar discussion parameter passing mechanisms reader referred section 
rows correspond control dependences thin dashed arrows call parameter parameter dependences thick dashed arrows represent transitive interprocedural flow dependences 
vertices slice statement write product shown shaded light shading indicates vertices identified phase algorithm dark shading indicates vertices identified second phase 
clearly statements sum add sum write sum slice 
slices computed algorithm necessarily executable programs 
cases subset vertices actual formal parameters slice correspond procedures arguments sliced away different calls procedure different arguments may omitted 
horwitz propose methods transforming non executable slice executable program 
method consists creating different variants procedure slice disadvantage slice longer restriction original program 
second solution consists extending slice parameters call calls occur slice 
addition vertices added vertices dependent added slice 
clearly second approach disadvantage yielding larger slices 
outlined interprocedural slices computed partial sdgs corresponding programs development programs containing library calls sdg interprocedural forward slices computed way similar previously described method interprocedural backward slicing 
reps proposed new algorithm computing summary edges sdg asymptotically efficient horwitz reps binkley algorithm time requirements algorithms discussed section 
input algorithm sdg summary edges added collection procedure dependence graphs connected call parameter edges 
algorithm uses worklist determine level realizable paths 
intuitively level realizable path obeys call return structure procedure calls starts ends level procedure 
level realizable paths formal formal vertices procedure induce summary edges corresponding actual actual vertices call algorithm starts asserting level realizable path length zero exists formal vertex 
worklist select path extend adding edge 
demand version algorithm incrementally determines summary edges sdg 
lakhotia presents algorithm computing interprocedural slices sdgs 
algorithm computes slices identical slices computed algorithm 
associated sdg vertex valued tag possible values tag indicating visited indicating visited vertices reached visited fi indicating visited vertices reached visited 
precisely edge entry vertex call vertex traversed call vertex labeled 
worklist algorithm visit vertices labeled visiting vertex labeled fi 
process ends vertices labeled fi slice 
lakhotia algorithm traverses performs single pass sdg 
algorithm value tag may change twice 
unclear lakhotia algorithm really improvement horwitz reps binkley pass traversal algorithm 
static slicing presence unstructured control flow dataflow equations lyle reports version weiser algorithm static slicing yields incorrect slices presence unstructured control flow behavior slice necessarily projection behavior program 
presents conservative solution dealing goto statements consisting including goto non empty set active variables associated 
gallagher gallagher lyle variation weiser method :10.1.1.39.1532
goto statement included slice jumps label included statement agrawal shows algorithm produce correct slices cases 
jiang extend weiser slicing method programs arbitrary control flow 
introduce number additional rules collect unstructured control flow statements goto break continue part slice 
unfortunately formal justification treatment unstructured control flow constructs 
agrawal shows algorithm may produce incorrect slices 
dependence graphs ball horwitz choi ferrante discovered independently conventional pdg slicing algorithms produce incorrect results presence unstructured control flow slices may compute values criterion differ original program 
problems due fact algorithms determine correctly unconditional jumps break goto continue statements required slice 
example shows variant example program uses goto statement 
shows pdg program 
vertices transitive dependence statement write product highlighted 
shows textual representation program obtained 
clearly slice incorrect contain goto statement causing non termination 
fact previously described pdg algorithms include goto slicing criterion statement data control dependent goto 
solution solution remarkably similar unconditional jumps regarded pseudo predicate vertices true branch consists statement jumped false branch textually statement 
correspondingly outgoing edges augmented control flow graph acfg 
edges traversed execution outgoing edge non executable 
notion data flow dependence altered order ignore dependences caused non executable edges 
augmented pdgs constructed acfg cfg slicing defined usual way slight simplification 
basic block partitioned labeled blocks labeled block subsequence statements basic block starting labeled statement containing labeled statements 
goto included slice jumps label included statement block 
read sum product true goto sum sum product product write sum write product read product true product product write product read product true goto product product write product read entry sum product true write product write sum product product sum sum goto goto entry write product write sum true product sum read sum sum product product program unstructured control flow pdg program incorrect slice augmented pdg program correct slice 
graph reachability problem 
labels pertaining statements excluded slice moved closest post dominating statement occurs slice 
main difference approach ball horwitz approach choi ferrante slightly limited example language conditional unconditional goto structured control flow constructs 
choi ferrante argue constructs transformed conditional unconditional goto ball horwitz show certain cases results overly large slices 
groups formal proof algorithms compute correct slices 
shows augmented pdg program vertices vertex labeled write product reached indicated shading 
correct slice corresponding vertices shown 
choi ferrante distinguish disadvantages slicing approach augmented pdgs 
require space conventional pdgs construction takes time 
second non executable control dependence edges give rise spurious dependences cases 
second approach choi ferrante utilize classical pdg 
approximation standard algorithm computing slices produces incorrect results presence unstructured control flow 
basic idea statement slice new goto immediate post dominator added 
separate phase redundant cascaded goto statements removed 
second approach advantage computing smaller slices 
disadvantage slices may include goto statements occur original program 
pdg method slicing programs unstructured control flow proposed agrawal 
methods agrawal uses standard pdg 
observes conditional jump statement form goto included slice predicate slice statement slice control dependent 
terminology conventional slicing algorithm adopted refer standard pdg slicing method extension conditional jump statements 
main observation unconditional jump statement included slice immediate postdominator slice differs immediate lexical successor slice 
statement lexical successor statement textually precedes program statements newly added statement transitively dependent added slice 
motivation approach understood considering sequence statements slice contains unconditional jump statement statement lexical successor 
suppose included slice 
flow control slice pass unconditionally original program need case jump transfer control 
included statements depends 
agrawal algorithm traverses postdominator tree program pre order considers jump statements inclusion order 
algorithm iterates jump statements added agrawal observes notion equivalent non executable edges augmented control flow graphs 
necessary adding jump statements depend may change lexical successors slice jump statements may need included 
proof stated agrawal claims algorithm computes correct slices computes slices identical computed algorithm 
algorithm may simplified significantly type jump occurs program structured jump jump lexical successor 
break continue return statements structured jumps 
single traversal postdominator tree required 
second jump statements added control dependent predicate slice 
case statements dependent included slice 
programs structured jumps algorithm simplified conservative algorithm including slice jump statements control dependent predicate slice 
agrawal algorithm include goto statement example program control dependent included predicate statement 
static slicing presence composite datatypes pointers lyle proposes conservative solution problem static slicing presence arrays 
essentially update element array regarded update entire array 
pdg variant ottenstein ottenstein contains vertex subexpression special select update operators serve access elements array 
presence pointers procedures situations may occur variables refer memory location phenomenon commonly called aliasing 
algorithms determining potential aliases 
slicing presence aliasing requires generalization notion data dependence take potential aliases account 
done roughly follows statement potentially data dependent statement defines variable ii uses variable iii potential aliases iv exists path cfg necessarily defined 
paths may contain definitions potential aliases altered notion data dependence principle static slicing algorithm 
slightly different approach pursued horwitz pfeiffer reps 
defining data dependence terms potential definitions uses variables defined notion terms potential definitions uses memory locations 
pdg static slicing algorithm proposed agrawal demillo spafford implements similar idea deal composite variables pointers 
reaching definitions scalar variable node flowgraph determined finding paths nodes corresponding definition contain definitions composite datatypes pointers considered definitions involve valued expressions variables 
valued expression expression may occur left hand side assignment 
composite datatypes pointers new definition reaching definitions layout memory locations occupied valued expressions names variables 
memory locations regarded quantities array corresponds locations delta delta delta :10.1.1.30.3437
definition scalar variable write node def ref gamma example program 
defined variables variables relevant variables program 
incorrect slice 
reach situation complex composite datatypes pointers allowed 
def expression expression situations may occur ffl complete intersection memory locations corresponding superset memory locations corresponding example case defines record ffl intersection determined statically memory locations coincide situation occurs assignment array element array element 
pointer dereferencing may give rise intersections 
ffl partial intersection memory locations subset memory locations occurs example array record array element defined concepts extended reaching definition function defined traverses flowgraph finds complete intersections worst case assumptions case intersections continues search array record parts defined case partial intersections 
jiang zhou robson algorithm slicing programs pointers arrays 
weihl notion dummy variables addresses may pointed unfortunately approach jiang appears flawed 
shows example program def ref sets statement incorrect slice computed algorithm criterion 
dummy variables denote values pointed respectively gamma denotes address second statement incorrectly omitted define variable relevant statement 
static slicing distributed programs cheng considers static slicing concurrent programs dependence graphs 
generalizes notions cfg pdg nondeterministic parallel control flow net program dependence net pdn respectively 
addition edges data dependence control dependence may contain edges selection dependences synchronization dependences communication dependences 
selection dependence similar control dependence involves nondeterministic selection statements alt statement occam 
synchronization dependence reflects fact start termination execution statement depends start termination execution statement 
communication dependence corresponds situations value computed point program influences value computed point interprocess communication 
static slices computed solving reachability problem pdn 
unfortunately cheng clearly state semantics synchronization communication dependence state prove property slices computed algorithm 
interesting point cheng uses notion weak control dependence construction 
notion subsumes standard notion control dependence difference weak control dependences exist control predicate loop statements follows 
example statements lines program weakly control dependent strongly control dependent control predicate statement line 
comparison methods static slicing overview section compare classify static slicing methods earlier 
section organized follows section summarizes problems addressed literature 
sections compare accuracy efficiency slicing methods address problem respectively 
section discuss possibilities combining algorithms deal different problems 
table provides overview significant slicing algorithms literature 
table lists computation method indicates interprocedural slices computed ii control flow constructs consideration iii datatypes consideration iv interprocess communication considered 
important realize entries table indicate problems addressed table indicate quality solutions exception incorrect solutions indicated footnotes 
table indicate algorithms may combined 
example interprocedural slicing algorithm principle combined dependence graph slicing methods dealing arbitrary control flow 
possibilities combinations investigated section 
kamkar distinguishes methods computing slices executable programs computing slices consist set relevant statements control predicates 
agree observation horwitz static slicing single procedure programs merely matter presentation 
remarked section static slicing multi procedure programs distinction executable non executable slices relevant 
problems strongly related solution problem obtain solution problem believe distinction executable non executable computation interprocedural control data interprocess method solution flow types communication weiser lyle gallagher lyle jiang carr ottenstein horwitz horwitz reps lakhotia agrawal ball horwitz choi ferrante agrawal cheng dataflow equations functional denotational semantics information flow relations reachability dependence graph 
structured arbitrary 
scalar variables arrays records pointers 
solution incorrect see 
solution incorrect see section 
non recursive procedures 
table overview static slicing methods 
static slices dismissed 
accuracy issues complicate comparison static slicing methods ffl original formulation weiser slicing algorithm considers line source code unit may result imprecise slices line contains statement 
algorithms information flow relations pdgs suffer problem statement distinct unit 
subsequent discussions feel free ignore fact easily imagine reformulation weiser algorithm labeled expressions line numbers 
ffl slicing methods dataflow equations information flow relations slicing criterion consists pair statement arbitrary set variables 
contrast pdg slicing methods criterion effectively corresponds pair vars statement vars set variables defined pdg slicing method compute slice respect criterion arbitrary performing steps 
cfg node corresponding pdg vertex determined 
second set cfg nodes corresponding reaching definitions variables node determined 
third set pdg vertices corresponding set cfg nodes determined desired slice consists vertices vertex reached 
having dealt issues state concerning accuracy static slicing methods basic algorithms intraprocedural static slicing accuracy methods dataflow equations see section information flow relations see section pdgs see section essentially presentation computed slices differs weiser defines slice executable program methods slices defined subset statements original program 
procedures weiser interprocedural static slicing algorithm inaccurate reasons summarized follows 
interprocedural summary information approximate effect procedure call establishes relations set input parameters set output parameters contrast approaches determine output parameter input parameters depends 
second algorithm fails take call return structure interprocedural execution paths account 
problems addressed detail section 
algorithm carr compute truly interprocedural slices main program sliced 
capable handling recursive programs 
carr slices accurate sense exact dependences input output parameters ii calling context problem occur 
solutions compute accurate interprocedural static slices capable handling recursive programs see sections 
arbitrary control flow lyle method computing static slices presence arbitrary control flow conservative see section 
agrawal shown solutions proposed gallagher lyle jiang incorrect 
precise solutions static slicing presence arbitrary control flow proposed ball horwitz choi ferrante agrawal see section 
conjecture approaches equally accurate 
composite variables pointers lyle conservative algorithm static slicing presence arrays see section 
discussed section approach jiang incorrect 
agrawal propose algorithm static slicing presence arrays pointers see section accurate lyle algorithm 
interprocess communication approach static slicing concurrent programs proposed cheng see section 
efficiency examine efficiency static slicing methods studied earlier basic algorithms weiser algorithm intraprocedural static slicing dataflow equations determine slice theta theta time number variables program number vertices cfg number edges cfg 
carr report relation statement computed theta 
relation slices variables statement obtained 
construction pdg essentially involves computing data dependences control dependences program 
structured programs control dependences determined syntax directed fashion 
presence arbitrary control flow control dependences single procedure program computed theta time 
computing data dependences essentially corresponds determining reaching definitions 
scalar variables accomplished theta number definitions program see 
follows pdg constructed theta time 
self evident advantages pdg slicing methods pdg computed slices extracted linear time number vertices edges slice respectively 
especially useful slices program required 
worst case slice consists entire program equal number vertices edges pdg respectively 
certain cases quadratic blowup number flow dependence edges pdg 
aware slicing algorithms efficient program representations ssa form 
procedures discussion visible denotes maximal number parameters variables visible scope procedure params denotes maximum number formal vertices procedure dependence graph sdg 
total number call sites program denote number vertices edges cfg procedure sites number call sites procedure weiser states bound theta theta log 
bound number bit vector steps performed length bit vector 
multiplied cost account cost bit vector operations 
problem determining relevant variables similar determining possibly uninitialized variables 
transformation technique employed theta time 
iterations performed due branch statements indirect relevance 
improved bound weiser intraprocedural slicing algorithm theta theta 
weiser state estimate complexity interprocedural slicing algorithm 
observe initial criterion set criteria contains visible criteria procedure intraprocedural slice procedure takes time visible theta theta 
furthermore computation interprocedural summary information done globals theta time 
expression constitutes upper bound time required slice entire program globals theta visible theta sigma sites theta theta complexity approach carr requires procedure sliced 
call site replaced visible assignments 
cost slicing procedure visible theta visible theta sites total cost computing interprocedural slice visible theta sigma visible theta sites discussed section approach hwang du chou may require time exponential size program 
construction individual procedure dependence graphs sdg takes time sigma thetan 
horwitz reps binkley algorithm computing summary edges takes time theta pdg theta params theta sites theta params sites maximum number call sites procedure pdg maximum number control data dependence edges procedure dependence graph 
details reader referred 
reps approach computing summary edges requires theta pdg theta params theta params time 
denotes number procedures program 
assuming number procedures usually number procedure calls terms complexity measure reps horwitz approach asymptotically smaller horwitz reps binkley algorithm 
sdg constructed slice extracted passes number vertices edges slice respectively 
worst case sdg sdg sdg sdg number vertices edges sdg respectively 
arbitrary control flow lyle conservative algorithm dealing unstructured control flow essentially weiser algorithm goto statement included non empty set relevant variables 
time requirements lyle algorithm weiser theta theta time 
interprocedural arbitrary non scalar interprocess slicing control flow variables communication 
eqs 
weiser lyle lyle 
rels 
carr pdg horwitz ball horwitz agrawal cheng lakhotia choi ferrante reps agrawal algorithms computing potential data dependences presence non scalar variables aliasing 
see section 
table orthogonal problems static slicing 
complexity estimates stated 
difference algorithms standard pdg slicing algorithm minor slightly different control dependence subgraph conjunction data dependence subgraph standard pdg conjunction lexical successor tree constructed linear time 
expected efficiency algorithms roughly equivalent standard pdg algorithm discussed 
composite variables pointers lyle approach slicing presence arrays complexity bound weiser algorithm slicing presence scalar variables worst case length reaching definitions paths remains 
cost constructing pdgs programs composite variables pointers algorithm proposed agrawal constructing pdgs programs scalar variables 
case worst case length potential reaching definitions paths remains determining intersections partial intersections see section done constant time 
interprocess communication cheng doesn state complexity estimate determining selection synchronization communication dependence 
time required extracting slices denote number vertices edges pdn respectively 
remarked accurate static slices determined presence non scalar variables advanced computationally expensive data dependence analysis performed see 
combining static slicing algorithms table highlights orthogonal problems static slicing dealing procedures unstructured control flow non scalar variables interprocess communication 
computation method table shows papers solution problems 
principle solutions different problems combined appear row table apply computation method 
read mod mod mod mod write du tc ir trajectory example program 
dynamic flow concepts trajectory 
methods dynamic slicing basic algorithms dynamic slicing section study basic algorithms dynamic slicing structured programs variables procedures interprocess communication 
dynamic flow concepts korel laski describe dynamic slices computed 
formalize execution history program trajectory consisting sequence occurrences statements control predicates 
labels serve distinguish different occurrences statement execution history 
example shows trajectory program input 
dynamic slicing criterion specified triple denotes input program statement occurrence th element trajectory subset variables program dynamic slice defined executable program obtained original program deleting zero statements 
input values variables computed corresponding points trajectories program slice 
requirements imposed dynamic slices statement corresponding criterion occurs slice ii loop occurs slice traversed number times original program 
order compute dynamic slices korel laski introduce dynamic flow concepts formalize dependences occurrences statements trajectory 
definition du relation associates variable definition 
korel laski definition dynamic slicing criterion somewhat inconsistent 
assumes trajectory available input uniquely defines 
self contained minimal definition dynamic slicing criterion consist triple number statement occurrence trajectory induced input read mod write du tc ir read mod write read mod write trajectory example program 
input 
dynamic flow concepts trajectory 
dynamic slice criterion 
non terminating slice obtained ignoring effect ir relation 
note trajectory definition uniquely defined 
test control tc relation associates occurrence control predicate statement occurrences trajectory control dependent 
relation defined syntax directed manner structured program constructs 
occurrences statement related symmetric identity ir relation 
shows dynamic flow concepts trajectory 
dynamic slices computed iterative way determining successive sets directly indirectly relevant statements 
slicing criterion initial approximation contains definitions variables trajectory test actions trajectory control dependent 
approximation defined follows consists du tc ir dynamic slice easily obtained fixpoint sc process finite exists statement instance occurs sc slice 
furthermore statement corresponding criterion added slice 
read mod write read mod mod write example program 
trajectory input 
example compute dynamic slice trajectory criterion 
final statement control dependent statement initial approximation slice consists definition subsequent iterations produce follows sc dynamic slice respect criterion fxg includes statement statement corresponding statement trajectory 
slice shown earlier 
role ir relation calls clarification 
consider trajectory example program input shown 
dynamic flow concepts trajectory slice respect criterion shown respectively 
note slice obtained terminating program 
compute slice ir relation account non terminating program obtained 
reason phenomenon introducing ir relation du tc relations traverse trajectory backward direction 
purpose ir relation traverse trajectory directions include statements control predicates necessary ensure termination loops slice 
unfortunately proof provided sufficient 
unfortunately traversing ir relation backward direction causes inclusion statements necessary preserve termination 
example shows slightly modified version program 
shows trajectory program 
trajectory follows ir du du 
statements included slice statement needed compute final value preserve termination 
interesting investigate dynamic variation podgurski clarke notion weak control dependence ir relation lead accurate slices 
ffl ffl ae ffl id vars theta ae vars theta id gamma ae delta delta ae ae ae delta ae ae vars theta evaluates true evaluates false ae theta defs evaluates true evaluates false ae ae vars theta defs ae id evaluates true evaluates false ae vars theta vars theta evaluates true evaluates false ae theta defs theta defs evaluates true evaluates false ae ae vars theta defs ae vars theta defs ae evaluates true evaluates false definition dynamic dependence relations 
dynamic dependence relations gopal describes approach dynamic dependence relations compute dynamic slices 
introduces dynamic versions carr relations ae see section 
relation contains pairs statement depends input value program executed 
relation contains pairs output value depends execution statement pair relation ae output value depends input value definitions presumed executed fixed input 
empty statements assignments statement sequences gopal dependence relations exactly static case 
static information flow relations conditional statement derived statement statements constitute branches 
dynamic dependence relations dependences arise branch executed taken account 
dependence relation statement omitted expressed terms dependence relations nested conditionals equivalent behavior 
gopal uses notation order avoid confusion relation carr explicit see section ae 
expression affected variables expressions indicated line numbers 
relation example program input 
static case loops effectively replaced infinite dynamic case requires loop unwound times number times loop executes 
resulting definitions convoluted dependence relations body loop may differ iteration 
simple transitive closure operation static case insufficient 
summarizes gopal dynamic dependence relations 
defs denotes set variables modified executing statement relations dynamic slice final value variable defined oe fe shows information flow relation entire program relation follows set expressions input affect value program 
corresponding dynamic slice nearly identical slice shown difference fact gopal algorithm excludes final statement write line 
previous example gopal dependence relations computed similar slice computed section difference fact omitted write statement 
certain cases gopal algorithm may compute non terminating slice terminating program 
shows slice program input computed gopal algorithm 
advantage dependence relations certain cases smaller slices computed korel laski algorithm 
example shows slice respect final value example program input 
observe assignment occurs slice computed algorithm section included slice 
dependence graphs miller choi introduce dynamic variation pdg called dynamic program dependence graph 
graphs parallel program debugger perform analysis constructed incrementally demand 
gopal define information flow relations statements 
purposes example assumed statement read treated assignment statements write sum write product treated empty statements 
read mod read mod non terminating slice computed example program respect final value input 
slice example program respect final value input 
prior execution variation static pdg constructed object code program augmented code generates log file 
addition emulation package generated 
programs partitioned called emulation blocks typically subroutine 
debugging debugger uses log file static pdg emulation package re execute emulation block obtain information necessary construct part dynamic pdg corresponding block 
case user wants perform analysis parts graph constructed emulation blocks re executed 
agrawal horgan develop approach dependence graphs compute dynamic slices 
algorithms computing dynamic slices inaccurate useful understanding final approach 
initial approach uses pdg discussed section marks vertices executed test set 
dynamic slice computed computing static slice subgraph pdg induced marked vertices 
construction slice contains vertices executed 
solution imprecise detect situations exists flow edge pdg marked vertex marked vertex definitions example shows pdg example program 
suppose want compute slice final value input 
vertices pdg executed causing pdg vertices marked 
static slicing algorithm section produce entire program slice assignment irrelevant 
assignment included slice exists dependence edge vertex vertex write edge represent dependence occurs second iteration loop 
precisely dependence occurs iterations loop control variable odd value 
second approach consists marking pdg edges corresponding dependences dependence graphs entry vertex 
absence entry vertex result different slice 
reasons uniformity dependence graphs shown entry vertex 
arise execution 
slice obtained traversing pdg time marked edges 
unfortunately approach produces imprecise slices presence loops edge marked loop iteration subsequent iterations dependence recur 
shows pdg example program 
input dependence edges marked causing slice consist entire program 
shown potential refinement second approach consisting edges previous iterations incorrect 
agrawal horgan point interesting fact second approach computing dynamic slices produces identical results algorithm proposed korel laski see section 
pdg program optionally marked edges requires space denotes number statements program korel laski trajectories principle unbounded size 
agrawal horgan second approach computes imprecise slices account fact different occurrences statement execution history may transitively dependent different statements 
observation motivates third solution create distinct vertex dependence graph occurrence statement execution history 
kind graph referred dynamic dependence graph ddg 
dynamic slicing criterion identified vertex ddg dynamic slice computed determining ddg vertices criterion reached 
statement control predicate included slice criterion reached vertices occurrences 
shows ddg example program 
slicing criterion corresponds vertex labeled write vertices vertex reached indicated shading 
observe criterion reached vertex labeled 
corresponding assignment slice 
disadvantage number vertices ddg equal number executed statements unbounded 
number dynamic slices worst case number statements program sliced 
shows program dynamic slices 
program reads number values variables allows compute sum number subsets delta delta delta crucial observation iteration outer loop slice respect statement write contain exactly statements read set elements subsets program different dynamic slices 
agrawal horgan propose reduce number vertices ddg merging vertices transitive dependences map set statements 
words new vertex introduced create new dynamic slice 
obviously check involves run time overhead 
resulting graph referred reduced dynamic dependence graph program 
slices computed precision computed 
ddg vertices labeled rightmost vertices labeled transitive dependences vertices depend statements program 
program input obtained merging ddg vertices vertex 
algorithm construction having program read delta delta delta read xn true finished false finished read case delta delta delta xn read finished write read 
program different dynamic slices 
read entry mod entry read mod entry read mod mod pdg program 
pdg program 
ddg program 
keep track entire execution history 
information needs maintained variable vertex corresponding definition ii predicate vertex corresponding execution iii vertex dynamic slice vertex 
interprocedural dynamic slicing agrawal demillo spafford consider dynamic slicing procedures various parameter passing mechanisms 
discussion assumed procedure formal parameters delta delta delta called actual parameters delta delta delta important realize approach dynamic data dependences definitions uses memory locations 
way potential problems avoided 
global variables inside procedures pose problems 
second alias analysis required 
call value parameter passing modeled sequence assignments delta delta delta executed procedure entered 
order determine memory cells correct activation record sets actual parameters determined procedure entered def sets formal parameters procedure entered 
call value result parameter passing additional assignments formal parameters actual parameters performed exit procedure 
call parameter passing require actions specific dynamic slicing memory cell associated corresponding actual formal parameters alternative approach interprocedural dynamic slicing kamkar fritzson 
distinguishes solution agrawal fact authors primarily concerned procedure level slices 
study problem determining set call sites program affect value variable particular call site 
execution dynamic dependence summary graph constructed 
vertices graph referred procedure instances correspond procedure activations annotated parameters edges summary graph activation edges corresponding procedure calls summary dependence edges 
type reflects transitive data control dependences input output parameters procedure instances 
slicing criterion defined pair consisting procedure instance input output parameter associated procedure 
constructing summary graph slice respect slicing criterion determined steps 
parts summary graph criterion reached determined subgraph referred execution slice 
vertices execution slice partial procedure instances parameters may sliced away 
interprocedural program slice consists call sites program partial instance occurs execution slice 
approaches constructing summary graphs considered 
approach intraprocedural data dependences determined statically may result precisely kamkar refers incoming outgoing variables procedure 
notion applies global variables referenced modified procedure 
inaccurate slices presence conditionals 
second approach dependences determined run time 
results accurate dynamic slices dependences procedure re computed time called 
third approach attempts combine efficiency static approach accuracy dynamic approach computing dependences inside basic blocks statically inter block dependences dynamically 
approaches control dependences determined statically 
unclear useful third approach presence composite variables pointers run time intra block dependences determined statically additional alias analysis performed run time 
kamkar adapts interprocedural slicing method compute statement level interprocedural slices slices consisting set statements set call sites 
essence accomplished introducing vertex statement instance procedure instance summary graph 
approaches static dynamic combined static dynamic constructing summary graphs 
choi miller netzer discuss approach interprocedural analysis 
initially assumed procedure call may modify global variable static pdg augmented linking edges indicating potential data dependences 
second phase interprocedural summary information replace linking edges data dependence edges delete graph 
linking edges may remain resolved run time 
dynamic slicing presence composite datatypes pointers dynamic flow concepts korel laski consider slicing presence composite variables regarding element array field record distinct variable 
dynamic data structures treated distinct entities pointer object pointed 
dynamically allocated objects propose solution unique name assigned object 
dependence graphs agrawal demillo spafford dependence graph algorithm dynamic slicing presence composite datatypes pointers 
solution consist expressing def sets terms actual memory locations provided compiler 
algorithm similar static slicing presence composite datatypes pointers authors see section 
computation dynamic reaching definitions intersections occur complete partial intersections 
choi miller netzer extend analysis method see section order deal arrays pointers 
arrays linking edges added static pdgs edges express potential data dependences deleted changed kamkar notion termination preserving control dependence similar podgurski clarke weak control dependence 
genuine data dependences run time 
pointer accesses resolved run time recording uses pointers log file 
dynamic slicing distributed programs dynamic flow concepts korel ferguson extend dynamic slicing method distributed programs ada type rendezvous communication see 
distributed program execution history formalized distributed program path task comprises sequence statements trajectory executed ii sequence triples identifying rendezvous task involved 
identifies accept statement task identifies task participated communication denotes entry call statement task involved rendezvous 
dynamic slicing criterion distributed program specifies input task ii distributed program path iii task iv statement occurrence trajectory variable dynamic slice respect criterion executable projection program obtained deleting statements 
program guaranteed preserve behavior program rendezvous slice occur relative order program 
note rendezvous program need slice 
method computing slices distributed programs basically generalization method stated slightly different manner 
addition previously discussed dynamic flow concepts see section notion communication influence introduced capture tasks 
authors distributed version algorithm uses separate process slicing task 
dependence graphs duesterwald gupta soffa dependence graph algorithm computing dynamic slices distributed programs 
introduce distributed dependence graph ddg representing distributed programs 
distributed program consists set processes delta delta delta communication processes assumed nondeterministic expressed way send receive statements 
distributed dynamic slicing criterion delta delta delta specifies process input set statements distributed dynamic slice executable set processes delta delta delta statements subset slice computes values statements program executed input 
accomplished including input statements slice ii replacing nondeterministic communication statements program deterministic communication statements slice 
ddg contains single vertex statement control predicate program 
control dependences statements determined statically prior execution 
edges data communication dependences added graph run time 
abbreviation ddg section confused notion dynamic dependence graph discussed earlier section 
slices computed usual way determining set ddg vertices vertices specified criterion reached 
construction ddg computation slices performed distributed manner separate ddg construction process slicing process assigned process program processes communicate send receive statement encountered 
due fact single vertex occurrences statement execution history inaccurate slices may computed presence loops see section 
example slice respect final value program input entire program 
cheng presents alternative dependence graph algorithm computing dynamic slices distributed concurrent programs 
pdn representation concurrent program see section computing dynamic slices 
cheng algorithm basically generalization initial approach proposed agrawal horgan pdn vertices corresponding executed statements marked static slicing algorithm section applied pdn subgraph induced marked vertices 
discussed section yields inaccurate slices 
choi describe approach analysis extended parallel programs 
shared variables semaphores message passing communication ada type rendezvous mechanisms considered 
parallel dynamic graph introduced contains synchronization vertices synchronization operations semaphore synchronization edges represent dependences concurrent processes 
choi explain analysis parallel dynamic graph read write write write conflicts concurrent processes 
comparing methods dynamic slicing section compare classify dynamic slicing methods earlier 
section organized follows section summarizes problems addressed literature 
sections compare accuracy efficiency slicing methods address problem respectively 
section investigates possibilities combining algorithms deal different problems 
overview table lists dynamic slicing algorithms discussed earlier summarizes issues studied 
table shows computation method ii computed slices executable programs iii interprocedural solution supplied iv data types consideration interprocess communication considered 
similar table table shows problems addressed 
indicate various algorithms may combined give indication quality 
static case exists significant difference methods compute executable slices approaches compute slices merely sets statements 
type slice may executable due computation executable interprocedural data interprocess method solution types communication korel laski korel ferguson gopal agrawal horgan agrawal kamkar duesterwald cheng choi dynamic flow concepts dynamic dependence relations reachability dependence graph 
scalar variables arrays records pointers 
table overview dynamic slicing methods 
absence assignments incrementing loop counters convenience henceforth refer slices non executable slices 
discussed section algorithms compute executable dynamic slices may produce inaccurate results presence loops 
apart venkatesh little semantic justification methods computing non executable slices 
algorithms graph reachability algorithms compute set statements directly indirectly affect values computed criterion 
algorithms little attention paid formal characterization slices 
accuracy basic algorithms slices computed korel laski algorithm see section accurate computed algorithms agrawal horgan see section gopal see section 
due korel laski constraint slices executable 
slices terminating programs computed agrawal horgan gopal may consist diverging programs 
procedures dependence graph algorithms interprocedural dynamic slicing proposed agrawal demillo spafford kamkar see section 
unclear algorithms procedures accurate slices 
composite variables pointers korel laski see section agrawal demillo spafford see section proposed methods dynamic slicing presence composite variables pointers 
unaware difference accuracy 
interprocess communication korel ferguson see section duesterwald gupta soffa see section compute executable slices deal course slice may executed anyway may terminate 
nondeterminism different way approach requires mechanism replaying rendezvous slice relative order appeared original program approach replaces nondeterministic communication statements program deterministic communication statements slice 
cheng choi see section address problem slices compute necessarily executable 
methods cheng duesterwald inaccurate static dependence graphs computing dynamic slices see discussion section 
efficiency dynamic slicing involves run time information surprising dynamic slicing methods discussed section time requirements depend number executed statements procedure calls case algorithms spend time execution order store execution history program update dependence graphs 
certain algorithms traverse execution history order extract slice require time slice algorithms require constant time 
discuss time requirements discussion ignore time spent execution needed construct histories dependence graphs 
space requirements discussed detail 
basic algorithms korel laski solution see section requires space store trajectory space store dynamic flow concepts 
construction flow concepts requires theta time number variables statements program respectively 
extracting single slice computed flow concepts done time 
algorithm gopal see section requires space store execution history theta space store relation 
time required compute relation program bounded theta 
relation slices extracted time 
discussed section slicing method proposed agrawal horgan requires space number statements program 
vertices annotated slice execution slices extracted 
procedures interprocedural dynamic slicing method proposed kamkar see section requires space store summary graph number executed procedure calls 
traversal graph needed extract slice takes time 
time space requirements method agrawal demillo spafford essentially agrawal horgan basic slicing method discussed 
composite variables pointers algorithms korel laski see section agrawal demillo spafford see section slicing interprocedural composite vars interprocess slicing pointers communication dyn 
flow concepts korel laski korel ferguson dyn 
dep 
relations gopal dependence graphs agrawal agrawal duesterwald kamkar cheng choi table orthogonal problems dynamic slicing 
presence composite variables pointers adaptations basic slicing algorithms korel laski agrawal horgan respectively see discussion 
adaptations essentially consist change reaching definitions functions determine data dependences affect worst case behavior algorithms 
expect time space requirements scalar variable case 
interprocess communication algorithms cheng duesterwald static pdgs 
space required store dependence graph slices extracted time 
distributed slicing algorithm uses separate slicing process process program slicing process process requires time number edges pdg process communication overhead slicing processes requires time number edges entire graph 
combining dynamic slicing algorithms table displays solutions orthogonal problems dynamic slicing dealing procedures composite variables pointers communication processes 
algorithms dynamic flow concepts dealing composite variables pointers interprocess communication may integrated little problems 
dependence graphs situation slightly complicated ffl different graph representations 
agrawal kamkar choi dynamic dependence graphs distinct vertices different occurrence statements execution history 
contrast duesterwald cheng variations static pdgs 
ffl dynamic slicing agrawal definition memory locations 
dependence graph slicing methods definitions uses variable names 
furthermore unclear combined static dynamic interprocedural slicing approach kamkar practical presence composite variables pointers intra block dependences determined statically case additional alias analysis required run time 
read write read write read write example program 
accurate slice obtained performing constant propagation 
minimal slice 
accurate slicing language specific syntactic issues slicing algorithms stated language independent way syntactic issues avoided practice 
weiser states source language slicing requires transformations statement deletion 
example case language allow statements empty branches slicing algorithm exclude statements branches 
fact characteristics slicing methods discussed far ffl slices obtained deleting statements program 
ffl slices computed tracing data control dependences backwards slicing criterion 
singular objective obtain slices small possible constraints need dismissed 
consider example program 
asked slice respect statement write traditional slicing algorithms produce entire program 
constant propagation techniques determine value constant causing branch conditional selected 
accurate slice computed principle 
replacement entire statement statements branches allowed compute minimal slice 
compiler optimization techniques loop invariant motion loop unrolling see comprehensive overview may employed obtain precise slices 
shows example program sliced respect final statement write 
traditional slicing algorithms fail omit statements 
accurate slice example acquired merging statements 
effect semantics preserving transformation shown 
clearly slicing algorithm conceptually perform transformation able determine accurate slice shown 
field tip currently working reduction theoretical framework computing accurate slices 
performing semantics preserving transformations source programs programs compiled intermediate graph representation named pim 
representation carefully designed accommodate transformations read read 
write read read write read read 
write example program 
transformed program 
accurate slice obtained slicing transformed program 
simplifications shown figures 
transformation source programs pim graphs subsequent optimizations transformations representation expressed way algebraic specification 
orienting equations specification left right yields term rewriting system 
dynamic dependence relation term rewriting systems developed keep track corresponding parts source program intermediate representation compiles optimized version pim graph 
roughly speaking pim graph contains subgraph statement represents store expression 
slices computed framework selecting store expression optimized pim graph tracing dependence relations back source program 
pim dynamic dependence relations implemented asf sdf programming environment generator developed cwi 
experiments produced promising results 
particular accurate slices figures computed 
applications program slicing debugging program analysis debugging difficult task confronted large program little clues regarding location bug 
program slicing useful debugging potentially allows ignore statements process localizing bug 
program computes erroneous value variable statements slice possibly contributed computation value statements slice safely ignored 
forward slices useful debugging 
suppose course debugging statement incorrect 
making change examine forward slice indicating program parts affected may produce useful insights error may corrected 
lyle weiser introduce program dicing method combining information different slices 
basic idea program computes correct value variable incorrect value variable bug statements slice slice approach failsafe presence multiple bugs computations incorrect values produce correct values referred coincidental correctness :10.1.1.30.3437
authors claim program dicing produces useful results assumptions relaxed 
static slicing methods detect dead code statements affect output program 
statements executable presence bug 
static slicing determine uninitialized variables expressions symptom error program 
debugging interested specific execution program exhibits anomalous behavior 
dynamic slices particularly useful reflect actual dependences execution resulting smaller slices static ones 
agrawal thesis contains detailed discussion static dynamic slicing utilized semi automated debugging programs :10.1.1.30.3437
proposes approach user gradually zooms location bug manifested repeatedly considering larger data control slices 
data slice obtained static dynamic data dependences account control slice consists set control predicates surrounding language construct 
closure data control slices expression static dynamic slice set variables expression 
information dynamic slices combined gain insight location bug 
operations slices proposed union intersection difference :10.1.1.30.3437
difference operation dynamic version program dicing notion 
obviously operations combining slices may produce misleading information presence multiple bugs coincidental correctness 
implementation debugging tool ideas discussed 
choi miller netzer describe design efficient implementation debugger parallel programs incorporates analysis notion introduced seminal balzer 
intuitively analysis reveals computation values depends earlier computation values 
difference analysis dependence graph dynamic slices notion allows interactively browse dependence graph consists set program parts corresponding vertices graph designated vertex criterion reached 
fritzson interprocedural static dynamic slicing algorithmic debugging 
algorithmic debugger partially automates task localizing bug comparing intended program behavior actual program behavior 
intended behavior obtained asking user program unit procedure behaves correctly 
answers user location bug determined unit level 
applying algorithmic debugging process slice incorrectly valued variable entire program irrelevant questions skipped 
program differencing program integration program differencing task analyzing old new version program order determine set program components new version represent syntactic semantic changes 
information useful program components reflecting changed behavior need tested 
key issue program differencing consists partitioning components old new version way components partition equivalent behaviors 
program integration algorithm discussed compares slices order detect equivalent behaviors 
partitioning technique comparing slices produces accurate results semantics preserving transformations accommodated 
horwitz prins reps static slicing algorithm single procedure programs basis algorithm integrates changes variants program 
inputs algorithm consist program base variants derived base 
algorithm consists steps 
pdgs base ga gb constructed 
correspondences related vertices graphs assumed available 

sets affected points ga gb base determined consist vertices ga gb different slice base 
merged pdg gm constructed ga gb sets affected points determined 

ga gb gm sets affected points computed algorithm determines behaviors preserved gm accomplished comparing slices affected points ga gb gm ga gb 
different slices changes interfere integration performed 

changes interfere algorithm tests gm feasible pdg corresponds program 
case program constructed gm changes integrated 
semantic justification single procedure slicing algorithm program integration algorithm 
formalizes relationship execution behaviors programs slices programs variants program corresponding integrated version 
comparison slices step relies existence mapping different components 
mapping available techniques comparing slices linear time sum sizes 
alternative formulation horwitz prins reps program integration algorithm brouwerian algebras 
algebraic laws hold algebras restate algorithm prove properties associativity consecutive integrations 
sets affected points computed efficiently way forward slice directly affected points vertices ga occur base vertices different set incoming edges ga base 
software maintenance problems software maintenance consists determining change place program affect behavior parts program 
gallagher lyle static slicing decomposition program set components reduced programs captures part original program behavior 
set guidelines maintainer component obeyed preclude changes behavior components 
describe changes component merged back complete program semantically consistent way 
gallagher lyle notion decomposition slice decomposition programs 
decomposition slice variable consists statements may affect observable value point defined union slices statement outputs statement program 
decomposition slice ord slice decomposition slice output statements removed 
ord slices independent statements common ord slice strongly dependent ord slice subset 
ord slice strongly dependent ord slice maximal 
statement occurs ord slice dependent independent 
variable dependent assigned dependent statement independent assigned independent statements 
maximal ord slices contain independent statements union maximal ord slices equal original program minus output statements 
complement ord slice defined original program minus independent statements ord slice output statements 
intuitively decomposition slice captures part behavior program complement captures behavior rest program 
essential observation independent statements slice affect data control flow complement 
results guidelines modification ffl independent statements may deleted decomposition slice 
ffl assignments independent variables may added decomposition slice 
ffl logical expressions output statements may added decomposition slice 
ffl new control statements surround dependent statements affect complement behavior 
new variables may considered independent variables provided name clashes variables complement 
changes required involve dependent variable user extend slice independent way described introduce new variable 
merging changes components complete program trivial task 
guaranteed changes ord slice affect complement testing modified slice necessary 
testing program satisfies conventional data flow testing criterion def pairs occur successful test case 
duesterwald gupta soffa propose rigorous testing criterion program slicing def pair exercised successful test case output influencing influence output value 
def pair output influencing occurs output slice slice output statement 
user automatic test case generator construct test cases def pairs tested 
slicing approaches utilized different dependence graphs 
static slices computed static dependence graphs similar pdgs dynamic slices computed dynamic dependence graphs similar instances vertex merged resulting slight loss precision hybrid slices computed dependence graphs combined static dynamic information similar quasi static slices 
hybrid approach set variables program partitioned disjoint subsets way variables subset refer variables subset 
static dependences computed subset typically scalar variables dynamic dependences subset typically arrays pointers 
advantage approach combines reasonable efficiency reasonable precision 
kamkar fritzson extend duesterwald gupta soffa multi procedure programs 
define appropriate notions interprocedural def pairs 
interprocedural dynamic slicing method determine interprocedural def pairs effect correct output value test case 
summary graph representation see section slightly modified annotating vertices edges def information 
way set def pairs exercised slice determined efficiently 
regression testing consists re testing parts affected modification previously tested program maintaining coverage original test suite 
gupta harrold soffa describe approach regression testing slicing techniques 
backward forward static slices serve determine program parts affected change test cases execute affected def pairs need executed 
conceptually slices computed backward forward traversals cfg program starting point modification 
algorithms designed determine information necessary regression testing affected def pairs 
bates horwitz variation pdg notion incremental program testing 
testing criteria defined terms pdg notions vertices testing criterion satisfied vertex pdg exercised test set statement control predicate program executed 
flow edges criterion defined similar manner 
tested subsequently modified program slicing determine statements affected modification ii test cases reused modified program 
roughly speaking consists statements occur previously statements different slices 
requires partitioning statements original modified program equivalence classes statements class control slice slightly modified version standard notion 
bates horwitz proof statements class exercised test cases 
tuning compilers larus chandra approach tuning compilers dynamic slicing detect potential occurrences redundant common subexpressions 
finding common subexpression indication sub optimal code generated 
object code instrumented trace generating instructions 
trace reads trace produces stream events read load memory location 
stream events input compiler auditor common subexpression elimination auditor constructs dynamic slices current values stored registers 
larus chandra variant approach dynamic slice represented directed acyclic graph dag containing operators operands produced current value register 
common subexpression occurs isomorphic dags constructed registers 
situation indicates common subexpression occurs specific execution 
common subexpression occurs execution paths inputs executions 
verified checking program counter pc occurrence common subexpression dominates program counter pc second occurrence ii register containing occurrence common subexpression modified path pc pc iii inputs common subexpression modified path pc pc 
third condition impossible verify general feasible number special cases 
general compiler writer check condition iii 
applications weiser describes slicing parallelize execution sequential program 
slices program executed parallel outputs slices spliced way behavior original program preserved 
principle splicing process may take place parallel execution slices 
natural requirement weiser splicing algorithm set slices cover execution behavior original program 
splicing rely particular slicing technique method computes executable static slices adequate 
programs structured control flow considered weiser splicing algorithm depends fact execution behavior expressed terms called program regular expression 
main reason reconstruction original behavior unsolvable presence irreducible control flow 
ott view module set processing elements act compute outputs module 
classify cohesion class module kind relationships processing elements comparing slices different output variables 
low cohesion corresponds situations module partitioned disjoint sets unrelated processing elements 
set involved computation different output value overlap slices 
control cohesion consists sets disjoint processing elements depends common input value intersection slices consist control predicates 
data cohesion corresponds situations data flows set processing elements slices non empty intersection non trivial differences 
high cohesion situations resemble pipelines 
data processing element flows successor slices high cohesion modules overlap large extent 
rely specific slicing method quantitative measures 
binkley presents graph rewriting semantics system dependence graphs uses perform interprocedural constant propagation 
interprocedural slicing algorithm extract slices may executed obtain constant values 
beck eichmann consider case standard module data type module part functionality required 
objective slice away unnecessary code module 
generalize notion static slicing modular programs 
order compute reduced version module interface dependence graph idg constructed 
graph contains vertices definitions types global variables subprograms inside module 
idg contains edges def relation vertices 
interface slicing criterion consists module subset operations adt 
computing interface slices corresponds solving reachability problem idg 
inter module slices corresponding situations modules import modules computed deriving new criteria imported modules 
ning discuss set tools extracting components large cobol systems 
tools include facilities program segmentation distinguishing pieces functionally related code 
addition backward forward static slices condition slices determined 
condition slice criterion specifies constraint values certain variables 
survey static dynamic slicing techniques literature 
basis classifying slicing techniques computation method variety programming language features procedures arbitrary control flow composite variables pointers interprocess communication 
essentially problem slicing presence features orthogonal solutions features 
dynamic slicing methods additional issue fact computed slices executable programs capture part program behavior 
possible compared different solutions problem applying algorithm example program 
addition discussed possibilities problems associated integration solutions orthogonal language features 
section compared classified algorithms static slicing 
listing specific slicing problems studied literature compared accuracy efficiency static slicing algorithms 
significant section summarized follows basic algorithms intraprocedural static slicing absence procedures unstructured control flow composite datatypes pointers interprocess communication accuracy methods dataflow equations information flow relations program dependence graphs essentially 
algorithms advantage dataflow analysis performed slices extracted linear time 
especially useful slices program required 
procedures solution interprocedural static slicing weiser inaccurate reasons 
algorithm exact dependence relations input output parameters 
second call return structure execution paths taken account 
shown section weiser algorithm may slice procedure times presence loops 
solution carr compute truly interprocedural slices procedures main program sliced 
approach carr sufficiently general handle recursion 
exact solutions interprocedural static slicing problem hwang du chou reps horwitz binkley reps horwitz sagiv 
reps horwitz sagiv algorithm interprocedural static slicing efficient 
arbitrary control flow lyle algorithm static slicing presence arbitrary control flow 
solution presents conservative may include goto statements necessary 
agrawal shown solutions proposed gallagher lyle jiang incorrect 
precise solutions static slicing presence arbitrary control flow proposed ball horwitz choi ferrante agrawal 
clear efficiency algorithms compares 
composite datatypes pointers lyle conservative algorithm static slicing presence arrays 
algorithm proposed jiang incorrect 
agrawal demillo spafford propose pdg algorithm static slicing presence composite variables pointers 
interprocess communication approach static slicing concurrent programs proposed cheng 
unfortunately cheng provided justification correctness algorithm 
compared classified algorithms dynamic slicing section 
due differences computation methods dependence graph representations potential integration dynamic slicing solutions orthogonal problems clear static case 
section may summarized follows basic algorithms methods intraprocedural dynamic slicing absence procedures composite datatypes pointers interprocess communication proposed korel laski agrawal horgan gopal 
slices determined agrawal horgan algorithm gopal algorithm accurate slices computed korel laski algorithm korel laski insist slices executable programs 
korel laski algorithm gopal algorithm require unbounded amount space entire execution history program stored 
slices computed traversing history amount time needed compute slice depends number executed statements 
similar statement analysis algorithm 
algorithm proposed agrawal horgan reduced dynamic dependence graphs requires space number statements program 
time needed agrawal horgan algorithm depends number executed statements executed statement dependence graph may updated 
procedures dependence graph algorithms interprocedural dynamic slicing proposed agrawal demillo spafford kamkar fritzson 
method relies heavily memory cells basis computing dynamic reaching definitions 
various procedure passing mechanisms modeled easily assignments actual formal formal actual parameters appropriate moments 
method expressed reachability problem summary graph 
number differences approach 
parts graph constructed compile time 
efficient especially cases calls procedure occur 
second kamkar study procedure level slices slices consisting set procedure calls set statements 
third size summary graph depends number executed procedure calls graphs space efficient due fusion vertices transitive dependences 
unclear algorithm produces precise slices 
arbitrary control flow far know dynamic slicing presence arbitrary control flow studied 
conjecture solutions static case may adapted dynamic slicing 
composite datatypes pointers approaches dynamic slicing presence composite datatypes pointers proposed korel laski agrawal demillo spafford 
algorithms differ computation method dynamic flow concepts vs dependence graphs way composite datatypes pointers represented 
korel laski treat components composite datatypes distinct variables invent names dynamically allocated objects pointers agrawal demillo spafford base definitions definitions uses memory cells 
unclear accuracy algorithms compares 
time space requirements algorithms essentially case scalar variables occur 
interprocess communication methods dynamic slicing distributed programs proposed 
korel ferguson duesterwald gupta soffa compute slices executable programs different way dealing nondeterminism distributed programs approach requires mechanism replaying rendezvous slice relative order occurred original program approach replaces nondeterministic communication statements program deterministic communication statements slice 
cheng choi consider problem slices compute executable programs 
duesterwald gupta soffa cheng static dependence graphs computing dynamic slices 
space efficient ap proaches computed slices inaccurate see discussion section 
algorithms korel ferguson choi require amount space depends number executed statements 
korel ferguson require slices executable slices contain statements computed algorithm 
section argued compiler optimization techniques program transformations obtain accurate slices 
section overview slicing techniques applied areas debugging program analysis program integration software maintenance dataflow testing 
am grateful john field jan heering susan horwitz paul klint ramalingam tom reps fruitful discussions comments earlier drafts 
tom reps provided program picture 
susan horwitz provided program 
programs shown figures adaptations example programs :10.1.1.30.3437
agrawal automatic debugging computer programs :10.1.1.30.3437
phd thesis purdue university 
agrawal slicing programs jump statements 
proceedings acm sigplan conference programming language design implementation orlando florida 
appear 
agrawal demillo spafford dynamic slicing presence unconstrained pointers 
proceedings acm fourth symposium testing analysis verification tav pp 

purdue university technical report serc tr 
agrawal demillo spafford debugging dynamic slicing backtracking 
software practice experience 
agrawal horgan dynamic program slicing 
proceedings acm sigplan conference programming language design implementation pp 

sigplan notices 
aho sethi ullman compilers 
principles techniques tools 
addison wesley 
alpern wegman zadeck detecting equality variables programs 
conference record fifteenth acm symposium principles programming languages san diego pp 

ball control flow control dependence software tools 
phd thesis university wisconsin madison 
ball horwitz slicing programs arbitrary control flow 
proceedings international workshop automated algorithmic debugging fritzson ed vol 
lecture notes computer science springer verlag pp 

balzer extendable debugging monitoring system 
proceedings afips vol 
pp 

banning efficient way find side effects procedure calls aliases variables 
conference record sixth acm symposium principles programming languages pp 

barnes programming ada second ed 
international computer science series 
addison wesley 
barth practical interprocedural data flow analysis algorithm 
communications acm 
bates horwitz incremental program testing program dependence graphs 
conference record twentieth acm symposium principles programming languages charleston sc pp 

beck eichmann program interface slicing reverse engineering 
proceedings th international conference software engineering baltimore 
carr information flow data flow analysis programs 
acm transactions programming languages systems 
bergstra heering klint eds 
algebraic specification 
acm press frontier series 
acm press operation addison wesley 
binkley interprocedural constant propagation dependence graphs data flow model 
proceedings th international conference compiler construction cc edinburgh uk fritzson ed vol 
lncs pp 

cheng slicing concurrent programs graph theoretical approach 
proceedings international workshop automated algorithmic debugging fritzson ed vol 
lecture notes computer science springer verlag pp 

choi burke carini efficient flow sensitive interprocedural computation pointer induced aliases side effects 
conference record twentieth acm symposium principles programming languages acm pp 

choi ferrante static slicing presence goto statements 
acm transactions programming languages systems may 
appear 
choi miller netzer techniques debugging parallel programs analysis 
acm transactions programming languages systems 
cooper kennedy interprocedural side effect analysis linear time 
proceedings acm sigplan conference programming language design implementation atlanta georgia pp 

sigplan notices 
cytron ferrante sarkar compact representations control dependence 
proceedings acm sigplan conference programming language design implementation white plains new york pp 

sigplan notices 
duesterwald gupta soffa distributed slicing partial re execution distributed programs 
proceedings fifth workshop languages compilers parallel computing new haven connecticut pp 

duesterwald gupta soffa rigorous data flow testing output influences 
proceedings second irvine software symposium iss california pp 

ferrante ottenstein warren program dependence graph optimization 
acm transactions programming languages systems 
field simple rewriting semantics realistic imperative programs application program analysis 
proceedings acm sigplan workshop partial evaluation program manipulation pp 

field tip dynamic dependence term rewriting systems application program slicing 
report cs xx centrum voor wiskunde en informatica cwi amsterdam 
forthcoming 
appear proceedings plilp 
fritzson kamkar generalized algorithmic debugging testing 
acm letters programming languages systems 
gallagher program slicing software maintenance :10.1.1.39.1532
phd thesis university maryland 
gallagher lyle program slicing software maintenance 
ieee transactions software engineering 
gopal dynamic program slicing dependence relations 
proceedings conference software maintenance pp 

gupta harrold soffa approach regression testing slicing 
proceedings conference software maintenance pp 

gupta soffa framework generalized slicing 
technical report tr university pittsburgh 
denotational program slicing 
proceedings nd hawaii international conference system sciences hawaii pp 

horwitz identifying semantic textual differences versions program 
proceedings acm sigplan conference programming language design implementation white plains new york pp 

sigplan notices 
horwitz pfeiffer reps dependence analysis pointer variables 
proceedings acm conference programming language design implementation portland oregon 
sigplan notices 
horwitz prins reps integrating non interfering versions programs 
conference record acm sigsoft sigplan symposium principles programming languages pp 

horwitz prins reps adequacy program dependence graphs representing programs 
conference record fifteenth annual acm symposium principles programming languages acm pp 

horwitz prins reps integrating noninterfering versions programs 
acm transactions programming languages systems 
horwitz reps efficient comparison program slices 
acta informatica 
horwitz reps program dependence graphs software engineering 
proceedings th international conference software engineering melbourne australia pp 

horwitz reps binkley interprocedural slicing dependence graphs 
acm transactions programming languages systems 
hwang du chou finding program slices recursive procedures 
proceedings th annual international computer software applications conference chicago 
hwang du chou influence language semantics program slices 
proceedings international conference computer languages miami beach 
jiang zhou robson program slicing problems implementation 
proceedings conference software maintenance pp 

kamkar overview comparative classification static dynamic program slicing 
technical report ida linkoping university linkoping 
appear journal systems software 
kamkar interprocedural dynamic slicing applications debugging testing 
phd thesis linkoping university 
kamkar fritzson interprocedural dynamic slicing applied interprocedural data flow testing 
proceedings conference software maintenance montreal canada pp 

kamkar fritzson approaches interprocedural dynamic slicing 
microprogramming 
kamkar fritzson interprocedural dynamic slicing 
proceedings th international conference programming language implementation logic programming bruynooghe wirsing eds vol 
lecture notes computer science springerverlag pp 

klint meta environment generating programming environments 
acm transactions software engineering methodology 
klop term rewriting systems 
handbook logic computer science volume 
background computational structures abramsky gabbay maibaum eds 
oxford university press pp 

korel ferguson dynamic slicing distributed programs 
applied mathematics computer science 
korel laski dynamic program slicing 
information processing letters 
korel laski dynamic slicing computer programs 
journal systems software 
kuck kuhn padua wolfe dependence graphs compiler optimizations 
conference record eighth acm symposium principles programming languages pp 

lakhotia graph theoretic foundations program slicing integration 
report cacs tr university southwestern louisiana 
lakhotia improved interprocedural slicing algorithm 
report cacs tr university southwestern louisiana 
landi ryder safe approximate algorithm interprocedural pointer aliasing 
proceedings acm conference programming language design implementation san francisco pp 

sigplan notices 
larus chandra tracing dynamic slicing tune compilers 
computer sciences technical report university wisconsin madison 
leung comments program slicing 
ieee transactions software engineering se 
lyle evaluating variations program slicing debugging 
phd thesis university maryland 
lyle weiser automatic bug location program slicing 
proceedings second international conference computers applications beijing china pp 

maydan hennessy lam efficient exact data dependence analysis 
proceedings acm sigplan conference programming language design implementation pp 

sigplan notices 
miller choi 
mechanism efficient debugging parallel programs 
proceedings acm sigplan conference programming language design implementation atlanta pp 

sigplan notices 
ott relationship slices module cohesion 
proceedings th international conference software engineering pp 

ottenstein ottenstein program dependence graph software development environment 
proceedings acm sigsoft sigplan software engineering symposium practical software development environments pp 

sigplan notices 
podgurski clarke formal model program dependences implications software testing debugging maintenance 
ieee transactions software engineering 
reps algebraic properties program integration 
science computer programming 
reps sequential nature interprocedural program analysis problems 
unpublished report university copenhagen 
reps illustrating interference interfering versions programs 
proceedings second international workshop software configuration management princeton pp 

acm sigsoft software engineering notes vol 
reps horwitz sagiv speeding slicing 
unpublished report institut university copenhagen 
reps sagiv horwitz interprocedural dataflow analysis graph reachability 
report diku tr university copenhagen copenhagen 
reps yang semantics program slicing program integration 
proceedings colloquium current issues programming languages vol 
lecture notes computer science springer verlag pp 

generalized algorithmic debugging 
phd thesis linkoping university 
shapiro algorithmic program debugging 
mit press 
venkatesh semantic approach program slicing 
proceedings acm sigplan conference programming language design implementation pp 

sigplan notices 
wegman zadeck constant propagation conditional branches 
acm transactions programming languages systems 
weihl interprocedural data flow analysis presence pointers procedure variables label variables 
conference record seventh acm symposium principles programming languages pp 

weiser program slices formal psychological practical investigations automatic program abstraction method 
phd thesis university michigan ann arbor 
weiser programmers slices debugging 
communications acm 
weiser reconstructing sequential behavior parallel behavior projections 
information processing letters 
weiser program slicing 
ieee transactions software engineering 
weiser private communication 
zima chapman supercompilers parallel vector computers 
acm press frontier series 
acm press new york 

