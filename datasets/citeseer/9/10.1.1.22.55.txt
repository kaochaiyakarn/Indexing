filtering algorithms implementation fast publish subscribe systems fabret arno jacobsen llirbat pereira ken ross dennis shasha publish subscribe paradigm users express long term interests subscriptions external agent users publishes events ers 
job publish subscribe software send events owners subscriptions satis ed events 
example user subscription may consist interest airplane certain type exceed certain price 
published event may consist er airplane certain properties including price 
subscription closely resembles trigger long lived conditional query associated action usually informing subscriber 
general trigger novel data structures implementations may enable creation scalable high performance publish subscribe systems 
describes attempt construction algorithms implementation 
combination data structures application speci caching policies application speci query processing system handle events second subscriptions consisting conjunctions attribute comparison operator value predicates 
motivation description problem human information web years 
web particularly suited changing information yahoo better source current world events newspapers 
reason pointed need systems capture changing information notifying users interesting events 
example bargain hunter may search web decide expensive 
may want alerted item cheaper 
food lover may wonder certain available convenient market 
may want alerted 
users bene publish subscribe system indicate desires alerted items matching desires met 
tool implements functionality scalable cient 
manage millions user demands noti cations subscriptions 
handle high rates events day notify interested users short delay 
addition provide simple expressive subscription interface ciently cope high volatility web user demands new subscriptions new users cancellations 
example user may want go new york california hours get ight 
subscription short lived 
model publish subscribe system system managing stream incoming subscriptions stream incoming data items events 
subscription event associated time interval considered valid 
publish subscribe system stores valid subscriptions valid event provides complementary functionalities new subscription comes system evaluates subscription valid events 
second new event comes system checks subscriptions matched new event sends event interested users 
describe publish subscribe system supports millions subscriptions high throughput incoming events hundreds new events second 
consider problem supporting high rate subscription changes 
event matching problem subscription system collection predicates triple consisting attribute value relational operator 
event conjunction pairs pair consists attribute value 
pairs attribute 
example movie groundhog day price theatre event 
event pair matches subscription predicate relop relop example price matches price event satis es subscription predicate matched pair example event movie groundhog day price theatre satis es movie groundhog day price price 
matching problem en event set subscription nd subscriptions satis ed notational rest denote set equality predicates 
represents set attributes occurring equality predicates example subscription movie groundhog day price price movie groundhog day movie 
database solutions subscription matching section examine database systems perform subscriptions matching directly 
traditional database systems scale millions subscriptions high throughput incoming data research may change state airs 
database systems designed fast evaluation queries stored data sets 
er trigger functionality check subscriptions new item comes 
valid data items stored single universal table form 
possible attributes subscriptions de ned sql triggers 
example subscription implemented sql trigger create trigger insert referencing new row new row new new signal manage millions subscriptions database system support millions triggers subscription single insertion data item may cause execution millions triggers 
solution scalable database systems implement optimization techniques trigger executions 
projects triggerman niagaracq propose global optimization techniques trigger executions :10.1.1.39.4584
solution close spirit triggerman proposed main memory data structures exact nature data structures di er 
schemas possible essentials ensuring scalability triggers 
contributions presents cient main memory matching algorithm matching subscriptions handle large number volatile subscriptions millions support high rates incoming data items hundreds events second 
algorithm nice properties 
creates data structures tailored complexity subscription language 

algorithm processor cache conscious maximizes temporal spatial locality 
techniques avoid cache misses processor prefetch command 

matching algorithm uses schema clustering strategy built main ideas group subscriptions size common conjunction equality predicates subscriptions partly evaluated single comparison multi attribute hashing indexes subscription attributes evaluated single comparison 

provide cost algorithms knowledge subscriptions statistics incoming data items able compute incrementally adapt optimal clustering changes subscription data item patterns 
experiments algorithms show support millions subscriptions high rates events hundreds events second high rates subscription changes 
section gives general description matching algorithm 
section presents cost approach compute optimal clustering 
section presents adaptive algorithm deal changes subscription event patterns 
section presents related approaches algorithms 
section performance studies 
section concludes 
solution overview performance issues main memory algorithms emergence cheap computers having large random access memory algorithms run main memory access secondary memory 
pc processors small cache memories processor cache memories static ram memories hold data referenced running programs 
inside cache memory memory processed processor speed 
cache called misses require fetch corresponding cache block main memory higher cost tens cpu cycles 
cache occurs processor normally idle fetch performed 
cache misses severely impede program performance 
reason main memory algorithm performance sensitive number instructions perform cache behavior 
main trends ram size processor speed grow exponentially years processor cache size increase linearly 
main memory algorithms sensitive processor cache behavior 
processor cache management policies simple evident processing cost reasons 
modern processors provide prefetch command permits running program force fetch cache block speci ed position ram 
command executed parallel program instructions 
program predict advance cache block need read avoid cache prefetching cache block instructions 
way limit cache misses design algorithms aware temporal spatial locality 
spatial locality achieved data consecutively algorithm placed consecutive memory addresses 
temporal locality achieved data manipulated consecutive instructions 

bit vector indexes list clusters predicates lines detail cluster list clusters subscription line mapping predicates clusters lists vector algorithm data structures propose matching algorithm speci cally designed cache conscious 
lot matching algorithms proposed literature :10.1.1.22.8918
knowledge aware cache behavior 
matching algorithm data structures algorithm data structures depicted 
recall subscription de ned identi er set predicates form attribute comparison operator value 
event set value pairs 
algorithm uses set indexes predicate bit vector vector subscriptions clusters lists called cluster vector 
algorithm uses indexes compute set predicates satis ed incoming event set clusters relevant event 
indexed predicate occurs subscriptions associated single entry predicate bit vector 
entry serves represent result predicate evaluation 
set predicate satis ed event 
predicate may associated list subscription clusters 
case say access predicate subscriptions clusters list 
predicate access predicate subscription match events veri es guarantees subscriptions cluster list associated need checked satis ed 
inside cluster list subscriptions grouped subscription clusters size number predicates 
provides detailed description subscription cluster subscriptions having predicates check 
subscriptions cluster subscriptions size organized follows consists collection dimensional arrays called predicates array containing bit vector entries dimensional array called subscription line contains subscription identi ers 
entry predicates array contains bit vector th predicate subscription identi er stored position subscription line 
subscription match event bit vector entries referenced column predicates array equal 
input event instance global variables set index bit vector set subscriptions clusters local variables candidate set clusters set subscriptions body candidate predicate testing index predicate reached bit vector access predicate clusters list lc candidate candidate lc subscriptions matching cluster candidate cluster matching return event matching algorithm event matching algorithm algorithm depicted algorithm executed time new event comes 
predicate bit vector initialized algorithm consists steps 
rst step uses indexes compute set veri ed predicates 
sets corresponding entries predicate bit vector collects lists clusters having veri ed access predicates 
second step considers candidate cluster applies cluster matching algorithm compute matching subscriptions 
cluster matching algorithm example cluster matching algorithm 
particular example specialized group subscriptions exactly predicates 
collection similar methods specialized small numbers predicates current implementation fewer 
generic method deal subscriptions having predicates 
generic method time consuming needs additional loop 
subscriptions small number predicates generic code called 
sub array sub array sub array answer prefetch sub array lookahead prefetch sub array lookahead prefetch sub array lookahead important features algorithm :10.1.1.22.8918
notice subscriptions stored columnwise 
subscription entries separate subscription arrays 
reason choice improve data locality 
loop subscriptions partitioned loops 
value unfold chosen unfold array entries cache line 
inner loop execute prefetch instructions 
prefetch subroutines implemented directly assembly language prefetch instructions telling cpu copy ram cache cache line full array entries processing near 
lookahead value chosen data arrives cache just cpu ready process data 
transfer asynchronous meaning overlap computation data transfer 
cache performance 
columnar storage means entry sub array consulted 
condition tested relatively selective may consult entry sub array sub array fact may cases avoid cache lines arrays :10.1.1.22.8918
row wise storage method forced touch cache line 
prefetching cache lines arrays may pay avoid reading cache lines possible reasons 
cache line may quite cache time 
second important processors limit number simultaneous outstanding cache requests 
pentium iii limit 
processors reserve right drop prefetch instructions limit reached prefetch instructions essential correctness 
circumstances certain prefetched cache line cache 
access fewer cache lines ect dropping prefetch instructions reduced 
larger numbers predicates empirically doesn pay prefetch corresponding arrays 
prefetch instructions compete limit better avoid prefetching arrays consulted frequently consulted arrays prefetched thoroughly 
algorithm analysis section rst analyze properties approach term memory space cache misses matching time subscription changes 
discuss problem designing clusters introduce sections 
space cost space cost linear number predicates size bit vector equal number distinct predicates 
subscription stored single cluster contains bit vector predicates 
total size subscriptions clusters linear total number predicates 
additional space indexes data structures 
hash indexes equality predicates simple trees inequalities guarantee space cost indexes linear number distinct predicates 
cache misses temporal locality reached avoiding repetitive operations data items 
algorithm predicates checked 
way subscription checked 
entries bit vector may checked times 
subscriptions redundant predicates bit vector kept small resident processor cache 
spatial locality reached independent data structures predicate matching subscription matching 
optimized main memory data structures predicate testing 
putting closed cluster subscriptions checked event clearly improve spatial locality 
size criteria number predicates group subscriptions clusters organize clusters integer arrays 
permit asynchronous prefetch operations cluster matching algorithm order reduce number synchronous caches misses directly ect response time 
simplicity presentation code assumes number subscriptions multiple unfold 
practice need small separate piece code deal remainder unfold subscriptions 
matching time subscriptions grouped cluster lists access predicates 
subscriptions cluster list match events verify cluster list access predicate 
clustering permits algorithm check subscriptions access predicate veri ed 
performance challenge de ne access predicates incoming event matched minimal number clusters 
equality predicates contained subscriptions candidates access predicates 
checking predicates incurs additional cost checked rst step algorithm computing bit vector 
second predicates access predicates permits guarantee exclusive access clusters accessed equality predicates attribute 
reduces signi cantly number cluster access event making processing time sub linear number subscriptions 
example consider simple workload consists subscriptions containing equality predicate attribute assume uniform distribution equality predicates values average number subscription checks event having value da da number distinct equality predicates contained workload 
equality predicates natural idea limit number subscription checks access predicates conjunctions equality predicates 
multi dimensional access predicates incurs additional space additional processing costs additional index structures hash table needed check 
clear trade additional cost hashing number subscription checks saved 
section propose cost approach compute optimal clustering simple equality predicates conjunction equality predicates access predicates 
insertion deletion subscriptions algorithm adding new subscription system similar event matching algorithm 
consists phases 
algorithm inserts predicates predicates indexes algorithm chooses access predicate inserts corresponding cluster 
cost insertion algorithm close event matching cost 
trees hashing tables indexes keep maintenance cost indexes close retrieving cost 
inserting cluster simply requires add new entry predicates array subscription line cluster 
deletions fast maintaining subscription identi er cluster contains 
cost insertion deletion adding deleting subscriptions obsolete ine cient previously optimal clustering 
way changes event patterns may degrade performance 
section adaptive algorithm maintain optimal clustering supporting high rates subscription changes incoming data items 
schema clustering schema clustering consists grouping subscriptions terms size common conjunction equality predicates access predicate multi attribute hashing nd subscription clusters 
precisely clustering instance clusters accessed set multi attribute hash tables called hashing con guration 
table con guration associated set attributes called schema allows access clusters having predicates access built schema 
hashing con guration clustering instance cluster table having entry referencing example consider collection subscriptions independently distributed attributes mentioned subscriptions 
suppose attribute values values attribute equiprobable 
suppose subscriptions indexes updated contains new predicate system 
subscription equality condition nonempty subsets fa cg 
suppose exactly subscriptions equality predicates exactly attributes consider clustering instance involving access predicates simple equality predicates subscriptions mentioning attribute equality placed cluster 
distributed uniformly population accessed hashing table subscriptions cluster contain subscriptions 
consider involving access predicates simple predicates conjunctions equality predicates ab bc 
subscriptions ac uniformly distributed subscriptions abc uniformly distributed ab bc 
hashing table populations ab bc 
sizes corresponding clusters ab bc 
consider cost matching event mentions need consult clusters clusters total cost hash table lookups subscription checks 
need consult average clusters clusters ab clusters total cost hash table lookups subscription checks 
analysis expect clustering instance preferred kind event 
note get clusters having equality predicates access predicate say abc expect just subscription check event mentioning partitioning cluster say abcd subscriptions equality conditions probably worthwhile add extra hash table lookup reducing number subscription checks 
event matching cost algorithm decomposed main parts cost needed computing value predicate bit vector cost computing relevant clusters cost checking set accessed subscriptions 
generally possible build clustering instances set subscriptions costs sensitive way subscriptions clustered problem choose cient clustering 
section describe cost approach compute optimal schema clusterings matching algorithm 
choice clustering cost function statistics subscriptions events 
section organized follows 
rst precise notions access predicate hashing con guration clustering instances 
give matching cost space cost incurred matching set subscriptions clustering 
pose clustering problem term minimization matching cost space constraint enumerate search space propose greedy algorithm produces locally optimal solution 
multi attribute clustering consider access predicates de ned conjunction equality predicates 
predicate de ned pair id identi er pred set equality predicates pairwise di erent attributes 
set attributes occurring pred called schema access predicate 
hashing con guration ap set access predicates 
order test predicates incoming events multi attribute hashing structures 
hashing structure intended check predicates having certain schema 
precisely multi attribute hashing structure set access predicates de ned pair set attributes called schema structure hash function takes event returns identi er access predicate exists having schema satis ed call hashing con guration set access predicates ap set hashing structures hn covers schemas access predicates ap call schema con guration set schemas tables clustering instance set subscriptions group subscriptions access predicates 
subscription cluster de ned triplet id identi er access predicate subs set subscriptions subscription contains predicates occurring call clustering instance set clusters subscriptions subscription appears cluster note cluster containing subscription ap set access predicates clusters access predicate ap note clusters set clusters having access predicates note clusters di er size subscriptions 
call hashing con guration hashing con guration covering ap 
matching cost clustering instance assume set subscriptions clustering instance associated hashing con guration 
cost matching event includes cost retrieving relevant multi attribute indexes event hashing cost relevant table cost checking accessed subscriptions 
event cluster cost matching matching index retrieving hashing ap cluster checking index retrieving cost retrieving indexes probability schema incoming event includes schema hashing cost running hashing function probability event satisfy access predicate cluster checking total cost checking subscriptions clusters set having access predicate 
checking checking cost cluster 
takes account fact group predicates checked remaining predicates checked 
assume cost retrieving relevant indexes linear number structures hashing con guration 
hashing cost independent size hashing structure linear size schema hashing structure cost checking set subscriptions linear number subscriptions 
assumptions consistent implementation 
assumptions leads simpli ed cost formula matching checking represent number indexes size schema respectively represent constants cluster containing access predicate 
space cost clustering instance space cost clustering instance hashing con guration includes cost storing hashing structures ap cost storing clusters 
space cost space init space ap hash space cluster cluster space init space initial space necessary create empty hash table 
hash space space necessary manage entry access predicate hashing structure cluster space size cluster regarding data structures clusters see size equal space size preds space represents constant 
computing best clustering instance goal set subscriptions problem nd clustering instance minimizes cluster checking cost depicted constraint total space occupied subscriptions clusters hashing structures amount main memory space 
exhaustive algorithm examine possible clustering instances 
approach algorithm builds clustering instance picking possible predicate group subscription nds associated matching cost space 
number clustering instances examined exhaustive algorithm jp number equality predicates average number equality predicates subscription represents number subscriptions 
complexity exhaustive algorithm impracticable 
propose greedy algorithm worst case complexity ga represents number subscriptions ga set attribute groups occurring subscriptions ga represents cardinality ga number bound jaj denotes set attributes occurring equality predicates algorithm starts natural clustering consists grouping subscriptions simple equality predicates access predicates 
equality predicates access predicates incurs additional hashing space cost hashing structures de ned predicate testing phase global matching algorithm 
improve initial clustering de ning additional multi attribute hash tables 
additional tables chosen incrementally step step 
step bene function decide hash table add 
bene function notion best clustering instance hashing con guration schema 
rst explain notion give bene function describe algorithm 
algorithm produces local optimum 
experimental results section show matching time improvements realized algorithm 
best clustering instance hashing con guration schema 
set subscriptions hashing con guration schema set clustering instances having hashing con guration schema 
call best clustering instance clustering instance gives best matching cost clustering instances 
clustering instance built iterating choosing subscription predicate access gp minimizes checking 
matching cost formula shows clustering instances associated hashing con guration schema di er total checking cost see line formula 
note best best clustering instance bestcost cost best clustering instance space space cost 
bene choice additional hashing structure set subscriptions hashing con guration schema 
matching bene adding hashing structure schema respect denoted de ned bestcost bestcost fag 
space cost adding denoted ds de ned space fag space space fag space 
bene unit space adding hashing structure schema ds 
bene unit space may nite matching bene strictly positive ds space saved 
greedy algorithm algorithm described bellow 
takes input set subscriptions maxsize space constraint returns hashing con guration schema associated best clustering instance ts maxsize 
set subscriptions maxsize space constraint 
ga ga ffag attribute involved equality predicate best space maxsize schemas ga schema maximum positive bene unit space respect exist return fbg best endif return dynamic clustering goal clustering minimize number subscription checks 
static approach clustering decisions taken global knowledge subscriptions system knowledge statistics incoming event streams 
subscription event patterns may change time degrading initial optimal clustering 
cope problem rst solution consists periodically recomputing scratch clustering instance adapted new situation 
due complexity reorganization solution suited applications subscriptions event patterns relatively stable large time intervals 
static approach clearly impracticable evolving continually 
section describe dynamic clustering algorithm incrementally adapts clustering changes subscription event patterns 
algorithm dynamically decides redistribute subscriptions cluster pro table clusters delete hash table redistribute subscriptions create new hash table table create 
decisions rely metrics called bene margin absolute bene power 
cluster redistributed bene margin high 
hash table removed absolute bene small new table created power su ciently high 
rst give de nition metrics show metrics characterize current state clustering instance 
describe maintenance algorithm 
algorithm parametrized thresholds setting minimal values absolute bene power maximal values bene margin 
discuss maintenance cost impact thresholds tradeo maintenance cost matching cost 
absolute bene absolute bene measures average number checks saved clustering instance compared case access predicate 
clustering instance cluster subscription absolute bene equal access predicate probability incoming event satis es cluster subscription checked probability systematically checked access predicate absolute bene cluster sum bene ts subscriptions equal absolute bene hash table sum absolute bene ts clusters equal bene margin bene margin focuses number checks saved clustering instances possible access predicates 
clustering instance cluster subscription bene margin equal access predicate maximal group equality predicates respectively probability incoming event satis es 
rationale superset bene margin cluster sum bene margin subscriptions equal 
power clustering instance associated hashing con guration 
power hash table respect set clusters absolute bene obtained moving subscriptions clusters bene equal set subscriptions cluster new access predicate access predicate algorithm metrics order metrics costly compute metrics approximation parameters 
approximation fact selectivity equality predicates usually low 
characterize current state clustering instance follows cluster approximate bene margin noted bm de ned hash table approximated bene noted de ned potential hash table set clusters approximated power noted rp de ned maintenance algorithm maintenance algorithm parametrized threshold values bmin 
maintenance algorithm act situations cluster bene margin cluster rises bene existing hashing table falls bmin 
bene margin cluster may increase reasons insertion subscription increase selectivity access predicate bene hash table may decrease subscriptions deleted 
implementation metrics updated insertion deletion subscription 
assume independent tool periodically provides statistics events streams impact access predicate selectivity 
algorithm described bellow 
actions undertaken algorithm cope situation twofold performed distinct phases 
rst phase maintenance algorithm attempts redistribution subscriptions 
dealing cluster excessive bene margin algorithm tries redistribute subscription existing table maximizes absolute bene dealing table insu cient absolute bene algorithm removes redistributes clusters 
redistribution clusters performed redistribute function 
function recursive 
redistribution induces insertions clusters may recursively induce redistribution clusters 
redistribution terminates subscription move 
subscription moved rst try best table subscriptions moved 
subscriptions moved may happen clusters excessive bene margin 
function redistribute returns clusters 
clusters candidate second phase algorithm 
goal second phase nd additional hash tables able reduce remaining bene margin 
phase takes input set clusters repair returned rst phase 
new tables chosen terms power bene margin solve 
algorithm considers candidate tables able receive subscriptions input clusters 
rst updates power 
selects creates tables su cient power 
may happen cluster sent rst phase repaired immediately due fact tables repair cumulated su cient power 
cluster contributes increase power su cient iterations phase 
soon tables created cluster subscriptions moved 
maintenance algorithm current clustering instance associated hashing con guration ph set candidate hash tables phase redistribution situation cluster excessive bene margin candidate phase redistribute situation table insu cient bene foreach subscription move cluster maximizes bene ts foreach cluster received subscriptions due deletion situation candidate phase redistribute endif foreach cluster deleted due deletion situation add deleted clusters endif phase creation new hash tables foreach deleted clusters foreach table ph ga update power deletion remove candidate repair foreach candidate phase foreach table ph ga update power add candidate repair situation exists candidate table su cient power choose table su cient power fhg move subscriptions candidate repair better bene update metrics endwhile cost maintaining hash table maintenance cost proportional number subscription moves 
new subscription arrives insertion algorithm chooses hash table gives best absolute bene may move hash table lifetime deletion subscriptions insu cient bene hash table insertions changes event statistics increase bene margin cluster triggers creation hash table better choice threshold values clearly impacts number moves 
bmin impacts number hash table deletions 
impacts amount clusters candidate new hash tables 
impacts number hash table creations 
terms matching cost quanti es pro changing cluster 
precisely indicates acceptable cluster checking cost cluster reorganization pro table 
example cluster large size rarely checked bene margin may small decide average checking cost acceptable candidate reorganization 
spirit quanti es pro create new hash table 
bmin quanti es pro maintain existing hash table clustering con guration 
section study performance maintenance algorithm terms improvements matching cost maintenance cost 
related lot main memory matching algorithms proposed context content publish subscribe systems triggers :10.1.1.22.8918:10.1.1.39.4584
basis algorithms main techniques 
consists phase algorithms test predicates rst step compute matching subscriptions results rst step 
proposal phase algorithm 
cite 
uses version counting algorithm second step :10.1.1.39.4584
counting algorithm consists counting subscription number hits number satis ed predicates 
achieve algorithm maintains association table giving predicate subscriptions occurs 
time predicate satis ed count corresponding subscriptions incremented 
sift sdi system allowing users subscribe documents specifying set weighted keywords 
keyword corresponds predicate keyword document 
rst step document parsed nding keywords best matching subscriptions computed similar counting approach 
matching algorithm proposed pereira uses similar approach algorithm 
algorithm groups subscriptions respect number predicates algorithm 
doesn prefetching optimizing second step algorithm uses single predicates grouping criterium 
performance evaluation bellow shows bene prefetching multi attribute hashing tables 
second technique consists compiling subscription predicates test network ala treat tree structure 
internal nodes represent tests predicates leaves network contain subscriptions 
events enter network root network tested internal nodes progressing node node node test succeeds 
event having successfully satisfy tests path reaches leaf obtain matching subscriptions 
algorithms subscription appear leaf proposed aguilera may appear leaves gough :10.1.1.22.8918
rst case event follow path tree 
second case generally follow paths 
rst solution cient space 
algorithm proposed aguilera gryphon system 
compared phase approach algorithms su er drawbacks 
bad temporal spatial locality second space third test network data structures complex costly maintain respect insertion updates subscriptions making solutions suited high rates subscription changes 
algorithms designated conjunctions attribute comparison operator constant predicates ltering event content 
triggerman niagaracq address respectively problem trigger condition continous queries evaluation 
optimize conditions combine predicates event predicates current database state 
cases algorithm works steps 
rst step ltering step content events order select database conditions candidate complete evaluation 
second step candidate conditions resp 
queries evaluated global optimization techniques 
discriminating ltering step amount computation evaluation step 
niagaracq database queries evaluated global multi query plan including split operators queries grouped common predicate signatures selective signature usually selection predicate equality operator chosen initial ltering selections performed plan 
triggerman uses treat network evaluate conditions 
ltering step sophisticated niagaracq consist conjunctions equality predicates signatures 
index techniques improve ltering equality predicates 
algorithm works conjunction equality inequality predicates event content 
enhance ltering phase triggerman niagaracq permitting powerful event ltering uses equality inequality predicates 
subscription algorithm entry point common query plans network triggerman consist joins splits operators 
ltering limited equality predicates cost algorithms improve performance choosing best multi key index con guration 
performance experiments section show best index con guration consisting choosing simple equality predicates consisting systematically choosing maximal conjunctions equality predicates 
show cost algorithms approach best con guration 
performance evaluation section evaluate performance algorithm compare ect clustering strategies 
consider versions algorithm simple propagation algorithm single equality predicates access predicates 
evaluate ects prefetch command see section compare implementations propagation algorithm propagation prefetching propagation wp prefetching 
static algorithm dynamic algorithms clustering strategy takes advantage conjunctions equality predicates 
static algorithm clustering build statically cost algorithm depicted section 
dynamic algorithm clustering incrementally maintained maintenance algorithm depicted section 
algorithms implemented prefetching 
comparison part related implemented counting algorithm see publish subscribe systems 
algorithms implemented publish subscribe system prototype 
system evaluated various simulated workloads accounting subscriptions events emitted system 
experimental results show algorithms able handle large number subscriptions millions high rate attribute comparison operator selection predicates attribute comparison operator attribute joins 
events events second 
detailed analysis characteristics various algorithms 
experimental setup workload generation ran experiments single cpu pentium workstation cpu mhz gb ram operating linux 
publish subscribe system runs process workstation waiting subscription events process 
subscriptions events submitted system time 
implemented workload generator workload speci cation emits subscriptions events publish subscribe system 
workload generation task ran separate process workstation publish subscribe system 
subscriptions events emitted system xed size batches 
batch size may set workload speci cation 
order evaluate matching algorithms high number subscriptions high event rate developed evaluation framework 
subscriptions events drawn randomly workload speci cation determines subscriptions predicates events attribute names 
subscription workload speci es total number subscriptions generate ns batch size ns determines number subscriptions submit system number predicates subscription np number predicates xed subscription np fix broken np fix np fix np fix number predicates respective operators predicate workload speci cation 
predicates determined name operator value domain domain cardinality 
value domain may speci ed predicate predicates 
determines value predicate speci ed lower upper bound respectively 
values drawn domain governed uniform distribution 
predicate names drawn prede ned set attribute names 
set attribute names draw attribute names events 
total number names available determined analogously events determined number events generate ne batch size events submit system ne number attribute value pairs event na number attributes xed na fix breakdown subscriptions value domain determined lower upper bound ua respectively 
values drawn uniformly distributed domain 
experiments intervals positive integers value domains 
determinants uence matching behavior algorithms probabilistic sense control number matched subscriptions workload speci cation determine parameter settings workload generation speci cations 
event attribute data skew determines distribution attribute values events 
may speci ed di erently attribute event referred event skew 
subscription predicate data skew determines distribution predicate values 
may speci ed di erently predicate subscription referred subscription skew 
correlation subscription event skews determine overlap predicate attribute value domains 
modifying correlation number events matched workload speci cation uenced 
necessary evaluate algorithmic behavior di erent matching algorithms di erent points state space 
required cross validate matching behavior algorithms 
workload parameters certain number predicates respectively attributes serve resource intense evaluate algorithms pre computed workload know number events matched subscription con guration 
resort simulated workload subscriptions events drawn randomly workload speci cation 
speci cation allows uence matching behavior algorithm probabilistic sense priori determine number matches workload speci cation 
determine number di erent subscription schemas generated average table summarizes workload speci cation parameters values experiments 
parameter description range global parameters total number predicate attribute names subscription predicate determining parameters ns total number subscriptions ns number subscriptions submit system np number predicates subscription np fix number predicates xed subscription limits value domain predicates predicate event determining parameters ne number events ne number events submit system na number attribute value pairs event na fix number attributes xed ua limits value domain attributes table parameter de nitions range values 
evaluate compare performance di erent algorithms metrics system throughput memory size system update time 
system throughput measures number events processed unit time various con gurations system 
memory size captures resident memory size publish subscribe system process separately di erent algorithms di erent system states 
system update time measures time takes submit updates insertions deletions publish subscribe system 
timings taken mill seconds workload generating process just events subscriptions submitted publish subscribe system process right system responds 
system responds event submissions noti cations contain ids matched subscriptions 
timings include interprocess communication times individual timings account processing entire batch subscriptions events submitted 
ran experiments multiple times notice signi cant di erence results 
report variances gures lower experimental runs repeated 
experiments total system throughput system scalability series experiments assume publish subscribe system subject large number subscriptions subscriptions stay system long time system handle high rate events 
basic assumptions designed matching algorithms 
represents key requirements assume system operate 
demonstrate total system throughput number subscriptions algorithms 
evaluate scalability characteristics system performance terms event throughput increasing number subscriptions process 
measure memory utilization time takes process constant number subscriptions system system update time 
compares system throughput algorithms 
workload speci cation np xed equality na xed value domain number may calculated combinatorially follows fix fix 
matching time ms number subscriptions matching process time event counting propagation propagation wp dynamic matching process time ms number subscriptions matching process time event dynamic dynamic propagation wp propagation wp np np fix ns varies np np fix ns varies memory bytes number subscriptions resident memory size counting propagation propagation wp dynamic time ms number subscriptions subscription loading time counting propagation propagation wp dynamic static np np fix ns varies np np fix ns varies event matching processing time memory resident size subscription loading time algorithms 
skews ns ne workload figures 
expected dynamic algorithm shows best performance counting algorithm performance 
performance propagation algorithms lies 
prefetching technique applied implementation propagation algorithms improves performance additionally factor large numbers subscriptions 
instance matching events subscriptions takes average ms counting ms propagation ms propagation prefetching ms dynamic 
notable feature dynamic algorithm fact matching time kept independent number subscriptions 
nice behavior ensured dynamically creating new hashing tables size clusters large 
ran experiments compare dynamic algorithm static algorithm 
static algorithm produced clustering instances similar obtained dynamic additional hashing tables signi cantly beat dynamic algorithm ms events 
shows metrics dynamic algorithm provide approximation clustering bene ts 
algorithms implemented phases 
rst phase consists determining predicates matched event second phase consists determining matched subscription information gained rst phase 
predicate matching done function algorithms 
propagation dynamic algorithms designed optimize second phase 
experiments separately measured phase 
ms dynamic algorithm matching events spent follows satis ed predicates discovered ms includes time process events parse arriving events 
matching subscriptions ms rest time spent communicating ids matching subscriptions back client process 
propagation prefetching algorithm spends time predicates checking communication subscription matching time increases number subscriptions ms subscriptions ms 
predicate matching performance may improved algorithms highly optimized index structure predicate domains 
primary goal highly optimize subscription matching phase techniques known 
compares system throughput dynamic algorithm propagation prefetching algorithm di erent kinds operators predicates 
workload speci cations set follows ns np np fix np fix xed predicate equality operator chosen freely unused predicate names ns np np fix np ix np fix xed predicate equality operator chosen freely unused predicate names 
results show algorithms sensitive non equality predicates 
performance decreases constant factor non equality predicates vs processed 
number satis ed non equality predicates computed rst phase algorithms greater non equality predicates generated workload 
performance di erence algorithms equal 
due fact algorithms cluster propagation algorithm handle non equality predicates 
algorithm bit vector entries associated inequality predicates subscription checked equality predicates veri ed 
algorithms tested similar subscription workloads probability situation arises 
performance gain dynamic algorithm shown left gure due improved handling equality predicates multi attribute hash tables 
figures show memory utilization rst gure subscription loading time second gure algorithms 
individual graphs follow natural intuition increased processing time memory due increased data processing storage needs 
terms memory utilization propagation algorithms internal data structures require amount memory closely followed counting algorithm dynamic algorithms requires 
multi attribute hash tables dynamic algorithm memory 
subscription load time cf 
smallest counting algorithm deploys simple data structures highest static algorithm statically computes scratch optimal clustering con guration 
compared static algorithm dynamic algorithm improves signi cantly loading time reorganizing incrementally internal data structures processing best suit subscriptions encountered far 
experiments results depicted show matching performance obtained incrementally computed clusterings ones obtained static algorithm 
uence number predicates size value domain performed series experiments test uence number predicates size predicate value domains kind predicate operators subscriptions 
due space limitations summarize results 
ran experiment increased steps size value domain predicates 
tested performance dynamic algorithm propagation algorithm workload conclude values domain better performance algorithms 
due fact higher selectivity domain fewer subscription need list values di er workload speci cation 
parameters workload equal values 
event maximal throughput time hours dynamic strategy change strategy event maximal throughput time hours events dynamic strategy change strategy changing subscriptions schemas adding subscription event skew evolution event throughput varying conditions veri ed 
furthermore dynamic algorithm sensitive factor propagation algorithm 
explained fact dynamic algorithm take advantage multi attributes access predicates 
test uence number predicates ran series experiments increased number predicates steps 
predicates subscription better performance dynamic algorithm 
encountering subscriptions predicates early algorithm build hash tables access patterns improve performance 
adaptivity subscription updates real world constraints publish subscribe systems deployed internet subjected constant stream subscription updates modi cations insertions deletions events 
subscriptions events change structure content value distributions time 
certain similarity patterns neighboring elements streams may observable 
subscriptions events may instance change terms predicates domains 
dynamic matching algorithm aims handling conditions 
order study adaptive behavior comparison algorithms context simulate conditions set experiments 
experiments consider situations publish subscribe system handle concurrently incoming events high rate incoming subscriptions 
assume subscription live time hours 
subscription rate subscription insertions second system process roughly events aging subscriptions deleted system 
say system reaches saturation 
experiments investigate behavior algorithms system saturation 
experiments system rst populated subscriptions workload speci cation 
state remove subscriptions representing oldest ones inserted hrs ago insert new subscriptions second 
system manage insertions deletions second remaining time second tick send events system measure number events system handle remaining time 
measure system evolution various application scenarios subscription event patterns changing 
rst experiment depicted investigates impacts subscription schema changes 
experiment models situation subscribers subjects interest changing time 
start workload ns np np fix na ua subscriptions focus attributes available sub 
system events provide uniform values attributes 
saturation clustering con guration optimal 
rst hours subscriptions events workload 
insert subscriptions new workload similar focuses attributes addressed 
hours system reaches new stable state subscriptions system 
continue run experiment hours inserting deleting subscriptions 
shows evolution average event throughput time throughput averaged hours compares opposite strategies clustering maintenance dynamic strategy uses dynamic algorithm adapt clustering subscriptions changes creating deleting hashing tables 
change strategy change initial optimal clustering con guration 
shows change strategy prevent performance degrade subscriptions schema changing 
event throughput divided 
hand dynamic strategy adapts clustering new situation 
hours subscription patterns stable system handle events second events second change strategy 
transition phase dynamic algorithm performance quite irregular 
due additional maintenance cost occurs new hashing tables created 
cost quickly compensated matching bene new tables 
dynamic strategy time better change strategy 
second experiment depicted 
investigates impact subscription skew combined event skew 
experiment models situation interest raises subscribers publishers 
typical examples arise news dissemination systems days election president everybody may want know candidates 
time information published subject 
model phenomena built experiment 
start workload ns np np fix na ua equality predicates attributes values uniformly distributed values 
rst hours subscriptions events workload 
hours create event skew subscription skew 
new events new subscriptions inserted new workload 
similar skew di erent values attribute values predicates xed attributes subscriptions 
hours system reaches new stable state subscriptions system 
run system hours inserting subscriptions 
shows evolution average event throughput time hours dynamic change strategies 
shows change strategy prevent performance degrade skewed subscriptions coming system 
event throughput reduced 
hand dynamic strategy adapts clustering new situation 
experiment subscription patterns stable system manage throughput transition phase cost maintaining clustering remains slightly compared matching bene hours matching bene obtained clustering reorganization overcomes maintenance cost 
propose main memory algorithm ltering event contents respect conjunctions attribute comparison operator constant predicates 
algorithm nice properties algorithm processor cache conscious maximizes temporal spatial locality 
techniques avoid cache misses processor prefetch command 
due subscription event skew subscriptions matched experiment 
incurs additional cost compensated clustering reorganization 
algorithm uses schema clustering strategy order minimizes number subscription checks 
subscription clusters accessed multi attribute hashing tables clustering strategy cost model compute optimal hashing con guration corresponding clusters statistics incoming events 
propose dynamic algorithm create remove clusters hashing tables dynamically set subscription modi ed due insertions deletions event patterns changing 
performance studies show algorithm support millions subscriptions high rates events hundreds event second millions subscriptions single cpu pentium workstation cpu mhz gb ram 
performance studies show algorithm support high rates subscription changes 
ltering algorithm implemented publish subscribe system provides cient support subscription language consisting dnf conditions events 
think algorithm cient pre ltering module powerful publish subscribe systems sql triggers continuous queries 
aguilera strom sturman chandra :10.1.1.22.8918
matching events content subscription system 
eighteenth acm symposium principles distributed computing podc 
chen dewitt tian wang 
niagaracq scalable continuous query system internet databases 
proc 
acm sigmod conf 
management data 
bernstein asilomar report database research 
acm sigmod record 
gough smith 
cient recognition events distributed systems 
proceedings 
hanson 
rule condition testing action execution ariel 
proceedings acm sigmod international conference management data pages 
hanson huang park vernon :10.1.1.39.4584
scalable trigger processing 
proceedings international conference data engineering pages 
hanson kim wang 
predicate matching algorithm database rule systems 
sigmod 
new era networks www com products html :10.1.1.39.4584
joao pereira fabret llirbat dennis shasha 
cient matching web publish subscribe systems 
proc 
int 
conf 
cooperative information systems coopis israel 
jun rao kenneth ross 
cache conscious indexing decision support main memory 
vldb proceedings th international conference large data bases pages 
segal arnold 
elvin left building publish subscribe noti cation service quenching 
proceedings auug 
yan garcia molina 
sift information dissemination system 
acm tods 

