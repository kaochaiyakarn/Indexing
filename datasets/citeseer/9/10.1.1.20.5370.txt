computational soundness formal adversaries jonathan herzog submitted department electrical engineering computer science september partial ful llment requirements degree master science dolev yao model useful widespread framework analyze security protocols 
models messages protocol high level extremely strong assumptions power adversary 
computational model cryptography cryptographic protocols takes low level view messages uses weaker assumptions 
major result demonstration certain kinds computational cryptography result equivalence sorts formal computational adversary 
speci cally give interpretation messages dolev yao model terms computational cryptography 
de ne computational security condition powers computational adversary show condition limits computational adversary operations dolev yao adversary 
lastly show security condition achievable standard computational cryptographic constructs 
thesis supervisor ron rivest title professor mit thesis supervisor nancy lynch title professor mit computational soundness formal adversaries jonathan herzog submitted department electrical engineering computer science partial ful llment requirements degree master science massachusetts institute technology september massachusetts institute technology 
rights reserved 
author 
department electrical engineering computer science september certi ed 
ron rivest professor mit thesis supervisor certi ed 
nancy lynch professor mit thesis supervisor accepted 
arthur smith chairman departmental committee graduate students contents example protocol 
dolev yao model 
computational model 

formal preliminaries computational preliminaries relating formal computational messages active synthesizer relating formal attacks active synthesizer ideal encryption open problems index notation formal sets operators 
computational sets operations 
sets operations connect formal computational settings 
abadi rogaway result public key encryption semantic security chapter area formal cryptography beginnings 
rst came needham schroeder proposed rst set authentication protocols 
second came seventeen years gavin lowe aw needham schroeder public key protocol xed protocol importantly proved xed protocol correct 
beginnings di erent previous cryptographic orts level abstraction 
protocols needham schroeder proposed speci ed terms cryptographic operations speci cryptographic algorithms 
similarly aw lowe rely properties cryptographic algorithms existed abstracted system 
authentication protocols 
exact de nition collection examples shares characteristics protocols sequence messages parties messages utilize cryptographic algorithms secure contents various ways protocol intended perform objectives 
authentication course protocol parties gain proof particular party participating protocol share common views protocol agree values protocol 
secrecy certain values protocol unknown observers 
chapter 
example protocol particular example de nition clearer 
needham schroeder public key protocol described sequence messages parties 
fja jg kb 
jg ka 
jg kb notation names unique identi ers parties 
starts protocol role initiator 
responds original message role responder 
protocol begins step fja jg kb notation read sends message exactly transmission message entity entity message rst step fja jg kb fjm jg encryption plaintext key concatenation joining messages value nonce random value generated freshly case sucient length small chances previous party 
nonce generated includes second message 
protocol goals 
secrecy values known generally nonces protocol known participants 
authentication initiator responder authenticated 
speci cally initiator know identity responder responder knows initiator agree values nonces responder know identity initiator initiator knows responder agree values nonces 
conceivable protocol analogous roles practice 
unusual initiator responder services trusted third party called server protocols 
literature de nition nonce 
weaker de nitions nonce require value nonce fresh protocols rely fact value nonce unpredictable 
initiator know responder knows appropriate secret key 
chapter 
authentication conditions hold 
attack lowe discovered initiator starts run protocol malicious entity uses pretend initiator third party 
fja jg km 
fja jg kb 
jg ka 
jg km 
jg kb entity fooled attack 
perspective sequence messages exactly expect run initiator initiator engaged run protocol thinks responder lowe include responder name second message making 
jg ka proof correctness involved parts rst proved attack large system multiple honest parties translated attack small system just parties 
model checker standard tool formal methods community exhaustively search small system vulnerabilities 
lowe rst papers subject interest area 
model checkers expanded re ned theorem provers shown value direct mathematical methods proved quite useful :10.1.1.145.4394
methods share common characteristics common weaknesses 
methods dolev yao model model attacker aspects model theoretical foundation 
dolev yao model dolev yao model early successful ort provide mathematical framework protocols examined 
model kinds active parties regular honest participants adversary 
regular participants follow steps protocol deviation 
engage multiple runs protocol simultaneously di erent parties 
model contains messages send receive internal states modeled chapter 
explicitly 
messages send receive assumed sent shared network messages tagged source destination values 
messages assumed elements algebra values 
types atomic messages texts keys 
compound messages created deterministic operations encrypt pair write fjm jg enc pair 
write encryptions range encrypt pairs range pair 
additionally algebra assumed free value produced applying operators atomic elements unique way 
phrased di erently value unique representation 
network assumed completely control adversary record delete replay reroute reorder messages 
adversary able create new messages limited degree 
setting adversary usually thought having particular goal 
adversary thought source noise non deterministic process send message generate participant time 
main approach proving security model nd strongest security properties secrecy authentication achievable regular participants despite presence adversary 
ability adversary create new messages limited adversary assumed know public predictable values names public keys time stamps 
create fresh values nonces session keys names 
assumed name possible regular participants may communicate adversary regular participant 
create new names assumed know set secret private keys 
keys include know regular participant 
adversary multiple entities set include secret keys entity 
terms written assume grouped left 
pair pair 
coalition adversaries adversary corrupted honest participants 
cases assume coalition remains constant adversary corrupt new entities protocol run 
model corruption participant usually assumed participant corrupted protocol run began 
chapter 
encrypt values knows keys knows decrypt encryptions knows decryption key pair known values compound message separate parts pair 
explicitly enumerated abilities adversary powers 
assumptions model freeness algebra limitations adversary surprisingly strong freeness assumption simply hold encryption schemes widespread des cbc rijndael cbc schemes number possible ciphertexts number plaintext key pairs xed message length 
inevitability ciphertext collisions necessarily freeness assumption true approximate sense schemes 
bad assumption encryption schemes time pads secure informationtheoretic sense 
priori reason freeness need true arbitrary encoding encryption scheme 
limitations adversary stronger set assumptions 
example basic rsa encryption algorithm plaintext ciphertext fjm jg represented integers 
due internal workings rsa turns fjm jg 
fjm jg fjm 
jg rsa adversary additional operation transforming encryption plaintext encryption plaintexts product 
arbitrary encryption scheme possible adversary additional operations able change plaintext encryption knowing plaintext able create valid encryption knowing encrypted 
additional operations usually undesirable considerable research gone identifying eliminating additional possibilities 
cryptography practice lags state research contains undesirable possibilities 
assumptions freeness algebra limitations adversary relaxed somewhat entirely disregarded 
variants dolev yao model contain note operations distinct operations de ne algebra adversary decrypt example decryption operator construction des rijndael cipher block chaining mode 
chapter 
additional operations studied attempts non freeness attempted :10.1.1.145.4394
assumptions listed may stronger necessary assumptions model inspired derived dolev yao 
methods model operate recursive manner rst examine possible operations available adversary produce bad term 
consider inputs operations require consider operations available adversary produce terms 
process repeated inde nitely entire set dangerous terms de ned 
dangerous terms available adversary initially part protocol run original bad term produced 
essential style argument set possible operations produce bad term explicitly enumerated 
recursive process fail catch dangerous terms set possible operations incomplete 
tractability necessary number ways produce term small 
ways produce term greater number attacker strategies checked part correctness proof increasing resources required automatic tools model checkers 
strong assumptions dolev yao model 
stipulating algebra free adversary limited model restricts possible ways term constructed small number 
true adversary produce term decrypting fjm jg requires adversary possess fjm jg recursively de ned set dangerous terms ends fairly small 
term xy produced di erent ways underlying algebra adversary unbounded number operations term considered dangerous methods fail 
methods build dolev yao model rst assumptions similar 
clear assumptions justi ed cast doubt method uses 
true attacks aws presence assumptions 
method assumptions nds aws protocol remains possibility attack adversary additional ability 
chapter 
computational model assumptions dolev yao model especially strong compared widely accepted model encryption cryptographic algorithms computational cryptography 
approach regards cryptography branch complexity theory regards cryptographic primitives algorithms map bit strings bit strings 
adversaries regarded probabilistic polynomial time ppt algorithms security conditions stated terms probability adversary perform calculation face increasing security parameter 
example suppose fd families distributions indexed security parameter distributions said computationally indistinguishable ppt algorithms negligible chance distinguishing sample formally distinguisher 
de ne computational indistinguishability way de nition distribution families fd computationally indistinguishable written fd polynomials pr pr means drawn distribution pr alternative notation pr 
computational framework computational indistinguishability express different types security conditions 
case pseudo random generators example generator pseudo random output generator random seed computationally indistinguishable random string length 
case encryption security condition matter messages chosen encryptions random key indistinguishable 
security parameter length key previous example security parameter length random seed 
practice proves algorithm meets relevant de nition security proving solve underlying hard problem 
cryptographic primitives notion probabilistic polynomial time adversary sucient 
authentication protocols hand advanced adversary needed 
oracle model models authentication protocols computational framework 
mes chapter 
sages represented bit strings encryption operations assumed meet certain standard computational de nitions security suggested 
main di erence regular participants modeled 
regular participants oracles transform formed bit strings formed bit strings 
adversary modeled arbitrary probabilistic polynomial time algorithm oracle access regular participants 
aside complexity limitation placed adversary create arbitrary bit strings perform polynomial time calculation 
security expressed ways authentication modeled predicate oracles 
usually predicate states oracle queried adversary oracle queried adversary matching way 
regular participant rst oracle observes sequence queries regular participant second oracle observe particular related sequence 
secrecy modeled indistinguishability 
secrecy condition holds adversary distinguish secret value key random value length 
characteristic computational framework protocols proven secure reduction argument 
example protocols designed number theoretic problems directly 
case typically show exists probabilistic polynomialtime algorithm able violate conditions exists probabilistic polynomial time algorithm solve hard problem 
alternately protocol lower level cryptographic primitives encryption security properties 
case show violate security conditions protocol exists algorithm violates security conditions underlying cryptographic building blocks 
model advantages disadvantages 
model uses lower level abstraction easier faith guarantees proof provide 
proofs model tend somewhat dicult 
proofs need created protocol individually dicult prove theorems protocols general 
models complement goal unify way gain bene ts 
oracle model uses low level abstraction gain strong proofs dolev yao model leverages high level abstraction provide intuitive chapter 
simple reusable proof methods 
assumptions dolev yao model justi ed computational setting protocol designers high level methods yield low level proofs 
area performed particularly abadi rogaway 
authors give signi cant support validity dolev yao model grounding large part model terms computational cryptography 
particular identify conditions secret key cryptography satisfy insure terms indistinguishable dolev yao adversary fact indistinguishable computational adversary 
results valid weak adversary call passive distinguisher 
passive adversary access information input 
name denotes fact overhear messages activity honest parties send messages creation take action ect honest parties 
likewise distinguisher adversary relatively dicult task distinguishing messages 
adversary abadi rogaway weak charged solving dicult task 
adversary consider active synthesizer 
active adversary create new messages send honest participants attempt solicit additional potentially useful information 
calling adversary synthesizer means goal creating new message 
easier task distinguishing messages aw rsa described chapter indicates create fjm jg fjm jg fjm jg fjm jg fjm jg indistinguishable ciphertext 
adversary relatively strong charged accomplishing relatively simple task 
concerned slightly dicult challenge 
synthesizer create message certain ones messages created formal adversary 
dicult creation single message easier task faced distinguisher 
main results fold 
de ne security property computational cryptography called ideal security de nition 

abadi rogaway devised method relating messages formal model computational messages probability distributions bit strings uses computational cryptography 
show primitives relation ideal term creation 
may standard term kind adversary 
chapter 
equivalence sorts active synthesizer dolev yao adversary 
put way underlying cryptography ideal active synthesizer perform action unachievable dolev yao adversary theorem 

provide example encryption algorithm ideal prove 
theorem 
review dolev yao computational models depth chapters respectively 
explore messages models relate chapter 
develop adversary model relevant setting chapter 
chapter consider ideal cryptography induces equivalence active synthesizer formal adversary 
provide example ideal encryption scheme chapter proof ideality 
nish possible extensions open problems chapter 
chapter formal preliminaries stated messages model assumed elements algebra values 
types atomic messages di er application application setting considering case asymmetric encryption needham schroeder protocol running example 
types atomic messages having subtypes texts subtypes names public predictable nonces private random unpredictable keys subtypes public keys private keys compound messages created deterministic operations encrypt range pair range simple terms pairs atomic terms encryptions 
additionally algebra assumed free value produced applying operators atomic elements unique way 
require bijection inv chapter 
formal preliminaries write inv assume mapping 
write ka security protocol hinges fact certain value created adversary despite fact adversary power create fresh random values 
particular adversary assumed power create fresh random nonces keys 
discuss issue greater detail chapter de ne set nonces containing nonces created formal adversary 
values distinguishes elements versus nonces distinction useful 
likewise de ne set keys created adversary 
assume adversary subverted static set subv principals access keys subv subv principals subv subverted adversary keys chosen 
opposed keys adversary unable choose values keys subv 
designate entire set private keys known adversary bad subv formal setting global system modeled set communicating processes 
honest participants adversary modeled processes maintain internal state send receive messages channel 
di erent models style making slightly di erent assumptions timing synchronicity channels processes messages 
essential aspects modeling constant 
adversary assumed total control network 
adversary repeat delete delay re route messages sees modeled letting adversary network 
model honest participants send messages adversary receive messages adversary illustrated 
model concern liveness properties 
purpose model prove bad things won happen things 
example adversary powerful previous paragraph able prevent message reaching honest participant 
impossible show honest chapter 
formal preliminaries participant adversary participant participant participant general formal model communications participant complete run protocol 
perspective perfectly acceptable honest participant nishes protocol honest participant fooled protocol 

model generally assumes message reaches honest participant participant expecting hear part protocol 
slightly di erent issues assumption honest participants need deal message ill formed invalid participant current stage protocol 
certainly assumption address purpose give computational soundness model strengthening model come afterward 
aspects fact interested entirely behavior adversary model convenient form 
actions capabilities honest participants environment process adversary communicates 
adversary total control network communication adversary honest participant 
perspective adversary regular participant thought interface environment 
true going channels lose addressing information 
information insecure control adversary concerned liveness properties 
simply regard environment non deterministically routing message adversary receptive participant 
participant able receive message point time 
chapter 
formal preliminaries environment adversary participant participant participant participant model communication commonality formal models operation adversary 
addition power network adversary assumed limited power synthesize new messages transmit 
particular adversary assumed internal knowledge set increase time 
initial knowledge set adversary usually assumed consist things 
public keys 
private keys subverted participants subv 
names principals 
nonces generates assumed distinct nonces generated honest participants 
keys generates 
analysis protocol assume adversary access sets terms 
adversary learned set messages sum total knows union sets 
ease notation denote union de nition knowledge set subv adversary knows set close operations decryption private keys knowledge set encryption public keys knowledge set chapter 
formal preliminaries deduce encryption public key encrypt joining elements knowledge set separation join element component elements 
put formally de nition closure written smallest set 

fjm jg 
fjm jg 


fjm jg point time adversary knowledge set send element honest participant 
adversary receives response honest participant replaces knowledge set fng 
send element fng participant 
central assumption formal model extent adversary ability manipulate cryptographic material 
concerned closure arbitrary condition de nition closure usually irrelevant 
adversary de ned closure operation de ne attack adversary environment env possible trace adversary communicating env attack sequence messages sent received adversary certain restrictions 
general restriction messages adversary receive transmissions send receptions 
order message reception ect operation adversary model trace sequence message transmissions alternating reception possibly empty message sets originating env de nition formal attack environment env trace formal adversary communication environment env sequence message transmissions chapter 
formal preliminaries possibly empty message set receptions requirements sets determined speci cation environment env stated dolev yao adversary assumed particular goals 
attempts prove strongest security conditions true despite presence adversary 
chapter computational preliminaries computational side adversary probabilistic polynomial time turing machine assumed attempting violate security property 
messages nite length bit strings 
public key encryption simple operation triple algorithms parameter coins publickey randomized key generation algorithm string coins publickey ciphertext randomized encryption algorithm string string decryption algorithm assume returns input string valid encryption corresponding public key 
helper sets parameter coins set nite sequences bit strings 
publickey ciphertext vary key generation algorithms implicitly depend parameter string write probability distribution induced chosen randomly uniformly coins 
similarly write probability distribution induced technically distribution somewhat complex achieves intuitive result 
algorithms encryption scheme assumed take time polynomial security parameter length keys polynomial security parameter algorithm depend nite sub sequence random coins 
loss generality assume algorithms depends rst bits polynomial 
coins partitioned equivalence classes strings chapter 
computational preliminaries chosen randomly uniformly coins 
write mean drawn distribution nite set mean uniform distribution set 
weakest form security public key encryption algorithm known semantic security best described game 
key pair generated algorithm adversary rst represented picks messages 
messages chosen random encrypted 
adversary represented decide messages encrypted 
encryption scheme semantically secure adversary correct guess non negligibly greater de nition public key encryption algorithm pass semantically secure ppt algorithms polynomials suciently large pr de nition slightly di erent better known form security pass version 
di erence pass version de nition adversary allowed know encryption key choosing messages version de nition strictly stronger pass version need additional strength proofs 
apparently new de nition public key cryptography extract public key encryption encryption de nition public key encryption scheme key providing exists polynomial rst bits class 
note nite number equivalence classes 
select randomly coins rst select equivalence class select arbitrary class 
intended interpretation selecting randomly coins 
likewise speak selecting speci element coins mean setting rst bits 
technically de nition di erent de nition security usually called general message gm security 
gm security known equivalent semantic security slightly convenient form purposes 
relevant line pass version 
chapter 
computational preliminaries time algorithm messages pr constructing key providing encryption scheme dicult constructing encryption scheme theorem semantically secure public key encryption scheme exists semantically secure key providing public key encryption scheme exists 
proof semantically secure encryption scheme algorithm input mi runs produce outputs hc ei rst component clearly scheme key providing public key part ciphertext 
furthermore original encryption scheme semantically secure modi ed encryption scheme 
adversary receives public key anyway having ciphertext reveal gives additional power 
particularly useful creature known zero knowledge zk proof 
zk proof type interactive proof system interactive proof sequence messages prover veri er truth theorem np language 
concern special type interactive proof called non interactive zero knowledge proofs interactive proofs limited message prover veri er 
assumed theorem proven shared parties chosen external proof protocol 
prover veri er share common string xed bit string known randomly chosen 
de nition language np witness relation function pair interactive machines called non interactive proof system machine polynomial time polynomial polynomials suciently large terminology somewhat misleading 
non interactive proof fact special type interactive proof 
called non interactive proof message exchanged veri er chance ect behavior prover 
chapter 
computational preliminaries 
completeness theorems length witnesses strings length 
soundness unbounded adversary pr prover able veri er accept true statement adversary negligible chance able veri er accept false statement 
recall np de nition turing machine ml exists ml accepts hx wi time polynomial jxj 
called witness clearly np turing machine ml act veri er prove prover nd witness cases may wish prove disclosing witness de nitions formalizing intuition consider simplest de nitions non interactive zero knowledge proof non interactive proof interesting condition proof completed veri er gains information fact de nition non interactive proof system language np computational non interactive zero knowledge pair ppt machines adversaries pr pr proof system zero knowledge matter malicious veri er tries glean information prover prover replaced simulator ecting behavior adversary 
malicious veri er gleaned prover gleaned access prover 
require proof string speci apparently new condition states proof valid string invalid chapter 
computational preliminaries string de nition non interactive proof system language np string speci polynomials suciently large exists string making accept pr especially strong condition 
fact trivial turn interactive proof system string speci theorem non interactive proof systems exist language string speci non interactive proof systems exist proof bit string hm ni contiguous substring position position inclusive 
non interactive proof system 
system hl hl hl new string length old string length plus additional bits 
new prover uses rst bits string simulate old prover outputs proof plus bits string 
veri er checks proof rst bits string veri es bits proof bits string 
suppose 
pr pr vanishes faster polynomial system string speci furthermore system non interactive proof system inherits soundness completeness original proof system 
new system string speci non interactive proof system chapter 
computational preliminaries easy see transformation preserves zero knowledge aspect noninteractive proof system additional bits random untouched prover adding proof reveals underlying witness 
condition need proof proofs knowledge 
proof system adversary fact create proof new theorem np possible derive adversary witness derivation done pair algorithms collectively known extractor adversary subroutine de nition proof system np witness relation 
proof knowledge ppt algorithms polynomials suciently large 
string uniformity pr pr 
witness adversaries pr pr rst condition technical consideration specifying extractor signi cantly change behavior adversary trying extract witness 
second consideration important specifying adversary create new statement proof veri er accept extractor adversary produce witness showing great chance success 
chapter relating formal computational messages major result demonstration certain kinds computational cryptography result equivalence sorts formal computational adversary 
consider adversary rst consider formal messages correspond computational analogue probability distributions bit strings 
chapter de ne function formal messages computational messages computational primitives de ned chapter 
material chapter exactly abadi rogaway exact analogue adapted case symmetric encryption public key encryption 
conversion function helper functions handle translation atomic elements keys keys assumed randomly independently generated 
family distributions indexed parameter distribution set functions publickey 
assume parameter pr pr coins probability random element drawn assigns pair bit strings pair keys exactly probability getting pair chapter 
relating formal computational messages bit strings key generation algorithm 
words assume formal key pair assigned computational keys key generation algorithm independently key pair 
keys generated adversary hand necessarily chosen randomly 
chosen way adversary likes long keys 
elements key 
set functions keys bit strings publickey assume exists injective function names bit strings 
names representation 
lastly need helper function map nonces bit strings 
intuitively nonces random values created freshly needed 
natural translation map nonces bit strings length grows security parameter 
carefully consider nonces chosen adversary 
cases adversary may choose nonce particular property adversary exploit 
keys consider disjoint sets nonces rst set nonces nonces values chosen adversary 
second set nonces chosen regular honest principals 
assume values nonces chosen independently random 
handle cases de ne sets set functions bit strings length set functions bit strings length 
practice regular participants choose nonces randomly independently assumed adversary picks nonces way chooses 
represent random element considering possible elements chapter 
relating formal computational messages helper functions de ne function maps formal messages probability distributions bit strings de nition fix 
de ne convert function messages probability distributions bit strings way convert nonce nonce name key hf key convert coins enc fjm jg convert pair interpret pair encryption operation function pairs triples distributions distributions constructed intuitive way 
denote convert implicit 
function reconsider main focus abadi rogaway conditions formal messages look formal adversary 
formal adversary power certain limited deductions formal messages formal messages look possible deductions yield results 
example adversary information messages indistinguishable formal adversary 
represent information deduced formal message pattern de nition recursively de ne function notation means uniform distribution set chapter 
relating formal computational messages fjm jg fjp jg pattern pk public key pattern expression set fmg grammar algebra patterns exactly messages addition blob represent encryptions 
blob labeled formal adversary deduce plaintext able deduce key encrypt 
main result abadi rogaway convert algorithm formal messages pattern distributions induce computationally indistinguishable passive adversaries 
true technical condition de nition expression construct graph gm nodes public private key pairs expression 
draw edge private key associated pair encrypted public key associated expression acyclic graph gm acyclic 
expression acyclic encrypts encrypts sequence keys encrypting keys loops back 
example message acyclic message 
result abadi rogaway remains true new convert function abadi rogaway version condition regards symmetric keys 
chapter 
relating formal computational messages theorem suppose acyclic expressions 
pattern pk pattern pk 
new convert algorithm provides security passive distinguisher abadi rogaway convert algorithm symmetric key cryptography 
proof exactly abadi rogaway appendix brevity 
proof yields interesting fact corollary acyclic message pattern pk 
words assign distribution pattern message extending de nition assign distribution message indistinguishable pattern 
proof appendix de nition concerns acyclic messages 
need apply results sets messages 
need intermediate operator transforms set messages single message de nition set messages 
attening message created applying pair operation element canonical order 
de ne acyclic set messages de nition set messages acyclic acyclic message 
de nition useful proof main result theorem 
entirely reasonable messages available adversary result realistic protocol acyclic 
usually actual cryptographic protocols operate ways long term keys encrypt session keys encrypt keys session key encrypt session key previous keys encrypted 
cycles keys encryptions result cases 
real world protocols set messages sent regular participants result key cycle 
example fa cg ab chapter active synthesizer opposed adversary considered adversary interest active synthesizer eavesdropping xed protocol 
chapter discuss additional powers adversary 
theorem corollary address issue message structure adversary determine message limited set keys 
adversary limited eavesdropper know source message adversary knows messages keys 
adversary consider active implies things 
assumed listening trac xed known protocol 
able send messages devising part trac 
views trac simply messages able learn great deal message external channels trac analysis 
example adversary able know overheard message rst message run needham schroeder protocol chapter message structure pair identi er random nonce created freshly run encrypted public key 
adversary hand de ned absence protocol 
access context message drawn 
model information active adversary may glean trac analysis 
may trac analysis may yield partial information structure messages 
fully capture ability adversary give perfect knowledge structure messages 
hand want give additional knowledge giving knowledge values messages contain 
chapter 
active synthesizer reveal structure message revealing values assume message comes tag representation structure message 
de ne function maps messages machine readable tags way de nition 
function name function names bits convert algorithm 
nonce produces machine readable label uniquely identifying nonce completely independent distribution 
key produces machine readable label uniquely identifying key completely independent distribution 
pair term pair encryption term fjm jg fjm jg enc example tag message fja jg kb rst message needham schroeder protocol fja jg kb enc pair name nonce key kb primary di erence tag pattern twofold rst tag reveals entire structure message pattern may reveal partial information tag contain values message pattern reveals values extent reveals structure 
tags di erent contexts essential way 
tag represents internal structure message 
rst context discussed provide adversary knowledge internal structure messages possibly gain trac analysis 
particular simply assume message overheard adversary tagged way include tags part adversary input 
direct contradiction spirit abadi rogaway explores cases structure encryption hidden adversary 
contradict results regard structure overheard encryptions predictable cases information explicit 
abadi rogaway interested passive adversaries need de ne tags 
de nition rest chapter original 
chapter 
active synthesizer second context tags discuss honest participants decide message certain structure 
convert algorithm provides way turn formal term distribution bit strings 
suppose protocol participant receives bit string 
formal term message correspond 
protocol participant decide 
resolve diculty idea conversion veri er de nition 
function nonce tags nonce bit strings function key tags key bit strings 
say algorithm conversion veri er veri er accepts legitimate encodings message 
messages 



contexts clear omit oracles 


conversion veri er useful de ning challenge faced synthesizing adversary 
informally adversary charged creating new valid message 
formalize adversary conversion veri er decide message valid 
possible conversion veri er accept strings valid encodings 
major result theorem conversion veri er constructed hard nd string 
formalize challenge faced active synthesizer formalize active synthesizer 
usual adversary modeled probabilistic polynomial time turing machine active adversary send messages honest participants receive replies 
represent access information input giving access potentially helpful oracles adversary allowed know public key principal represent way oracle oracle returns kx returns names representation oracle de ned 
oracle assume picked initialize oracles 
note conversion veri er may power conceive formal participants having 
deal issue purposes regard environment knowing secret 
chapter 
active synthesizer assume adversary static sense adversary corrupted xed unchanging collection principals 
opposed dynamic adversaries defer decision corrupt gathered information adversary operate xed set corrupted participants chosen 
formalize assuming set principals subv trustworthy 
adversary subverted adversary 
exact circumstances matter matters keys subv deviate needham schroeder protocol 
set subv change course protocol adversary may learn new keys due aws protocol handle closure operation learn new keys subverting new principals 
represent corruption principals subv allowing adversary oracle access private keys oracle returns subv returns lastly adversary able know name participant ones subverted 
explicitly model oracle provides names participants sort request necessary 
secret unpredictable naming participants 
easy imagine naming participants done ecient deterministic algorithm hard wired adversary 
assume loss generality adversary knows names relevant participants 
chapter discuss challenge creating valid appearing message equivalence formal attacks active synthesizer 
chapter relating formal attacks active synthesizer chapter explore relationship formal adversaries active synthesizers 
particular de ne concept attack computational formal levels show certain conditions computational attack correspond formal attack 
formal attacks de ned de nition 
de ne computational attack activity active synthesizer 
mentioned chapter assume message sent adversary expected environment 
re ne notion time avoid particular issue considering conservative goal 
requiring adversary synthesize element particular set messages set expected messages consider general case adversary synthesize message 
requirement consider message sent active synthesizer apparently valid encoding formal message de nition quasi formal attack environment env conversion veri er trace computational adversary communication environment env sequence bit string queries receptions sets tagged bit string responses qn rn qn rn chapter 
relating formal attacks active synthesizer element note queries need fool conversion veri er responses contain legitimate encodings 
call type attack quasi formal entirely computational setting entirely formal setting 
entirely computational adversary queries encodings formal messages arbitrary bit strings 
attack entirely formal hand queries adversary limited sort closure operations 
de nition quasi formal attack corresponding formal sequence de nition corresponding formal sequence quasi formal attack qn rn qn rn alternating sequence messages sets messages bijection 
may corresponding formal sequence quasi formal attack convert algorithm allows formal term encoding 
note de nitions assume application convert algorithm uses functions 
wish prove quasi formal attack computational setting imply attack formal setting 
wish show possible quasi formal attack corresponding formal attack 
de nition quasi formal attack great deal weaker formal attack correspondence may able nd result cryptography convert algorithm 
de ne security condition limits power adversary calculating single query chapter 
relating formal attacks active synthesizer de nition encryption scheme ideal 
key providing semantically secure pass encryption scheme 
conversion veri er adversary satisfy veri er outside closure acyclic polynomials suciently large pr 

encryption ideal semantically secure adversary encoding outside closure 
note de nition applies acyclic set messages natural extend sets need acyclicity property proofs 
despite fact condition describes query sucient enforce correspondence quasi formal formal cryptography theorem 

env distribution communication transcripts interactive turing machine oracle access 

environment env convert algorithm uses ideal encryption number messages exchange generated adversary xed number pr 

env quasi formal corresponding formal attack polynomials suciently large 
proof consider quasi formal attack qn rn qn rn chapter 
relating formal attacks active synthesizer quasi formal corresponding formal sequence way consider attempts part adversary break ideal encryption 
particular query considered attempt produce stage interactive adversary received input corresponding tag 
oracle access 

runs time polynomial 
know de nition ideal encryption pr polynomials suciently large 
union bound upper bound pr suciently large 
constant respect probability adversary produce quasi formal attack fact formal remains negligible 
order show computational adversary limited operations available formal adversary sucient ideal cryptography 
ideal cryptography achieved 
quite easily fact demonstrate chapter 
chapter ideal encryption chapter show speci encryption scheme ideal theorem suppose key providing semantically secure pass encryption scheme 

random oracle suppose string speci non interactive zero knowledge proof knowledge system ciphertext 
distribution hm ei hc pi randomness produce hc pi de ned recursively nonce ni hl nonce accept 
key ki hl key accept 
pair ni ha pair accept accepts 
enc ki hhc pi enc accept 
veri er 
hc pi 
accepts 
chapter 
ideal encryption recall functions nonce tags key tags nonce encodings key encodings respectively 
ideal 
proof show collection algorithms satis es de nition ideal cryptography need show provide semantic security conversion veri er fooled 
show algorithms provide semantic security appendix focus attention second condition de nition 
suppose adversary violates condition 
acyclic polynomial nitely pr 

note assume loss generality contains simple terms atomic terms encryptions 
contain pair term simply consider equivalent set fx likewise assume loss generality simple term adversary produce simple matter modify adversary produce 
implies sucient consider adversary produces simple terms 
proceed case analysis suppose jg case equal hhc pi enc output gm secure encryption scheme non interactive zero knowledge string speci proof knowledge proving knowledge plaintext associated randomness encryption 
string proof assumed rst bits random oracle 
suppose adversary able produce polynomial probability pair hc pi hhc pi enc jg 
hhc pi enc accepts chapter 
ideal encryption accepted 
proof knowledge know de nition extractor pr pr pr pr negligible function disappears faster polynomial 
produces satis es jg exists produce satis es runs rst part extractor produce string 
runs passing oracle queries oracles 
exception tries query random oracle 
returns 
produces proof uses second part extractor hc extract witness witness course hn ei plaintext randomness encryption algorithm public key encrypt 
odds succeed task 
know strings produced computationally indistinguishable random strings rst part de nition probability produce seemingly valid encoding jg change non negligible amount 
rest assured produce theorem proof non negligible advantage 
fact non negligible chance producing particular theorem valid encoding fjm jg chances doing new string 
second part de nition know probability second part extractor producing witness non negligibly chances producing proof 
advantage creating proof bounded polynomial advantage producing witness bounded chapter 
ideal encryption negligible functions 
non negligible chance creating witness yield plaintext immediately 
point 
know query random oracle value 
proof string speci vanishingly strings accept proof adversary created querying random oracle adversary able produce value random oracle happened vanishingly strings random oracle produces random strings probability adversary able nd pr adversary create hc pi conversion veri er accepts value doing 
adversary produce valid encryption produce plaintext encryption chances 
likewise adversary create encoding pair create encoding component 
switch moment consider parse tree suppose path root parse tree leaf passes element suppose path parse tree root leaf node message root message path parse tree element path including root shown adversary create valid encoding create valid encoding consider possibilities suppose matter contradiction 
suppose matter suppose subv need worry subv 
cases parse tree 
parse tree element input adversary completely independent required output 
function conversion veri er chapter 
ideal encryption access value accept sole element 
drawn randomly drawn randomly element independent value encoding atomic value 
particular value independent encodings elements possible encodings elements subv adversary question able guess bit random value inputs independent target value 
probability bounded contradicting assumption probability polynomial 
hand adversary able guess private key corresponding public key values independent private key 
assuming encryption scheme semantically secure probability bounded polynomial fraction 
matter probability adversary able produce polynomial fraction 
hand may parse tree elements parse tree element parse tree attening suppose parse tree pattern pk bad reach trivial contradiction 
case interest parse tree pattern pk bad acyclic apply abadi rogaway result appendix giving adversary sample give adversary sample pattern pk bad theorem know pattern pk bad computationally indistinguishable 
adversary great chance able extract pattern pk bad 
distribution pattern pk bad independent value know odds algorithm able negligible 
small complication 
know distributions pattern pk bad indistinguishable ppt algorithm 
adversary ppt algorithm access additional oracles 
distributions indistinguishable adversary 
answer course 
suppose contrary adversary distinguish sample pattern pk bad pr adv 

chapter 
ideal encryption pr pattern pk bad adv 

suppose polynomial nitely jp build adversary distinguishes distributions additional oracles 
distributions distinguished pattern pk bad slight modi cation 
essential idea create new message distinguish pattern 
distinguish directly distinguish sub message pattern 
parts message included simulate oracles queries 
set key public private parse tree inverse parse tree key useful analysis bad set key available adversary potentially useful analysis distributions new adversary able distinguish hh ii hh pattern pk bad ii essence add pattern pk bad useful keys available penetrator 
simply add keys adversary knows may nite number 
add nitely keys may useful analysis particular message 
corollary know distributions indistinguishable 
construct adversary distinguishes distinguishable pattern pk bad original adversary new operates running sub routine 
suppose drawn input new adversary rst strips chapter 
ideal encryption keys ends string 
transforms example element hh ii element 
creates tag tag depends parse tree actual values atomic messages leaves exception function names bits assumed public easily computable function 
parse tree hard wired accurately generate valid tag function described de nition 
adversary simulates 

input ti 
exactly input original adversary expects 


oracle query responds way oracle queried 
input valid name return key 
kn key return part original input checks internal table see value kn created 
returns 
runs create values kn stores internal table returns new value kn oracle queried 
input valid name may may return key 
compromised participant key returned 
key returned 
key return part original input checks internal table see value created 
returns 
runs create values kn stores internal table returns new value adversary exactly simulate adversary additional information input simulate oracles call 
subroutine act exactly fashion 
produces returns 
returns 
probability produces changes polynomial fraction depending distribution new adversary polynomial advantage predicting distribution input distinguish know distributions indistinguishable know original assumption original adversary correct oracles tag give power distinguishing pattern pk 
run sample pattern pk achieve result running sample 
cases adversary polynomial chance producing parse tree pattern pk 
chapter 
ideal encryption distribution pattern pk independent value adversary able produce random value input completely independent random value 
odds happening negligible case nonces private keys know reached contradiction 
shown things 
adversary produce encryption outside closure non negligible probability exists adversary produce plaintext encryption 
adversary produce compound term atomic element parse tree compound term outside produced potentially adversary 

probability adversary produce atomic element outside closure negligible 
adversary produce term atomic compound outside closure input non negligible probability 
result theorem stated encryption scheme ideal 
encryption scheme assumption quasi formal attack sequence corresponding sequence formal algebra formal attack attack available dolev yao adversary probability negligibly close 
theorem suppose encryption scheme described theorem 
pr 

env quasi formal corresponding formal attack polynomials suciently large 
cryptography theorem computational adversary produce formal message formal adversary produced 
chapter open problems primary contribution rigorous computational de nition ideal cryptography definition concept poorly understood widely albeit implicitly area formal cryptography 
simply put de nition ideal cryptography says computational adversary receives collection terms synthesize term produced dolev yao adversary 
particular adversary create ciphertext having access able synthesize non negligible probability corresponding plaintext 
idea may related idea plaintext aware encryption due bellare rogaway 
de ne plaintext aware encryption informally encryption property adversary create ciphertext knowing corresponding plaintext 
certainly basic desire motivated great deal construction theorem exact relation plaintext aware encryption ideal encryption investigated 
stronger possible de nitions ideal cryptography possible 
example de nition may possible adversary probability making new term negligible chance making particular term 
reason consider stronger possible de nition chapter 
open problems de nition encryption satis es polynomials pr 

desirable achieve extremely strong de nition clear achievable necessary justify formal model 
possibility allow abilities adversary grow security parameter additional ways 
de nition ideal cryptography de nition running time adversary grows security parameter 
aspects problem remain constant 
particular set terms remains xed respect 
possible weakening de nition allow size grow de nition encryption non uniformly ideal satis es polynomial polynomials jsj pr 

areas desirable extend encompass cryptographic operations secret key cryptography 
may secret key analog ideal public key cryptography identi ed name authenticated encryption connection dolev yao adversary explored 
lastly importantly results contain half picture 
particular results show adversary objective produce legitimate encoding query trace queries responses correspond available dolev yao adversary 
adversary chooses send illegitimate encoding 
adversary reasonably hope gain information plaintext chapter 
open problems encryption honest participants tell strings valid encodings 
similarly regular participant receives encoding message participant expects time 
send error assuming message garbled transit accept 
send error terminate 
simply terminate 
may safe courses action rst glance question deserves deeper examination 
case behavior regular participant indicates error occurred reveals single bit information message adversary 
may sucient break underlying cryptography secure protocols implementations successfully attacked exploitation error conditions 
example demonstrated descriptive error codes provide adversary information launch chosen ciphertext attack widely form rsa 
way honest participants handle errors may undermine security provided cryptography 
address issue analyzing behavior participants depth 
particular environment abstracted away examined detail 
regular participants typically underspeci ed protocol speci cations particularly terms error handling 
important extension formulate characterization honest participant behavior gives adversary advantage gain quasi formal attacks 
assuming termination third case recognized adversary timers 
bibliography mart abadi phillip rogaway 
reconciling views cryptography computational soundness formal encryption 
ifip international conference theoretical computer science ifip tcs lecture notes computer science 
springer verlag 
mihir bellare phillip rogaway 
entity authentication key distribution 
stinson editor advances cryptology crypto proceedings volume lecture notes computer science 
springer verlag 
full version available 
ucsd edu users mihir 
mihir bellare phillip rogaway 
optimal asymmetric encryption encrypt rsa 
de santis editor advances cryptology eurocrypt proceedings volume lecture notes computer science 
springer verlag 
daniel bleichenbacher 
chosen ciphertext attacks protocols rsa encryption standard pkcs 
hugo krawczyk editor advances cryptology crypto volume lecture notes computer science 
manual blum alfredo de santis silvio micali giuseppe 
noninteractive zero knowledge 
siam journal computing december 
dolev yao 
security public key protocols 
ieee transactions information theory 
oded goldreich 
cryptography 
early unpublished version manuscript july 
joshua guttman javier thayer zuck 
faithfulness encryption 
forthcoming 
gavin lowe 
attack needham schroeder public key authentication protocol 
information processing letters 
bibliography gavin lowe 
breaking xing needham schroeder public key protocol fdr 
margaria ste en editors tools algorithms construction analysis systems volume lecture notes computer science pages 
springer verlag 
james manger 
chosen ciphertext attack rsa optimal asymmetric encryption standardized pkcs 
advances cryptology crypto 
silvio micali charles bob sloan 
notion security probabilistic cryptosystems 
siam journal computing april 
john mitchell mark mitchell ulrich stern 
automated analysis cryptographic protocols mur 
proceedings ieee symposium security privacy pages 
ieee computer society press ieee 
roger needham michael schroeder 
encryption authentication large networks computers 
communications acm 
paulson :10.1.1.145.4394
inductive approach verifying cryptographic protocols 
journal computer security 
alfredo de santis giovanni di ostrovsky giuseppe amit sahai 
robust non interactive zero knowledge 
advances cryptology crypto proceedings 
javier thayer jonathan herzog joshua guttman 
strand spaces proving security protocols correct 
journal computer security 
appendix index notation formal sets operators notation sets operations setting formal cryptography appendix index notation entity sends message addressed 
guarantee reaches 
fjm jg message encrypted key concatenation messages formal algebra terms set plaintexts set names subv set names subverted principals set nonces nonces values set adversary nonces values picked randomly honest participants set public keys set private keys keys values set adversary subv keys principals subverted adversary keys chosen bad private keys known adversary subv set keys set encryptions set concatenations private key associated public key ka public key entity closure set pattern sk symmetric key pattern pattern pk public key pattern set keys equivalence expressions equivalence renaming function expressions tags knowledge set subv sj elements parse tree concatenation message created pairing elements canonical order set keys potentially useful analysis appendix index notation computational sets operations notation sets operations setting computational cryptography security parameter polynomial usually function distribution families computationally indistinguishable natural numbers drawn distribution 
set drawn uniformly 
pr probability predicate true key generation algorithm symmetric asymmetric depending context computational symmetric key computational encryption key computational decryption key computational encryption algorithm symmetric asymmetric depending context computational ciphertext computational decryption algorithm symmetric asymmetric depending context key extractor derives public key encryption key parameter set security parameters typically coins set nite random bit sequences publickey set possible public keys set possible private keys ciphertext set possible encryptions string set nite bit strings probability distribution induced chosen randomly uniformly coins 
key set possible secret symmetric keys adversary prover algorithm zk proof veri er algorithm zk proof 
random oracle context proofs theorem proof witness string respectively hm ni contiguous substring starting position position inclusive 
conversion veri er appendix index notation sets operations connect formal computational settings notation sets operations bridge connect formal computational settings distribution induced running convert algorithm family indexed distributions functions formal keys computational keys random element function formal name bit strings set functions bit strings randomly chosen element set functions bit strings element chosen adversary set functions bit strings element chosen adversary init algorithm corresponding needham schroeder initiator initiator responder security parameter instance resp algorithm corresponding needham schroeder responder responder initiator security parameter instance function names public keys function names subverted principals private keys appendix abadi rogaway result public key encryption chapter give proof theorem convert function chapter theorem suppose acyclic expressions 
pattern pk pattern pk 
proof prove hybrid argument 
acyclic order parse tree pm pm graph gm deeper key encryptions smaller number 
write mean private key associated pm keys receive similar notation 
go hybrid argument constructing number intermediate patterns particular construct patterns 

pattern pk mk similarly pattern pk pattern pk pattern pk mk similarly pick key replace encryptions key example suppose fja appendix abadi rogaway result public key encryption djg pattern pattern pk pattern pk order keys suggested notation fja fja djg patterns associate probability distribution bit strings 
probability distributions de ned de ne probability distribution patterns way xed bit string depend 
de ne encryption appropriate computational key coins enc de ne distribution associated pattern recursively chapter 
suppose distributions top bottoms rows table distinguishable 
know hybrid argument consecutive rows distinguishable 
number rows table constant respect 
continue hybrid argument creating new table distinguishable rows 
suppose key rows 
xed number encryptions converted blobs 
example rows fja appendix abadi rogaway result public key encryption expand table fja fja number rows constant respect exist consecutive rows distinguished 
assume loss generality rows distributions build adversary distinguish hh ii allow break semantic security computational encryption scheme 
note general distinguish encryption xed message xed pattern way rst hybrid table constructed know pattern contain encryptions may contain instances trying distinguish encryption xed message hand encryption random variable 
de nition semantic security de nition allows generality 
corollary note message indistinguishable pattern theorem pattern pk 
see di erent ways 
note extend de nition include unde ned pattern pk pattern pk pattern pk alternate proof part proof theorem showed rows rst table indistinguishable 
message pattern pk rows table 
message indistinguishable pattern set keys appendix semantic security recall de nition theorem distribution hm ri hc pi randomness produce hc pi semantically secure encryption scheme 
random oracle string speci non interactive zero knowledge proof knowledge system ciphertext 
recall de nition pass semantic security de nition pass semantically secure ppt algorithms polynomials pr hc pi hc pi appendix semantic security notation mean suciently large prove semantically secure suppose 
assume ppt algorithms polynomial nitely pr hc pi hc pi build algorithms defeat semantic security algorithm simulator proof system 
particular input runs get runs get runs hc pi get lastly returns going 
new adversary uses simulator produce proof indistinguishable real proof 
de nition behavior hc pi computationally indistinguishable hci theorem hpi prover input hc pi computationally indistinguishable input distinguish encryption scheme adversary distinguish encryption scheme 
formal de nition uses bipartite adversary assume returns hc empty string 
