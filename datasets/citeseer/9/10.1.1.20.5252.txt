platform specific optimizations stub code generation andreas university karlsruhe ira uka de july stub code generator greatly reduce effort required implement multi server system top microkernel 
stub code traditionally highly generic slow prevented performance critical applications 
show restriction eliminated specialization underlying platform exploiting specific properties kernel compiler hardware platform 
demonstrate approach example platform microkernel variety optimization techniques improve stub code performance platform 
techniques implemented validated idl optimizing stub code generator 
comparison traditional stub code generators shows idl stubs perform order magnitude better increase application performance percent 
contents contents remote procedure call 
interface definition languages 
related target platform microkernel family 
intel pentium ii processor 
gnu compiler 
optimization simple rpc model 
kernel specific optimizations 
ipc characteristics 
special system calls 
lazy process switching 
hints 
compiler specific optimizations 
direct stack transfer 
inline functions 
compile time evaluation 
annotation 
record partitioning 
extending calling convention 
architecture specific optimizations 
reordering message elements 
function tables 
server side stack switch 
special instructions 
cache aware memory allocation 
usage specific optimizations 
pass 
domain local servers 
annotated data types 
custom presentation 
idl requirements 
design decisions 
corba dce 
idl extensions 
language mapping 
buffer allocation 
architecture 
front 
marshaling stage 
kernel specific part 
contents back 
regression test 
evaluation flick 
dice 
methodology 
microbenchmarks 
marshaling overhead 
application performance 
discussion 
operating systems traditionally designed monolithic structure 
functionality task management scheduling device drivers implemented single entity kernel runs highest privilege level 
approach criticized lack protection kernel component complete control faulty component break unrelated components crash entire system 
multi server operating systems solve problem breaking kernel multiple components executed separate protection domains 
small component microkernel remains highest privilege level implements essential primitives address space management inter process communication ipc performed lower level 
apart robustness gained increased protection approach offers additional flexibility components easily exchanged multiple versions coexist single system 
order perform specific function components may need interact frequently 
execute different protection domains requires ipc directly supported programming languages 
additional code needed handle communication packing data messages sending messages receiving unpacking 
writing debugging large amounts code tedious error prone task 
fortunately tools available generating communication code stub code automatically high level specification 
tools support remote procedure call rpc programmer perspective works exactly ordinary procedure call call procedures protection domain 
similarity rpc integrates programming languages widely today 
apart convenience code generators offer benefits 
provide abstraction underlying communication mechanism hiding unnecessary details programmer 
available platforms code uses easily portable 
due lack type safety hand written communication code hard debug generated code usually reliable need debugging 
stub code performance usually primary goal 
reason rpc traditionally distributed systems connected network overhead stub code negligible communication costs higher orders magnitude 
different modern microkernels high speed ipc primitives available case relative overhead considerable may exceed actual transfer costs 
result communication prohibitively expensive totally unacceptable multi server system 
programmers may tempted base design decisions communication cost birrell nelson pointed rpc performance important lest communication expensive application designers avoid 
approach improves stub code performance specialization underlying platform 
exploit specific knowledge microkernel hardware architecture compiler certain characteristics application code 
demonstrate approach built idl optimizing stub code gener remote procedure call callee caller client request reply server loop server stub domain boundary stub rpc scheme ator microkernel 
experiments show idl generated code perform order magnitude better optimizing code generators performance applications improved 
rest structured follows section describes related distributed operating systems communities 
section gives overview target platform section describes optimizations applied platform 
section design architecture idl optimizing stub code generator 
section shows measured performance idl section presents 
remote procedure call mentioned rpcs mimic semantics local procedure calls natural extension programming languages 
remote procedure executed different domain communication primitive usual stack register call 
caller uses communication primitive send request message callee suspends waits callee respond reply message 
procedure arguments return values included corresponding message 
local case transferred meaning remote domain 
values copied call sender encode marshal message receiver decode 
higher level languages support rpc natively additional code needed handling communication 
code termed stub code serves placeholder actual function see 
client stub marshals arguments sends request message waits reply return values 
counterpart server stub performs inverse operations 
individual server exports multiple procedures clients additional server loop required receives incoming requests dispatches appropriate server stub 
interface definition languages order generate stub code automatically formal specification remote procedures required 
specification contain names procedures parameters complete size direction client server server client 
details properties underlying communication related mechanism left determined code generator 
permits high level abstraction 
variety interface definition languages idl specified purpose 
example interface definition corba idl interface foo typedef sequence buffer short alpha string void beta buffer specification defines interface foo contains procedures alpha beta 
procedure takes string argument returns short integer 
second procedure arguments returns variable number characters 
corba designed interoperability type system idl independent particular platform target language mappings specified ada cobol java lisp pl python smalltalk implemented platforms 
example stub code generator language produce code specification typedef struct long length maximum void data buffer short foo alpha foo obj char void foo beta foo obj buffer 
idls platform specific example matchmaker support ports special data type mach kernel platforms 
related considerable amount dedicated optimize rpc different techniques demonstrated 
section discuss research directions relate 
virtual memory approaches virtual memory primitives optimize transfer large messages 
system uses page remapping efficiently move call arguments results client server address spaces 
dec firefly rpc facility uses global buffer pool resides memory shared user address spaces fbuf scheme druschel peterson buffers shared members related particular data path 
lrpc scheme bershad client server privately shared memory argument passing 
remapping approach uses move copy semantics limited situations client need access data call 
revoking memory address space costly operation modern cpus may require modification translation lookaside buffer tlb 
shared memory compromise security model system 
automatic program transformation tempo system muller source level transformations optimize output existing idl compiler case sun rpc 
tempo applies partial evaluation specialize code compile time removing genericity needed 
micro benchmarks authors measured speedups 
tempo uses existing stub code apply optimizations involve changing transfer algorithm 
clearly shows high overhead caused genericity 
compiled vs interpretive stubs time vs space tradeoff exists approaches interpretive stubs smaller compiled stubs yield better performance 
gokhale schmidt pointed importance small memory footprint embedded systems 
interpretive stubs generated tao idl compiler achieve comparable performance hand crafted compiled stubs relative code size 
hand speed oriented idl compilers flick demonstrated impressive performance compiled stubs aggressive inlining 
huitema suggested hybrid approach decision compiled interpretive estimated cost subsequent solving knapsack combination problem 
presentation osi network model presentation layer handles conversion local data representation network format 
clark tennenhouse conversion responsible total protocol overhead 
malley demonstrate conversion code improved stubs generated code generator usc times faster conventional stubs 
explored possibility customizing presentation adapting application needs 
dce idl interface definition may accompanied separate file application configuration file acf may contain additional attributes controlling binding protocol error condition treatment 
concert system partitions interface specifications network contract relevant interoperability endpoint modifier represents interface stub programmer contract 
ford introduce new presentation attributes changing allocation semantics choosing alternate transfer mechanisms 
target platform combining multiple optimizations build general high performance rpc system single optimization technique sufficient newer idl compilers combine variety techniques 
ford pointed task making optimizations challenging simply finding 
target platform approach maximize stub code performance specializing underlying platform remove genericity needed 
course technique restricted particular platform discussed merely level 
specific environment chosen 
environment consists hardware platform intel pentium ii processor microkernel compiler generate application binaries gcc 
section explains elements detail 
microkernel family microkernel developed jochen liedtke german national research center information technology gmd ibm watson research center 
true microkernel implements minimal set concepts address spaces virtual memory managed external pagers threads activities executing inside address space synchronous message inter process communication ipc priority scheduling hard priorities initially implemented ia ported variety architectures including alpha mips strongarm ia powerpc kernel api revised twice 
chose ia version kernel implements version api 
additionally order cover upcoming api include kernel 
focuses communication mainly discuss ipc kernel primitive omit functions scheduling thread control 
please refer kernel manuals information 
inter process communication ipc synchronous 
means sender receiver ready time partner may blocked waiting 
communication unbuffered intermediate kernel object store messages data copied directly sender receiver 
different message types supported 
simplest register message consists small number values loaded processor registers sender traps kernel 
message type low latency kernel needs perform context switch values remain target platform microkernel family respective registers delivered receiver untouched 
platforms number registers register messages quite small 
message fit registers partly stored memory 
sender collects data contiguous buffer memory message supplies kernel 
ipc kernel copies contents message buffer receiver address space 
possible construct multi part messages extending memory message indirect parts 
indirect part points additional data different memory location copied ipc 
saves copy operation sender side data copied primary buffer causes overhead indirection 
indirect parts large contiguous memory objects 
map message map virtual memory sender address space receiver 
map messages similar register messages memory messages contain send describe regions virtual memory 
map virtual memory primitives may mapped granted see 
page mapped shared sender receiver accessible address spaces sender revoke mapping 
page granted receiver complete control page disappears sender address space revoked 
memory messages indirect parts generally transferred temporary mapping 
buffering messages kernel memory target region mapped temporarily transfer window source address space message copied directly transfer window 
causes additional misses translation lookaside buffer tlb saves copy operation decreases cache pollution 
kernel kernel implements kernel api 
ia means ipc transfers register message bit machine words optionally memory message mb added may contain arbitrary number send indirect parts 
simplest fastest message type intra domain register message register message sent threads address space 
best case overhead cycles cost entering leaving kernel mode context switch sender receiver simple checks 
inter domain messages expensive mapping virtual physical addresses invalidated ia done flushing subsequently tlb 
memory messages indirect parts cause additional overhead creating removing temporary mapping 
target platform intel pentium ii processor introduced optimization intra domain ipc require switch kernel mode certain cases 
optimization overhead reduced approximately cycles 
kernel kernel implements kernel api 
important difference api version support memory messages thread message registers transferred receiver partly entirely may contain indirect parts send 
architectures cpu registers may virtual backed memory 
experimental kernel performance numbers currently available 
expected medium sized messages transferred considerably faster longer necessary establish shared mapping 
stub code microkernels ipc primitive offered current microkernels flexible 
stub code generator usually choose multiple different ways implement particular message transfer 
choice important significant impact performance example considerably efficient transfer large data structure multi part message simple memory message 
stub code generator provide support different kernel api versions 
research project highly dynamic changes api major revisions issued 
stub code generator provide abstraction layer isolate application code smaller changes time new features improve performance 
intel pentium ii processor focus pentium ii successor pentium iii pentium available project started 
processors common currently desktop pcs 
pentium ii implementation intel bit architecture ia cisc style instruction set 
internally cisc instructions broken simple operations called micro ops ops issued risc style execution core pentium ii combine excellent code density high execution speed 
cisc instructions thoroughly optimized complex instruction slower equivalent sequence simple instructions 
see details 
optimizing application code pentium ii important consider points high memory latency 
high clock speed accessing main memory extremely expensive cache efficiency limiting factor 
chip die instruction data caches kb additional second level cache kb module way set associative byte cache lines 
optimization gnu compiler small register set 
ia general purpose registers including stack pointer base pointer 
compilers forced generate spill code free registers moving values memory reload 
branch prediction 
order increase efficiency pipelined core pentium ii attempts predict conditional branches tentatively fills pipeline path 
misprediction occurs entire pipeline flushed 
points important release pentium memory latency comparably higher due clock speeds ghz longer pipeline stages twice length pentium iii pipeline 
believe optimization techniques applicable chip 
properties pentium ii architecture translation lookaside buffer tlb directly relevant 
stub code generator produces code higher level language compiled separately control low level features cpu 
gnu compiler gnu compiler gcc chosen widely support variety platforms 
suited low level system code powerful interface inline assembly important system calls 
gcc poor optimizer match performance proprietary compilers intel 
encountered problems releases ranging occasional crashes incorrect code 
optimization section various methods optimizing generated stub code methods implemented validated idl optimizing idl compiler section 
basic claim best performance obtained specialization target platform 
possible code generator detailed information particular kernel system run particular compiler particular architecture target machine particular usage pattern application code targeted multi server operating systems distributed systems assume interoperability required client server run machine kernel stubs compiled idl compiler 
reason assume messages damaged optimization simple rpc model lost underlying transport mechanism case ipc 
restrict static invocation interfaces known compile time 
permits fixed message layout eliminates need tagging message elements 
goal maximize application performance increase execution speed variety criteria equally applied 
embedded system example small memory footprint low power consumption may preferable security system require maximum confidentiality 
different goals certainly result different optimizations general approach 
simple rpc model introduce simple model remote procedure calls 
model section explain particular optimization applied 
assume client invokes remote method supplied server 
parameters characterized parameters passed client server parameters sent back client inout parameters combination 
order perform call client marshals inout parameters sends resulting message server waits reply 
reply arrives inout parameters resumes normal execution 
detail client stub pass input values stub code transfer control allocate sufficiently large message buffer marshal inout parameters add identifier send resulting message server wait reply check error conditions may occurred inout parameters release storage occupied message buffer return output values resume execution server side request received server loop dispatched appropriate stub 
detail server loop wait request message arrive extract method identifier determine appropriate stub pass request message stub transfer control reply message returned send back client receives request server stub inout parameters passes completes marshals inout parameters prepares reply message sent back client 
detail server stub inout parameters pass resulting values transfer control check error conditions may occurred marshal inout parameters create reply optimization kernel specific optimizations kernel specific optimizations mentioned microkernel platform consists different implementations kernel interface exists major revisions different hardware platforms supported including alpha ia ia strongarm mips powerpc platforms special support different cpu versions 
example ia platform distinguishes pentium pentium ii iii pentium 
special kernels support new features small address spaces local ipc diversity relevant stub code generators ways 
features supported kernels code generator conservative target kernel known 
second feature may different characteristics different implementations api 
example consider ipc mechanism 
due flexibility usually multiple different ways transfer particular message tradeoff different implementation 
target kernel known performance improved choosing efficient option call 
ipc characteristics kernel interfaces provide basic methods copying data ipc 
small fixed number machine words transferred directly registers additional data put memory message copied receiver address space 
buffer may contain indirect parts logically part message need copied buffer 
obviously tradeoff exists memory messages indirect parts 
save copies message buffer require address space manipulations temporary mapping cause increased overhead 
illustrates fact kernel small messages machine words simple memory message efficient tradeoff exists small messages 
data fits entirely register message machine words memory message omitted may necessary multiple smaller values share register 
overhead packing unpacking values considered usually small 
special system calls kernels support way invoke ipc system call 
example generic calls coexist special calls optimized certain scenario portable call methods supported version hardware specific methods 
calls supported kernels single call method performs best messages 
idl compiler round trip ipc hot caches dual pentium ii second ipc short optimization kernel specific optimizations direct indirect ipc kernel specific knowledge choose call variant deliver best performance 
example supports int instructions trapping kernel 
faster works pentium ii newer processors pentium 
part official kernel abi implementations pip fiasco support 
conservative code generator slow call times optimizing code generator kernel specific knowledge choose available 
note optimization trades portability performance 
code optimized previous method runs kernels slightly slower stub uses pentium machine pip kernel 
serious restriction portability binary code affected binaries platforms easily generated recompiling stub code 
similar optimization possible version abi implemented 
specifies system calls invoked special machine instruction indirect call kernel interface page kip 
code generator allowed inline call reduce overhead result improved stub code performance 
lazy process switching lazy process switching optimization frequent intra domain communication allows callee run context caller time saving cost context switch 
principle part interface implemented experimental variant kernel 
special system calls local ipc available switching lazily sender receiver 
experiments show primitive boost rpc performance add overhead improperly nonlocal calls 
means code generator drastically improve performance knows target kernel supports assume calls local 
see section discussion 
optimization compiler specific optimizations hints new interface introduces mechanism improve cache efficiency 
ipc application supply hints kernel prevent allocating cache lines lower levels disable caching entirely certain message elements 
possible transfer large message elements flushing entire cache 
fact feature highly platform dependent ideal candidate stub code optimization unclear code generator guess suitable cache policy 
promising method user specified attribute part acf problematic hint specified sender side receiver processes data benefit custom caching strategy 
compiler specific optimizations stub code generators produce code higher level language 
compared object code binary code approach advantage keeping stub code generation separate main compiler stubs easily integrated application code 
stub code generator little influence final machine code code quality largely depends optimizations done main compiler 
stub code generator lot freedom particular effect usually achieved different ways example program unrelated statements reordered different language constructs switch multiple ifs chosen 
detailed knowledge compiler available code generator take advantage choosing implementation results efficient code 
gcc compiler analysis largely gcc specific 
assumptions may hold architectures ia example ia stack calling convention 
similar approach taken compiler 
direct stack transfer remote procedure call method invoked input parameters need passed client stub step stub code model 
possible implementation conventional function call creates activation record stack 
similar operation performed server side procedure called parameters pushed stack activation record client side recreated 
marshaling steps apparently equivalent op 
possible omit marshaling steps entirely 
client simply send activation record server procedure called directly see 
shown approach leads extremely efficient code simple procedures certain implementation issues output parameters problematic input parameters usually passed 
activation record contain pointers meaningless callee address space 
optimization compiler specific optimizations arg arg arg arg arg arg ptr ptr inout arg arg inout arg client server direct stack transfer problem solved ways 
send activation record including meaningless pointers overwritten correct values server side 
remove pointers client side server add 
implemented efficiently reordering arguments pointers pushed lower part stack frame needs sent 
indirect strings easily corresponding descriptors appear memory message 
stack necessary space occupied activation records 
short messages fully optimized calling convention requires arguments passed stack 
short messages desirable keep values registers pass directly ipc system call 
issues solved inline assembler code client side compiler generated function call 
enables code generator alter layout activation frame easily omit pointers reserve space indirect parts keep values registers 
server side minor changes may required pointers output values added client minimize changes choosing appropriate message layout 
str str ptr str str header function id caller id return value header stack top message layout shows recommended message layout uses overlapping buffers optimization see section 
client pushes inout values followed values function id message header step ensuring free space remains receiving output message 
server allocates optimization compiler specific optimizations space output values directly adds pointers imitate pass step 
call discards pointers input values sends remaining message back client step 
inline functions higher level language function calls costly operations 
caller pays high overhead costs push arguments stack save context create new context callee transfer control 
return dispose callee context restore acquire return values 
additionally indirect costs due fact compilers apply optimizations function calls especially function globally visible possible determine contexts called common optimizations partial redundancy elimination pre common subexpression elimination cse usually limited individual basic blocks 
call related overhead eliminated inlining code substituting individual function call 
possible way macro declare function inline compiler perform substitution 
large functions tradeoff exists execution speed code size code may cause instruction cache efficiently 
stub code usually small 
inline stub mov var eax caller invokes stub var add eax push eax argument passed stack call stub stub push ebp establish new context mov esp ebp mov ebp ebx load argument ebx ipc invoke ipc simplified mov ebp esp pop ebp ret inline stub mov var ebx load argument directly ebx add ebx stub var called ipc invoke ipc simplified 
inline stub code example shows example 
lower function inlines stub code compiler eliminate call instruction entry exit code 
inlining especially important system calls parameters ipc 
application load parameters address callee pointers global knowledge available problem alleviated cross procedural optimization 
supported gcc 
optimization compiler specific optimizations message buffers registers traps kernel results returned registers call 
system call code separate function register allocator compiler know constraints argument values may reside activation record entirely different registers may partly spilled memory 
causes additional overhead avoided inlining system call code calling function 
compiler avoid spilling argument values correct registers place 
effect observed ebx register 
inlining argument value loaded different register eax passed stack inlining case correct register 
compile time evaluation generated code usually general required 
example may contain functionality may check error conditions null pointers occur 
theoretically prevented adding details specification case interface definition add lot complexity practicable 
fortunately compiler detect situation specialize corresponding code remove parts entirely 
resulting machine code correct done possible prove certain condition occur 
generated code avoid constructs proof impossible 
example gcc unable data flow analysis records larger bits 
record condition checking exceed size 
annotation optimizing compilers perform extensive code analysis gather information possible choose promising optimization 
approach limited 
example code may contain fast paths paths frequently taken certain conditions occur 
compiler improve performance optimizing common case hard statically determine program 
information known programmer knows details underlying algorithm intended code 
newer versions gcc provide language extensions annotation 
example builtin expect function indicate result expression determines fast path hints builtin prefetch data probably referenced soon 
attribute applied function known return contains infinite loop code left way means inline jump instruction 
stub code generator extensions knows highlevel algorithm code generates 
example assume exceptions occur rarely fast path exploit prefetching knows exactly order data referenced 
optimization compiler specific optimizations record partitioning record data types structs require large marshaling effort order preserve internal structure element marshaled individually 
client server representation particular memory layout record treated opaque array bytes copied en bloc memcpy special machine instructions see section 
technique efficient record contains data types need special marshaling scalars 
applied case special elements marshaled separately 
requires additional buffer space increases transfer costs may outweighed efficient copy operation 
special elements sparse record divided multiple regions containing flat data types copied separately 
exact representation record endpoints important members reordered special elements grouped remaining elements copied efficiently 
records contain memory holes inserted compiler alignment 
record marshaled en bloc holes removed resulting message larger 
experiments show element level marshaling extremely expensive optimization works cases 
endpoint representation changed holes eliminated sorting elements alignment size 
extending calling convention described section inlining eliminate overhead function call 
gcc apply optimization function inlined appears call translation unit code file associated header files 
issue client stubs put header file included necessary 
server side calls method steps stub model full inlining require stubs method implementations appear single file certain order impractical 
solution inline calls implement traditional function call 
standard function call follow calling convention caller context saved parameters passed stack kept registers 
situation gcc offers attribute applied function ia causes parameters passed registers 
sufficient different registers required possible inline assembler code implement custom call 
cases region record contains special element reused marshaling example space bit pointer transfer bit value points restriction removed newer versions gcc optimization architecture specific optimizations architecture specific optimizations section mentioned style kernels available hardware architectures ia strongarm powerpc 
architectures differ ways qualitative supporting different features predication data speculation smt quantitative differently sized caches instruction register sets 
exploiting architecture specific features code quality drastically improved 
type optimization domain main compiler scope stub code generator 
compiler apply optimizations preserve low level semantics code stub code generator follow specification higher level interface definition 
doing free choose algorithm likes 
freedom optimization details hardware architecture available 
ia architecture see section 
important features respect optimization particularly small register set general purpose registers high penalty mispredicted branches high memory latency 
see details 
reordering message elements due high memory latency advisable avoid copies server side unmarshaling input values directly message buffer see sections 
means step reply message created inout values inout values may copied new buffer 
additional overhead avoided sorting message elements direction collecting inout values side buffer 
fortunately interfaces allow separate send receive buffers possible overlap marshal inout values situ 
inout message layout shows resulting message layout 
request message inout values collected message buffer 
lower part buffer contains input values simply dropped reply part overwritten header reply message 
indirect parts reordered similar fashion may necessary adjust size message buffer case kernels locate indirect part 
similar technique heap zahorjan lrpc implementation mach 
optimization architecture specific optimizations function tables important task server loop distribute incoming requests appropriate server stub step 
process method identifier checked resolved stub address 
done sequence conditional branches decision tree large number mispredictions occur method identifiers successive calls usually related 
possibility method identifier index function table single memory access sufficient perform entire operation 
course bounds checking required done enlarging table power filling unused entries address error handler 
simple operation strip irrelevant bits 
gcc usually generates function tables dense switch statements method identifiers sparse custom implementation may preferable advantage giving user control table implementations changed runtime 
tradeoff exists large function tables call performs better data cache working set grows may lead hidden costs 
server side stack switch limitations small register set apparent case server stubs 
order input values server stub needs know address message buffer 
possible buffer fixed memory location desirable example resulting stub multithreaded server 
alternative pass buffer address argument stub due frequent occupy valuable register 
possible save register stack pointer 
fashion similar direct stack transfer see stack pointer moved message buffer subsequently message elements compiler changes allocate spill buffers local variables 
approach compiler treat message buffer argument update relative position moves stack pointer 
achieved defining record data type covers message buffer declaring stub argument type 
consider example struct buffer unsigned fid short char void stub struct buffer 
stub function entered compiler assumes caller pushed buffer record stack element fid position esp 
generated code move stack pointer bottom gcc sequence conditional branches generated case values threshold case labels usually value range times bigger number values optimization architecture specific optimizations message buffer call stub function arguments desired effect 
approach obviously trades performance code readability alters calling convention 
data cache working set grows original stack 
special instructions extensive instruction set ia contains complex instructions rarely generated gcc 
code generator knows instructions improve performance insert hand inline assembly 
example approach applied predicated move 
introduced instruction avoid conditional branches 
gcc generates march flag specified reliably 
rep fast memory copy 
suitably aligned data dramatically improve performance operates directly cache lines 
rep memory scan search certain bit pattern 
instruction determine length string 
rep instruction particularly interesting efficiently move large data structures marshaling 
cache aware memory allocation years widening gap processor speed memory speed observed 
dramatically increased importance caching mhz pentium ii mhz single bank sdram memory latency exceed ns equivalent cpu cycles execute instructions 
efficient cache usage crucial application performance 
modern microprocessors pentium ii separate data instruction caches data cache consists cache lines bytes total capacity way set associative 
apart initial costs filling empty cache types faults occur capacity misses due limited size cache conflict misses due limited size set 
code generator little conflict misses instruction cache affect placement machine code capacity misses reduced generating smaller stub code tradeoff exists see 
data cache misses generally reduced cache lines efficiently bundling local variables increase chance fit single line aligning message buffers cache line boundaries 
furthermore memory allocated dynamically conflict misses avoided ensuring greatest common divisor cache size allocation size small 
newer chips rep optimized rep tight loop performs better optimization usage specific optimizations usage specific optimizations default stub code generator assumptions stubs function calls go server time arguments specification allows result 
practice stub code seldom arbitrarily example call looking person name phone directory usually called name string characters seldom characters definitely happen supported 
application contain thread implementing semaphore corresponding methods called outside address space stub code support 
additional knowledge stub code optimized ways specialized removing functionality optimized common case cases supported possibly efficient 
advisable include kind information interface definition spoil abstraction provided separate file acf 
pass default request message rpc contain information required execute procedure server 
particular means pointers dereferenced resulting values copied complex data structures lists trees may involve recursion 
resulting request message may large 
caller callee machine may choose shared memory common data case pointer meaningful callee copied directly 
information passed stub code generator marking method entire interface local 
pass particularly useful single address space operating systems address space shared applications pointers meaningful 
parameters copy semantics may required 
domain local servers optimizations possible caller callee run address space 
unusual example applications separate thread memory management control thread coordinating multiple worker threads dedicated thread critical section 
addition pass code generator exploit fact parties implicitly trust example omit security checks 
special system calls available see section 
annotated data types stated parameters fully exploit value range permitted data type values appear frequently optimization usage specific optimizations appear 
information supplied code generator optimization example maximum size principle idl data types sequences strings arbitrary size 
additional information available stub code provide worst case allocate large buffers ipc variants limited data sizes virtual registers 
typical size arguments strings arrays typically shorter maximum size 
typical size known code generator optimize expected case choose direct copy indirect parts see section partial redundancy arguments type scheme idl may coarse 
consider integer divisible lower bits implicit need transferred 
limited region large array may interest rest omitted 
custom presentation transit representation particular data type freely chosen eliminate partial redundancy consistent client server stubs ensured server understand request messages client 
different data representation particular communication endpoint specific client task 
representation visible externally may different instance chosen suit application needs 
example represent string sequence characters trailing zero variable sized array separate length 
language corba language mapping uses representation stub code second representation convenient copy string efficiently memcpy length known 
application code stub code need know length string absurd situation occurs length discarded immediately retrieved expensive call strlen 
avoided choosing second representation length attribute dce 
example buffer allocation policy especially output values 
buffer space allocated application code dynamically stub code 
dynamic allocation efficient variable length arguments buffer allocated call actual length known compared static buffer additional overhead allocation deallocation additional copy may required data specific memory location 
problem solved introducing special attribute choosing allocation policy case case basis see 
note properties previous section attributes discussed specified interface definition different instances different choices 
kept separately acf 
idl idl substantiate claims idl idl compiler platform 
idl produces stub code current kernel interfaces see section implements optimizations discussed previous chapter 
section discusses requirements resulting design decisions gives short overview idl architecture 
requirements apart maximizing stub code performance idl meet additional requirements portability 
design part compiler platform specific rewritten new target platform 
keep effort minimum possible reuse code possible 
ease 
primary justification automated stub code generators convenience 
tool complicated error prone requires 
maintainability 
designed research environment tool moving target additions changes occur frequently 
architecture support changes possible verify break existing code 
design decisions corba dce stub code generators mig provide custom interface definition language 
gives opportunity tailor language needs example special data types introduced programmer control certain implementation details 
danger introducing limitations design flaws detected users required learn entirely new language 
decision existing idl standard corba idl dce idl 
languages unique advantages corba idl offers interface inheritance proper exception handling 
high level abstraction independent particular programming language dce idl allows specification attributes control various implementation details attributes kept application configuration file separate interface definition 
syntax idls quite similar fulfils requirements decided support 
users choose primary language features appropriate 
idl design decisions idl extensions vm primitives map see section handled ipc desirable support stub code generator 
new data type added idl 
maps kernel specific data type contains describes region memory send base necessary ipc permissions read write execute transfer mode map parameters encapsulated allow api independent applications 
manipulated means helper functions provided kernel 
idl compilers platform idl support special data type indirect parts 
believe decision indirect parts idl compiler knows details target platform see 
contrast mapping indirect parts semantically different memory messages distinguished interface definition 
number dce style attributes added idl typ size max size specify typical maximum sizes variable length argument string local applied interfaces invoked locally domain relevant bits may scalars full value range packed efficiently caches designate caching policy user request idl specification relaxed allow flat unions 
flat union discriminator value may contain members special semantics pointers 
copied maximum size 
similar microsoft include import directives added 
causes special header file included target code import data type definitions ordinary style headers 
contrast idl import headers contain complex definitions code simply ignored 
data type corba idl implemented sense tagged message format 
memory messages indirect parts copy semantics difference placement buffer idl architecture language mapping apart idl language mapping required specifies relationship idl definitions stub code generated 
choice create custom language mapping adapt existing 
decided corba language mapping proven concept variety implementations 
idl tries adhere standard possible especially client side point performance suffer 
fortunately specification gives implementers freedom defining certain data types partially opaque 
buffer allocation variable length output parameters need special handling input parameters size unknown call time 
situation handled different ways 
caller statically allocate buffers advance maximum argument size expects supply buffers stub 

stub allocate buffers dynamically call actual argument size 

caller stub provide buffers case case basis 
method usually results waste memory due second method involves additional copy possible receive message directly buffer 
caller may need data certain virtual address causes copy 
corba language mapping uses dynamic allocation 
reasons stated decided additionally support static allocation 
user change global policy compiler flag attributes override individual arguments 
purely matter presentation affect actual interface 
architecture flexibility important design goal chosen modular architecture 
compiler consists major parts see front reads interface definition performs syntactical semantical analysis 
result language independent representation interface 
marshaling stage transforms interface series marshal operations 
creates stub code mapping marshal operations target language 
kernel specific part encapsulates details ipc mechanism 
creates message layout produces message related code copying elements message invoking ipc 
back writes stub code output file 
idl architecture corba idl dce idl corba language mapping ast kernel specific test idl architecture parts interact defined interfaces possible replace independently 
multiple part coexist chosen runtime compiler flags 
front currently front ends available combined corba dce idl front front code type import discussed 
idl front consists scanner parser analyzer 
scanner transforms input file stream tokens parser applies grammar analyzer resolves checks consistency 
result syntax tree ast contains information input file higher level abstraction designed sufficiently general idls mapped 
tree passed marshaling stage 
marshaling stage marshaling stage central part idl determines transfer algorithm implemented actual stub code 
specific particular language mapping independent kernel api idl 
step build intermediate representation input 
procedure defined interface determines arguments marshaled creates sequence marshal operations ops 
ops longer specific particular data type example copy certain chunk memory scan memory area value zero map 
multiple ops created single argument record containing pointer dependencies array size 
second step create message layout requires interaction kernel specific part 
op allocate number message elements see 
placement elements mapping specific kernel primitives influenced stage 
third step actual stub code produced 
op implemented pieces code marshaling unmarshaling client server side combined message handling code kernel specific part 
result ast target language case 
idl architecture stub code written directly output file ast considerably flexible 
kernel specific part kernel specific part provides abstraction ipc mechanisms different kernel versions different architectures 
marshaling stage exports generic interface supports fixed size copy chunks fcc length known compile time variable size copy chunks vcc length determined runtime map chunks fmc cause region virtual memory mapped receiver elements grouped connections usually correspond individual procedures 
connection describes set messages exchanged client server request reply exception reports 
message kernel specific layout computed style kernels placed registers possible memory message 
mapped memory messages indirect parts depending typical size 
placement fixed api registers memory message followed delimiter 
style kernels message registers normally 
capacity exceeded memory message emulated 
placed memory message may memory message 
created dynamically 
marshaling stage needs kernel specific code various points send receive messages access individual message elements 
code provided kernel specific part 
request delivers ast subtrees marshaling stage transformed integrated remaining stub code 
back back responsible writing actual output compiler consists header files code files 
accepts ast marshaling stage traverses simply prints corresponding code tree node 
additionally supports modification transformation ast subtrees occasionally required 
regression test order verify maintain correctness compiler regression test included 
invoked special command line flag compiler produces addition stubs entire application run stand top microkernel 
application sets server task invokes methods interface definition performing checks invocation evaluation direction arguments initialized random values checked transfer alignment size message elements checked user defined exception tested side effects monitored stack overruns memory leaks invalid pointer compiler includes interface definition relevant test cases 
evaluation evaluate impact optimizations compared idl generated stubs stub code generators support platform dice adapted version flick 
flick flexible idl compiler kit flick developed eide university utah 
flick designed toolkit reusable components easily adapted different idls language mappings transport mechanisms 
flick implements number powerful optimizations ranging efficient memory management code inlining fast data copying 
generated stubs times faster stubs produced idl compilers 
uhlig adapted flick platform 
version front corba idl uses corba language mapping specific extensions example special data types indirect parts introduced 
supports versions kernel api 
dice drops idl compiler dice developed ronald aigner part dresden real time operating system drops project 
contrast flick dice adapted version generic idl compiler designed specifically platform take full advantage ipc transport mechanism 
additionally applies various generic optimizations example message elements may reordered packed order generate efficient copy operations 
dice understands corba idl dce idl generate code versions api 
addition rpcs dice supports message passing feature evaluated 
methodology initially evaluate stub code performance determine round trip cost typical remote procedure calls 
account indirect costs due cache tlb pollution different call types domain local intra domain measure best case domain local call hot caches worst case evaluation microbenchmarks cross domain call complete cache flush 
additionally count number instructions executed call gives estimate complexity generated code 
second experiment determine marshaling cost element measuring calls variable number arguments 
best worst cases evaluated total cost compared pure ipc overhead cost ipc transferring amount data marshaling dispatching 
evaluate impact stub code quality application performance 
cite results earlier version idl tested multi server operating system 
stub code generator component physical file system pfs switched flick idl performance compared intensive benchmark 
microbenchmarks experiment determine round trip cost kernel typical remote procedure calls long tiny long simple function handle needs passed worker thread local domain 
single argument fits easily register message simple marshal possible generate efficient stub code call 
idl function tested local keyword domain local server see section 
long small short long short function taken device driver interface commit requests 
small number arguments transferred registers reordered packed 
long large long long long long long long function equivalent start function task server interface requires simple marshaling operations transferred registers 
void string long long designed resolve name handle function takes complex argument zero terminated string 
stub code determine length string scanning trailing zero marshal copy message buffer 
long large long stub code function marshal argument type large large record struct large long short evaluation microbenchmarks char short long char struct tag short char long short record contain pointers special data types require marshaling elements copied directly 
void length char str length char str long long function copies large variable length arrays client server 
length element stub code easily indirect parts 
supplied hints compiler type flick ref attribute dice indicate arrays large 
compiled idl specification current version idl compiler idl dice version flick optimizations enabled available 
resulting stub code added test application compiled gcc mode flags march frame pointer run dual pentium ii system current kernel uniprocessor version debugging tracing enabled 
test application sets server executes rpcs tight loop time stamp counter tsc performance counters measurements 
call invoked times invocation determined total number cycles spent number cycles kernel mode number instructions 
check quality measurements compared quantiles typically differed 
average values 
domain local variant tiny evaluated user level implementation local ipc 
equivalent implementation described contain kernel fix code 
unfortunately dice produce correct code rpcs 
generated stub small marshal parameters stub unnecessarily called strlen determine length string 
stub compiled gcc treat arrays scalars 
reason remaining functions measured dice 
instruction count shows results instruction count 
seen flick stubs need times instructions idl stubs dice factor evaluation microbenchmarks dice idl dice idl dice idl idl ipc overhead idl flick flick flick flick flick idl local flick idl tiny small large user level instruction count approximately 
function exception length string argument determined tight loop iteration loop counted separately 
domain local variant tiny lower instruction count generic call implements fewer security checks uses local ipc results simpler stub code 
best case cost rpc lowest call domain local code data cache 
measured best case repeatedly invoking calls domain local server kernel flush caches tlb intra domain ipc calls get maximum benefit caches 
results shown cycles spent kernel shown darker color 
tiny call see slightly higher kernel overhead flick reason flick uses int call method faster 
local ipc kernel overhead lower ipc code executed user level extra cost entering leaving kernel mode removed 
results small clearly show effect register packing see section 
idl stub uses single bit machine word transfer bit values register message considerably expensive memory message flick 
huge differences due way records marshaled flick 
idl uses simple memory copy move entire record message buffer flick marshals member individually 
worst case worst case measurements changed benchmark ways client server executed separate domains second caches tlbs flushed call server side implementation rpc large cache footprint overhead may higher part kernel ipc code may evicted caches request reply 
test rpc implementations return immediately perform 
evaluation marshaling overhead dice idl dice idl dice idl idl ipc overhead flick idl flick flick flick flick idl local idl flick tiny small large best case performance dice idl dice idl dice idl idl ipc overhead flick idl local idl flick flick flick flick flick idl tiny small large worst case performance shows results 
contrast best case measurements higher kernel overhead int 
possible reason cache footprint code path larger 
marshaling overhead second experiment varied number arguments rpc order determine marshaling overhead element 
specifically measured round trip costs rpcs simple arguments bit words 
best worst case tested 
results shown comparison included cost ipc size pure setup transfer cost marshaling 
especially case flick caused cache effects conflicts kernel user code 
seen flick dice higher fixed overhead idl possible reasons include additional complexity server loop buffer management allocation deallocation memory messages 
element marshaling unmarshaling cost higher determined gradient 
evaluation application performance cycles rpc dword arguments flick best case dice best case idl best case ipc best case dword arguments flick worst case dice worst case idl worst case ipc worst case variable number arguments application performance illustrate effect improved stub code application level performance cite results earlier 
experiment idl generate stub code project 
linux derived multi server os physical file systems pfs file buffer cache device drivers network stack vm subsystems anonymous memory implemented user level servers communicate ipc stub code generated idl compiler 
evaluation flick idl generate stubs ext pfs implements physical file system derived ext file system linux 
resulting system run pentium iii mb main memory mb ide disk drive file system performance measured benchmark 
benchmark begins writing file kb reads contents twice 
second read phase requests fulfilled page cache phase completely processing bound disk bound 
re read throughput linux flick stubs idl stubs kb kb kb kb table throughput standard deviation benchmark measured re read throughput read kb file data read request 
table presents performance results reported consecutive iterations 
idl improves throughput approximately time kb read request decreases re read costs dominated data copy costs result explained significant improvements stub code 
discussion corba idl provides rich type set combined variety ways form virtually infinite number rpcs 
performance generated stub code depends factors surrounding code calling context values arguments 
systematic investigation stub code performance hard rpcs may small basis making statements performance general 
results show idl stubs consistently complex stubs generated flick dice fixed overhead element cost lower 
idl stubs tested times faster corresponding flick stubs domain local servers observed speedups order magnitude 
flick dice optimizing idl compilers improvement explained special platform specific optimizations applied idl experiments show stub code performance considerable impact application level performance 
comparison idl stubs shows original system achievable performance lost generated code unacceptable 
optimizations idl overhead reduced significantly 
stub code generator greatly reduce effort required implement multi server system 
stub code traditionally highly generic slow prevented performance critical applications 
shown limitation eliminated optimizing stub code target platform 
variety optimization techniques improve performance intel ia platform microkernel believe similar techniques applied platforms 
implemented validated techniques idl optimizing idl compiler 
idl applies platform specific optimizations due modular structure easily adapted platforms 
compared traditional optimizing idl compilers idl stubs improve performance order magnitude 
availability complete idl source code documentation available idl home page www ka org projects idl 
supervisor uhlig support helpful feedback kevin marcus horst stefan fruitful discussions 
special go uwe answered questions get impatient asked 
ronald aigner 
development idl compiler micro kernel components 
diploma thesis dresden university technology sep 
joshua auerbach james russell 
concert signature representation idl intermediate language 
acm sigplan notices aug 
brian bershad thomas anderson edward lazowska henry levy 
lightweight remote procedure call 
proceedings th acm symposium operating systems principles pages 
acm press dec 
andrew birrell bruce jay nelson 
implementing remote procedure calls 
acm transactions computer systems tocs 
john zahorjan 
implementing lightweight remote procedure calls mach operating system 
technical report tr university washington department computer science engineering feb 
david cheriton 
distributed system 
communications acm 
david clark david tennenhouse 
architectural considerations new generation protocols 
proceedings acm symposium communications architectures protocols pages 
acm press sep 
intel 
intel architecture optimization manual 
order 
peter druschel larry peterson 
fbufs high bandwidth cross domain transfer facility 
proceedings th acm symposium operating systems principles pages 
acm press dec 
eric eide kevin frei bryan ford jay lepreau gary lindstrom 
flick flexible optimizing idl compiler 
proceedings acm sigplan conference programming language design implementation pages 
acm press jun 
bryan ford mike hibler jay lepreau 
separating presentation interface rpc idls 
technical report uucs university utah dec 
bryan ford mike hibler jay lepreau 
annotated interface definitions optimize rpc 
proceedings th acm symposium operating systems principles page dec 
open software foundation 
osf dce application development guide 
prentice hall 
alain trent jaeger park jochen liedtke kevin uhlig jonathon luke lars 
approach 
proceedings th acm sigops european workshop sep 
gokhale douglas schmidt 
principles optimizing corba internet inter orb protocol performance 
proceedings st hawaiian international conference system sciences jan 
gokhale douglas schmidt 
techniques optimizing corba middleware distributed embedded systems 
proceedings infocom pages 
ieee mar 
object management group 
corba specification 
www omg org cgi bin doc formal 
object management group 
corba language mapping 
www omg org doc formal 
andreas jochen liedtke park lars uhlig 
stub code performance important 
proceedings workshop industrial experiences systems software pages oct 
heiser kevin stephen russell jerry 
distributed single address space operating system 
proceedings th australasian computer science conference pages jan 
philipp christian huitema 
automatic generation optimized code marshalling routines 
manuel medina nathaniel borenstein editors international working conference upper layer protocols architectures applications pages 
elsevier jun 
hermann michael jochen liedtke sebastian 
performance kernel systems 
proceedings th acm symposium operating systems principles pages 
acm press oct 
david johnson willy zwaenepoel 
high performance rpc system 
software practice experience 
michael jones richard rashid 
mach matchmaker kernel language support object oriented distributed systems 
proceedings st conference object oriented programming systems languages applications pages 
acm press nov 
jochen liedtke 
improving ipc kernel design 
proceedings th acm symposium operating systems principles pages 
acm press dec 
jochen liedtke 
lava nucleus ln manual 
www ka org mar 
jochen liedtke 
nucleus version manual 
www ka org sep 
jochen liedtke horst 
lazy process switching 
proceedings th workshop hot topics operating systems hotos viii pages may 
gilles muller volanschi renaud marlet 
scaling partial evaluation optimizing sun commercial rpc protocol 
proceedings acm sigplan symposium partial evaluation semantics program manipulation pages 
acm press jun 
william 
file system benchmark 
available www org 
sean malley todd proebsting allen brady 
usc universal stub compiler 
proceedings conference communications architectures protocols applications pages 
acm press sep 
michael schroeder michael burrows 
performance firefly rpc 
proceedings th acm symposium operating systems principles pages 
acm press 
ka team 
experimental kernel manual version 
www ka org feb 
uhlig 
micro kernel file system development environment 
technical report tr ibm watson research center oct 
horst 
design implementation fast local ipc microkernel 
study thesis university karlsruhe jul 

