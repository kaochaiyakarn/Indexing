functional programming january fl cambridge university press ml ada strongly typed language interoperability source translation andrew tolmach pacific software research center department computer science portland state university box portland usa email apt cs edu dino oliva pacific software research center department computer science engineering oregon graduate institute walker road box portland usa email oliva cse ogi edu describe system supports source level integration ml functional language code ansi ada code 
system works translating functional code type correct vanilla ada offers simple efficient type safe inter operation new functional code components legacy third components 
translator represents novel synthesis techniques including user parameterized specification primitive types operators removal polymorphism code specialization removal higher order functions closure datatypes interpretation aggressive optimization resulting order code viewed encoding result closure analysis 
programs remain fully typed stage translation process simple standard type systems 
target code runs speeds comparable output current optimizing ml compilers handicapped conservative garbage collector 
functional languages fls ml haskell provide powerful high level control mechanisms symbolic data types available traditional third generation languages gls ada modula 
example easier define iterate list ml high level features supported part air force materiel command contract 
author supported part national science foundation ccr 
portion previously author workshop types compilation title combining closure conversion closure analysis algebraic types 
current address bell laboratories rm mountain ave murray hill nj usa 
tolmach oliva fls suited rapid prototyping stand applications 
real world applications need take advantage existing base legacy code written imperative gls 
reasonable aim enable programmers fl write glue code combines existing gl code components write fl components integrated larger gl systems 
unfortunately fl implementations typically give programmer control detailed layout lifetime data usually assume special purpose runtime system characteristics impede interfacing foreign languages 
foreign function interfaces address problems common leroy peyton jones tofte tend disadvantages moving data languages typically requires expensive fly format conversions tricky cast operations substantial overhead transferring control fl gl runtime systems discourages small grained interactions resulting integrated code inelegant hybrid depends implementation details fl gl compilers may unacceptable organizations mandate standardized portable gls 
developed alternative approach interoperability completely bypasses problems translating entire fl program imperative gl legacy code base 
specifically built system translates ml source language called rml restricted ml welltyped portable vanilla ada ansi code passed standard compiler 
output translator represents fl types control structures gl types control structures fl gl code easily integrated single procedure efficient fully type safe manner 
system developed back larger application generator system produces integrable components high level specifications kieburtz generate rml code specifications techniques translate code ada scheme described 
system quite general accommodate hand written generated rml code source may useful context tight integration existing legacy code base desirable 
describes design implementation rml gl translator 
requirements translator familiar existing fl compilers high level features polymorphism higher order functions algebraic datatypes need expressed terms lower level type control constructs 
need generate adequately performing welltyped vanilla target code particularly ada quite secure restrictive language special demands translator 
led novel combination compilation techniques independent interest choice ada mandated project sponsor air force materiel command 
ml ada ffl type macro expansion technique called templates volpano kieburtz volpano kieburtz integrate gl code rml 
rml program translated respect particular template defines set primitive types set primitive operators 
definitions take form macros expand text 
substantial legacy code components simple primitive types operators handled uniformly fashion 
operators monomorphic order 
templates specified specialized definition language see section 
ffl system removes polymorphism rml programs cloning polymorphic functions datatype declarations making separate monomorphic version distinct set instantiating type variables see section 
approach suggested jones similar effects achieved accident tarditi unaware previous practical intentional realizations :10.1.1.27.353
approach requires access rml program 
ffl system removes higher order functions novel typed closure conversion algorithm represents closures members algebraic datatypes generates type specific dispatch functions interpret see section 
resulting code require function pointers ada lacks 
previous treatments typed closure conversion minamide need introduce new language primitives fancy type systems maintain typability method require access program monomorphic :10.1.1.141.7192
ffl system optimizes closure converted code simple standard style transformations optimizing stage suggested aware done proves useful 
example standard uncurrying optimization performed free standard inlining optimization see section 
ffl furthermore code produced typed closure conversion algorithm viewed result simple implicit closure analysis 
system takes advantage closure analyses choose efficient closure representations perform aggressive inlining untyped conversion support see section 
show express results somewhat stronger closure analysis bondorf jrgensen bondorf jrgensen palsberg standard algebraic type framework see section 
ffl system eliminates tail calls mutually recursive functions introducing global labels ansi ada lack 
uses local labels merging mutually recursive functions single function multiple entry points necessary see section 
architecture translator resembles fl compilers appel leroy peyton jones tarditi :10.1.1.27.353
translator written standard ml structured tolmach oliva series relatively simple transformations preserving semantics types see section 
uses small set intermediate languages strongly typed executable interpreter 
type checkers self test mechanisms built intermediate language stage heavily development find correct bugs translator 
transformation step dependent particular gl target language involved translator easily retargeted new output languages 
system relies standard gl compilers handle traditional low level concerns register allocation instruction selection local optimization reasonable results 
high performance primary goal performance code generated translator compares favorably output regarded standard ml new jersey compiler 
memory management area 
back incorporates boehm demers weiser conservative collector boehm weiser 
heap allocation spot perform casting order allocate storage values different types common heap course standard practice ada supports garbage collection principle implementations ada applications built far structured safe perform simple bulk deallocation ada code key points 
interest typed intermediate representations compilers peyton jones morrisett cases types abandoned code generation :10.1.1.47.6555
til compiler tarditi keep type information late stage compilation process code reached low level form primitive gl code type system substantially complex ada style typing :10.1.1.27.353
existing systems compile ml haskell tarditi peyton jones tofte heavy casts non standard extensions provided gcc especially handle closures exceptions avoid procedure activation model 
system generates ansi standard nearly cast free code 
systems generate low level intermediate forms stack machines target program completely different structure source fl program 
contrast translator perturbs function level structure source program needs rml program nested higher order functions inter function tail calls translated natural looking program structure 
system currently handle exceptions 
describes architecture system reports detail novel transformations 
assume reader familiar syntax functional languages ml able read ada code 
tried avoid formality demanded sake precision 
ml ada package type array float type transform access type point record float float record id transform function rotate float return transform function translate float return transform 
function compose transform return transform function apply transform point return point fig 

example ada package specification excerpts 
example simple motivating example suppose wish build rml component existing ada package implements simple transformations points see 
points represented pairs reals transformations real matrices transformations composed applied matrix multiplication see 
want existing ada numerical computation rml convenient manipulation points transforms considered values 
ada write main program driver responsible invoking rml component little say driver 
application granularity primitive operations quite small invoking function perform quite inefficient 
template definition imports operations basic real number support rml component shown 
template declares real point transform new types operator signatures listed 
operators expand calls corresponding ada routines apply defined expand inline ada code 
template syntax explained section 
simple rml component uses template shown 
rml concrete syntax similar sml details section 
component heavy rml facility defining manipulating polymorphic algebraic types list traversal operations foldl 
builds list transforms uses foldl compose combined transformation uses foldl apply combined transform list points third foldl reverse result returning list transformed points original order 
remainder refer repeatedly example component somewhat artificial example functional language implementations built support numerical computing recoding small legacy component easy 
tolmach oliva package body 
function rotate float return transform return new cos sin sin cos rotate 
function compose transform return transform retval transform loop loop 
loop loop return retval compose function apply transform point return point retval point bottom row retval retval return retval apply fig 

example ada package implementation excerpts template type real float type point point type transform transform val add real real res real pure res val div real real res real res val id transform id val rotate real res transform pure res rotate val apply transform point res point pure res res fig 

example template geometric operations excerpts 
ml ada export type point list plist val nil point list val cons point point list 
point list val doit point list 
point list doit datatype list cons list nil fun foldl case nil 
cons 
foldl val ts cons translate cons scale cons rotate div nil fun doit ps val foldl compose id ts fun cons apply val ps foldl nil ps foldl cons nil ps fig 

rml component geometric template 
show effect various transformations 
preview product show final output rml ada translator component 
genuine output renamed variables reformatted better readability coalesced variable declarations initial assignments declarations initializers 
output code illustrates key characteristics translation approach extremely small size input program optimizer done unusually job 
output efficient order monomorphic code 
original polymorphic foldl function specialized monomorphic variants foldl foldl transform lists transforms point lists point lists respectively 
possible functional arguments foldl cons represented members discriminated record type closure 
discriminant tag indicates function required variant carries free variable associated value dynamically constructed cons variant statically defined 
case closure small manipulated value heap allocated 
cons arguments foldl code inlined foldl 
primitive ada code apply inlined specified template 
stronger optimization applied foldl compose argument passed closure required body specialized call primitive ada compose routine directly 
tolmach oliva math math package type type plist access type record point plist record function point plist return plist plist null function doit ps plist return plist package body type type tlist access type record transform tlist record function transform tlist return tlist tlist null type type closure constructor record case constructor 
null 
transform case record cons closure tf float transform transform transform vts tlist ts tlist ts tlist function point plist return plist return new 

function transform tlist return tlist return new 

function foldl transform tlist return transform transform tlist goto 
null return declare transform tlist transform compose goto foldl fig 

generated ada code corresponding example 
ml ada function foldl closure plist plist return plist closure plist plist goto 
null return declare point plist case constructor 
declare plist goto 
declare transform point declare plist goto case function doit ps plist return plist transform foldl id ts closure ps plist foldl ps ps plist foldl cons ps return ps doit translate scale tf rotate tf ts ts ts ts ts fig 
cont 
generated ada code corresponding example 
tolmach oliva primitive types type variables hi 
function types hi algebraic types oe hti 
type schemes primitive constants variables hei function applications hei constructor applications hei primitive applications fn inline rule anonymous abstractions local declarations case destructuring rule hv 
rules val rec hv oe fn inline recursive function declarations val oe value declarations hti flat omega hi ff algebraic type declarations datatype mutually recursive declarations export type name type exports val name value exports comp export components fig 

rml syntax 
syntax descriptions notation hxi sep mean sequence zero separated sep mean optional giving examples written syntax generally omit grouping parentheses ambiguity results 
heap allocated structures ada program lists translator automatically chosen efficient representation record list item null pointer represent empty list point lists completely flattened word record item indirection point pair embedded reals 
tail recursive calls foldl foldl converted local jumps 
major remaining optimizations performed ada compiler variable coalescing jump jump elimination loop invariant hoisting 
rml source language rml eager language class functions algebraic datatypes parametric hindley milner polymorphism 
plain rml primitives essentially similar pure subset core standard ml sml milner ml ada nested patterns derived forms addition true multi argument functions data constructors 
impure features arrays added language template primitive mechanism see section exceptions fundamentally missing 
human readable somewhat syntax rml intermediate languages translator 
representation assumed identifier bound twice 
practice source code fed rml translator elaborate concrete syntax similar sml syntax usual lexical scoping rules machine generated source internal representation syntax 
primary difference concrete syntax untyped system performs standard hindley milner type inference hindley milner damas cardelli obtain type annotated form :10.1.1.120.5931
concrete syntax allows primitives constructors class values syntax permits operator position applications class uses automatically eta expanded concrete syntax parser 
parser accepts translates common sml derived forms fun val rec 
rml typing rules largely standard mention distinctive points 
rml syntax includes explicit type annotations variable constructor uses type schemes declarations 
annotations suffice reconstruct types arbitrary terms 
different mentions bound toplevel function constructor may course different types mention instantiating type expressions generic type variables determined unifying type annotation mention scheme annotation declaration 
sml rml adheres value restriction polymorphic bindings wright requires recursive bindings explicit function abstractions prohibits polymorphic recursion functions 
sml rml prohibits polymorphic recursion datatype definitions 
sml rml lacks records tuples se built datatypes single constructor 
datatypes marked flat meaning manipulated tuple immediate values heap allocated suitable small records simple sum types 
degenerate special case data type may zero constructors case value type arms arbitrary result type dynamic semantics abort 
semantics rml declarations expressions straightforward omit formal presentation 
sml evaluation order fixed left right conditional control flow governed case expressions 
user defined functions primitives receive parameters value 
built facility exceptions sensibly implemented call value primitives 
unit translation component sequence type value declarations datatype definition abstracted list type variables righthand side mention datatype instantiated exactly variables 
tolmach oliva type type string primitive types value val string primitive constants val hv pure string primitive functions template name templates fig 

template specification syntax 
types rml 

rml component export clause lists types values exported gl components system specifies gl names 
particular main program driver executable written host gl invokes rml code exported functions 
polymorphic types values exported specific monomorphic instances 
argument result types exported functions order 
formally meaning component environment mapping gl names rml types values environment altered translation process 
translator currently directly support multiple rml components program functions generated rml component treated gl functions imported order primitives rml component template mechanism 
obvious reasons useful divide rml code large system multiple components provide independent namespaces libraries speed system building separate compilation 
plan extend system support goal straightforward 
separate compilation harder translation strategies depend fundamentally having access rml source code time 
templates rml component translated respect particular template specifies interface gl components rml code 
template definition plays key roles 
specifies types operators implemented gl available rml code primitives information translator parsing type checking rml components 
template includes macro definitions types operators terms gl code fragments translator generates gl code rml 
templates defined small special purpose language concrete syntax shown 
template specifications heavy quoted strings represent text target gl utilize standard set escape conventions sml 
provides typical example ada template template definition format course macro text differ 
primitive types typically include general purpose types integer real application specific types transform point 
primitive type ml ada type declaration gives type name rml code specifies corresponding gl type name built user defined provides concrete realization type 
primitive types monomorphic parameterized 
primitive values operators defined val declarations specify types expansions gl code 
values operator arguments operator results primitive types implies values operators monomorphic order 
value declaration specifies rml type value corresponding gl syntax 
operator declaration specifies formal names types operator arguments result corresponding gl code string treated macro formal names parameters 
formal parameters referenced inside string surrounding back quotes 
example definition primitive division operator val div real real res real res rml expression val div eventually leads ada code example illustrates expansions operators statements expressions permits elaborate definitions 
possible rml side code generation performed imperative intermediate form see section primitive operator calls appear right hand sides assignment statements result operation returned assigning variable 
actual arguments operators variable names constants prevents potential problems multiple uses formal argument macro 
operators general purpose primitive types div operator described implemented built operators gl 
applicationspecific types operators usually depend non trivial gl type definitions library code 
desired calls small functions inlined hand operator definition apply example 
operators marked pure assumed separate verification side effects translator apply aggressive optimizations expressions involve pure operators see section 
mechanism describe detail algebraic type bool true false permits rml code perform conditional computation result primitive operation 
principle integer real string literal rml program specified way avoid tedium template mechanism literal constants built 
experience gl compilers depended perform inlining automatically 
tolmach oliva compiler architecture representations compiler structured pipeline operating series specialized typed intermediate representations see 
section summarizes important steps compilation sequence serves guide detailed descriptions steps sections follow 
ffl rml code parsed concrete text representation loaded binary representation produced separate generator tool 
parsing performed respect particular template definition provides particular set primitive types operators 
ffl rml code annotated type information conventional type inference 
annotated code translated monomorphic form section 
ffl monomorphic rml code transformed restrictive language called sil sequentialized intermediate language variant normal form flanagan closely related continuation passing style steele kranz appel :10.1.1.48.8807
sil arguments functions primitives required named variables constants 
translation rml sil section effectively fixes order evaluation primitives 
sil supports jump points locally scoped continuation functions kelsey initial translation sil doesn :10.1.1.3.6773
ffl sil code optimized section repeated application rewrite rules encode partial evaluation style improvements value variable propagation simplification case expressions known values elimination dead code unused datatypes conservative function inlining 
ffl sil code reduced order form section 
resulting code re optimized section 
ffl tail calls changed jumps merging mutually recursive functions necessary section 
ffl sil code transformed imperative target code stages treated briefly section 
sil code transformed intermediate form called mil mutable intermediate language abstracts essential characteristics shared ada similar languages 
mil code translated ada code template macros 
entire compiler amounts lines standard ml runs version standard ml new jersey system 
ml ada parsing type inference monomorphic rml code sequentialization sil code order sil code higher order removal tail recursion removal sil jump points conversion imperative style mil code code ada code specification template reoptimization optimization rml concrete syntax typed rml code remove polymorphism gl code generation fig 

architecture compiler 
numbers parentheses refer section numbers relevant transformation described 
tolmach oliva eliminating polymorphism concept target gls directly support parametric polymorphism 
translator converts polymorphic components monomorphic ones producing specialized clones polymorphic functions constructors type 
arranging perform step early compilation process rml rml translation clear way transformation algorithms notably higher order function representation analyzer require monomorphic input 
specialization algorithm operates complete type checked source program polymorphic identifier annotated instantiated type 
representation full set instantiations type abstraction enumerated way described 
rml restrictions polymorphic recursion datatypes functions guarantee sets finite 
complete set instantiations bound type variables recursive function datatype definition mutually recursive set definitions determined looking right hand side definition 
fact allows instantiations enumerated pass algorithm doesn require fixed point calculation 
section example specializer generates versions list datatype specialized points transforms respectively corresponding versions foldl function 
resulting component shown 
details algorithm complete specialization algorithm consists passes type annotated program produced standard inferencer 
pass replaces occurrences free type variables arbitrary trivial type safe computation examines values types involve free type variables morrisett 
second pass computes mapping polymorphic variable algebraic type constructor corresponding set instantiations 
third pass uses mapping perform actual specialization 
enumeration pass far complex details 
explain algorithm require terminology 
simultaneous substitution hti 
mapping sequence type variables corresponding sequence types 
applying substitution type usual effect replacing type variable dom leaving type variables type constructors unchanged 
define result applying substitution sequence types sequence hs multi substitution mapping hti 
sequence ada generics necessary power certain restrictions form generic package interfaces cause unnecessary extra copies code generated 
ml ada export type plist plist val plist val point plist 
plist val doit plist 
plist doit datatype plist point plist datatype tlist transform tlist val rec foldl transform transform 
transform transform tlist 
transform fn 
case 

foldl val rec foldl point plist 
plist plist plist 
plist fn 
case 

foldl val ts tlist val rec doit plist 
plist fn ps 
val transform foldl fn 
compose id ts val point plist 
plist fn 
apply val ps plist foldl ps foldl fn 
cons ps fig 

rml syntax geometric example component type specialization 
type annotations omitted improve readability 
type variables set corresponding sequences types compactly describes set substitutions common domain 
define result applying type resp 
sequence types set types resp 
sequences types resulting applying individual substitutions turn removing duplicates 
substitution viewed multi substitution making result singleton set 
hti 
hti 
multi substitutions domain define sum multi substitution hti 
represents ordinary set union removal duplicates 
hm sequence multi substitutions having domain write hm combined sum 
define composition multi substitutions hti 
multi substitution hti 
fm computes union members set sets 
tolmach oliva theta theta hi ht theta theta hi ht fd 

hi theta theta hti fv 
inst theta theta hei theta theta hei 
inst theta theta hei fn inl rule rule theta theta case gamma 
inst rule delta theta theta hv 
ht val oe ffi oe ffi fi fi fi free jj fi fi fi bound theta theta val rec hv oe fn inl ffi hs oe ffi rule fi fi fi free rule rule fi fi fi bound rule ej hi ds ds ds hh datatype hti flt omega hi ff ii ffi omega omega ht ffff type name val name fv 
inst export ds hx export fig 

enumeration instances polymorphic identifiers 
ml ada instantiation map mapping polymorphic identifiers hti multi substitutions domain hti build instantiation maps domains include variables algebraic type constructors 
instantiation map set identifiers write instantiation map results restricting domain instantiation maps write instantiation map fx 
dom dom hii sequence instantiation maps hii represents sequential combination 
fx 
instantiation map multi substitution define composition ffi instantiation map fx 
ffi syntax directed rules maps syntactic fragment instantiation map describing sets type instantiations induced mentions variables constructors fragment 
particular calculates instantiation map entire component domain component complete set top level bound variables algebraic type constructors 
algorithm walks component bottom fashion information non recursive mentions identifier incorporated instantiation map definition identifier processed map passed auxiliary argument rule processes definition example process fragment val hti algorithm builds instantiation map ii 
builds instantiation maps instantiating types may mention type variables hti iii 
divides parts fe corresponding free bound variables iv 
expands fe fe pre composing multi substitution describing possible instantiations hti similarly expands vi 
sums fe unexpanded yield final map expression 
distinction free bound variables effectively prevents map entry locally defined function refined definition processed important specialization pass 
rules recursive function datatype definitions similar 
rml prohibits polymorphic recursive definitions functions algebraic types auxiliary guaranteed describe instantiations identifier defined need look right hand side definition 
recursive function case necessary combine instance information uses mutually recursive functions pre composing 
algorithm relies number auxiliary functions 
free returns set free variables type constructors mentioned expression rule similarly bound returns set bound variables inst hti returns substitution hti 
called argu tolmach oliva datatype val 
fn 

val 
fn 
val 
fn 

val 

val bool int bool 
bool int true bool val string bool string 
string false bool abc string fig 

example nested polymorphic functions 
ments result substitution guaranteed exist 
assume existence reconstruction functions returns possibly degenerate type scheme corresponding variable constructor returns algebraic type constructor data constructor belongs returns possibly empty sequence type variables algebraic type constructor abstracted 
assume certain consistency conditions functions schemes functions sequence bound type variables similarly schemes data constructors type constructor mutually recursive type constructors sequence bound type variables match sequence returned type constructor 
conditions naturally met annotations produced standard type inferencer provided recursive definitions separated strongly connected components inferencing 
artificial example algorithm operation consider code written explicitly typed form 
computation proceeds roughly follows ignoring generation empty map entries non polymorphic variables ffl declaration processed yielding instantiation map fg 
di 

ai 
ffl declaration processed yielding instantiation map fg 
di 
fhint 
ai 
ffl added produce map declarations ae 
di 
hint 
ai 
oe ffl val expression processed yielding steps map 
bi 
fh cig 
ei 
fh cig 
ai 
fh ci dig ml ada ffl body definition processed yielding map ff 
bi 
fh dig 
ai 
fh dig ffl composition ffi computed yielding unchanged 
ffl added produce map body definition 
bi 
fh ci dig 
ei 
fh cig 
ai 
fh ci dig ffl composition ffi fi fi fi ff pg computed yielding map ae 
bi 

ai 
oe ffl added fi fi fi fhg produce map declarations 
di 
hint 
ei 
fh cig 
bi 

ai 
ffl processing definitions produce map guide specialization pass algorithm 
specialized copies function corresponding instantiations di 
note importance tracking sequences instantiations type variables instantiations variable tracked separately way distinguish correct instantiations spurious ones bool bool int string 
copy single specialized version instantiated relevant instance int copy bool second 
note enumeration algorithm freeze instantiation map point definition final map entry 
ei 
correctly enumerate versions required fail indicate instance needed copy say needed 
specialized copies corresponding instantiations 
omit detailed description specialization pass quite straightforward existence instantiation map 
discussion worst case size monomorphic program produced algorithm may exponential size original polymorphic program 
tolmach oliva code explosion serious problem practice polymorphic functions tend small probably polymorphic function fewer useful things wadler :10.1.1.38.9875
idea removing parametric polymorphism specialization received informal discussion small experiment attempted gofer jones aware previous practical compiler approach 
analysis benchmarks run til compiler tarditi indicates compiler removes essentially polymorphism result aggressive function inlining offering independent evidence specialization need lead excessive code explosion :10.1.1.27.353
til guarantee produce monomorphic program take full advantage having compilation stages translator 
sequentialization rml rich collection expression forms target gls severely limited expressions 
appears direct correspondence expression forms rml target language evaluation order may differ 
step translating rml simplify expressions name intermediate results time explicitly computation intended order 
call resulting language sil sequentialized intermediate language syntax specified 
compared rml important differences arguments applications discriminants case expressions simple variables constants anonymous function expressions 
sil type system monomorphic polymorphism removed rml level 
means types longer mention type variables type schemes type annotations dropped redundant variable mentions exports algebraic type declarations identical rml 
jump points label goto appear initial translations rml code discussed section 
example shows sil form doit functions monomorphic version running example section 
transformation rml sil essentially performs naming sequentialization steps continuation passing style cps transform steele kranz appel introducing full scale continuations 
omit details transformation fairly straightforward 
resulting sil code closely resembles cps forms adopted functional language compilers lawall danvy flanagan kelsey tarditi :10.1.1.48.8807:10.1.1.3.6773
sil adopts relatively permissive approach location bindings permits result case bound normal form flanagan permits result expression bound normal form til form tarditi :10.1.1.48.8807
extra flexibility easy transform rml case expressions sil duplicating code ml ada primitive types monomorphic algebraic types hi 
function types se primitive constants variables se simple expressions function applications constructor applications primitive applications decs local declarations case se omega hvi 
ff destructuring goto jumps local labels val variable declarations fun omega inline hv ff mutually recursive function declarations label omega hv ff mutually recursive jump point declarations decs variable declarations function declarations jump point declarations top level variable declarations top level function declarations flat omega hi ff algebraic type declarations datatype mutually recursive declarations export type name type exports val name value exports comp export components fig 

sil syntax 
tolmach oliva fun doit ps plist plist val transform fun comp transform transform compose foldl comp id ts fun point plist val apply val ps plist foldl ps fun cons point plist foldl cons ps fig 

sil translation geometric example component selection 
introducing continuation functions keeps sil closed larger class optimization transformations 
optimization sil code optimized repeated application rewrite rules encode style improvements 
include propagation simple expressions constants variables simplification case expressions known values elimination unused function pure value bindings elimination unused datatypes hoisting bindings described conservative function inlining 
function application inlined ffl sole application function ffl body small value variable application ffl body form case expression argument argument known value relevant arm case small call case splitting ffl programmer demands inlining source pragma function definition 
guarantee termination inliner function inlined body 
choice implementation optimizations largely inspired appel jim 
optimizer perform speculative inlining 
optimization passes performed repeatedly change observed fixed small number passes reached 
optimization passes preceded single round eta expansion improve opportunities inlining 
variable bound case expression value known compile time propagated 
hoisting case expressions lets optimization enabling transform increase amount information available constant propagation case arm 
general form transformation optimization includes selection fields records known values important special case 
ml ada val case hwi 
hwi 
cn hwi 
en case hwi 
val hwi 
val cn hwi 
val en primarily worth doing form possible perform case splitting general dangerous transformation duplicates code case arm performed small expression 
addition lets hoisted lets causes code explosion may help optimization exposing case hoisting opportunities 
optimizations described essential type information system perform simple type global optimizations 
uses transparent datatype form datatype replaced direct uses datatype definition removed 
uses unit datatype form datatype function constructor argument lists eliminated escaping functions remaining values type replaced literal forms datatype quite arise code generated higher order removal process see section 
rml strict semantics templates may include impure operators optimizer guarantee duplicate reorder eliminate calls primitives potentially nonterminating functions 
fact transformations described induce duplication reordering pure expressions eliminated 
pure primitive operators marked template definition simplicity user function calls treated impure 
sophisticated approach perform effects analysis functions increase number eliminable expressions talpin jouvelot tarditi 
removing higher order functions concepts target gls directly support class nested functions ada support pointers top level functions ansi support nested functions 
convert higher order programs equivalent order programs nested functions perform closure conversion 
simplicity wish express order programs strict subset original language closure passing style appel jim closures represented ordinary records constructed accessed ordinary record operators 
particular allow optimize closure manipulation operations ordinary record optimizations 
closure converted program typed rules original language rules enforceable ada 
difficulty functions type differ number types free variables closure records completely different structural type 
tolmach oliva minamide morrisett harper treated problem solutions rely new language primitives closure manipulation complicate subsequent optimization giving closures existential types substantial complication compiler type system 
solution leads typable ada 
solutions continue top level function pointers 
take different approach relies having monomorphic program available analysis transformation 
derives interpretive technique introduced reynolds warren explored typed settings bell bellegarde hook bell bellegarde hook bell 
key idea represent function closures members closure algebraic data type discriminated union 
constructor function definition program arguments function free variables 
convert program order higher order operations functions replaced equivalent operations closure values 
function definitions original definitions replaced closure constructor applications calls unknown lambda bound functions transformed calls dispatch function passing closure value argument 
dispatch function examines closure tag passes control appropriate lambda lifted function 
usual calls known bound functions need converted way simply changed invoke lambda lifted version calls function known construction closure datatype value removed altogether standard dead code elimination optimization 
provides simple example involving higher order function twice 
strongly typed setting single closure datatype dispatch function typically suffice pair distinct arrow type program 
translation algorithm choose correct dispatch function site inspecting type original function 
effect illustrated code shows closure converted version running example 
contrast higher order removal techniques code specialization chin darlington algorithm handle programs number generated closures statically bounded 
gives example known encoding integer set characteristic function type int bool 
executing upto builds set ng represented int bool closures containing closure free variable 
pattern reflected fact type clos recursive fact isomorphic standard list datatype represent sets non functionally 
flat closure representation elaborate representations handled framework 
possible build single polymorphic dispatch function ordinary typing rules case 
ml ada original code fun twice int int int int fun main int int fun int int fun int int twice twice 
closure converting datatype clos int type int int fun int int int lambda lifted functions int int dispatch clos int int type int int case 

fun twice clos int int dispatch dispatch fun main int int val clos closure values val clos twice twice 
fig 

simple example typed closure conversion 
converted code slightly optimized version output produced formal algorithm section 
details algorithm core algorithm syntax directed translation terms terms ffl distinct arrow type converted unique corresponding closure datatype ffl function definition lambda lifted augmenting argument list new arguments representing function free variables ffl augmented functions renamed definitions lifted top level ffl original function definition body program replaced binding application freshly chosen closure constructor free variables ffl variables bound function values variables bound closure values ffl calls unknown functions calls appropriate dispatch function passing closure datatype value extra argument ffl calls known functions calls corresponding lifted function passing free variables extra arguments 
way conversion keeps track new closure datatypes data constructors created incrementally top level declarations component converted information construct definitions tolmach oliva datatype ccomp type transform transform transform datatype transform type point plist plist fun comp transform transform transform compose transform transform transform case type transform transform transform ccomp 
comp point plist transform plist val apply cons point plist plist point plist plist case type point plist plist 
cons 
fun foldl transform tlist transform case 

val transform foldl fun foldl plist plist plist val plist fun doit ps plist id transform ts tlist plist val comp ccomp val transform foldl comp id ts val val ps plist foldl ps val cons foldl cons ps val ts tlist 
fun doit ps plist doit ps id ts fig 

geometric example component closure conversion 
slightly optimized version output produced formal algorithm section 
ml ada original code fun empty int bool false fun member int bool int bool fun insert int bool int int bool fun case true 
true false 
fun upto int int bool case true 
empty false 
insert upto fun main int bool lookup upto closure converting int bool functions datatype clos int clos type int bool fun empty int bool false lambda lifted functions int int clos case true 
true false 
dispatch dispatch clos int bool type int bool case 
empty 
val empty clos closure value fun member clos int bool dispatch fun insert clos int clos val clos closure value fun upto int clos unchanged fun main int bool unchanged fig 

closure conversion code sets represented characteristic functions 
improve readability rml concrete syntax sil 
converted code slightly optimized version output produced formal algorithm section 
closure datatypes corresponding dispatch functions 
definitions combined lifted function definitions converted terms form fully converted component definition 
described algorithm redefines function valued identifier closure changes arrow type closure type 
signatures exported values changed implies argument result types exported functions involve arrow types noted section exported functions closure converted 
practice system handles problem creating special stub versions exported functions unchanged signatures omit detail formal presentation correct programs export functions 
detailed specification term conversion algorithm 
translation type denoted translates top level declarations tolmach oliva hi theta theta hi ek se se ek theta theta dom lift dispatch ffi ffi typeof ek theta theta ek theta theta ek val val ek ek ek theta theta fun theta theta fun fdec 
fs ek hh case se omega hvi 
ff ii case se omega hvi ek ff fdec fk fdec ek fk theta theta inl hv lifted lifted lift inl hv omega fv typeof fv ff ek tc gamma tc 
gamma lift omega fv typeof fv ff delta delta val tc hh datatype flt omega hi ff ii flt omega hi ff val val ek theta theta fun theta theta fun fdec 
hf dec fig 

closure conversion sil terms 
translates expressions translates functions fs auxiliary function translating recursive sets functions 
translations explicitly parameterized environment records identifiers current scope refer known functions defined returns sequence free variables guaranteed current scope 
fs parameterized function sequence free variables 
translates mutually recursive sets algebraic type declarations 
addition producing result terms translations side effects build important auxiliary structures ml ada theta theta fun dec theta theta inl hv gamma gamma fv fvg theta theta se dom fk fvg theta theta se theta theta se val gamma fvg theta theta fun theta theta fun gamma fdec case se hc hvi 
ei se omega gamma ff fig 

calculation free variables 
notation hxi denotes set union sets resulting calculation members sequence 
mapping lift source function names corresponding lifted function names ii 
bijective mapping source arrow types corresponding closure datatype names iii 
mapping dispatch closure datatype names corresponding dispatch function names iv 
set lifted lifted function definitions mapping closure datatype names tc sets tuples dc dc closure data constructor tc corresponding lifted function name sequence corresponding function free variables types 
mappings lift dispatch treated self functions generate return fresh name called argument time subsequent calls argument return result call 
assume auxiliary functions returns fresh closure data constructor name time called typeof reconstructs original type source term extracts function name declaration lifted set sets extended explicitly side effect translation 
term translation complete sets generate closure datatype definitions dispatch functions described 
note order side effects executed build structures alter results choice names translation functions read particular imperative evaluation order mind 
simplicity omits certain variable renamings required maintain identifier uniqueness 
auxiliary function fv specified computes free variables expression assuming initial known function environment specified tolmach oliva export lift dispatch lifted flatten ha point mappings built closure dispatch funs tc codom closure closure tc omega dc hi ff dispatch funs dispatch funs dispatch tc tc hv case omega dc 
hvi ff dc tc hi gamma tc hvi fresh done export datatype ha closure fun hf dispatch hf fig 

closure conversion sil components 
notation hs si read sequence comprehension sequence values drawn set auxiliary function flatten converts sequence sequences single sequence 
fv returns set assume implementation produce members set deterministic order canonical sequence ordering free variables 
free variable calculation slightly tricky produce free variables translated term original term input free variables calculated translation occur 
break circularity observe free variables sets source translated terms differ due replacement known function application hvi corresponding lifted application lift hvi free variables case target free variable set include include 
top level conversion function components shown 
function read imperatively construction closure datatypes dispatch functions translation export list rely auxiliary data structures built side effect translations 
datatype declaration dispatch function built closure datatype invented corresponding arrow type source program 
note possible closure datatype constructors corresponding discovered formulation free variable calculation xavier leroy gallium compiler leroy 
ml ada dispatch function body case arms defined type 
dispatch functions applied cases dead code eliminator remove 
freshly created closure datatype declarations may refer converted versions source program datatype declarations free variables may belong datatypes vice versa source datatypes may include fields arrow type converted closure types 
converted component single mutually recursive set algebraic type declarations including closure datatypes converted source datatypes 
similar reasons converted component groups freshly created closure dispatch functions lifted versions source program functions single mutually recursive declaration followed translations original top level declarations 
identifier uniqueness guarantees harmless declare set declarations mutually recursive post processing step separate datatypes functions true mutually recursive components 
discussion need type dispatch functions algorithm depends critically having monomorphic source code believe similar algorithm polymorphic programs addition typecase construct morrisett 
bell bellegarde hook bell specified elaborate algorithm polymorphic source programs performs type specialization higher order removal simultaneously may leave parts program polymorphic possible 
approach powerful significantly complicated implemented 
algorithm depends having full source program available restriction lifted permit extensible datatype declarations datatypes data constructor declarations scattered program separate compilation units tolmach 
supporting datatypes requires small extension type system standard ml treats built exception type constructor way requires somewhat expensive implementation case precludes optimizations discussed section 
optimization order code order conversion pass back optimizer typical call unknown function known call dispatch function followed case dispatch 
sequence probably efficient single indirect jump performed conventionally closure converted program 
supports indirect jumps top level functions representation converted back conventional closure representation final compilation step code pointers lifted functions constructor tags closure tolmach oliva potential performance advantages obtained interpreted style converted program deriving fact explicitly order program 
uncurrying general purpose optimizations inline small functions perform case splitting explicit closure form mimic effect standard uncurrying transformation extra implementation effort 
consider curried function expressed sil fun 
fun fully applied instance expressed sil val 
code efficient application arity function due cost building entering intermediate closure 
uncurrying transformation reduces cost introducing arity function redefining call note duplicated 
fun fun fun fully applied instances altered call directly escaping instances changed 
similar transformation desirable curried functions arguments called actuals 
uncurrying ordinarily performed prior closure conversion 
appel noted uncurrying achieved simply introducing definition relying standard inlining heuristics inline bodies small yielding direct call 
observation closure conversion performs transformation appel suggests introducing lifted version 
applying round standard optimizations closure conversion get uncurrying free 
result closure conversion example type 
works closure value cased relevant dispatch function 
course code require unsafe casts 
ml ada datatype clos cf fun clos cf fun dispatch clos case cf 
val clos dispatch standard optimizer proceeds follows inlines call body function small yields val clos cf dispatch call dispatch case split resulting inlining dispatch yielding direct ary call 
note success inlining strategy doesn depend number cases dispatch function arbitrarily large 
depend sizing heuristic conservative inliner judge relevant function bodies small 
works correctly functions arguments 
implicit type closure analysis higher order functions complicate compilers making flow analysis difficult data flow control flow interdependent analyses conventional gl compiler world won modification 
optimizations value propagation dead code elimination require compiler determine approximation set invoked application site program 
existing implementations called closure analysis interpretation involving fixpoint calculation sestoft shivers constraint mechanism bondorf jrgensen palsberg region inference koch olesen 
surprisingly existing system appears take advantage fact simple typing provides cut analysis free 
existing closure analysis algorithms express results language feed subsequent general purpose optimizations 
closure conversion algorithm seen encoding simple closure analysis 
type inference tags application site type lambda expressions invoked site type matches annotation 
set lambdas explicit dispatch function called site corresponding closure datatype 
standard partial evaluation style optimizations constant propagation dead code tolmach oliva datatype flat transform fun foldl transform tlist transform case 

val transform compose foldl fun foldl plist plist plist case 

case 
val plist cons foldl 
val point apply val plist cons foldl val ts tlist 
fun doit ps plist plist val transform foldl id ts val val ps plist foldl ps foldl ps fig 

optimized order code geometric example component 
elimination described section directly representation 
addition potential optimization payoffs number data constructors particular closure type small 
singleton set constructors ideal optimizer knows precisely function called arrange call directly small inline jagannathan wright 
inlining possible risk code blow sets just constructors implemented 
closure datatype built compiler fact knows constructors choose optimized representation 
standard datatype representation tricks cardelli appel avoid building heap records closure constructors free variables :10.1.1.43.208
useful support flat unboxed variant types see section avoid heap allocation non recursive constructors just free variables 
example shows effect optimizing code 
function having absorbed cons inlined foldl 
closure datatype represented flat ml ada need heap allocated 
datatype recognized unit type definition uses removed altogether allowing body simplified call comp call compose inlined foldl 
function doit inlined doit 
payoff inlining closure representation optimizations depends precision underlying type closure analysis turn depends source program types 
extent types represent structural distinctions values essentially fixed programmer choice data structures algorithms 
source languages support model types allow programmers distinguish different uses structurally equivalent types 
rml standard ml example done transparent datatype declarations datatype fahrenheit int datatype int ordinarily programmers order program text clearer obtain help compiler type checker detecting logical errors 
example lambda bound functions type fahrenheit fahrenheit reliably distinguished type reducing risk accidentally confusing kinds quantities 
closure conversion scheme functions go distinct closure datatypes having fewer constructors datatype common structural type int int possibly offering optimization opportunities call sites 
users motive making fine typing distinctions may enable better optimization efficient closure representations better performance 
explicit closure analysis translator perform forms flow analysis explicitly record results form specialized typing closure converter take account collecting constructors closure datatypes producing larger number datatypes containing fewer constructors 
built analyzer structured variant type inferencing 
copy original sil program expression annotated explicit monomorphic type analyzer tags occurrence arrow type fn expression variable unique integer 
performs standard type checking traversal program adjustment type checker unifies arrow types integer tags types placed equivalence class 
particular guarantees fn expression possibly applied application tags necessarily equivalence class 
hand arrow tags placed equivalence class merely argument result types match 
classes refinement ordinary types 
analysis simple typed intermediate form tolmach oliva hand linear complexity dominated union find algorithm 
produces essentially analysis constraintbased approach described bondorf jrgensen analyzed palsberg 
koch olesen implemented closure analysis ml kit compiler potentially polymorphic region annotations tofte talpin functions allocated region placed closure analysis equivalence class :10.1.1.23.5498
tag unification method closely resembles region inference monomorphic programs baker tofte talpin developed independently scheme corresponds ml kit polymorphic region inference :10.1.1.23.5498
important point framework result automated analysis expressed directly sil basis closure conversion 
done rewriting sil program 
equivalence class analyzer simply invents new unary datatype replaces instances adding necessary coercions program 
amount construction body function type case result application function 
resulting program fed directly ordinary closure converter 
transparent types cleaned resulting order program standard optimizer 
plan apply conventional fortran world optimizers closure converted code particularly take advantage developed dataflow frameworks don rely inlining propagate information 
eliminating tail calls function calls generally expensive standard implementations target gls 
desirable remove tail calls favor jumps especially calls recursive 
tail calls frequent sil user functions derived original rml code dispatch functions generated higher order function removal 
possible express calls jumps sil includes facility defining labeled jump points corresponding gotos function kelsey 
jump points declared similarly bound functions label name formal parameters defining expression body gotos similar function applications target jump point label actual parameters 
ffl goto expressions appear tail position ffl jump point labels mentioned targets gotos class values ffl goto particular jump point may appear recursively inside jump point definition immediate body function declaration nested inside body 
deeply recursive nests calls particularly expensive sparc processors register windows gl compilers 
ml ada fun foldl transform tlist transform label jp transform tlist transform case 

val transform compose goto jp goto jp fun doit ps plist plist val foldl id ts fig 

insertion jump points geometric example code 
sil translated target gl sil jump point labels ordinary labels parameters ordinary variable declarations scoped function level sil goto translates set assignments parameter variables followed ordinary local goto 
tail call turned goto 
simple recursive tail call function easy jump point inserted top function body recursive tail call changed goto non recursive non tail calls unchanged 
example shows jump point introduced top foldl code 
approach extended handle tail calls recursive functions significantly increased cost 
order nested labels proper scoping functions combined single function simulated multiple entry points 
jump point established inside combined functions original functions combined function gets extra discriminant argument dispatch control appropriate label 
discriminant encoded datatype manner similar closure datatypes introduced higher order function removal 
example fun datatype flat fun forg label goto forg goto case 
goto 
goto forg tolmach oliva transformation non tail call original functions requires constructing discriminant datatype value passing combined function performing immediate case dispatch 
fortunately added datatype sensibly declared flat recursive values consumed immediately top combined function escape 
target gl compilers net effect push datatype tag parameters original functions arguments stack 
principle compilers pass registers 
transformation costly code size execution time non tail calls performed tail recursive call set definitions 
worth including repertoire mutual tail recursion dispatch functions lifted functions invoke quite common 
generating ada code translation order optimized sil code target gls fairly straightforward give brief overview 
ease re targeting new gls translation mediated common imperative intermediate form called mil 
mil component sequence algebraic type declarations value definitions function definitions 
translations mil ada maintain top level structure sil code 
mil code body mil function block consists local mutable variable declarations labeled set nested sub blocks imperative statement sequence 
statement sequence consists zero assignment statements described followed unlabeled sub block case statement arms blocks goto label block enclosing explicit function return 
mil blocks produced sil function body binding case arm points convenient temporary variables 
mil block translated directly fg delimited block declare block ada 
assignment statements update variables declared block enclosing 
right hand side assignment restricted variable literal constant application applications apply primitive operator constructor user defined function variables constants 
particular template defined primitive operators appear right hand sides assignments simple variable constant arguments 
mil assignments translated directly ada assignments 
algebraic type representation mil algebraic type declarations extend sil declarations representation information 
careful choice representations quite important achieving ml ada performance target code 
algebraic type represented boxed tagged variant record ary data constructor type corresponding tagged variant fields types defined straightforward manner ada approach type representations uniform size word important systems polymorphic target code 
efficient representations maintain uniform size requirement known system uses standard tricks appel cardelli require casting 
system generates monomorphic code need require types uniform size 
non recursive type values occupy sufficiently small space represented flat unboxed manipulated directly value heap allocated manipulated 
unboxed records carries benefits costs 
major benefit reducing heap consequent reductions allocation garbage collection data access costs 
hand unboxed records expensive move boxed ones move requires entire contents record copied 
automatic unboxed representation restricted fairly small records threshold size tunable parameter translator 
users force datatype held unboxed marking flat source program 
functional language compilers known translator supports unboxed representations variant records 
particularly useful avoiding heap allocation small closures 
course unboxed values occupy space needed largest possible variant waste space copying time smaller variants important largest variant large 
ada ansi support manipulation unboxed record values efficiently 
potential advantage unboxed values need principle stored memory profitably spread registers machines lots registers 
unfortunately target gl compilers generally reluctant handle unboxed records way particular insist passing returning unboxed records stack 
improve direct access machine code 
choosing unboxed representations offers measurable improvements performance benchmarks discussed section 
code generation gcc compiler ansi compilation sun ada compiler versions ada compilation 
rely gl compilers important tasks including register allocation copy propagation peephole optimization jumps generation code case statements 
practice compilers vary considerably quality code gcc generally doing better job especially copy propagation 
cases semantics target language cause subtle performance tolmach oliva table 
benchmark results 
life fft sieve mess lines time standard time closure size flow flat time flow boxed time closure size flow flat time heap flow boxed time heap sml nj version rounds 
user system time seconds unloaded mhz pentium mb memory linux version 
generated code compiled gcc version option 
generated code linked boehm demers weiser conservative collector version 
maximum closure size words 
heap allocation mb 
problems 
example ada local variable contain variant record initialized default value immediately overwritten assignment initializations function entry expensive simple stack pointer adjustment expect 
deal number complications arising arbitrary limitations sun ada compiler 
example hard internal limit depth syntactically nested blocks required perform transformation mil function bodies lifts nested blocks top function 
unfortunately transformation broadens syntactic scope local variables substantially increases stress ada compiler register allocator 
performance benchmarks simple benchmark results indicate compiler generates code quite competitive quality established standard ml new jersey compiler 
measure effects refined closure analysis unboxed closure representations 
summary benchmark results table 
life implementation conway game life making heavy higher order functions inner loop processes list pairs integers mark flat 
fft implementation fast fourier transform due xavier leroy template supports ml ada simple operations arrays reals 
lambda calculus interpreters evaluating factorial function direct style continuation passing style taken bondorf 
sieve list version sieve eratosthenes 
mess parses simple bit messages rml code generated message specification language application generator kieburtz 
row represents behavior standard ml new jersey 
rows represent behavior compiler generating variety compilation settings resulting compiled gcc noted linked boehm demers weiser conservative garbage collector boehm weiser 
row standard represents standard configuration compiler 
particular flat non heap datatype representations non recursive closure types 
execution times compiler small factor sml nj substantially better cases 
figures considered rough indication comparable performance numerous differences systems exact comparison difficult 
example sml nj checks overflow integer arithmetic operations profiling results indicate difference irrelevant particular benchmarks 
seriously performance system heavily influenced amount physical memory allocated memory management system start difficult control quantity ensure fair comparison 
flow flat represents configuration invoke explicit closure analysis described section continue larger flat representations closure types flow boxed analysis uses boxed representations closure types 
comparing figures indicates refined closure analysis occasionally worthwhile conjunction flat representation closure types 
comparisons flat vs boxed closure representations may skewed relatively slow boehm demers weiser collector probably penalizes heavy heap allocation disproportionately system efficient built allocator 
get better evidence flat closures types worthwhile linked generated code flow flat flow boxed heap memory management implementation allocation single large array garbage collection 
results shown flow flat flow boxed 
cheap heap management despite fact gcc doesn generate particularly code handling flat structures substantially lower heap allocation requirements flat approach lead measurable speed improvement 
conclude flat closure allocation worth investigation optimization technique functional language compilers 
versions compiler described translation system years 
generates working ada ansi code tolmach oliva respectable performance relative established functional language compilers level type safety 
handled rml input programs lines 
generated ada components integrated air force generic command center demonstration environment meeting specific goals project originally undertaken 
broadly believe template approach promising alternative previous interoperability schemes strongly typed functional languages 
perform detailed comparisons existing non functional glue languages tcl 
plan extend template definitions include specifications algebraic laws capture important optimizations arithmetic constant folding 
believe simple approaches handling higherorder functions may generally useful implementing type preserving compilers 
researchers tarditi peyton jones ability type check intermediate representations invaluable uncovering bugs course compiler development :10.1.1.27.353
type systems required intermediate languages considerably simpler needed systems 
developed new uses type information late stage optimization programs see opportunities apply conventional optimization techniques order sil code 
ability generate efficient monomorphic data representations avoid heap allocation closures important impact performance 
effects polymorphic function cloning code size need thorough investigation 
significant restriction system requires access entire rml program polymorphism removal higher order removal algorithms program transformations 
believe problem partly addressed providing separately compiled components digest relevant type function information components 
appel 

compiling continuations 
cambridge university press 
appel jim 

continuation passing closure passing style 
sixteenth acm symp 
principles programming languages pages new york 
acm press 
appel jim 

shrinking lambda expressions linear time 
journal functional programming 
appear 
baker 

unify conquer garbage collection updating aliasing functional languages 
proc 
acm conference lisp functional programming pages 
bell 

implementation method modern functional language 
master thesis oregon graduate institute 
bell bellegarde hook 

type driven 
proc 
nd international conference functional programming pages 
ml ada bellegarde hook 

substitution formal methods case study monads transformations 
science computer programming 
boehm 
weiser 

garbage collection uncooperative environment 
software practice experience 
bondorf 

automatic higher order recursive equations 
science computer programming 
bondorf jrgensen 

efficient analyses realistic line partial evaluation 
journal functional programming 
cardelli 

compiling functional language 
proc 
acm conference lisp functional programming pages 
cardelli 

basic polymorphic typechecking 
science computer programming 


efficient way compiling ml proc 
acm workshop ml applications pages 
chin 
darlington 

higher order removal method 
lisp symbolic computation 


optimizing ml compiler 
proc 
acm workshop ml applications pages 
damas 

type assignment programming languages 
phd thesis university edinburgh 
flanagan sabry duba felleisen 

essence compiling continuations 
sigplan notices 
proceedings acm sigplan conference programming language design implementation 
hindley 

principal type scheme object combinatory logic 
trans 
amer 
math 
soc 


portable interface standard ml new jersey 
available cm bell labs com lorenz papers ps 
jagannathan wright 

flow directed inlining 
proceedings acm conference programming language design implementation pages 
jones 

partial evaluation dictionary free overloading 
technical report yaleu dcs rr yale university dept computer science 
kelsey 

correspondence continuation passing style static single assignment form 
proc 
acm sigplan workshop intermediate representations pages 
kieburtz bellegarde bell hook lewis oliva sheard walton zhou 

calculating software generators solution specifications 
tapsoft volume lncs pages 
springer verlag 
koch olesen 

compiling higher order call value functional programming language risc stack regions 
master thesis university copenhagen 
diku dissertation 
kranz kelsey rees hudak philbin adams 

orbit optimizing compiler scheme 
sigplan notices 
proceedings acm sigplan symposium compiler construction 
lawall danvy 

separating stages continuation passing style transformation 
conference record twentieth annual acm symposium principles programming languages pages charleston south carolina 
leroy 

zinc experiment economical implementation ml language 
technical report inria 
tolmach oliva leroy 

unboxed object polymorphic typing 
conference record nineteenth annual acm sigplan sigact symposium principles programming languages pages 
leroy 

objective caml system documentation user manual version 
inria 
milner 

theory type polymorphism programming 
computer system sciences 
milner tofte harper macqueen 

definition standard ml revised 
mit press cambridge ma 
minamide morrisett harper 

typed closure conversion 
conference record popl rd acm sigplan sigact symposium principles programming languages pages 
morrisett 

compiling types 
phd thesis carnegie mellon university 
available tr cmu cs 
morrisett felleisen harper 

models memory management 
fpca sigplan sigarch wg conference functional programming languages computer architecture pages 
palsberg 

closure analysis constraint form 
acm transactions programming languages systems 
peyton jones 

implementing lazy functional languages stock hardware spineless tagless machine 
journal functional programming pages 
peyton jones 

compilation transformation report 
european symposium programming esop volume lncs pages 
peyton jones hall hammond partain wadler 

glasgow haskell compiler technical overview 
proc 
uk joint framework information technology technical conference keele 
peyton jones nordin reid 

green card foreign language interface haskell 
proc 
acm haskell workshop 


elements functional programming 
addison wesley 
reynolds 

definitional interpreters higher order programming languages 
acm national conference pages 
acm 
sestoft 

replacing function parameters global variables 
master thesis university copenhagen 
diku master thesis 
shivers 

control flow analysis higher order languages 
phd thesis carnegie mellon university pittsburgh pa cmu cs 
steele 

rabbit compiler scheme 
technical report ai tr mit cambridge ma 
talpin 
jouvelot 

polymorphic type region effect inference 
journal functional programming 
tarditi 

design implementation code optimizations type directed compiler standard ml 
phd thesis carnegie mellon university 
technical report cmu cs 
tarditi lee acharya 

assembly required compiling standard ml acm letters programming languages systems 
tarditi morrisett cheng stone harper lee 

til type directed optimizing compiler ml 
proceedings acm sigplan conference programming language design implementation pages 
tofte birkedal elsman olesen sestoft bertelsen 

programming regions ml kit 
technical report university copenhagen department computer science diku 
ml ada tofte talpin 

region memory management 
information computation 
tolmach 

combining closure conversion closure analysis algebraic types 
workshop types compilation tic 
boston college computer science technical report 
volpano kieburtz 

software templates 
proceedings eighth international conference software engineering pages 
ieee computer society 
volpano kieburtz 

templates approach software reuse 
perlis editors software reusability pages 
acm press 
wadler 

theorems free 
proceedings th int 
conf 
functional programming languages computer architecture pages 
warren 

higher order extensions prolog needed 
hayes michie pao editors machine intelligence pages 
edinburgh university press 
wright 

simple imperative polymorphism 
lisp symbolic computation 
