composing contracts adventure nancial engineering functional pearl simon peyton jones microsoft research cambridge simonpj microsoft com jean marc technologies paris com julian seward university glasgow microsoft com th july financial insurance contracts sound promising territory functional programming formal semantics fact discovered insights programming languages bear directly complex subject describing valuing large class contracts 
introduce combinator library allows describe contracts precisely compositional denotational semantics says contracts worth 
sketch implementation combinator library haskell 
interestingly lazy evaluation plays crucial role 
consider nancial contract right choose june receive jan 
pay feb 
option dec choose receive jan 
pay feb 
receive jan 
pay feb 
details contract important simpli ed realistic example sort contract traded nancial derivative markets 
important complex contracts formed combining simpler contracts turn formed simpler contracts appear international conference functional programming montreal sept point red functional programmer start foam mouth build combinator library 
turns possible tremendously bene cial 
nance industry enormous vocabulary jargon typical combinations nancial contracts swaps futures caps spreads straddles captions european options american options list goes 
treating individually having large catalogue prefabricated components 
trouble soon want contract catalogue 
de ne contracts xed precisely speci ed set combinators better position having xed catalogue 
start easier describe new unforeseen contracts 
systematically analyse perform computations new contracts described terms xed set primitives 
major thrust draw insights study functional programming illuminate world nancial contracts 
speci cally contributions de ne carefully chosen set combinators extended sequence examples haskell show combinators describe wide variety contracts section 
combinators describe contract want process contract 
notably want able nd value contract 
section describe give valuation semantics combinators 
fundamentally important property semantics compositional value compound contract combining values sub contracts 
sketch implementation valuation semantics example simple interest rate model associated lattice section 
lazy evaluation turns tremendously important translating compositional semantics modular implementation section 
stated way sounds perfectly routine application idea functional language contract observable date time currency dimensionless real value value process random variable notational conventions de ne domain speci combinator library effectively creating application speci programming language 
languages de ned parsers music animations hardware circuits 
standpoint nancial engineers language truly radical acknowledge lack precise way describe complex contracts bane lives taken long time boil immense soup actively traded contracts reasonably small set combinators done new open single formal description drive manner automated processes 
example generate schedules back oce contract execution perform risk analysis optimisations contracts new graphical ways decision trees provide animated simulations 
addressed functional programming audience 
introduce nancial jargon go 
getting started section informally introduce notation contracts show build complicated contracts simpler ones 
functional language haskell 
simple contract consider simple contract known industry zero coupon discount bond receive st january 
specify contract name contract gbp summarises notational conventions variables de nition 
combinator de nition type date double currency contract rst argument date speci es particular moment time date time 
provide function date converts date expressed friendly character string date 
date string date quote informal response draft de ne date date date gmt jan date gmt feb need subtract dates get time di erence add date time di erence get new date 
type days double time difference diff date date days add date days date represent time di erence oating point number units days parts days important 
combining contracts lets build simple contract 
combine contracts bigger contracts 
example combining form type contract contract contract de ne contract involves payments contract gbp holder contract bene payment time payment time 
general contracts describe parties holder contract counter party 
notwithstanding advice acts default owner contract receives payments choices speci ed contract 
situation reversed give combinator give contract contract contract give simply rights obligations reversed statement precise section 
parties agree contract acquires contract simultaneously acquires give counter party 
example contract holder receives time pays time give far de nitions de ned new contract 
easy de ne new combinator function builds contract 
example de ne contract contract contract give give alternative de nition built earlier haskell function turned operator enclosing back quotes 
ability de ne new combinators just built quite routine functional programmers nancial engineers 
building contracts completed informal 
section give full set primitives show wide variety contracts built 
gives primitive combinators contracts introduce primitives need 
acquisition date horizon gives english language quite precise description combinator 
uses technical terms acquisition date horizon 
introducing brie language describes contract consequences holder contract depends date contract acquired acquisition date 
consequences holder mean rights obligations contract confers holder contract 
example contract receive jan receive jan worth lot acquired jan rights obligations fall due acquisition date simply discarded 
second fundamental concept contract horizon expiry date horizon expiry date contract latest date acquired 
contract horizon may nite nite 
horizon contract completely speci ed contract contract easily horizon de nitions 
note carefully contract rights obligations may principle extend horizon 
example consider contract right decide jan contract 
sort contract called option 
horizon jan acquired date acquires underlying contract may typically consequences extending jan 
reiterate horizon contract property contract acquisition date 
discount bonds earlier described zero coupon discount bond receive time section 
time assumed primitive combinator fact isn 
obtained composing fewer primitive combinators 
combinator gbp gives careful albeit informal de nition acquire gbp immediately receive 
contract nite horizon restriction acquire contract 
bond want pays earlier regardless bond acquired 
obtain ect combinators get truncate get truncate gbp truncate contract horizon acquired 
get contract acquired acquires underlying contract horizon possible moment regardless composite contract get acquired 
combination exactly ect want horizon truncate gbp exactly 
get truncate de ned 
nished 
bond want pays 
combinator scale contract get truncate gbp de ne shortly section 
type double contract contract acquire acquire payments receipts multiplied nally de ne correctly date double currency contract get truncate de nition ectively extends repertoire combinators just section usefully 
continually extend library combinators way 
go trouble de ning terms combinators making primitive 
turns get truncate independently useful 
embodies distinct piece functionality separating signi cantly simplify semantics enrich algebra contracts section 
combinators result extended iterative process re nement leading interlocking set decisions programming language designers quite familiar process 
observables scaling real contract mentions quantities measured particular date 
example contract say receive amount dollars equal noon temperature los angeles pay amount pounds sterling equal month spot rate multiplied 
term observable objective time varying quantity 
objective mean particular time observable value parties contract agree 
temperature los angeles objectively measured value insuring house subjective observable 
observables di erent kind thing contracts give di erent type spot rate published daily nancial press 
purposes matter means matters observable quantity 
zero contract zero contract may acquired time 
rights obligations nite horizon 
section currency contract contract immediately pays holder unit currency contract nite horizon 
section give contract contract acquire give acquire rights obligations vice versa 
note bilateral contract parties acquiring implies acquires give 
section contract contract contract acquire immediately acquire expired expired 
composite contract expires expire 
section contract contract contract acquire immediately acquire 
expired chosen 
expired compound contract expires 
section truncate date contract contract truncate exactly expires earlier horizon notice truncate limits possible acquisition date truncate rights obligations may extend 
section contract contract contract acquire expired acquire 
expired acquire 
compound contract expires expire 
section scale obs double contract contract acquire scale acquire moment rights obligations multiplied value observable moment acquisition 
section get contract contract acquire get acquire expiry date 
compound contract expires moment expires 
section anytime contract contract acquire anytime acquire time acquisition anytime expiry compound contract expires 
section primitives de ning contracts obs double obs double general value type obs represents time varying quantity type previous section scale contract xed quantity 
primitive combinator scale scales contract time varying value observable scale obs double contract contract aid scale de ne strange realistic contract receive amount dollars equal noon temperature los angeles scale usd precise de nitions 
exactly noon temperature la sampled 
answer acquire scale immediately acquire scaling payments receipts value observable sampled moment acquisition 
sample observable single de ned moment acquisition date single number scale subsequent payments receipts useful observable value time obs aid de ne double contract contract scale arithmetic combination observables observable 
example may write obs double addition operator add observables observables instance num class operations addition subtraction multiplication instance num num obs readers unfamiliar haskell type classes need worry need employ usual arithmetic operators observables 
observables operations course reminiscent fran behaviours :10.1.1.17.7696
fran provide combinators lifting functions observable level lift lift gives primitive combinators observables 
european options subtlety nancial contracts arises participants exercise choices 
encapsulate choice numeric classes real fractional obs observable value time 
lift obs obs lift observable value result applying value observable lift obs obs obs lift observable value result applying values observables 
instance num num obs numeric operations lift obs type 
implementation simple lift lift 
time date obs days value observable time time number days positive may arbitrary number primitive observables provided particular implementation 
example currency days days obs double observable equal time quoted forward rate currency time interval add add 
primitives observables primitive combinators anytime 
allows choose contracts acquire section allows choose acquire section 
consider choice contracts contract contract contract acquire contract immediately acquire 
clearly chosen horizon similarly 
horizon latest horizons 
acquiring composite contract example horizon horizon means choose acquire contract 
example contract gbp gbp gives holder right acquired min choose immediately receive alternatively receive 
called european option gives right choose particular date acquire underlying contract european date contract contract example consider contract european date apr date may gbp date may gbp date may gbp give date apr gbp contract gives right choose apr acquire underlying contract consisting receipts payment 
nancial industry kind contract called call coupon bond giving right date buy bond prescribed price 
de ne european terms simpler elements european date contract contract european get truncate zero read de nition follows primitive contract zero rights obligations zero contract contract zero expresses choice acquiring acquiring 
trim horizon contract zero primitive combinator truncate 
get combinator acquire horizon 
repeatedly encounter pattern truncate zero package new composite combinator date contract contract truncate zero american options combinator lets choose contracts acquire 
consider choice acquire contract anytime contract contract acquiring contract anytime gives right acquire underlying contract time acquisition date anytime horizon 
note acquired albeit latest possible date 
american option ers exibility european option 
typically american option confers right acquire underlying contract time dates 
rst incorrect attempt de ne contract say american date date contract contract american wrong anytime obviously wrong mention 
arrange acquire american contract bene ts acquired 
attempt american wrong get truncate anytime wrong allow acquire american contract 
really want say get get 
express combinator american get truncate opt opt opt contract opt anytime give intermediate contract opt arbitrary name clause need twice 
new combinator de ned follows acquire contract expires acquire acquire expired 
summary approach de ning contracts 
combinators de ned far describe contracts actively traded extending set ongoing 
main una ected financial contracts described purely declarative way 
huge variety contracts described terms small number combinators 
identifying right primitive combinators quite challenge 
example breakthrough identify separate forms choice anytime encapsulate choices combinators 
valuation disposal rich language describing nancial contracts 
useful communicating people industry lacks precise notation 
addition precise description lends automatic processing various sorts 
single contract description may hope generate legal pictures schedules 
immediate question ask contract worth 
pay contract 
question turn 
express contract valuation layers evaluation semantics 
show translate arbitrary contract written language value process handful operations processes 
processes correspond directly mathematical stochastic machinery nancial experts 
concrete implementation 
process mathematical value 
computer calculate processes represent step semantics concrete implementation 
implementation consist nancial model associated discrete numerical method 
tremendous number di erent nancial models today families numerical methods widely industry partial di erential equations monte carlo lattice methods 
approach strongly reminiscent way compiler typically structured 
program rst translated low level machine independent intermediate language optimisations applied level program translated instruction set desired processor pentium sparc 
similar way transform contract value apply meaning preserving optimising transformations intermediate representation computing value process 
step done imagine generating specialised code run perform valuation 
semantics serves model means contracts 
example claims get get get give give give fact rst true second know sure 
answer compare valuation semantics shall see section 
value processes de nition value process 
value process type partial function time random variable type random variable describes possible values time write informal type de nition pr dat 
rv font types semantic level 
need di erent processes de ned underlying space ltration value process precisely described adapted stochastic process ltration 
processes come equipped sophisticated mathematical theory familiar computer scientists informal intuitive notions 
usually abbreviate value process simply process 
warned process variable mean quite di erent things conventional computer science meanings 
contracts observables modeled processes 
underlying intuition follows value process observable maps time random variable describing possible values example value process observable ibm stock price total function maps time real valued random variable describes possible values ibm stock price 
obs pr time time lift lift lift lift omitted evaluation semantics observables value process contract expressed currency partial function time random variable describing value currency acquiring contract time intuitions essential understand rest 
value process general partial function time may de ned values argument 
observables de ned time need exibility de ne total processes 
contracts de ned time value process contract unde ned times horizon 
contracts processes go contracts observables processes 
gives complete translation contracts processes observables 
figures look impressive point 
far leading point entire design organised desire give simple tractable modular valuation semantics 
look detail 
function takes contract maps process describing moment time value currency acquiring moment 
example equation give says value process give simply negation value process aha 
negation mean 
clearly need notion value process collection operations processes 
negating processes operation negation process simply function maps time negation 
absolutely straightforward exercise lift operations real numbers operate point wise processes 
turn requires negate random variable doing simple 
need number operations processes 
summarised introduce need 
consider equation 
contracts modeled sum value processes need equations give value earlier horizon contracts earlier vice versa 
fourth case times horizons evaluation function simply unde ned 
notation indicate corresponding equation applies part time domain 
primitives independent evaluation model pr process de ned times value time dat pr process time de ned times number days positive lift pr pr apply speci ed function argument process point wise 
result de ned arguments process de ned 
lift pr pr pr combine argument processes point wise speci ed function 
result de ned arguments de ned 
primitives dependent particular model disc pr primitive disc maps real valued random variable date expressed currency fair equivalent stochastic value process currency pr real valued process representing value unit expressed currency 
simply process representing quoted exchange rate currencies 
snell pr pr primitive snell calculates snell envelope argument 
uses probability measure associated currency model primitives speci es formally calculate horizon contract returns horizon contract nite horizon extend min max obvious way 
equation combinator 
design combinator maps simple mathematical operation max 
wonder de ned value process partial function total function zero horizon 
equation gives answer horizon forced choose 
general max equation nice simple 
scale contract time varying observable simply multiply value process contract value process observable remember modeling observable value process 
express de ned similar fashion 
rst odd scale point wise scaling applies payments receipts 
recall value contract pr give ft ft ft max ft ft ft scale zero truncate ft tg ft ft get disc anytime snell compositional evaluation semantics contracts zero max max max truncate min scale anytime get de nition horizon process time gives value acquiring value value acquiring contract payments receipts scaled certainly de nition scale fact driven directly desire express semantics simple way 
simple semantics gives rise simple algebraic properties section 
equations zero truncate easy 
equation delivers constant zero process equation truncates process simply limiting domain remember time argument process models acquisition date 
combinator equation behaves rst process domain second 
exchange rates top group operations value processes de ned generic unrelated particular nancial model 
get away 
lower group primitives gure speci nancial contracts remaining equations 
consider equation 
says get value process unit currency expressed currency simply exchange rate process exch 
get exchange rate processes 
come implementation need numerical assumption evolution exchange rates suces treat exchange rate processes primitives 
important relationships 
notably exchange rate process currency unity di erence convert directly go intermediate currency particular cases conditions wonder er spread encountered traveller counter 
order keep things technically tractable nance theory assumes time absence spreads typically rst computes fair price nally adding pro margin 
gives rise spread modelling applies 
interest rates consider equation 
get combinator acquires underlying contract horizon 
get unde ned nite horizon 
matter value earlier times matters value horizon described random variable ek 
value get earlier times 
answer question need speci cation arbitrage condition excludes risk free opportunity earn money 
opportunity exist take opportunity soon go away 
evolution interest rates interest rate model 
consider concrete example get truncate gbp year today 
underlying contract truncate gbp pays immediately acquired get acquires horizon value just 
worth 
expect interest rates average say year fair price today 
just primitive exch encapsulates assumptions exchange rate evolution primitive disc encapsulates interest rate evolution 
maps random variable describing particular currency particular date process describing value earlier dates currency 
exch properties arbitrage nancial model satisfy 
notably disc disc disc disc disc disc rst equation says disc identity horizon second says interest rate evolution di erent currencies compatible assumption evolution exchange rates 
third right left direction optimisations perform discounting random variables separately add resulting process trees faster add random variables single column discount result 
just optimising compiler may identities transform meaning contract form faster execute 
careful 
plausible property hold disc max max disc disc plausible hold single numbers disc simple multiplicative factor 
random variables property false 
equation uses snell operator give meaning anytime 
operator mathematically subtle simple characterisation snell smallest process exercise option time anytime times better disc 
defer exercising option anytime better contract acquired 
observables value contracts observables model 
example value contract involving associated risk neutral probability go nancial details 
educated reader note assume implicitly called complete markets 
temperature los angeles model temperature los angeles 
observables clearly require separate models 
rate price futures modeled value particular contracts 
omit details gives semantics simplest observables 
unrealistic 
write large range contracts contract combinators simple observables 
reasoning contracts ready semantics answer questions posed section 
equation valid 
get get get take meaning left hand side arbitrary currency ek get get disc ek get disc disc ek disc disc ek disc ek ek get get similar way argue plausible equation false give give give proof routine core observation max max back real world point left hand side gives choice counter party right hand side choice holder contract 
combinators satisfy rich set equalities get 
equalities side conditions example scale scale scale holds exactly reason get commute 
hang 
mean say 
mean positive time 
generally equalities contracts developed notion ordering observables contracts pronounced dominates 
equalities ones optimising transformations valuation engine 
contract compiler transform contract expressed intermediate language value processes see section form valued cheaply 
summary completes description evaluation semantics 
programming language point view short term interest rate evolution quite routine including proofs 
stress unusual nd formal proofs nance industry level abstraction 
named complicated primitives disc exch laws satisfy give way prove identities contracts having understand random variables 
mathematical details arcane believe 
implementation evaluation semantics beast 
regard figures translation contract language lower level language processes combinators primitives 
optimise process level description 
ha 
need implement primitives able value arbitrary contract 
key decision course implement value process 
value process represent uncertainty explicit way 
numerous ways model uncertainty 
sake concreteness simply pick ho lee model lattice method evaluate contracts 
choose model numerical method technical simplicity historical importance section applicable models black toy 
changing numerical method monte carlo entail bigger changes language semantics sections ected 
entirely possible di erent numerical methods di erent parts single contract 
ho lee valuation lattice interest rate model typical ho lee numerical scheme interest rate evolution represented lattice recombining tree depicted 
column tree represents discrete time step time increases left right 
time zero represents 
usual discrete models issue long time step won discuss note passing time steps need uniform size 
node tree associated period short term interest rate shortly interest rate 
know today interest rate rst column tree just element 
uncertainty interest rates evolve rst time step 
expressed having interest rate values second column idea interest rate evolve values equal probability 
third time step rates split path joins path rates third column 
structure called lattice scheme computationally feasible giving linear growth width tree time 
course tree discrete approximation continuous process recombining nature just choice eciency reasons 
write vector rates time step th member vector starting bottom 
example 
actual numbers unrealistically regular elaborated interest rate models evenly spaced monotonically distributed column 
value processes interest rate model 
value process modeled lattice exactly shape interest rate evolution value node interest rate 
shows value process tree favourite zero coupon bond get truncate gbp evaluated pounds sterling gbp 
evaluation semantics disc gbp assume time time step 
step value contract certainly nodes unconditionally delivers time remember axiom 
time step discount interest rate appropriate time step 
compute value node time step averaging values successors discounting average value back time step interest rate associated node notation value tree rate model get equation 

size time step 
equation ll rest values tree done 
value time step current value contract pounds sterling 

short lattice implementation works follows value process represented lattice column discrete representation random variable 
value node possible values variable take simple setting number paths root node proportional probability variable take value 
say bit represent tree subsection 
generic operations top half easy implement 
value process equal time process values particular column equal number days column time lift applies point wise lift zips combining corresponding values point wise model speci operations bit harder 
described implement disc uses interest rate model 
exch easier multiply value process point wise process representing exchange rate 
snell primitive takes bit describe detail 
roughly speaking possible implementation may take nal column tree discount back time step take maximum column corresponding column original tree repeat process way back root 
evident presentation reasons don care fact ho lee model member class models admit fact closed form solution zero coupon bonds 
remaining high level question big set possible interest rate models model 
answer 
candidate interest rate model price correctly contracts widely traded simply look current market prices compare calculated results 
look adjust interest rate model ts market data simple contracts 
ready model compute prices exotic contracts 
entire market gigantic feedback system active research studies problem stability 
implementation haskell partial implementations earlier versions ideas implemented haskell combinator library 
type contract implemented algebraic data type constructor primitive combinator data contract date currency give contract 
translation processes done straightforward recursive haskell implementation eval model currency contract model contains interest rate evolutions exchange rate evolutions necessary evaluate contract 
rst implementation representation value process type timestep slice type slice double value process represented pair process horizon list slices columns time step reverse time order 
rst slice horizon process slice time step earlier 
fundamental discount recurrence equation section works backwards time convenient represent list way round 
slice element shorter 
laziness plays important role reasons process trees large size quadratic number time steps cover 
complex contract represented combining value trees bad fully evaluate sub trees combine 
lazy evaluation automatically pipelines evaluation algorithm current slice value tree required moment 
part process tree may required 
consider example contract get truncate gbp value process truncate gbp complete value process way back time step zero value 
get samples value process horizon point computing value earlier time 
representing value process lazily evaluated list get right behaviour automatically 
microsoft research collaborates closely lombard risk systems production tree valuation system 
uses clever complex event driven engine value tree represented single slice mutated time progresses 
notion complete tree 
haskell implementation treats trees rst class values point view ers radical new perspective evaluation process 
hopeful insights haskell implementation may serve inform improve ecient implementation 
haskell version takes lines haskell support working albeit limited contract valuation engine complete com interface lets plugged lombard framework 
nearly fast production code slow example takes seconds compute value contract sub contracts time steps standard desktop pc 
lacks functionality compositional approach means value contracts options options production system 
production system fundamentally incapable programmed case case basis complicated cases hard implement 
functional programming terms quite straightforward 
nasty practical problem repeatedly bites people embed domain speci language functional language 
consider contract join join join join shared sub contract opt de nition american section 
trouble eval evaluate branches root oblivious fact branches 
fact eval evaluating join twice 
way eval tell seen argument 
problem arises various guises embedded domain speci language 
seen fran reactive animations diculty extracting net lists hawk circuit descriptions settings :10.1.1.17.7696
particularly frustrating sharing absolutely apparent source program 
solution suggest eval memo function nd satisfactory 
losing sharing give rise unbounded amount duplicated unpleasant relegate maintenance proper sharing operational mechanism 
example memo function may unevaluated arguments automatically purged memo tables 
simply identify important open problem deserves study 
addresses issue head proposes way sharing observable leaves open question memo functions 
putting context rst sight nancial contracts functional programming 
surprise delight discover insights useful design semantics implementation programming languages applied directly description evaluation contracts 
developing idea nearly years soci en erale 
peyton jones seward came fruitful partnership lombard risk systems original idea apply functional programming realistic problem compare resulting program existing imperative version ended radical re thinking describe evaluate contracts 
great deal domain speci programming languages see surveys virtually attempt give formal description nancial contracts 
exception risla language developed cwi object oriented domain speci language nancial contracts 
risla designed object oriented framework appears stateful declarative system 
design combinator library embedded haskell haskell proved excellent host language prototyping library design various implementation choices 
design absolutely haskell speci big payo comes declarative approach describing contracts 
happens functional language implementing contract language somewhat incidental 
equally implemented free standing language domain speci compiler technology 
just compiling contract code fast faster best available current valuation engines strict functional language ocaml implementation language 
haskell lazy useful implementation really signi cant feature language declarative lazy 
design seen declarative language entirely independent haskell readily implement valuation engine java example 
left 
need expand set contract combinators describe wider range contracts expand set observables provide semantics new combinators write prove range theorems contracts consider notion normal form sense contracts build robust implementation exploit dramatic simpli cations closed formulas possible give formal speci cation evolution contract life validate real nancial settings 
just begun 
john jurgen porter malcolm lombard risk systems collaboration 
invested great deal time educating authors peyton jones seward mysteries nancial contracts toy evaluation model 
jean marc philippe helpful discussions soci en erale nancial support 
conal elliott andrew kennedy stephen andy moran norman ramsey colin runciman david vincent icfp referees helpful feedback 
boyle 
monte carlo methods security pricing 
journal economic dynamics control 
claessen sands 
observable sharing functional circuit description 
ps thiagarajan yap editors advances computing science asian th asian computing science conference lecture notes computer science pages 
springer verlag 
cook launchbury 
disposable memo functions 
launchbury editor haskell workshop amsterdam 
cook launchbury matthews 
specifying superscalar microprocessors hawk 
formal techniques hardware hardware systems sweden 
cox ross rubinstein 
option pricing simpli ed approach 
journal financial economics 
elliott hudak :10.1.1.17.7696
functional reactive animation 
acm sigplan international conference functional programming icfp pages 
acm amsterdam august 
finne leijen meijer sl peyton jones 
calling hell heaven heaven hell 
acm sigplan international conference functional programming icfp pages paris september 
acm 
ho lee 
term structure movements pricing interest rate contingent claims 
journal finance 
hudak 
building domain speci embedded languages 
acm computing surveys december 
john hughes 
lazy memo functions 
proc workshop implementation functional languages february 
xavier leroy er ome vouillon damien doligez objective caml system release 
technical report inria available caml inria fr ocaml 
marlow sl peyton jones elliott 
stretching storage manager weak pointers stable names haskell 
international workshop implementing functional languages ifl lecture notes computer science netherlands 
springer verlag 

martingale methods financial modelling 
springer 
sl peyton jones hughes augustsson barton boutel burton fasel hammond hinze hudak johnsson mp jones launchbury meijer peterson reid runciman pl wadler 
report programming language haskell 
haskell org february 
yor 
continuous martingales brownian motion 
springer 
van deursen kline visser 
domain speci languages annotated bibliography 
technical report centrum voor wiskunde en informatica amsterdam 
van deursen klint 
little languages little maintenance 
journal software maintenance 

option pricing mathematical models computation 
oxford financial press 

