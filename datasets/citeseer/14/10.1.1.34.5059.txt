synchronous dataflow programming language lustre halbwachs caspi raymond imag grenoble pilaud verilog grenoble describes language lustre dataflow synchronous language designed programming reactive systems automatic control monitoring systems describing hardware 
dataflow aspect lustre close usual description tools domains block diagrams networks operators dynamical samples systems synchronous interpretation suited handling time programs 
synchronous interpretation allows compiled efficient sequential program 
lustre formalism similar temporal logics 
allows language writing programs expressing program properties results original program verification methodology 
reactive systems reactive systems defined computing systems continuously interact physical environment environment unable synchronize logically system instance wait 
response times system meet requirements induced environment 
class systems proposed hp ber distinguish transformational systems classical programs data available provide results terminating interactive systems interact continuously environments possess synchronization capabilities instance partially supported french ere de la recherche contract informatique prc cnrs operating systems 
reactive systems apply mainly automatic process control monitoring signal processing systems communication protocols man machine interfaces required response times small 
generally systems share important features ffl parallelism design take account parallel interaction system environment 
second implementation quite distributed reasons performance fault tolerance functionality communication protocols instance may easier imagine system comprised parallel modules cooperating achieve behavior implemented centralized way 
ffl time constraints include input frequencies input output response times 
said constraints induced environment imperatively satisfied 
specified taken account design verified important item system correctness 
ffl dependability systems highly critical ones may important feature 
just think design error nuclear plant control system commercial aircraft flight control system 
domain application requires careful design verification methods may domains formal methods higher priority design methods tools support formal methods chosen imply certain limitations 
synchronous approach opinion programming tools designing reactive systems satisfactory 
clearly assembly languages widely reasons code efficiency 
methods include classical languages programming sequential tasks cooperate synchronize services provided real time operating system parallel languages provide real time communication services 
promising criticized ber services provided low level allow programs easily designed validated appears expensive run time 
synchronous languages proposed order deal problems languages provide idealized primitives allowing programmers think programs reacting instantaneously external events 
internal event program takes place known time respect history external events 
feature limitation deterministic constructs results deterministic programs functional temporal points view 
practice synchronous hypothesis amounts assuming program able react external event event occurs 
possible check hypothesis holds program environment ideal behavior represents sensible abstraction 
pioneering esterel led propose general structure object code synchronous programs finite automaton transition consists executing linear piece code corresponds elementary reaction program 
transition code loop execution time quite accurately evaluated machine enables accurately bound reaction time program allowing synchronous hypothesis checked 
synchronous languages include see issue esterel signal statecharts sml hardware description languages bl 
dataflow approach method reliable programming high level languages languages allow natural expression problems programs 
domain reactive programming people automatic control electronic circuits traditionally people model systems means networks operators transforming flows data gates switches analog devices higher level means boolean functions transfer functions block diagram structures means systems dynamical equations capture behavior networks 
formalisms look quite similar computer scientists call dataflow systems kah gra cf 

dataflow considered high level paradigm field 
furthermore basis high level programming language possesses advantages ffl functional model subsequent mathematical particularly complex side effects 
dataflow description associated equations adapted formal verification safe program transformation functional relations dataflows may seen time invariant properties 
reuse easier interesting feature reliable programming concerns 
ffl parallel model sequencing synchronization constraints arise data dependencies 
nice feature allows natural derivation parallel implementations 
interesting notice domain people accustomed parallelism earlier times areas computer science 
synchronous dataflow may appealing develop dataflow approach reactive programming 
dataflow thought essentially asynchronous synchronous approach necessary tackle problem time instance relating time index data flows 
concern lustre project reported 
resulted proposing primitives structures restrict dataflow systems implemented bounded memory automata programs sense esterel 
language programming examples section 
compiling efficient code generation matters discussed section 
second main concern project take advantage approach developing techniques formal verification section 
idea consider lustre specification language declarative aspect 
shown compiler tool verifying program correctness respect specifications 
section presents current activities project related hardware distributed implementations 
comparisons existing approaches discussed 
lustre language flows clocks lustre variable expression denotes flow pair ffl possibly infinite sequence values type ffl clock representing sequence times 
flow takes th value sequence values th time clock 
program piece program cyclic behavior cycle defines sequence times called basic clock program flow clock basic clock takes th value th execution cycle program 
slower clocks defined boolean valued flows clock defined boolean flow sequence times flow takes value true instance table displays time scales defined flow clock basic clock flow clock defined basic time scale true false true true false true false true time scale false true false true true time scale table boolean flows clocks noticed clock concept necessarily bound physical time 
matter fact basic clock considered setting minimal grain time program discriminate external events corresponds response time 
real time required implemented input boolean flow instance flow true value indicates occurrence millisecond signal 
point view provides concept time millisecond time scale program 
variables equations expressions assertions variables declared types variables correspond inputs definition form equations 
considered mathematical sense equation defines variable identical expression sequence values clock 
equation oriented sense defines way equations give properties arise definition 
provides important principle language substitution principle substituted program conversely 
consequence equations written order extra variables created give names subexpressions changing meaning program 
lustre elementary basic types boolean integer real type constructor tuple 
complex types imported host language handled types similar mechanism exists esterel 
constants basic types imported host language instance constants imported types 
corresponding flows constant sequences values clock basic 
usual operators basic types available arithmetic div mod boolean relational conditional functions imported host language 
called data operators operate operands sharing clock operate pointwise sequences values operands 
instance basic clock sequences values respectively expression flow basic clock th value integer operators lustre called temporal operators operate specifically flows ffl pre previous acts memory sequence values expression pre clock sequence values nil gamma nil represents undefined value denoting uninitialized memory 
ffl 
followed expressions clock respective sequences expression clock sequence 
words equal time clock 
table shows effect operators ffl samples expression slower clock expression boolean expression clock expression clock defined sequence extracted keeping values indexes corresponding true values sequence words sequence values true ffl current interpolates expression clock immediately faster 
expression clock basic boolean expression defining clock 
current clock value time clock value time true false true false true false false true true current nil table sampling interpolating equations body lustre program may contain assertions 
generalize equations consist boolean expressions true 
primary give compiler indications order optimize code environment program possesses known properties see 
instance know input events represented boolean variables occur time shall write assert similarly assertion assert true 
pre says event occurs twice row 
note initialization true prevents occurrence value nil forbidden assertions clocks output sequences cf 

code optimization assertions play important role program verification cf 

program structure lustre system equations represented graphically network operators 
instance equation 
pre defines counter basic clock cycles corresponds network 
naturally suggests notion subroutine subnetwork encapsulated new reusable operator called node 
node declaration consists interface specification providing input output parameters types possibly clocks optional internal variables declarations body equations assertions defining outputs internal variables function inputs 

counter network instance node defines general purpose counter having inputs initial reset value increment value reset event node counter val init val incr int reset bool returns int val init 
reset val init pre val incr tel 
node functionally expression 
instance counter false modulo counter pre modulo define sequence numbers cyclic sequence modulo numbers basic clock 
similarly gamma acceleration expressed meter second clock rate speed counter gamma false position counter speed false substitution principle equivalent position counter counter gamma false false node may outputs case output tuple 
instance node gamma int returns speed position int speed counter gamma false position counter speed false tel 
concerning clocks basic clock node defined inputs consistent dataflow point view 
instance expression counter false counts true example operator applies tuple false table shows result expression difference expression counter false sampling applies output node inputs 
true false true false true false false false false counter false counter false counter false table nodes clocks example stresses interest clocks reuse clocks available way getting effect required modify node adding input 
node may admit input parameters distinct clocks 
faster basic clock node clocks input declaration list 
example node millisecond bool int bool millisecond returns basic clock node millisecond clock defined millisecond 
outputs node may clocks different basic clock 
clocks visible outside node 
note clocks certainly slower basic 
programming examples linear systems translating sampled linear systems lustre programs quite obvious task systems expressed transform equations amounts translating gamma operator 
pre 
instance consider nd order filter az bz dz equivalent counter false output written ax bx gamma dy gamma cx gamma ey gamma yields program const real 
node secondorder real returns real var real pre pre tel 
furthermore clocks allow easy extension multiply sampled systems 
non linear time varying systems letting identifiers parameters second order node constants yields time varying filter 
non linear systems easy describe 
instance rho cos theta 
pre theta logical systems previous discussion dataflow programs signal processing systems close specification terms systems dynamical equations 
systems important logical component instance monitoring systems essentially logical systems 
systems described terms automata parallel automata statecharts instance petri nets imperative formalisms describe states transitions states 
question adequacy dataflow paradigms provide easy descriptions systems carefully checked 
examples intended show paradigms may allow easy incremental modular descriptions logical systems 
subsection shall consider versions watchdog device monitors response times 
version receives events set reset commands deadline occurrence 
output alarm raised deadline occurs received command set 
usual events represented boolean variables value true denotes presence event 
watchdog lustre node having boolean inputs set reset deadline emitting boolean output alarm 
order equations unimportant defining output alarm true deadline true true command set 
local boolean variable expressing condition 
write alarm deadline remains define true time set true false time reset true initially true set true false set 
set true reset false pre furthermore assume set reset commands take place time expressed assertion 
full program node wd set reset deadline bool returns alarm bool var bool alarm deadline set 
set true reset false pre assert set reset tel 
consider second version receives commands raises alarm reset occurred time set time number basic clock cycles 
new program reuses node wd providing appropriate deadline parameter reception set event register initialized decremented 
deadline occurs register value reaches zero built general purpose node edge returns true rising edge input node edge bool returns edge bool edge false 
pre tel 
node wd set reset bool delay int returns alarm bool var remain int deadline bool alarm wd set reset deadline deadline false 
edge remain remain set delay pre remain pre remain pre remain tel 
assume delay expressed time scale number occurrences event 
just call wd appropriate clock wd catch time units commands properly initialized alarm yields nil node wd set reset bool delay int returns alarm bool var clock bool alarm current wd set reset delay clock clock true 
set reset tel 
coming back question raised section see programs written referring transitions states describing states terms state variables stating strongest invariant property state variable 
state variables evolve parallel recreating global state system 
shown bfh finite state machine described boolean lustre program 
mixed logical signal processing systems mixing signal processing logical systems quite easy task signal processing parts provide logical ones boolean expressions relational operators conversely logical components control signal flows means conditional operators current 
lustre compiler describe main techniques lustre compiler pla 
prototype compiler written le lisp john plaice 
static verifications static formedness checking clearly important issue framework reliable programming aims avoiding overhead dynamic checks run time 
classical type checking main checks performed compiler ffl definition checking local output variable equational definition 
ffl absence recursive node call view obtaining automata executable programs lustre allows static networks described 
problem structuring recursive calls property maintained investigated 
ffl clock consistency intensively discussed 
ffl absence uninitialized expressions yielding nil values 
expressions accepted far concern clocks outputs assertions 
ffl absence cyclic definitions cycle network contain pre operator 
sense kah equation meaning solution respect prefix ordering sequences case solution empty sequence interpreted deadlock 
rejected 
note lustre rejects structural deadlocks true ones reason analysis networks undecidable general discuss clock calculus represents original aspect lustre respect dataflow languages 
program illustrates reason calculus true 
pre second equation data operator combines flows distinct clocks 
standard dataflow philosophy program meaning 
easy see computation th value needs th th values reactive system may assumed run required memory certainly overflow 
program compiled bounded memory object code speak physical consisting adding time time 
clock calculus consists associating clock expression program checking operator applies appropriately clocked operands ffl primitive operator argument applies operands sharing clock ffl clock operand current operator basic clock node belongs ffl clocks node operands obey clocks requirements stated node definition header 
define mean clock 
ideally mean boolean flow may require semantical analysis undecidable general 
compiler uses restricted notion equality boolean expressions define clock unified means syntactical substitutions 
consider example contrast signal lustre allow basic clock time intervals split smaller ones 
copies cyclic call share clock considered distinct clock rules clock calculus formally described pla 
node expansion lustre compiler produces purely sequential code 
raises question compiling nodes nodes 
example shows easily done lustre node int returns int 
clearly possible sequential codes basic cycle node choice programs may depend way node node instance corresponding 
case program correct 
compiling program compiler expands recursively nodes called program formal parameters substituted actual ones local variables unique name distinguish node call instances node called node body inserted calling node body 
code generation step start flat node call node shall see separate compiling technique apply 
single loop code obvious way associating imperative program lustre node consists constructing infinite loop body implements inputs outputs transformation performed basic cycle node 
done ffl choosing variables computed output ones possible number local ones implement memories temporary buffers ffl defining actions update variables ffl choosing ordering actions dependencies variables induced network structure node 
example consider modified version watchdog wd node wd set reset bool delay int returns alarm bool var bool remain int alarm remain pre remain false 
set true reset false pre remain 
set delay pre remain pre remain pre remain assert set reset tel 
single loop body executed program reaction looks init cycle false remain alarm false init false cycles set true remain delay reset false endif remain endif endif alarm remain endif write alarm remain remarks ffl compiler defined auxiliary variables variable init assumed initialized true implement operator 
memory variable pre remain 
note expression pre set result creation memory variable compiler way avoid 
ffl easy find ordering actions meets dependency relations variables static checks described ensure order exists choice order quite difficult particularly order conditional statements opened closed critical respect code length 
ffl code speed improved 
note instance cycle program tests particularly awkward 
solution consists complex control structures single loop structure 
discussed section 
automaton code search complex control structures borrowed compiling technique esterel remarks ffl classical concept control imperative programs represented lustre means boolean variables acting conditional clock handling operators 
ffl condition clock depends values boolean variable computed previous cycles means expression pre current code actual cycle simpler value assumed known 
distinguish code executed value 
synthesis control structure consists choosing set state variables boolean type values expected influence code cycles 
set variables called state program takes finite set values 
possible value state defines sequential code executed cycle state variables values just execution cycle 
starting state executing corresponding code result computing state ready execution cycle 
static reachability analysis performed delete state values transitions reached initial state matter fact reachability analysis done generating state values transitions avoid generating useless items 
result finite state automaton transitions labeled code corresponding reaction 
state variables chosen ways ffl boolean expressions resulting pre current operators ffl auxiliary variables init associated clock value true clock cycle false allow evaluation 
operators 
control synthesis illustrated watchdog example wd cf 
chosen state variables pre set init 

cycle yields pre set nil init true 
initial state 
init true state value 
operators operand 
set false remain 
elementary boolean calculus yields alarm false 
furthermore set evaluates false value pre set state 
state pre set false init false 
state code looks remain alarm false remain goto 
state pre set value false set evaluates true input set value true 
state pre set true init false 
code state set remain delay alarm remain remain goto remain alarm false remain goto endif 
code state pre set true init false follows set remain delay alarm remain remain goto reset remain alarm false remain goto remain alarm remain remain goto endif endif reachable states processed ends code generation 
display resulting automaton 
reset set set reset watchdog control automaton remarks ffl obtained transition codes simpler single loop code particularly codes 
reduction may impressive larger programs 
ffl contrast length code may large 
practice action code table built uniquely identifies actions may belong transitions transition codes refer actions means indexes table 
ffl boolean expressions depending non boolean variables needed computing state variables integer comparison instance handled inputs means tests value 
ffl technique allows assertions fully taken account 
assertions computed way state variables branch yielding false assertion deleted 
state total code deleted declared unreachable branches computed lead state recursively deleted 
noticed assertions may increase number state variables reachable states increase code length inducing extra tests 
ffl contrast esterel automata obtained lustre automata far minimal question dis cussed 
entails need minimization 
esterel lustre environment automata produced lustre compiler expressed oc format ps esterel compiler 
common tools take format input code generators translators le lisp ada languages designed esterel team 
produce procedure implements code corresponding transition automaton 
automaton minimizer aldebaran fer minimizer interfaced oc 
allows minimal equivalent automata obtained oc particularly useful case lustre 
interfaces proof tools automata common basic model analysis verification tools parallel systems 
appealing experiment tools operating oc automata 
oc interfaced auto ver 
experiments performed emc ces 
shall see section proof techniques apply specifically lustre 
display tools oc language designed internal code representation lacks readability 
checks debugging purposes translators readable representations graphic display rs code developed 
verification noted reactive systems concern critical applications program verification key issue 
practitioners field skeptical formal verification methods convincing arguments need provided order support claim methods practical interest 
object discussion 
research program verification started early seventies intended provide complete proofs general programs 
led important contributions concerning programming techniques language design admit practice limited 
goal concerning reactive systems may ambitious 
safety critical application depend total correctness control program small set properties program fulfill 
instance occurrence critical situation raise alarm delay 
experience proof properties handled framework simple decidable theories properties seldom depend numerical relations computations 
furthermore properties safety properties state situation appear statement hold contrast liveness properties state situation eventually appear 
instance relevant question train eventually crosses red light 
important proof techniques safety properties known simpler liveness properties ffl safety property verified simply checking properties reachable states account transition relation constructing reachable states 
allows efficient methods reachability hol 
ffl safety property checked abstraction actual program 
informally safety property holds program holds programs set behaviors subset initial 
possible programs ignoring details instance numerical computations set behaviors larger properties hold abstractions hold actual programs 
ffl safety properties checked modularly 
properties submodules combined derive property module 
allows proof complexities reduced modular decomposition program structure 
view discussion propose methods specifying checking simple safety properties lustre programs 
specification safety properties formalisms proposed order express properties real time parallel programs 
main approaches distinguished temporal logics pnu mm automata theory petri nets statecharts timed graphs acd process calculi mil 
formalisms clearly allow interesting property expressed provide easy readable expression proving certain property poor interest convinced desired property system 
led investigate possible take advantage lustre declarative aspect expressing properties lustre programs 
positive answer considerations ffl lustre considered subset temporal logic ph bfh 
proposal express temporal property boolean expression holds expression true execution path program 
bfh safety property expressed way 
ffl proposal easily implementable assertion mechanism lustre lustre assertions means expressing properties program environment 
ffl programming language expressing programs properties interesting structuring facilities language available sake readability expressiveness 
instance show node concept allow user define temporal operators 
show useful non trivial temporal operators expressed lustre nodes 
consider property occurrence critical situation followed alarm seconds delay property relates events critical situation occurrence alarm deadline 
provided externally easily expressed lustre 
general pattern property occurrence event followed occurrence event occurrence event formulation directly translatable lustre refers happens occurrence lustre allows past respect current instant 
translate equivalent past expression time occurs occurred previously occurred occurrence 
define node boolean input parameters returning boolean output true property holds node bool returns bool implies tel equation defining uses auxiliary nodes ffl nodes implies implements ordinary logical implication node implies bool returns bool tel 
ffl node returns value true long input equal true 
returns false node bool returns bool 
pre tel 
ffl node inputs returns true second input true input true true value second input node bool returns bool true 
pre tel 
realistic example studied glo critical properties nuclear plant monitoring program expressed lustre small set general purpose temporal operators similar 
verification proposed verification method similar model checking ces state graph program built assumes obviously finite number states property checked state graph 
critical issue approach clearly number states large realistic programs 
shall see restriction safety properties expression properties language program may help solving problem 
lustre case state graph exists corresponding control automaton built compiler 
graph abstraction actual state graph expresses control ignores details concerning non boolean variables boolean ones influence control 
noticed properties checked depend essentially booleans taken account control graph properties safety ones abstraction sensible checking purposes yields general smaller graphs 
important observation decreasing total graph size consists account property checked building state graph 
case lustre easily achieved language applies properties programs order prove expression invariant program build new program body system equations defining output cf 

compiler requested compute take account part program concerns computation expected yield smaller graph 
graph verifying property corresponds check states code performs assignment output false 
verification program third issue reducing size graph consists assertions expressing assumptions property checked suspected hold assumptions 
assertions useful expressing properties numbers ignored compiler 
instance program uses numerical tests assertion assert prevents compiler generating states satisfying xyz course reachable actual program 
example consider general purpose node represents switch output alternates true false input events third input defines initial value 
version node node switch init bool returns state bool state init 
true false pre state tel 
version flaw call node defining variable set cg cf 
version watch dogs 
state switch button button init output change time button pushed expect 
general version take account previous state checking inputs node switch init bool returns state bool state init 
pre state true pre state false pre state tel 
wish verify generalization correct sense versions behave way soon inputs true time 
achieved constructing comparison node calls nodes inputs compares outputs assumption inputs exclusive cf 
fig 
node compare init bool returns ok bool var state state bool state switch init state switch init ok state state assert tel 
compiling node yields states automaton transition assigns value true output ok way tackle state explosion problem modular verification 
having prove expression true execution program calling node cf 
fig 
idea decompose proof sub proof concerning sub proof concerning ffl find intuition property expression input output parameters prove true execution switch switch ok init assumption dependent equivalence programs assert modular verification ffl consider part environment replace call assertion assert try prove invariance modified program cf 
fig 

example making modular decomposition may hlr 
prototype verification tool called analogy cesar family model checkers implemented program single boolean output goes states checks output assigned false 
check mentioned nuclear plant control system glo 
program computations real numbers state graphs needed build appeared quite small states 
course validity proof relies satisfaction synchrony hypothesis proof performed inside synchronous model performance analysis 
mentioned checking validity synchrony hypothesis amounts evaluate maximum reaction time program machine 
current activities compiler version section lustre compiler currently available described 
experiments conducted version serious drawbacks identified improved version currently designed 
briefly discuss main trends adopted new design 
automata minimization indicated automata provided current compiler far minimal case esterel generated automata 
suspected reason may esterel imperative language offering powerful control structures sequencing interruptions 
furthermore medium large grain parallel language sense parallel construct explicit may tightly controlled programmer allows programming rules stated lead minimal automata 
contrary control lustre hidden results data dependencies lustre fine grain parallel language sense expression potentially parallel construct 
minor changes program text may induce large variations automaton size causes state explosion identified easily synthesized sensible programming rules 
problem efficiently compiling lustre intrinsically difficult 
solutions currently investigated ffl posteriori minimization automaton minimizer aldebaran cf 
interfaced main esterel assumption synchronous product automata limits state explosion respect asynchronous product may main cause state growth 
process oc automata low cost solution 
applies successful automaton generation case state explosion occurs 
ffl fly minimization analysis state explosion 
main reason lustre variables defined program execution care effective 
nice feature language programmer point view leads compiler distinguish states differ values influence sequence outputs 
suggests demand driven state generation strategy states created influence input output behavior program asserted bfh 
strategy successfully implemented 
ffl source code optimization mentioned rules known reduce automaton size sensibly programming rules 
idea take advantage large versatility lustre programs due mathematical aspect instance definition principle rules optimizing rules 
experiments carried direction 
transition code size automaton size happens codes transitions exceedingly large 
results inadequacy scheduling algorithm produces sequential code 
tasks consists transforming conditional expressions conditional statements order tests opened closed appears critical respect code size cf 

heuristics investigated solve problem 
modular compiler may happen minimal automaton program remains large 
happens program quasi independent parts number states large product state numbers parts 
solution case consist generating automaton part linking automata 
raises problems 
noted modularly compiling pieces lustre programs general impossible 
ray proposed method identifying program pieces compiled separately 
second may result significant decrease code length expense execution time 
method implemented foreseen keep programmer control reach satisfactory balance code length execution time 
distributed programming execution scheme considered lustre programs purely sequential 
consistent highly parallel aspect language fact parallel languages occam ada parallel concurrent execution schemes 
reasons discrepancy ffl parallelism lustre intended expressiveness adequacy culture control systems engineers independent execution scheme 
ffl contrast abovementioned languages parallelism lustre fine grain concurrent execution inefficient 
contrary seen efficient sequential codes respect execution time generated furthermore sequential execution allows transition time accurately bounded 
control monitoring systems constitute main application domain lustre distributed systems reasons performances fault tolerance location sensors actuators systems programmed separately 
may bad solution may correspond modular decomposition systems frequently raises difficult debugging problems validation systems usually impossible 
alternative method automated tool producing distributed code lustre programs user provided distribution commands instance compute variable location 
allow application programmed lustre care distribution problems application easily debugged validated standard lustre methods 
provided automatically produced distributed program preserves lustre semantics expected debugging validation performed centralized program hold distributed 
tool called oc rep described bcp implemented 
oc program set distribution commands automatically produces oc programs communicate fifo queues statements location exp type execution location consists inserting value exp queue location gettype location var type execution location consists waiting queue empty assigning head queue note queue mechanism fact puts gets inserted convenient order allow messages identify transmitted values sending destination locations 
distributed programs synchronized deadlock free meet functional semantics lustre experiments show method avoids difficult distributed debugging problems 
accurate bounds transition times difficult get evaluation constitutes real problem 
hardware issues adequacy lustre description digital circuits shown papers hlp hp tp 
expected circuit proof validation may benefit lustre proof techniques 
interesting issue hardware design boolean lustre specifications descriptions 
topic currently undertaken cooperation digital equipment paris research laboratory roc 
idea implement hardware network operators corresponding program successful achievements obtained direction programmable active memory circuits 
applies esterel input tool oc program 
lustre language main applications associated tools 
concluding remarks compare lustre approach alternative approaches programming language verification points view 
related programming languages dataflow dataflow model basis programming languages instance aw gra bro nice formal definition kahn kah 
trying locate lustre dataflow world looks close lucid syntactical point view 
similarity casual lucid main design lustre 
final language quite different model 
due choice kahn model basic lustre model newly computed values appended sequence computed values lucid model allows appended sequence 
raises lot problems efficient execution mechanisms required poorly meets point view reactive systems 
lustre seen restriction lucid kahn model 
soon appeared general bounded memory bounded reaction time required 
clearly recursive node call forbidden sampling blocking operators strictly restricted purpose 
originated concept lustre clocks final distinguishing feature language 
signal language quite similar lustre signal see issue comparing easy task 
main issue distinct semantical model opinion signal belong kahn family languages functions sequences functional composition concept programming constraints signal construct denotes finite memory relation sequences program intersection relations 
program bounded memory relational non deterministic object signal clock calculus consists finding execution scheme program deterministic deadlock free 
free absent data symbols semantics signal powerful language lustre sense internal clock program faster inputs faster clock 
opinion drawback approach lies fact clock calculus complex hardly mentally performed programmer 
imperative synchronous languages synchronous models languages imperative ones sccs mil esterel sml statecharts programming style different 
comparison experiments undertaken esterel showed problems fit better imperative style 
indicate reactive programming toolbox offer possibility mixing approaches 
languages share tools common may practical objective 
noted data flow aspect lustre dependent synchronous execution schemes imperative languages 
instance denotational semantics lustre ber impose synchronous execution 
may open door asynchronous execution schemes semantical interpretation 
proof techniques lustre language expressing program properties allows compared called real time logics mm jm ah 
logics mainly obtained adding quantitative time dimension ordinary temporal logics time seen ordering events 
proposal differs remain framework temporal logics consider time external event 
presents advantages logic grow complexity allows concept time handled 
topic stressed interest language writing programs expressing properties satisfied programs 
concerning proof techniques began considering inductive methods axiomatic approach 
done direction soon appeared methods state enumeration model checking efficient 
improvements method particular case lustre described 
acknowledgments people involved project eric pilaud played great part language definition john plaice defined implemented lustre compiler glory involved program specification proof framework contract merlin 
lustre project received constant attention help erard berry esterel team 
particular indebted compiling technique lustre 
indebted albert benveniste energy spent promoting synchronous programming 
courcoubetis referees careful manuscript 
acd alur courcoubetis dill 
model checking realtime systems 
fifth ieee symposium logic computer science philadelphia 
ah alur henzinger 
really temporal logic 
jacm january 
aw ashcroft wadge 
lucid data flow programming language 
academic press 
bcp caspi pilaud 
programming distributed automatic control systems language compiler solution 
technical report imag grenoble grenoble july 
ber 

lustre un langage pour le temps eel 
thesis institut national polytechnique de grenoble grenoble france 
ber berry 
real time programming special purpose general purpose languages 
ifip world computer congress san francisco 
bfh bouajjani 
fernandez halbwachs 
minimal model generation 
kurshan editor international workshop computer aided verification rutgers june 
bfh bouajjani 
fernandez halbwachs 
verification safety properties 
technical report imag grenoble grenoble march 
fleming milne 
tutorial lts 
rr 

standard telecommunication laboratories 
bl le 
overview cascade multilevel hardware description language mixed mode simulation mechanisms 
computer hardware description languages applications 
elsevier science north holland 
bro broy 
functional specification time sensitive communicating systems 
de bakker 
de roever editors rex workshop stepwise refinement distributed systems models formalisms correctness 
lncs springer verlag may 
bertin vuillemin 
programmable active memories 
editors systolic array processors 
prenticehall 
ces clarke emerson sistla 
automatic verification finite state concurrent systems temporal logic specifications 
acm toplas 
caspi pilaud halbwachs plaice 
lustre declarative language programming synchronous systems 
th acm symposium principles programming languages munchen january 
courcoubetis vardi wolper 
memory efficient algorithms verification temporal properties 
kurshan editor international workshop computer aided verification rutgers june 
fer 
fernandez 
aldebaran un syst eme de par eduction de processus 
thesis universit joseph fourier grenoble grenoble france 
glo 
glory 
de propri es de programmes de donn ees 
thesis universit joseph fourier grenoble grenoble france december 
gra mc 
val language description analysis 
acm toplas january 
hlp halbwachs pilaud 
describing designing circuits means synchronous declarative language 
ifip working conference hdl descriptions guaranteed correct circuit designs grenoble september 
hlr halbwachs 
experience proving regular networks processes modular model checking 
acta informatica 
hol holzmann 
limits possibilities automated protocols analysis 
ifip wg th 
international conference protocol specification testing verification zurich 
north holland 
hp harel pnueli 
development reactive systems 
logic models concurrent systems nato advanced study institute logics models verification specification concurrent systems 
springer verlag 
hp halbwachs pilaud 
real time declarative language systolic array design simulation 
international workshop systolic arrays oxford july 
halbwachs pilaud glory 
specifying programming verifying real time systems synchronous declarative language 
workshop automatic verification methods finite state systems grenoble grenoble june 
lncs springer verlag 
jm jahanian mok 
safety analysis timing properties real time systems 
ieee transactions software engineering se 
kah kahn 
semantics simple language parallel programming 
ifip 
north holland 
mil milner 
calculi synchrony asynchrony 
tcs july 
mm moszkowski manna 
reasoning interval temporal logic 
workshop logics programs 
lncs springer verlag 
ph pilaud halbwachs 
synchronous declarative language temporal logic dealing time 
joseph editor symposium formal techniques realtime fault tolerant systems warwick september 
lncs springer verlag 
pla plaice 
compilation de lustre un langage 
thesis institut national polytechnique de grenoble grenoble france 
pnu pnueli 
temporal logic programs 
th symp 
foundations computer science providence 
ieee 
ps plaice 
saint 
lustre esterel portable format 
unpublished report inria sophia antipolis 
ray raymond 
compilation ee de programmes lustre 
technical report imag grenoble grenoble june 
roc 
programmation un circuit parall ele aide un langage 
technical report imag grenoble june 
rodriguez sifakis 
verification sliding window protocol 
ifip wg th 
international conference protocol specification testing verification zurich 
north holland 
rs roy de simone 
primer 
technical report inria sophia antipolis may 
schwartz melliar smith vogt 
interval logic higher level temporal language definition examples 
research report csl computer science lab 
sri international february 
tp pilaud 
declarative language lustre circuit verification 
workshop designing correct circuits oxford september 
ver 
verification means observational equivalence automata 
technical report inria 

