test pattern generation test application time reduction algorithms vlsi circuits university university thesis submitted partial fulfillment requirements degree doctor philosophy computer science graduate college university illinois urbana champaign urbana illinois complexity vlsi circuits increasing rate predicted moore law switching frequencies approaching testing cost important factor ic manufacturing cost 
testing cost incurred test pattern generation test application processes 
dissertation address factors contributing testing cost 
propose new test pattern generation test application time reduction algorithms reducing ic testing cost 
propose new efficient robust structure techniques speeding deterministic test pattern generation combinational circuits 
techniques improve average case performance algorithm reducing number backtracks low computational cost 
extend techniques sequential circuits propose new structure techniques speeding deterministic test pattern generation sequential circuits 
techniques improve performance iterative logic array deterministic sequential circuit test generation algorithms 
propose new algorithms generating compact test sets combinational circuits single stuck fault model new heuristic estimating minimum single stuck fault test set size 
extend algorithms generate compact test sets pure combinational full scan circuits fault models iii require pattern test sets particular transition cmos stuck open fault models 
propose new design testability technique reducing test application time full scan embedded cores additional test access pins ones full scan technique 
propose heuristic technique computing optimal scan chain configuration cores obtain minimal test application time 
propose new synthesis technique reducing test application time counter exhaustive built self test test pattern generators 
technique reduces test application time reducing size binary counter counter test pattern generators 
iv family acknowledgments advisor prof patel invaluable guidance encouragement freedom course dissertation 
pleasure privilege 
prof william prof prof elizabeth rudnick serving dissertation committee giving helpful comments 
turkish scientific technical research council darpa src financial support 
am grateful friends companionship stay university illinois 
am grateful late grandmother late omer ali grandmother parents mehmet wife love patience constant support 
son joy brought lives 
vi table contents chapter page organization dissertation 
test pattern generation combinational circuits test generation system 
test generation techniques 
experimental results 
summary 
test pattern generation sequential circuits test generation system 
test generation techniques 
experimental results 
summary 
test set compaction combinational circuits preliminaries 
redundant vector elimination 
essential fault reduction 
speed techniques 
minimum test set size estimation 
experimental results 
summary 
pattern test set compaction pure combinational full scan circuits transition cmos stuck open fault models 
pattern test set compaction pure combinational circuits 
preliminaries 
redundant vector elimination 
essential fault reduction 
vii test generation system 
experimental results 
pattern test set compaction full scan circuits 
experimental results 
summary 
test application time reduction full scan embedded cores parallel serial full scan 
scan chain configuration 
number scan chains 
mapping flip flops scan chains 
test generation 
experimental results 
summary 
test application time reduction built self test test pattern generators input compatibility relations 
synthesis algorithm 
finding compatible inputs 
finding compatible inputs 
experimental results 
summary 
research 
vita viii list tables table page results atpg fault simulation 
results atpg fault simulation 
impact technique test generation performance 
comparison atpg results 
sequential atpg results 
impact technique sequential circuit test generation performance 
comparison sequential atpg results 
lower bounds minimum test set size 
compaction results 
comparision compaction results 
results pure combinational circuits transition fault model results pure combinational circuits stuck open fault model comparison compaction results pure combinational circuits 
results full scan circuits transition fault model 
results full scan circuits stuck open fault model 
results full scan embedded cores 
results psfs cores default scan chain configuration 
results psfs cores optimal scan chain configuration 
partially specified test set generation compaction 
comparison test application time 
comparison test data 
synthesis results 
ix list figures page improved unique sensitization 
backtrace path check 
backtrace conflict check 
lookback algorithm 
lookback example 
support region example 
iterative logic array model sequential circuit 
sequential circuit test generation algorithm 
support region state 
rve algorithm 
efr algorithm 
efr example 
efr iteration example 
fault set incompatibility 
pattern test set generation algorithm 
efr example 
compact pattern test set generation algorithm 
frame circuit 
full scan embedded core 
parallel serial full scan psfs technique 
bit misr 
test application process 
partially specified test set matrix 
scan chain configuration example 
counter bist test pattern generator 
direct inverse compatibility example 
compatibility example 
synthesis algorithm 
xi chapter complexity vlsi circuits increasing rate predicted moore law transistor count chip doubling eighteen months switching frequencies approaching testing cost important factor integrated circuit ic manufacturing cost 
testing cost incurred test pattern generation test application processes 
dissertation address factors contributing testing cost 
propose new test pattern generation test application time reduction algorithms reducing ic testing cost 
scan design testability dft techniques increasingly today vlsi circuits test generation combinational circuits important 
scan dft techniques convert sequential circuit combinational circuit testing purposes cases cost full scan prohibitive area overhead performance degradation 
test generator efficiently handle combinational sequential circuits necessary solving testing problem wide range vlsi circuits 
effective atpg algorithms combinational sequential circuits average case performance decreasing increasing complexity today vlsi circuits 
propose new efficient robust structure techniques speeding deterministic test pattern generation combinational circuits 
techniques improve average case performance algorithm reducing number backtracks low computational cost 
achieved finding necessary signal line assignments detecting conflicts earlier avoiding unnecessary test generation 
extend techniques sequential circuits propose new structure techniques speeding deterministic test pattern generation sequential circuits 
techniques improve performance iterative logic array deterministic sequential circuit test generation algorithms 
compact test sets important reducing test application time vlsi circuits 
especially important scan circuits test application time circuits directly proportional product test set size number storage elements scan chain 
small test sets reduce test storage requirements 
previously proposed compact test set generation algorithms successful producing small test sets resulting test sets larger known lower bounds 
order close gap propose new algorithms redundant vector elimination essential fault reduction generating compact test sets combinational circuits single stuck fault model new heuristic estimating minimum single stuck fault test set size 
test sets generated single stuck fault model may detect possible physical defects may occur vlsi circuits fault models increase defect coverage 
transition fault model model defects affect timing behavior circuit cmos stuck open fault model model defects cause transistors permanently 
necessary test patterns detect transition fault fault compact test set generation especially important fault models 
extend redundant vector elimination essential fault reduction algorithms generating compact test sets pure combinational full scan circuits fault models require pattern test sets particular transition cmos stuck open fault models :10.1.1.46.6724
chips multiple embedded cores called system chip prevalent industry core design approach considerably reduces design time design reuse 
testing embedded cores challenging problem limited access core inputs outputs 
full scan technique widely adopted industry reducing complexity test generation sequential circuits combinational circuit test generation problem expense increased test application time 
techniques proposed reduce test application time full scan circuits effective full scan circuits embedded cores 
propose new dft technique reducing test application time full scan embedded cores additional test access pins ones full scan technique 
propose heuristic technique computing optimal scan chain configuration cores obtain minimal test application time 
built self test bist effective technique testing vlsi circuits reduces dependency expensive external test equipment provides speed system testing circuit test cut 
applicability bist technique cut depends ability design low overhead test pattern generator achieve high fault coverage small amount test application time 
counter exhaustive testing effective design techniques proposed address problem 
face problem random pattern resistant faults achieves stuck fault coverage low hardware overhead 
requires relatively high test application time 
propose new synthesis technique reducing test application time counter exhaustive bist test pattern generators 
technique reduces test application time reducing size binary counter counter test pattern generators 
organization dissertation rest dissertation organized follows 
new deterministic test pattern generation techniques combinational circuits chapter 
extension techniques sequential circuits new deterministic test pattern generation techniques proposed sequential circuits described chapter 
test set compaction algorithms minimum stuck test set size estimation heuristic combinational circuits chapter 
extension test set compaction algorithms pattern fault models described chapter 
dft technique reducing test application time full scan embedded cores chapter 
synthesis technique reducing test application time counter bist test pattern generators chapter 
chapter discusses directions research 
chapter test pattern generation combinational circuits complexity vlsi circuits quality requirements increasing problem test generation important 
scan design testability techniques increasingly large circuits test generation combinational circuits important circuits 
test generation problem viewed finite space search problem finding appropriate logic assignments primary inputs fault detected 
size search space exponential number primary inputs test generation problem proven np complete important find efficient techniques speed test generation process 
branch bound search algorithm introduced number techniques proposed literature improve performance 
test generation problem viewed boolean satisfiability sat problem possible reduce test generation equivalent sat problem polynomial time reduction 
number test generation systems introduced solving test generation problem fast sat solvers 
effective atpg algorithms average case performance decreasing increasing complexity today vlsi circuits 
propose new structure techniques speeding test pattern generation vlsi circuits 
techniques improved unique sensitization improved backtrace path conflict check multiple primary input assignments lookback support region 
improve average case performance algorithm reducing number backtracks low computational cost 
achieved finding necessary signal line assignments detecting conflicts earlier avoiding unnecessary test generation 
able assess effectiveness proposed techniques developed deterministic atpg system combinational circuits called atom incorporated techniques test generator 
test generator uses single stuck fault model algorithm 
addition techniques proposed employs test generation techniques introduced literature 
experimental results iscas full scan versions iscas benchmark circuits demonstrate effectiveness techniques test generation performance 
results showed atom detects testable faults proves redundant faults redundant small number backtracks short amount time 
initial random test generation phase obtained similar results fault simulation results demonstrate robustness techniques developed 
test generation system atpg system developed combinational circuits called atom composed parallel pattern fault simulator deterministic test pattern generator 
random test generation phase atom order assess robustness test generation techniques developed 
atom designed object oriented style implemented 
fault simulator parallel pattern simulator simulates patterns time 
parallel fault simulator simulates faults fanout free region fanout stem simulates faults fanout stem rest circuit 
employs fault simulation techniques proofs fault simulator 
test generator algorithm 
uses single stuck fault model valued logic logic values uses controllability observability values controllability observability measures guide search process 
addition new test generation techniques developed test generator uses local implications static global implications path check unique sensitization dynamic unique sensitization techniques proposed literature 
reported costly test generation techniques easy detect faults degrades performance atpg system 
observation 
atom runs phases 
phase low cost test generation techniques local implications path check unique sensitization support region test faults possible maximum backtrack limit backtracks 
second phase costly test generation techniques static global implications dynamic unique sensitization improved unique sensitization backtrace path conflict check multiple primary input assignments lookback test remaining faults 
techniques proposed literature test generator reasons 
costly process multiple backtrace technique introduced fan algorithm 
static head lines technique introduced fan algorithm improved fast tops algorithms dynamic head lines technique introduced leap system number head lines practical circuits relatively small backtrace path conflict check technique achieves effect cases 
dynamic global implications technique proposed socrates system finding dynamic global implications costly process 
reason advanced logic implication algorithms proposed literature 
costly process dependency directed backtracking introduced leap system 
test generation techniques describe new techniques propose improve test generation performance 

improved unique sensitization dynamic unique sensitization technique introduced socrates system improved effectiveness unique sensitization technique proposed fan algorithm 
technique identifies necessary logic assignments due fault propagation constraints considered basic unique sensitization technique 
finds necessary logic assignments intersection dynamic dominators gate frontier 
improved dynamic unique sensitization technique identify necessary logic assignments 
new technique finds necessary assignments follows 
suppose frontier consists gate static dominator order fanout 
note fanout assume fans gates necessary signal line assignments propagating fault gates identified static unique sensitization technique contained sets respectively 
signal line assignments logic implications logic implications necessary propagate fault fanout gates set necessary logic assignments detecting fault 
dynamic unique sensitization technique technique applicable situations gate frontier 
multiple gates frontier finding necessary assignments costly 
technique gate frontier 
new dynamic unique sensitization technique discovers large number necessary logic assignments discovered socrates 
necessary logic assignments speed test pattern generation identifying conflicts earlier 
example illustrates situation new technique discovers necessary logic assignment discovered socrates 
example assume frontier consists gate situation new technique determine necessary logic assignment follows 
propagate fault gate signal set implies 
similarly propagate fault gate signal set implies 
gate assigned logic value fault propagated improved unique sensitization gate signal set regardless gate fault propagated 
socrates able find necessary logic assignment dynamic dominator gate 
improved backtrace path conflict check backtrace procedure algorithm involves types decisions selecting unsolved justification problems selecting possible ways solving selected justification problem 
dissertation refer unsolved justification problem choice possible way solving selected justification problem choice 
selecting gate fault propagation carries path check gate determine path gate primary outputs lines path selects gate 
path check carried backtrace procedure 
path may exist backtrace starts choice backtrace may destroy paths 
improved backtrace procedure detect situations backtrace committing primary input assignment 
backtrace path check example illustrates situation 
case assume objective propagate fault gate signal set 
justified setting signal 
setting signal implies signal 
signal path remaining gate backtrace procedure continues selecting resulting primary input assignment may satisfy initial objective propagating fault gate primary output 
test generator discards choice continues backtrace selecting 
uses controllability measures choice decision point backtrace 
backtrace choice conflicts choices earlier backtrace 
conflict considered resulting primary input assignment may satisfy initial objective 
improved backtrace procedure detect possible conflicts committing primary input assignment 
prevents test generator going area search space result significant number backtracks 
example illustrates situation choice directly conflicts earlier choice 
example assume current objective backtrace procedure 
justifying objective requires setting signals 
backtrace procedure chooses choice direct conflict indirect conflict backtrace conflict check justified setting signal signal 
choice clearly conflicts choice 
improved backtrace procedure detect conflict continue backtrace selecting 
example illustrates basic improvement 
complicated cases choice directly conflict earlier choices logic implications choice conflict earlier choices 
example illustrates situation 
example assume current objective backtrace procedure 
justifying objective requires setting signals 
backtrace procedure chooses justified setting signal signal 
directly conflict earlier choices setting signal implies conflicts choice 
improved backtrace procedure detect conflict continue backtrace selecting 
observation detecting conflicts backtrace simplifies improved backtrace procedure 
detect possible conflicts backtrace sufficient check choices 
necessary check choices decision point cause conflict 
previous choice imply choices checked consider implications previous choice 
improved backtrace procedure works follows 
backtrace backtrace stack built keep track earlier choices 
decision point push choices logic implications selected choice stack marking selected choice tried 
decision point backtrace procedure checks choice destroys paths initial objective directly indirectly conflicts choices selected earlier backtrace 
choice causes conflict untried choices selected 
choices decision point cause conflict backtrace procedure backtracks choice 
way tries possible choices primary input conflicts untried choice left case test generator backtracks 
circuits technique may cause large number backtracks backtrace degrading performance test generator 
avoid situation maximum backtrack limit test generator 
limit exceeded backtrace technique longer circuit backtrace procedure executed conflict checks 
iscas circuits maximum backtrack limit exceeded test generation test generator run fault simulation 

multiple primary input assignments multiple backtrace technique introduced fan algorithm concurrently objective may assign logic values primary input backtrace 
improved single backtrace technique assign logic values primary input backtrace 
opposed multiple backtrace technique technique require backtracing multiple objectives 
new technique speeds test pattern generation reducing number 
multiple primary input assignments achieved exploiting backtrace stack constructed single backtrace procedure 
backtrace stack contains selected backtrace logic implications 
improved test pattern generator check backtrace stack backtrace determine choices selected backtrace implies logic value primary input assigned logic value backtrace procedure primary input decision tree 
logic implication exists put corresponding primary input decision tree assigning implied logic value 

lookback conflict occurs test generation process backtracks primary input decision 
dependency directed backtracking technique introduced improved algorithm backtrack earlier primary input decision 
conflict occurs test generation process dependency directed backtracking technique carries extensive analysis determine cause conflict backtracks primary input decision responsible conflict 
conflict analysis quite costly process 
improved algorithm backtrack earlier primary input decision new search technique called lookback 
lookback probing technique triggered maximum backtrack limit test generator reached 
case continuing branch bound search algorithm save current search state primary input decision tree perform branch bound search starting dt test vector return success backtrack previous primary input decision dt return failure dt empty complement logic value current pi current pi primary input dt backtracks dt dt save dt conflict dt dt restore dt lookback dt decision tree lookback backtrack limit int backtracks backtrack previous primary input decision dt backtracks backtracks lookback algorithm lookback technique 
lookback effective situations earlier primary input decision causes test generator go large area 
tries avoid spending time area tries quickly reach solution area carrying conflict analysis 
shown lookback procedure takes parameters current decision tree lookback backtrack limit 
test generator limit 
starting primary input decision decision tree lookback procedure complements logic value primary input runs algorithm lookback backtrack limit reached 
solution lookback backtrack limit backtracks previous primary input decision original decision tree 
way spending large amount time area quickly backtracks earlier primary input decision failure success unexplored unexplored lookback example caused test generator enter area 
lookback complete algorithm fails find test vector test generator continues branch bound search algorithm starting original decision tree 
example illustrates situation lookback technique helps test generator quickly get rid area detect fault 
unshaded part triangles represents areas completely searched lookback shaded part triangles represents areas explored lookback 
square boxes represents conflict failure represents solution 
assume test generator reached maximum backtrack limit current decision tree consists decisions 
example branch bound algorithm may take large number backtracks come back decision tree node find solution 
lookback explores small portion triangle size determined lookback backtrack limit lookback procedure quickly backtracks decision tree node finds solution 
primary inputs circuit faulty gate support region primary outputs support region example 
support region define support region fault circuit part circuit may affect test generation process fault 
illustrated faulty gate region consists gates fanin cones primary outputs fanout cone faulty gate 
gates outside support region fanout primary outputs faulty gate affect test generation process faulty gate 
logic value gate support region may imply logic value gate outside support region test generation necessary carry forward implications outside support region target fault 
support region technique prevents test generator carrying forward implications outside support region target fault avoiding considerable amount unnecessary test generation 
technique requires computation support regions cost computation reduced computing information fanout free region demand driven way 
support region faults fanout free region information computed fanout free region faults fanout free region 
technique fault simulator necessary compute support regions faults detected fault simulation 
compute support regions faults targeted test generator 
experimental results atom tested iscas full scan versions iscas benchmark circuits mhz pentium pro pc mb ram running linux gnu cc version 
order assess robustness test generation techniques developed ran atom fault simulation 
tables performance results fault simulation cases respectively 
experiments maximum backtrack limit lookback technique triggered backtracks 
det red abt columns tables number faults detected number faults proven redundant number aborted faults respectively 
vect column table presents number test vectors generated 
fault simulation case test vector generated fault number test vectors generated number detected faults 
number test vectors generated case 
results show atom detected testable faults proved redundant faults redundant 
tb columns tables total number backtracks done test generation corresponding circuit 
mdb columns show maximum number backtracks required detect fault mrb columns show maximum number backtracks required prove fault redundant 
mt columns table results atpg fault simulation circuit det red abt vect tb mdb mrb mt time total table results atpg fault simulation circuit det red abt tb mdb mrb mt time total show number faults required backtrack detected proven redundant 
results show atom detected testable faults proved redundant faults redundant small number backtracks 
time column table presents total test generation time seconds corresponding circuit including time computing dominators static global implications fault simulation time input output times 
time column table presents total test generation time seconds including time writing generated test vectors file 
largest iscas circuits size test vector file mb considerable input output time circuits 
input output time independent test generation algorithm determined performance input output subsystem machine 
include total time fault simulation case 
results show atom detected testable faults proved redundant faults redundant short amount time aborting faults 
summary performance results show new test generation techniques developed quite successful detecting testable faults proving redundant faults redundant small number backtracks short amount time fault simulation 
demonstrates effectiveness robustness new test generation techniques 
order assess individual impact test generation technique atpg performance carried detailed experimental analysis results table 
abt tb time columns total number aborted faults total number backtracks total test generation time seconds iscas iscas benchmark circuits 
row table presents performance results test generation techniques table impact technique test generation performance fault simulation fault simulation atom abt tb time abt tb time techniques improved unique sensitization improved backtrace multiple pi assignments lookback support region phase test generation 
rows performance results test generation techniques indicated column 
improved unique sensitization improved backtrace contribute detecting hard detect faults reducing test generation time 
multiple primary input assignments contributes reducing test generation time especially clear fault simulation case 
test generation lookback triggered targeted fault aborted happened circuits fault simulation 
circuits faults aborted respectively lookback 
support region phase test generation significantly reduce test generation time fault simulation cases 
summary results table show effectiveness technique reducing number backtracks test generation time detecting hard detect faults may require large number backtracks large execution times detected 
order accurately compare performance atom previously published test generation systems programs executed machine benchmark circuits 
programs previously published test generation algorithms publicly available accurately reimplement ing algorithms quite difficult don access machines previous results reported difficult perform comparison 
stephan carried accurate comparison test generation system uses satisfiability test generation algorithm previously published results porting machines previously published results obtained 
compared performance atom 
implicitly compared performance atom previously published results 
table presents comparison 
comparison iscas full scan versions iscas benchmark circuits 
experimental results programs obtained machine mhz pentium pro pc mb ram running linux 
atom number aborted faults circuits fault simulation zero number aborted faults table 
table number faults targeted column presents number faults explicitly targeted corresponding test generation system 
addition fault equivalence uses fault dominance relation atom fault collapsing 
circuit number faults explicitly targeted smaller atom 
table time fault column presents average test generation time fault milliseconds 
execution times reported atom fault simulation case include time writing generated test vectors file 
test generators target different numbers faults time fault measure compare performance atom test generation time 
time fault value obtained dividing total test generation time number faults collapsed fault list 
table comparison atpg results number fault simulation fault simulation faults targeted time fault ms time fault ms circuits atom atom atom total systems demonstrated robustness detecting testable faults proving redundant faults redundant fault simulation 
experimental results show atom faster fault simulation 
stephan showed faster previously published atpg systems faults explicitly targeted fault simulation 
showed faster previously published atpg systems random test generation fault simulation 
shown case atpg systems reported faster 
terms time fault measure atom faster fault simulation faster fault simulation results reported conclude test generation fault simulation performances considered atom fastest atpg systems reported literature test generation performance considered atom fastest atpg system reported literature 
summary chapter new efficient robust structure techniques speeding deterministic test pattern generation vlsi circuits 
techniques improve average case performance algorithm reducing number backtracks low computational cost 
achieved finding necessary signal line assignments detecting conflicts earlier avoiding unnecessary test generation 
able assess effectiveness proposed techniques developed deterministic atpg system combinational circuits called atom incorporated techniques test generator 
performance results iscas full scan versions iscas benchmark circuits demonstrated effectiveness techniques 
atom detected testable faults proved redundant faults redundant small number backtracks short amount time 
results achieved initial random test generation phase similar results obtained fault simulation results demonstrated robustness techniques developed 
chapter test pattern generation sequential circuits scan design testability techniques convert sequential circuit combinational circuit testing purposes cases cost full scan prohibitive area overhead performance degradation 
efficient sequential circuit test generation algorithms important producing high quality vlsi circuits 
problem test generation sequential circuits complex combinational circuit test generation problem 
significant progress solving sequential circuit test generation problem time consuming process 
sequential circuit test generation algorithms proposed literature iterative logic array ila model sequential circuit test generation purposes 
illustrated model represents sequential circuit array identical cells 
cell called time frame represents state sequential circuit different point time 
time frame time frame time frame primary outputs primary inputs state state primary outputs primary inputs state primary outputs primary inputs state iterative logic array model sequential circuit target fault sequential circuit test generation algorithm needs excite fault propagate fault effect primary output justify required state sequential circuit test generation process usually requires considering multiple time frames 
time consuming combinational circuit test generation 
iterative logic array sequential circuit test generation algorithms proposed literature classified major categories deterministic simulation hybrid 
algorithms successful generating high quality test patterns test generation times high 
extend deterministic test generation techniques proposed chapter sequential circuits propose new structure techniques speeding deterministic test pattern generation sequential circuits 
new sequential circuit test generation techniques state space reduction unreachable state identification 
techniques improve average case performance iterative logic array deterministic sequential circuit test generation algorithms 
able assess effectiveness proposed techniques developed new atpg system sequential circuits called atoms atom underlying combinational circuit test generation system incorporated techniques test generator 
addition techniques proposed test generator employs test generation techniques introduced literature 
experimental results iscas sequential benchmark circuits showed atoms achieves high fault coverages short amount time 
demonstrates effectiveness techniques test generation performance 
test generation system developed new atpg system sequential circuits called atoms atom underlying combinational circuit test generation system 
atoms designed object oriented style implemented 
fault simulator uses proofs fault simulation algorithm 
test generator sequential circuit test generation algorithm uses algorithm processing time frame 
test generator uses single stuck fault model valued logic 
incorporated new test generation techniques developed test generator 
addition techniques test generator uses state relaxation unreachable state storage fault cycle detection state justification techniques proposed literature 
illustrated order generate test sequence fault sequential circuit test generation algorithm uses forward time processing reverse time processing iterative logic array model sequential circuit 
po po po po po pi pi pi pi pi initial state propagation time frames excitation justification sequence propagation sequence time frame justification time frames sequential circuit test generation algorithm forward time processing phase test generator tries find input sequence fault propagates fault effect primary output 
fault tries propagate fault effect primary output single time frame 
fault effect propagated primary output time frame tries propagate fault effect primary output time frame 
process repeated fault effect successfully propagated primary output fault proven maximum number time frames expanded maximum fault effect propagation backtrack limit reached 
backtrace process fault effect propagation phase test generation algorithm considers time frames excite fault propagate fault effect primary output simultaneously assigns logic values primary inputs time frame flip flops time frame fault excited 
forward time processing phase fault effect propagated primary output reverse time processing justify state required fault excitation fault effect propagation 
fault proven test generator aborts fault 
reverse time processing phase test generator tries find input sequence brings sequential circuit fully unspecified initial state state required fault excitation fault effect propagation 
state justification process test generation algorithm considers time frame time 
tries justify state required fault excitation fault effect propagation single time frame 
process flip flop time frame assigned logic value state time frame justified time frame 
process repeated state justification current time frame achieved assigning logic values flip flops state required fault excitation fault effect propagation proven unreachable maximum number time frames expanded maximum state justification backtrack limit reached 
test generator fails justify state required fault excitation fault effect propagation state proven unreachable test generator aborts fault 
hand state required fault excitation fault effect propagation proven unreachable test generator tries propagate fault effect primary output different state 
fault excitation fault effect propagation achieved state fault declared 
fault excitation fault effect propagation achieved state test generator tries justify state 
process repeated states required fault excitation fault effect propagation justified fault excitation fault effect propagation achieved state case fault declared maximum backtrack limit reached case test generator aborts fault 
time frame fault excited called excitation time frame time frames propagate fault effect primary output called propagation time frames time frames justify required state called justification time frames 
state flip flops excitation time frame called excitation state 
initial part test sequence brings sequential circuit fully unspecified initial state excitation state called justification sequence 
remaining part test sequence fault propagates fault effect primary output called propagation sequence 
test generation techniques describe extension test generation techniques proposed combinational circuits sequential circuits new deterministic test generation techniques proposed sequential circuits 

improved unique sensitization improved unique sensitization technique useful identifying necessary logic assignments due fault effect propagation constraints technique fault effect propagation phase sequential circuit test generation algorithm 
improved unique sensitization technique identify necessary assignments propagating fault effect primary output flip flop single time frame 
case combinational circuits improved unique sensitization technique discovers necessary logic assignments previous techniques speeding test pattern generation identifying conflicts earlier 

improved backtrace path conflict check backtrace operation fault effect propagation state justification phases sequential circuit test generation algorithm find appropriate primary input flip flop assignments justify fault effect propagation state justification objectives 
path check technique useful fault effect propagation backtrace path check technique fault effect propagation phase 
time frames expanded fault effect propagation technique time frame fault effect selected frontier propagated primary output 
backtrace conflict check technique phases sequential test generation algorithm 
fault effect propagation phase decision point compute implications time frame decision point identify possible conflicts single time frame 
may potentially costly operation compute implications time frames 
state justification proceeds time frame time state justification phase compute implications single time frame 
case combinational circuits improved backtrace path conflict check technique helps test generator determine possible conflicts committing primary input flip flop assignment preventing test generator going area search space result significant number backtracks 

multiple primary input flip flop assignments multiple primary input assignments technique phases sequential test generation algorithm order assign logic values primary input flip flop backtrace 
fault effect propagation phase check possible multiple primary input assignments propagation time frames check possible multiple primary input flip flop assignments excitation time frame 
state justification proceeds time frame time state justification phase check possible multiple primary input assignments current time frame 
similar combinational circuit case multiple primary input assignments achieved exploiting backtrace stack constructed backtrace procedure speeds sequential test pattern generation reducing number fault effect propagation state justification phases 

lookback lookback technique state justification phase sequential circuit test generation algorithm 
chapter introduced lookback search technique combinational circuit test generation problem 
section extend sequential circuits 
state justification phase test generator tries find input sequence bring sequential circuit fully unspecified initial state excitation state 
achieved traversing state transition graph sequential circuit backward direction starting excitation state 
conventional branch bound search algorithm sequential circuit test generation traverses state transition graph depth fashion attempt explore entirely justification sequence excitation state proven unreachable maximum backtrack limit reached 
test generator reaches maximum backtrack limit finding justification sequence excitation state lookback technique find justification sequence 
reason failure test generator finding justification sequence maximum backtrack limit solution part search space state transition graph explored 
indicates depthfirst search technique traverse state transition graph unable bring test generator solution area search space 
lookback technique tries overcome problem traversing state transition graph combination depth breadth search techniques 
lookback procedure takes input parameters partial state transition graph explored test generator lookback procedure called local state backtrack limit global state backtrack limit 
state visited state transition graph traversal local state backtrack limit determines size search space explored backward direction starting state depth traversal 
words state local limit solution traversing predecessors depth search test generator stops traversing predecessors jumps back successor partial state transition graph continues traversing predecessors state depth traversal local state backtrack limit reached state 
process repeated state partial state transition graph justification sequence limited depth search tried state global state backtrack limit reached 
summary state visited state justification phase lookback technique carries limited depth traversal backward direction starting state 
uses combination depth breadth search techniques traversing state transition graph 
lookback technique effective situations depth search conventional branch bound test generation algorithm unable bring test generator solution area reasonable amount time 
flip flops primary outputs flip flops primary inputs support region single time frame support region state lookback complete search algorithm 
fails find justification sequence test generator search rest search space explored order find justification sequence prove excitation state unreachable 

support region support region technique state justification phase sequential circuit test generation algorithm 
chapter defined support region fault combinational circuit part circuit may affect test generation process fault 
section extend definition support region state sequential circuit 
define support region state sequential circuit part circuit may affect state justification process state single time frame 
illustrated state region consists gates fanin cones flip flops known logic value state 
gates outside support region state fanout flip flops known logic value state affect state justification process state current time frame 
logic value gate support region may imply logic value gate outside support region state justification time frame necessary carry forward implications outside support region state justified 
support region technique avoids considerable amount unnecessary state justification 
cost computing support region state small compute fanin cone flip flop preprocessing step test generation 
test generation compute support region state simply computing union fanin cones flip flops known logic value state 

state space reduction propose new technique theorem reducing size search space needs explored deterministic sequential circuit test generator 
theorem fault sequential circuit testable exists test sequence detects fault assigning opposite faulty logic values flip flop excitation time frame 
proof 
assignment logic value flip flop excitation time frame required generate test sequence fault sequential circuit fault redundant logic value applied primary input testing combinational circuit 
redundant fault sequentially exists test sequence detect fault 
fault sequential circuit testable exists test sequence detects fault assigning opposite faulty logic values flip flop excitation time frame 
theorem indicates sequential circuit test generation necessary consider logic value pairs flip flop excitation time frame 
words generate test sequence testable fault prove fault sufficient search state space logic value assignments flip flop excitation time frame fault testable solution test generation problem region state space 
hand fault solution test generation problem region state space 
state space reduction technique avoids considerable amount unnecessary search test generation reducing state space needs explored fault 

unreachable state identification state sequential circuit said unreachable exists input sequence bring sequential circuit fully unspecified initial state state hand input sequence said reachable 
identification unreachable states useful sequential circuit test generation knowledge unreachable states prevents test generator going area search space 
propose new low cost unreachable state identification technique theorem 
theorem unreachable state reached state unreachable state 
proof 
state reached state reachable fully unspecified initial state reachable 
unreachable state reachable state 
unreachable state 
theorem new technique discovers unreachable states follows 
unreachable state traverses state transition graph sequential circuit backward direction starting state transition graph traversed depth breadth search technique 
states visited traversal declared unreachable 
number states reachable large may possible traverse states due execution time storage space limitations 
traversal restricted visit predetermined number states 
low cost technique identifying unreachable states may difficult prove unreachable 
knowledge unreachable states speeds sequential circuit test pattern generator avoiding unnecessary search state justification phase 
technique useful discovering new unreachable states existing unreachable states industrial circuits number functionally unreachable states known test generation 
experimental results atoms tested iscas sequential benchmark circuits mhz pentium pro pc mb ram running linux gnu cc version 
experiments maximum backtrack limit maximum time frame expansion limit fault effect propagation phase 
state justification computationally expensive process state justification phase smaller backtrack limit smaller time frame expansion limit larger circuits lookback technique benchmark circuit 
particular maximum backtrack limit maximum time frame expansion limit circuits gates maximum backtrack limit table sequential atpg results atoms circuit det abt vect time maximum time frame expansion limit circuits gates 
aware functionally unreachable states iscas circuits unreachable state identification technique experiments 
table presents performance results 
columns table number faults detected number faults proven number aborted faults number test vectors generated total test generation time seconds respectively 
execution times include time computing dominators static global implications fault simulation time input output time 
results show atoms achieved high fault coverages short amount time circuits 
demonstrates effectiveness new test generation techniques test generation performance 
table impact technique sequential circuit test generation performance atoms det abt time techniques improved unique sensitization improved backtrace multiple pi assignments lookback times backtrack limit lookback times backtrack limit support region order assess individual impact test generation technique atpg performance carried detailed experimental analysis results table 
columns table total number detected faults total number faults proven total number aborted faults total test generation time seconds iscas sequential benchmark circuits 
row table presents performance results test generation techniques 
rows performance results test generation techniques ones indicated column 
improved unique sensitization improved backtrace multiple primary input assignments techniques sequential circuit test generator obtained performance results techniques second row 
results show techniques quite effective detecting hard detect faults reducing test generation time 
lookback technique test generator aborts state justification process fault spends additional effort generate test sequence fault 
order fair comparison lookback technique increased justification backtrack limit times times normal justification backtrack limit results rows 
results show lookback technique test generator unable detect table comparison sequential atpg results atoms circuit det vect time det vect time det vect time number faults amount test generation time 
results show support region technique significantly reduces test generation time 
summary results table show effectiveness technique reducing test generation time detecting hard detect faults may require large execution times detected 
compared performance atoms best deterministic sequential atpg system reported literature best simulation sequential atpg system reported literature 
table presents comparison 
sign table indicates corresponding result circuit reported 
number faults iscas circuits proven reported 
performance results atoms obtained mhz pentium pro pc mb ram running linux gnu cc version 
performance results obtained hp workstation mb ram 
possible exactly compare test generation times performances machines specint benchmarks approximately compare test generation times mhz pentium pro hp 
results table show atoms achieved higher fault coverages smaller amount time circuits 
demonstrates effectiveness new test generation techniques improving average case performance iterative logic array deterministic sequential circuit test generation algorithms 
results show circuits atoms achieved level fault coverage smaller amount time 
circuits achieved higher fault coverages larger execution times 
detailed analysis experimental results indicates faults detected atoms aborted state justification phase test generator unable find justification sequences faults 
effective state justification heuristics genetic algorithm framework successfully finds justification sequences faults 
summary chapter new structure techniques speeding deterministic test pattern generation vlsi circuits application combinational circuit test generation problem 
chapter extension techniques sequential circuits new deterministic test pattern generation techniques sequential circuits 
techniques improve average case performance iterative logic array deterministic sequential circuit test generation algorithms 
able assess effectiveness proposed techniques developed new atpg system sequential circuits called atoms atom underlying combinational circuit test generation system incorporated techniques test generator 
atoms achieves high fault coverages short amount time iscas sequential benchmark circuits demonstrating effectiveness techniques test generation performance 
chapter test set compaction combinational circuits compact test sets important reducing cost testing vlsi circuits reducing test application time 
especially important scan circuits test application time circuits directly proportional product test set size number storage elements scan chain 
small test sets reduce tester storage requirements 
problem estimating size minimum single stuck fault test set irredundant combinational circuit proven np hard test set compaction algorithms different heuristics proposed literature static compaction dynamic compaction gang testing independent compatible fault set test generation reverse order fault simulation compact maximal compaction rotating backtrace double detection forced pair merging essential fault pruning 
algorithms successful producing small test sets resulting test sets larger known lower bounds 
reasons previously published test set compaction algorithms unable compact test sets known lower bounds tight 
order close gap address problems 
propose new algorithms redundant vector elimination rve essential fault reduction efr generating compact test sets combinational circuits single stuck fault model new heuristic estimating minimum single stuck fault test set size 
algorithms dynamic compaction algorithm proposed incorporated atom advanced atpg system combinational circuits 
new compact test generator called mintest 
mintest better lower bounds generated smaller test sets previously published results iscas full scan versions iscas benchmark circuits 
circuits sizes test sets generated mintest smaller equal best published results 
circuits sizes test sets generated mintest equal known lower bounds 
executing iteration efr algorithm mintest generated smaller test sets previously published results 
circuits mintest produced smaller test sets executing efr algorithm iteratively 
lower bounds computed mintest larger previously published results larger larger larger test sets generated mintest smaller previously published results smaller smaller smaller 
preliminaries section definitions chapter 
test vector test set called essential vector detects fault detected test vector test set 
fault defined essential fault test vector detected test vector test set 
words essential vector detects essential fault 
test vector redundant respect test set detect essential faults faults detected detected test vectors test set 
essential fault ef test vector said pruned test vector test set replaced new test vector detects ef essential faults faults detected 
faults detected single test vector called compatible 
similarly faults called incompatible detected single test vector 
incompatibility graph set faults fs defined ig fs incompatible 
fault set called independent fault set faults set pairwise incompatible 
combinational circuit independent fault set maximum size called maximum independent fault set 
problem finding maximum independent fault set np hard maximal independent fault sets practice 
minimum test set size combinational circuit single stuck fault model defined minimum number test vectors required detect testable single stuck faults circuit 
redundant vector elimination test vector fault simulate test vector fault proven redundant fault detected vector detection count detection count number essential faults detection count identify vector detects number essential faults gamma gamma number essential faults drop vector test set fault detected detection count gamma gamma detection count identify vector detects number essential faults rve algorithm redundant vector elimination automatic test pattern generation faults detected earlier test vectors may incidentally detected test vectors generated 
result vectors generated atpg process test vector generated earlier may redundant 
redundant vector elimination rve algorithm identifies redundant vectors test generation dynamically drops test set 
shown rve fault simulates faults fault list ones proven keeps track faults detected vector number essential faults vector number times fault detected 
test generation number essential faults vector reduces zero vector redundant dropped test set 
illustrated example rve algorithm reduce size test set reverse order fault simulation 
identify redundant test vector faults detected detected test vectors generated earlier 
identify redundant vector faults detected detected test vectors generated 
example consider fault set ff suppose fault set atpg system generated test set order detects faults detects faults detects faults example generated rve algorithm determines redundant drops test set 
reduces test set reduce size test set 
performance rve algorithm similar double detection dd algorithm introduced slightly different results may produced order dropping redundant vectors 
proposing rve standalone test set compaction algorithm step step compaction framework includes rve essential fault reduction efr algorithms 
addition number essential faults test vector obtained dd efr needs additional information produced rve faults detected test vector exact number times fault detected current test set 
dd rve efr obtain information 
rve spends execution time computing information execution time rve efr algorithms combined smaller dd efr algorithms combined 
essential fault reduction test set int int int times test vector essential faults ef pruned true failure limit essential fault pruned false test vector pruned multiple target test generation pruned true break pruned true update replacing new test vector fault simulate new test vector failure limit ef pruned false failure limit break ef pruned true drop vector efr algorithm essential fault reduction pruning essential fault test vector decreases number essential faults essential faults test vector pruned redundant dropped test set 
shown initial test set generated essential fault reduction efr algorithm iteratively compact test set pruning essential faults vector possible 
efr uses multiple target test generation procedure generate test vector detect set faults 
efr algorithm improves tbo essential fault pruning efp algorithms 
initial test set tbo tries reduce test set size replacing test vectors new 
achieved finding test vector detects essential faults vectors faults detected vectors 
possible find test vector may possible eliminate test vectors test set 
may achieved algorithm tries replace test vectors new ones 
general algorithm extended algorithm 
worst case tbo needs check vector pairs possible compaction number test vectors initial test set needs check vector triplets general algorithm needs check vector sets 
algorithm computationally expensive implementation algorithm reported 
efp hand tries reduce test set size trying prune essential faults test vector 
essential faults test vector pruned vector redundant dropped test set 
tbo seen special case efp test vector allowed prune essential faults replacing vector 
efp achieves better performance tbo relaxing restriction allowing test vector prune essential faults replacing vector test set 
worst case efp try generate test vector fault sets number essential faults number test vectors initial test set 
cases larger efp computationally expensive tbo 
cases algorithm computationally expensive 
problem compacting test set viewed distributing essential faults test set test vectors number redundant vectors maximized 
search space explored possible distributions essential faults test vectors 
tbo efp algorithms global view search space carry localized greedy search concentrating removing test vector time test set pruning essential faults 
prune essential fault test vector causes vector redundant prune essential fault 
restriction explore part search space 
example illustrates limitation algorithms 
test set tbo efp algorithms try prune essential faults test vector require essential faults pruned case vector dropped test set original test set retained 
fail prune essential faults processing recover original test set 
restriction partial essential fault pruning may prevent eliminating test vector test set 
essential faults may incompatible essential faults test vectors test set may compatible essential faults 
allowed prune incompatible essential fault essential faults pruned dropped test set 
dropped test set 
efr algorithm hand global view search space 
overcomes limitation tbo efp algorithms carrying non greedy global search trying distribute essential faults test vectors number redundant vectors maximized 
vector redundant efr tries reduce number essential faults test vector faults detected detected redundant test vector faults detected test vector faults detected test vector faults detected detected step step step incompatibility graph initial test set efr example possible trying prune essential faults possible 
fails prune essential faults test vector tries prune essential faults 
way efr explores larger portion search space tbo efp 
illustrated example new search technique efr produce smaller test sets ones produced tbo efp algorithms 
example consider test set ft suppose detects faults ff detects ff detects ff detects ff adjacency list representation incompatibility graph 
efr reduce size test set iteration 
illustrated achieved replacing test vectors detects detects detects replacements redundant dropped test set 
tbo efp algorithms reduce size initial test set 
illustrated example means new search technique efr compact test set iteratively 
possible tbo 
possible efp may compact test set iteratively happen new test vectors accidentally detects essential faults test vectors intended detect 
may possible prune essential faults test vector second iteration possible iteration 
example consider test set ft suppose detects faults ff detects ff detects ff detects ff detects ff adjacency list representation incompatibility graph 
illustrated iteration efr algorithm pruned replacing pruned replacing iteration efr able reduce test set size 
iteration essential fault essential fault anymore second iteration pruned replacing pruned replacing redundant dropped test set 
hand tbo efp algorithms reduce size initial test set 
efr worst case computational complexity efp try generate test vector fault sets number essential faults number test vectors initial test set 
iteratively worst case complexity number iterations 
incompatibility graph test vector initial test set faults detected test vector step detected faults test vector step detected faults detected redundant detected test vector step detected faults test vector step faults detected iteration iteration efr iteration example speed techniques section propose techniques reducing average case execution time efr algorithm 
introduce new incompatibility relation stuck faults 
possible fault pairwise compatible faults fault set may incompatible faults targeted 
illustrated example 
fault set incompatibility example illustrates situation fault compatible different faults compatible fault set including faults 
circuit shown primary inputs primary outputs 
circuit faults fa pairwise compatible pair possible generate test vector detects faults detects detects detects 
possible generate test vector detects faults compatible fault set fa 
logic assignments necessary detect respectively imply 
conflicts logic assignment necessary excite fault possible detect faults single test vector 
incompatibility graph speed tbo efp algorithms 
incompatibility relation explained represented incompatibility graph definition 
extended definition incompatibility graph allowing graph node represent set faults 
new incompatibility graph constructed demand driven way compaction speeding efr algorithm 
observed new incompatibility graph reduced execution time efr algorithm 
propose technique speeding efr algorithm observation 
suppose efr trying prune essential faults vector trying replace vectors test set new ones order failing prune essential fault replacing test vectors successfully pruned replacing indicates may possible prune essential fault replacing trying prune essential fault may worth trying 
may avoid unsuccessful calls procedure 
may turn essential fault pruned replacing pruned replacing vector case trying prune essential fault may worth trying replace trying vectors test set 
observation heuristic technique works follows 
vector heuristic technique keeps track new vectors generated pruning essential faults tries prune essential fault trying replace vectors trying vectors test set 
observed heuristic considerably reduced number calls procedure execution time efr algorithm 
minimum test set size estimation able assess effectiveness test set compaction algorithms combinational circuit necessary know minimum test set size circuit 
addition known test set compaction time reduced stopping iteration efr algorithm minimum test set size reached iterating predetermined number times 
problem computing size minimum single stuck fault test set irredundant combinational circuit proven np hard heuristic techniques finding lower bound 
commonly heuristics finding lower bound finding size maximal independent fault set 
size maximal independent fault set equal minimum test set size 
maximal independent fault set computed finding maximal clique incompatibility graph single stuck fault set 
problem finding maximal clique graph proven np complete heuristics proposed finding maximal clique incompatibility graph 
essential faults test vectors test set highly incompatible suggested compute maximal clique considering essential faults enlarging clique considering faults 
reported circuits computing maximal clique incompatibility graph constructed essential faults larger cliques computing maximal clique incompatibility graph constructed considering faults 
theorem corollary compute maximal clique considering essential faults enlarging clique considering faults fault list 
theorem complete single stuck fault test set ts size combinational circuit exists maximal independent fault set size circuit contains essential faults different test vector 
proof 
exists maximal independent fault set size definition pairwise incompatible faults 
faults pairwise incompatible test vector detect fault 
fault detected different test vector ts 
test set complete test vectors ts detect faults 
faults detected remaining test vectors ts essential fault different test vector ts 
worst case remaining test vectors detects different fault 
faults detected vectors essential faults 
worst case faults essential fault different test vector ts 
words contains essential faults different test vector 
corollary complete single stuck fault test set ts size combinational circuit exists maximal independent fault set size circuit contains essential fault test vector ts 
proof 
theorem contain essential fault test vectors ts size maximal independent fault set 
expression equal ts test vectors means contain essential fault test vector ts 
theorem shows maximal clique incompatibility graph small test set contain essential faults corollary indicates minimum size test set exists clique size incompatibility graph clique contains essential faults 
efr algorithm produces test sets minimum size close theorem compute lower bound searching maximal clique includes essential fault test vectors possible test set produced efr algorithm enlarging clique considering faults fault list 
size search space computing maximal clique choosing essential fault test vectors possible large computationally expensive search exhaustively 
vectors ft test set sizes essential fault sets efs efs efs respectively size search space efs 
propose new heuristic guide branch bound search algorithm 
trying choose essential fault test vector consider vectors ascending order number essential faults explore branches initial test vectors 
heuristic increases probability computing maximal clique short amount time reason 
essential fault included clique reduces number essential faults remaining test vectors included clique 
test vector efs essential faults essential faults equally maximal clique trying select essential fault test vector probability choosing essential fault maximal clique efs number essential faults included maximal clique decreases probability selecting essential fault maximal clique increases 
test vectors small number essential faults probability selecting essential fault maximal clique high selecting essential faults test vectors larger number essential faults probability selecting essential fault maximal clique increases considering vectors smaller number essential faults increases probability computing maximal clique short amount time 
experimental results incorporated minimum test set size estimation rve efr algorithms propose dynamic compaction algorithm proposed atom advanced atpg system combinational circuits 
called new compact test generator mintest 
mintest designed object oriented style implemented 
tested mintest iscas full scan versions iscas benchmark circuits 
performance results mintest obtained mhz pentium pro pc mb ram running linux gnu cc version 
compared performance mintest minimum test set size estimation previously published results comparision performance results table 
sign table indicates lower bound circuit reported 
results show algorithm computed better lower bounds previously published ones 
circuits lower bounds computed algorithm greater equal best published lower bounds 
circuits algorithm computed larger lower bounds previously published results larger larger larger 
new lower bounds indicated asterisk table 
minimum test set size estimation algorithm applicable large circuits execution time similar algorithms 
algorithm applied small circuits circuits algorithm computed table lower bounds minimum test set size mintest circuit loc glb lb time total total lower bounds 
algorithm computationally expensive algorithm execution time iscas circuits performance iscas circuits reported 
performance mintest test set compaction table 
table columns headed det red abt number detected faults number faults proven redundant number aborted faults respectively 
columns headed base dc dc rve dc rve efr performance mintest compaction techniques base dynamic compaction dc dynamic compaction rve dc rve dynamic compaction rve efr algorithms dc rve efr respectively 
results show dynamic compaction technique effective reducing test set sizes short amount time 
rve algorithm reduces test set sizes moderately 
rve spends execution time computing information needed efr algorithm contributes little total execution time 
cost effective technique 
furthermore helps reduce execution time efr producing relatively smaller initial test set 
efr algorithm effective compacting initial test sets produced dynamic compaction rve algorithms expense greater execution time 
performance mintest test set compaction compared best test set compaction algorithms published literature ct tsc 
comparison performance results table 
table smallest known test size circuit marked asterisk 
largest known lower bound minimum test set size circuit lb column 
lower bounds computed minimum test set size estimation algorithm rest taken 
table compaction results test set size time secs dc dc dc rve dc rve circuit det red abt base dc rve efr base dc rve efr table comparision compaction results test set size time secs mintest mintest circuit lb ct tsc ct tsc total total experiments backtrack limit mintest 
execution times mintest include fault simulation initial test set generation times test sets generated mintest fault coverage 
performance results ct tsc taken respectively 
performance tsc iscas circuits reported 
observations experimental results 
circuits sizes test sets generated mintest smaller equal best published results 
circuits sizes test sets generated mintest equal known lower bounds circuits 
executing iteration efr algorithm mintest generated smaller test sets ct tsc iscas iscas circuits 
circuits mintest produced smaller test sets executing efr algorithm iteratively 
test sets generated mintest smaller previously published results smaller smaller smaller 
order measure performance efr algorithm iteratively iterated times circuits lower bound achieved iteration 
seen column headed circuits mintest produced smaller test sets efr iteratively 
efr algorithm iterated times mintest produced smaller test sets circuits 
results column headed 

test set sizes columns headed 
indicated iteration number test set size reached parentheses 
times column headed 
execution times mintest iterations 
table performance tsc backtrack limit 
test set sizes produced tsc backtrack limit 
execution time tsc backtrack limit reported authors say running tsc backtrack limit takes far cpu time practical backtracks tsc 
want point iteration mintest produced smaller test sets ones produced tsc backtrack limit 
ct tsc execution times table obtained sun sparc workstation 
compaction times ct mintest include initial test generation time 
compaction times tsc show execution time tsc starting initial test set 
mintest exploring larger search space execution time larger ct reported reasonable running time currently tsc applicable medium size circuits largest 
experimental results show mintest applicable large circuits 
summary chapter new algorithms generating compact test sets combinational circuits single stuck fault model new heuristic estimating minimum single stuck fault test set size 
algorithms dynamic compaction algorithm incorporated advanced atpg system combinational circuits called mintest 
mintest better lower bounds generated smaller test sets previously published results iscas full scan versions iscas benchmark circuits 
chapter pattern test set compaction pure combinational full scan circuits test sets generated stuck fault model may detect possible physical defects may occur vlsi circuits fault models increase defect coverage 
transition fault model model defects affect timing behavior circuit cmos stuck open fault model model defects cause transistors permanently 
test generation fault simulation algorithms transition stuck open fault models reported literature 
compact test sets important reducing cost testing vlsi circuits reducing test application time 
especially important fault models require pattern test sets transition stuck open fault models 
transition stuck open fault requires test vectors detected transition stuck open test sets usually larger stuck test sets resulting higher test application time 
test set compaction fault models especially critical reducing cost testing vlsi circuits 
test set compaction algorithms different heuristics proposed literature transition stuck open fault models static compaction forward backward simulation dynamic compaction 
algorithms successful producing small test sets possible reduce test set sizes 
chapter extend test set compaction algorithms proposed combinational circuits single stuck fault model fault models require pattern test sets particular transition cmos stuck open fault models :10.1.1.46.6724
algorithms dynamic compaction algorithm incorporated advanced atpg system combinational circuits called mintest 
test sets generated mintest smaller previously published pattern test set compaction results iscas full scan versions iscas benchmark circuits 
transition cmos stuck open fault models transition fault model model defects delay rising falling transition line 
types transition faults slow rise transition faults slow fall transition faults 
transition faults require pattern tests 
pattern called initialization pattern places initial value line 
second pattern called test pattern fault placing final value line causes appropriate transition propagates fault effect primary output 
slow rise slow fall transition fault tested fault target fault list tested generate initialization pattern proven initialized declare redundant test generator fails initialize declare aborted generate test pattern proven tested declare redundant test generator fails test declare aborted fault simulate vector pair fault tested proven redundant pattern test set generation algorithm initialization pattern places faulty line followed test pattern tests line stuck stuck fault 
cmos stuck open fault model model defects cause transistors permanently 
dissertation consider fully complementary cmos gates non robust tests stuck open faults 
cmos stuck open faults require pattern tests 
test generation stuck open faults cmos gate achieved generating test patterns stuck faults gate inputs 
example stuck open fault type type transistor nand gate tested initialization pattern sets output logic gate followed test pattern tests input line logic gate corresponding faulty transistor stuck stuck fault 
summary described test generation transition cmos stuck open faults requires generation successive vectors initialization pattern test pattern test pattern stuck fault test vector 
test sets generated fault models called pattern test sets successive vectors pattern test set called vector pair 
pattern test set ordered test set testing vectors vector pair applied circuit test order appear test set 
assume transition fault testing patterns applied circuit rated clock speed 
cmos stuck open fault testing patterns applied slower speed 
transition fault test generation fault lists collapsed transition fault equivalence relation described stuck open fault test generation fault lists collapsed stuck open fault equivalence relation described 
pattern test set compaction pure combinational circuits section extensions propose rve efr algorithms able generate compact test sets fault models require pattern test sets 
algorithms section applicable pure combinational circuits applicable full scan circuits 
preliminaries essential vector essential fault redundant vector definitions stuck test set section 
section define terms pattern test set introduce new term hidden redundant vector 
suppose pattern test set delta delta delta delta delta delta 
test vector test set called essential vector vector pair detects fault detected vector pair fault defined essential fault fault detected vector pair vector pair 
similarly fault defined essential fault vector pair fault detected vector pair 
words essential vector belongs vector pair detects essential fault 
test vector redundant respect detect essential faults faults detected vector pairs detected vector pair include test vector called hidden redundant vector respect essential faults detected vector pairs detected vectors applied successively circuit test order 
case may essential faults redundant removed test set removing vectors form vector pair detect essential faults detected vector pairs 
definition pruning essential fault test vector stuck test set section 
section extend definition pattern test set 
suppose denotes set faults detected vector pair 
pattern test set delta delta delta delta delta delta xp ys delta delta delta essential fault test vector said pruned vector pair test set replaced new vector pair detects satisfies properties 
ffl detects essential faults vector pair faults set fd fd detected vector pair ffl xp detects essential faults vector pair xp faults set fd xp fd xp detected vector pair ffl ys detects essential faults vector pair ys faults set fd ys fd ys detected vector pair redundant vector elimination redundant vector elimination rve algorithm fault models require pattern test sets similar rve algorithm stuck fault model 
test vector generated test generator rve fault simulates faults fault list ones proven keeps track faults initialized vector faults tested vector number essential faults vector number times fault detected 
fault simulation number essential faults vector reduces zero vector redundant drops vector test set 
simulating test vector rve algorithm checks test set hidden redundant vectors drops form test set 
addition reducing test set size dropping redundant test vector test generation advantages pattern test set generation 
rve algorithm drops test vector test set delta delta delta delta delta delta faults initialized tested detected new test set 
detects faults detected vector pair test set saves possible test generation time faults 
hand detects faults detected vector pair test set decrease number essential faults vectors 
vectors may redundant 
essential fault reduction essential fault reduction efr algorithm transition stuck open fault models similar efr algorithm stuck fault model 
essential fault test vector pattern test set pruned explained section 
initial test set generated efr algorithm reduce test set size trying prune essential faults test vector possible 
process essential faults test vector pruned vector redundant dropped test set 
efr algorithm iteratively repeating process number iterations 
example consider initial test set 
suppose test vector initialize faults example efr algorithm reduces size test set iteration 
illustrated tries prune essential faults vector prunes replacing test vector initialize faults faults prune tries prune essential faults vector prunes replacing replacing replacing essential faults pruned redundant 
vector test initialized faults tested faults initial test set vector test initialized faults step faults tested vector test initialized faults faults tested step vector test initialized faults step faults tested vector test initialized faults step faults tested redundant tested initialized tested initialized efr example dropped test set 
resulting test set vectors size test set reduced 
worst case computational complexity efr algorithm transition stuck open fault models xv number essential faults number test vectors initial test set number iterations 
heuristics decrease execution time 
incompatibility graph similar stuck fault model speed efr algorithm 
incompatibility graph set faults fs defined ig fs incompatible :10.1.1.46.6724
stuck faults called incompatible detected single test vector 
transition stuck open fault models faults called incompatible statements true faults vector initialize vector initialize test time vector initialize test time vector test 
incompatibility graph transition stuck open fault models keeps track type incompatibility represented edge 
computationally expensive construct complete incompatibility graph fault pairs number faults fault list checked incompatibility 
addition incompatibility information fault pairs may needed efr algorithm 
build incompatibility graph demand driven way compaction new incompatibilities discovered execution efr algorithm added incompatibility graph 
propose heuristic speed efr algorithm transition stuck open fault models 
able prune essential fault test vector necessary find vector pair test set vector initializes second tests 
currently essential fault pair 
test vector test set may initialize test fault 
vectors successive test set currently detect trying find vector pair detects vectors initialize test vectors pair preceding succeeding vector replaced new vector initializes tests vector pair generated way technique prunes replacing vector 
technique considerably decreases execution time efr algorithm 
test generation system enhanced advanced atpg system combinational circuits called mintest generate pattern test sets transition stuck open fault models 
incorporated dynamic compaction algorithm pattern test sets proposed rve efr algorithms mintest 
mintest composed parallel pattern fault simulator deterministic test pattern generator 
test generator uses valued logic logic values mintest designed object oriented style implemented 
basic pattern test set generation compaction mintest uses test generation algorithm described 
compact pattern test set generation algorithm mintest described 

generate initialization pattern initializes untested faults target fault list possible 
fully unspecified fault considered proven initialized declare redundant 
fully unspecified fault considered test generator fails initialize declare aborted 

generate test pattern tests untested faults initialized possible 
fully unspecified fault considered proven tested declare redundant 
fully unspecified fault considered test generator fails test declare aborted 

unspecified inputs extend initialize untested faults possible 

call redundant vector elimination procedure parameter 
initializes untested faults assign go step 
call redundant vector elimination procedure parameter fault proven redundant aborted test generator go step 
call essential fault reduction procedure 
compact pattern test set generation algorithm experimental results mintest tested iscas full scan versions iscas benchmark circuits 
experiments treated full scan versions iscas circuits pure combinational circuits 
words assumed test vector applied circuit inputs parallel circuit outputs observed parallel serial scan scan operations 
performance results tables 
results obtained mhz pentium pro pc mb ram running linux gnu cc version 
experiments backtrack limit mintest efr algorithm iterated 
execution times mintest include fault simulation initial test set generation times applicable 
tables columns headed base dc dc rve dc rve efr performance mintest compaction techniques base dynamic compaction dc dynamic compaction rve dc rve dynamic compaction rve efr algorithms dc rve efr respec table results pure combinational circuits transition fault model test set size time secs dc dc total dc rve dc rve circuit faults det red base dc rve efr base dc rve efr table results pure combinational circuits stuck open fault model test set size time secs dc dc total dc rve dc rve circuit faults det red base dc rve efr base dc rve efr table comparison compaction results pure combinational circuits transition fault model stuck open fault model test set size time secs test set size time secs circuit ct ii mintest ct ii mintest ct ii mintest ct ii mintest total tively 
results show dynamic compaction technique effective reducing test set sizes short amount time 
rve algorithm reduces test set sizes moderately 
rve spends execution time computing information needed efr algorithm cost effective technique 
efr algorithm effective compacting initial test sets produced dynamic compaction rve algorithms expense greater execution time 
performance results mintest compared best pattern test set compaction algorithm published literature ii ct ii 
comparison performance results shown table 
performance ct ii reported iscas circuits table 
ct ii execution times obtained sun sparc workstation 
test sets generated mintest fault coverage ct ii aborted faults circuits 
performance results show mintest generated smaller test sets ct ii transition stuck open fault models expense greater execution time 
pattern test set compaction full scan circuits different techniques apply pattern test sets full scan circuits functional justification skewed load 
functional justification technique vector generated assuming scan elements fully controllable 
second vector generated assuming scan elements contain values generated application vector 
skewed load technique generates vector way 
second vector generated shifting vector bit scan chain appending bit scan input 
functional justification technique applying pattern test sets full scan circuits 
order generate pattern test sets functional justification technique circuit structure shown 
circuit obtained duplicating sequential circuit treating outputs storage elements frame primary inputs connecting inputs storage elements frame outputs storage elements second frame treating inputs storage elements second frame primary outputs 
new combinational circuit obtained modifications shown dotted lines 
new combinational circuit mapping lines frame lines second frame 
test generation transition frame frame primary outputs pseudo pseudo primary inputs pseudo primary inputs primary outputs pseudo primary outputs primary outputs primary inputs primary inputs response response response vector vector vector frame circuit stuck open fault models achieved initializing appropriate line frame testing corresponding line second frame appropriate fault 
frame second frame form single combinational circuit process test generation combinational circuits stuck fault model addition justification requirement 
atpg system stuck fault model easily enhanced generate test sets functional justification technique 
test generation transition stuck open fault functional justification technique produces vectors denoted vector vector 
testing vectors applied full scan circuit follows 
pseudo primary input values vector shifted scan chain 
clock cycle primary input values vector applied primary inputs second clock cycle second vector applied primary inputs 
output response circuit generated second clock cycle indicated response detect fault 
primary output values directly observed second clock cycle 
pseudo primary output values hand observed scan output shifted scan chain 
essential vector essential fault redundant vector essential fault pruning definitions pattern test sets generated functional justification technique ones stuck fault model 
dynamic compaction rve efr algorithms stuck fault model generate compact test sets full scan circuits transition stuck open fault models virtually modification 
difference versions algorithms underlying test generation algorithm 
vector pairs pattern set pure combinational circuit compacted vectors 
example vector pairs compacted form vector tuple tests essential faults vector pair initializes essential faults vector pair 
possible full scan circuits vector pair applied circuit separately 
sizes compact test sets generated full scan circuits considerably greater ones generated pure combinational circuits 
experimental results incorporated extensions mintest tested mintest iscas benchmark circuits 
performance results tables 
results obtained mhz pentium pro pc mb ram running linux gnu cc version 
experiments backtrack limit generation initial test set backtrack limit efr algorithm efr algorithm iterated 
mintest achieved table results full scan circuits transition fault model test set size time secs dc dc total dc rve dc rve circuit faults det red base dc rve efr base dc rve efr table results full scan circuits stuck open fault model test set size time secs dc dc total dc rve dc rve circuit faults det red base dc rve efr base dc rve efr fault coverage circuits 
transition fault model aborted faults faults faults faults faults 
stuck open fault model aborted faults faults faults faults faults 
tables columns headed base dc dc rve dc rve efr performance mintest compaction techniques base dynamic compaction dc dynamic compaction rve dc rve dynamic compaction rve efr algorithms dc rve efr respectively 
results show dynamic compaction technique effective reducing test set sizes short amount time 
rve efr algorithms quite effective generating compact test sets full scan circuits functional justification technique expense greater execution time 
summary chapter extensions proposed redundant vector elimination rve essential fault reduction efr algorithms generating compact test sets pure combinational full scan circuits fault models require pattern test sets particular transition cmos stuck open fault models 
algorithms dynamic compaction algorithm incorporated advanced atpg system combinational circuits called mintest 
test sets generated mintest smaller previously published pattern test set compaction results iscas full scan versions iscas benchmark circuits 
chapter test application time reduction full scan embedded cores chips multiple embedded cores called system chip prevalent industry core design approach considerably reduces design time design reuse 
testing embedded cores challenging problem limited access core inputs outputs 
major peripheral access techniques parallel direct access functional access serial boundary scan access 
parallel access technique provides direct access core dedicated chip pins sharing chip pins multiplexing demultiplexing signals 
approach high routing overhead difficult number core pins larger number chip pins usually case system chips multiple cores 
functional access technique provides access core justifying test patterns propagating fault effects user defined logic surrounding core 
approach small hardware overhead structure surrounding logic justification propagation difficult 
serial access technique provides indirect full access core boundary scan chain core 
routing overhead approach small hardware requirements acceptable current system chips 
serial access technique increases test application time cores due serial access core currently realistic approach providing peripheral access embedded cores 
full scan technique widely adopted dft technique industry reducing complexity test generation sequential circuits combinational circuit test generation problem making memory elements circuit controllable observable scan chain 
controlling observing flip flops done serially shifting values memory elements full scan technique increases test application time 
techniques proposed reduce test application time full scan circuits 
hybrid test generation schemes adaptively combinational sequential test generation algorithms minimizing test application time 
generate combinational test vector sequential test sequence target fault maximizes faults detected test cycle 
require sequential circuit test generation generating test set techniques computationally expensive may applicable large sequential circuits 
loading memory elements parallel parallel direct access scan inputs outputs drastically reduces test application time technique may practical high hardware overhead 
multiple scan chains reduce test application time dividing scan chain multiple partitions shifting test vector partitions parallel 
technique effective reducing test application time may primary inputs primary outputs embedded core scan chain peripheral access sytem chip si te full scan embedded core require additional input output pins 
hand access scan chains provided multiplexing chip input output pins degrades performance circuit normal mode full scan technique 
ordering memory elements single scan chain reduces test application time degree possible reduce test application time 
test application time reduction techniques proposed full scan circuits effective full scan circuits embedded cores refer full scan embedded cores 
general structure full scan embedded core shown 
hybrid test generation technique uses sequential test generation generates larger test sets combinational test generation technique full scan circuits 
vectors require shifting values memory elements input values directly applied primary inputs reduces test application time standalone full scan circuits 
serial access technique test access test application time quite large primary input values vector serially shifted boundary scan 
addition generates larger test sets combinational test generation technique full scan circuits technique difficult functional access technique increasing number vectors justified core inputs 
technique requires sequential test generation may applicable large cores 
multiple scan chains msc technique requires separate input output pins scan chain 
requirement difficult parallel access technique increasing number core pins routing overhead 
requirement difficult functional access technique increasing number values justified core inputs 
hand serial access technique test access core including scan chain inputs outputs msc technique reduce test application time input values shifted scan chain serially shifted boundary scan shifted scan chains parallel 
similarly test responses scan chains shifted boundary scan parallel serially shifted boundary scan 
test application time test application time full scan cores single scan chain 
parallel direct access memory elements impractical embedded cores direct access core inputs outputs limited 
ordering memory elements single scan chain reduces test application time full scan embedded cores degree possible reduce test application time 
previous techniques proposed reduce test application time full scan circuits suitable full scan embedded cores propose new dft technique parallel serial full scan psfs reducing test application time full scan embedded cores 
psfs technique additional test access pins ones full scan technique require large number test vectors applicable full scan cores peripheral access techniques serial parallel functional access 
psfs techniques reduces test application time dividing scan chain multiple partitions shifting vector scan chain single scan input 
outputs scan chains observed multiple input signature analyzer misr 
order test faults detected organization faults aliased misr psfs technique preserves single scan chain structure extra multiplexers simple control structure 
performance psfs technique dependent scan chain configuration number scan chains assignment memory elements scan chains propose heuristic technique computing optimal scan chain configuration produces minimal test application time 
addition reducing test application time psfs technique important advantage testing full scan cores 
test vector addition primary input values input values longest scan chain stored tester psfs technique reduces tester storage requirements amount test data transfered tester core core back tester 
especially important large system chips multiple cores 
enhanced atom advanced atpg system combinational circuits generate test vectors single stuck fault model embedded cores incorporating psfs technique 
experimental results showed iscas circuits psfs technique reduces total test application time reduces total test data 
addition significantly reducing test application time amount test data psfs technique effective terms performance metrics 
particular uses combinational test generation applicable large cores 
doesn degrade performance core normal mode full scan technique 
doesn require additional test access pins scan scan test enable pins full scan technique 
incurs small amount hardware overhead provides combinational fault coverage 
dissertation applied psfs technique flip flops full scan core assumed inputs outputs core accessed peripheral access techniques 
serial boundary scan access technique test access core possible apply psfs technique flip flops core boundary scan flip flops inputs outputs core considering flip flops single scan chain dividing scan chain multiple partitions shifting vector scan chain single scan input observing outputs scan chains misr 
way test application time reduced 
similar technique psfs proposed testing multiple independent circuits simultaneously single input support scan chains circuits shifting logic values scan chains circuits 
number scan chains equal number circuits memory elements circuit assigned scan chain 
design parameter order memory elements scan chain 
circuits independent detectable faults circuit detectable organization 
psfs technique hand proposed testing single full scan embedded core 
number scan chains distribution memory elements scan chains order memory elements scan chain design parameters psfs technique 
addition psfs technique applied single full scan core detectable faults core may detectable logic values shifted multiple scan chains core 
parallel serial full scan full scan embedded cores incorporating parallel serial full scan psfs technique called psfs cores 
organization flip flops psfs core shown 
shown additional test access pins ones full scan technique scan si scan test enable te psfs cores 
full scan cores te input controls operation psfs cores 
te core operates normal mode 
operation psfs cores normal mode full scan cores 
te core operates test mode 
operation psfs cores test mode controlled control flip flop cff 
cff psfs core operates serial test mode 
operation psfs core serial test mode operation full scan cores test mode new values shifted flip flop serially si input previous values flip flops shifted serially output 
cff psfs core operates parallel test mode 
parallel test mode shifting input values flip flops shifting test response flip flops done parallel 
scan chain mux scan chain mux scan chain mux mux si te mux misr control flip flop parallel serial full scan psfs technique explain operation psfs cores test mode detail 
psfs technique divides single scan chain full scan core multiple partitions 
input scan chain driven si input 
input scan chains driven output previous scan chain si input 
selection done multiplexer mux controlled cff 
cff scan chain driven si input logic values shifted scan chain parallel 
cff scan chain driven previous scan chain flip flops behave single serial scan chain input values shifted flip flop serially si input 
output scan chain connected mux driving scan chain multiple input signature analyzer misr 
frequently built self test bist applications compressing test response multiple output circuits 
psfs technique uses misr compress test response embedded core stored flip flops 
misr compresses test response doing polynomial division 
divides input polynomial test response characteristic polynomial resulting quotient polynomial remainder polynomial final signature 
output scan chain connected different data input misr size misr psfs core equal number scan chains core 
dissertation different type internal xor bit bit misr primitive characteristic polynomials respectively 
structure bit misr shown 
data inputs output misr 
output psfs core driven output scan chain output misr 
selection done mux controlled cff 
cff output misr shifted characteristic polynomial bit misr output 
cff output driven output scan chain flip flops behave single serial scan chain logic values flip flops shifted serially output 
summary cff logic values shifted scan chain parallel si input outputs scan chains compressed misr output misr observed output 
hand cff flip flops behave single serial scan chain new values shifted flip flop serially si input previous values flip flops shifted serially output 
value cff psfs core decided si te inputs 
te core normal mode value si input loaded cff 
te core test mode cff keeps current value 
value loaded cff current normal mode operation determines parallel serial test mode observing test response vector applying test vector 
parallel test mode reduce test application time 
logic values shifted scan chain testable faults may detected parallel test mode 
misr response 
apply si te apply clock pulse 
loads control flip flop 

apply te shift parallel test vector applying clock pulses 

apply te si apply primary input values waiting combinational delay core apply clock pulse 
captures test response flip flops 

parallel test vectors applied go step 
apply te shift parallel test vector shift test response simultaneously applying clock pulses 
go step 
apply te si shift test response applying clock pulses 

apply te si apply clock pulse 
loads control flip flop 

apply te shift serial test vector applying clock pulses 

apply te si apply primary input values waiting combinational delay core apply clock pulse 
captures test response flip flops 

serial test vectors applied go step 

apply te shift serial test vector shift test response simultaneously applying clock pulses 
go step 

apply te shift test response applying clock pulses 
test application process compaction may cause faults aliased 
serial test mode test faults providing combinational fault coverage 
test vectors applied serial test mode called serial vectors test vectors applied parallel test mode called parallel vectors 
length serial vector equal number primary inputs plus number flip flops 
length parallel vector equal number flip flops longest scan chain 
test application process psfs core assuming parallel access technique test access core shown number flip flops number scan chains number flip flops longest scan chain 
steps gamma apply parallel test vectors observe responses steps gamma apply serial test vectors observe responses 
parallel test mode quotient remainder polynomial resulting polynomial division done misr observed 
applying parallel test vector step observed step output misr 
quotient polynomial applying parallel test vector observed step clock pluses final signature observed step clock pulses output misr 
scan chain configuration effectiveness psfs technique reducing test application time dependent scan chain configuration number scan chains assignment flip flops scan chains 
propose heuristic technique computing optimal scan chain configuration provides minimal test application time 
number scan chains number scan chains increases amount parallelism increases parallel vector length decreases decreasing test application time 
large number scan chains increases number faults tested parallel test mode increasing number serial vectors starts increasing test application time 
number scan chains increases hardware overhead psfs technique increases large number muxes large misr extra routing needed 
core computationally prohibitive compute optimum number scan chains dissertation selected number scan chains trying avoid small large number scan chains relative number flip flops core 
criterion experiments scan chains cores flip flops scan chains cores flip flops 
mapping flip flops scan chains finding optimum scan chain configuration produce minimum number test cycles np hard problem requires solving problem generating minimum size stuck test set combinational circuit proven np hard 
special case evenly distributing flip flops scan chains number different scan chain configurations possibly different test application times nsc nsc sc total number flip flops sc number scan chains maxn sc maximum number scan chains 
computationally prohibitive search entire scan chain configuration space finding optimum scan chain configuration 
propose heuristic mapping technique finding optimal scan chain configuration 
heuristic assumes number scan chains circuit sc tries map flip flops scan chains minimal test application time achieved 
inputs combinational circuit said compatible shorted introducing redundant stuck fault circuit inputs called incompatible 
similarly set inputs said compatible inputs set shorted introducing redundant stuck fault circuit 
set compatible inputs said form compatibility class 
parallel testing mode corresponding flip flops scan chain assigned logic value 
restriction may prevent detection testable faults increasing test application time increasing number serial vectors necessary achieve fault coverage 
flip flops compatible restriction introduce artificial redundancies 
heuristic mapping technique tries assign compatible flip flops position scan chain may incur routing overhead depending structure full scan core 
assigning compatible flip flops position scan chain requires finding compatibility classes size sc common greedy heuristic solving problem 
heuristic technique considers flip flop time 
flip flop assigned compatibility class 
flip flop compatible assigned compatibility class assigned new compatibility class 
flip flop compatible flip flops existing compatibility class sc flip flops added class assigned new compatibility class 
step repeated flip flop circuit 
exact techniques checking compatibility set flip flops computationally expensive heuristic technique described deciding set flip flops compatible 
heuristic technique generates complete partially specified test set full scan circuit test set compaction algorithm 
resulting test set represented dimensional matrix row test vector column values assigned single flip flop circuit 
set columns matrix compatible row corresponding logic values columns ones don care logic value 
example test set matrix shown columns compatible 
columns partially specified test set matrix incompatible columns incompatible logic values second row different don care 
set columns test set matrix compatible corresponding compatible 
set columns incompatible possible conclude corresponding flip flops incompatible possible different test set columns corresponding flip flops may compatible 
heuristic technique pessimistic identifying compatible flip flops may fail prove compatibility compatible flip flops 
compatibility classes computed heuristic mapping technique uses information mapping flip flops scan chains 
sorts compatibility classes descending order cardinality 
starting position scan chain assigns flip flops compatibility class size sc position scan chain flip flops compatibility class size sc assigned position scan chain flip flops second compatibility class size sc assigned second position scan chain 
assigns flip flops compatibility class size sc position scan chains fills position remaining scan chains flip flops compatibility classes size sc assigns flip flops remaining compatibility classes size sc position scan chains leaving position remaining scan chains empty 
second step heuristic mapping technique may cause faults parallel test mode flip flops assigned position scan chain may incompatible 
increases number serial vectors necessary achieve fault coverage increasing test application time 
assignment reduces size longest scan chain reducing test application time 
number artificial redundancies introduced amount reduction achieved longest scan chain size depends number incompatible flip flops assigned position scan chain 
number large may increase test application time helps decrease 
order reduce size longest scan chain causing large number artificial redundancies heuristic technique assigns sc incompatible flip flops position scan chain 
order assess effectiveness heuristic optimal mapping technique measured performance psfs technique different mapping technique called default mapping try find optimal scan chain configuration produces minimal test application time 
default mapping technique distributes flip flops evenly scan chain flip flop order circuit description flip flops assigned scan chain flip flops assigned scan chain number lip gammaf number scan chains 
example consider full scan embedded core flip flops 
suppose scan chains circuit 
shown default mapping technique assigns flip flops evenly scan chain flip flop order circuit description 
suppose heuristic computing compatibility classes ii iii iv vi scan chains default mapping compatibility classes ii iii iv vi scan chains optimal mapping scan chain configuration example computed compatibility classes core flip flops shown 
optimal mapping technique assigns flip flops scan chains compatibility information explained section 
resulting scan chain configuration shown 
test generation problem generating minimum size test set scan chain configuration np hard requires solving problem generating minimum size stuck test set combinational circuit proven np hard 
dissertation heuristic test set compaction algorithms dynamic compaction redundant vector elimination generating compact test sets psfs cores scan chain configuration :10.1.1.46.6724
test generation process scan chain configuration proceeds follows 
minimal test set detects faults detectable parallel test mode generated 
test generation process parallel test mode test generation constraint flip flops assigned position scan chain assigned logic value test vector taken account 
misr fault simulated vectors test set faults aliased misr faults signatures circuit signature identified 
proofs sequential circuit fault simulation algorithm simulating misr 
serial test mode minimal test set detects aliased faults faults undetectable parallel test mode generated 
final test set union test set parallel test vectors serial test vectors 
experimental results order generate test vectors psfs cores single stuck fault model enhanced atom advanced atpg system combinational circuits implemented sequential circuit fault simulator proofs algorithm simulating misr incorporated atom 
atom new extensions implemented 
test application time small iscas circuits small number flip flops sizes minimal test sets quite small circuits :10.1.1.46.6724
tested atom large iscas circuits 
assumed circuits full scan embedded cores 
performance results obtained mhz pentium pro pc mb ram running linux gnu cc version 
experiments backtrack limit atom test sets generated atom fault coverage 
experimental results full scan embedded cores table 
columns table core name number core inputs number core outputs number flip flops core number test vectors table results full scan embedded cores core inputs outputs flip flops test vectors test cycles test data bits time minimal test set number cycles necessary test core amount test data number bits stored tester testing core test generation time seconds respectively 
experimental results full scan cores table obtained assuming parallel access technique test access core inputs outputs 
test application time full scan core computed number flip flops number test vectors test application process vector shifting current vector shifting circuit response previous vector overlapped shifting flip flop values cycle applying input vector capturing circuit response 
experimental results psfs cores default optimal scan chain configuration techniques tables respectively 
columns tables core name number scan chains number flip flops longest scan chain number parallel test vectors number faults detected parallel test mode number faults aliased misr number serial test vectors testing aliased faults faults detected parallel test mode table results psfs cores default scan chain configuration longest parallel serial test scan scan test aliased test test data core chains chain vectors faults faults vectors cycles bits time table results psfs cores optimal scan chain configuration longest parallel serial test scan scan test aliased test test data core chains chain vectors faults faults vectors cycles bits time number cycles necessary test core amount test data number bits stored tester testing core test generation time seconds respectively 
experimental results psfs cores tables obtained assuming parallel access technique test access core inputs outputs 
test application time psfs core computed lsc lsc number flip flops circuit lsc number flip flops longest scan chain number scan chains number parallel test vectors number serial test vectors 
table partially specified test set generation compaction detected redundant aborted test core faults faults faults vectors time test generation time psfs cores heuristic optimal mapping method table include test generation time generating partially specified test sets 
includes time compute optimal mapping partially specified test set test generation time scan chain configuration 
experimental results generating partially specified test sets test set compaction algorithm table 
comparison test application time amount test data full scan cores psfs cores tables respectively 
percent reduction columns table percentage test application time reduction compared full scan cores percent reduction columns table percentage test data reduction compared full scan cores 
percentage test application time reduction computed original est cycles gamma reduced est cycles original est cycles percentage test data reduction computed original est data gamma reduced est data original est data results show psfs technique quite effective reducing test application time test storage requirements iscas circuits table comparison test application time psfs psfs full scan default scan chain optimal scan chain test test percent test percent circuit cycles cycles reduction cycles reduction table comparison test data psfs psfs full scan default scan chain optimal scan chain test data test data percent test data percent circuit bits bits reduction bits reduction default mapping method 
test generation time default scan chain configuration quite small 
may case full scan embedded core default mapping method provides satisfactory test application time reduction avoids design time heuristic optimal mapping technique 
results show embedded cores layout information configure scan chains reduce routing overhead psfs technique sacrificing advantage reduced test application time 
results show psfs technique heuristic optimal mapping method significantly reduces test application time test storage requirements full scan cores 
iscas circuits total test application time reduced total test data reduced 
results show heuristic optimal mapping technique effective default mapping technique 
design time computing optimal scan chain configuration test generation time configuration small 
effectiveness psfs technique core depends existence compatible flip flops core 
psfs technique effective iscas circuits flip flops full scan core highly incompatible may effective reducing test application time full scan core 
results showed circuits parallel vectors achieved fault coverage misr cause aliasing 
serial vectors needed circuits need preserve single serial scan structure extra multiplexers control structure 
psfs technique incurs smaller hardware overhead circuits 
summary chapter new dft technique parallel serial full scan psfs reducing test application time full scan embedded cores additional test access pins ones full scan technique 
heuristic technique computing optimal scan chain configuration psfs core obtain minimal test application time 
enhanced atom generate test vectors psfs cores single stuck fault model 
experimental results iscas benchmark circuits showed psfs technique significantly reduces test application time amount test data full scan embedded cores 
chapter test application time reduction built self test test pattern generators built self test bist effective technique testing vlsi circuits reduces dependency expensive external test equipment provides speed system testing circuit test cut 
bist technique requires chip test pattern generator tpg output response analyzer ora testing cut 
applicability bist technique cut depends ability design low overhead test pattern generator achieve high fault coverage small amount test application time 
different design techniques proposed address problem exhaustive testing pseudo exhaustive testing pseudo random testing weighted random testing pseudo random testing transformed pseudo random patterns deterministic test set embedding counter exhaustive testing 
input output mapping logic primary inputs circuit test combinational bit binary counter counter bist test pattern generator illustrated counter exhaustive testing technique uses bit binary counter generate possible bit patterns mapped primary inputs cut primary inputs technique guarantees detection testable stuck faults 
achieved synthesizing mapping logic compatibility relations primary inputs cut introduced 
mapping logic includes direct connections inverters includes binary decoders 
technique face problem random pattern resistant faults achieves stuck fault coverage low hardware overhead 
requires relatively high test application time 
propose new technique reducing test application time counter exhaustive bist test pattern generators 
technique reduces size binary counter reducing test application time test pattern generator small multiple input combinational circuit mapping logic 
synthesis multiple input combinational circuit new input compatibility relation called compatibility propose dissertation 
incorporated synthesis algorithm synthesizing bist test pattern generators compatibility technique atom advanced atpg system combinational circuits 
experimental results showed test pattern generators synthesized compatibility relation iscas full scan versions iscas benchmark circuits achieve stuck fault coverage smaller test application time previously published results 
shows compatibility technique quite effective synthesizing low overhead test pattern generators require small test application time 
input compatibility relations section definitions input compatibility relations previously introduced literature 
new input compatibility relation introduce dissertation allows synthesis low overhead bist test pattern generators require smaller test application time previously published counter exhaustive test pattern generators 
inputs combinational circuit said directly compatible shorted introducing redundant stuck fault circuit 
similarly inputs combinational circuit shorted inverter introducing redundant stuck fault circuit inputs called inversely compatible 
inputs directly inversely compatible called incompatible inputs 
set inputs said form compatibility class inputs set shorted introducing redundant stuck fault circuit 
bit binary counter circuit test direct inverse compatibility example opposite case inversely compatible inputs logic value applied inputs compatibility class testing introducing redundant stuck fault circuit size binary counter counter exhaustive test pattern generators equal number compatibility classes 
example consider combinational circuit 
suppose inputs directly compatible inputs inversely compatible inputs 
inputs form compatibility class inputs form compatibility class 
illustrated compatibility classes testable faults circuit tested bit binary counter 
inputs circuit said decoder compatible compatible detectable stuck faults circuit tested test set test vector requires inputs 
definition generalized include number inputs inputs 
circuit said compatible detectable stuck faults circuit tested test set test vector requires inputs 
decoder compatibility reduce size binary counter obtained direct inverse incompatibility inputs inputs 
directly inversely incompatible possible inputs compatible 
values inputs 
test vector generated binary counter log stages reducing size binary counter test pattern generator 
dissertation introduce new compatibility relation inputs circuit called combinational compatibility compatibility 
inputs 
circuit said cn compatible input circuit output input output combinational circuit inputs 
connected introducing redundant stuck fault circuit 
combinational circuit degenerates input output combinational circuit single line inverter 
case input said compatible input similarly combinational circuit degenerates input output combinational circuit 
case inputs said compatible input similarly compatibility defined 
compatibility general compatibility relation inputs circuit previously introduced compatibility relations 
previously introduced direct inverse decoder compatibilities special cases compatibility 
direct inverse compatibilities correspond compatibility 
decoder compatibility corresponds compatibility multiple output combinational circuit combinational circuit decoder 
bit binary counter bit binary counter compatibility compatibility circuit test circuit test compatibility example compatibility provides opportunities reducing size binary counter test pattern generator 
turn reduces test application time 
example inputs circuit pairwise incompatible compatible inputs compatible third reducing size binary counter reduces test application time 
example consider combinational circuit 
suppose inputs directly compatible input inversely compatible inputs 
inputs form compatibility class inputs form compatibility class input forms compatibility class 
illustrated compatibility classes counter exhaustive testing technique compatibility relation direct inverse compatibilities requires bit 
generate complete partially specified test set circuit 
find compatibility direct inverse compatibility classes test set 
find necessary input assignments testable fault 
find compatibility classes test pattern generation necessary avoid test pattern generation inputs proven incompatible necessary input assignments 
find compatible inputs considering possible input combinational functions input pair test pattern generation necessary synthesis algorithm binary counter 
hand illustrated inputs compatible input counter exhaustive testing technique compatibility compatibility relations requires bit binary counter 
compatibility relation reduces test application time 
synthesis algorithm section describe algorithm synthesize bist test pattern generators compatibility relation 
synthesis algorithm 
dissertation compatibility compatibility relations synthesizing test pattern generators 
possible extend synthesis algorithm cn compatibility relations 
finding compatible inputs synthesis algorithm finds compatibility direct inverse compatibility classes common greedy heuristic 
heuristic technique considers input time 
input assigned compatibility class 
input compatible assigned compatibility class assigned new compatibility class 
input compatible inputs existing compatibility class added class assigned new compatibility class 
step repeated input circuit 
computing compatibility classes requires checking compatibility set inputs 
synthesis algorithm uses heuristic technique described checking compatibility set inputs 
explained section heuristic technique generates complete partially specified stuck test set circuit 
resulting test set represented dimensional matrix row test vector column set values assigned single input circuit 
set columns matrix compatible row corresponding logic values columns ones don care logic value 
set columns test set matrix compatible corresponding circuit inputs compatible 
set columns incompatible show corresponding inputs incompatible possible different test set columns corresponding inputs may compatible 
heuristic technique pessimistic identifying compatible inputs may fail prove compatibility compatible inputs 
quickly identifying large number compatibility classes heuristic technique checking compatibility set inputs synthesis algorithm tries find classes computationally expensive technique similar checking compatibility set inputs 
technique checks compatibility set inputs test generation determine inputs introduces redundant stuck faults circuit 
computationally inexpensive technique usually identifies large number compatibility classes computationally expensive technique needs explore small search space 
technique checks compatibility set inputs follows 
tries prove incompatibility inputs doing explicit test generation 
achieved necessary assignments detecting testable faults circuit 
computationally inexpensive heuristic technique identifying compatibility classes synthesis algorithm determines necessary assignments detecting testable fault circuit unique sensitization improved unique sensitization techniques 
fault necessary assignments corresponding primary inputs stored 
necessary primary input assignments fault covered necessary primary input assignments fault necessary assignments fault stored 
explicit test generation computationally expensive technique checks necessary assignments find prove incompatibility inputs 
example necessary primary input assignments fault require value input value input proves inputs directly compatible inputs shorted fault redundant 
incompatibility set inputs proved necessary primary input assignments computationally expensive technique uses test generation check compatibility inputs 
maintains complete test set process 
trying decide compatibility set inputs checks test set identify test vectors incompatible values inputs 
example synthesis algorithm checking direct compatibility inputs test vector incompatible values inputs value inputs value 
faults detected vectors incompatible values inputs may potentially redundant inputs 
technique carries test generation faults determine redundant 
faults proven redundant concludes inputs incompatible 
hand faults detected inputs declared compatible 
finding compatible inputs finding compatibility classes synthesis algorithm tries reduce size binary counter test pattern generator finding compatible inputs 
process uses representative input compatibility class 
checks pair inputs possible compatibility representative input 
size search space needs explored process proportional number compatibility classes 
number compatibility classes combinational circuit usually number primary inputs size search space relatively small 
integer total number combinational functions inputs expression combinational functions inputs 
input functions constant constant input functions remaining input functions xor xnor input combinational functions finding compatible inputs input combinational functions finding compatible inputs 
input pair different gate types tried deciding inputs compatible input 
input pair input gate type synthesis algorithm checks necessary primary input assignments order prove compatible example necessary primary input assignments fault requires value input value input value input proves inputs compatible gate type 
output input gate inputs connected connected fault redundant 
incompatibility inputs proved necessary primary input assignments synthesis algorithm uses test generation check compatibility inputs 
maintains complete test set process 
trying decide compatibility inputs third gate type checks test set identify test vectors incompatible values inputs gate type 
example synthesis algorithm checking compatibility inputs input gate type test vector incompatible values inputs gate type value value 
faults detected vectors incompatible values inputs may potentially redundant connecting output input gate inputs connected inputs third input 
synthesis algorithm carries test generation faults determine redundant 
faults proven redundant concludes inputs compatible third 
hand faults detected inputs declared compatible 
experimental results incorporated synthesis algorithm atom advanced atpg system combinational circuits 
atom synthesis algorithm implemented 
atom tested iscas full scan versions iscas benchmark circuits mhz pentium pro pc mb ram running linux gnu cc version 
performance results atom compared best published results literature comparison performance results shown table 
execution times synthesizing test pattern generators reported 
addition experimental results largest iscas circuits reported indicated sign table 
synthesis times compatibility technique table include test generation fault simulation times applicable 
synthesis times column headed comp 
include execution times finding compatibilities 
experiments backtrack limit atom 
test sets generated atom fault coverage 
reducing size binary counter reduces test application time exponentially reducing size reduces test application time reducing size reduces test application time achieved significant test application time reduction counter exhaustive test pattern generators 
experimental results show test pattern generators synthesized compatibility technique require smaller test application time iscas full scan versions iscas benchmark circuits previously published counter exhaustive bist test pattern generators 
results show table synthesis results number counter compatibility sizes counter size synthesis time secs circuit inputs reported comp 
comp 
comp 
comp 
compatibility technique quite effective synthesizing low overhead test pattern generators require small test application time 
summary chapter new technique called compatibility reducing test application time built self test bist test pattern generators 
incorporated synthesis algorithm synthesizing bist test pattern generators compatibility technique atom 
experimental results showed test pattern generators synthesized technique iscas full scan versions iscas benchmark circuits achieve stuck fault coverage smaller test application time previously published counter exhaustive bist test pattern generators 
chapter dissertation proposed new efficient robust structure techniques speeding deterministic test pattern generation combinational circuits 
techniques improve average case performance algorithm reducing number backtracks low computational cost 
achieved finding necessary signal line assignments detecting conflicts earlier avoiding unnecessary test generation 
able assess effectiveness proposed techniques developed deterministic atpg system combinational circuits called atom incorporated techniques test generator 
experimental results showed benchmark circuits atom detected testable faults proved redundant faults redundant small number backtracks short amount time demonstrating effectiveness techniques test generation performance 
results achieved initial random test generation phase similar results obtained fault simulation results demonstrated robustness techniques 
extended techniques sequential circuits proposed new techniques speeding deterministic test pattern generation sequential circuits 
techniques improve average case performance iterative logic array deterministic sequential circuit test generation algorithms 
able assess effectiveness proposed techniques developed new atpg system sequential circuits called atoms atom underlying combinational circuit test generation system incorporated techniques test generator 
experimental results showed atoms achieved high fault coverages short amount time sequential benchmark circuits demonstrating effectiveness techniques test generation performance 
proposed new algorithms redundant vector elimination rve essential fault reduction efr generating compact test sets combinational circuits single stuck fault model new heuristic estimating minimum single stuck fault test set size 
incorporated algorithms dynamic compaction algorithm atom 
called new compact test generator mintest 
experimental results showed mintest better lower bounds generated smaller test sets previously published results benchmark circuits 
extended rve efr algorithms generating compact test sets pure combinational full scan circuits fault models require test sets particular transition cmos stuck open fault models 
incorporated algorithms dynamic compaction algorithm pattern fault models mintest 
experimental results showed mintest generated smaller test sets previously published pattern test set compaction results benchmark circuits 
proposed new dft technique parallel serial full scan psfs reducing test application time full scan embedded cores additional test access pins ones full scan technique 
proposed heuristic technique computing optimal scan chain configuration cores obtain minimal test application time 
enhanced atom generate stuck test vectors embedded cores new dft technique 
experimental results showed psfs technique significantly reduced test application time amount test data benchmark circuits 
proposed new synthesis technique called compatibility reducing test application time counter exhaustive bist test pattern generators 
technique reduces test application time reducing size binary counter counter test pattern generators 
incorporated synthesis algorithm synthesizing bist test pattern generators compatibility technique atom 
experimental results showed test pattern generators synthesized technique benchmark circuits achieved fault coverage smaller test application time previously published counter exhaustive bist test pattern generators 
research combinational sequential test generators currently handle logic primitives multiplexer buffer primitives exist benchmark circuits assess effectiveness test generation techniques proposed 
logic primitives industrial circuits 
order assess effectiveness new techniques industrial circuits combinational sequential test generators extended handle additional logic primitives 
experimental results sequential benchmark circuits showed sequential circuit test pattern generator achieved high fault coverages benchmark circuits achieve stuck fault coverage circuits 
detailed analysis results indicated faults aborted state justification phase test generator find justification sequences faults 
order generate better quality test sets new techniques improving performance state justification phase sequential circuit test generation algorithm investigated 
test set compaction algorithms rve efr minimum test set size estimation heuristic proposed dissertation extended sequential circuits 
number test set compaction algorithms proposed literature sequential circuits algorithms utilize test set compaction concepts introduced rve efr algorithms 
extension rve efr algorithms sequential circuits generate smaller test sets previously published results 
dissertation compatibility compatibility relations synthesizing counter exhaustive bist test pattern generators 
possible extend synthesis algorithm cn compatibility relations 
general compatibility relations provide opportunities reducing size binary counter test pattern generator reducing test application time 
kulikowski menon miller smart fast test generation vlsi scan design circuits ieee design test computers pp 
august 
breuer friedman 
digital systems testing testable design 
ieee computer society press new york 
agarwal store generate built testing approach int 
symp 
fault tolerant computing pp 
june 
agrawal tutorial built self test part principles ieee design test computers pp 
march 
agrawal tutorial built self test part applications ieee design test computers pp 
june 
akers joseph krishnamurthy role independent fault sets generation minimal test sets proc 
int 
test conf pp 
august 
akers test set embedding built self test environment proc 
int 
test conf pp 
october 
new dynamic test vector compaction automatic test pattern generation ieee trans 
computer aided design vol 
pp 
march 
rosen comparison ac self testing procedures proc 
int 
test conf pp 
october 
static test sequence compaction segment reordering accelerated vector restoration proc 
int 
test conf pp 
october 
static compaction overlapped restoration segment pruning proc 
int 
conf 
computer aided design pp 
november 
fujiwara neutral netlist combinational benchmark designs special translator fortran proc 
int 
symp 
circuits systems june 
bryan combinational profiles sequential benchmark circuits proc 
int 
symp 
circuits systems pp 
may 
murray liu zhu test width compression built self testing proc 
int 
test conf pp 
october 
agrawal transitive closure algorithm test generation ieee trans 
computer aided design vol 
pp 
july 
raghunathan bottleneck removal algorithm dynamic compaction sequential circuits ieee trans 
computer aided design vol 
pp 
october 
chakravarty ravi computing optimal test sequences complete test sets stuck open faults cmos circuits ieee trans 
computeraided design vol 
pp 
march 
chandra patel experimental evaluation testability measures test generation ieee trans 
computer aided design vol 
pp 
january 

chang 
lin test set compaction combinational circuits ieee trans 
computer aided design vol 
pp 
november 
chen gupta methodology design efficient bist test pattern generators proc 
int 
test conf pp 
october 
cheng gate level test generation sequential circuits acm trans 
design automation vol 
pp 
october 
cheng back algorithm sequential test generation proc 
int 
conf 
computer design pp 
october 
cheng chakraborty automatic test generation system sequential circuits ieee computer pp 
april 
cho somenzi redundancy identification removal test generation sequential circuits implicit state enumeration ieee trans 
computer aided design vol 
pp 
july 
new static compaction techniques test sequences sequential circuits proc 
european design test conf pp 
march 
patel rudnick enhancing topological atpg high level information symbolic techniques proc 
int 
conf 
computer design october 
cox stuck open transition fault testing cmos complex gates proc 
int 
test conf pp 
october 
bertrand mosaic multiple strategy oriented sequential atpg integrated circuits proc 
european design test conf pp 
march 
fujiwara complexity fault detection problems combinational logic circuits ieee trans 
computers vol 
pp 
june 
fujiwara acceleration test generation algorithms ieee trans 
computers vol 
pp 
december 
garey johnson 
computers intractability guide theory np completeness 
freeman new york 
ghosh devadas newton test generation verification highly sequential circuits ieee trans 
computer aided design vol 
pp 
may 
ghosh jha dey low overhead design testability test generation technique core systems proc 
int 
test conf pp 
october 
goel rosales test generation dynamic compaction tests digest papers test conf pp 
october 
goel implicit enumeration algorithm generate tests combinational logic circuits ieee trans 
computers vol 
pp 
march 
goldstein sandia controllability observability analysis program proc 
design automation conf pp 
june 
kaibel test generation techniques sequential circuits proc 
ieee vlsi test symp pp 
april 
kaibel advanced techniques sequential test generation proc 
european design test conf pp 
february 
guo reddy procedures static compaction test sequences synchronous sequential circuits vector restoration proc 
design automation test europe conf pp 
february 
patel new techniques deterministic test pattern generation proc 
ieee vlsi test symp pp 
april 
patel compact pattern test set generation combinational full scan circuits proc :10.1.1.46.6724
int 
test conf pp 
october 
patel test set compaction algorithms combinational circuits proc 
int 
conf 
computer aided design pp 
november 
patel reducing test application time full scan embedded cores int 
symp 
fault tolerant computing pp 
june 
patel new techniques deterministic test pattern generation journal electronic testing theory applications vol 
october 
patel test set compaction algorithms combinational circuits appear ieee trans 
computer aided design 
hsiao rudnick patel alternating strategies sequential circuit atpg proc 
european design test conf pp 
march 
hsiao rudnick patel sequential circuit test generation dynamic state traversal proc 
european design test conf pp 
february 
hsiao state relaxation subsequence removal fast static compaction sequential circuits proc 
design automation test europe conf pp 
february 
hsiao rudnick patel application genetically engineered finite state machine sequences sequential circuit atpg ieee trans 
computer aided design vol 
pp 
march 
hsiao rudnick patel fast static compaction algorithms sequential circuit test vectors ieee trans 
computers vol 
pp 
march 
raman direct access test scheme design block core cells embedded asics proc 
int 
test conf pp 
october 
jas test vector decompression cyclical scan chains application testing core designs proc 
int 
test conf pp 
october 
kinoshita reddy cost effective generation minimal test sets stuck faults combinational logic circuits proc 
design automation conf pp 
june 
kinoshita reddy compacting test sets addition removal test vectors proc 
ieee vlsi test symp pp 
april 
kinoshita reddy cost effective generation minimal test sets stuck faults combinational logic circuits ieee trans 
computer aided design vol 
pp 
december 
kelsey fast test generation sequential circuits proc 
int 
conf 
computer aided design pp 
november 
mercer topological search algorithm atpg proc 
design automation conf pp 
june 
th 
van der linden van de sequential test generation advanced illegal state search proc 
int 
test conf pp 
november 
th 
van der linden van de illegal state space identification sequential circuit test generation proc 
design automation test europe conf pp 
march 
krishnamurthy akers complexity estimating size test set ieee trans 
computers vol 
pp 
august 
abraham speed test generation high level primitives proc 
design automation conf pp 
june 
kundu huisman nair iyengar reddy small test generator large designs proc 
int 
test conf pp 
september 
kunz pradhan recursive learning attractive alternative decision tree test generation digital circuits proc 
int 
test conf pp 
september 
kunz pradhan accelerated dynamic learning test pattern generation combinational circuits ieee trans 
computer aided design vol 
pp 
may 
test pattern generation boolean satisfiability ieee trans 
computer aided design vol 
pp 
january 
lee reddy new test generation method sequential circuits proc 
int 
conf 
computer aided design pp 
november 
lee ha efficient automatic test pattern generator stuck open faults cmos combinational circuits proc 
design automation conf pp 
june 
lee chen huang single input support multiple scan chains proc 
int 
conf 
computer aided design pp 
november 
lee shin design test partial parallel scan ieee trans 
computer aided design vol 
pp 
february 
lee algorithm reduce test application time full scan designs proc 
int 
conf 
computer aided design pp 
november 
lempel gupta breuer test embedding discrete logarithms proc 
ieee vlsi test symp pp 
april 
menon transition faults combinational circuits input transition test generation fault simulation proc 
fault tolerant computing symp pp 
june 
lin reddy mix test generation system synchronous sequential circuits proc 
int 
conf 
vlsi design january 
ma devadas newton sangiovanni vincentelli test generation sequential circuits ieee trans 
computer aided design vol 
pp 
october 
el complexity sequential atpg proc 
european design test conf pp 
february 
effective test generation system sequential circuits proc 
design automation conf pp 
june 
fujita fast test pattern generator large scale circuits proc 
synth 
simulation meeting int 
interchange pp 
april 
mint exact algorithm finding minimum test sets ieice trans 
fundamentals vol 
pp 
october 
rudnick 
genetic algorithms vlsi design layout test automation 
prentice hall new jersey 
verification testing test technique ieee trans 
computers vol 
pp 
june 
mcdonald test set reduction subscripted proc 
int 
test conf pp 
october 
muth valued circuit model test generation ieee trans 
computers vol 
pp 
june 
narayanan gupta breuer optimal configuring multiple scan chains ieee trans 
computer aided design vol 

pp 
september 
narayanan breuer reconfiguration techniques single scan chain ieee trans 
computer aided design vol 
pp 
june 
patel test generation package sequential circuits proc 
european design automation conf pp 
february 
cheng patel proofs fast memory efficient sequential circuit fault simulator ieee trans 
computer aided design vol 
pp 
february 
roy patel abraham test compaction sequential circuits ieee trans 
computer aided design vol 
pp 
february 
patel method automatically generating test vectors digital integrated circuits patent december 
park oh mercer improved sequential atpg functional observation information new justification methods proc 
european design test conf pp 
february 
reddy reddy method generate compact test sets combinational circuits proc 
int 
test conf pp 
october 
reddy generalization independent fault sets transition faults proc 
ieee vlsi test symp pp 
april 
reddy reddy reverse order test compaction technique proc 
ieee euro asic conf pp 
september 
reddy multiple observation time test strategy ieee trans 
computers vol 
pp 
may 
reddy weight pseudorandom test generation deterministic test set combinational sequential circuits ieee trans 
computer aided design vol 
pp 
july 
reddy learning method match test pattern generator circuit test proc 
int 
test conf pp 
october 
reddy patel theory practice sequential machine testing testability int 
symp 
fault tolerant computing pp 
june 
reddy static compaction test sequences synchronous sequential circuits proc 
design automation conf pp 
june 
reddy vector restoration static compaction test sequences synchronous sequential circuits proc 
int 
conf 
computer design pp 
october 
pradhan saxena design testability scheme reduce test application time full scan proc 
ieee vlsi test symp pp 
april 
automatic test pattern generator large sequential circuits genetic algorithms proc 
int 
test conf pp 
october 
reddy reddy ii method generate compact pattern test sets combinational logic circuits proc 
int 
conf 
computer aided design pp 
november 
reddy reddy agrawal robust tests stuck open faults cmos combinational logic circuits proc 
fault tolerant computing symp pp 
june 
rudnick patel greenstein sequential circuit test generation genetic algorithm framework proc 
design automation conf pp 
june 
rudnick patel genetic approach test application time reduction full scan partial scan circuits proc 
int 
conf 
vlsi design pp 
january 
rudnick patel combining deterministic genetic approaches sequential circuit test generation proc 
design automation conf pp 
june 
rudnick patel simulation techniques dynamic test sequence compaction proc 
int 
conf 
computer aided design pp 
november 
rudnick patel potential fault detection sequential circuits proc 
int 
test conf pp 
october 
rudnick patel greenstein genetic algorithm framework test generation ieee trans 
computer aided design vol 
pp 
september 
rudnick patel putting squeeze test sequences proc 
int 
test conf pp 
november 
saab saab abraham cris test program sequential vlsi circuits proc 
int 
conf 
computer aided design pp 
november 
saab saab abraham iterative simulation genetics deterministic techniques complete atpg proc 
int 
conf 
computeraided design pp 
november 
skewed load transition test part calculus proc 
int 
test conf pp 
october 
schulz socrates highly efficient automatic test pattern generation system ieee trans 
computer aided design vol 
pp 
january 
schulz auth improved deterministic test pattern generation applications redundancy identification ieee trans 
computer aided design vol 
pp 
july 
schulz auth essential efficient self learning test pattern generation algorithm sequential circuits proc 
int 
test conf pp 
august 
silva sakallah dynamic search space pruning techniques path sensitization proc 
design automation conf pp 
june 
silva sakallah robust search algorithms test pattern generation proc 
fault tolerant computing symp pp 
june 
stephan brayton sangiovanni vincentelli combinational test generation satisfiability ieee trans 
computer aided design vol 
pp 
september 
specint 
standard performance evaluation 
open org 
transformed pseudo random patterns bist proc 
ieee vlsi test symp pp 
april 
synthesis mapping logic generating transformed pseudo random patterns bist proc 
int 
test conf pp 
october 
testing embedded cores partial isolation rings proc 
ieee vlsi test symp pp 
april 

tromp minimal test sets combinational circuits proc 
int 
test conf pp 
october 
venkataraman efficient bist scheme reseeding multiple polynomial linear feedback shift registers proc 
int 
conf 
computer aided design pp 
november 
fault modeling logic simulation cmos mos integrated circuits bell systems technical journal vol 
pp 
may june 
rosen iyengar transition fault simulation ieee design test computers pp 
april 
atpg structured designs proc 
int 
test conf pp 
august 
multiple distributions biased random test patterns proc 
int 
test conf pp 
october 
zhao rudnick patel static logic implication application redundancy identification proc 
ieee vlsi test symp april 
test requirements embedded core systems ieee proc 
int 
test conf pp 
october 
vita born turkey 
received bachelor science master science degrees computer engineering university istanbul turkey respectively 
started ph study department computer science university illinois urbana champaign 
supported nato science fellowship award turkish scientific technical research council august august 
rest ph study university illinois urbana champaign worked teaching research assistant department computer science research assistant center reliable high performance computing 
worked staff research assistant computational science methods group los alamos national laboratory summer 
summers worked visiting lecturer department computer science university illinois urbana champaign 
received memorial award department computer science 
research interests include computer aided design testing digital systems computer architecture parallel processing 
completing doctoral dissertation joining motorola labs senior staff engineer digital dna systems architecture group illinois 

