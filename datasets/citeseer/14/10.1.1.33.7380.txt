mmlite highly system architecture mmlite modular system architecture suitable wide variety hardware applications 
system provides selection object components dynamically assembled full application system 
components namespace supports new programming model components automatically loaded demand 
virtual memory manager optional loaded demand 
components easily replaced reimplemented 
third party independently replaced real time scheduler different implementation 
reduced development time led flexible understandable system 
mmlite efficient portable small memory footprint 
runs microprocessors including vliw processors 
processors embedded number multimedia directx accelerator boards 
progressive computerization society involves number diverse computing platforms general purpose computer embedded control systems including consumer devices intelligent sensors smart home controls 
communication oriented devices digital cell phones networking infrastructure 
programmable peripherals microcontrollers 
cases general purpose platform approach applicable prohibitively expensive 
microprocessor dsp vliw micro controller memory budget severely restricted mmu network connection sporadic real time essential 
current operating systems inflexible big lack real time support complex hardware requirements specialized development tools unavailable code reusability low 
mmlite system architecture suitable wide range applications 
strategy build system minimal flexible components 
fixed set operating system services hardware requirements provide menu defined components chosen compose complete system depending hardware capabilities security johannes helander alessandro forin microsoft research needs application requirements 
components selected compile time link time run time 
components transparently replaced mechanism call mutation 
easier change implementation component affecting rest system 
minimalism possible system severely restricted hardware budgets 
forces system understandable adaptable 
software components possible tied particular layer system reused 
example code implements system physical memory heap provide application heaps virtual memory 
system aggressively previous system 
includes virtual memory system ipc scheduler addition filesystems networking drivers security policies 
rest organized follows section describes system architecture 
sections describe implementation major components 
results section related section section 
architecture java provide objects fine granularity level successful application programmers 
unfortunately languages confine objects single address space 
object linking embedding ole corba omg similar systems extend objects address spaces machine boundaries 
ole seamlessly integrates independently developed components 
editing excel spreadsheet inside word document fact excel process operates objects inside word address space 
unfortunately ole works user mode applications 
mmlite takes objects approach extends object orientation address spaces protection levels 
component object model mmlite components contain code metadata classes objects 
component loaded address space instantiated 
instantiated component creates object instances communicate objects potentially components 
objects expose methods component object acm sigops european workshop september sintra portugal 
model com interfaces 
mmlite objects available components registering namespace 
namespaces similar filesystem directories limited just files 
threads execute code synchronize mutexes condition variables 
system components typically written fundamental bias particular language 
com object virtual method table methods derived base interface agreeing interface protocols release counting 
specific interfaces additional methods actual 
addition constructor usually provided 
object model enables late binding version compatibility checking transparency proxies cross language support reasonably lightweight efficient 
object method table pointer count 
call adds indirection fetching actual method pointer 
garbage collection done counting 
release called implementation finalize deallocate object 
counting limitations convenient system environment due simplicity 
interaction objects garbage collection models achieved proxies intercept methods update root sets 
mmlite component implementations rarely aware intended system layer 
code different address spaces contexts nested 
filesystem applied file provided filesystem provided disk driver 
heap applied memory physical memory memory allocated heap memory provided virtual memory manager 
loader loads modules address space 
communication namespaces object target method different machine different address space called directly proxy interposed delegation 
calling actual object client call local proxy object 
proxy marshals parameters message sends actual object located 
message received dispatched stub object 
stub parameters calls actual method 
return path stub similarly marshals return values sends message back proxy turn returns 
aside longer execute remote object call proxy looks exactly local call directly actual object 
implementation server transparent client location 
namespaces applications gain access objects provided components 
namespace filesystem directory tree hold kind objects just files 
namespaces implemented different components including filesystem exports directories sub namespaces files registered objects 
namespaces registered namespaces extending directory tree 
location transparency objects automatically namespaces distributed 
namespaces filtered access control providing different views different applications 
limit number namespaces 
component gain access namespace call 
minimal system applications share boot namespace 
application looks name namespace obtains object local direct case object local automatically created proxy object remote 
ipc system responsible creating proxies handling delegation remote objects counting 
namespace free create objects demand case filesystem 
namespace needs handle interface 
application obtain proper interface directly object method 
implemented demand loading namespace supports new programming model 
main entry point image constructor returns object 
application tries bind name exist namespace invokes loader looks instantiates component name 
loader invokes component entry point registers resulting object namespace returns application 
application releases component namespace unload component choose keep cached 
execution model components code static data stack number dynamic objects 
heap object allows dynamic memory allocations 
stack pointed stack pointer register allocated heap 
physical memory system initial size stack maximum size stack byte paid real memory 
embedded application stack size chosen carefully 
compilers generate stack checks function entry guard stack overflows 
virtual memory system stack backed real memory allocated demand 
stack consumes virtual address range allocated liberally 
real time application want pre allocate memory order avoid time fluctuations 
case existence virtual memory affect stack 
acm sigops european workshop september sintra portugal 
memory code static data allocated heap 
code placed memory position independent pc relative relocatable 
microsoft visual compiler instance creates compressed relocation table run time loader uses fix executable placed different place memory linked 
compilers embedded provide similar functionality specific image formats relocation schemes differ 
unfortunately compilers support 
code image reentrant possible execute multiple instances image address space 
code data simply loaded multiple times time relocated differently 
relocation information component virtually overlaps component executed address space 
case new address space required turn requires virtual memory 
mutation object consists interface instance pointer implementation state 
interface list methods 
instance pointers interfaces exposed objects state implementation 
worker threads execute implementation code accesses modifies state 
object instance created instance pointer interface implementation traditionally immutable state changed method calls 
mmlite allow run time changes ordinarily immutable part object object 
call mutation act atomically changing ordinarily constant part object method implementation 
thread performing mutation called mutator 
mutator translate state object representation expected old implementation expected new implementation 
coordinate worker threads mutators suitable synchronization mechanisms 
transition functions capture translations applied object state worker thread execution state 
order limit amount metadata execution transitions happen corresponding clean points old new implementations 
number mechanisms implemented mutation 
interposition done replacement object filter object points clone original object 
dynamic software upgrade replace incorrect implementation method corrected 
run time code generation stub implementation trigger 
mutation replace generic code specialized version exploits partial evaluation treating ordinarily non constant state immutable 
optimistic conditions longer true mutation allows reverting back generic code 
execution profiling indicate different implementation perform better trigger mutation 
object mobility realized turning objects proxies vice versa 
example mutation useful device drivers 
configuration minimal floppy disk drivers called bios rom functions 
loadable driver take mutate bios driver real driver transparently filesystem 
instance pointer table state object method interface acm sigops european workshop september sintra portugal 
implementation run time object representation 
synchronization mechanisms suitable implementing mutation divided groups mutual exclusion mutation happen workers executing methods object mutated 
implementation read write lock disabling preemption uniprocessor holding tank cowan counting 
mutual exclusion simple worker state associated object mutation allowed happen 
transactional roll back workers affected mutation 
mutators workers operate object aborted necessary 
swizzling modify state workers reflect mutation 
waiting workers exit object forcing third mechanisms just suspends 
mutator modifies state worker reflect change object 
nesting environment provided mmlite viewed virtual machine com programs 
programs may include virtual machines provide suitable environments languages different environments 
way mmlite provide arbitrary virtual machine environments nesting 
nested virtual machines employ type safe languages software fault trust insulation 
alternatively nested virtual machines implemented terms hardware means virtual memory system 
nested virtual machines loaded demand address space 
software solutions means insulation system hardware protection 
hardware protection software solutions win performance avoiding expensive domain crossings 
virtual machine running mmlite environment external objects available nested applications proxies security filtering 
similarly export nested objects outer world stubs 
selection system components components part deployed system depends applications interface requirements application memory requirements security requirements target hardware capabilities 
flexible loading modules important design goal system 
loading components deferred application 
device drivers run time services typically fall category 
loaded just prior running application virtual memory untrusted applications 
services terminate longer needed 
structure system change radically execution due external events 
drivers virtual memory hardware support 
application tries look namespace 
lookup operation fails driver absent returns null pointer valid initialization 
library null thread null scheduler mutex condition startup application timer icu minimal system configuration 
components loaded link time lt 
shows minimal system configuration watch 
shows larger system configuration cell phone 
applications run physical address space separate address space virtual machine 
ipc system uses network virtual memory mappings transports 
virtual memory existing operating systems mmlite support virtual memory integral part system 
system function executes binaries 
virtual memory manager component loaded dynamically demand 
loading unloading virtual memory system interfere applications running started physical memory space 
virtual memory system started new components lt loaded address space 
component code may shared different address spaces case shared libraries 
instance code loaded physical memory space visible applications regardless address space 
secret systems code security problem 
virtual memory required security reasons program trusted 
virtual memory system implements firewalls applications 
covering common programming errors null pointer memory leaks 
creating sparse address space 
leads better memory utilization fragmented heaps 
paging provides memory available working set adaptation mapped files 
safe flexible memory sharing copy write libraries shared memory windows 
running non relocatable executables described 
implementing garbage collection protection tricks 
java vm network drivers acm sigops european workshop september sintra portugal 
ipc thread mutex condition timer icu rt scheduler library heap namespace applications startup loader sample system configuration 
link time lt run time rt loadable components 
rt interprocess communication ipc system needed applications run separate address spaces 
applications talk system services 
ipc system allows communication address spaces machine 
communication applications different machines distributed environment 
graceful termination cleanup applications address space 
cleanup involves releasing memory held application 
involves closing application objects 
level indirection needed bookkeeping providing cutoff point 
level indirection ipc system provides 
lt ipc system implements com model 
possible replace communication model applications expect different model 
components implementing various communication paradigms loaded system needed 
system components section describes base menu mmlite system components 
components described section 
implemented tested 
sizes see table section 
heap implements physical memory management allowing dynamic memory allocations specifiable alignments 
constructor allows creating nested heaps heaps virtual memory 
different implementations provided 
loader load additional components running system 
embedded systems provide loader eliminated link time system 
multiple image formats supported 
loader loads images address space flag virtual memory manager creates new address space loads image 
particular distinction executables dlls shared libraries 
executable simply dll exports entry points main 
support library machine initialization shared support library includes common base utilities memcpy int system components available components 
basic machine initialization code startup system reset 
machine dependent code mmlite goes 
timer interrupt drivers driver timer chip scheduler keep track time thread pre emption 
driver interrupt control unit icu dispatches interrupts keeps registry interrupt routines installed removed components 
system particular notion device driver se 
enforce strict limits interrupt routine wakeup thread 
scheduler policy module determines thread run time 
low level management blocking switching threads handled thread synchronization component 
timer interrupt thread synchronization modules call scheduler possibly passing callback functions arguments 
schedulers implemented null scheduler simple round robin scheduler constraint real time scheduler independently implemented real time scheduler 
null scheduler systems thread 
constraint scheduling consumer real time applications described jones 
threads synchronization basic thread support synchronization primitives 
thread created address space component started 
virtual memory address space physical address space 
threads block mutexes conditions 
inform scheduler time constraints calls fail scheduler constraint scheduler 
constraint scheduler performs priority inheritance threads block mutexes 
namespaces simple boot namespace applications register objects 
namespace cooperates loader demand loading caching components 
namespace displaying status running threads performance parameters execution times system development 
filesystems loadable namespaces 
filesystem load additional components run time 
implemented read memory images arbitrary files system merged image reading writing disks 
simple network filesystem client built top sockets 
network complete bsd lite network protocol code minor adaptations 
interface com interface provides sockets 
protocols operate network drivers interface 
startup program started system initialized 
simple command interpreter configures system launches applications application 
small win compatibility library making easier windowsnt code drivers applications 
atomic queues dma manager useful device driver writers 
virtual memory implementation viewed driver mmu hardware 
creates virtual memory mappings physical memory mmu hardware 
loading starting virtual memory manager executable interfere applications running 
unloading done objects provided manager released 
new started needed 
virtual memory space looks physical memory space larger doesn contiguous paged protected replicated recursively mapped objects 
virtual memory manager exports number control interfaces create new address spaces vspace map address spaces files address spaces vmap map address spaces threads control state protections vspace 
realistically mmu driver need exclusive control mmu hardware 
objects acm sigops european workshop september sintra portugal 
implementing virtual memory interfaces interposed application mmu driver 
way logical virtual memory systems arbitrarily composed instance stacked exokernel engler 
rest system unaware virtual memory component exceptions 
thread hold pointer page faults resolved correct context context switch path check change 
context switch path detects address space change calls method synchronize mmu hardware change 
virtual memory server registers trap handler icu driver 
heap may choose modify behavior running virtual memory 
loader create new address spaces virtual memory system 
ipc system may utilize virtual memory mappings data transfers 
applications equator technologies ported mmlite proprietary vliw media processor run multiple simultaneous multimedia applications including mpeg decode ac graphics telecommunications 
mmlite system microsoft prototype graphics multimedia card 
involved supporting direct software midi synthesizer implementing dls level specification 
interactive game doom run directly board number demo programs regression tests 
look applications detail 
directx interface windows platform lets applications efficiently create graphics unnecessary operating system overhead 
direct equivalent interface graphics 
combination direct memory access driver support job 
interface audio collectively known directx 
prototype implementation utilizes multimedia card bulk 
card contains processor local memory controlled mmlite 
card mmlite provides framework basic services graphics audio engines 
components handle communication pci bus nt side mmd mmlite side 
send packets 
user application workstation interfaces directx library logically method calls objects reside card 
mmd act proxies stubs perform necessary argument marshaling unmarshaling 
graphics component rendering writes results frame buffer 
audio component uses board converters 
user application directx library nt kernel driver pc workstation pci bus acm sigops european workshop september sintra portugal 
audio graphics component mmd driver card mmlite directx communication 
mmd uses demand loading namespace exports functionality side 
filesystem delegates file requests back fetches filesystem workstation 
constraints schedule computations device driver level 
feedback graphics component lets adapt rendering precision time availability 
setup communication latency important performance application directx 
mhz pc measured excess rpc second user mode windowsnt process mmlite component time predominantly spent nt 
midi data synth audio data mixer midi synthesizer components 
audio data audio driver midi synthesizer depicts structure midi synthesizer components 
synth thread runs periodically new midi data arrives 
produces output buffer khz bit stereo audio samples 
mixer thread runs periodically expects find new buffer available input channels 
input buffer buffer silence data 
buffers contain data number formats mixer adapts frequencies stereo mono number bits sample 
result mixing audio driver 
thread awaits signals interrupt routines switches buffers 
completed buffers returned mixer 
audio components time constraints interference run applications 
cpu load running components mmlite mhz processor synth component remaining audio components 
results system currently runs arm philips equator technologies vliw processors 
software development kit sdk contains mmlite kit shipped july licensees 
heap boot ns heap ns pe loader library timer startup icu network null sched win event rr sched rt sched mmd thread vm synchro doom table components binary sizes bytes 
size minimal system kb excluding boot stack 
size base system lt box kb kb arm 
table lists sizes components section 
development experiences experience microsoft reduces development time system flexible understandable 
components functional porting development incremental 
system little assumptions hardware 
philips port functional week days spent learning development tools 
vliw architecture microprocessor quite new different ones mmlite supported time 
equator technologies ported system new microprocessor platform 
told experience favorable system reasonably bug free 
demand loading namespace programming model mmd pair 
separation machine dependencies successful 
modified existing loader modules image format implemented new real time scheduling component 
related ford shows base set system components composed different ways build operating system kernel 
granularity fairly coarse techniques limited static linking 
components interest os researchers vm ipc scheduling replaced removed statically dynamically 
decomposition limited os component meant system approach 
bears similarity mmlite go far 
provides convenient components bootstrap loader filesystems concerned reusing existing device drivers unix code 
mmlite hand core services extends paradigm applications 
chorus rozier system know configured page vm system 
mmlite run vm dynamically load unload course look ms dos twisted way 
cowan employs limited form object mutation specialization 
generalized mutation usable number new contexts 
synchronization mechanism cowan holding tank keeps workers entering object mutated 
holding tank viewed asymmetric read write lock solve problem workers entered object 
solved problem including cases worker blocks 
jones draves shows com model implemented presence vm argues unified programming model independent privilege issue user versus kernel distinction 
show principles beneficial scaling system cope resource poor domains 
corba omg forces calls go object request broker penalizing local case 
real time support corba research stage yang 
location independence studied context filesystems network protocols maeda number existing embedded systems psos isi 
typical embedded system loader components chosen static link time load image built 
services extremely limited just scheduling component 
number priority threads specified statically 
spin bershad addresses issue expensive address space crossings letting user code compiled trusted compiler run inside kernel 
mmlite enables acm sigops european workshop september sintra portugal 
equal functionality loadable nested virtual machines 
modularity important paradigm software design 
breaking complex system pieces complexity manageable 
address spaces provide security installing firewalls applications 
issues orthogonal distinction lost systems research concentrating called microkernels black cheriton engler young 
liedtke argues microkernels failed exclusively performance grounds poor performance cause inflexibility 
argument opposite inflexibility inherent design leads unavoidable inefficiencies mitigated implementations eliminated 
liedtke granularity address space level single object level com model 
prove construction modular system require vm contradicting axioms theoretical model 
building operating system emerging computing platforms components pays terms flexibility minimalism adaptability 
naturally leads software design rapid implementation portability 
com way adding transparency location privilege level overhead 
mmlite system efficient portable small memory footprint suitable embedded 
successfully multimedia devices 
andy jerry van rest team invaluable help 
bershad brian bershad savage pardyak sirer fiuczynski becker eggers chambers 
extensibility safety performance spin operating system 
th acm symposium operating system principles pages copper mountain resort colorado december 
black david black david golub daniel richard rashid richard draves randall dean alessandro forin joseph barrera tokuda gerald malan david 
microkernel operating system architecture mach 
st usenix workshop micro kernels kernel architectures pages seattle april 

inside ole second ed 
microsoft press redmond wa 
cheriton david cheriton kenneth duda 
caching model operating system kernel functionality 
st symposium operating systems design implementation seattle 
omg corba iiop specification 
available www omg org corba htm 
cowan crispin cowan charles calton pu jonathan walpole 
fast concurrent dynamic linking adaptive operating system 
proceedings international conference configurable distributed systems annapolis md 
draves richard draves scott 
unifying user kernel environments 
microsoft research technical report msr tr pages march 
available ftp ftp research microsoft com pub tr tr ps 
engler engler kaashoek toole jr exokernel operating system architecture application specific resource management 
th acm symposium operating system principles pages copper mountain resort colorado december 
ford bryan ford back greg benson jay lepreau albert lin olin shivers 
flux oskit substrate kernel language research 
proceedings th acm symposium operating systems principles pages 
acm sigops saint malo france october 

architectural overview qnx 
st usenix workshop micro kernels kernel architectures pages seattle april 
isi integrated systems system concepts 
part 
col may isi sunnyvale ca 
jones michael jones joseph barrera iii richard draves alessandro forin paul leach gilad 
overview real time architecture 
proceedings th acm sigops european workshop pages september 

cpu reservations time constraints efficient predictable scheduling independent activities 
proceedings th acm symposium operating systems principles pages 
acm sigops saint malo france october 
daniel jonathan chew mark stevenson paulo paul paul roy 
generalized emulation services mach overview experiences current status 
proceedings usenix mach symposium 
liedtke jochen liedtke 
th acm symposium operating system principles pages copper mountain resort colorado december 
maeda chris maeda brian bershad 
protocol service decomposition high performance networking 
th acm symposium operating system principles pages 
rozier rozier armand hermann kaiser leonard 
chorus distributed operating system 
computing systems pages vol 

sdk mailto microsoft com 
jay jim kajiya 
commodity real time graphics pc 
proceedings siggraph august 
yang yang sun 
corba hard real time applications critical issues 
operating systems review pages vol 

young michael wayne young 
exporting user interface memory management communication oriented operating system 
ph thesis cmu cs carnegie mellon university november 
acm sigops european workshop september sintra portugal 
