may lids auction algorithms network flow problems tutorial dimitri bertsekas surveys new comprehensive class algorithms solving classical linear network flow problem various special cases shortest path max flow assignment transportation problems 
prototype method algorithms derived auction algorithm assignment problem 
intuitive method operates real auction persons compete objects raising prices competitive bidding prices viewed dual variables 
conceptually auction algorithms represent significant departure cost improvement idea underlies primal simplex dual ascent methods iteration may deteriorate primal dual cost 
auction algorithms perform important types problems theory practice suited parallel computation 
research supported nsf 
ddm ccr aro daal 
published journal computational optimization applications 
laboratory information decision systems cambridge mass 
contents 


assignment naive auction 
naive auction algorithm 

complementary slackness auction algorithm 
auction algorithm 
scaling 
dealing infeasibility 
profits reverse auction 
combined forward reverse auction 

auction algorithms shortest path problems 
auction shortest path algorithm 
reverse algorithm 
auction algorithm graph reduction 
shortest path problems 
node disjoint shortest path problems 

extension transportation problems 
auction algorithm similar objects 
auction algorithm similar persons 

generic auction algorithm minimum cost flow problems 
generic algorithm 

relaxation method 

application relaxation method max flow problems 

extension asymmetric assignment problems 
reverse auction asymmetric assignment problems 
forward reverse auction types inequality constrained problems 

practical computational aspects auction algorithms 

assignment problems 
adaptive scaling 
problem integer overflow 
third best implementation 
parallel asynchronous implementation 

shortest path problems 
parallel implementation 

transportation problems 

minimum cost flow problems 

max flow problems 



appendix cs primal optimality dual optimality 
assignment problems 
minimum cost flow problems 
appendix finite termination auction algorithm 


classical algorithms solving linear network flow problems primal cost improvement methods including simplex methods iteratively improve primal cost moving flow simple cycles dual ascent methods iteratively improve dual cost changing prices subset nodes equal amounts 
auction algorithms subject tutorial fundamentally di erent depart cost improvement idea iteration may deteriorate primal dual cost find optimal primal solution 
origin lies erentiable optimization nonmonotonic subgradient algorithms common subgradient method bertsekas mitter bem particular progress method depends gradually reducing parameter acceptable tolerance level 
auction algorithms highly intuitive easy understand explained terms economic competition concepts couched everyday experience 
auction algorithms originated algorithm proposed author classical assignment problem ber 
algorithm developed ber ber bee 
motivation solve problem parallelism natural way 
turned resulting method fast serial environment 
subsequent extended auction algorithm linear network flow problems 
particular extension minimum cost problem relaxation method author ber ber 
auction algorithm transportation problems author collaboration bec 
auction algorithm shortest paths author ber 
max flow algorithm developed goldberg gol entirely di erent point view fundamentally involves auction ideas viewed natural extension auction algorithm max flow problem 
algorithms just mentioned derived original auction algorithm assignment problem 
derivation known transformations general linear minimum cost flow problem various special cases shortest path max flow equivalent assignment problems 
auction algorithm applied corresponding equivalent assignment problem computations streamlined obtains auction algorithm original problem 
purpose provide tutorial auction algorithms 
textbook presentations refer reader bet ber 
initially focus basic algorithm assignment problem discuss various extensions problems 
sections develop auction algorithm symmetric assignment problem 
particular discuss number issues common types auction algorithms including scaling dealing infeasibility 
discuss alternative form auction algorithm called reverse auction regular auction persons bid objects raising prices reverse auction objects compete persons essentially ering discounts 
section develop auction algorithms shortest path problems 
section discuss extension auction algorithm transportation problems section give generic auction algorithm minimum cost network flow problem 

assignment naive auction section develop relaxation method minimum cost flow problem special case generic algorithm 
relaxation method specialized max flow problem section yielding algorithms similar goldberg tarjan gol got 
section discuss specialized auction algorithms inequality constrained problems asymmetric assignment problem 
section discuss computational aspects auction algorithms including issues parallel asynchronous implementation 

assignment naive auction classical symmetric assignment problem persons objects match basis 
benefit ij matching person object want assign persons objects maximize total benefit 
set pairs matched 
person denote set objects matched object denote set persons matched 
assignment mean set person object pairs person object involved pair number pairs person assigned distinct object say feasible said infeasible 
feasible assignment exists problem said feasible said infeasible 
seek feasible assignment set person object pairs 
jn objects 
jn distinct optimal sense maximizes total benefit ij symmetric assignment problem distinguished asymmetric version number objects larger number persons requirement assign person requirement objects 
auction algorithms asymmetric related problems discussed section 
assignment problem important practical contexts great theoretical importance 
despite simplicity embodies fundamental linear programming structure 
important type linear programming problem minimum cost network flow problem reduced assignment problem means simple reformulation see bet ber pas section 
method solving assignment problem generalized solve minimum cost flow problem 
reason assignment problem served convenient starting point important algorithmic ideas linear programming 
example primal dual method min motivated developed kuhn hungarian method kuh specialized method assignment problem 

assignment naive auction develop intuitive understanding auction algorithm helpful introduce economic equilibrium problem turns equivalent assignment problem 
consider possibility matching objects persons market mechanism viewing person economic agent acting best interest 
suppose object price person receives object pay price net value object person ij person logically want assigned object maximal value ij max ij 
economic system equilibrium sense person incentive act unilaterally seeking object 
equilibrium assignments prices naturally great interest economists fundamental relation assignment problem turns equilibrium assignment ers maximum total benefit solves assignment problem corresponding set prices solves associated dual problem 
consequence duality theorem linear programming see dan pas lue 
terminology linear programming relation known complementary slackness cs short 
simple principles proof relation equilibria optimal assignments dual optimization developed appendix 
naive auction algorithm consider natural process finding equilibrium assignment price vector 
call process naive auction algorithm serious flaw seen shortly 
flaw help motivate sophisticated correct algorithm 
naive auction algorithm proceeds iterations generates sequence price vectors assignments 
iteration cs condition ij max ij satisfied pairs assignment 
persons assigned algorithm terminates 
nonempty subset persons unassigned selected computations performed 
typical iteration naive auction algorithm nonempty subset persons unassigned 
bidding phase person finds object ers maximal value arg max ij computes bidding increment 
complementary slackness auction algorithm best object value max ij second best object value max ij 
object define computational purposes number smaller assignment phase object selected best object nonempty subset persons determines highest bidder arg max raises prices highest bidding increment max gets assigned highest bidder person assigned iteration unassigned 
algorithm continues sequence iterations persons assigned object 
note negative compare eqs 
object prices tend increase 
fact bidder largest bidding increment cs maintained assignment preferred object 
just real auction bidding increments price increases spur competition making bidder preferred object attractive potential bidders 
note freedom choosing subset persons bid iteration 
possibility consist single unassigned person 
version known gauss seidel version similarity gauss seidel methods solving systems nonlinear equations usually works best serial computing environment 
version consists unassigned persons best suited parallel computation known jacobi version similarity jacobi methods solving systems nonlinear equations 

complementary slackness auction algorithm unfortunately naive auction algorithm excellent initialization procedure methods price adjustment primal dual relaxation 
di culty bidding increment zero object ers maximum value bidder result situation may created persons contest smaller number equally desirable objects raising prices creating cycle see fig 

break cycles introduce perturbation mechanism motivated real auctions bid object raise object price minimum positive increment bidders occasion take risks win preferred objects 
particular fix positive scalar say assignment price vector satisfy complementary slackness cs short ij max ij initial price ij ij persons objects initial price initial price initially assigned object initially unassigned initially assigned object 
complementary slackness auction algorithm start object assigned bidder preferred bidding iteration prices pairs object increment illustration naive auction algorithm may terminate person object problem 
objects er benefit persons object ers benefit persons 
algorithm cycles persons alternately bid object changing price prefer equally object object 
assigned pairs 
words satisfy cs assigned persons assigned objects best 
auction algorithm reformulate previous auction process bidding increment equal 
resulting method auction algorithm naive auction algorithm bidding increment eq 

choice cs condition satisfied 
particular increment auction algorithm maximum amount property 
smaller increments long largest possible increment accelerates algorithm 
consistent experience real auctions tend terminate faster bidding aggressive 
shown reformulated auction process terminates finite number iterations necessarily feasible assignment set prices satisfy cs 
see case fully dense problem consists person object pairs note object receives bid 
complementary slackness auction algorithm iterations price exceed initial price 
su ciently large object expensive judged inferior object received bid far 
follows object receive bid limited number iterations object received bid 
hand objects receive bid auction terminates 
auction algorithm terminate fact preceding argument shows case zero initial prices total number iterations object receives bid max ij iteration involves bid single person total number iterations times preceding quantity bid requires operations running time algorithm max ij proof generalized case sparse problem set person object pairs assigned limited long problem feasible see appendix 
shows auction algorithm bidding increment cf 
eq 
overcomes cycling problem example fig 

auction algorithm terminates assignment satisfying cs assignment optimal 
answer depends strongly size 
real auction prudent bidder place excessively high bid fear win object unnecessarily high price 
consistent intuition show small final assignment optimal 
particular proposition proved appendix shows total cost final assignment optimal idea feasible assignment set prices satisfy cs satisfy cs primal dual optimal respectively slightly perturbed problem costs ij costs assigned pairs modified amount 
proposition feasible assignment satisfying complementary slackness price vector optimal 
suppose costs ij integer typical practical case ij rational numbers scaled integer multiplication suitable common number 
total benefit assignment integer complete assignment optimal optimal 
follows benefits ij integer assignment obtained termination auction algorithm optimal 
state result proposition proof appendix 
proposition consider feasible assignment problem integer benefits ij auction algorithm terminates finite number iterations optimal assignment 
shows sequence generated object prices example figs 
relation contours dual cost function assignment problem appendix 
initial price ij ij persons objects initial price initial price initially assigned object initially unassigned initially assigned object 
complementary slackness auction algorithm start object assigned bidder preferred bidding iteration prices pairs object increment illustration auction algorithm overcomes cycling problem example fig 
making bidding increment equal 
table shows possible sequence bids assignments generated auction algorithm starting prices equal 
iteration person assigned object bids object increasing price iteration subsequent iteration 
iteration prices rise object receives bid auction terminates 
seen bid dual cost approximately minimized respect price object receiving bid 
observation established generality see ber ber 
successive minimization cost function single coordinates central feature coordinate descent relaxation methods popular unconstrained minimization smooth functions solving systems smooth equations 
auction algorithm interpreted approximate coordinate descent method 
scaling amount needed auction algorithm terminate depend strongly value maximum absolute object benefit max ij 
contours dual function 
complementary slackness auction algorithm sequence prices generated auction algorithm example figs 

shows equal dual cost surfaces space fixed 
basically types problems number iterations termination tends proportional argued earlier fully dense problems 
seen example fig 
number iterations termination roughly starting zero initial prices 
small method susceptible price wars protracted sequences small price rises resulting groups persons competing smaller number roughly equally desirable objects 
note dependence initial prices prices near optimal expect number iterations solve problem relatively small 
seen example fig 
initial prices satisfy number iterations termination quite small 
preceding observations suggest idea scaling consists applying algorithm times starting large value successively reducing ultimate value critical value example benefits ij integer 
typical reduction factors scaling phase order 
application algorithm provides initial prices application 
scaling suggested original proposal auction algorithm ber extensive experimentation established ectiveness types assignment problems 
particular scaling typically beneficial sparse problems 
cost structure problem important determining scaling needed 
integer data shown worst case running time auction algorithm scaling appropriate data structures na log nc see bee bet 
experiments 
complementary slackness auction algorithm running time algorithm randomly generated problems grow proportionally log log log nc 
supported approximate analysis sch 
practical computational aspects auction algorithm discussed section 
dealing infeasibility termination occur feasible assignment problem infeasible auction algorithm keep iterating user wondering problem infeasible just hard solve 
problems existence feasible assignment known priori supplement auction algorithm mechanism detect infeasibility 
mechanisms discuss 
basic result symmetric asymmetric assignment problems infeasible assignment mutually exclusive possibilities maximal cardinality assignment having assigned persons 
exists unassigned person unassigned object augmenting path respect starts ends sequence form 
jm im assigned 
result proved number ways 
example introducing assignment problem graph supersource node connected person nodes node connected object nodes view problem finding assignment maximal cardinality problem finding maximum flow result follows max flow min cut theorem related analysis ber chapter props 

corollary preceding result feasible assignment problem infeasible assignment person unassigned exists augmenting path respect starts 
prove modify assigning person unassigned fictitious object apply preceding result 
criterion detect infeasibility maximum values max ij 
turns course auction algorithm values bounded bound problem feasible values eventually reduced bound problem infeasible 
particular suppose auction algorithm applied initial object prices 
shown person unassigned respect current assignment augmenting path respect starts max 
complementary slackness auction algorithm max ij 
proof obtained adding cs condition augmenting path 
problem feasible discussed earlier exists augmenting path starting unassigned person times lower bound hold unassigned persons auction algorithm 
hand problem infeasible persons submitting bids infinitely corresponding values decreasing 
apply auction algorithm keep track values decrease 
gets lower bound know problem infeasible 
unfortunately may take iterations reach lower bound 
alternative method detect infeasibility convert problem feasible problem adding set artificial pairs original set benefits pairs small participates optimal assignment problem infeasible 
particular shown original problem feasible pair participate optimal assignment provided ij max ij 
prove contradiction assume adding set set artificial pairs create optimal assignment contains nonempty subset artificial pairs 
assignment consisting exclusively pairs original set ij ij ij ij ij ij contradicts eq 

note ij preceding argument modified show su cient ij artificial pairs 
hand addition artificial pairs benefit eq 
expands cost range problem factor 
context scaling necessitates larger starting value correspondingly large number scaling phases 
problem feasible extra scaling phases wasted 
problems normally expected feasible may better introduce artificial pairs benefits order gradually scale downward benefits threshold artificial pairs persist assignments obtained auction algorithm 
procedure scaling downward benefits artificial pairs embedded number ways scaling procedure 
method detect infeasibility property problem infeasible auction algorithm find assignment maximal cardinality finite number iterations provided unassigned persons selected bidding order cyclic ensures person get chance submit bid fixed number iterations 
proof lower bound property assignments maximal cardinality stated earlier 
particular current assignment reached maximal cardinality exist unassigned person path starts augmenting respect 
complementary slackness auction algorithm current assignment 
adding cs condition path see satisfy lower bound contradiction tend submit bid infinitely 
suppose periodically interrupt auction algorithm check exists augmenting path unassigned person unassigned object simple search breadth type see ber 
cardinality current assignment maximal check establish problem infeasible 
modified auction algorithm guaranteed find feasible assignment set prices satisfying cs establish problem infeasible simultaneously obtain assignment maximal cardinality 
case shown original symmetric problem separate saturated cut components corresponding asymmetric assignment problems 
may auction algorithms asymmetric problems see section optimize assignment component obtain optimal assignment class assignments maximal cardinality 
profits reverse auction assignment problem symmetric possible exchange roles persons objects 
leads idea reverse auction objects compete persons essentially ering discounts lowering prices 
roughly price vector view net value best object person max ij profit person objects lower prices tend increase profits persons 
profits play persons role analogous role prices play objects 
describe reverse auction di erent ways unassigned objects lower prices possible attract person violating cs unassigned objects select best person raise profit possible violating cs 
second description analytically convenient description forward reverse auctions seen mathematically equivalent 
introduce profit variable person consider cs condition assignment profit vector ij max kj set persons assigned object assumed nonempty 
relation profit variable expression max ij cf 
eq 
apparent discuss somewhat di erent cs condition involves prices profits see eqs 

note symmetry cs condition profits corresponding prices cf 
eq 

reverse auction algorithm maintains iteration assignment profit vector satisfying cs condition 
terminates assignment feasible 

complementary slackness auction algorithm typical iteration reverse auction nonempty subset objects unassigned 
bidding phase object find best person arg max ij corresponding value max ij find max ij 
person define computational purposes number smaller assignment phase person selected best person nonempty subset objects determines highest bidder arg max increases highest bidding increment max gets assigned highest bidder object assigned iteration unassigned 
note reverse auction identical forward auction roles persons objects profits prices interchanged 
corresponding forward auction results cf 
props 
proposition feasible assignment exists reverse auction algorithm terminates finite number iterations 
feasible assignment obtained termination optimal optimal problem data integer 
combined forward reverse auction reasons interested reverse auction construct algorithms switch forward reverse auction back 
algorithms simultaneously maintain price vector satisfying cs condition profit vector satisfying cs condition 
introduce cs condition pair see implies 
maintaining condition essential switching gracefully forward reverse auction 
say assignment pair satisfy cs ij ij 
proposition 
proposition suppose assignment profit price pair satisfy cs 

complementary slackness auction algorithm satisfy cs condition ij max kj 
satisfy cs condition ij max ik 
feasible optimal assignment 
proof view eq 
ij eq 
implies ij kj 
shows eq 

proof part roles interchanged 
part cs condition satisfied prop 
optimal 
introduce combined forward reverse algorithm 
algorithm maintains assignment profit price pair satisfying cs conditions 
terminates assignment feasible 
common way initialize algorithm cs conditions satisfied take empty choose arbitrarily select function relation max ik person combined forward reverse auction algorithm step run forward auction execute iterations forward auction algorithm subject termination condition iteration increasing prices objects received bid set ij person object pair entered assignment iteration 
go step 
step run reverse auction execute iterations reverse auction algorithm subject termination condition iteration increasing profits persons received bid set person object pair entered assignment iteration 
go step 
note additional overhead combined algorithm forward reverse algorithm minimal just update form required iteration object person received bid iteration 
important property updates eqs 
maintain cs conditions pair prop 
maintain required cs conditions respectively 
stated proposition proved see ber 

auction algorithms shortest path problems proposition assignment profit price pair available start iteration forward reverse auction algorithm satisfy cs conditions true assignment profit price pair obtained iteration provided eq 
update case forward auction eq 
update case forward auction 
note forward auction object prices increase profits decrease exactly opposite happens reverse auction 
reason termination proof forward auction see appendix apply combined method 
possible construct examples feasible problems combined method terminates switch forward reverse auctions done arbitrarily 
easy guarantee combined algorithm terminates finitely feasible problem su cient ensure irreversible progress switching forward reverse auction 
easily implementable possibility refrain switching person object pair added assignment 
way switch times forward reverse steps algorithm 
feasible problem forward reverse auction guaranteed finite termination final step terminate feasible assignment satisfying cs 
combined forward reverse auction algorithm typically works substantially dramatically faster forward version shown experimentally original extensive computational study cas 
ected price war phenomenon motivated scaling 
price wars occur combined algorithm arise complex problem structures forward algorithm 
reason combined forward reverse auction algorithm depends scaling performance forward counterpart 
consequence starting bypassing scaling best choice 
consequence larger reduction factor typically price war ects scaled forward reverse auction scaled forward auction 
result fewer scaling phases typically needed forward reverse auction deal ectively price wars 

auction algorithms shortest path problems turn attention types network flow problems 
approach constructing auction algorithms problems convert assignment problems suitably apply auction algorithm streamline computations 
start classical shortest path problem 
suppose graph node set arc set length ij arc 
section path mean sequence nodes 
arc 

addition nodes 
distinct sequence 
called simple path 
length path defined sum arc lengths 
assuming cycles positive length want find path minimum length paths start origin node destination node 

auction algorithms shortest path problems shortest path problem origin destination corresponding assignment problem 
arc lengths assignment costs shown arcs 
shortest path associated optimal augmenting path starts ends 
generally node introduce object node node introduce person node arc shortest path problem introduce arc cost ij assignment problem 
introduce zero cost arc assignment assigns object person leaves person object unassigned paths associated augmenting paths start shortest path corresponds shortest augmenting path unassigned person unassigned object shown augmentation shortest augmenting path gives optimal assignment 
known transformation converts problem particular type assignment problem shown fig 

apply auction algorithm solve equivalent problem turns structure problem naive auction algorithm works 
assuming arc lengths nonnegative start naive auction algorithm zero price vector assignment assigns person object pair satisfies cs arc lengths nonnegative assigned arcs zero cost feasible leaves person object unassigned 
seen induction tracing steps naive auction algorithm assignment generated consists possibly empty sequence form 
additional arcs 
sequence corresponds path 

long unique unassigned person naive auction algorithm person corresponding terminal node path 
feasible assignment results case naive auction algorithm terminates 
unassigned person submits bid possibilities best object case unassigned path 
corresponding new assignment obtained previous path 
contraction node 

auction algorithms shortest path problems best object case path 
corresponding new assignment obtained previous path 
extension node 
describe naive auction algorithm directly terms original shortest path problem properly translating preceding operations node contraction extension path prices associated price changes terminal node path maintaining cs condition 
auction shortest path algorithm auction algorithm shortest paths maintains times simple path 

node belong path 
arc extending means replacing path 
called extension consist just origin node contracting means replacing path 

algorithm maintains price vector satisfying property ij ij pairs successive nodes referred complementary slackness cs short 
condition related cs condition equivalent assignment problem cs conditions formulation shortest path problem minimum cost flow problem see ber section 
shown pair satisfies cs conditions portion node node shortest path corresponding shortest distance 
see note eq 
length portion path connecting length equal add eq 
arcs path 
assume initial pair satisfying cs available 
restrictive assumption arc lengths nonnegative default pair algorithm proceeds iterations transforming pair satisfying cs pair satisfying cs 
iteration path extended new node contracted deleting terminal node 
case price terminal node increased strictly 
degenerate case occurs path consists just origin node case path extended left unchanged price strictly increased 
iteration follows 
typical iteration auction shortest path algorithm terminal node min ij go step go step 

auction algorithms shortest path problems step contract path set min ij contract go iteration 
step extend path extend node arg min ij destination desired shortest path 
go iteration 
note extension step simple path adding create cycle arc cycle ij adding condition cycle see cycle zero length possible assumptions 
interesting interpretation cs conditions terms mechanical model min 
think node ball arc connect string length ij 
requires ij ji assume sake interpretation 
resulting balls strings model arbitrary position dimensional space vertical coordinate node cs condition ij clearly holds arcs illustrated fig 

model picked left hang origin node gravity strings tight perfectly vertical tight strings ij tight chain strings corresponds shortest path chain illustrated fig 

particular length tight chain connecting origin node node equal shortest distance 
result essentially known min path max tension theorem see roc ber 
auction shortest path algorithm interpreted terms balls strings model viewed process nodes raised stages illustrated fig 

initially nodes resting flat surface 
stage raise node tight chain starts origin level string tight 
single origin multiple destinations algorithm applied virtually change 
simply algorithm destinations terminal node path 
note algorithm similarly applied problem multiple origins single destination reversing roles origins destinations direction arc reverse algorithm number ways speed basic algorithm described detail ber ber bps see section 
significant relates sided version algorithm maintains addition path path ends destination 
understand version note shortest path problems exchange role origins destinations reversing direction arcs 
possible version algorithm maintains path ends destination changes shortest path problem arc lengths shown arcs 
node origin 
node destination 

auction algorithms shortest path problems illustration cs conditions shortest path problem 
node ball arc nodes connected string length ij vertical coordinates nodes satisfy ij shown problem 
model picked left hang origin node gives shortest distance node shown 
iteration means contraction extension 
algorithm called reverse algorithm mathematically equivalent earlier forward algorithm parallels reverse auction algorithm assignment problem discussed previous section 
initially reverse algorithm path destination price vector satisfying cs conditions example arc lengths nonnegative 
typical iteration reverse algorithm starting node max ij go step go step 
step contract path set max ij contract delete starting node 
go iteration 
step extend path extend node jx jx starting node preceding jx arg max ij jx origin desired shortest path 
go iteration 
shortest path problem arc lengths shown arcs 
node origin 
node destination 
initial position st stage nd stage rd stage th stage th stage 
auction algorithms shortest path problems illustration auction shortest path algorithm terms balls strings model problem shown 
model initially rests flat surface various balls raised stages 
stage raise single ball marked gray lower level origin reached sequence tight strings tight string connecting ball lower level ball tight chain hanging 
tight string connecting ball lower level 
raise level strings connecting ball lower level tight 
stage corresponds contraction 
ball raised corresponds terminal node path 
reverse algorithm helpful combined forward algorithm 
combined algorithm initially price vector paths satisfying cs starts origin ends destination 
paths extended contracted rules forward reverse algorithms respectively combined algorithm terminates common node 
satisfy cs algorithm meet say node composite path consisting portion followed portion shortest 
combined forward reverse auction shortest path algorithm 
auction algorithms shortest path problems step run forward algorithm execute iterations forward algorithm subject termination condition leads increase origin price go step 
step run reverse algorithm execute iterations reverse algorithm subject termination condition leads decrease destination price go step 
combined forward reverse algorithm interpreted terms balls strings model fig 

nodes resting initially flat surface 
forward part algorithm raise nodes stages illustrated fig 

reverse part algorithm lower nodes stages stage lower top node tight chain ends destination level string tight 
note case multiple destinations handled separate reverse path destination 
alternates forward step reverse step preceding algorithm cyclically di erent destinations di erent reverse steps 
experiments randomly generated problems serial machine ber combined forward reverse auction shortest path algorithm outperforms substantially closest competitors problems destinations single origin computation time reduced order magnitude 
case destinations algorithm apparently runs slower state art label setting label correcting methods typical slowdown factors order 
hand case multiple destinations algorithm better suited parallel computation shortest path algorithms 
variation algorithm substantially improved performance problems destinations 
variation described 
auction algorithm graph reduction despite excellent practical performance problems destinations auction algorithm pseudopolynomial complexity example see ber ber 
weakly polynomial versions algorithm developed ber idea scaling arc lengths versions prove ective practice 
strongly polynomial versions algorithm obtained pallottino pas adding extension contraction operations reduction operation 
time node terminal node path time incoming arcs path deleted improve distance node 
auction algorithm obtained shown running time number arcs 
idea outgoing arcs node order increasing length running time reduced mn number nodes 
additional advantage graph reduction allows relaxation positivity assumption cycle lengths nonnegativity 
reason requiring positive cycle lengths ensure cycle formed process path extension 
hand graph reduction node visited path unique incoming arc node incoming arc 
little thought seen precludes extension path node path 

auction algorithms shortest path problems subsequent bertsekas pallottino bps graph reduction idea strengthened certain upper bounds node shortest distances delete arcs ectively 
algorithms developed 
maintains basic simplicity auction algorithm earlier nmin log running time 
second algorithm somewhat complex running time 
theoretical improvements conjunction cient implementation techniques resulted substantially faster practical performance single origin destination problems 
particular fully dense randomly generated problems auction algorithm graph reduction closest competitors bps 
shortest path problems consider generalization single origin single destination shortest path problem single path seek best paths 
words want find shortest path say origin destination find shortest path subject condition di erent arc find shortest path subject condition di erent kth shortest path versions problem depending paths allowed contain cycles law 
important algorithmic ideas solving shortest path problems solving sequence shortest path problems involving graphs di er slightly arcs nodes dre law mar acm amm 
auction shortest path algorithm particularly suited solving shortest path problems reasons conveniently transfer favorable initial price information shortest path problem solution subproblem greatly expedited 
second requires solution single origin single destination problems solve forward reverse mode faster single origin destination problem existing methods solve acm amm 
computational studies exploring auction algorithms shortest path problems interesting subject investigation 
node disjoint shortest path problems consider generalization single origin single destination shortest path problem single path seek node disjoint paths minimum sum lengths 
node node added assignment problem viewed special case problem special case separable version threedimensional assignment problem involving optimal choice disjoint ordered triplets cost triplet separable form ij jm auction algorithm node disjoint shortest path problem bears similarity preceding shortest path algorithm developed bec 
particular algorithm maintains price vector node disjoint paths starting origin satisfy cs condition 
paths destination algorithm stops 
paths say destination extended contracted terminal node 
result 
extension transportation problems extension joins path node truncated portion node preceding portion added favorable computational results auction algorithm bec 
interestingly algorithm specialized assignment problem identical original auction algorithm section illustrating relation bidding mechanism assignment auction algorithm extension contraction mechanism shortest path auction algorithm 

extension transportation problems consider extension auction algorithm uncapacitated transportation problem 
bipartite graph sources sinks 
problem assignment problem node supplies need 
form maximize ij ij subject ij 
ij 
ij 
positive integers feasibility satisfy easily convert problem assignment problem replacing source sink node collection duplicate persons objects respectively nodes 
particular source node supply replaced persons sink node demand replaced objects 
furthermore arc create arc benefit ij connecting person corresponding object corresponding example fig 

possible solve equivalent assignment problem straightforward application auction algorithm di culties dimension problem greatly increased number persons number objects 
structure equivalent assignment problem protracted price wars inevitable due duplicate objects persons created transformation 
provides example 
sources sinks persons objects similar persons similar objects similar persons transportation problem equivalent assignment problem sources sinks persons objects transportation problem equivalent assignment problem 
extension transportation problems illustration conversion transportation problem assignment problem 
source transformed persons example source transformed persons sink transformed objects example sink transformed objects 
arc benefit ij transportation problem assignment arc benefit ij connecting persons corresponding objects corresponding typical example transportation problem converted equivalent assignment problem duplicate objects induce price wars auction algorithm 
larger zero 
persons keep bidding prices objects increments prices reaches exceeds minimum 
example figs 

possible address di culties modifying auction algorithm takes advantage special structure assignment problems created duplicate objects persons bec 
particular assignment problem say objects similar write matched persons equal values ij ij 

extension transportation problems say persons similar write ij 
object set objects similar called similarity class denoted 
person set persons similar called similarity class denoted 
get sense deal similarity classes consider auction algorithm section applied assignment problem fig 

person continue bidding similar objects prices equal object attractive person objects may viewed contention threshold reached prices similar objects person interested object outside similarity class 
contention thresholds object similarity class course higher price object rules auction algorithm constrained price object class 
suppose person bids object similarity class updates price updates corresponding contention threshold 
suppose contention thresholds objects similarity class rise essentially common price objects 
seen violating cs raise simultaneously prices objects class minimum contention threshold resolving corresponding price war 
auction algorithm similar objects preceding idea implemented simply algorithm call auction algorithm similar objects 
object maintain contention threshold unassigned contention threshold equal initial price time assigned new person contention threshold set plus minimum level rise finds object di erent similarity class equally attractive prices determined contention thresholds 
particular price object minimum contention threshold objects similarity class min 
objects similarity class price possibly di erent contention thresholds 
formally auction algorithm similar objects auction algorithm section di erence bidding phase unassigned person finds best object corresponding best value basis contention thresholds arg max ij max ij 
sets contention threshold plus bidding increment second best object di erent similarity class defined max ij value best object person value second best similarity class person price increment implicit bid person best object case regular auction algorithm value second best object person price increment implicit bid person best object case auction algorithm similar objects similarity class best person similarity class second best person values aij pj objects person contention thresholds 
extension transportation problems max ij 
contention thresholds objects similarity class raised price class raised minimum contention threshold eq 

note relation min prices contention thresholds replaced eqs 

unassigned person bids best object best similarity class bidding increment contention thresholds significantly higher bidding increment prices see fig 

example problem fig 
initially object prices contention thresholds zero iteration bidding person bid contention threshold object second iteration bidding person bid contention threshold object price similarity class increase min third iteration min bidding person bid object auction terminate person bid object depending smallest contention threshold person left unassigned bid object iteration terminating auction 
seen auction algorithm similar objects resolves quickly price wars due duplicate objects corresponding sinks transportation problem 
illustration bid person auction algorithm similar objects 
object ers best value ij person contention thresholds value ered second best similarity class value second best object regular auction algorithm 
second best object belongs similarity class bid person higher auction algorithm similar objects regular auction algorithm 

generic auction algorithm minimum cost flow problems regarding validity algorithm shown object prices satisfy cs essentially repeating proof prop 
follows algorithm terminate feasible problem 
shown integer ij final assignment optimal number object similarity classes case auction algorithm section see bec ber pp 
prop 
proved appendix 
increased dimensionality due duplicate objects created transforming transportation problem assignment problem reflected corresponding reduction threshold value obtain optimal solution 
auction algorithm similar persons enhance performance auction algorithm account presence similar persons 
idea submit common bid persons similarity class person class unassigned 
result persons class compete objects bids submitted higher 
ect persons similarity class cooperate compress price war resolve iteration 
illustrate idea corresponding auction algorithm fig 

idea common bid person similarity class combined previously discussed idea contention thresholds corresponding auction algorithm similar objects 
particular cooperative bid person similarity class contention thresholds objects 
proper streamlining computations obtains algorithm transportation problem ect auction algorithm corresponding equivalent assignment problem cf 
fig 
similar persons objects properly taken account 
auction transportation algorithm sink price arc carries positive flow ij contention threshold ij associated 
price equal original price sink demand sink exhausted ij equal minimum contention threshold incoming arcs carry positive flow min ij ij 
sources bid sinks increasing contention thresholds corresponding arcs sink price increases demand exhausted associated contention thresholds increased 
sink prices increase corresponding profits sources defined max ij decrease cs condition ij ij maintained 
cs conditions extend corresponding condition assignment problem 
shown bec integer problem feasible flow vector optimal provided exists price vector corresponding profit vector satisfying cs min 
sources sinks persons objects transportation problem equivalent assignment problem similar persons 
generic auction algorithm minimum cost flow problems illustration auction algorithm similar persons 
algorithm persons similarity class persons submit bids best objects class 
levels bids bids accepted profit person class set profit ered st best object 
example similar persons result conversion transportation source similar persons consider case initial assignment empty initial prices 
regular auction algorithm operate fig 
involving long price war small relative iteration auction algorithm similar persons persons submit common bid best objects 
person submit bid object iteration algorithm terminate avoiding price war 
initial iteration persons submit bid object bid object bringing net value objects value third object minus 
person submit bid object iteration algorithm terminate 
person submit bid object second iteration raising price persons submit common bid objects third iteration algorithm terminate 

generic auction algorithm minimum cost flow problems discuss general algorithm auction type linear minimum cost flow problems author bec bec includes special cases auction algorithm assignment transportation problems relaxation method discussed section 
specializing general algorithm network flow problems special structure may obtain cient methods exploit structure example general algorithm basis node disjoint shortest path algorithm briefly described section 
directed graph set nodes set arcs number nodes denoted number arcs denoted arc optimization variable ij called flow arc 
denote flow vector ij 
minimum cost flow problem consider minimize ij ij mcf subject 
generic auction algorithm minimum cost flow problems ij ji ij ij ij ij ij ij integers 
problem said feasible exists flow vector satisfying constraints said infeasible 
problem converted equivalent transportation problem shown fig 

possible equivalence transcribe auction transportation ideas previous section minimum cost flow context 
particular derive appropriate form cs 
equivalent transportation problem fig 
denote ij price sink corresponding arc denote profit source corresponding node eq 
ij replaced ij account change maximization minimization ij ij ij 
assume auction total incoming flow sink corresponding arc transportation arcs equal demand ij ij initial set possible enforce condition preserving cs selecting initial ij ij min ij 
eq 
ij ij ij ij ij ij ij 
eqs 
obtain ij ij ij ij ij ij ij 
eqs 
obtain ij ij ij ij ij ij ij 
say flow price pair satisfies complementary slackness cs short satisfies arc flow bounds eqs 
hold see fig 

proposition parallels prop 
assignment problem proved general form appendix cf 
prop 

proposition feasible price vector pair satisfies cs number nodes optimal minimum cost flow problem mcf 
develop auction algorithms minimum cost flow problem draw motivation auction algorithms equivalent transportation problem associated assignment problem similar objects persons 
notion bid single source associated increase flow best outgoing arc transcribed context minimum cost problem flow increase single node best outgoing arcs flow reduction node best incoming 
ij ij sinks arcs original network sources nodes original network 
cost coeff 
cost coeff 
ij im jm im jm ij ij ij ij 
generic auction algorithm minimum cost flow problems transformation minimum cost flow problem transportation problem form 
take sinks transportation problem arcs original network sources transportation problem nodes original network 
transportation problem sink incoming arcs cost coe cients shown 
demand transportation problem sink feasible flow range length corresponding original network arc demand transportation problem source sum feasible flow range lengths outgoing arcs corresponding original network node minus supply node shown 
arc flow ij mcf corresponds flows equal ij ij ij ij transportation problem arcs respectively 
illustration cs 
pairs arc flows ij price di erences lie thick lines shaded area thick lines 

generic auction algorithm minimum cost flow problems arcs cf 
fig 

flow modifications followed increase node price maintaining cs condition 
context transportation algorithm notions cooperative bids nodes sense corresponding minimum cost flow context consider simultaneous price increases nodes 
motivated associations introduce computational operations constitute building blocks general auction algorithm minimum cost flow problem 
definitions assumes flow price vector pair satisfying cs 
definition arc said unblocked ij ij ij arc said unblocked ji ji ji push list node denoted possibly empty set arcs unblocked arcs unblocked 
subsequent algorithms flow allowed increase unblocked arcs allowed decrease unblocked arcs 
definition specifies type flow changes considered 
definition arc arc push list node scalar ij ij ji ji respectively 
push node arc respectively consists increasing flow ij decreasing flow ji respectively leaving flows price vector unchanged 
evident definitions push preserves cs 
operation consists raising prices subset nodes maximum common increment cs violated 
definition price rise nonempty strict subset nodes consists leaving unchanged flow vector prices nodes belonging increasing prices nodes amount min sets scalars ij ij ij ji ji ji 
verified definitions price rise maintains cs 
note scalar sets eqs 
nonnegative cs conditions respectively scalar nonnegative 
price rise said substantive price 
generic auction algorithm minimum cost flow problems rise said trivial 
trivial price rise changes flow vector price vector introduced facilitate presentation 
case subset consists single node price rise singleton set referred price rise node price rise single node substantive set nonempty push list empty 
shown feasible problem push list node empty set nonempty 
generic algorithm generic algorithm described shortly consists sequence push price rise operations 
order execution operations subject mild restrictions allowing great deal flexibility exploit structure problem hand 
suppose minimum cost flow problem mcf feasible consider pair satisfying cs 
flow vector define surplus node di erence total flow coming total flow coming ji ij consider node 
possibilities push list nonempty case push node possible 
push list empty case mentioned earlier price rise node substantive 
problem feasible push substantive price rise possible node furthermore price rise node push list nonempty see eqs 
feasible problem push possible node possibly price rise preceding observations form basis method called generic algorithm uses fixed positive value starts pair satisfying cs 
algorithm terminates nodes continues perform iterations 
iteration consists sequence pushes price rises including push described 
typical iteration generic algorithm perform sequence order finite number pushes price rises push necessarily price rise 
furthermore push performed node flow increment satisfy 
price rise performed set proposition proved bec bec ber establishes validity generic algorithm 

relaxation method proposition assume minimum cost flow problem mcf feasible 
increment push integer generic algorithm terminates pair satisfying cs 
flow vector feasible optimal idea proof pushes indefinitely performed intermediate substantive price rises 
algorithm terminate prices nodes positive surplus increase infinity prices nodes negative surplus remain initial level 
thought seen implies feasible problem cs violated leading contradiction 
problem infeasible algorithm may terminate 
way deal infeasibility convert problem guaranteed feasible introducing artificial high cost arcs 
appropriate level cost quantified similar case assignment problems see eqs 
ber 

relaxation method price rise operations generic algorithm may involve nodes 
require node involved price rise obtain relaxation method proposed author ber ber described section 
fixed positive value start pair satisfying cs 
furthermore starting arc flows integer algorithm preserves integrality arc flows 
start typical iteration flow price vector pair satisfying cs select node node algorithm terminates 
iteration perform pushes prise rises involving node typical iteration relaxation method select node 
node exists terminate algorithm go step 
step push list node empty go step select arc push list go step 
step node arc opposite min ij ij min ji ji 
perform push arc result operation obtain go step go step 
step perform price rise node go step 
straightforward verify relaxation method special case generic algorithm section prop 
applies 
result feasible problem algorithm terminates pair satisfying cs flow optimal similar assignment problems possible scaling conjunction method frequently essential practical performance 

extension asymmetric assignment problems computational complexity unscaled version relaxation method studied ber 
complexity scaled version studied gol particularly favorable polynomial running time estimates derived see bee bee got additional results lines 

application relaxation method max flow problems relaxation method applied max flow problem problem converted minimum cost flow format involving feedback arc connecting sink source having cost shown fig 

small cost range forego scaling maintaining polynomial complexity better appropriate implementation 
practice typically forego scaling additional computational tricks needed ects price wars see section 
scaling change cost feedback arc ts 
done relaxation method bears close resemblance max flow algorithm proposed gol got called push relabel algorithm 
max flow algorithm derived di erent point view unrelated duality cs 
uses node labels context relaxation approach viewed prices 
maxflow version relaxation method ber ber simpler algorithm gol got obtains maximum flow phase single phase versions authors see amo 
initialized arbitrary prices max flow algorithm gol got initial prices satisfy arcs 
significant example wants scaling generally reoptimization setting wants capitalize results solution slightly di erent max flow problem 
related max flow algorithms computational complexity discussed aho amo chm mps 

extension asymmetric assignment problems slight variation auction algorithm asymmetric assignment problems number persons number objects requirement person assigned object 
solve problem auction algorithm need modified choice initial conditions su cient require initial prices zero noted original ber 
unfortunately approach asymmetric assignment problems deficiency initial object prices zero scaling impossible 
result method susceptible price wars associated long running times 
address di culty may convert asymmetric problem symmetric adding artificial persons assigned 
extension asymmetric assignment problems max flow problem minimum cost flow representation 
special nodes source sink 
objective push flow possible observing arc capacity constraints 
introduce artificial arc cost large upper flow bound assign cost zero arcs 
optimum flow ts equals maximum flow sent original graph 
object zero cost 
introduces undesirable increase problem dimension 
auction algorithm similar persons section allow scaling advantage structure induced artificial persons 
indirect approach converting asymmetric assignment problem symmetric seen 
discuss direct probably ective auction approach asymmetric assignment problems 
reverse auction asymmetric assignment problems possible reverse auction conjunction forward auction provide asymmetric assignment algorithms scaling 
introduce proper form cs condition assignment pair 
proposition proved parallels prop 
symmetric assignment problem 
proposition feasible assignment pair satisfy conditions ij ij min assigned unassigned optimal asymmetric assignment problem 
consider trying solve asymmetric assignment problem means auction 
start assignment pair satisfying cs conditions perform forward auction defined earlier symmetric assignment problem point 
extension asymmetric assignment problems person assigned distinct object 
feasible problem seen yield finite number iterations feasible assignment satisfying conditions 
assignment may optimal prices unassigned objects may minimal may satisfy third cs condition 
roughly happening forward auction resolve objects left unassigned termination intrinsically undesirable er relatively low benefit persons left unassigned initial prices high relative initial prices assigned objects 
resolve dilemma modified form reverse auction lower prices objects left unassigned termination forward auction 
reverse auction iterations persons may reassigned objects third condition satisfied 
assignment obtained shown satisfy cs conditions prop 
optimal strictly optimal problem data integer 
modified reverse auction starts feasible assignment pair satisfying cs conditions 
feasible problem obtained regular forward reverse auction discussed earlier 
denote minimal assigned object price initial assignment min assigned initial assignment typical iteration modified reverse auction reverse auction unassigned objects participate auction 
particular algorithm maintains feasible assignment pair satisfying eqs 
terminates unassigned objects satisfy case seen third cs condition satisfied 
scalar kept fixed algorithm 
typical iteration modified reverse auction asymmetric assignment select object unassigned assignment satisfies object algorithm terminates 
find best person arg max ij corresponding value max ij find max ij 
person define 
set go iteration 
min 
set 
practical computational aspects auction algorithms add assignment pair remove pair object assigned start iteration 
note formula bidding increment object enters assignment price equal minimum eq 
attained term 
furthermore calculated seen eqs 
algorithm prices monotonically decreasing profits monotonically increasing 
proposition proved see ber asserts validity method 
proposition modified reverse auction algorithm asymmetric assignment problem terminates finite number iterations assignment obtained optimal 
mentioned earlier forward auction followed modified reverse auction start arbitrary initial prices 
result scaling performing sequence auctions decreasing values 
possible variations method ective modified reverse auction scaling phase 
scaling phases forward auction exclusively 
alternative algorithms asymmetric assignment problems switch forward reverse methods scaling phase see bec 
forward reverse auction types inequality constrained problems reverse auction solve variation sided inequality constrained assignment problem persons objects need assigned degrades assignment total benefit 
problem converted asymmetric assignment problem persons assigned introducing person artificial object zero benefit pair 
algorithm earlier solve problem 
algorithm streamlined calculations involving artificial objects pairs handled ciently 
class interesting assignment problems called problems solved ciently combined forward reverse auction ideas see 
problems persons assigned object objects assigned person simultaneously number assignments person object may may subject upper bound 

practical computational aspects auction algorithms section provide overview computational aspects auction algorithms concentrating primarily case assignment problem 
generally appears simple problems assignment shortest path max flow auction algorithms competitive far superior classical methods 
problems complex structure auction algorithms 
practical computational aspects auction algorithms match performance closest competitors primal simplex primal dual relaxation methods 
generally auction algorithms better suited parallel computation 

assignment problems practice auction algorithm proved ective assignment problems 
computational studies bee shown substantially faster closest competitors particularly sparse problems 
speedup factor typically increases problem size 
problem density increases speedup factor tends decrease fully dense problems auction algorithm roughly competitive methods combine primal dual sequential shortest path method extensive initialization procedure naive auction algorithm section ber 
extensive computational study cas explores behavior various auction algorithms randomly generated problems broad variety di erent structures 
adaptive scaling number variations scaling technique aimed improving computational ciency 
types problems scaling essential high likelihood price wars 
types problems price wars highly better forego scaling altogether implement aggressively reduce quickly ultimate value 
motivates scaling techniques known collectively adaptive scaling reduced aggressively conservatively method progress 
type adaptive scaling uses values scaling phase ceiling value denoted current value denoted 
ceiling value kept constant scaling phase reduced phase ultimate value 
current value bidding increment cf 
eq 
may change range 
current value coincides ceiling value standard form nonadaptive scaling obtained 
scaling truly adaptive started relatively small value gradually increased various criteria ceiling value 
example may kept constant long new pair added assignment fixed number iterations may gradually increased 
adaptive scaling may useful high cost artificial pairs introduced guarantee problem feasible described earlier 
pairs cost range problem greatly expanded potentially increasing number scaling phases 
hand high cost pairs superfluous problem feasible may form adaptive scaling recognize case accordingly reduce appropriate levels 
generally ective adaptive scaling requires ingenuity trial error fair amount intuition structure problem hand 
problem integer overflow benefits ij integer auction algorithm cases executed integer 
practical computational aspects auction algorithms arithmetic 
common way integer starting prices multiply ij integer values final value 
generated prices quantities integer 
potential di culty prices may large exceed integer range computer 
particular eq 
see upper bound order max ij ij multiplied integer arithmetic large lie outside integer range computers moderate values remedy situation may store prices floating point format preferably double precision floating point arithmetic execute price update calculations integer arithmetic computations 
experiments reported cas observed involves slowdown practical running time algorithm factor 
appears di culty integer overflow ectively addressed relatively small cost 
third best implementation frequently auction algorithm best objects person change successive bids person 
motivates implementation idea developed author collaboration unpublished attempts exploit fact test check best objects previous bid continue best 
test passed computation values ij remaining objects unnecessary 
consider auction algorithm iteration calculate bid person basis price vector suppose addition best value max ij best object arg max ij second best value max ij compute second best object arg max ij 
third best value max ij 
consider subsequent iteration person bids updated price vector ij ij seen continue best objects reason object prices decrease course algorithm implying ij result tests passed forego calculation values ij objects hand tests violated inference regarding best second best objects exhaustively compare values objects compute best second best third best values 
computational 
practical computational aspects auction algorithms experience shown savings calculation object values tests passed far outweigh overhead maintaining third best values performing tests 
particularly problem fairly dense set objects 
parallel asynchronous implementation bidding assignment phases auction algorithm highly parallelizable 
particular bids computed simultaneously parallel persons participating auction 
similarly subsequent awards highest bidders computed parallel objects received bid 
furthermore bid single person computed cooperatively processors parallel 
implementations auction algorithm parallel shared memory machines bec zak simd machines csw 
strict temporal separation bid calculation phase highest bidder award phase implementation said synchronous 
implementation basic methods parallelize bidding phase set unassigned persons submit bid third method combination 
number processors parallelization bids jacobi parallelization calculations involved bid person carried single processor 
number persons call exceeds number processors processors execute calculations involved bid 
processors idle bidding phase reducing ciency 
typically happen late stages algorithm 
parallelization bid gauss seidel parallelization set consists single person calculations involved bid person shared processors system 
set admissible objects divided groups objects 
assuming number processors number objects processors left idle 
best object best value second best value calculated group parallel separate processor 
calculations completed synchronization processors required check results merged processors finds best value best group values simultaneously computing corresponding best object bid increment 
possible merging parallel processors absence special simd type hardware may ine cient particularly number processors small extra synchronization overhead involved 
drawback method preceding typically requires larger number iterations iteration involves single person 
significant gauss seidel iteration may take time executed multiple processors parallel synchronization overhead roughly proportional number iterations 
hybrid approach block gauss seidel parallelization approach bid calculations person parallelized preceding method number processors bid 
practical computational aspects auction algorithms compute bids roughly persons parallel assuming unassigned persons available iteration 
proper choice method combines best features alleviates drawbacks preceding 
bidding phase iteration completed synchronization point assignment phase executed 
phase may carried single processor 
possible consider multiple processors execute assignment phase parallel potential gain parallelization may modest associated overhead may set gain suggested computational study bec shared memory machine 
totally asynchronous implementations auction algorithm interesting quite flexible may result faster solution 
knowledge parallel asynchronous implementations auction algorithm todate shared memory machine 
implementation bec bidding merging calculations gauss seidel method divided tasks organized queue 
processor free starts executing top task queue queue nonempty checks termination condition satisfied 
algorithm stops processors encounter termination condition 
similar synchronous block gauss seidel implementation set admissible objects divided groups objects 

calculation bid person divided tasks 
tasks search tasks involving groups objects 

perform tasks processor calculate store memory best value second best value best object corresponding object group 
sth task starts search memory storage best value second best value best object group completes bid person merging individual group search results finding best object bid person currently stored group results 
sth task includes raising price best object changing assignment object assuming calculated bid larger best object price 
sources 
possible prices changed time search task completed time results task calculate person bid 
second possible merging task person bid carried search tasks associated bid completed 
cases bid may reflect date price information may prove ine ective yields bid exceed corresponding best object price occurs simply cancel bid forego corresponding update object price assignment 
advantage asynchronous implementation processors remain idle waiting get synchronized processors waiting merging tasks completed 
careful formulation totally asynchronous model proof validity bec includes extensive computational results shared memory machine confirming advantage asynchronous synchronous implementations 
computational experience far suggests generally typically prolonged endgame auction algorithm small percentage persons remains unassigned speedup 
practical computational aspects auction algorithms obtained jacobi parallelization relatively modest order 
attainable speedup gauss seidel parallelization hybrid schemes potentially higher particularly problem dense special hardware vector processing capabilities 

shortest path problems aside combining forward auction shortest path algorithm reverse counterpart number useful implementation ideas 
main computational bottleneck algorithm calculation min ij done time node terminal node path 
reduce number calculations observation 
cs condition ij maintained times arcs satisfies ij follows ij min ij path extended terminal node path 
suggests implementation strategy time path contraction occurs terminal node calculate min ij arc arg min ij time node terminal node path check condition ij satisfied extend path node going calculation min ij practice device ective typically saving third half calculations preceding expression 
reason test ij rarely fails way fail price increased successive times terminal node path 
theoretical point see bps 
preceding idea strengthened 
suppose compute best neighbor arg min ij compute second best neighbor arg min ij 
practical computational aspects auction algorithms corresponding second best level ik time node terminal node path check condition ij satisfied know attains minimum expression min ij obviating calculation minimum 
hand ij due increase subsequent calculation check see ik best neighbor arg min ij obviating calculation minimum 
proper implementation devices outlined typically reduce number calculations expression min ij factor typically range dramatically reducing total computation time 
devices graph reduction auction shortest path codes presently fastest single origin destination randomly generated problems see bps 
parallel implementation single destination multiple origins interesting parallel computation possibilities arise 
idea maintain di erent path origin possibly reverse path destination 
di erent paths may handled di erent processors price information shared processors way 
possible implementations idea 
describe shared memory implementation refer ber ms thesis pol discussions message passing implementations 
simplicity consider possibility reverse path thesis pol pob discuss parallel sided algorithms 
common price vector stored shared memory accessible processors 
origin path satisfying cs synchronous implementation algorithm iteration executed simultaneously origins possibly origins depending availability processors 
iteration results corresponding di erent origins coordinated 
note node terminal node path origins result iteration origins path extension path contraction corresponding price change occur simultaneously origins 
potential conflict arises node terminal path node origin path di erent origin extended result iteration 
increased due path contraction origin path extension origin cancelled 
additional important detail origin computation terminal node path origin shortest 
practical computational aspects auction algorithms path destination 
processor handling origin may diverted handle path origin 
reasonable speculate parallel time solve multiple origins problem closer smallest time origins find single origin shortest path longest time 
conjecture needs tested experimentally shared memory machine 
parallel implementation outlined synchronous origins iterate simultaneously results communicated coordinated iteration extent necessary iteration 
asynchronous implementation possible principally monotonicity mapping min ij see bet 
refer pol pob discussion asynchronous implementation 

transportation problems serial version auction transportation algorithm section implemented tested bec 
algorithm uses adaptive scaling integer arithmetic version floating point arithmetic useful large cost range tested 
computational results show auction algorithm considerably faster chief competitors important classes transportation problems 
generally problems characterized properties homogeneity asymmetry homogeneous problem levels supply demand 
asymmetric problem number sources larger number sinks 
types transportation problems computational experimentation suggests auction algorithm outperformed state art codes relaxation methods see bec ber 
know unpublished studies parallel asynchronous implementations transportation auction algorithm unpublished 
studies indicate jacobi parallelization modest speedup order possible shared memory machines 

minimum cost flow problems serial implementations relaxation method general minimum cost flow problems competitive practice implementations methods overwhelmingly worse see ber 
relaxation method suited parallel computation parallel computing environments may faster closest competitors 
method admits totally asynchronous implementation shown original ber see bee bet 
synchronous massively parallel implementation relaxation method liz 
relaxation method implemented reverse version node price decreased flow pulled incident arcs node pushed away node 
idea fairly similar reverse auction 
computational tests ber liz combined forward reverse version relaxation perform better forward version evidence conclusive 
forward reverse version greater parallelism potential nodes positive negative surplus iterate simultaneously safeguards preserve desirable termination properties 
parallel implementations type tested 

max flow problems mentioned section max flow version relaxation method implemented ciently scaling 
important understand intense price wars occur particularly sparse problems despite small cost range polynomial complexity method 
alleviate detrimental ects price wars computational tricks essential 
particular observed problems price wars occur relaxation method finds minimum cut quickly may spend great deal additional time resolve subsequent price wars 
interested just minimum cut just value maximum flow worth testing periodically see minimum cut obtained 
method doing breadth search described ber exercise max flow code appendix ber 
maximum flow obtained minimum cut variant ford fulkerson method typically done quickly 
related procedures aim ects price wars discussed gol mps 
noted despite practical success schemes described worst case max flow examples constructed unscaled version relaxation method take large number iterations proportional see bet 
examples quite artificial unknown method behavior important types practical problems 

progress years extend apply auction algorithms variety linear network flow problems place equal footing classical primal cost dual cost improvement methods 
auction algorithms new fully developed 
research broadly applicable competitive classical methods 
auction algorithms discussed implemented computer codes 
codes appear author textbook ber latest versions available author 
acm costa madeira martins algorithm ranking shortest paths working universidade de coimbra coimbra portugal 
amm madeira martins computational improvement shortest paths ranking algorithm working universidade de coimbra coimbra portugal 
amo ahuja magnanti orlin network flows sloan cambridge ma handbooks operations research management science vol 
optimization nemhauser rinnooy kan todd eds north holland amsterdam pp 

aho ahuja orlin fast simple algorithm maximum flow problem working cambridge ma operations research vol 
pp 

bertsekas 
reverse auction solution inequality constrained assignment problems unpublished report 
bps bertsekas pallottino polynomial auction algorithms shortest paths submitted publication 
bec bertsekas auction algorithm transportation problems annals operations research vol 
pp 

bec bertsekas auction algorithm minimum cost network flow problem laboratory information decision systems report lids cambridge ma november 
bec bertsekas parallel synchronous asynchronous implementations auction algorithm report burlington ma nov parallel computing vol 
pp 

bec bertsekas generic auction algorithm minimum cost network flow problem report burlington ma sept 
bec bertsekas forward reverse auction algorithm asymmetric assignment problem report burlington ma april 
bee bertsekas eckstein distributed asynchronous relaxation methods linear network flow problems proc 
ifac munich germany july 
bee bertsekas eckstein dual coordinate step methods linear network flow problems math 
progr series vol 
pp 

bem bertsekas mitter descent numerical methods optimization problems erentiable cost functions siam journal control vol 
pp 

bet bertsekas tsitsiklis parallel distributed computation numerical methods prentice hall englewood cli 
ber bertsekas distributed algorithm assignment problem lab 
information decision systems working march 
ber bertsekas new algorithm assignment problem math 
programming vol 
pp 

ber bertsekas distributed asynchronous relaxation algorithm assignment problem proc 
th ieee conf 
dec contr pp 

ber bertsekas distributed asynchronous relaxation methods linear network flow problems lab 
information decision systems report november 
ber bertsekas distributed relaxation methods linear network flow problems proceedings th ieee conference decision control pp 

ber bertsekas auction algorithm distributed relaxation method assignment problem annals operations research vol 
pp 

ber bertsekas linear network optimization algorithms codes press cambridge mass ber bertsekas auction algorithm shortest paths siam optimization vol 
pp 

csw smith wilson performance parallel assignment algorithms di erent multiprocessor architectures report burlington mass 
cas reverse auction algorithms assignment problems dimacs series discrete mathematics theoretical computer science 
chm maheshwari analysis push algorithms maximum network flow siam comput vol 
pp 

dan dantzig linear programming extensions princeton univ press princeton 
dre dreyfus appraisal shortest path algorithms operations research vol 
pp 

ford jr fulkerson flows networks princeton univ press princeton 
got goldberg tarjan new approach maximum flow problem proc 
th acm stoc pp 

got goldberg tarjan solving minimum cost flow problems successive approximation math 
operations research vol 
pp 

gol goldberg new max flow algorithm tech 
mem 
mit lcs tm laboratory computer science cambridge ma 
gol goldberg cient graph algorithms sequential parallel computers tech 
report tr laboratory computer science cambridge ma 
jonker shortest augmenting path algorithm dense sparse linear assignment problems computing vol 
pp 

zaki performance characteristics jacobi versions auction algorithm alliant fx report dept mech 
ind eng univ illinois champaign urbana 
kuh kuhn hungarian method assignment problem naval research logistics quarterly vol 
pp 

law lawler combinatorial optimization networks matroids holt reinhart winston 
liz li zenios data parallel solutions min cost network flow problems relaxations report dept decision sciences wharton school univ pennsylvania phil penn 
lue luenberger linear nonlinear programming addison wesley reading ma 
mar martins algorithm ranking paths may contain cycles european operations research vol 
pp 

mps maximum flow problem max approach european operational research vol 

min comment shortest route problem operations research vol 

pas papadimitriou steiglitz combinatorial optimization algorithms complexity prentice hall englewood cli 
pas pallottino strongly polynomial algorithms shortest paths dipartimento di informatica report tr university pisa italy 
phillips zenios experiences large scale network optimization connection machine report dept decision sciences wharton school univ pennsylvania phil penn nov 
pob bertsekas parallel shortest path auction algorithms lab 
information decision systems report april 
pol analysis parallel asynchronous schemes auction shortest path algorithm ms thesis eecs dept cambridge ma jan 
roc rockafellar network flows programming wiley interscience 
sch schwartz computational analysis auction algorithm unpublished manuscript 
wein zenios massively parallel auction algorithms assignment problem proc 
rd symposium frontiers massively parallel computation md 
appendix wein zenios massively parallel solution assignment problem parallel distributed computing vol 
pp 

zak zaki comparison algorithms assignment problem report orl dept mechanical industrial engineering univ illinois urbana ill 
appendix cs primal optimality dual optimality assignment problems fix 
show feasible assignment 
set prices 
satisfy complementary slackness complementary slackness assignment maximizing total benefit optimal 
furthermore set prices minimizing certain dual cost function 

note total benefit feasible assignment 
satisfies ik max ij set prices 
second term right hand side ik term equal optimal total assignment benefit max ik min max ij hand assignment 
satisfies cs set prices 
max ij ij appendix adding relation see max ij ij 
showed earlier follows total assignment benefit ij optimal value note function max ij appearing definition may viewed dual function price variables minimization may viewed dual problem standard linear programming duality context see ber bet roc pas 
seen preceding analysis prices attain dual optimal value preceding argument see assignment set prices equilibrium maximize total benefit minimize dual function respectively 
minimum cost flow problems consider minimum cost flow problem prove generalized version prop 
holds problem data integer 
proposition flow price pair satisfy cs suppose feasible 
optimal minimum cost flow problem mcf provided min simple cycles cost number arcs cost cost ij ij particular optimal problem data integer proof optimal see ber exists simple cycle negative cost ij ij unblocked respect ij ij ij ij cs cf 
eq 
preceding relations imply ij appendix ij adding relations arcs number hypothesis obtain ij ij 
arc costs ij integer obtain contradiction eq 

appendix finite termination auction algorithm appendix show feasible problem positive value auction algorithm terminates feasible assignment optimal optimal problem data integer 
shows particular prop 

proof relies facts object assigned remains assigned remainder algorithm duration 
furthermore termination exist object assigned price equal initial price 
reason bidding assignment phase result reassignment assigned object di erent person result object unassigned 
time object receives bid price increases see eq 

object receives bid infinite number times price increases 
bids person number objects set best object value defined max ij decreases 
reason bid person decreases leaves unchanged object attaining maximum eq 

case price object receiving bid increase object receive bid person decreases 
person bids infinite number times decrease 
argue contradiction 
termination occur subset objects received infinite number bids nonempty 
subset persons bid infinite number times nonempty 
argued prices objects tend argued scalars max ij decrease persons ij tends implying 
appendix cs condition states ij assigned pair finite number iterations object assigned person finite number iterations person unassigned start iteration follows number persons strictly larger number objects contradicts existence feasible assignment eq 
persons assigned objects algorithm terminate 
feasible assignment obtained termination satisfies cs algorithm preserves cs prop 
assignment optimal 

