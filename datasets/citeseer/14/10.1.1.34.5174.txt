compile time optimisations persistence antony hosking eliot moss coins technical report august object oriented systems laboratory department computer information science university massachusetts amherst ma appears proceedings fourth international workshop persistent object systems design implementation martha vineyard ma sept 
project supported national science foundation ccr dcr digital equipment gte laboratories eastman kodak 
consider persistent programming language offer performance competitive non persistent languages memory resident data 
concerned object oriented languages implementing persistence object faulting system detects uses non resident objects fetches demand 
background object faulting means implementing describe specific language developing persistent modula 
explore approaches optimising persistence aspects persistent modula outline techniques consideration compiler development effort 
object oriented systems group university massachusetts engaged research exploring integration programming languages database technology 
part involved development persistent programming languages ps algol effort atkinson atkinson morrison 
approach problem language database integration object oriented standpoint 
particular approach persistence integrate existing programming languages persistent object store mneme moss moss 
difference functionality mneme object storage systems exodus storage manager carey carey observer skarra hornick zdonik integration techniques extend 
chosen object oriented languages integration mneme smalltalk goldberg robson modula cardelli 
reasons choosing follows 
relatively known 
smalltalk object oriented programming language gain widespread recognition 
modula widely known ancestry quite familiar derives class languages including pascal jensen wirth modula wirth oberon wirth wirth 
second represent quite different philosophies 
smalltalk static type checking 
fact smalltalk class hierarchy provides weak notion type 
calls bound run time hierarchical method lookup mechanism class object method invoked 
lookup fails run time error signalled indicating method undefined class 
hand retaining dynamic binding methods modula guarantee type correctness programs compile time compiler detect invocation methods undefined arguments wrong type 
choosing different languages hope explore generality techniques identify alternatives arising differences 
program manipulates persistent data decision data fetched stable storage memory 
extreme require persistent data memory resident program begins manipulating 
case program accesses small fraction persistent data indiscriminate preloading clearly undesirable 
preloading dynamically check residency persistent data item fetching necessary 
way subset persistent data resident grows dynamically data items accessed program 
approach incurs run time overhead access persistent data item requires explicit residency check resulting retrieval non resident 
case persistent data item accessed dereferencing kind pointer approach reduces technique call object faulting 
residency check performed time persistent pointer dereferenced resulting object fault retrieve data item non resident 
consider referenced data items persistent volatile kind virtual heap 
object faulting preload entire heap objects faulted demand 
design persistent smalltalk object faulting responsibility run time system hosking 
non resident objects trapped smalltalk virtual machine 
certain heuristics restrict residency checks just send bytecodes primitives 
approach purely dynamic changes smalltalk compiler image 
approach modula compiler generate line code perform residency check call object fault handler check fails persistent pointer dereferenced 
note contrast smalltalk impose burden residency checks run time system 
compiler statically determines checks occur 
particular interest persistent programming languages exhibit performance 
aspects performance persistent program 
mentioned persistence usually implies sort residency check ensure data items memory resident contents accessed 
minimise overhead case data resident persistent program approach performance non persistent counterpart 
second aspect performance pertains fetching non resident data stable storage 
case performance difficult define characterised best system resources 
sum costs persistence ffl cost residency checks ffl cost fetching storing managing non resident data 
focus mitigating cost residency checks application typically considered compiler techniques 
addressing second aspect performance require techniques databases cluster data retrieval 
approach improving performance devise exploit compile time optimisations eliminate circumvent residency checks 
emphasis static techniques concentrate realisation modula submits stronger compile time analysis smalltalk modify compiler support persistence 
approach complicated dynamic call binding occurs object methods modula methods bound object created 
late binding means particular call site actual code execute statically determined 
prohibits standard optimisations inlining method code 
contributions follows 
begun frame issues regarding performance persistent programming languages 
second offer approaches implementing persistence identify potential performance problems approaches 
begun identify compile time optimisations bringing performance aspects persistent programming languages close performance non persistent counterparts 
remainder organised way 
review object faulting requirements imposes consider techniques implementing object faulting 
background describe modula programming language changes making move modula persistent modula sketch straightforward techniques implementing persistent modula 
consider compile time optimisations improving performance persistence persistent modula specific language concreteness 
requirements object faulting indicated object faulting requires mechanism checking residency object 
wish check cheap possible assume incur marginal cost 
assume special hardware support example paging hardware 
furthermore residency checks may machine independent assume particular hardware architecture 
mechanism detecting need object fault way handling fault 
assume existence underlying object manager unique object identifier return pointer object buffers retrieving persistent object store necessary 
issue format mismatch objects represented store objects represented memory 
especially significant object contains objects 
typically represented object identifiers store may need converted memory pointers object resident 
conversion process known swizzling performed ways place copying 
place swizzling simply overwrites object object manager buffers converted version object 
requires objects buffer unswizzled buffer written back disk 
complicated fact objects buffer may pointer volatile objects heap 
objects objects accessible persistent 
copy swizzling maintains separate converted version object volatile part heap corresponding version object manager buffers 
cost maintaining correspondence update heap version object eventually results corresponding update buffer version may involve making volatile objects persistent place 
relative advantages scheme obvious place swizzling demands memory may involve 
copy swizzling added benefit buffers may removed easily modified objects unswizzled 
importance fact persistent object stores allow place swizzling applications denied access objects store buffers 
aspect buffer removal addressed direct pointers buffer objects parts heap located updated reflect fact objects refer longer resident 
locating pointers requires remembered set maintained buffer indicating memory locations contain pointers buffer 
pointer object buffer stored memory location check see buffer remembered set updated reflect store 
techniques employed generation scavenging garbage collectors ungar 
garbage collectors shown superior performance interactive systems smalltalk ungar 
performance reputation assume generation scavenging garbage collector choice maintaining remembered sets buffers object manager require little additional mechanism 
unfortunate drawback overhead performing store checks eliminated 
performance generation scavenging persistence known point time 
systems smalltalk remembered sets grow large 
persistence remembered sets probably larger highly data persistent volatile 
larger remembered sets affect performance generation scavenging remains seen 
techniques fault detection previous sections identified need mechanism check residency object detect object fault occur 
object manager handles fault returning direct memory pointer desired object retrieving store non resident 
elaborate residency checks may performed 
consider links non resident objects marked object fault link resident object link non resident object edge marking virtual heap directed graph 
nodes graph objects edges graph object 
computation traverses object graph partially resident memory 
traversing edge resident object non resident object causes object fault link point resident object 
important note merely naming object cause object fault 
contents object need accessed link object traversed required object resident 
need able detect traversal link resident object non resident object 
effectively just ways achieving ffl mark edges graph links non resident objects distinguishing links resident objects see 
ffl mark nodes graph distinguish resident objects non resident objects see 
edge marking relatively easy implement tagging pointers 
checking pointer refers resident object simply matter checking tag 
marked link traversed object fault occurs handled object manager returns pointer resident object 
marked link point resident object see 
note legal suboptimal marked edge refer resident object unmarked edge may refer non resident object 
node marking complicated fact non resident objects just non resident paradoxically memory checked 
solving problem simple 
specially marked resident pseudo objects called fault blocks stand non resident objects 
resident object non resident object pointer fault block see 
link traversed fault block fault occurs handled object manager 
snapping link case involves setting fault block point non resident objects marked fault blocks stand non resident objects object fault occurs updating traversed link resident object non resident object fault block traversed link node marking object memory see 
note level indirection fault block may bypassed updating traversed link point object memory see 
preceding discussion assumes object identifier available object manager handle fault 
edge marking scheme store identifier bits pointer reserved tag 
node marking scheme store fault block 
schemes particular advantages disadvantages 
node marking particular fault block may referenced resident objects 
means object manager need called fault block obtain memory pointer corresponding object link fault block traversed 
memory address cached fault block subsequent traversals links fault block pick additional calls object manager 
overheads associated fault blocks storage management fault blocks creation fault blocks objects referred non resident object swizzled extra level indirection fault blocks imply 
edge marking advantage eliminating space consumed fault blocks level indirection associated 
disadvantage link object fault occurs link traversed 
links object marked pointing non resident object 
means traversal marked link result call object manager determine object address regardless object resident 
snapping link mentioned way reducing overhead object faulting 
edge marking scheme usually little benefit marked link ends getting probably register temporary location 
compiler may help statically determine source marked making sure gets updated link 
modula modula consists primarily modula extensions threads lightweight processes single address space exception handling objects methods garbage collection dispensing variant records ability nest modules 
exception handling threads raise novel issues discuss 
understanding remaining extensions requires understanding type system modula 
modula strongly typed expression unique type type compatibility defined terms single syntactically specified subtype relation written subtype instance type instance type assignment satisfying rule allowed assignable subtype addition specific assignment rules ordinal types integers enumerations subranges pointers arrays 
discuss specifics types 
type may traced untraced 
traced type ref refers storage type automatically reclaimed garbage collector longer traced 
untraced type untraced ref just pascal pointers storage refer explicitly allocated deallocated 
type contains traced address contains untraced 
type null contains value nil 
object types types 
object nil data record paired method suite record procedures accept object argument 
objects may traced untraced 
object type supertype inherits supertype representation implementation optionally may extend providing additional fields methods overriding methods inherits different type correct implementations 
object created may supply may apply certain heuristics problem 
details see hosking 
specific methods individual object type correct overriding default implementations supplied object type 
scheme designed physically reasonable interpret object instance supertypes 
subtype guaranteed fields methods defined supertype possibly may override supertype method implementations 
addition object method values determined object allocated values changed 
object type specified syntax object fields methods methods specifies object subtype additional fields fields additional overriding methods methods 
object inherits traced ness supertype 
built object types traced untraced having fields methods object types descended root untraced root 
summarise subtype rules follows null null null object type root untraced root garbage collection able find traced data 
means untraced data item contain traced 
reason records arrays containing traced implicitly traced 
restrictions summarised table untraced traced untraced theta traced traced data item may contain traced untraced untraced data item may contain untraced 
briefly consider implementation objects 
object interpreted different types carry type code tell actual type methods vary object type possibly object shorthands object untraced object may forms root object 
object types inheriting root untraced root respectively 
methods pointer fields type code method addresses method offset field offset variable implementation modula objects need way find methods invoked 
expected implementation object fields preceded pointer method suite 
method suite simply vector addresses procedures preceded type code 
offset method method suite static run time search required find code run method invocation 
similarly field offsets statically known 
implementation approach illustrated 
persistent modula previous section gave modula type system 
section extend type system incorporate persistence adding third class types persistent similar db types database programming language richardson carey 
persistent type indicated keyword persistent analogous untraced 
persistent indicates specific object object may may resident memory 
addition permit top level variable qualified persistent keyword program persistent data item start persistent data reached 
may thought implicit persistent known root objects persistent store 
new types subtype rules analogous traced types follows null persistent root object inherits persistence supertype 
variable top level may declared persistent persistent var construct just var non persistent variables 
analogous traced data reachable top level persistent variable persistent persist able find persistent top level variable variable declared outermost scope module 
data 
untraced data item may contain persistent 
persistent data item may refer non persistent data question 
glance may little strange data referred persistent data item disappear program ceases execution leaving dangling 
give special semantics allowing refer volatile data program running setting nil persistent data item written back stable storage loaded stable storage 
augment table previous section summarise rules untraced traced persistent untraced theta theta traced persistent special semantics design admittedly non orthogonal orthogonality require data item able contain persistent vice versa persistent data item able contain volatile data making persist transitivity 
non orthogonality consistent traced untraced distinction overhead garbage collection allows programmers indicate explicitly accept overhead persistence 
furthermore easier perform experiments evaluate relative performance persistent ordinary 
collapse persistent traced distinction done smalltalk potential persistent data 
depend performance persistence imposes little performance degradation need distinction 
implementation indicated syntax semantics persistent types variables modula 
turn straightforward implementation extensions techniques object faulting 
persistent ref types simplest implementation perform residency check time 
may node edge marking schemes 
node marking simply implies fault blocks marked tag bit enable check 
overhead extra indirection removed scavenger detects fake object real object attached updated point real object 
fault block storage may eventually reclaimed 
edge marking problem need able tag persistent enable check 
byte addressed architectures achieved ensuring persistent data word aligned leaving low order bit free tag 
alternatively sign bit distinguish memory pointers persistent object identifiers 
techniques certain assumptions machine architecture 
cases tagging may simply impossible 
implement field access persistent object types similarly persistent ref types 
method invocation technique eliminate conditional code residency check 
fault block standing resident object supply fake method suite fault block 
fake method suite contain procedures fault real object 
fault time fault block updated point real object update fault block fake method suite forward calls real object 
technique field access prepared turn field access method invocation 
persistent var treat persistent variable implicit implementation techniques 
mentioned methods code persistent objects persist 
clearly ordinary code persist virtue fact program disk 
question code implementing methods reside persistent object store program 
ideally objects carry methods go different program created 
method code reside store 
face problem dynamically linking method code running program 
appear fundamental difficulties specific design time 
optimisations previous section indicated straightforward implementation persistence modula 
section look improving performance persistent programs compile time optimisation techniques eliminate residency checks 
assuming resident object non resident program execution performing residency check performing times 
occurrences check superfluous may eliminated 
eliminate checks apply traditional static analysis techniques compilers 
discuss optimisations may enabled local basic block global intra procedural analysis eliminate redundant residency checks procedure 
consider traditional optimisations requiring inter procedural analysis residency properties persistent data items residency checks just check 
data items said resident resident 
local optimisations may performed examining statements basic block section straight line code having just entry point exit point 
typical local optimisation common subexpression elimination 
similar approach eliminate redundant residency checks basic block 
consider residency check evaluating boolean expression residency check performed expression true 
checks replaced value true 
approach extend global intra procedural analysis 
furthermore global analysis enables optimisations dead code elimination code motion 
reduce residency checks true fault handling code executed check evaluates false dead may eliminated 
code motion move loop invariant residency check loop 
code hoisting replace residency checks occur different paths program just 
techniques similar shown quite effective richardson 
procedure inlining replaces full call procedure code implements procedure 
allows called code optimised context call site integrating analysis calling procedure 
inlining difficult methods dynamic binding implies general know specific method invoked 
clear allowing objects override type default methods creation time poses difficulty 
eliminating feature language pragmas inserted programmer object type declaration indicating particular method overridden individual object instance type 
consider inlining method call particular cases 
suppose data flow analysis reveals exact type object method invoked determine pragma analysis object override type default implementation method 
inline default code 
second assume object exact type known may override method 
inline default code preceding check object method suite sure method slot contains default method generate code full call failure case 
third case assumptions replace call conditional code branching type object inline default methods second case 
technique known message splitting applied object oriented languages self chambers ungar chambers ungar 
prepared inter procedural analysis customised compilation tailor compilation procedure characteristics particular call site 
just inlining allows compiler optimise procedure context particular call site customised compilation additional space cost inlining imposes customised version line 
customised compiled procedure call sites having appropriate characteristics 
previously self trellis owl schaffert 
applying customised compilation persistence compile customised versions procedures assumptions residency arguments 
particular customised version call site residency requirements satisfied 
techniques information gleaned code compile time 
going back analogy virtual heap directed graph code establishes possible traversals graph 
derive information types potential structure graph 
residency information available attached types retrieval data items indicated resident reducing number residency checks needed 
best explain example 
consider persistent type declaration type persistent ref record field persistent ref foo field persistent ref bar suppose know resident foo object named field 
fault data item simultaneously fault foo item ensure points directly foo item 
compiler need generate residency check uses field components 
way represent residency information annotations type graph 
nodes graph types program edges indicate uses type defining 
example nodes types foo bar edges foo bar 
indicate residency mark edges type graph 
example mark edge foo indicate residency assumption discussed 
order provide precise information distinguish edges name record component correspond 
course question residency information comes 
option allow programmers annotate type declarations pragmas indicating desired properties 
preferable automatic derivation properties 
static trellis trademark digital equipment 
analysis procedure determine information desirable residency properties types procedure 
example intra procedural analysis say path type graph definitely traversed may traversed traversed executing procedure 
obvious combine analyses individual procedures annotate global type graph residency assumptions 
global type graph desirable allow assumptions program 
ensure optimisations applied consistently 
global type graph relatively simple data structure run time system enforcing residency assumptions handling object faults 
global type graph problems assumption represents compromise procedures follow long paths type graph procedures follow short ones 
procedure follows shorter paths global type graph assumptions may cause unnecessary fetches 
procedure follows longer paths need perform residency checks 
problem global type graph approach single object may unbounded number objects required resident 
example large homogeneous data items arrays type causing combinatorial explosion potentially high branching factor 
recursively defined types pose difficulties create cycles type graph introduce residency paths unbounded length 
example consider singly linked list type type persistent ref record persistent ref 
field marked residency fetching item list fetch subsequent items 
shortcomings single global type graph may overcome putting type context 
example specialise annotation type variable type 
view annotating variables types 
variable attached subgraph full type graph root subgraph variable type 
subgraph indicates residency assumptions data reachable variable 
far considered statically obtained residency information 
possibility including statistics obtained dynamic profiling 
types define possible structure virtual heap programs define potential traversals structure profiling approximate probability particular traversal occur 
information fed back compiler intelligent residency decisions actual usage patterns 
style optimisation similar database systems tuning indexing clustering briefly sketched techniques determine number potential faults merged share just residency check 
interesting residency characteristics communicate object manager clustering purposes 
clustering places objects physically close disk may retrieved just disk access 
data items resident clustered retrieving items performed fewer disk accesses 
indicate potential gains allows address aspect performance persistence fetching storing managing non resident data 
interesting potential turn things 
indicated residency information may clustering clustering information drive residency analysis phase compiler 
analysis serve input initial data clustering decisions profiles entire suites programs 
clustering decisions compiler residency analysis 
identified issues regarding performance persistent programming languages introduced approaches implementing persistence 
discussed approaches may implementing persistent modula modification compiler 
indicated possibilities improvement performance persistent programs compile time optimisations 
particular interest role analysis play eliminating residency checks obtaining clustering criteria underlying object store 
modula implementation group university massachusetts consists rick hudson amer diwan addition authors 
group regular design meetings generated ideas incorporating persistence modula 
atkinson morrison malcolm atkinson ronald morrison 
procedures persistent data objects 
acm trans 
program 
lang 
syst 
oct 
atkinson atkinson cockshott 
ps algol algol persistent heap 
acm sigplan notices july 
cardelli luca cardelli james donahue glassman mick jordan bill kalsow greg nelson 
modula report revised 
tech 
rep dec src dec systems research center olivetti research center palo alto menlo park ca nov 
carey carey dewitt richardson shekita 
object file management exodus extensible database system 
proceedings twelfth international conference large databases kyoto japan sept acm pp 

carey michael carey david dewitt joel richardson eugene shekita 
storage management objects exodus 
object oriented concepts databases applications won kim lochovsky frederick eds frontier series 
addison wesley acm press new york ny ch 
pp 

chambers ungar craig chambers david ungar 
customization optimizing compiler technology self dynamically typed object oriented programming language 
proceedings sigplan conference programming language design implementation portland june vol 
acm sigplan notices acm pp 

chambers ungar craig chambers david ungar 
iterative type analysis extended message splitting optimizing dynamically typed object oriented programs 
proceedings sigplan conference programming language design implementation white plains ny june vol 
acm sigplan notices acm pp 

goldberg robson adele goldberg david robson 
smalltalk language implementation 
addison wesley 
hornick zdonik mark hornick stanley zdonik 
shared segmented memory system object oriented database 
acm trans 
office inf 
syst 
jan 
hosking antony hosking eliot moss cynthia bliss 
design object faulting persistent smalltalk 
coins technical report department computer information science university massachusetts amherst ma may 
jensen wirth kathleen jensen niklaus wirth 
pascal user manual report second ed 
springer verlag 
moss eliot moss steven 
managing persistent data mneme designing reliable shared object interface 
advances object oriented database systems sept vol 
lecture notes computer science springer verlag pp 

moss eliot moss 
mneme persistent object store 
coins technical report department computer information science university massachusetts amherst ma oct 
submitted publication design mneme persistent object store 
richardson carey joel richardson michael carey 
programming constructs database system implementations exodus 
proceedings acm sigmod international conference management data san francisco ca may vol 
acm sigmod record acm pp 

richardson joel edward richardson 
persistent systems implementation language 
phd thesis computer sciences department university wisconsin madison wi aug 
available computer sciences technical report 
schaffert craig schaffert cooper bruce mike kilian carrie 
trellis owl 
proceedings conference object oriented programming systems languages applications portland sept vol 
acm sigplan notices acm pp 

skarra andrea skarra stanley zdonik stephen reiss 
object server object oriented database system 
proceedings international workshop object oriented database systems pacific grove ca sept acm pp 

ungar david ungar 
generation scavenging non disruptive high performance storage reclamation algorithm 
proceedings acm sigsoft sigplan software engineering symposium practical software development environments pittsburgh pa apr acm sigplan notices acm pp 

ungar david michael ungar 
design evaluation high performance smalltalk system 
acm distinguished dissertations 
mit press cambridge ma 
ph dissertation university california berkeley february 
wirth niklaus wirth 
programming modula second corrected ed 
springer verlag 
wirth niklaus wirth 
modula oberon 
software practice experience july 
wirth niklaus wirth 
programming language oberon 
software practice experience july 

