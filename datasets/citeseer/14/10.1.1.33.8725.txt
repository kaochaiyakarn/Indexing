page acm transactions programming languages systems pp 

subtyping recursive types roberto amadio luca cardelli cnrs nancy dec systems research center investigate interactions subtyping recursive types simply typed calculus 
fundamental questions recursive types subtype relation term type 
address question relate various definitions type equivalence subtyping induced model ordering infinite trees algorithm set type rules 
show soundness completeness rules algorithm tree semantics 
prove soundness restricted form completeness model 
address second question show pair types subtype relation associate term denotation uniquely determined coercion map types 
derive algorithm term implicit coercions infer type possible 
author supported part digital equipment part stanford cnr collaboration project 
page contents 
types subtypes equality recursive types subtyping recursive types algorithm outline formal development 
simply typed calculus recursive types types terms equations 
tree ordering subtyping non recursive types folding unfolding tree expansion finite approximations 
algorithm canonical forms computational rules soundness completeness algorithm implementation 
typing rules type equivalence rules completeness equivalence rules subtyping rules completeness subtyping rules 
model realizability structure complete uniform pers completeness interpretation 
coercions definability inference 

acknowledgments page 
subtyping inclusion relation types degree programming languages 
subtyping especially important object oriented languages crucial understanding complex notions inheritance subclassing 
recursive types languages 
types supposed unfold recursively match types 
unfolding preserve typing soundness cause compiler diverge 
investigate interaction unrestricted recursive types subtyping 
interaction modern languages structural type matching type equality subtyping determined type structure types syntactically 
past recursive types restricted language features example explicit unfolding ml name matching modula 
algol language rely structural type equality algorithm recursive types 
name matching popular largely easier implement prevents accidental matches type structure 
name matching determines type equality relying partially names assigned types program structure 
name matching recursive analysis occurrences type names 
unfortunately general definition name matching language compiler implements slightly differently 
types meaning eye programmer may may equated different runs compiler depending irrelevant textual perturbations affect name matching rules 
inconsistency name matching rules problem distributed environments type definitions data may migrate outside compiler program run created 
types data meaning independent particular runs languages modula experimental languages amber quest concerned data persistence data migration adopted structural matching 
languages rely subtyping structural subtyping issue 
various language design issues modula restricts structural equivalence plus limited form structural subtyping deal unrestricted combination recursion subtyping forms basis amber quest 
motivation investigate type systems recursive types subtyping related problems structural matching structural subtyping 
structural matching techniques known strong connections understood theoretical concepts 
structural subtyping newer subject 
provide complete theory recursive subtypes leads naturally effective type theory typechecking algorithms 
practice easy adapt algorithms structural typing structural subtyping knowledge done amber formalizing type rules proofs correctness algorithms challenging 
show algorithm type rules complete respect natural notion subtyping 
page rest provide basic intuitions recursive subtypes illustrate main problems non solutions 
section formalizes syntax basic calculus recursive types section introduces subtyping relation tree ordering 
section describes subtyping algorithm section describes corresponding type rules 
partial equivalence relation model section 
section relates subtyping type coercions 
types type normally intended programming languages collection values sharing common structure shape 
examples basic types unit trivial type containing single element int collection integer numbers 
examples structured types functions integers integers pairs integers unit int disjoint union unit int consisting unit value marked left integer marked right arbitrary distinct marks 
recursive type type satisfies recursive type equation 
common examples tree int collection binary trees integer leaves list unit intlist collection lists integers 
note definitions tree list equational properties definition tree list satisfy 
useful examples recursion involving function spaces typical objectoriented style programming cell cell interpreted collection integer containing memory cells implemented triples functions read write add 
functions current cell implicit example add needs receive cell order perform binary addition 
recursive types described equations shall see fact unambiguously defined equations 
see need formal way reasoning solutions type equations 
formal tools particularly useful start examining problematic equations ss rr clear solutions solutions unique 
appealing set sufficient conditions type equations canonical solutions 
equation unit talk solution equation 
canonical solution indicated term unit type equal unit 
new type construction just introduced denoting canonical solutions 
say unit means equal definition solution list equation implies satisfy equation unit intl page provable 
requirement suggests important rule construction amounts step unfolding recursion meaning equal replace 
example unit unit unit intl equation expected hold 
having discussed recursive types need determine value belongs recursive type 
rule allows expand recursive types arbitrarily far finite number expansions 
postulate finite value belongs recursive type belongs finite expansions ordinary typing rules 
push troublesome far longer need consider 
values finite example defined recursively may able push way 
case need provide adequate notions finite approximations values types postulate value belongs type approximation value belongs approximation type 
approximation type expression appropriate truncation depth different unfolding 
precise sections 
subtypes types collections values subtypes subcollections 
example introduce new basic types bottom collection containing divergent computation top collection values 
subtype type type subtype write relations function spaces ab subtyping rule antimonotonic argument 
ab example nat int stores integer cell willing store natural number cell 
sound opposite 
antimonotonic rule familiar object oriented programming main considerations correct typechecking methods 
adequate subtyping rules type constructions may 
example products ab aa bb 
similarly disjoint unions aa bb 
subtyping recursive types 
intuition adopt recursive types subtype relation infinite unfoldings relation appropriate sense 
just consider finite unfoldings type require 
shall see shortly condition strong 
insist inclusion infinite page unfoldings 
precise notion mentioned finite approximations type defining 
unfortunately formal subtyping rules recursive types related algorithms rely approximations involves testing infinite number conditions 
subtyping rules rely finitary rules obvious invent collection rules achieve desired effect 
example idea simply say may occur free show example just assumption tt 
unfortunately implies quite wrong 
unfolding twice get implies subtypes left right wrong inclusion relation antimonotonic position 
problem rule comes negative occurrences left odd number recursion variable 
fact rule sound types monotonic recursion variable 
correct finitary rule inclusion recursive types st occurs occurs assuming inclusion recursive variables verify inclusion bodies deduce inclusion recursive types 
interesting check subtyping fails example 
going back list example unit nats intlist unit safely deduce rule st implies unit nats unit 
hand cell example smoothly 

nats ss 
tt conclude rule inclusion second component write inclusion third add fail 
deficiency rule unsound 
example write function type fails negative numbers 
cell considered possible pass negative integer write cause fail 
issues related typechecking object types object oriented languages discussed length 
page equality recursive types need consider strong notions equality recursive types 
necessary rule weak areas example deduce directly tt ss require assuming st ts 
combination rule equality rules give power need 
check recursive types equivalent assume attempt prove assumption 
tt ss 
consider types ints expand infinitely set values example recursive terms lx int 

assumption show ints get stuck question 
attempt involve expanding unfortunately expand existence 
unfolding get ints int ints ints unfoldings leaves original problem determining meant earlier insufficiency expansion 
fact progress come back original question analyzing entire structure able conclude complete analysis contradiction 
kind reasoning possible carefully justified general need determine conditions stronger notion equality lead circular argument 
note process single context fixpoints shall able show non trivial formally contractive type contexts unique fixpoints infinite trees fixpoints equal 
necessary rule determining type equality formulated follows contractive remains shown generate contractive contexts allow equate types equal infinite expansions 
done algorithm fact natural 
show algorithm sound equate types different infinite expansions complete equate types equal infinite expansions 
proofs correctness algorithms major goals need carefully develop formal framework 
page subtyping recursive types problem equating recursive types related known solvable problems equivalence finite state automata 
similar problem subtyping known parallel 
take example ints looking infinite expansions obtain deduce gd 
exact rules 
attempts unfold fall difficulties 
strategy reduce subtyping problem equality problem solve rule plus rule 
show rule show gd gd 
initially strategy suggests step algorithm synchronizes recursions appropriate way uses rule additional folding unfolding 
algorithm tests subtyping recursive types directly correspondence algorithm rules obvious 
example involves distinct recursive types rule sufficient determine subtyping 
example may artificial situation easily happen practice 
slightly plausible example suppose define type lists alternating integers naturals unit int unit definition arise naturally mutual recursion construct programming language example rec unit unit certainly expect hold 
unit nats show unit nat unit nats apply rule successfully 
algorithm outline describe algorithm informally show sample runs 
approximation algorithm analyzed formal part explain main ideas 
detailed description section 
recursive type form represented memory cyclic linked structure occurrence recursive body represented address corresponding structure back pointer 
subexpressions type expression including subexpressions uniquely determined address memory 
time algorithm reaches structure possibly back pointer option analyzing interior structure unfolding recursive type compare page address addresses termination condition 
algorithm ab operates pair linked structures trail 
trail set address pairs records pairs addresses jointly encountered pair paths linked structures 
avoid diverging cyclic structures algorithms registers local successful termination reaches pair addresses seen pair addresses contained trail 
algorithm determine ab starts empty trail proceeds steps sequence 
consider basic types function types recursive types 
succeed pair addresses order contained trail 
situation completely explored pair cyclic paths subtyping failures declare success paths 
succeed type constants equal subtype relation 
base case collection basic types basic inclusions 
recur 
succeed recursions succeed 
case function types note swapping inclusion domains swapping occur data type constructors 
add pair addresses order trail recur 
succeed recursion succeeds 
presence signals potential cyclic paths store current pair addresses trail case prevent looping 
ordered pair addresses inclusion obviously symmetric detail differs standard trail algorithms type equivalence 
cases similar 
add pair addresses trail recur 
succeed recursion succeeds 
add pair addresses trail recur ab 
succeed recursion succeeds 
fail 
means pair incomparable type expressions function type base type 
faithful description run algorithm involve assigning arbitrary addresses subexpressions type expressions obscure exposition 
display type expressions leave addresses implicit reader urged keep mind 
diagrams represent execution trees 
starting goal bottom branching represents recursive calls leaves represent termination conditions 
trail shown curly brackets elements written ts represent pairs addresses type expressions 
indicate square bracket step algorithm line obtain line 
sample run involves types matching structures inclusion nontrivial 
page ts ts ts tt ts ts tt tt second sample run involves types mismatching structures 
mismatch introduces need examine cyclic path 
loopback step corresponds cyclic structure back original entry point artificial loopback step needed said keep address information implicit 
algorithm loopback situation corresponds failure step followed dereferencing back pointers leads step 
ts ts ts ts ts ts ts ts ts loopback ts run go loop twice order go loop 
interesting examples check tt ss succeeds fails 
main aims show algorithm consistent fact equivalent rules sections 
need place rules algorithm formal framework 
formal development having explained problems unsatisfactory solutions arising subtyping recursive types proceed formal treatment 
far discussed rules subtyping recursive types motivated operational intuition 
broaden perspective consider various notions type equivalence subtyping ab 
induced ordering infinite trees section algorithm section collection typing rules section collection models section mathematical content consists mainly analyzing relationships notions 
simply typed lambda calculus recursive types described section show properties prove restricted form completeness respect model show definability calculus certain maps interpret coercions give page algorithm computing minimal type term respect 
results support relevance theory subtyping recursive types sketched 

simply typed calculus recursive types consider simply typed calculus recursive types ground types bottom top play roles greatest elements subtype relation 
calculus simple embodies interesting problems provide solutions sufficiently general extend domains 
comment techniques applied complex calculi 
types informal bnf notation types defined follows type variables type constants ab types identified renaming bound variables 
parentheses determine precedence absence associates right scoping extends right far possible 
simplicity omit type constructors considered 
terms terms denoted 
rules establish term type written 
assmp lx ab ab mn fold fold unfold unfold terms typed variables typed abstractions applications fold unfold coercions 
subscripted intended recursive type facilitate type inference subscripts omitted 
fold unfold coercions technical devices explicitly contract expand recursive type term contractions expansions happen automatically 
equations fundamental equations calculus 
particular notice constants fold unfold establish isomorphism recursive type unfolding 
conventions stands equality definition abbreviation syntactic identification precedes judgment provable certain formal system linguistic implication metalinguistic implication denotes substitution page lx fold unfold unfold fold section consider model types terms equated example valid equations fold unfold lx mx fv 
tree ordering established theory subtyping non recursive types 
basic motivations example :10.1.1.116.1298:10.1.1.116.1298
notion non recursive type merely syntactic means type contain 
purpose section extend theory recursive types defining notion approximation infinite trees 
subtyping non recursive types simple rules 
type greatest type operator antimonotonic argument monotonic second 
relation reflexive virtue var 
var ab fairly easy prove relation defined iff ab derivable system partial order collection non recursive types 
particular show transitivity rule trans derived 
proven defining collection rewriting rules proofs property applied proof transitivity produce trans free proof judgment 
abstractly look rules clauses inductive definition binary relation show relation transitive see 
folding unfolding types considered equivalent 
general provably isomorphic calculus fold unfold 
languages fold unfold implicit implementations generate run time code 
reasonable require making unfolding transparent 
page fact exhibit model calculus equated recursive domain equations solved equality 
theory type equivalence congruence closure fold unfold turns weak example types sst st equivalent 
assume transparency unfolding natural consider types infinite expansions equivalent 
infinite expansion rephrased approximation property semantics type completely determined semantics finite syntactic approximations 
fact desirable property semantics programming languages see example approximation theorem 
tree expansions seen simple unfolding induce sufficiently strong notion type equivalence 
stronger condition approximation required deal infinite expansions 
explain associate finitely branching labeled regular tree recursive type 
paths tree represented finite sequences natural numbers sw ps concatenation nil empty sequence 
nodes tree labeled ranked alphabet type variable superscripts indicate arity 
tree aw partial function paths node labels domain non empty prefix closed node number children equal rank associated label 
formally indicate domain indicate opposite 
collection tree finitely branching labeled trees partial maps nil ps pj define function type tree recursive types defined tree 
function counts number head position type 
define induction nil nil nil ab nil ab ab nil shape shape cases note ab case reduces second case preserves reducing entails definition founded 
page simple examples tree right repeats 
st 
define collection finite trees tree fin follows tree fin tree pw 
remarks induces bijection tree fin non recursive types 
denote inverse tree complete metric space respect usual metric trees 
fact completion space finite trees tree fin 
recall metric space complete iff cauchy sequence converges 
map mm metric space distance contractive iff real number bm 
banach fixpoint theorem asserts contractive map complete metric space unique fixpoint 
distance tree defined length shortest path distinguishes ta regular tree tree finite number different subtrees 
tree completely specified language occurrences pl atree occurrences occ pw 
particular regular tree associated set pp pl regular language 
follows types problem deciding ta tb reducible problem equivalence deterministic finite state automata 
going back example observe sst st 
finite approximations finite trees correspondence non recursive types partial order defined 
problem going consider extend partial order finite trees tree 
introduce notion finite approximation tree 
crucial keep mind antimonotonic behavior argument 
define family functions tree tree fin kw atree cut th level defined follows page positive negative say positive negative path root select left sibling node labeled odd number times 
extend definition types ta non recursive type convention bijection tree fin non recursive types omitted 
finite tree atree fin ambiguously identify corresponding non recursive type 
similarly atree denote cut corresponding non recursive type 
ready introduce notion tree ordering 
definition tree ordering tree fin fin finite types see tree 
fin type ta tb remarks partial order tree 
preorder recursive types show example consider tree expansions ta tb 
observe occur negative position conclude gives statement 
think tree orderings example consider inductive definition gives ordering ind tree 
ind reflexive relation tree ind ind ind ind ind equivalently ind page atree id tree difficult prove induction ind partial order tree conservatively extends ordering tree fin contained containment strict shown example 
fact ind lacks crucial approximation property possessed 
algorithm section show tree ordering defined types decided natural modification algorithm tests directly reduction minimal form tree equivalence types 
canonical forms step formalizing algorithm introduce canonical forms types systems equations 
canonical forms types allow ignore trivial type equivalences due redundant uses binders 
example recursive type ts simplified canonical form vv changing denoted tree 
canonical form body type variable body 
note different canonical forms may generate tree example st st st sst 
implementations subtyping algorithm manipulate cyclic linked data structures computer memory 
represent data structures abstractly special sets equations 
informally equation relates memory address represented variable node data structure represented type constant type constructor applied variables 
example simple type corresponding equational representation possible memory representation type equations memory representation root addr 
node child child sets equations stylized form called canonical 
section show canonical set equations root variable determines unique tree called solution equations 
give effective ways going type canonical set equations vice versa preserving represented tree 
page proviso order simple correspondence recursive types systems regular equations assume variables bound free types consideration distinct 
type unfolded necessary renaming bound variables performed 
example ts ts rewritten vs tr 
recursive types canonical form henceforth tp denotes collection non recursive types tp denotes collection recursive types canonical form defined follows ab ab case ab occur free ab 
body canonical form immediately start particular tp simplifies case analysis proofs 
proposition existence canonical forms type type canonical form ta tb 
proof crucial observation tt tv 
see proof fact uses rules type equivalence 
regular system equations canonical form systems regular equations known tool representing regular trees see example 
purposes regular system equations canonical form element tenv finite association distinct type variables members tvar types specific form tenv tvar tp dom finite tdom dom dom pair tp tenv represents system regular equations necessarily canonical form may complex fresh variable tdom important observe definition tenv system defines contractive functional tree see dom dom ta te predicate reach denotes variables reachable free variables applying equations formally page reach reach tdom tdom reach reach reach nw reach reach reach definition solution system denote sol component solution tree system associated 
solution banach unique fixpoint theorem see 
system regular equations canonical form possible minimize number variables procedure analogous minimizing number states deterministic finite state automaton 
immediately provides algorithm deciding equality trees represented regular systems equations canonical form 
rest section describe maps types regular systems equations canonical form summarized diagram paths leading node tree commute 
type tvar tenv tree sol proposition recursive types regular systems pair maps atype 
ta sol ea proof prove result term tp 
lemma follows 
define induction structure gtp 
cases take appearing original type page case ab 
denote pl type tp form arity 
assume induction hypothesis ea eb 
require disjoint variables appearing original consistent renaming performed 
system property sol sol sol sol ea sol eb tg follows easily induction hypothesis 
case ab 
course tg tg 
previous case assume ea eb system denote 
analogously denotes 
proceed induction prove tg sol 
difficulty arises ab 
order apply induction hypothesis needs lemma 
notation show instance sol sol 
see proof related fact gives main insights slightly simpler 
example procedure described proof 
consider base cases choosing names case proof obtain note equations system redundancy facilitates uniform treatment case 
definition regular systems recursive types define function type induction dom page ab tdom tdom undefined continuing example line equivalent original type established general proposition 
proposition commuting translations system equations component solution coincides tree expansion associated recursive type tp tenv 
sol ta abbreviate ta map satisfies conditions 


tdom 
tt te tdom 
tab 
ta ea ta proof show induction ta sol 
interesting case arises tdom sol sol sol tt tt order apply induction hypothesis complete case needs prove tt 
obtain show lemma canonical system type variables tt proceed induction depth path case analysis show tt case page case subcase tdom dom say 

ta 

tb np current path apply inductive hypothesis shorter path variables system show tt 
ii variables system show tt 
iii variables system show tt 
substitutivity operation tg td conclude ta tb 
subcase tdom dom say tt 
subcase tdom dom say tt tt subcase tdom dom tt tt conditions follow definition 
condition follows sol sol part 
condition follows prop 
part ta sol ea ta ea 
computational rules subtyping algorithm described section canonical sets equations described previous section equations interpreted linked data structures memory 
algorithm involves single set equations distinct roots representing types compared 
involves trail form records inclusions variables discovered algorithm progresses 
invocation algorithm parameters written judgment ab 
algorithm expressed ordinary procedure collection rules resembles prolog program 
typical rule written logical implication judgments page operationally means order determine holds invoke subroutines check hold 
general logical deduction system rules algorithm execution recovered reading rules backwards assumptions 
denote arbitrary variables denote variables domain finite set subtyping assumptions pairs type variables 
algorithm written follows assmp ts tss var aa bb ab ts initial judgment starts execution algorithm obey special condition expressing reasonable assumptions 
condition says initial type structures simple root variables denoting disjoint structures come play 
define vars vars dom judgment satisfies initiality condition equivalently initial goal iff decomposed tdom dom dom way canonical systems constructed fact starting initial goal expansions variables synchronized 
call execution algorithm situation variable dom vice versa covers cases may arise 
desires treat general systems equations may necessary introduce rules take account situations just expansion left right needed 
cases rules assmp ab abs la ta ta tdom ra 
note conceptually distinct uses rule assmp algorithm initial assumptions contained represent known inclusions type constants assumptions inserted computation come unfolding 
page generating execution tree goal ts algorithm consists applying inference rules backwards generating subgoals cases 
process completely determined establish assmp priority rules priority 
tree goals built way called execution tree 
rules applicable certain subgoal branch execution tree abandoned execution resumed subgoal subgoals exhausted 
termination execution tree finite 
observe assumption add type variables dom 
observe rule shrinks size current goal replacing subexpressions goal application rule enlarges bound depth execution tree order product sizes systems ea eb 
algorithm ordering execution tree succeeds leaves correspond application rules assmp var 
dually fails leaf unfulfilled goal rule applied 
write ts iff ts initial goal corresponding execution tree succeeds 
recursive types write testing type equality define alternatively directly define efficient type equality algorithm lines subtyping algorithm 
soundness completeness algorithm show subtyping algorithm described previous section sound complete respect infinite tree interpretation types 
algorithm precisely embodies intuition recursive types infinite trees 
prove soundness completeness non recursive types 
soundness derived observing successful execution algorithm input successful finite approximations input 
completeness proven examining failing execution tree concluding trees corresponding input different start 
lemma derived structural computational rules definition tenv algorithm ordering page weaken ts ss ss ts 
strengthen ss ts reach ts vars ts 
weaken ts reach ts dom ee dom dom ee ts 
strengthen ee ts reach ts dom ts 
proposition completeness non recursive types non recursive types proof 
show induction structure case 
eb 
take vars cases 
similar 
case 
case similar case 
case 
ea eb ea eb 
induction hypothesis 

take 
weaken note 
weaken 
applying conclude ea 
proposition soundness non recursive types non recursive types proof show induction structure page case 
assmp apply cases 
similar 
case 
assume step case 
similar case 
case 
second step ea eb ea eb 
contain reach dom 
simple analysis 
strengthen 
similarly 
strengthen 
induction hypothesis 
lemma uniformity btype 
proof sketch execution tree possible extract successful execution tree point assmp rule arbitrarily delayed repeating certain pattern computation 
example consider gives raise 
execution tree initial goal assmp es goal assmp replaced copy entire tree appropriately renamed 
time appropriately expanded 
assmp ev eu eu es eu page execution tree different initial goal originated problem equivalent original problem 
similar way execution tree transformed replacing assmp leaf leaf 
repeating process obtain execution tree arbitrarily large proposition soundness btype proof definition fin lemma faithfulness paths lead sol nil label skipping initial variables 
ab root execution tree terminating success failure leaves obtained rules 
node execution tree determines path root considering occurrences ignoring rules 
bound type variables ta lead tb lead 
proof induction depth execution tree 
proposition completeness btype proof show ta tb 
assumption execution tree contains failure node determining path lemma 
ta lead tb lead 
common path ta tb corresponding failure node 
table summarizes possible cases entry indicates failure rule applied algorithm 
applicable cases come 
fail fail fail assmp fail var fail fail fail fail fail algorithm corresponds situation trees inclusion relation 
page implementation order facilitate proofs representation data structures algorithms 
section show similar treatment concrete traditional representations 
computational rules converted straightforward practical algorithm method trails 
reflect closely actual implementations adopt additional rules assmp la ra described 
results algorithm discussed informally differs slightly treated formally additional rules needed systems equations taken canonical form 
member tp represented directed cyclic graph nodes uniquely labeled example memory addresses starting label 
corresponds cycle concretely informal programming notation store store partial functions labels nodes memory addresses memory locations 
graph label nat node bot top var tvar arrow rec label 
allocator transforms type graph structure alloc graph new label example dom 
denote bot store just bot 
alloc new bot alloc new top alloc tdom new var alloc ab alloc alloc new arrow alloc new alloc bot rec allocation done reserving new memory location allocating body binding occurrence storing rec node containing allocation back store bot recursion prevent returned new 
page path define partial access function returns node corresponding path graph skipping rec nodes gt tree section gt nil rec gt nil bot top var arrow gt rec gt arrow gt gt rec gt arrow gt gt show alloc correct initial state irrelevant 
proposition atp 

alloc gt ta proof sketch single extension extension single extension extension indicate arbitrary finite extension note 
alloc dom extension gt gt 
obtain proposition need prove stronger statement atp 

alloc 
gt ta gt proof induction hard case 
page implementation algorithm assumption set represented trail set label pairs 
task remembering pairs labels cyclic graphs jointly visited 
types produce graphs ab ab extends alg ab proceeds follows mimicking rules alg tr tr ok bot ok top ok var var ok arrow arrow alg tr alg tr rec rec alg trl rec rec alg trl rec rec alg trl fail alternative approach avoid rec nodes completely allocator construct direct loops graph 
leads algorithm trails kept pair nodes pair nodes rec node 
algorithm closer formulation rules algorithm practice produces shorter trails uses equivalent la ra rules described 
definition 
alloc alloc alg ok point possible mimic sections modulo la ra rules show iff checked cumbersome details 

typing rules section introduce certain number axioms rules type equality subtyping 
intended natural rules language subtyping specification subtyping algorithm language 
section studied subtyping algorithm see algorithm rules match perfectly relating trees 
page type equivalence rules say type contractive type variable occur free rewritten unfolding type shape write fact 
easy observe sufficient necessary condition enforce functional space tree ta atree ta denotes substitution tree occurrences ta 
suggests rule generalized larger calculus contract words types fixpoints functional equal contractive functionals unique fixpoints 
rule inspired standard proof technique bisimulation 
convenient identify section consider equivalence meaning derived congruence induced contract rule axioms 
complete axiomatization refl symm trans congr ab congr fold unfold contract proposition soundness equivalence rules trees ta tb proof immediate previous considerations 
derived rules means contract fold unfold possible prove new interesting equivalences example st st contraction explicit free variable writing example 
page consider sr 
st st st st 
st st st 

consider 
reduction canonical form easy show recursive type provably equivalent type canonical form 
strategy described follows unfold get rid bind variable 
contraction reduce sequences 
reduce subtypes shape completeness equivalence rules strong connection regular trees recursive types show time recursive types tree expansion ta tb conclude show solve systems type equations 
introduce notion equational characterization type characterize type system type equations 
equational characterizations prove completeness theorem 
section notation 
free variables write substitution particular emphasizes superset free variables lemma system equations solution iterated elimination system equations variables solution congruence induced axiom fold unfold 

proof induction case 
equation just take 
case 
equations take 
consider system equations inductive hypothesis solution take check solution original system 
lemma system contractive equations unique solution assume sets types related systems equations tj page proof induction case 

consider context contract case 
consider th equation 
fold unfold contract 
take 
construct system size check solutions 
inductive hypothesis 
congruence obtain definition node context pl see proof type form arity 
node contexts provide convenient meta notation nodes children type variables 
example type denoted node context redundantly type 
note node context contractive prefixed occur type 
definition type atype equationally characterized eq 
char 
types node contexts 
equation system reachable variable reachable variables see 
equation reachable reachable variables 
lemma building equational characterization term atype equational characterization equations reachable 
proof construction basically 
prove induction structure term tp equationally characterized 
lemma follows invariance equational characterization modulo provable equivalence 
lemma assume ta tb ta tb page proof soundness ta tp tb tq 
ta tb definition theorem completeness type equivalence rules ta tb proof idea proof follows ta tb produce corresponding equational characterizations say ec ec 
collapse equivalent equations derive new equational characterization ec 
solutions smaller system associated ec replicated produce solutions systems associated ec ec 
apply twice lemma uniqueness solutions transitivity conclude ta tb lemma equationally characterized equations reachable ones 
generate sequence pairs equivalence classes respectively 
shall invariant ta ta tb tb start pair 
step consider pairs indicate depending similarly lemma ta tb 
ta tb add pairs way respecting invariant done replace pairs replace pair replace pair add new pair 
list pairs longer changes 
process terminates pairs consider 
process produces partitions size kn km total partitions equations reachable ones 
partitions determine functions partitions define system equations turn equivalent systems 
page need argue proper definition example show happens construction 
similarly possible conflicts 
show facts investigate properties start pair 
qj th th equations respective systems 
property pair considered process pairs added list 

saying 
th th equations system 
property 
consider pairs considered process pairs added list 
similarly 

saying 
similarly 
conclude similarly lemma construct solution system obtain 
appropriately replicated satisfy system lemma similarly satisfy system transitivity 
constructive proof see differs important point addition deal equivalence classes types 
example example arising discussion mario coppo consider types tt tt page ta tb note single context prove equivalent contract rule 
find third type independently provably equal contract obtain transitivity 
find instantiate proof 
start equational characterizations aa bb provable fold unfold starting list match equations involves equating pairs obtaining obtaining 
matching newly inserted pairs modify situation reached termination partitions associated system equation generate solution system tt verify solves systems proof constructed lemma simply unfolding contract 
similarly transitivity subtyping rules clear define rule subtyping recursive types sufficiently powerful 
particular observe computational rule section apparent logical meaning premise valid classical reading entailment relation 
introduce rule soundness clear 
section show conjunction type equivalence rules leads subtyping system complete respect tree ordering 
page denote set subtyping assumptions type variables 
write subtype judgment ab 
define formal system deriving kind judgments follows congruence eq ab trans ab bg ag assmp ts ts ab ts ab say derive ab 
rule proposed specification amber programming language attempt define theory subtyping recursive types 
proposition soundness rule ordering tree ordering proof prove general statement ab fv proof goes induction length derivation interesting cases arise eq 
brevity write lists form free case ts ab induction hypothesis fv 
define applying induction hypothesis obtain choose sufficiently large examining occur 
definition recursive types shown page case eq ab congruence soundness preorder 
remarks easy observe prove system eq trans assumptions ts inserted applying rule respect pair positive occurrences may wonder rule suffices purposes ab monotonic monotonic monotonic iff occur negatively unfortunately prove inclusions involving negative occurrences tt careful defining occur negatively recursive types order ensure really monotonic example st monotonic true false st false false ab st false false false ab st monotonic conditions possible show rule provable system 
completeness subtyping rules 
proving completeness subtyping rules tree ordering helpful go algorithm 
obvious approach extracting proof successful execution tree complicated lack correspondence computational rule rule applied repeatedly variable applied 
may wonder possible rearrange regular systems preserving type equivalence execution expand twice variable means 
naively corresponds controlled unfolding recursive types corresponding appear time visit trees 
example prove tt page unfold type note unfolding fold unfold rule 
ets see say successful execution tree initial goal ets expansion property iff true tdom path execution tree expanded node 
follows expansion variable inserted unique way pair assumptions pairwise distinct 
consider nodes path pairwise distinct consider node assmp node path pairwise distinct 
lemma putting recursions lockstep ets sol sol sol sol satisfies expansion property 
proof initial goal ets related successful execution tree build new judgment properties hold initial goal 
sol sol sol sol 
execution tree equal ets modulo variable renaming 
ru satisfies expansion property 
build execution tree ets 
associate node tree couple negative branches fresh variables constraint assumption leaf ts associate pair variables node assumption ts introduced 
generate cases case 
say situation eb ets pair variables associated node add equations fresh variables variables reachable system reach dom 
case 
analogous 
case var 
say situation eaa ets pair variables associated node add pair equations case 
say situation ts es ts ts page fresh variables variables associated node inessential generate equations case assmp 
say situation ets abs 
pair variables associated node add pair equations case assmp 
visit node apply rule assmp assumption added computation generate equation 
fact equations corresponding variables defined corresponding node assumption 
consider properties follows fresh variables 
place establishes relation say variables reachable reachable general situation variable may correspond variables prove induction lowest level appearance execution tree implies sol sol 
construction step apply computational rule 
consequence constraint assignment fresh variables nodes 
example consider types ss 
types minimal form smallest types describe corresponding regular trees recursions lockstep need transform redundant forms order synchronize 
apply procedure described proof previous lemma 
assume types described canonical system 
describes successful execution tree associated initial goal assmp es es observe execution tree expansion property variable expanded twice 
start associating fresh variables node rules described proof 
describes rule applied node execution tree pair fresh variables associate node 
page assmp compute new type environment observe equation generated calculating 
equations needed variable reachable verify sol sol ss sol sol 
compute successful execution tree expansion property associated initial goal qr assmp qu qr qr qu qr qr qr lemma execution tree proof tree ets see execution tree expansion property proof proceed induction depth successful execution tree initial goal ets see 
depth measured number adjacent pairs nodes longest branch root 
inductive case subgoal converted initial goal depth order apply induction hypothesis 
case 
tree consists root goal initial single leaf assmp var 
application rule tdom terminal case ts 
subcase assmp 
ts ab abs 
definition tenv assmp abs ab 
conclude eq aa bs trans 
subcase 
ts 
conclude eq trans 
page subcase 
similar 
subcase var 
ts aa adom 
apply eq aa conclude eq trans 
case 
tree root child definition tenv dom ts ts ts ts initially focus subgoals depth ts consider goal intend subject induction hypothesis ts substitution fresh variables 
show goal initial 
ets initial vars dom dom dom tdom dom dom conclude vars ts dom dom dom dom dom possible dom dom dom similarly 
second tree execution subtree root tree execution tree root 
show induction length longest path tree build tree depth tree succeeds expands variables tree nodes exception expansion property tree 

proceed induction subgoal ts tree build subtree shape ts 
case assmp ts ets tss ts 
properties noted need consider cases pairwise distinct 
page tree ts ets taken ts ts ts successful assmp expansion 
longer depth 
pairwise distinct tree ts ts ets taken ts ts ts successful assmp expansion depth 
case expansion pairwise distinct 
tree shape ts ts ts ets 

tree chosen shape ts ts ts ts preserving success depth induction hypothesis 
expansion preserved induction hypothesis expands variables node tree expansion expanded assmp case situation distinct 
cases pose difficulties 
expansion case follows branches expansion defined path wise 
apply induction hypothesis obtaining ts st ss equivalences st ss eq trans ts similar argument ts es obtain ts ts tt ss ts example describe associate proof tree execution tree expansion property built repeatedly applying inductive proof just 
convenience rewrite execution tree assmp qu qr qr qu qr qr qr page proceeding root fall inductive case 
reapply procedure modified subgoals 
modified subgoal leads subcase 
second modified subgoal leads inductive case 
generate new modified subgoals modified subgoal leads subcase 
second modified subgoal leads subcase assmp 
build proof tree bottom proofs leaves just remains observe equivalences get back types started page theorem completeness subtyping rules proof completeness algorithm 
consider corresponding successful execution tree apply lockstep recursion lemma obtaining tree 
lemma extract new execution tree proof 
applying completeness rules type equivalence conclude 
derive eq trans 

model sketch main features model described see related complete uniform pers model 
partial equivalence relation models provide interpretation subtyping settheoretic containment relations 
addition structures interesting categorical properties particular cartesian closure interpretation second order quantification intersection see entail satisfying interpretation higher order typed calculi 
particular class pers considered preserves previous properties providing solution recursive domain equations equality 
result obtained application banach theorem uniqueness fixpoint contractive operator complete metric space 
realizability structure consider functor dd defined category complete partial orders cpo projection pairs 
cpo collection atomic values coalesced sum 
morphism part standard 
cpo initial fixpoint functor colimit diagram initial object cpo element uniquely determined projection pairs projection pair ed denotes usual join 
cpo projected means projection pairs 
operation application defined usual fd 
complete uniform pers complete uniform henceforth iff element cpo xa directed xa term suggested abadi plotkin 
page 
consider full subcategory complete uniform pers morphisms defined usual ad fd dd 
ed 
define ideals see closeness max distance subtype interpretation say subtype iff ab :10.1.1.116.1298
easily shown correspond existence unique map category realized identity 
maps play role coercions type interpretation type environment map type variables 
type interpretation type environment written view interpretation subtyping interpretation type variables type constants naturally follows top mentioned cartesian closed category 
particular exponent defined follows 
fd ge interpretation arrow referred simple 
general object exp isomorphic simple interpretation enjoy categorical properties 
assume exp binary operator satisfying exp choice satisfying point view 
order complete interpretation need properties operator exp anti monotonicity 
set endowed metric complete metric space 
require behavior exp level determined value arguments level exp exp condition exponentiation operator contractive space satisfies property page exp exp turns definable type operator contractive identity admits fixpoint 
type interpretation contractive exponent exp completed follows ab exp lfp la lfp fixpoint 
soundness subtyping rule order sound interpretation rule convenient operator exp satisfies additional condition bb exp exp proviso summarize discussion follows 
assume binary operator exp satisfying properties exp exp exp bb exp exp simple interpretation defined provides example operator 
discussed provides example 
interpret types parametrically operator exp follows top ab exp lfp la lfp fixpoint 
conditions sufficient obtain soundness theorem 
write ab iff operator exp relative type interpretation 
write ab 
usual means 
ab 
theorem soundness tree ordering model types ab proof sketch define completion contains ab tree tree define interpretation completion set theoretic union interpretations syntactic approximants easy observe need fact see page kn 
definition 
words interested interpretation type th level construction unfold certain level just consider interpretation finite part associated tree expansion 
fact 
conclude ta vice versa observe ta ta tb 
proposition soundness rule ordering model ab ab 
proof soundness type equivalence rules observes sufficient necessary condition enforce functional space subtyping rules problem check soundness 
suppose hypothesis 
bot bot bot 
proved see type gg bot thesis 
completeness interpretation consider interpretation see isomorphic simple interpretation satisfies properties 
interpretation completeness theorem 
define embedding functional space embedding distinct symbol roughly speaking built selecting elements functions underlying model attaching label introduce label order distinguish functional type see lemma 
exercise try give complete rules pure version interpretation difficult exercise define complete system simple semantics 
case identifications tt take place 
page theory subtyping giving definition model naively reflects conditions soundness theorem look ad hoc completeness result prefer concentrate specific interpretation 
typical example characterize valid interpretation 
write ab iff type structure constructed just described equivalently ab respect induced interpretation type environment order prove completeness theory elementary substructure ideals 
ideals just equivalence class closed standard operations 
consider type simple interpretation interpretation meaning essentially independent clearly case tree equivalence 
particular interpretation ab plays role supertype functional types add subtyping system axiom 
denote formal derivability new system 
write iff ab 
examining possible combinations rules axioms turns relation collection non recursive types preorder shows transitive rule derived case analysis 
extend preorder recursive types defining ordering trees iff 

define iff ta tb 
lemma recursive type type environment 
ta type variable free top top 
proof induction structure particular ta interpretation ta hypothesis interpretation solves equation definable operators forces atop 
lemma separation suppose algebraic cpo 
type environment matches element column row iff situation described corresponding intersection occurs page ab bb proof mentioned consider ideals subsets particular closure properties 
choose environment element flat cpo 
course ts interesting problem show case ab condition bb fact necessary 
observe pick consider constant map lx belongs ab hand lemma set empty contains compact element consider continuous function step evaluates elements greater equal 
function belongs ab note downward closure property ideals prove elements greater equal belong proposition completeness recursive types ab iff proof soundness follows discussion general soundness result 
showing completeness consider type structure type environment lemma 
want show ab 
observe relation invariant unfolding transformations types shape fix unfold types appears th level 
transform subtypes shape proceed induction show conditions table force remaining part concerned tree ordering simple analyze valid interpretation satisfying conditions theorem 
previous study suggests tree ordering close model ordering example decision algorithm discuss section easily adapted 
page 
coercions coercions subtyping closely related topics see example 
show standard coercions types ab definable extension basic calculus 
interpreted saying subtyping add expressive power calculus convenience 
show coercions implicit calculus subsumption automatically synthesized 
fact related algorithm inferring minimum type term 
definability 
section show associate successful execution tree term denotation model coercion unique map corresponding types realized identity 
building term 
show consider types tree equivalence initial goal ts ets term ts free variables type sake readability type labels bound variables fold unfold constants omitted 
recall possible define fixpoint combinator follows lf aa lx ta unfold fold lx ta unfold aa proceed induction structure execution tree see 
refer properties translation case assmp ts case lx 
lx 
case lx 
lx 
case var lx aa aa 
case lf ab lx ab 
induction hypothesis bb case induction hypothesis ts ts type term ly ts 
similar fashion associate term proof judgment gab system difficulty arises rule 
suppose inductively built term ts possible transform term term associated rule defined lx ly 
fold unfold page proposition coercions definable type suppose term associated execution tree 
denotation term model unique coercion map interpretation interpretation proof 
term interpretation explicitly see sketch idea proof 
place need facts interpretation terms erasing type information constants fold unfold typed term obtain untyped term er 
denote untyped terms 
basic property interpretations interpretation er gives representative equivalence class corresponds interpretation shortly refer fact saying er realizer 
showing interpretation coercion means proving identity map id realizer equivalently id er equivalent ab 
note sake readability simply refer syntactic objects really intend speak denotations model 
realizer element fix functionality lg 

order prove theorem induction structure execution tree needs generalize somewhat 
place observes execution tree ets assmp interpretation associated term ts coercion ts induction go case term really depends assumption variable 
observe enjoys property 
suppose rule applied 
construction assume term functional coercions coercions 
show lx coercion 
observe rule rule 
term structure lf ly 
observe realizer lx lx lf ly realizer 
show realizer equivalent id type structure ab ab exp 
type complete show equivalent id appropriate type 
need denote approximation th level 
observes id id follows easily structure assumption 

id implies id page inference calculus section 
term possibly typeable interested problem determining typed modulo insertion appropriate coercions 
refer problem coercion inference 
define simple algorithm term succeeds exactly typeable modulo insertion coercions 
case algorithm returns type types assigned similar problem solved second order lambda calculus records second order lambda calculus including form bounded quantification 
results rely structural properties subtype relation stated case proposition 
notation 
section shorthands ta tb ta tb 
typing modulo coercions formalize idea typing modulo coercions ways subsumption 
add typing system rule tree order version fin referred subsumption sub denote formal derivability new system sub 
explicit coercions 
extend term language collection constants types add typing system rule denote formal derivability new system denote corresponding term language denote er mnemonic erase coercions obvious function takes term erases constants returns term rules justified finitary axiomatization section 
note systems fold unfold terms redundant 
definition coercion inference define inductively structure term function ci fail ci coercion inference fails returns typed term er clauses fold unfold priority clause apl 
var ci abs ci lx ci lx ci fail apl ci mn ci ci specification determines class algorithms suffices purposes 
page ab ab ci ci ci ci fail fail fold ci fold ci fold ci fail unfold ci unfold ci unfold ci fail clearly ci define inference algorithm sub just consider type term synthesized ci 
prove algorithm computes minimal type term 
achieve result need simple properties 
proposition term sub iff er 
ci er ci proof explicit coercion corresponds application subsumption vice versa 
induction definition ci 
proposition recursive types 
proof rewritten unfolding equivalent type shape definition tree ordering hypothesis lead simple case analysis 
analogous 
theorem terms type term sub implies ci proof induction structure meta notation ca ca virtue may equivalently assume existence typed term er page observe crucial role property proving surprising fact algorithm complete sense just stated 
case er hand ci case 
er lx lx er 
induction hypothesis ci definition 
ci lx ab 
note ab definition implies case done ab case implies ab case 
er er induction hypothesis ci follows case ci done 
second ci 
observe case fold 
er fold fold er induction hypothesis ci 
definition ci fold case unfold 
analogous 
remarks think substituting explicit coercions definable coercions constructed section 
resulting term typeable extension calculus section including rule recall rule soundly interpreted model 
observe general possible typed terms type erase coercions map assigns term er er receive interpretation model 
appealing aspect semantic approach interpretation subtyping hard coherence problems see simply disappear recalling uniqueness coercion model 
trivial example term typed type system subsumption system described sub ts lx 
ly ts page 
subtyping relation infinite trees central concept 
experience relation arisen naturally giving insights valid certain models behavior amber implementation 
fact shown relation characterize sound complete theories certain class models simply efficiently implemented 
shown soundness completeness certain rules definability coercions calculus modulo strengthening notion type equality 
observed process inferring coercions minimal types automated 
consider problem extension results 
notions tree expansion finite approximation section easily adapted larger languages order type constructors products sums records variants higher order type constructors second order universal quantification 
important point tree resulting expansion regular 
assumption possible adapt algorithms rules obtain results soundness completeness sections 
caution necessary extensions bounded quantification systems undecidable 
relationship tree ordering model expect extension soundness theorem straightforward 
hand expect technical problems completeness theorem introducing higher order type constructors second order universal quantification 
particular case clear extend separation lemma 
result definability coercions obtained calculi records variants bounded quantification recursion 
reassuring result shows subtyping theory harmony calculus 
fact terms type clear impact implementation typechecker 
appears desirable property automatic treatment coercions 
result state art clearly relies structural properties subtyping relation 
observe challenging extensions arise dealing non ground collections subtyping assumptions see 
case remains done 

acknowledgments martn abadi comments early draft referees efforts improving presentation 
page amadio recursion realizability structures information computation pp 
preliminary version appeared tr dipartimento di informatica universit di pisa 
amadio formal theories inheritance typed functional languages tr dipartimento di informatica universit di pisa 
amadio typed equivalence type assignment type containment proc 
conditional typed rewriting systems eds 
kaplan okada lecture notes computer science vol 
springer verlag 
arnold nivat metric space infinite trees 
algebraic topological properties fundamenta informaticae iii pp 
breazu tannen coquand gunter scedrov inheritance implicit coercion information computation vol pp 
breazu tannen gunter scedrov denotational semantics subtyping recursive types report ms cis logic computation dept computer information science university pennsylvania 
bruce longo modest model records inheritance bounded quantification information computation vol pp 
canning cook hill mitchell bounded polymorphism object oriented programming proc 
functional programming computer architecture 
cardelli wegner understanding types data abstraction polymorphism computing surveys pp december 
cardelli amber combinators functional programming languages proc 
th summer school le val france may 
lecture notes computer science vol 
springer verlag 
cardelli semantics multiple inheritance info comp pp preliminary version lncs springer verlag :10.1.1.116.1298
cardelli typeful programming formal description programming concepts neuhold paul eds pp springer verlag 
cardelli longo semantic basis quest journal functional programming vol part pp cambridge university press oct 
page coppo type inference recursive types syntax semantics info comp pp 
cook denotational semantics inheritance ph thesis brown university 
courcelle fundamental properties infinite trees theoretical computer science pp 
courcelle equivalence transformation regular systems applications recursive program schemes grammars theoretical computer science pp 
curien ghelli coherence subsumption minimum typing typechecking mathematical structures computer science vol pp 
hyland small complete category annals pure applied logic pp 
macqueen plotkin sethi ideal model recursive polymorphic types info comp 
milner complete inference system class regular behaviours journal computer system science pp 

nelson ed systems programming modula prentice hall 
park concurrency automata infinite sequences proc 
th gi conference lecture notes computer science vol 
pp 
springer verlag 
pierce bounded quantification undecidable proc acm symposium principles programming languages pp 
salomaa complete systems algebra regular events journal acm 
scott continuous lattices toposes algebraic geometry logic lawvere ed lecture notes mathematics pp springer verlag 
scott data types lattices siam computing pp 
van wijngaarden ed revised report algorithmic language algol pp springer verlag 
wadsworth relation computational denotational properties scott models lambda calculus siam computing pp 
