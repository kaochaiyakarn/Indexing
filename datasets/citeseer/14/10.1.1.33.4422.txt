programming partition aware network applications babao glu alberto bartoli dini universit di bologna zamboni bologna italy babaoglu cs unibo www home page www cs unibo babaoglu universit di trieste trieste italy univ trieste www home page uts univ trieste universit di pisa pisa italy dini iet unipi www home page www iet unipi dini 
consider problem developing reliable applications deployed partitionable asynchronous distributed systems 
task dicult guaranteeing consistency shared state despite asynchrony failures recoveries including formation merging partitions 
view synchrony process groups powerful paradigm signi cantly simplify reasoning asynchrony failures insucient coping recoveries merging partitions repairs 
rst give characterization shared state management partitionable asynchronous distributed systems show views enriched convey structural historical information relevant group activity 
resulting paradigm called enriched view synchrony implemented eciently leads simple programming methodology solving shared state management presence partitions 
distributed computing rapidly principal paradigm providing critical services everyday life deployment networking technologies accelerate trend 
large geographic extent due increased globalization unpredictability loads imposed users contribute asynchronous characterization systems sense communication delays relative computing speeds bounded certainty 
banking nance electronic commerce medical systems telecommunications industrial process control collaborative just sectors increasingly rely large scale asynchronous distributed systems computing infrastructure 
distributed applications deployed systems dicult reason develop 
principal di culty stems fact asynchronous distributed systems subject failures inability communicate attributed real cause destination may crashed may overloaded slow communication path may disconnected may experiencing long delays 
abstraction simplify reasoning implementation distributed applications view synchrony context process groups see chapter 
aspects view synchrony enable hide complexities due failures asynchrony 
hand cleanly describes failures recoveries form changes group view agreed connected members group 
hand view synchrony provides guarantees set messages delivered globally function view changes process observes locally 
permits components group reason globally solely local information 
partitions may result communication failures insidious characteristic large scale distributed systems 
informally de ne partitionable system admitting multiple views group exist concurrently 
systems membership group may change dynamically due individual process failures recoveries due subsets correct processes disconnected re connecting 
contrast primary partition group membership model view group active time 
partitionable group membership service allows collection mutually communicating processes install view group lets application decide progress 
chapter consider programming reliable applications partitionable asynchronous distributed systems process groups view synchrony 
group members maintain state information distributed replicated 
view synchrony great aid guaranteeing consistency information failures recoveries disconnections technical problems remain need solved application programmer 
rst give novel characterization shared state problems show view synchrony gives little support cope 
burden solving shared state problems falls application programmer detracts simplicity elegance view synchrony 
propose extension basic model including structural historical information views form subviews subview sets manipulated processes re ect application state preserved automatically view changes system 
extension called enriched view synchrony ers simple programming methodology programming reliable services partitionable asynchronous systems 
illustrate methodology detailed examples 
abstraction rst introduced isis system known virtual synchrony 
prefer term associated model group membership excludes possibility progress multiple concurrent partitions 
system model view synchrony system collection processes executing potentially remote sites communicate network 
result failures processes may crash communication network may partition 
crashes cause processes halt prematurely 
crashed processes may rejoin computation recovery partitions may merge repairs 
consider asynchronous system possible place bounds communication delays relative speeds processes 
assume system considered admits failure detector weak properties shown sucient solve view synchrony see chapter 
view synchrony implements notion process group provides reliable multicast basic communication primitive 
processes want participate common computation join named group 
terminate participation leaving group 
member group processes communicate reliable multicasts 
view synchrony includes membership service provides consistent information form views regarding components group currently mutually communicate 
view synchrony abstracts away process communication failures real due false suspicions delivering group members view change events collectively agreed 
events mcast denote multicast message delivery message view change respectively 
process view synchrony installs new views events de ne totally ordered sequence 
view installed sequence process called current view process 
events said occur view happens current time 
views called consecutive exists process common views view installed view called successor exists sequence views leading adjacent pair sequence consecutive views 
possible views installed di erent processes incomparable respect successor relation case called concurrent concurrent views allow model diverging views group membership due partitions 
discussion formal speci cation view synchrony babao glu chapter set properties view installations message deliveries 
essence view synchrony captured informally property states group membership reliable multicast services interact processes survive view consecutive view delivered set messages view respect relative order messages delivered consecutive views assume messages multicast process delivered order sent 
turns message ordering guarantees stronger fifo property may help solving preventing shared state problems 
membership service chapter guarantees view coherency property property gm 
correct process installs view processes compose view install eventually installs immediate successor 
ii processes initially install view installs immediate successor eventually installs immediate successor crashes 
iii process installs view immediate successor view processes survive view previously installed shall replace property stronger property gm 
correct process installs view containing process installs crashes 
ii iii gm 
words property gm excludes possibility views installed correct members implies pair concurrent views empty intersection 
resulting semantics membership service called strong partial 
assume semantics simpli es discussion examples 
shall see results including enriched view synchrony programming paradigm remain valid original weaker property gm 
aside membership services strong partial semantics considered undesirable known non blocking implementations 
shared state problem application distributed computation performed group processes run top view synchrony 
loss generality consider applications structured single group 
involvement process application begins joins corresponding group ends leaves group view synchrony primitives join leave respectively process local state part may permanent survive crashes 
consider class applications implement objects object oriented paradigm object instance data type encapsulating internal state exporting clients interface de ned set external operations informally semantics data type may de ned invariants internal state 
group implementation object certain type seen simulating logical internal state global state distributed group members 
turn requires correct coordinated interaction group members invariants remain valid global state 
determines invariants data type implements related interactions satisfy scope chapter 
assume tasks achieved group implementation object static membership 
words group experience view changes external operations transform global state invariants continue satis ed 
complicates programming task possibility view changes external operations due events failures recoveries joins leaves 
concentrate aspect programming job clearly object remain correct despite view changes operations implementation restore truth invariants global state violated 
achieve application relies set internal operations visible object implementor part external interface 
group member may perform external operations perform internal operations depends general local state current view composition speci application considered 
model factors means executing modes group members 
time group member modes said normal mode mode brevity execute external operations said reduced mode mode perform possibly empty subset external operations nally group member said executing settling mode mode check global state necessary reconstruct new invariants satis ed executing proper internal operations 
call reconciliation necessary group members shared state problem 
may classify instances problem categories call state transfer state creation state merging simplicity shall introduce categories informally means examples 
rigorous treatment topic analysis relationship issues existing implementations view synchrony 
consider group processes implements les external operations read write 
increased availability reduced latency le partially fully replicated group 
informally correctness criteria object stated follows respect write operations replicated object behave exactly copy le respect read operations acceptable return available data may stale missing writes 
possible implementation object associate replica le vote de ne quorum collection votes obtained concurrent view 
suppose initially group members belong view case processes clearly mode perform read write operations 
suppose splits concurrent views de nes quorum 
view conducive satisfying write operations risk violating invariant 
members mode perform subset external operations read operation 
suppose nally merge view de nes quorum 
view restores conditions related connectivity performing external operations 
processes performing external operations soon replica re ect updates applied le 
processes mode execute proper internal operation 
particular process compare local state local state process possibly modify consequence comparison 
call state transfer particular instance shared state problem 
signi cant scenario application quorum view merge immediately splits concurrent views de nes quorum 
merge form quorum view situation re ects di erent form shared state problem process knows local replica upto date 
instance consider process point view write operations executed concurrently existence processes reason exactly 
call kind shared state problem state creation global state le reconstructed scratch 
case process compare state replica processes view possibly modify result comparison 
situation members view just recovered crash total failure essentially identical 
identifying local state recreation may require determining process fail 
consider di erent application group implementing database single look query interface 
performance reasons database fully replicated group query performed parallel group members responsible portion database 
correctness criterion requires look ups replicated database return exactly results non replicated case 
particular entire database searched reporting value looked exist 
example external operation look performed view 
mode exist 
event causing view change results transition mode order rede ne division responsibility portions database searched members group 
inconsistency global state information result reducing eciency compromising correctness 
example consider view splits successor views view change requires redistribution responsibility members resulting view 
portion database charge processes searched course compromise correctness look operations carried similar reasoning suppose merge view case redistribution database view members necessary 
pair processes coming responsibility portions completely partially overlapping 
carrying query portions searched multiple times negative ects look eciency 
example shows global state reconstruction takes place processes continued serving external operations independently concurrent partitions gather conditions leading partition repaired 
application speci computation performed de ning new global state reconciles divergence may taken place 
reconciliation activity corresponds third form shared state problem call state merging depending speci application state merging problem state transfer problem may 
state merging problem arise applications structured primary partition paradigm applications concurrent views execute external operations 
general process delivers view change process determine shared state problem needs solved 
information provided view synchrony typically sucient classifying shared state problem views de ned view synchrony structures contain information regarding past history processes 
example suppose process transition mode mode delivery 
reasoning composition view draw shared state problem solved able distinguish state transfer state creation problem information processes mode 
furthermore view synchrony ers limited support solving shared state problem programming related internal operation 
hand process determine role processes view respect shared state problem 
example solve state transfer problem know processes todate state 
solve state merging problem know processes state 
processes obtain information additional protocols typically complex costly 
hand instance shared state problem may interrupt execution external operation overlap instance shared state problem interrupt internal operation 
clearly asynchrony occurrence shared state problem group activity source signi cant complexity may obscure conceptual simplicity elegance view synchrony 
ectively attacking problems depends semantics application programming skills 
enriched view synchrony section novel extension view synchrony aimed simplifying reasoning shared state problems 
extension called enriched view synchrony evs requires minor modi cations view synchrony run time support implemented eciently 
cited contains comparison evs proposed extensions basic view synchrony model formal speci cation evs 
speci cation terms membership service concurrent views overlap easily transformed quasi strong partial service 
ev ev ev ev ev ev ev ev fig 

basic features enriched view synchrony model 
views subviews indicated respectively thick thin dashed frames 
simplicity sv sets contain single subview traced dashed frames 
arrows indicate view changes 
solid arrows change composition view view change dashed arrows change structure view 
basic properties enriched view synchrony proposed extension view synchrony notions subviews subview sets sv sets short 
just views subviews sets process names exist view 
view constructed subview 
process belongs exactly subview 
words subviews overlap span view boundaries 
subviews view grouped sv sets subview belongs exactly sv set 
view subviews sv sets split merge application control described 
consecutive views processes common subview sv set remain subview sv set installation example depicted fig 
illustrates properties 
partition causes view ev split concurrent views ev ev partition repaired part concurrent views merge form view ev note partition divides processes ev ev ev view black processes remain single subview 
merged view ev maintains structure previous views respect subviews sv sets 
informally subviews permit reasoning processes belonged view installation new view 
subview sets hand applications mark processes involved global activity time view change interrupted new processes entering view 
sv sets subviews process names view form tree structure corresponding properly nested sets view contains sv sets sv sets contain subviews subviews contain process names 
case single containing single subview containing processes degenerates traditional view abstraction 
system attaches meaning subviews sv sets 
simply maintains structuring information behalf applications 
distinguishes subviews sv sets views fact composition grow application arbitrary times 
example process simply appear subview recovery merger partition 
rst appear subview application decides may admitted existing subview 
views failures may cause subview sv set compositions shrink asynchronously respect application times view changes 
fig 
partition ev causes subview shrink views ev ev merge ev processes di erent subviews sv sets ev ev continue belong di erent subviews sv sets ev subviews sv sets may merge response application invoked primitives described 
aspect evs subviews sv sets expand synchronously respect application distinguishes traditional view synchrony 
extended view synchrony service delivers processes messages enriched views views short include sv set subview structure view 
traditional view changes correspond view changes change set processes making view 
view membership remains unaltered view change events may provoked applications requesting mergers subviews sv sets 
process rst joins group appears new view new sv set containing new subview containing process 
initial creation subviews sv sets may modi ed application calls augment usual view synchrony interface sv sv set list create new sv set union sv sets sv set list sv set sv set list belong current view ignored 
sv list create new subview union subviews sv list resulting subview belongs sv set invoking process 
subview sv list belong sv set invoking process ignored 
example fig 
view change ev ev due call merging sv sets containing single subview 
change ev ev due call merging subviews newly created sv set 
note view changes correspond scenario failures occur composition view remains unchanged structure subviews sv sets view change response application invoked calls 
extended service maintains semantics view synchrony regarding view changes message deliveries exactly described appendix respect view changes additional properties guaranteed state informally property total order 
view change events view consecutive view change events totally ordered processes view 
property causal order 
view change events de ne consistent cuts computation 
words causality relations message multicasts view changes preserved 
property structure 
subview sv set structures preserved view changes 
words processes belong subview sv set view remain subview sv set successor view 
processes belong subview sv set view remain di erent subviews sv sets successor view 
structuring applications enriched view synchrony proposed extension view synchrony presents opportunity systematic simpli ed solutions shared state problems 
enhances global reasoning achieved local information view changes simpli es handling asynchrony view synchrony run time support application 
terms application model chapter structure application methodology 
external operations performed single subview di erent subviews 

internal operations performed subviews belonging sv set 
successful completion internal operation subviews sv set merged single 
follows existence multiple sv sets view signals necessity solving certain instance shared state problem 
existence multiple subviews sv set signals shared state problem instance progress sv set 
methodology illustrated fig 

initially process ev creates sv set containing subviews signaling internal operation progress 
resulting view change indicated dashed arrow 
internal operation progress partition merges view ev installed 
white process ev conclude solely local information processes partition ev engaged internal operation merge disturbed 
methodology simpli es greatly reasoning shared state problems information locally available processes 
note processes entering expanding view permitted participate computation progress time view change appear di erent subview sv set carrying external internal operations 
explicitly members order appropriate subviews sv sets expand 
structure property guarantees processes remain relevant subview sv set view changes surviving processes continue participate computation notion shared state 
example consider le object introduced section suppose implementation external operations involves management mutually exclusive write lock quorum view 
shared global state include identities lock manager current lock holder 
suppose process installs view consecutive de nes quorum switches mode mode 
traditional view synchrony installing view draw local information fact de nes quorum 
distinguish scenarios quorum existed views prior state transfer problem exists ii shared state reconstructed time installed creation problem exists instance related internal operation interrupted iii quorum disappeared temporarily creation problem exists 
proposed extensions process draw relevant local reasoning view composition structure 
new view contains subview de nes quorum subview contain processes notion shared state date 
notice major advantage may contain processes just joined know obtain date shared state 
contrary contain subview de nes quorum cases ii iii distinguished controlling contains sv set de ning quorum 
asynchrony application run time support note operation executed set processes participating may shrink new view may delivered view synchrony arbitrary times composition subviews sv sets may grow application 
algorithms easily designed run view changes 
instance case ii process decide locally wait processes running creation protocol complete task disturbing copy 
example suppose availability replicated object le increased allowing writes view 
informally write takes place view de ning quorum permanent ect 
ects write performed non quorum view tentatively accepted remain pending 
permanent write occurred concurrent view 
discarded 
read date permanent values view de ning quorum 
possible implementation scheme consists letting tentative write create tentative copy associating tentative copy information re ecting partial ordering writes 
version vectors example information tentative write permanent promoting tentative copies plain copies disseminating quorum processes 
tentative write rolled back deleting tentative copies produced 
views merge form single view version vectors resulting view compared order detect concurrent writes 
tentative write discovered concurrent respect write rolled back 
write propagated members view version vectors updated accordingly 
resulting view de nes quorum write permanent 
example external operations read write performed view follows processes view composed single subview mode mode exist 
view change noti es merging views produces transition mode mode 
processes mode compare version vectors propagate copies necessary returning mode 
external operations performed view processes confront state merging problem 
suppose process installs view consecutive views 
stated earlier traditional view synchrony process draw local information de nes quorum 
evs may determine grouping clusters subviews clusters involved state merging sv sets composed multiple subviews 
programming example section details le object implementation described section previous section 
exercise useful illustrate programming methodology introduced previous section 
shall state machine model 
example may form basis state machine implementation important features informally summarized follows ability crashed servers stopping re starting service ii ability reconstruct state service total failure iii ability tolerate network partitions iv ability continue external operations internal operations view changes 
shall internal operations form independent speci example applicable large class quorum applications 
alternative implementations operations outlined discussed 
shall external operations implement le object state machine model 
external operations quite general modi ed easily kinds objects 
shall describe internal operations tailored object 
example section external operations executed concurrent views merging problem occur 
example pseudo code handling merging problem may 
example illustrates execute multiple merging operations parallel view feature complex obtain traditional view synchrony 
overview quorum sv set quorum subview respectively sv set subview include processes de ne quorum 
de nitions replicated le speci cation mode process determined follows 
process mode belongs quorum view composed subview mode belongs quorum view composed multiple subviews mode belong quorum view 
furthermore shared state problems may occur creation problem quorum subview disappears time state transfer problem subviews appear view quorum subview 
programming methodology external operations executed subviews 
particular writes executed quorum view composed subview reads executed subview returning possibly stale data 
reads guaranteed return current contents le executed quorum subview 
internal operations solving creation state transfer problem consistency le contents joining processes carried quorum sv set 
developing application methodology requires implementation components 
external operations 
internal operations 
computing process mode 
detecting shared state problem instances 
deciding internal operation interrupted 
achieve splitting process components lowlevel event manager high level event manager 
implements items analyzing views delivered process evs run time support 
passes view event enriched outcome analysis implements 
collects results analysis data structure called analysis triple mode problem phase enumerated types 
mode variable contains current mode process may mode mode mode 
problem variable describes shared state problem needs solved may creation 
phase variable describes process involved internal operation internal operation necessary started 
value speci es case value recorded 
shared state problem needs solved problem phase set 
crucial point observe constructs analysis basis local reasoning 
straightforward deduce methodology analysis produced analyzing ev identical processes belong subview ev 
starts internal operation receives view event augmented triple elds mode phase equal mode recorded respectively point clari ed 
value eld problem determines internal operation executed 
internal operations creating sv set includes relevant processes 
delivery corresponding view phase eld analysis switches 
internal operations proceed view changes long eld phase continues long composition sv set continues de ne quorum 
operation aborts 
notation algorithms expressed simple pseudo programming language supports multi threaded processes 
indentation levels implicitly delimit blocks 
statement wait condition synchronizes thread delivery event renders speci ed condition true 
delivery event thread executes code segment called handler speci ed event statement 
handler notation abort wait shorthand forcible termination procedure containing wait condition statement synchronized executing thread current event 
ancillary functions de ned 
function set takes argument returns set sv sets contained view 
function takes view sv set returns set subviews contained argument 
function comp takes view sv set subview argument returns set processes contained argument 
function quorum takes view sv set subview argument returns boolean value true corresponding set processes de nes quorum 
set current subview sv set name invoking process 
function elect returns process chosen deterministically set speci ed argument 
process composed initial threads corresponding 
starts internal operation spawning new thread 
general delivery event forwards event progress operations necessary starts internal operation 
sake brevity omit details concerning inter thread communication 
section shall give details internal operations carried solving state transfer state creation problems 
section shall complete description providing details external operations 
internal operations pseudo code fig 

denote executing process 
cases mode mode straightforward lines 
mode reasoning depends primarily belongs quorum subview lines lines 
case reasons set processes belong sv set subview variable line 
set empty sv set contains multiple subviews 
follows participating execution state transfer line 
need state transfer recorded line 
quorum subview rst determines quorum sv set line 
quorum sv set creation algorithm shall started line 
reasoning depends belongs quorum sv set 
implies participating execution internal operation lines 
implies internal operation executed participating lines 
pseudo code part implements creation fig 

spawns thread executing procedure creation receiving triple mode creation recorded 
summary state creation performed follows 
processes quorum view elect coordinator creates sv set encompassing entire view ii collects procedure ev quorum ev analysis mode comp comp ev analysis mode mode quorum fp comp set comp analysis mode analysis mode recorded ss set ev quorum ss set ss analysis mode recorded sv ev quorum sv analysis mode analysis mode creation analysis mode creation recorded pass ev event fig 

structure low level event management 
local states processes sv set iii decides new state multicasts sv set iv merges entire sv set single quorum subview 
correspondence steps pseudo code fig 
straightforward 
particular note primitives subview sv set merging invoked coordinator lines 
changes view composition execution algorithm handled simply lines 
particular algorithm aborted relevant sv set constitute quorum coordinator leaves quorum view creating sv set lines 
case instance creation algorithm spawned 
coordinator leaves quorum view creating sv set taken process lines 
shown number view changes nite view continues de ne quorum quorum subview eventually created 
procedure creation comp ev coord elect coord sv set ev wait ev analysis phase core creation procedure core creation transfer local state coord coord wait receipt local state select new state received local states transfer new state processes wait ack process set wait new state coord send ack coord wait ev comp comp set ev analysis mode mode analysis mode mode analysis phase abort thread comp ev coord coord elect abort wait call core creation fig 

state creation algorithm 
observations 
ev ev views corresponding respectively formation sv set merging single subview 
causal property evs guarantees process quorum subview delivered message pertinent external operations ev 
similarly instance coordinator delivered local states delivery ev 
pseudo code part implements state transfer fig 

operation started receiving triple mode recorded 
particular processes quorum subview execute procedure state transfer active execute state transfer passive 
processes quorum subview elect coordinator creates sv set encompassing entire view ii transfers state processes sv set quorum subview iii merges procedure state transfer active sv ev sv set coord elect comp coord sv wait ev analysis phase core active procedure core active coord transfer state processes wait ack process set wait ev comp comp set ev analysis mode mode analysis mode mode analysis phase abort thread analysis problem set coord comp coord elect comp abort wait call core active abort wait call creation procedure state transfer passive wait ev analysis phase receive state send ack wait ev analysis mode mode ev analysis mode mode analysis mode mode analysis phase abort thread analysis problem abort wait call creation fig 

state transfer algorithm 
upper part executed processes quorum subview lower part processes quorum subview 
sv set single subview 
processes quorum subview simply wait date state admission quorum subview 
observe processes joining quorum view internal operation progress creation state transfer simply wait todate state admission quorum subview line fig 
lines fig 

algorithm exhibits similarities creation algorithm 
primitives subviews sv set merging invoked coordinator lines state transfer aborted coordinator leaves enlarging quorum sv set quorum sv set disappears lines coordinator leaving quorum view managed electing new lines 
process executing state transfer algorithm outside quorum subview 
shown number view changes nite eventually belong quorum subview view de ne quorum 
ev denote view corresponding state transfer 
delivery ev lets processes quorum view switch mode resume servicing external operations 
causal property evs guarantees messages related new external operations may delivered ev 
external operations section complete presentation providing details external operations implement le object 
shall state machine replication model 
clearer state machine implementation tailored le object easily generalized 
overview 
implementation le object satisfy correctness criterion informally stated section 
respect write operations le object behave exactly copy read operation returns available data may date 
achieve goal impose restrictions way read write operations carried 
restrictions take form replica control policy concurrency control policy informally state 
replica control policy allow read operations served process 
hand process serves write operation correct process serve operation 
say process correct view belongs quorum subview view 
notice process serves read operation correct read operation returns date data 
concurrency control policy solve read write con icts guaranteeing mutually exclusive access local replica 
hand lines handle case quorum subview disappears sv set state transfer executed de nes quorum 
solve write write con icts requiring processes serve write operations serve order 
classical state machine model client multicasts operation invocation processes 
process carries request autonomously interacting processes responds 
example assume client willing access le sends operation invocation process closer example 
actual invocation performed process 
structuring allows simplify client code keep clients outside group 
furthermore multicast invocation processes processes quorum subview 
strategy clearly increases availability le object 
case read operation process selected client carries operation locally multicasting operation invocation remaining processes 
strategy clearly improves latency read operation 
process receives request client 
mode multicasts operation request subview 
mode mode bu er request goes back mode 
brevity shall omit obvious details related communication clients processes including possible bu ering client requests 
structuring replica control policy concurrency control policy satis ed requiring operation requests delivered correct processes total order ii process serves operation requests order delivered iii response sent back client operation performed quorum correct processes 
particular enforce constraint token scheme 
process maintains replica le object 
addition actual le content replica associated information kept permanent storage tentative content ii quorum subview counter iii monotonically increasing version number 
information necessary coping failures occurring execution write operations reconstructing state le object total failures 
tentative content contains null value tentative new version le 
say replica stable case tentative 
contents visible clients 
quorum subview counter identi es quorum view replica tentative see 
system initialization processes provided identical replicas particular having 
operation processing greatly simpli ed fact processes quorum subview identical replicas 
shall discuss section details creation state transfer satisfy assumption 
structured example execution write operation quorum subview shrink 
words process join quorum subview write operation progress 
satisfying requirement dicult decides schedule stance active internal operation 
shall see removing constraint particularly dicult 
algorithms 
implementation software modules write coordinator wc write participant wp token distribution td 
process enters quorum subview main thread spawns threads module 
threads exist long process continues belong quorum subview 
aborted process leaves quorum subview produces analysis mode eld equal mode analysis equal mode creation recorded 
simplicity shall omit code creates aborts threads 
write operation process multicasts operation request behalf client called ordinator 
processes execute request called participants module wc implements ordinator behavior module wp implements participant behavior 
module td implements token distribution scheme totally orders operation requests 
thread executing write coordinator module wc responsible performing operation invocations behalf clients 
invocation performed invoking procedure write 
ordinator acquires token multicasts write request message participants including 
sets waiting messages 
receipt message participant implies participant updated le object 
having received message quorum participants ordinator multicasts write commit message releases token 
point ordinator return operation results client 
token requests directed distinguished process quorum subview token manager algorithm executed token manager part module td discussed 
variable wp module identi es token manager initialized entering quorum subview follows 
process enters quorum subview completion creation algorithm sets equal result deterministic function select applied composition quorum subview 
process enters quorum subview completion state transfer algorithm acquires value part state received state transfer 
leaves quorum subview participants determine identity new token manager re evaluating select 
case process requested received token resends outstanding request new token manager 
wp module shown 
variable qs cnt counts view changes delivered creation quorum subview 
variable incremented process delivers view change initialized entering quorum subview follows 
process enters quorum subview completion creation algorithm qs cnt set zero 
var pid boolean initial false procedure write args msg args cast msg procedure wait quorum members cast send trel procedure true send wait delivery message false ev comp select comp send fig 

state machine processing operation requests issued clients part write coordinator module wc 
process acquires initial value qs cnt part state received state transfer 
realized easily qs cnt kept identical processes quorum subview 
replica accessed auxiliary procedures shown brevity 
replica participant tentative 
determines tentative new value le object records value sets equal current value qs cnt 
replica stable previous value actual le content set incremented 
participant realises write operation progress receiving message 
replica tentative participant responds coordinator means message 
participant replica stable receiving message 
tentative replica may stable receiving 
var qs cnt integer writer msg initial msg initial procedure delivery message msg writer 
writer msg sender res msg args res send writer delivery message msg msg vn vn writer ev qs cnt qs cnt writer 
writer comp writer select comp writer spawn thread executes terminates send writer fig 

state machine write participant module wp 
example consider sequence events process multicasts message mp releases token ii message mp experiences high network delays way iii process receives mp soon initiates new write operation sending message iv arrives earlier mp 
case handles mp piggybacked ignore real mp 
similar scenarios possible assume multicast ordering stronger fifo 
participant delivers view change check write progress ordinator left quorum subview 
case new ordinator selected components quorum subview order terminate write operation 
election performed applying deterministic function select composition quorum subview 
participant sends message new ordinator sent previous coordinator 
doing new ordinator instructed level progress write operation 
module td tokens shown 
variable identi es member quorum subview acts token manager variable kept identical processes quorum subview managed analogous variable wc module 
token manager receives token request message token queues request depending token free 
token manager receives token release message trel outstanding token requests 
pending requests served fifo avoiding starvation 
view change requests originated processes current view removed queue 
current token holder leaves view token revoked process quorum subview created tentative copy le 
token inherited process complete progress write operation 
token manager discriminates cases basis value writer variable kept identical analogous variable module wp 
tailoring internal operations 
internal operations state transfer creation section purposefully left generic 
instance specify state exchanged processes rule deciding creation algorithm state selected 
tailoring operations le object just described accomplished follows 
state coordinator state transfer algorithm transfers process admitted quorum subview consists local replica values variables qs cnt 
joining process information updating replica initializing necessary variables modules td wc wp 
aside notice modifying modules processes enter quorum subview write operation progress exceedingly dicult 
essentially suces include value writer variable transferred state 
state process sends coordinator creation algorithm consists information associated local replica le content 
coordinator selects new state associated highest 
states correspond stable replicas selected 
tentative replica highest selected 
intuitively tentative replicas identical created order induced increasing 
follows replicas highest tentative created selected 
fact choice operated creation algorithm safe derived informal considerations 
denote set participants creation algorithm outs denote set composed var pid boolean initial true writer pid initial queue pid initial procedure pid false writer procedure release true writer procedure pid send procedure delivery message msg msg sender put msg sender delivery trel message get 
release delivery message msg writer msg sender ev writer 
writer comp writer select comp remove process comp writer 
release extract writer elseif comp select comp writer 
writer fig 

state machine token distribution module td 
remaining group members recall de nes quorum 
replica selected creation algorithm associated 
suppose stable 
process outs having stable replica process having stable replica tentative replica case selected 
suppose tentative 
creation algorithm possible tell process outs stable making stable safe write attempts certainly failed write operation initiated operation completed quorum processes quorum subview disappear 
course entire reasoning property write operations completed view time stronger property write operations initiated concurrent views 
property guaranteed strong partial semantics assumed membership service hold service speci ed chapter 
changes algorithms needed function service speci ed chapter 
shall come back issue section 
case state selected creation algorithm associated nonnull pending write completed resuming service ered clients 
accomplished instance requiring token manager acts coordinator write operation soon process enters quorum subview sets writer variable wp module equal variable wc process executes lines fig 
receiving coordinator client requests processed 
discussion 
consider system model processes may crash communication failures occur 
case state machine may complete operation respond client soon result server available 
scenario possible admit existence partitions 
consider process member quorum subview suppose delivers request message op related operation op args 
returned operation results client soon invariants state machine violated due view change quorum subview exclude composed members received op case operation executed re ected object state 
interesting observe wanted implement volatile object opposed permanent able survive total failures structuring remain unaltered 
case fact server carried operation suce declare operation completed quorum responses necessary 
reason fact example depends partitionable nature system possibility servers simultaneously crashing 
respect volatile objects solution partitionable systems single response suces declare operation completed obtained strengthening multicast semantics 
instance requiring atomicity message delivery respect partitions safe multicast 
disseminating operation requests safe multicasts guaranteed process quorum subview deliver request crashes 
coming back example delivers op conclude process quorum subview delivers op crashes 
execute operation described op respond client immediately 
similar reasoning constructed systems view group active systems partitionable 
case need uniform multicast 
solutions additional cost hidden run time support 
supporting stronger semantics required safe uniform multicast requires rounds perform application level 
state machine approach provides systematic framework implementing fault tolerant services 
example easily generalized kinds objects necessarily les 
fundamental systematic model primary backup approach 
case distinguished server primary responsible processing requests managing interaction clients 
processing request involves multicasting backup waiting replies state servers kept sync 
primary crash leave primary view group backups new primary 
modifying example primary backup approach quite simple 
essentially suces forward operation requests agreed process quorum subview act coordinator requests 
process identi ed way token manager example 
evs weaker group membership services far chapter considered view synchrony model strong partial membership service 
model pair concurrent views empty intersection 
property clearly eases programmer task process installing view consider possibility processes view installed di erent view 
unfortunately babao glu shown non blocking implementations strong partial group membership service impossible achieve partitionable asynchronous systems 
evs abstractions related programming methodology bound membership service strong partial property 
fact accommodated weaker view synchrony model described chapter allows existence concurrent views overlapping compositions 
evs retains power conceptual framework programming paradigm model 
course solutions problem implemented di erent membership services look di erently 
general point view algorithms developed strong partial membership service ported unchanged top weaker service 
programming methodology evs need changed 
respect examples apply unaltered membership service chapter 
essentially reason examples progress messages received 
instance messages received set processes form quorum 
words fact process belongs view taken proof installed taken receiving message sent necessary changes concern algorithms assumption concurrent quorum views exist 
assumption solution state creation problem 
creation creation procedure able distinguish uncompleted write operations see 
write operation uncompleted installed quorum stable replicas 
identifying uncompleted write operation necessary results write operation sent back client soon operation created quorum tentative replicas matter operation completes 
example performs identi cation observation uncompleted write operations initiated di erent quorum subviews 
quorum subviews totally ordered due strong partial property ordering sort uncompleted write operations 
quorum subview counter re ect total order existing quorum subviews write operations 
weaker view synchrony model possible anymore concurrent quorum views scheduled group membership service 
approaches possible manage problem 
approaches application writer exploit evs abstractions programming methodology 
approach write algorithm modi ed participants acknowledge reception messages ii write results sent back client quorum processes acknowledged reception message 
case creation algorithm remain unaltered 
alternative approach leaves algorithms write operation unaltered 
approach quorum replicas suce rebuild shared state object creation 
takes place replicas tentative replicas generated uncompleted writes initiated concurrent quorum subviews 
situation possible determine results sent client 
quorum subview created instance creation algorithm involving number replicas large determine set identical tentative replicas de nes quorum 
cope kind situations necessary modify creation procedure 
observe existence quorum sv set composed subviews necessarily indicate anymore activity rebuilding shared state progress 
creation procedure may fail select new state line 
case creation procedure terminate soon creating quorum subview 
new instance procedure shall executed soon quorum view composition changes 
sum presence quorum view composed subviews schedule state transfer problem subviews quorum subview 
schedules creation problem 
report new pseudo code brevity 
approaches embody di erent trade eciency availability 
rst approach allows quorum replicas progress 
expenses costly write 
hand second approach write operations implemented eciently 
object may unavailable total failure notwithstanding existence quorum view 
application designers adopt rst second approach depending application requirements write operation frequency probability quorum subviews disappears 
shared state problems state transfer creation merging issue applications reliability constraints 
particularly true partitionable systems internet multiple views group may exist concurrently 
view synchrony potential clean elegant programming abstraction elegance easily lost practice special provisions supporting shared state maintenance 
characterization shared state problems terms necessary conditions analysis related problems arise practical applications 
extension view synchrony called enriched view synchrony explicitly conceived simplify task shared state maintenance partition aware applications 
group views delivered processes enriched structural historical information relevant group activity 
information de ned application maintained run time support 
conjunction simple programming methodology local reasoning possible view changes greatly improved enriched view synchrony case expanding views 
process able infer algorithm shared state maintenance shall run progress view change 
case process infer type shared state problem processes need involved 
asynchrony run time support application may controlled sense shared state problems occur instants application 
turn simpli es entire application just parts responsible handling events trigger shared state problems 
methodology illustrated simple example extended large class applications quorum model 
acknowledgments supported part commission european communities esprit programme basic research project broadcast italian national research council italian dell universit della ricerca scienti ca tecnologica murst project design methodologies tools high performance systems distributed applications 
grateful ken birman comments early stages rachid guerraoui comments chapter 

amir moser melliar smith agarwal totem single ring ordering membership protocol acm trans 
comp 
sys 

babao glu bartoli dini replicated file management large scale distributed systems 
tel vit anyi eds distributed algorithms 
lecture notes computer science vol 

springer verlag 

babao glu inherent cost view synchronous communication 
raynal 
eds distributed algorithms 
lecture notes computer science vol 

springerverlag 

babao glu bartoli dini enriched view synchrony programming paradigm partitionable asynchronous distributed systems 
ieee trans 
comp 

birman cooper joseph marzullo kane schmuck wood isis system manual version 
department computer science cornell university 

birman virtual synchrony 
birman van renesse 
eds reliable distributed computing isis toolkit 
ieee computer society press 

chandra toueg unreliable failure detectors asynchronous systems 
proc 
th acm symp 
princ 
distr 
comp 


el abbadi skeen cristian ecient fault tolerant protocol replicated data management 
proc 
th acm symp 
princ 

syst 


el abbadi toueg maintaining availability partitioned replicated databases 
acm trans 

syst 


fischer lynch paterson impossibility distributed consensus faulty process 
journal acm 

herlihy wing linearizability correctness condition concurrent objects 
acm trans 
prog 
lang 
syst 

keidar dolev increasing resilience atomic commit additional cost 
proc 
th acm symp 
princ 

syst 


malki amir dolev kramer transis approach high availability cluster communication 
technical report cs institute computer science hebrew university jerusalem 

marzullo schneider toueg primary backup approach 
mullender 
ed 
distributed systems nd edition acm press 

satyanarayanan kistler kumar okasaki siegel steere coda highly available le system distributed workstation environment 
ieee trans 
comp 


schiper ricciardi virtually synchronous communication weak failure 
proc 
rd intern 
symp 
fault tolerant comp 


schiper ricciardi birman understanding partitions partition assumption proc 
th ieee workshop trends distr 
syst 


schiper uniform reliable multicast virtually synchronous environment 
proc th intern 
conf 
distr 
comp 
syst 


schiper primary partition virtually synchronous communication harder consensus 
tel vit anyi eds distributed algorithms 
lecture notes computer science vol 

springer verlag 

guerraoui schiper software replication fault tolerance 
ieee comp 


schneider implementing fault tolerant services state machine approach tutorial 
acm comp 
surveys 

skeen determining process fail 
acm trans 
comp 
syst 

