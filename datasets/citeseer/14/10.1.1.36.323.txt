dynamic reconfiguration corba applications rodriguez roberto ierusalimschy departamento de inform atica puc rio rio de janeiro brazil roberto inf puc rio br 
current support dynamic reconfiguration assumes component interfaces specify input output channels 
component models corba support client server architecture component interfaces describe offered services 
discusses interpreted language tool dynamic configuration distributed applications corba components 
describe luaorb system corba dynamic invocation interface dii dynamic skeleton interface dsi provides lua programs easy access corba servers allows servers dynamically modified 
luaorb lua console tool reconfiguration 
luaorb uses structural sub typing model correctly typed connections accepted 
discuss possible forms prescribing reconfiguration relation luaorb 
component programming receiving lot attention frequently considered successor object oriented programming 
fundamental point concept component separation interface implementation 
component necessary know interface implementations need general public 
allows client programs remain valid implementation invoked component substituted new version 
corba widely accepted component model open systems commercial academic implementations 
attention problem managing change corba applications 
need dynamically evolving applications corba increasingly apparent specially areas network management real time control systems 
fault tolerance dynamic integration newly available services important goals areas avoidance service interruption 
corba interfaces specified idl interface definition language specifications written idl typically compiled stubs client side skeleton programs server side 
modifications structure application client side implementation components server side require re compilation service interruption 
discuss interpreted language add flexibility corba programming 
set tools alternative dynamic mechanisms client server implementation discuss tools support dynamically evolving applications 
tools examples extension language lua binding corba called luaorb 
section define interpreted languages discuss advantages disadvantages 
describe lua luaorb section section show solve classic configuration problems 
section draw 
interpreted language adopt definition language said interpreted offers mechanism execution chunks code created dynamically words interpreter directly accessible language 
definition languages lisp lua tcl interpreted pascal java 
programs frequently developed environment installed configured different target environment 
configuration activity relates setting program variables ip addresses local directories server names appropriate values 
configuration may done environment variables simple text files system resource files 
programs complex configuration possibilities increase specially interface related issues 
programs allow menus created modified new operations macros defined 
support flexibility configuration times controlled full fledged programming language 
need fueled development extension languages tcl lua :10.1.1.45.2941
incorporation interpreter run time environment program configuration files contain list data options 
configuration file contain initialization routines expressive power available programming language conditionals loops abstractions 
preceding paragraphs term configuration sense tailoring application specific needs environments 
task different goals configuration distributed applications 
different points continuum complexity levels 
sense explore language lua proving useful extension configuration sequential applications tool configuration distributed applications 
context configuration applications fact interpreted languages allow changes take place need re compilation spe cially interesting allows distributed applications dynamically modified need service interruption 
interactivity offered interpreted language fits configuration requirements testing prototyping programmer console test components partial configurations directly avoiding need test stubs 
weaknesses generally associated interpreted languages efficiency robustness 
fact interpreted languages normally slower compiled counterparts factor uncommon 
component applications components may coded compiled efficient languages interpreted language acting flexible connection element 
role performance penalties interpretation impose may overruled time spent communication input output calls 
similarly robustness language evaluated context 
static verification certainly important ally development large software projects 
conventional programming languages pay price static typing loss polymorphism flexibility 
hand static typing available hand interpreted languages usually rely run time error checking mechanisms uninitialized variables dangling may useful program debugging 
case corba applications important emphasize corba component typically developed conventional statically typed language 
interpreted language glue components may result run time error attempt invoke method call method incorrect parameters 
explained section situation generate fallbacks lua ways similar exceptions may appropriately handled program flexibility 
luaorb luaorb binding corba language lua interpreted language developed puc rio 
lua extension language implemented library 
api easy call lua functions code easy register functions called lua code 
corba standard provides communication facilities applications distributed environment 
communication corba objects mediated object request broker orb 
client interact broker stubs dynamic invocation interface 
omg idl technology independent syntax describing object interfaces 
typically specifications written idl compiled client stubs called simply stubs server stubs called skeleton programs 
client program directly linked stub 
server program implement methods declared skeleton 
approach current language bindings java smalltalk requires clients recompiled time change server interface takes place time new type object server 
servers recompiled modification interface implementation 
corba architecture offers mechanisms allow programs circumvent need re compilation 
client side dynamic invocation interface dii generic facility invoking operation run time defined parameter list 
server side dynamic skeleton interface dsi interface writing object implementations compile time knowledge type object implementing 
dii dsi corba services trading naming services offer basic mechanisms support dynamic distributed object environment 
dynamic environments applications find incorporate new components run time 
components extended fly incorporate new functionality applications adapted fly component changes 
level flexibility important applications desktops operating systems network management tools cooperative applications 
corba allows discovery object type methods run time possible implement mechanisms dynamic typing 
interface repository ir offers support applications browse object types naming trader services offered corba address problem finding new objects system 
dii programmer access method call modes static stubs 
corba supports types calls synchronous stands traditional rpc semantics oneway allows client invoke method continue execution waiting completion deferred synchronous allows client continue execution immediately method call poll server result 
possibility available dii 
dii dsi trivial tasks involve querying constructing complex structures 
static typed languages automatic memory management program build dynamic call step step explicit calls create parameter list set parameter type value 
clear dii dsi interesting cases represents difficult task current existing support 
sections luaorb binding lua corba offers suitable support developing open applications allows management change corba application 
luaorb interacts lua official lua api implementation required changes language 
luaorb client binding lua dynamically typed language type checking done run time 
variables functions type declarations 
objects lua called tables classes object kind methods instance variables 
mapping lua corba tried respect flexibility lua 
way possible corba objects way lua objects 
corba objects accessed lua object generation stubs necessary interesting 
corba objects accessible lua need previous declarations dynamic typing 
achieve goal binding built dii 
luaorb uses proxies represent corba objects lua program 
proxy regular lua object uses fallbacks reflexive mechanism lua change default behavior 
lua program calls method proxy fallback intercepts call redirects luaorb binding 
luaorb dynamically maps parameters types lua idl actual invocation maps results back lua 
mapping parameter types done trying coerce lua values idl types vice versa result types 
mapping done dynamic type descriptions actual types lua arguments accessed lua api formal types method parameters accessed interface repository 
illustrate luaorb idl interface struct book string author string title interface foo boolean book boolean test long div long long create proxy distributed object implements foo interface function foo function optional second argument name specific instance interface specified parameter 
second parameter specified succeed server object name parameter 
function basically direct mapping equivalent function orb api 
proxy created services related object requested 
example methods foo interface called follows author title new book test foo div line creates object fields author title initialized strings 
second line calls add book method object foo colon lua operator method calls 
book argument call luaorb automatically tries convert idl structure book book correct fields correct types conversion succeeds luaorb signal error 
conversion works recursively list lua tables automatically converted array records instance 
dynamic nature type conversions allow changes idl interface affect uses lua reordering removing structure fields changes idl types similar representations lua short long array sequence 
type system emerges properties structural compatibility enforced 
mentioned previously dii allows mode invocation called deferred synchronous client triggers method polls completion 
server point view transparent invocation mode 
specify deferred synchronous call lua programmer simply prefixes method name deferred instance deferred method call returns handler retrieving method result 
deferred synchronous calls specially natural event driven programming 
setting interesting able define function called completion method 
supported luaorb completion event function takes parameters handler returned deferred synchronous method call function 
method completion function called method results parameters 
luaorb server binding server binding luaorb allows lua objects corba servers 
uses corba dynamic skeleton interface dsi 
basic idea dsi implement calls particular object call dynamic server invocations single upcall routine dynamic implementation routine dir 
routine responsible unmarshalling arguments dispatching call appropriate code 
frequent application dsi implement bridges different orbs 
context dynamic server acts proxy object orb 
similarly client binding luaorb uses proxies server binding reverses roles client side corba object lua object proxy server side lua object acts corba server represented proxy object 
object handles method requests original lua object dsi upcall routine 
call received upcall routine arguments converts appropriate lua values calls corresponding lua method converts back results lua corba 
conversions follow rules client binding opposite directions 
see simple example server written lua consider idl interface interface listener oneway void put long interface generator void listener generator object generates numbers random numbers instance number generates calls put method listener 
write listener object luaorb follows put function self print gen generator gen assignment create lua object single method called put 
create proxy generator set lua object listener 
luaorb detects formal parameter type idl listener actual argument lua object automatically creates proxy lua object enabling corba server 
luaorb offers idl interface remote server update interface readonly attribute object obj void string string interface instance corba intf create new instance dynamically extensible server client invokes method instance 
single parameter method interface definition interface repository 
instance retrieve information attributes methods new object 
new object returned attribute obj inside new object attribute fact proxy new lua object 
manager client invoke method install modify objects methods 
illustrate interface change example listener created remotely machine 
assume user created bindings interface repository ir remote server creates new object type listener server instance ir lookup listener creates new method called put put function self print gen generator gen obj sequence commands interactively issued simple luaorb console powerful tool interactive dynamic configuration 
access interface repository interface repository ir defined component orb provides dynamic access object interfaces 
ir corba object accessed method invocations 
general methods program allowing user instance browse available interfaces 
ir specially important dii dsi dynamic interfaces corba 
dii allows programs invoke corba servers precompiled stub 
order build dynamic invocations program possess information available methods parameters interface repository provides information 
server side dsi allows server handle requests precompiled skeleton 
correct signature requests obtained interface repository 
luaorb provides library called simplify access ir 
extensive lua data description facilities 
fallbacks reflects repository information lua objects operation objects automatically converted equivalent operation repository 
allows lua programmer manipulate repository information accessing regular lua objects 
reflexivity implemented allows queries repository updates 
possibility dynamically updating ir extends flexibility obtained luaorb 
allows manager client install new implementations existing interfaces unforeseen services server adding definitions interface repository 
configuration applications languages conic darwin interface component described terms input output channels 
darwin example component described terms communication objects provides roughly comparable input channels communication objects requires roughly comparable output channels 
approach allows specification different paradigms interaction processes 
instance filtering structures easily built components shown component filter provide left port int require right port int corba model interfaces described idl method signatures input output ports 
method signatures declare input output parameters optional return values 
method signature describes bidirectional flow information 
approaches different levels abstraction 
darwin interface component contains complete information communication component involved 
part communication activity component typically relates offered services may relate specific implementation 
example component implements parser may may communicate file server way stores temporary information 
corba offered services declared interface component known methods turn called component implementation purposes 
hand gives programmer control construction complete application 
hand mechanism supports existing services black boxes implementation programmer needs worry 
coupling service requirements service provisions building application case consists mainly decisions services 
cases need objects offer specific methods may part corba object interface 
object oriented programming important concept listener callback object 
specification object may define pass produced data consumer object register occurrence certain events registrar object 
cases communication part specification implementation interface object reflect existence communication partners instance providing methods defining partner languages darwin called architecture description languages 
reflects emphasis top approach support specification application structure tools offered translation specification module skeletons filled programmer 
component programming bottomup approach software development may appropriate 
goal need new application compose existing components keeping new code minimum 
focus existing components important role configuration language act intermediate components originally designed 
system description application script written luaorb 
possibility invoking arbitrary corba servers need previous declarations allows set corba components compose application dynamically evolve 
evolution implicit explicit linking unlinking operations 
lua luaorb framework provide environment allows application evolve way 
interface specific component modified extended lua program running different machine 
program may part distributed application may executing independent activity 
subsections discuss classes change management corba applications 
configuration examples 
interfaces application configuration goal example discuss concepts provisions requirements classic configuration languages modeled lua corba 
example primes sieve discussed darwin 
application process feeds stream numbers pipeline filter processes 
filter prints number receives subsequently filters multiples number stream numbers 
interface definition filter component regis basically previously 
describes ways pipeline created components 
static configuration fixed number filter components instantiated right port connected left port filter bind command 
dynamic configuration filter component dynamically instantiated predecessor pipeline uses left port 
follows discuss dynamic configuration main focus application reconfiguration 
idl filter component corba follows provider interface plays part input channel 
gets new items calls single method put 
interface provider oneway void put long interface models output channel component requiring input channel 
single method connects input channel new item interface needs output calls put method provider 
interface void provider interface inherits interfaces 
acts filter receiving numbers put method passing provider 
interface provider specific behavior filter quite simple stores number receives 
filters numbers multiple number non multiple numbers pass 
implementation sketched 
class provider prov long void provider prov void put long prov put fig 

implementation 
presents configuration sieve program luaorb 
program prints primes lua object assigned variable lnf responsible dynamic creation new filter components 
declaration lnf object generator object created 
component simply creates stream numbers fed filter pipeline 
example object create new instances component 
object represents application server service registers interface implementations supports requests running implementations new instances interface 
generator invokes put time activate lua object lnf current provider object 
execution lnf put results creation new object set provider generator 
subsequent invocations put generator invoke new filter object 
new filter object lnf provider component define listener creation new filters lnf put function self print local put self start application gen generator gen lnf gen fig 

configuring sieve primes 
behavior repeated time invokes put time 
example illustrates luaorb allows lua corba objects manipulated homogeneously 
calls method defined interface receive kinds objects arguments different moments 
note proposed scheme filter component aware existence provider object candidates primes passed 
lua script creates new filters identifies new primes way completely transparent components 
paradigm example data driven 
generator main active object filters act passive objects activated new datum available 
build example result driven paradigm change roles providers providers single method get returns new item call method providers need new item 
possibility dual approaches illustrates flexibility offered corba luaorb 
event driven applications important class distributed applications event driven applications actions associated occurrence specific events 
section discusses corba event driven applications coded luaorb 
illustrate proposed programming style get example glish language supports communication events 
example simple distributed application composed components measures data displays data 
monitor component announces produced new data generating event 
response event activate display component 
lua corba resort passing listener object argument monitor generation event modeled invocation object 
possible idl interfaces components follows interface monitor void measure long supervisor interface display void double data described section luaorb provides deferred invocations allow asynchronous style programming 
lua configuration program invoke measure asynchronously proceed execution lua supervisor object called needed 
configuration code example follows supervisor object function nd nd display monitor 
style component linking events pass configuration program 
discussed increases cost communication buys flexibility 
suppose depending value data need transform passing display component 
trivially programmed 
kind transformation needed done calling third component lua program 
performance vital glish provides point point links programs explicit link statement 
glish luaorb need extra mechanisms links 
luaorb facility follows directly fact lua objects corba objects interchangeable 
pass display component directly argument function measure monitor display component modification previous section discussed new components dynamically added application flow data dynamically redirected components 
section discuss changes component 
discussion example literature works discuss runtime changes components 
example drawn network management 
shows idl definitions component provides tcp related information 
definitions represent information provided snmp standard management information base 
attribute contains moment description current tcp connection 
entry table structure contains local remote ports ip addresses state connection 
struct long string long string long typedef sequence 
interface readonly attribute connections 
fig 

idl network management component common problem network management availability enormous quantities raw data processed management application 
circumvent problem interface provides method returns connection table entries satisfy criteria 
luaorb interface implemented component modified dynamically allowing administrator establish different filtering criteria need re compilation 
instance create component trivial filter returns table tcp connections function return connections instance ir lookup redefine implementation select connections local port say function connections connections connections return variable holds string code new filter function 
lua uses double square brackets delimit literal strings span lines 
installing new implementation retrieve table connections obj final remarks natural relate problem component configuration general problem software configuration deals customizing software different needs environments 
textual configuration file software customization reflects declarative static style compared declarative architecture description language component applications 
architecture description languages declarative linking unlinking style focus problem checking configuration consistency parsers check required properties easily built configuration files 
fact application properties static checking 
case static solution represents robustness avoiding run time errors limits flexibility provided 
extension language software configuration configuration file program associated difficulties automatic checkers flexibility programming language provide 
execution errors due eventual inconsistencies times captured handled interpreted language 
proposed extending extension languages configuration component applications 
explicit linking unlinking operations provided hand means consistency verifications possible hand means evolution application controlled full programming language 
shown examples discussed results great deal flexibility allowing different patterns component interaction dynamically defined components easily modified 
facilities specially important component programming fulfill promise fields software reuse rapid prototyping 

andrews 
paradigms process interaction distributed programs 
computing surveys 

ban 
generic management model corba snmp 
phd thesis university zurich 

boyer 
systems services distributed application configuration 
proceedings fourth international conference configurable distributed systems pages annapolis md 
ieee 

feiler li 
consistency dynamic reconfiguration 
international conference configurable distributed systems pages annapolis md 
ieee 

luiz figueiredo roberto ierusalimschy 
lua extensible embedded language 
dr dobb journal december 

kramer 
maintaining node consistency face dynamic change 
third international conference configurable distributed systems pages annapolis md 
ieee 

ierusalimschy rodriguez 
reflexivity interface corba 
international conference computer languages pages chicago il 
ieee ieee 

ierusalimschy figueiredo 
lua extensible extension language 
software practice experience 

magee dulay kramer 
structuring parallel distributed programs 
iee software engineering journal 

magee kramer sloman 
constructing distributed systems conic 
ieee trans 
software engineering se 

jeff magee dulay jeff kramer 
constructive development environment parallel distributed programs 
iee iop bcs distributed systems engineering 

philippe christoph jean marc geib 
generic object oriented dynamic environment corba 
technical report universite de lille 

marco martins rodriguez roberto ierusalimschy 
dynamic extension corba servers 
euro par toulouse france 

rose 
management information base network management tcp ip internets mib ii 
rfc 

object management group framingham ma 
common object request broker architecture specification revision jul 

ousterhout 
tcl tk toolkit 
professional computing series 
addisonwesley 

paxson 
glish user level software bus loosely coupled distributed systems 
winter usenix technical conference 

rodriguez ierusalimschy 
dynamic configuration corba components 
international conference configurable distributed systems pages annapolis md 
ieee 

rodriguez ierusalimschy 
types school 
sigplan notices 

schmidt 
corba products 
www cs wustl edu schmidt 
html 

jon siegel 
corba fundamentals programming 
john wiley sons 

peter wayner 
objects march 
byte january 

madeira 
mechanism provide interoperability orbs relocation transparency 
proc ieee third international symposium autonomous decentralized systems pages berlin germany 
