talx realistic typed assembly language greg morrisett karl crary neal glew dan grossman richard samuels frederick smith david walker stephanie weirich steve zdancewic cornell university goal typed assembly language tal provide low level statically typed target language better suited java bytecodes supporting wide variety source languages number important optimizations 
previous formalized idealized versions tal proved important safety properties 
progress defining implementing realistic typed assembly language called talx 
talx instructions comprise relatively complete fragment intel ia bit flat model assembly language executable processors intel pentium 
type system language incorporates number advanced features necessary safely compiling large programs code 
motivate design type system demonstrate various high level language features compiled talx 
purpose type safe language called popcorn 
ability type check low level object code java virtual machine language jvml bytecodes allows extensible system verify preservation important class safety properties untrusted code added system 
example web browser check memory safety ensure applets corrupt arbitrary data 
entire jdk security model depends crucially ability jvml type system prevent untrusted code passing runtime checks needed enforce high level material supported part afosr arpa radc nsf ccr national science foundation graduate fellowships 
opinions findings recommendations expressed publication authors reflect views agencies 
carnegie mellon university security policy 
support portability type checking jvml defined relatively high level abstraction stack machine 
language engineered type checking relatively easy 
jvml design su ers number drawbacks 
semantic errors uncovered jvml verifier english specification 
concentrated constructing ex post facto formal model language type soundness theorem proven 
product know design considerably improved formal model constructed conjunction design process 

di cult ine cient compile high level languages java jvml 
instance approaches compiling languages parametric polymorphism generally involved code replication run time type checks 
constrained extensions java 
example definitions languages scheme dictate tail calls implemented space cient manner 
limitations jvml necessitate control flow stacks languages explicitly encoded heap allocated objects 

jvml designed ease interpretation practice just time jit compilers achieve acceptable performance 
jit translation native code happens verification error compiler introduce security hole 
furthermore need rapid compilation limits quality code jit compiler produces 
address concerns studying design implementation type systems machine languages 
goal identify typing abstractions general utility encoding variety high level language constructs security policies interfere optimization 
abstractions necessary expressive contexts proof 
previous statically typed risc assembly language called tal showed simple functional language compiled tal proved type system tal sound typed assembly programs violate primitive typing abstractions 
described various extensions support stack allocation activation records data separate type checking object files 
languages described extremely simple keep formalism manageable 
informally describe talx statically typed variant intel ia bit flat model assembly language 
talx type system considerably advanced type systems described previously 
addition providing support stack allocation separate type checking linking number basic type constructors records tagged unions arrays type system supports higher order recursive type constructors arbitrary data representation rich kind structure allows polymorphism di erent kinds types 
demonstrate utility features describe high level language called popcorn compiler maps popcorn talx 
popcorn safe language provides support firstclass polymorphism types tagged unions exceptions simple module system 
ultimately popcorn support features stack allocated data flattened data structures 
giving brief overview process compiling popcorn program talx verifying output compiler creating executable 
discuss salient details popcorn 
talx type system showing popcorn programs translated type correct talx code 
close discussing planned extensions 
current software release talx popcorn available www cs cornell edu 
talx tools section describes talx tools listed table develop safe native programs 
running example assume popcorn source application files foo pop main pop 
popcorn compiles file separately 
syntax type errors new files generated foo tal foo foo main tal main main 
tal files contain ia assembly language type annotations described section 
tal file records values imports exports listing typed interface files 
extern declarations compiled corresponding import interface file 
non static types values compiled corresponding export interface file 
run talx type checker called foo tal main tal separately 
step verifies talx code type safe context implied corresponding import file 
popcorn compiler implemented correctly type checking individual tal files produces fail 
running longer assuming popcorn compiler produces safe code 
link verifier checks multiple tal files consistent assumptions values types share 
popcorn code may fail just traditional object files may fail link due missing multiple definitions 
traditional linker link verifier checks files agree types shared values 
link verification guarantees tal files type safe linked 
see glew morrisett technical details 
tal files assembled linked traditional tools 
compatible microsoft macro assembler fails long lines 
developed assembler deficiency 
produce stand executable additional trusted files linked 
component boehm demers weiser conservative garbage collector responsible memory management 
small runtime environment provides essential features runtime written talx types values runtime revealed applications typed interface file 
described build cycle executable detail 
practice tools compose steps talx tools type checks talx file 
link verifier verifies linking set talx files safe 
assembler assembles talx file produce elf object file 
popcorn compiles popcorn talx 
scheme compiles small subset scheme talx 
written popcorn 
table components talx implementation default providing programmer build interface similar traditional unsafe systems 
popcorn serious compiler targeting talx time talx specifically designed popcorn 
fact written compiler small part scheme demonstrating feasibility compiling higher order dynamically typed language 
popcorn section briefly summarize features popcorn 
discussion provides starting point section compiling talx 
language purposely looks unsafe features pointer arithmetic address operator pointer casts missing 
compiling features safely impose significant performance penalty popcorn code 
popcorn advanced features exceptions parametric polymorphism 
objects reasons discussed section 
addition avoid various java style semantic decisions ciency reasons 
example compiling java correctly requires run time type checks array updates precise exception semantics prevents standard optimizations 
control flow basic control constructs popcorn break continue identical test expressions type bool 
popcorn switch construct di ers execution falls cases 
furthermore default case required cases exhaustive 
argument switch test expression int char union exception 
example find occurrence character array result type relational logical operators bool 
int answer true switch arr case answer break break default array subscripts bounds checked run time see section example exit immediately arr contain 
exceptions may di erent types exception handlers may switch name exception java 
exception names hierarchical 
data currently simple types popcorn bool char short int string unsigned variants numeric types 
intend add floating point numbers long integers soon 
strings null terminated 
arrays carry size support bounds checks 
special size construct retrieves size array string 
popcorn tuples useful encoding anonymous structures multiple return values 
new construct creates new tuple new struct union values 
example code performs component wise doubling pair ints int int new int int dbl new popcorn kinds structure definitions struct struct 
resemble struct di erence struct struct values types defined struct null primitive construct language 
values types defined struct checked null field access failure causes program exit immediately 
unions popcorn ml datatypes unions 
variant consists tag associated type possibly void 
example union tree void leaf int tree tree node value union type particular variant determined tag may treated 
switch determine variant expression bind corresponding value variable 
continuing example write int sum tree switch case leaf return case return case node return sum sum parametric polymorphism popcorn function struct struct union declarations may parameterized types 
example define lists struct list hd list tl declare variable holds list ints instantiate type parameter list explicit type instantiation expressions necessary example new list null type list 
having polymorphic functions means write length function works type list 
polymorphism particularly useful function pointers 
example write map function list map list null return null return new list hd map tl call function look list list map int string overview talx section give overview features talx describe example features may 
particular show popcorn code may compiled typed talx 
talx uses syntax instructions data augments syntax type annotations necessary verification 
type annotations broken classes 
import export interface information separately type checking object files 

type constructor declarations declare new types type abbreviations 

typing preconditions code labels specify types registers control may enter associated code 

types data labels specify type static data item 

typing coercions instruction operands coerce values type 

macro instructions encapsulate small instruction sequences type checker treats sequence atomic action 
important typing preconditions code labels 
annotations general form type checker ensure control transferred corresponding label registers contain values types respectively 
bound type variables 
allow types registers polymorphic 
explicitly instantiate polymorphic precondition control transferred corresponding label 
see talx supports di erent kinds types 
consequently type variable explicitly labeled kind may check appropriate types instantiate bound type variables 
typing precondition code label type checker verifies instructions associated code block type correct assumptions types type treating type variables types ensure code appropriate instantiation 
rest section assume syntax semantics instructions data apparent focus attention typing annotations abstractions 
show various high level features popcorn may compiled talx 
due space limitations omit discussion talx features including exceptions static data higher order types interfaces 
basics example uses loop calculate sum natural numbers int int translate fragment talx code assuming initially register ecx mov eax ecx eax mov ebx jmp test body eax ebx add ebx eax test eax ebx dec eax cmp eax jg body example label preconditions say thing control transfer code occur registers eax ebx values byte integers 
type checker uses constraints check operands instruction block safe 
assume example know ecx initially contains 
instruction eax 
increment legal legal increment pointers 
third instruction puts ebx 
verifier assured precondition jumping test label satisfied 
test label requires ebx value transfers control body 
consider writing function int sum int previous example body return course function way return caller 
assume moment caller places return address register ebp 
code typing precondition assumes ecx contains byte integer ebp contains code label precondition 
particular type annotation ebp eax read ebp contains pointer code expects eax sum ecx ebp eax body eax ebx ebp eax test eax ebx ebp eax dec eax cmp eax jg body goto body mov eax ebx jmp ebp return final jmp verifies eax contains 
notice verify preceding mov instruction type soundness guarantee algorithmic correctness 
type sum label describes non standard calling convention argument ecx return address ebp result eax 
calling conventions typically leaf procedures optimizing compiler 
way call sum jmp 
mov ebp mov ecx jmp sum eax code explicitly moves return address ebp moves integer argument ecx jumps sum 
jump type checks precondition sum requires integer ecx return address ebp expects integer eax 
stacks function calls support richer realistic calling conventions talx control flow stack abstraction stack types 
examples demonstrate types 
theoretical discussion see morrisett 
standard calling convention win requires return address placed top stack followed arguments 
returning function pops return address 
caller responsible popping arguments 
talx describes shape stack list types se represents empty stack stack type type describes stacks top element type rest stack described 
example stacks grow lower addresses top lowest address 
ebp callee save incorporate shortly 
eax se type stack elements return address expecting eax values 
register points stack esp generally write esp sptr stack type 
give sum function type esp sptr eax se call sum stack contains exactly return address argument 
clearly calls sum type check regardless depth stack 
overcome problem talx supports stack polymorphism portions stack 
example assign sum type ts 
esp sptr eax esp sptr says stack shape sum called esp contains pointer stack suitable return address followed integer followed stack shape 
code associated sum verified treating type 
notice sum returns jumping return address stack shape input return address 
stronger property holds sum type checked holding input stack corresponding remain unmodified lifetime procedure 
caller assured sum read modify caller local data caller 
returning example mov eax ecx sum mov eax esp load integer argument stack eax 
final jmp replaced pops return address jumps 
call sum additional annotation instantiates actual stack type including input argument part 
simple example main esp se push hidden stack push input argument call tapp sum call instruction pushes return address jumping tapp instantiates se 
usually call occur context part stack instantiation stack variable scope call site 
instantiated stack type containing 
respect talx supports form polymorphic recursion 
example shows recursive implementation sum 
recursive call says stack return address 
polymorphism encode registers calling convention 
force sum preserve value ebp require ebp value distinct type entry exit 
write ts 
ebp esp sptr ebp 
means byte type 
call instantiate appropriately 
talx supports addition constants stack pointers values may written arbitrary non stack slots 
necessary replace value stack sequence pushes pops element directly overwritten 
additional constructs stack typing discipline talx support compiler tasks 
instance compile popcorn exceptions code generator needs pop dynamic amount data control stack 
support talx provides limited form pointers middle stack 
limited pointers su cient support displays static links compiling languages pascal 
su cient support general stack allocation data 
memory allocation support general heap allocation data talx provides additional constructs explore tuples 
recall popcorn tuple code section int int new int int dbl new assembly level creating new pair involves separate tasks allocating memory initializing fields 
talx code corresponds preceding popcorn malloc get space mov eax initialize mov eax initialize push eax save malloc get space dbl mov ebx esp ebx mov ecx ebx ecx add ecx ecx ecx mov eax ecx initialize dbl mov ecx ebx ecx int sum int return return sum sum ts 
esp sptr eax esp sptr cmp esp jne tapp iffalse mov eax iffalse ts 
esp sptr eax esp sptr mov ebx esp dec ebx push ebx recursive call instantiates current stack shape call tapp sum add esp add eax esp recursive function calling convention add ecx ecx ecx mov eax ecx initialize dbl malloc instruction macro expands code allocates memory appropriate size 
routine puts pointer space eax 
verifier knows eax contains pointer uninitialized fields specified typing annotation tracking initialization important safety fields may pointers type system prevent dereferencing uninitialized pointer 
type field variance rw standing uninitialized read write read write respectively 
type system allow uninitialized fields read 
uninitialized fields may written value appropriate type field changed read write field 
sub typing allows read write field read write 
lines example comment describes type verifier assigns eax instruction malloc mov eax rw mov eax rw rw example second type says pointer tuple fields initialized followed uninitialized 
course pointer types appear part stack type label type 
talx places restrictions order fields initialized require fields initialized passing pointer function 
possible field initialized creating alias 
example malloc mov ecx eax ecx aliases eax mov eax init st field mov ecx init code contents eax moved ecx ecx assigned type eax 
stores initialize field twice 
aliasing lead type unsoundness values type 
type system track aliasing semantically meaningful optimizations expressed code type checks 
instance verifier rejects code assumes field ecx uninitialized malloc mov ecx eax ecx aliases eax mov eax init st field mov ebp ecx type error 
possible augment talx conservatively track aliasing doing complicate type system 
far favored simpler approach 
talx supports explicit allocation deallocation stack allocated objects support general purpose pointers objects 
contrast general purpose point ers heap allocated objects supported explicit deallocation 
link talx code conservative garbage collector unreachable objects may reclaimed 
support explicit deallocation require extensive change type system 
arrays support arrays talx complicated feature language 
critical issue array sizes array indices determined statically preserve type safety ensure index lies physical size array 
talx provides flexible mechanism tracking size array requiring size placed pre determined position 
array subscript update require special macro instructions take array pointer size array integer set value place array 
macros expand code sequences perform bounds check exit immediately index bounds perform appropriate subscript update operation 
array bounds checks separated subscript update operations optimizer eliminate reschedule 
pointers middle arrays allowed current type system limiting optimization 
support arrays talx type system includes new type constructors 
called singleton type compile time expression corresponding integer 
primary purpose singleton types statically track actual integer value register word memory 
instance eax type value eax equal drawn singleton set 
kinds type expressions integer type expressions polymorphic 
ecx type determine statically integer value contained ecx 
ebx type type system conclude contents registers equal 
type system treats singleton integer types subtypes may required 
second new type constructor form array type array elements variance type expression represents size array 
notice constant case size array known statically type variable case size array unknown 
furthermore type expressions purely static construct verification available run time value 
shall show gives flexibility place runtime array size want fixed position 
furthermore size array determined statically size need tracked run time 
crucial issue enforce property run time integer value equal size array passed appropriate bounds check 
particular array type array integer passed size array type 
example talx code increments index size array values lab eax array rw ebx mov ecx put eax ecx edx 
array size ebx element size 
edx eax ecx ebx edx put edx eax ecx 
array size ebx element size 
eax ecx edx ebx example may arrays size 
support arrays size unknown statically introduce integer type variable quantify achieve size polymorphism lab sint eax array rw ebx instructions need change 
compiler represents popcorn arrays pointer data structure containing run time size followed array elements 
existential type tie type run time size type array sint array rw type reads exists integer am pointer structure containing integer equal followed values 
existential package run time size array pass data structure function place data structure maintain information perform checked subscript update array 
notice default representation compiler required talx 
particular run time size underlying array unboxed popcorn array escape 
struct int list int hd int list tl int len int list lst int lst null lst lst tl return type rw int list rw len ts 
esp sptr eax esp sptr int list int list mov eax eax mov ebx esp lst ebx jmp tapp test body ts esp eax ebx rw int list rw eax mov ebx ebx lst lst tl test ts esp eax ebx int list coerce unroll ebx int list rw intlist rw ne ebx tapp body check ebx null return list integers implementation size array known compile time optimizer avoid storing size entirely 
ways create arrays talx 
tuple values type variance may coerced array type array 
second trusted runtime provides function takes integer value type returns array size element initialized currently working eliminate macros expose bounds checks optimizer eliminate 
requires supporting expressive symbolic language static integer expressions type system ability prove inequalities expressions xi pfenning 
sums recursive types demonstrate talx sums recursive types consider implementing linked list integers see 
critical points list fundamentally sum type value type list null pointer tuple ensure code works case 
second list type recursive 
popcorn code struct definition lists len function calculates list length 
talx code corresponding type definition corresponding code 
talx type definition says value coerced type int list singleton value null pointer pair integer int list 
entry len label integer variable initialized placed register eax 
list argument placed ebx code jumps loop test 
test coerces ebx type int list representation type corresponding sum type 
instruction macro instruction tests ebx equal ne branches body 
macro expands simple compare branch 
type checker verifies register tested sum type value tested refines type register 
particular label body allowed stronger assumption ebx fact pointer null 
assumption allows mov ebx ebx operation verify ect setting ebx tail list 
current popcorn compiler generates nave code 
list tested null part test tail list selected 
clear optimizing compiler dataflow analysis determine second check redundant 
clear optimizing compiler easily maintain appropriate typing annotations 
making types smaller talx type annotations take far space suggested far 
example verifier allows typing preconditions dropped cer tain labels 
particular labels serve forward branch targets need typing precondition 
verifier simply re verifies corresponding code block branch 
restriction forward branches ensures termination verifier 
verifier supports type abbreviations common sub terms types may abstracted 
example popcorn gives type string 
repeat type popcorn defines str abbreviation uses place form type sint array rw source repetition code types 
example code types essentially repeat type stack twice stack type return address 
calling convention function abbreviation type esp sptr eax ret esp sptr example fully expanded type polymorphic map function unwieldy map ts 
esp sptr eax list esp sptr ts 
esp sptr eax esp sptr list ts 
esp sptr eax esp sptr list abbreviation map ts 
list ts 
list smaller readable practice faster verify 
summary described currently available tools producing talx including compiler language popcorn 
examples demonstrated talx ensures safety assembly code presence advanced structures optimizations 
planned extensions system add tools increase expressiveness languages 
include 
binary object file format replace talx current ascii format 
format save space parsing time 
provide better setting evaluating verifier performance 

support floating point mmx instructions 
expect di cult 

support run time code generation developed trevor jim university pennsylvania 
addition extension popcorn called cyclone features available higher level 
currently working minor interoperability issues 

advanced dependent type system allow bounds check elimination proven safe 

support object abstractions talx 
support objects talx requires having object types typing constructs translate object types 
having object types talx restrict talx oo languages compatible object model 
lot research done translating object types translations sacrifice theoretical properties introduce run time overhead 
currently investigating new efficient object encoding involves sub typing bounded quantification self quantifiers 
acknowledgments chris hawblitzel wrote version popcorn 
trevor jim luke provided invaluable feedback system addition adding support run time code generation 
martn abadi raymie stata 
type system java bytecode subroutines 
acm sigplan sigact symposium principles programming languages pages san diego california usa january 
nick benton andrew kennedy george 
mlj user guide 
hans juergen boehm mark weiser 
garbage collection uncooperative environment 
software practice experience 
karl crary 
simple proof technique certain parametricity results 
technical report carnegie mellon university pittsburgh pennsylvania usa december 
karl crary david walker greg morrisett 
typed memory management calculus capabilities 
sixth acm sigplan sigact symposium principles programming languages pages san antonio texas usa january 
neal glew greg morrisett 
type safe linking modular assembly language 
sixth acm sigplan sigact symposium principles programming languages pages san antonio texas usa january 
luke hornof trevor jim 
certifying compilation run time code generation 
acm workshop partial evaluation semantics program manipulation pages san antonio texas usa january 
richard kelsey william clinger jonathan rees 
revised report algorithmic language scheme 
acm sigplan notices september 
abelson adams iv brooks dybvig friedman halstead hanson haynes kohlbecker pitman steele jr sussman wand 
brian kernighan dennis ritchie 
programming language 
prentice hall englewood cli nj usa second edition 
tim lindholm frank yellin 
java virtual machine specification 
addison wesley 
greg morrisett karl crary neal glew david walker 
stack typed assembly language 
workshop types compilation volume lecture notes computer science pages kyoto japan march 
greg morrisett david walker karl crary neal glew 
system typed assembly language extended version 
technical report tr department computer science cornell university ithaca new york usa november 
greg morrisett david walker karl crary neal glew 
system typed assembly language 
fifth acm sigplan sigact symposium principles programming languages pages san diego california usa january 
andrew myers joseph bank barbara liskov 
parameterized types java 
acm sigplan sigact symposium principles programming languages pages paris france 
george necula 
proof carrying code 
acm sigplan sigact symposium principles programming languages pages paris france 
robert callahan 
simple comprehensive type system java bytecode subroutines 
sixth acm sigplan sigact symposium principles programming languages pages san antonio texas usa january 
martin odersky philip wadler 
pizza java translating theory practice 
fourth acm sigplan sigact symposium principles programming languages pages paris france january 
oopsla workshop 
formal underpinnings java 
vancouver canada october 
hongwei xi frank pfenning 
eliminating array bound checking dependent types 
acm sigplan conference programming language design implementation pages montreal canada june 
hongwei xi frank pfenning 
dependent types practical programming 
sixth acm sigplan sigact symposium principles programming languages pages san antonio texas usa january 

