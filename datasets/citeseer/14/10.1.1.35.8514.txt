secrecy typing security protocols martn abadi systems research center compaq ma pa dec com december develop principles rules achieving secrecy properties security protocols 
approach traditional classification techniques extends techniques handle concurrent processes shared key cryptography 
rules form typing rules basic concurrent language cryptographic primitives spi calculus 
guarantee protocol typechecks leak secret inputs 
preliminary version conjunction third international symposium theoretical aspects computer software september appeared proceedings volume springer verlag lecture notes computer science pages 
contents principles secrecy rules distributed systems 
preliminaries keys channels 
classifying data 
classifying inputs 

implicit flows 
principles 
untyped polyadic spi calculus syntax 
commitment 
testing equivalence 
typing system environments 
terms 
processes 
typing guarantees typing concretions abstractions 
auxiliary propositions 
lemmas commitment simulation 
main theorem 
examples example 
second example 
acknowledgments security elusive cocktail rare ingredients 
security protocol may want properties integrity confidentiality availability various forms anonymity non repudiation 
seldom protocol achieve properties designers intended 
protocol sound delicate define important properties di cult prove 
tasks protocol design analysis simplified having principles easier achieve particular security objectives isolation rules help recognize objectives achieved cf 
wl 
example wish obtain availability properties concerned denial service attacks may design protocols way obvious small bound amount principal response message 
relax bound messages trusted authenticated principals trust authentication correct letting availability depend done lightly 
develop informal principles formal rules achieving secrecy properties security protocols 
principles rules traditional concepts classification information flow den gas extended deal concurrent processes shared key cryptography 
particular analyzing protocol label piece data communication channel secret public 
secret data sent public channels secret channels available indiscriminately 
approach encryption keys pieces data labelled 
result encrypting secret data secret key public precautions 
example secret bit secret key simply publish may publish attacker deduce value comparing ciphertexts 
rules capture su cient set simple precautions permit publication ciphertexts contain secrets 
rules form typing rules basic concurrent language spi calculus ag ag ag ag calculus extension pi calculus mpw shared key cryptographic primitives 
purpose rules di erent standard typing rules related languages pierce sangiorgi ps 
rules guarantee protocol typechecks leak secret inputs 
secrecy obtained independently feature flaw protocol 
example rules may guarantee protocol leak contents certain messages concern message replay possible 
notion leaking formalized terms testing equivalence dh bn roughly process leak input second process distinguish running parallel running parallel typing rules helpful may lead designs clearer robust sound 
furthermore enable give simple proofs properties hard establish principles 
secrecy theorems obtain taken grain salt dependent choice particular model spi calculus 
model fairly accurate expressive take account issues key length example 
section explains informally approach achieving secrecy 
section review spi calculus 
spi calculus generalization defined originally ag includes polyadic constructs mil :10.1.1.1.5724
section provides typing rules spi calculus section shows rules applied prevent undesirable flows information 
section illustrates rules examples 
sections suggest conclude 
opt simplicity generality considering exploration promising approach 
particular take binary view secrecy 
view world divided system attacker secret attacker 
sophisticated view secrecy distinguish various principals system enable discuss principals piece data 
binary view vary boundary system attacker benefits 
principles secrecy security literature known methods controlling flows information 
typically methods rely putting objects subjects security classes guaranteeing data flows higher classes lower classes 
methods security classes formalized types control flows information relies typing rules vis 
adapt security protocols 
section describes approach informally main di culties addresses 
probable basic observations section documented open literature 
rules distributed systems centralized system administrator controls hardware system may hope control information flows 
communication mediated system hardware control information flows plausible principle 
particular administrator may check user programs running statically may apply dynamic checks 
distributed system hand single administration may control hardware 
part system may able check software part constructed set rules 
best principal analyze programs receives principals messages 
rules propose attacker satisfies vacuously result physical laws reasonable premises 
situations may assume attacker guess certain keys expect restrict code attacker runs 
rules constrain principals want protect secrets attacker 
preliminaries keys channels mentioned concerns shared key protocols 
write result encrypting shared key cryptosystem des des 
shared key cryptography secrecy achieved communication public channels secret keys 
addition public channels may communicate consider channels built protection 
restrict attention channels principals send receive 
single machine channel protection provided operating system mediates communication user processes distributed system protection implemented cryptographically 
ability communicate channel determined possession capability password key 
pi calculus spi calculus name channel capability channel 
public channel capability public similarly secret channel capability secret 
classifying data consider classes data public data communicated secret data leaked data arbitrary data 
possible generalize rules richer classification structures classes generalization essential immediate purposes 
symbols range classes secret public 
refer secret public classes levels types di erence emphasis 
informal discussions continue terms secret public consider explicitly class encryption keys data classification scheme applies 
di erent levels associated key level piece data levels data encrypt levels resulting ciphertexts 
combinations possible example public key turn secret data public ciphertexts 
simplest retain level key 
similarly associate single classification channel 
adopt principles result encrypting data public key classification data result encrypting data secret key may public 
public data sent public channels kinds data may sent secret channels 
relation holds equals 
piece data level piece data level 
piece data level level secret leaked 
hand piece data level level public secret 
example secret key encrypting secret data 
know piece data level protect level secret exploit level public 
piece data useful constructing channel capabilities encryption keys find cleaner forbid uses altogether accommodated substantial restrictions limited benefit 
classifying inputs principal may know classification data creates principal may know classification data acquires communication principals 
data arrives clear public channels presumed public 
hand data arrives protection may secret public 
participants protocols typically know handle fields encrypted messages receive example inspired needham schroeder protocol ns message message ksa message protocol principals share keys sa sb server respectively 
server provides confidential information response request receives message server decrypts retrieves forwards crucial able recognize action appropriate 
example principal plays role concurrent runs protocol able recognize message instance message instance message 
mistakes instance message instance message forward part clear 
example common principals deduce sensitivity inputs expected kind message implicit information 
implicit information incorrect hard analyze 
clearer label explicitly component message classification avoiding dependence implicit context 
labelling important messages secret channels secret keys 
messages contain public information helpful misleading public labelling components redundant 
alternatively may adopt standard format messages secret channels secret keys 
format guarantee standard way attach classifications parts message avoiding dependence implicit context 
rules adopt scheme 
message secret channel components level secret second third public 
message secret key components plus component discussed 
schemes implementations principle receipt message easy decide parts contents sensitive information 
decision error prone depend implicit context 
noted secret bit secret key simply publish may publish attacker deduce value comparing ciphertexts 
hand create fresh value publish concatenation value called 
purpose guarantee resulting ciphertext di ers previous ones 
resulting ciphertext di er ones ciphertext includes fresh position 
general concerned encrypting known plaintext need kept secret 
needed encryption history dependent different transformation applied message 
particular needed encryption done stream cipher chapter block cipher appropriate chaining mode section 
remarks section intended apply protocols built algorithms 
independently choice cipher needed protocols ciphertexts generated guaranteed di erent 
unfortunately clear guarantee ered 
example consider simple protocol principal sends message principal shared key kab sends message provides challenge nb fresh message challenge serves proof freshness protects replays 
message nb message nb kab may reason ciphertexts di erent includes fresh challenge 
reasoning incorrect 
attacker provide challenge reply noticing challenge come attacker may pick challenge nc twice row 
case ciphertexts responds nc kab nc kab identical identical 
find sending identical knowing key kab protocol leaking information 
order prevent small leak create na encryption 
modified protocol message nb message nb na kab protocol analyzed ag proved protocol guarantees secrecy prudent adopt principle encrypted message protocol includes freshly generated standard position protocol generate ciphertext 
obvious needed 
implicit flows system may reveal parameters parameter appears explicitly message 
example system may send di erent cleartext messages depending value parameter 
attacker deduce parameter patterns communication 
leak information called implicit flow 
course important restrict implicit flows 
purpose may forbid comparison involves pieces sensitive data followed actions reveal result comparison 
important push restriction uncomfortable extremes 
protocols exhibit implicit flows form usually severe undesirable ects 
example consider protocol message message ksa message attacker send arbitrary message message 
receipt message performs test involves secret sa branches result test 
reaction depends visibly message valid ciphertext sa regard implicit flow little importance chance independently created message valid ciphertext sa negligible 
allow implicit flow harmless model 
tentative policy implicit flows summarized principle implicit flows information prevented likelihood implicit flow greater likelihood attacker guess information 
principles principles discussed su ce basis rules theorems comprehensive 
practice additional warnings techniques important 

hard leak size secret 
padding encrypted messages help respect 
prudent minimize benefit attacker may derive discovering secret 
particular key protect great volume sensitive tra brute force attack key may profitable 
weak secrets passwords protected brute force attacks see example sch 
undoubtedly 
untyped polyadic spi calculus remainder develop rules checking protocols relying principles section 
principles informal rigorous definition rules requires formal notation describing protocols rigorous analysis rules requires semantics notation 
describe protocols spi calculus processes reason operational semantics spi calculus induced relation testing equivalence 
section presents version spi calculus serves setting formal defining syntax operational semantics testing equivalence 
main novelty respect earlier versions spi calculus polyadic forms input output encryption decryption operation applies arbitrary number pieces data single piece 
novelty important typing rules section 
novelty substantial particular ect expressiveness spi calculus 
presentation review 
material derived earlier presentations spi calculus includes ideas common pi calculus literature 
syntax assume infinite set names infinite set variables 
range names range variables 
identify expressions renaming bound names variables write 
outcome replacing free occurrence renaming bound name variable occurs set terms defined grammar terms name pair zero suc successor 
shared key encryption variable term 
represents ciphertext obtained encrypting 
key key arbitrary term typically names keys spi calculus names capabilities 
set processes defined grammar processes 
output 
input nil parallel composition replication restriction match pair splitting case suc integer case case 
shared key decryption name variables 
bound processes 
constructs familiar earlier process algebras see ag review see operational semantics :10.1.1.1.5724
intuitively meaning constructs follows 
process 
outputs 
behaves output happens name process ready receive inputs 
abbreviation 

process may output 

terminology pi calculus literature calculus defined section synchronous 
triggers communication 
asynchronous fragment obtained replacing 

grammar results apply asynchronous fragment change 
process 
ready receive inputs 
behave 

process 
process parallel composition family processes 
write parallel composition 
process behaves infinitely copies running parallel 
process new name behaves process behaves equal stuck 
process behaves pair stuck pair 
process case suc behaves suc stuck 
process case 
attempts decrypt key form 
process behaves 
process stuck 
grammars possible write expressions standard typing systems exclude example suc arithmetic operation applied pair 
typing system section di erent concerns exclude expression combination standard typing system may appealing necessary purposes see section 
polyadic notations input output encryption decryption defined corresponding unary notations 
example set case case variable fresh 
mentioned polyadic notations useful typing 
introduce typing di culty arities match case typing di culty overcome appropriate system sorts 
addition polyadic notations standard abbreviations 



variable fresh 
write fn fn sets names free term process respectively write fv fv sets variables free respectively 
expression closed free variables 
closed expression may free names 
commitment give operational semantics spi calculus defining commitment relation style milner mil 
definition commitment depends new syntactic forms abstractions concretions 
abstraction expression form 

bound variables process 
concretion expression form 


terms process names 
bound 
agent abstraction process concretion 
metavariables stand arbitrary agents concretions abstractions 
extend operations restriction parallel composition process abstractions 



assuming 
fv concretions 







assuming 

fn 
define dual composition symmetrically 
definition 

preserves distinctness bound names 

original definition ag guarantee names occur :10.1.1.1.5724

change crucial analysis rule comm res lemma 
abstraction 
concretion 


fn define processes follows 



reduction relation relation closed processes satisfies axioms red repl red match red red zero case suc red suc case suc suc red decrypt case 


barb name representing input name representing output 
action barb distinguished silent action commitment relation written closed process action closed agent 
defined rules comm 

comm 

comm inter comm inter comm par comm par comm res comm red testing equivalence test pair consisting closed process barb 
say passes test 
processes 
agent obtain testing preorder testing equivalence closed processes test passes passes strict barbed simulation binary relation closed processes implies barb exists strict barbed bisimulation relation strict barbed simulations 
definition somewhat stronger barbed bisimulations ag :10.1.1.1.5724
barbed bisimulations strict barbed bisimulations alike respects sensitive steps branching structure processes standard bisimulations ag sensitive contents messages example suc related output di erent terms :10.1.1.1.5724
lemma provides method proving testing equivalence lemma closed process exists strict barbed bisimulation proof lemma consequence earlier results ag give simple direct proof :10.1.1.1.5724
argue passes test assuming exists strict barbed bisimulation 
symmetrically passes test passes 
agent processes 

definition strict barbed simulation exist 

passes 
earlier presentations spi calculus define study equivalences addition testing equivalence 
context process algebras focardi gorrieri investigates equivalences relation security properties fg fg 
typing system section describes rules controlling information flow spi calculus 
ideas section 
ways formalizing ideas embody typing system spi calculus 
typing system simple enforced statically fact simon gay implemented gay 
main results typing system section 
imply process typechecks leak values parameters level 
examples parameters typically payload messages protocol 
despite secrecy parameters declared level secret process may produce terms level secret execution example encryption keys restriction construct 
instance may level level public assign level secret bound names results imply process leak value sense testing equivalent closed terms typing system meant protect parameters level relying dynamically generated names level secret typing system gives rules kinds assertions judgments formed means environment formed 
means term class ok means process typechecks environments environment list distinct names variables associated levels 
addition name associated term form 

intuitively association means name may term 
association crucial proposition 
write variable level 
name level term 
write shorthand arbitrarily needed 
set names variables declared environment domain write dom 
rules environments environment empty formed environment variable formed dom formed environment name formed dom 

formed collectively rules enable form environments lists variables names associated levels addition terms attached names 
empty list written rule environment empty 
rule environment name hypotheses 
included variable occurs 
declared left 
intuitively restriction important implies instantiate variable ways obtaining di erent terms defeating purpose 
example key level secret restriction lead excluding process may generate di erent ciphertexts note bound right hand restriction permit process generates ciphertext sends ciphertext times bound left robin milner benjamin pierce suggested mp reminiscent idea linearity kpt 
hypotheses rule environment name may seen linearity requirement 
linearity requirement peculiar fit neatly standard accounts linearity 
terms rules terms level subsumption level variable formed level name formed 
level zero formed public level successor suc level pair level encryption public public 
public 
level encryption secret secret public secret public rule level subsumption says term level public secret level 
rules level variable level name enable extract levels names variables environment 
rule level zero says level public 
rule level successor says adding preserves level piece data 
terms suc suc suc 
level public 
term form suc may levels 
example name variable level secret suc level 
intuitively classifications mean typing system works attacker may generate number starting successively incrementing 
allow unrealistic attacker preserving guarantees names numbers names numbers spi calculus ability produce number consistent inability guess certain names example names represent secret keys 
protection names require complexity theoretic bounds restrict production numbers 
terms suc suc suc 
level public process parameter level need reveal value suc 
attacker ability generate number entail ability deduce variable number value 
rule level pair says level pair level components 
components level pair term level public level secret need regard having level rule level pair loses little bit typing information interesting explore richer structural typing system avoid loss 
rule level encryption public says pieces data level encrypted key level public resulting ciphertext level rule level encryption secret imposes restrictions encryption keys level secret resulting ciphertext level public 
restrictions enforce particular format contents explained sections ciphertext contain component level secret second level third level public appropriate final component 
relax rule level encryption secret somewhat considering case resulting ciphertext level public rule strikes reasonable balance simplicity flexibility 
note rule encryption case term level 
explained section term level known level public secret key 
processes rules processes level output public public public 
public ok 
ok level output secret secret secret public ok ok level input public public public 
public ok 
ok level input secret secret secret public ok ok level nil formed ok level parallel ok ok ok level replication ok ok level restriction ok ok level match public secret ok ok level pair splitting public secret ok ok level integer case public secret ok ok case suc ok level decryption public public secret public 
ok case 
ok level decryption secret public secret secret secret public ok case ok rules output rules input 
rule level output public says terms level public may sent channel level public 
rule level output secret says terms levels may sent channel level secret provided done format described section triple component level secret second level third level public 
rules input level input public level input secret match rules output 
level input public inputs assumed level public level input secret levels inputs deduced position allowed format messages channels level secret explained section term level known level public secret channel 
rules nil parallel composition replication restriction routine 
rule level restriction name bound associated arbitrary term 
rule level match enables compare terms levels public secret terms level excluded order prevent implicit flows discussed section 
may little surprising terms level secret allowed rule may permit implicit flow 
implicit flow possible terms level secret generated uniformly executions process considered independently values sensitive parameters 
comparisons terms level secret obstacle results 
rule level pair splitting enables try break term level public secret components assumed level original term 
case original term known level disallowed allowed rule permit leaking term fact pair 
similarly rule level integer case enables examine term successor term branch result 
successor case variable represents predecessor term examined assumed level term 
level pair splitting term level may level secret names numbers repeated applications rule level integer case enable publish secret name unary 
formally leak happen names numbers discussed 
practical meaning small formal debatable 
may suggest model concrete spi calculus worth investigating cf 

rules decryption analogous rules input 
rule level decryption public handles case decryption key level public rule level decryption secret handles case decryption key level secret rule level decryption secret gives level message decrypted lack accurate static information significant practical loss 
rule decryption key level typing guarantees goal section prove process typechecks leak values parameters level mentioned testing equivalence formalizing notion leaking 
precisely main theorem says variables level names level public domain environment substitutions values variables typechecks ok proved testing equivalent 
means observer distinguish detect di erence values variables 
order prove main theorem develop number propositions lemmas analyze typing system characterize possible behaviors processes typecheck 
typing concretions abstractions step proofs extend typing rules concretions abstractions level concretion public 
public 

public 
ok 

public level concretion secret 
secret 

public 
ok 
level abstraction public public 
public ok 
level abstraction secret secret public ok rules reminiscent corresponding rules output input 
auxiliary propositions obtain auxiliary results 
proposition formal counterpart discussion section proposition shows suitable environment closed process may construe attacker typechecks 
typing rules narrow set attackers defend assume arbitrarily attacker adheres particular typing discipline 
proposition assume formed dom contain variables names dom level public 
closed term fn dom public 
closed process fn dom ok proof prove general property allowing variables occur consider environment formed levels names variables public 
prove term fn fv dom public 
process fn fv dom ok facts obtained direct induction structure level encryption public terms form 
facts obtained direct induction structure level output public level input public level decryption public 
proposition fairly standard says proved environment proved adding assumptions environment 
proposition assume formed 
ok ok proof property proved induction derivations ok proposition enables reorder environment moving declaration name past declarations variables 
proposition 

formed formed 
ok ok proof proof induction derivations judgments formed ok converse proposition false contains free occurrences 
formed may formed 
proposition says levels secret public mutually exclusive 
proposition secret case public 
proof assume secret public hold derive contradiction induction size derivations secret public 
interesting case form 
term 
levels secret public application rules encryption 
induction hypothesis yields expected contradiction 
remaining auxiliary results concern substitutions 
general substitution partial function finite domain set variables set terms 
write dom domain substitution 
proposition standard substitution lemma 
proposition assume formed formed 
ok ok proof proof joint induction derivations judgments formed ok case rule level encryption secret important note appears occur term formed 
proposition says substitutions variables level preserve forms terms levels 
proposition environment suppose variables level dom public secret variable variable 
name name 
form 

suc form suc 

form 
proof follows fact variable dom domain consists variables level 
proposition says substitutions variables level act terms levels 
proposition environment suppose variables level dom 
suppose public secret 
proof proof induction derivation case rules typechecking terms interesting level encryption secret 
rule level subsumption applied trivially rule derivation public secret 
level subsumption yield case requires trivial invocation induction hypothesis 
rule derivation level variable variable dom dom consists variables level implies proposition 
rule derivation level name level zero name implies proposition 
cases level successor level pair easy applications proposition induction hypothesis 
remaining cases form 
public secret depending derivation finishes application level encryption public application level encryption secret 
cases proposition implies form 
public secret depending derivation finishes application level encryption public application level encryption secret possibly followed trivial applications level subsumption 
induction hypothesis obtain proposition derivations finish applications rule 
rule level encryption public 

hypotheses applications rule 


induction hypothesis obtain 
rule level encryption secret name level name level name may declared environment conclude note argument rely induction hypothesis subterms level induction hypothesis apply 
reasoning necessary 
lemmas commitment simulation main lemma section relates typing system commitment relation 
write closed term fn dom dom 
lemma assume ok variables dom level 
process ok 
process ok 
public secret concretion public depending public secret 
public secret abstraction depending public secret proof assume variables bound appear domain range substitutions similarly bound assume names 
appear range substitutions conditions achieved renaming necessary 
part examine axioms 
case assume reduction yields process axiom construct process required properties 
particular equality holds easily cases 

red repl case 
judgment ok established rule level repl ok ok ok addition closed fortiori 
red match case 
judgment ok established rule level match ok public secret 
ok order obtain su ces process closed condition follows condition follows proposition 
red case 
judgment ok established rule level pair splitting ok public secret 
proposition pair 
addition established rule level pair 
obtain ok ok proposition 

red zero case case suc 
judgment case suc ok established rule level integer case judgments public secret ok ok proposition 
case suc case suc closed fortiori 
red suc case case suc suc 
judgment case suc ok established rule level integer case judgments ok public secret 
proposition suc 
addition established rule level successor 
obtain ok ok proposition 
case suc case suc suc 
red decrypt case case 


judgment case 
ok established rule level decryption public level decryption secret public secret 
ok secret public ok proposition 
terms 
equals equals 
judgment established rule level encryption public level encryption secret public secret secret public name proposition equals obtain equals follows equals proposition 
proceed cases public secret public 

obtain ok 
ok 
proposition 
secret 
obtain ok secret public ok secret public proposition 
cases case 
case 
case 


remaining parts proved induction derivations 
consider rules commitment 
comm case 

equal 


judgment 
ok established rules level output public level output secret 
ok public secret 
proposition name public secret public 
public obtain public level concretion public 
secret secret public hypothesis application level output secret obtain level concretion secret 
case 


comm case 

equal 


judgment 
ok established rules level input public level input secret 
ok public secret 
proposition name public secret public 
public obtain level abstraction public 
secret secret public ok hypothesis application level input secret obtain level abstraction secret 
case 


comm inter case obtain judgment ok derived ok ok induction hypothesis abstraction properties stated part corresponding concretion properties stated part corresponding 
particular 
consider cases public secret case public public 
form 
public 
public ok form 

public 
public ok environment form 

index defined 



obtain ok proposition proposition rules level parallel level restriction 
case secret form secret public ok form 
secret public ok environment form 


obtain ok proposition proposition rules level parallel level restriction 
cases 
suppose 

comm inter 
comm inter analogous comm inter 
comm par case obtain name name correspondingly process abstraction concretion 
judgment ok derived ok ok induction hypothesis exists ok public depending level public secret obtain ok follows suppose process 
ok derived directly level parallel 
suppose public abstraction 

case abbreviation 

judgment established public 
public ok proposition public 
public ok level parallel level abstraction public conclude 
suppose secret abstraction reasoning analogous previous case obtain suppose public concretion 

public 
case abbreviation 


judgment public established public 
public ok environment form 
proposition ok level parallel level concretion public conclude public 
suppose secret abstraction reasoning analogous previous case obtain cases obtain 
comm par 
comm par analogous comm par 
comm res case obtain name name correspondingly process abstraction concretion 
judgment ok derived ok induction hypothesis exists case comm par ok public depending level public secret obtain follows suppose process 
ok derived directly level restriction 
suppose public abstraction 

case abbreviation 
judgment established public 
public ok proposition public 
public ok level restriction level abstraction public conclude 
suppose secret abstraction reasoning analogous previous case obtain suppose public concretion 

public 
case abbreviation 

judgment public established public 
public ok environment form 
level concretion public conclude public 
suppose secret abstraction reasoning analogous previous case obtain cases obtain 
appear range comm res 
comm red case obtain exists ok induction hypothesis ok yield exists defined case comm par 
comm red 
lemma environment suppose variables dom level 
suppose relation ok strict barbed bisimulation 
proof consider commitment barb 
lemma agent consider commitment lemma process ok step may matched relation ok strict barbed simulation 
symmetry strict barbed bisimulation 
main theorem obtain theorem described start section theorem environment suppose variables level names level public dom 
suppose ok proof lemma su ces show closed process exists strict barbed bisimulation relates closed equals equals construct extension names appear free dom 
name add public call resulting environment 
propositions obtain ok proposition obtain ok combining results rule level parallel yields ok lemma yields desired result 
note theorem hold free occurrences names level secret occurrences ruled hypotheses names level public ok examples order illustrate typing rules consider examples protocols key exchange secure communication 
cases typecheck protocols 
typechecking manually simon gay reproduced implementation typing system gay 
corollaries obtain secrecy certain messages protected 
corollaries imply protocols publish message directly leak implicit flows 
corollaries surprising 
harder prove principles rules developed 
analogues corollaries provable formal systems 
surprisingly formal proofs sort literature protocols 
methods paulson ective inductive method pau may able show messages question terms attacker obtains protocol runs 
result approximation corollaries rule attacker deduce messages numbers odd numbers example 
corollaries exclude possibility 
analogues corollaries established informal rigorous models see example br 
models accurate particular take account issues probability complexity 
unfortunately proofs models remain di cult typechecking 
example protocol similar structure wide frog protocol ban 
enables principal transmit sensitive data principal help server generates key kab sends encrypted pre existent key forwards kab pre existent key sends kab addition keys payload protocol messages include names principals nonces 
informally protocol message message message kab ca kas message message nb message kab nb message kab message db channels db public 
keys kas sb secret keys communication server kab new secret key communication nb nonces prove timeliness arbitrary message appropriate level necessarily occurrences ca 
messages requests receives nonce challenge request simply name 
messages requests receives nonce challenge arbitrary message su ces request server 
message provides key kab passes message 
message tuple conveys name sender names users key nonce 
similarly message tuple nb conveys name sender names users key nonce 
message uses kab sending receipt message recipient outputs names public channel db message 
important specify receives message include order illustrate allowed react 
express protocol spi calculus earlier spi calculus ag attention requirements typing :10.1.1.1.5724
spi calculus definition protocol basically code produces message sequence shown 
produce exactly message sequence allows interleavings may get stuck doing better simple matter programming 
code long particularly deep intricate careful reading reveal step step behavior invariants 
familiarity earlier spi calculus may help understand style 
case fortunately application rules theorems require detailed comprehension code 
spi calculus definition set messages 
mm source addresses 
destination addresses 
respectively 
addresses natural numbers range indicate plays role plays role run protocol 
addition address 
address channels write term representing example suc suc simply write term representing construct process sys code complete protocol combining processes send srv recv processes give code sending address address server receiving address respectively 
definition send variable corresponds message write send send 
send nonce 
ca nonce ca srv 
cipher 
case cipher key cnf xb nonce nonce nonce 
key nonce recv nb cipher 
case cipher key cnf xa xb nonce nonce nb cipher 
case cipher cnf key sys 
ns 
sn send 
send mm srv recv 
recv precise replace occurrence appropriate term 
example expression may replace occurrence second alternatively may rewrite 
perform easy replacements somewhat cumbersome distracting 
proposition says protocol typechecks 
proposition environment public public 
public public 
public 
fixed numbers sys ok proof order indicate process sys typechecks annotate bound names variables levels introduced annotate terms 
secret sj secret define send nonce public 
secret secret nonce ca nonce ca secret srv public 
public cipher public 
case cipher key secret public cnf public public xb public nonce public nonce nonce public 
secret key nonce key nonce recv public public nb cipher public 
case cipher key secret public cnf public xa public xb public nonce public nonce nb cipher public 
case cipher secret public cnf key environment set sys secret 
ns secret secret 
sn secret send 
send srv recv 
recv writing send send 
consequence typechecking obtain protocol reveal message stated corollary simplicity restrict attention case numeral 
numeral terms suc suc suc 
corollary fixed numbers sys sys versions sys terms arbitrary numerals sys sys proof immediate consequence proposition theorem 
possible treat variants protocol keys sj secret 
example keys declared level public 
variant correspond situation may fall enemy hands principal address part enemy 
clearly messages address may longer secret messages ected 
second example second protocol purpose transmission sensitive data principal principal sends key generated server example interesting brings issue trust trusts provide key appropriate transmission requests key sending name nonce adds name nonce sends resulting information response provides key kab encrypting pre existent keys adding names nonces generated 
point sends kab 
message na message na nb message kab na ksa message kab nb message ca kab message db db public channels 
keys sa sb secret keys communication server na nb nonces ca 
example include message order illustrate allowed react specify destination message 
write example spi calculus style example 
definition set messages 
mm source addresses 
destination addresses 
respectively 
send na na cipher 
case cipher key cnf ksi nonce nonce na ca ca key srv nonce nonce 
nonce ksi nonce recv nonce 
nb nonce nb cipher 
case cipher key cnf nonce nonce nb cipher 
case cipher cnf key sys 
sn send 
send mm srv recv 
recv proposition corollary analogues proposition corollary respectively 
proposition environment public public 
public public 
public 
fixed numbers sys ok proof proposition order indicate process sys typechecks annotate bound names variables levels annotate terms 
si secret sj secret define send na public na cipher public 
case cipher key secret public cnf ksi public public nonce public nonce na ca secret ca key ca key srv public nonce public public nonce public 
secret secret nonce ksi nonce ksi secret nonce nonce recv public nonce public 
nb public nonce nb cipher public 
case cipher key secret public cnf public public nonce public nonce nb cipher public 
case cipher secret public cnf key environment set sys secret 
sn secret send 
send mm srv recv 
recv writing send send 
corollary fixed numbers sys sys versions sys terms arbitrary numerals sys sys proof immediate consequence proposition theorem 
indicated regard exploration promising approach 
section briefly suggests possible directions 
suggestions fairly obvious safe 
techniques information flow analyses den gas vis ml hr sv may help pursuing 
mentioned relies binary view secrecy world divided system attacker 
finer model distinguish individual principals groups system 
permit declassification operation principal reduce secrecy level data owns 
typing system allow comparisons terms level operations terms 
typing system may relaxed allow operations cases outcomes revealed public channels 
trivial way combine typing system typing system may simply require processes typechecked systems separately 
standard methods typing system may exclude expressions suc case discussed section 
trivial combination typing systems may appealing 
tighter integration may elegant powerful 
concerns shared key cryptography 
worthwhile treat public key cryptography 
suggestions speculative 
sake brevity list omits applications process calculi avoids discussion alternative access control models 
security literature contains quite principles designing protocols wl 
principles turned rules validated formal theorems 
woo lam useful principle full information particularly tractable 
authenticity dual secrecy sense authenticity properties concern sources data secrecy properties concern destinations 
may expect principles rules similar yield authenticity guarantees 
hand authenticity secrecy significant di erences 
example evidences timeliness freshness appear frequently authenticity proofs secrecy proofs 
inspired type directed compilers tmc may imagine compiler preserves secrecy levels mapping secret data source program secret data lower level representation 
instance compiler may translate pi calculus spi calculus low level language ering secrecy guarantees low level code produces aba 
part advances programming languages idea static checking security properties 
java bytecode verifier static checker security objectives ly 
sophisticated security checks self certification information flow techniques nec mwcg vis ml hr sv 
year papers consider applications programming language concepts techniques security context process calculi afg aba cg dam rh 
seen part revival 
develops method static checking secrecy properties programs written minimal expressive programming language spi calculus 
programs concurrent cryptography 
method embodied set typing rules 
principles rules developed necessary su cient security 
necessary practical static typechecking disciplines incomplete 
su cient ignore security issues secrecy account implement spi calculus preserving secrecy properties 
principles rules provide useful guidelines 
furthermore rules tractable precise able study detail prove secrecy properties establishing correctness informal principles formal model 
acknowledgments butler lampson suggested studying authentication protocols classification techniques years ago 
suggestion starting point 
took place context collaboration andrew gordon spi calculus themes techniques owe 
andrew gordon rustan leino anonymous referees suggested improvements drafts 
conversations mike burrows steve kent ted wobber helpful 
aba abadi 
protection programming language translations 
proceedings th international colloquium automata languages programming pages 
afg abadi fournet gonthier 
secure implementation channel abstractions 
proceedings thirteenth annual ieee symposium logic computer science pages 
ag abadi gordon :10.1.1.1.5724
calculus cryptographic protocols spi calculus 
proceedings fourth acm conference computer communications security pages 
ag abadi gordon :10.1.1.1.5724
calculus cryptographic protocols spi calculus 
technical report university cambridge computer laboratory january 
revised version appeared digital equipment systems research center report january abridged version appear information computation 
extended version ag ag :10.1.1.1.5724
ag abadi gordon 
reasoning cryptographic protocols spi calculus 
concur concurrency theory volume lecture notes computer science pages 
springer verlag 
ag abadi gordon 
bisimulation method cryptographic protocols 
programming languages systems th european symposium programming esop volume lecture notes computer science pages 
springer verlag 
anderson needham 
robustness principles public key protocols 
proceedings crypto pages 
abadi needham 
prudent engineering practice cryptographic protocols 
ieee transactions software engineering january 
aura 
strategies replay attacks 
proceedings th ieee computer security foundations workshop pages 
ban burrows abadi needham 
logic authentication 
proceedings royal society london 
preliminary version appeared digital equipment systems research center report february 
degano nielson nielson 
control flow analysis calculus 
concur concurrency theory volume lecture notes computer science pages 
springer verlag september 
bn boreale de nicola 
testing equivalence mobile processes 
information computation august 
br bellare rogaway 
provably secure session key distribution party case 
proceedings th annual acm symposium theory computing pages 
cg cardelli gordon 
mobile ambients 
foundations software science computation structures international conference fossacs volume lecture notes computer science pages 
springer verlag 
dam dam 
proving trust systems second order processes 
proceedings hicss volume vii pages 
den denning 
cryptography data security 
addisonwesley reading mass 
des data encryption standard 
fed inform 
processing standards pub 
national bureau standards washington dc january 
dh de nicola hennessy 
testing equivalences processes 
theoretical computer science 
fg focardi gorrieri 
classification security properties 
journal computer security 
fg focardi gorrieri 
compositional security checker tool verification information flow security properties 
ieee transactions software engineering september 
gas gasser 
building secure computer system 
van nostrand reinhold new york 
gay gay 
private communication 
september 
hr heintze riecke 
slam calculus programming secrecy integrity 
proceedings th acm symposium principles programming languages pages 
kpt kobayashi pierce turner 
linearity pi calculus 
proceedings th acm symposium principles programming languages pages 
lincoln mitchell mitchell scedrov 
probabilistic poly time framework protocol analysis 
proceedings fifth acm conference computer communications security pages 
ly lindholm yellin 
java virtual machine specification 
addison wesley 
mil milner 
polyadic calculus tutorial 
technical report ecs lfcs laboratory foundations computer science department computer science university edinburgh uk october 
appeared logic algebra specification bauer brauer schwichtenberg eds springer verlag 
mil milner 
calculus 
undergraduate lecture notes cambridge university 
ml myers liskov 
decentralized model information flow control 
proceedings th acm symposium operating systems principles pages 
mp milner pierce 
private communication 
september 
mpw milner parrow walker 
calculus mobile processes parts ii 
information computation pages september 
menezes van oorschot vanstone 
handbook applied cryptography 
crc press 
mwcg morrisett walker crary glew 
system typed assembly language 
proceedings th acm symposium principles programming languages pages 
nec necula 
proof carrying code 
proceedings th acm symposium principles programming languages pages 
ns needham schroeder 
encryption authentication large networks computers 
communications acm december 
palsberg 
trust calculus 
journal functional programming november 
pau paulson 
inductive approach verifying cryptographic protocols 
journal computer security 
ps pierce sangiorgi 
typing subtyping mobile processes 
mathematical structures computer science october 
rh hennessy 
typed language distributed mobile processes 
proceedings th acm symposium principles programming languages pages 
sch schneier 
applied cryptography protocols algorithms source code john wiley sons second edition 
sv smith volpano 
secure information flow multithreaded imperative language 
proceedings th acm symposium principles programming languages pages 
syverson 
limitations design principles public key protocols 
ieee symposium security privacy pages 
tmc tarditi morrisett cheng stone harper lee 
til type directed optimizing compiler ml 
proceedings acm sigplan conference programming language design implementation pages 
vis volpano irvine smith 
sound type system secure flow analysis 
journal computer security 
wl woo lam 
lesson authentication protocol design 
acm operating systems review 

