metatheory reflection theorem proving survey critique john harrison university cambridge computer laboratory new museums site pembroke street cambridge cb qg england cl cam ac uk th february way ensure correctness inference performed computer theorem provers force proofs done step step simple traditional deductive system 
techniques pioneered edinburgh lcf palatable 
believe approach efficient large complex proofs 
alternative commonly called reflection analyze proofs second layer logic metalogic justify abbreviating simplifying proofs making kinds shortcuts humans appealing specialized decision algorithms 
contrast fully expansive lcf approach reflection 
put forward arguments suggest inadequacy lcf approach adequately demonstrated practical utility reflection notwithstanding intellectual interest 
lcf system concerned hol proof assistant 
plan follows 
examine ways providing user extensibility theorem provers naturally places lcf reflective approaches opposition 
detailed lcf provided emphasizing ways efficient 
short metatheory usefulness starting godel proofs feferman transfinite progressions theories look logical reflection principles 
show introduce computational reflection principles extend power logic may deductions efficient speculate practical usefulness 
applications proposed applications computational reflection theorem proving surveyed draw 
appendix attempt clarify couple notions reflection encountered literature 
questions easy acceptance reflection principles practical necessity 
hope serves adequate concepts involved reflection survey relevant 
extensive bibliography provided 
extending theorem provers computer theorem provers typically implement certain repertoire inference mechanisms 
example may solve tautologies order reasoning resolution perform induction simplifying rewrites allow user invoke delicate logical manipulations 
certain systems fast tautology checkers useful applications quite restricted field 
virtue generality logic implement theorem proving procedures provide wider applicability wider applicability original design goal 
hol originally intended mainly verification hardware subsequently applied software protocol verification embedded formalisms temporal logic ccs pure mathematics 
theorem prover general applicability difficult supplier provide basic repertoire theorem proving facilities adequate purposes 
desirable policy theorem prover extensible provide facility augmenting basic repertoire 
simplest consist macro language automate certain common repeated patterns inference 
address question implementing radically different proof procedures included 
particular macro language limited facilities direct construction terms formulas demarcate valid inferences allow arbitrary formulas nominated theorems 
options 

new inference rule proves useful simply augment theorem prover basic primitives include 

allow full programming language manipulate basic rules users may write arbitrarily complex inference rules ultimately decompose primitives 

incorporate principle reflection user verify existing theorem proving infrastructure code implementing new rule correct add code system 
say theorem provers adopt mixture policies 
example nuprl forms 
incarnation inference done decomposing primitive rules martin lof type theory 
practical applications various additional facilities binary decision diagrams arithmetic decision procedures grafted 
furthermore third option investigated nuprl researchers course years shall discuss 
options taken considerable care exercised ensure proposed extension sound 
users allowed tailor system claims theorem proved system 
user variant unsound longer original theorem prover incorrect mutation 
supplier unwilling concede proof performed satisfactory standard 
hardly held meeting objective standard correctness 
small user community single research establishment consultation peers may help achieve considered view sound enhancement wider community people personal projects realistic 
practice sociological reasons major changes implemented supplier 
may enforced making system closed source code available example 
suppliers need exercise careful judgement new facilities add 
tempting add just obviously sound extension reason induction addition obviously sound extensions compromise system 
experience shows obviously sound extensions frequently sound 
suppliers attempt verify informally formally code augmenting system correct 
done formally approach looks similar third reflection reflection distinguishing feature proof conducted existing theorem prover 
careful thought principled way making reliable system 
mean suggest intellectually policy 
contrary purpose theorem proving highlight flaws informal reasoning may efficient add lots facilities ad hoc way order get quickly interesting error prone parts reasoning 
certainly final assertion correctness means bugs may emerge quickly 
example interesting hybrid system including hol fast symbolic model checker reported joyce seger 
allows tackle leading edge problems hardware verification advantage higher level abstraction hol permits 
policy argued rushby point similar ideas 
example floating point verification ora reported hoover mccullough aims prove correctness asymptotically precision arithmetic tends infinity 
useless giving true error bounds experience shows quickly highlight bugs software 
example computer algebra systems widely theorem provers despite giving wrong answers 
lcf approach theorem proving edinburgh lcf system described gordon milner wadsworth developed milner research assistants mid response dissatisfaction highly automatic provers low level proof checkers 
prover kind developed stanford lcf milner provided motivation 
edinburgh lcf ported stanford lisp franz lisp huet formed basis french research project 
paulson reengineered improved version resulting cambridge lcf 
original system implemented version scott logic computable functions name lcf emphasized gordon lcf approach applicable logic 
lcf systems ml programming language define data types representing logical entities types terms theorems 
name ml derived meta language effectively lcf systems kind metalogic explicitly algorithmic way demonstrate provable prove 
lcf related origin ml language achieved life 
higher order functional programming language polymorphic types typesafe exception mechanism imperative features 
reasonably formal semantics standard ml core language published see milner tofte harper milner tofte 
number ml functions provided produce theorems implement primitive inference rules logic 
hol rules nuprl implements martin lof constructive type theory requires 
hol primitive inference rules proved sound set theoretic semantics devised andy pitts published gordon melham 
pottinger proved complete respect henkin general models provided primitive ml inference rules theorem resulting correct 
adherence primitive rules enforced encoding theorems ml datatype constructors primitive inference rules logic 
type thm arisen applying primitive rules 
trustworthiness attractive proofs nontrivial facts terms primitive inferences extremely tedious approach far offers advantages simple proof checker 
simple proof checkers check substantial parts mathematics 
pioneering example jutting formalizing famous book landau automath system de bruijn 
large disparate body mathematics checked mizar system described rudnicki journal formalized mathematics devoted mizar formalizations attractive able direct proofs higher level perform proofs trivial tautologies facts arithmetic explicitly 
important verification applications pure mathematics proofs shallower tend involved intricate abstraction mechanisms hide layers complexity see melham 
done lcf provers ml programming program complicated patterns inference provided ultimately decompose primitives 
write derived inference rules higher level 
order exploit user may just call functions understanding decompose primitives 
original implementor derived rule need understand 
datatype user equal confidence correctness resulting theorems ultimately arise primitive inference 
user derived rule free decompose rebuild terms formulas way desired order decide proof strategy extremely simple term structure hol convenient 
theorems built primitive inference 
way lcf approach offer reliability controllability low level proof checker power flexibility sophisticated prover provided prepared put required provide useful derived inference rules 
sake completeness add morally true lcf implementation simple primitive rules 
primitives hol range complexity reflexivity equality simultaneous parallel substitution 
include rewriting arithmetic decision procedures 
alternative policy exemplified pvs system described owre rushby shankar primitives powerful 
means programming required build suitable set high level operations high level operations may efficient 
defect harder confident correctness complex primitives case primitives useful depend context example users embedded formalism considering polymorphism proof theoretic perspective hol polymorphism obviously conservative extension type instantiations floated back proof tree 
information journal surprisingly inexpensive contact philippe le mizar users group av 
roosevelt brussels belgium fax 
may require unusual proof procedures 
hand argue hol goes far direction parsimony insisting arithmetic done logic 
icl relaxes restriction takes numeral addition primitive rule 
readers aware word tactic widely theorem proving literature refer discussing compound proof step ultimately decomposes primitives 
hol original lcf system word tactic reserved cases high level proof step works backward goal directed manner 
avoid ambiguity irrelevant distinctions refer derived rules regardless steps forward backward 
reading quotes general word tactic borne mind 
advantages lcf obvious advantage lcf approach user feel degree confidence purported theorem really theorem 
critical code confined implementing primitive rules support functions 
admitted dependence correctness ml implementation particular correctness type system 
reasons finds assertion trustworthiness quite easy change system record proofs 
done hol wong primitive inference logged 
lcf style provers nuprl coq store proof trees lambda term witnesses 
proof may checked simpler external program written chosen programming language 
overview various pieces research hol connected ideas see gordon hale herbert von wright wong 
particular may feasible prove simple proof checker correct 
important part project analyze carefully constitutes hol proof notion hol proof formalized hol von wright 
process errors logical core uncovered 
personally considers worthwhile proof checking recommended certain procurement standards safety critical software mod practice formal proofs size created hand 
developed theorem proving assistants interactive programs carry symbol manipulation guidance human operator 
theorem proving assistants large programs correctness readily demonstrated formal proof 
possible remove reliance correctness theorem proving assistant case correctness application arranging version final proof omitting history construction passed theorem proving assistant proof checker 
reasonable languages proof checker simple program pages functional programming language developed highest level assurance 
naturally possible non lcf systems provide low level proof script example see discussion adding proof trademark international computers limited 
logging system 
making theorem prover capable producing primitive inferences effectively writing second lcf style mode existing theorem prover 
furthermore primitive inferences complex correctness questioned lcf decomposition simple primitives need emulated 
elegant adopt lcf approach start 
lcf approach offers great flexibility ordinary users may extend system customized derived rules 
slind remarked certain point view lcf approach theorem proving deserves manifesto user controls means theorem production 
rules added user need verified error proof procedure may fail ml type discipline produce invalid theorem 
users need provide theoretical justification adding new derived rule prove correctness code implementing 
simply design decompose primitive inferences 
simple cases straightforward complex cases arguably normally easier performing correctness proofs code 
inherent inefficiency lcf 
advantages undeniable appears heavy price pay derived rule proof procedure forced decomposing primitive rules 
apart unnatural instances hardly efficient hand coded proof procedure 
course necessarily problem key question serious constraint practice 
view firmly embedded theorem proving folklore serious constraint making lcf approach ultimately untenable practical examples 
lcf certainly influential subsidiary features tactics implement backward proof general stress interactive fully automatic proving widely imitated 
systems adhere pure lcf philosophy rare 
fact widely verification examples hol arguably system 
characteristic criticisms lcf davis schwartz 
edinburgh lcf system 
employs device tacticals obtain modest degree extensibility 
lcf tactical limited fixed combination existing rules inference 
virtue correctness proof sense needed sic obvious limitation really new inference rule adjoined 
armando cimatti major drawback approach proof procedure sophisticated ones ultimately invoke basic inference rules 
cases turns unnatural ineffective 
decision procedures decidable theories truth table method propositional calculus hardly rephrased proof strategies inference rules corresponding calculus 
performance translated proof strategies effective direct implementation original procedure 
reif opinion currently available validation mechanisms powerful large applications example software verification 
example hol systems extensions correct construction application large tactics inefficient 
practical applications bad compromise 
basin 
believe tactics insufficient provide proper level reasoning interactive theorem proving additional mechanisms metatheoretic extensibility required 
example able extend prover new kinds decision procedures hampered need produce proof primitive rules 
encountering criticism naturally expects find theoretical justification results case studies lend support assertions 
searches vain thing 
conference writes feel lot confident predicting way theorem prover architecture go known complexity issues theoretical practical face 
natural theorem proving problems reasonably tractable decision procedure tractable means finding proofs primitive inferences 
appears answered question convincingly 
central importance 
power intellectual simplicity lcf approach foolish enter nebulous complicated areas reflection reason supposing lcf approach practically insufficient may expect rigorous theoretical answer question complexity theory reveals difficulty proving apparently simple facts witness status np problem 
able say useful 
sufficiency lcf maintain inefficiency lcf approach 
remarks apply hol extent validity remarks depend logic higher order details 
obvious practical counterarguments ffl hol currently widely theorem proving system 
experience shows overwhelming majority cases difficulty proving theorem hol due inefficiency users constrained inefficiency 
difficulty providing proof key time factor user thinking time 
means quite substantial changes better worse efficiency basic proof procedures may minimal impact productivity users 
lessons lcf proofs guided quite low level apart course sheer intellectual curiosity 
motivation confused dictates practice 
dijkstra important distinguish research fields theorem provers theorem proving 
tedious provided chosen derived rules provided 
running derived decision procedures large examples efficiency important 
argument strong case automatic provers force interactive provers users come rely sophisticated derived rules 
ffl computers getting faster time may today efficiency problem ceases tomorrow 
author heard anecdotal evidence rewrites half hour early versions lcf 
today rewrite hol take second unusual 
course size typical proofs expanded time development machines argument longer hold 
correlation improbable 
early days unix ran little slowly written assembler 
time slowdown modest considering organizational advantages higher level language 
nowadays considers writes assembler 
specific arguments 
contentions hard justify theoretical need case studies 
believe current experience provides strong support 
detailed examination sources inefficiency hol see boulton 

proof procedures may implemented fairly natural way primitive inferences 
plugging terms ad hoc manner transformations may justified stage matching suitable theorem requiring primitive inferences time instantiate theorem perform say modus ponens step 

cases sophisticated inference rules inference may construed small part 
search dominates done requiring primitive inferences need written ml performed hol 

inefficiency derived rules hol arises poor excessively programming 
careful sophisticated programming efficiency problems disappear 

implementation improvements applied ml systems 
questions primitive inference aside ml order magnitude slower comparable applications 
looking matters details give example illustrate assertions 
hol rewriting rules tactics take set equational theorems repeatedly replace instances left hand sides corresponding instances right hand sides term 
subterms rewritten number repeated rewrites may precisely controlled default term searched matching subterms top order repeatedly possible 
initial search matching subterms implemented quite independently primitive inferences required perform rewrite 
hol term nets achieve fast lookup apparent matches thrown matcher tried 
part appears dominate rewriting efficiency especially large number rewriting theorems 
sophisticated algorithms hoffmann donnell known indexing technique tree structures originally added cambridge lcf paulson 
tried point matching unaffected need perform inference 
rewriting subterm performed instantiations buildup term done iterating congruence rules equality slower simply plugging terms ad hoc way 
fact boulton minimized rebuilding unchanged subterms exploiting failure optimization orthogonal question performing inference applied implementation term substitution hol core 
theorems justify inference contention patterns inference carried ad hoc may implemented terms primitive inference fairly straightforward fashion moderate slowdown 
extent particularly true hol higher order logic provides power encode quite sophisticated structures theorems 
idea long hol experts early example see melham 
harrison defines generic representation univariate polynomials lists poly poly cons theta poly possible prove list induction example polynomial differentiable 
specific instance necessary instantiate theorem perform rewrites unwind recursive definition 
necessary repeat proof time 
similar quite sophisticated inferences encoded example forall pos forall pos exists zero meaning finite set list polynomials strictly positive interval positive middle interval nonzero 
fact examples awaken fact hol logic incorporates simple functional programming language operations implemented outside alternatively internalized logic executed primitive inference 
course quite lot slower mark difference tractability intractability right boundary possible special proof procedures 
expect slowdown linear 
presuppose important condition 
transformation justified appeal pre proved theorem modus ponens step check equal 
ml implementation efficient operation internally pointers eq lisp parlance 
traversal trees terminate reached efficiency depends structural complexity respect applicative implementation 
full traversal required time severe efficiency bottleneck 
unfortunately current versions hol ff equivalence equality condition derived rules ff equivalence test succeeds quickly terms eq hol performs single eq test repeat test traverses subterms 
opinion changed performing equality test 
standard ml provide lisp eq obvious optimization putting eq test inside ff equivalence function possible 
proviso close plausible implementable ml purely functional programming implemented inside logic moderate constant factor slowdown 
cases true type system constrains generality theorem example want state theorem arbitrary iterations function space constructor 
general type systems nuprl may 
example useful able justify inductive definitions tarski fixpoint theorem interpret monotonicity just unary relations sets relations arbitrary arities 
xn xn xn xn xn xn particular case dealt various ways maintaining instantiation linear number variables repeating proof time satisfies constraint primitive inferences time 
separating search inference lot theorem proving procedures involve substantial amounts search search complete may simple produce proof terms primitive inferences 
example resolution proof may involve searching thousands millions clauses refutation 
path refutation usually quite short provided clauses unifiers recorded easily transformed hol proof little instantiation propositional reasoning 
tableau decision procedures order logic developed hol way see kumar schneider schneider kumar 
similar remarks apply arithmetic decision procedures implemented hol useful practical tools boulton 
procedures factorization polynomials numbers finding solution equations 
difficult computationally intensive require sophisticated heuristics 
putative answer relatively straightforward matter check correctness required formal proof 
observation harrison th ery discuss link hol maple computer algebra system 
general external oracles produce checkable answers idea delegating proof finding external proof planner 
idea explored bundy van smaill 
optimizations number techniques may lcf approach efficient 
example situations nuprl typechecking obligations example trivial theorem proved 
may aka previous theorems substantial gain efficiency obtained 
example situation arithmetic theorems described boulton 
general technique optimizing lcf implementations proposed boulton lazy theorems 
idea delay inference phase rules accumulating function closure inference executing final theorem needed happens hol backward proof exactly tactics 
offers potential making interactive proof efficient postponing costly inferences overnight 
gain idea simply achieved slow fast modes inference done 
may lazy theorems help manage separation search inference automatically allowing programmer employ free easy style inference rules exploratory search convenient 
furthermore may special situations inferences efficiently decided examining proof example phenomenon see bdds hol harrison 
partial evaluation substantial research area partial evaluation aims optimize functional programs precomputing parts 
idea similar known idea constant folding compilers sophisticated 
nice summary bjrner ershov jones large goal pe construct program form restriction usage knowledge input parameter values efficient new residual program equivalent original program restriction 
hol derived rules manually optimized perform computation see arguments 
example rewriting rules rewrites set term net applied term rewritten 
may considerable potential similar optimizations automatically 
ideally sequences primitive inferences folded efficient 
applying partial evaluation hol undertaken preliminary results promising 
point imperative features particular proof recording level primitive inferences destroy potential optimizations 
incidentally papers danvy talcott weyhrauch explore possible connections partial evaluation reflection 
difficult cases cases tractable proof primitive inference hard find algorithms making essential imperative features arrays shared data structures allowing cheap checking process 
binary decision diagrams described bryant constitute just algorithm interesting challenge 
harrison implements bdds derived rule encountering slowdown times direct standard ml implementation 
significant factor large considering bdds chosen precisely challenge 
furthermore second discussed applies extent chosen variable ordering tremendous difference efficiency bdd tautology check 
deciding variable ordering done requiring primitive inference 
special theorem proving algorithms hard implement satisfactorily lcf style system 
example method invented wu solving geometrical problems remarkably powerful see chou impressive examples 
involves manipulation polynomials high degree complicated asymptotically fast fft algorithms multiplication sine qua non large examples 
remains seen reasonably fast implementation done lcf style 
somewhat different example proof primitive inference dramatically efficient arithmetic 
generally situation duplicating hardware facility inside logic real example 
machine arithmetic perform inference inside logic add couple integers 
binary decimal representation inside logic consequently speed arithmetic operations numbers size log log 
purely theoretical point view course machine arithmetic different allows arbitrary precision 
practical perspective constant factor difference speed may enormous 
serious problem depends manipulation large numbers occurs frequently typical applications 
replicating hol described boyer yu quite difficult course follow softening lcf ideal slightly provided written implementation language perform arithmetic logic 
worth noting cases terms involved large may arise hidden overheads example instantiating theorem large assumption complete traversal assumption term required check instantiated variable free 
may decomposition primitive inferences forces times metaknowledge convince check suffices 
achieved paradoxically making certain aspects theorem explicit logic relying way primitive rules discussed harrison 
clear represents serious difficulty practical cases 
analogy drawn way languages compilers insert bounds checks array 
programmer may know fact unnecessary detailed structure program 
reasons perform checks general array dereferencing may applied arbitrary pointers outperforms superficially similar languages 
clear useful practical proof procedures impossible accommodate pure lcf approach 
theoretical unrealistic perspective demonstrated proof procedure suffers constant factor slowdown implemented lcf style 
certainly applications naturally demand procedures 
exceptions fast model checking algorithms bdds hardware verification 
clear software verification similar demands pure mathematics justification claim may 
case reflection represent substantial practical advance justifying greater difficulty verification essentially imperative code required 
metatheory various discovered classified ramsey logical epistemological contradictions 
classic example logical paradox russell arises considering set sets members equivalent predication set membership 
paradoxes involve kind self inside logical system avoided adding notion type explicitly type theory implicitly hierarchical set theories stratified formulas 
typical examples epistemological paradoxes liar statement false santa claus statement true santa claus exists 
involve kind self involving questions go mathematics example sentence referring 
order avoid usual formal logic tarski carnap enforce strict separation object logic metalogic reason object logic 
formal logical system may happen natural form reasoning metareasoning 
example inferences hilbert style proof systems greatly eased deduction theorem states fpg metatheorem higher order theorem 
discusses particular formal system straightforward distinction object level theorem metatheorem 
metatheorem may say essentially object level theorem 
example metalevel statement object oe corresponds object level statement oe 
general may impossible state object level theorem import metatheorem 
crucial note stated object level depends critically nature object level formal system 
consider categorical statements aiello weyhrauch 
reasoning system dealing capability explicitly representing metatheoretic knowledge statements elementary math books expressed 
interesting meta statements appeared practice 
contrary arise mathematics books 
aiello 
reading book algebra realizes stated lemmas theorems fact metatheorems 
instances putative metatheorems cited 
matthews explicit mathematics done proof development system quite way done textbook look 
instance book algebra read zermelo arrived paradox time chose little 
zermelo original system cantor limitation size doctrine held collections paradoxical simply big 
subsequent addition axiom foundation amounts type theory 
godel proof viewed formalized version liar lob santa claus 
interestingly lob theorem informal version paradox suggestion referees 
abelian group equivalence times ffi ffi ffi ffi times ffi ffi ffi times ffi ffi holds 
hand book imagine proof development system algebra theorem stated theorem abelian group theory meta theorem theorem abelian group theory 
underlying implicit assumption talking axiomatization order logic 
higher order logic embedding set theory conventional foundational systems mathematics iterated operations algebraic structures definable argument collapses 
take argument extreme allow arithmetic statements involving ground terms logic variable metatheorem 
point 
edwards major part kronecker objections mathematics sense talk functions arbitrary function corresponding statement particular instance perfectly acceptable 
comment similar import referees aiello weyhrauch 
elementary algebra taught manipulate equations 
manipulation equations syntactic expressions straightforwardly metamathematical 
ability directly formalization attractive 
making weaker claim proof strategies manipulative techniques connect mathematical results derive said outside formal system 
true clear purely algorithmic metalogic ml programming language inadequate lcf style systems 
case shall see difficulty incorporating syntactic techniques higher order framework explicit metatheory 
evident need elaborate metatheory 
sees mathematics books assertions cases similar may assume loss generality case upper semilattice treated analogously 
flavour metatheorems relate similar proofs theorems 
bear mind presenting proofs informally just devices abbreviate 
certainly way formalizing statements metatheorems connecting proofs 
simply program computer 
cases explicitly 
reason suppose inadequate practice 
performing similar proofs different contexts may anyway hint searching suitable mathematical generalization include cases 
example similarity proofs arithmetical theorems different kinds limits pointwise limits real functions limits real functions infinity limits real sequences leads general limit notions nets filters see example dudley 
course denying fascinating things proofs 
example interesting done finding computational content classical proofs generalized double negation translation nuprl see example constable murthy 
lots interesting avenues investigation example translating proofs analytic number theory weak systems arithmetic described takeuti 
claim 
interests largely preserve logicians mainstream mathematicians obvious relevance verification 

unusual want feed results back system interest arises independent piece mathematics 

manipulations algorithmic investigated minor modifications lcf method example storing proof trees concrete objects done systems including nuprl 
metalogical frameworks response proliferation theorem provers different logics number generic theorem provers logical frameworks developed 
wellknown examples include isabelle system described paulson lambda prolog described felty miller lf system described harper honsell plotkin 
provide simple metalogic different object logics represented 
proof procedures provided intended applicable wide variety logics 
objective avoid needing write new theorem prover scratch new logic interested 
users may fact proving facts metalevel need aware nature metalogic 
usually metalogic chosen weak isabelle example uses intuitionistic second order logic lambda calculus numbers recursive data types 
ideal formalizing object logics particular binding constructs universal quantifiers implemented lambda calculus binding metalogic 
framework designed support object level reasoning uniform manner 
sufficient perform metatheoretic reasoning fact particular object level statement theorem 
fact metalogic usually weak proving deduction theorem hilbert style object axiomatization impossible 
course possible extend metalogic 
pointed randy pollack lf logic embedded natural subset powerful calculus constructions implemented coq lego provers 
pollack unpublished proved deduction theorem hilbert style propositional logic lego prover taylor verified tactic lf encodings lego proves equations associative semigroup list equality fringes term trees 
alternatively break away traditional framework logics 
matthews explores feferman fs system metalogic 
independent interest fs proposed theoretically feferman precisely purpose representing formal systems explication constitutes formal system 
matthews gives detailed sketch prove cut elimination propositional logic fs algorithm simple usual textbook formulation uses induction higher ordinals directly available fs termination proof 
general extensive metatheoretic reasoning see basin constable 
metatheoretic proofs share verification proofs detailed messy technical execution fundamentally simple ingenious idea 
reader may guessed examples cited existing metatheoretic proof computer theorem provers surprisingly limited 
probably substantial example proof godel incompleteness theorem shankar apparently done interest exploiting theorem prover 
seamless metatheory power metatheoretic reasoning arises ability step back constraints formal system exploit syntactic properties connection semantics 
example lowenheim skolem theorems prove exist groups rings fields boolean algebras order axiomatizable structures arbitrary infinite cardinality 
means syntactically classification structures able prove theorem attractive generality 
substantial example principle algebraic geometry imprecisely stated weil algebraic geometry characteristic pointed tarski noted seidenberg quite simple quantifier elimination procedure order theory algebraically closed fields 
routine logical equivalences facts polynomials gcd suffices eliminate universal quantifier 
algebraically closed field splits linear factors divide 
equivalent dividing formal degree 
consequently characteristic specified allowing decide ground sentences order theory complete models elementarily equivalent 
principle literally true restrict order statements 
possible take techniques mathematical logic showed 
examples applications mathematical logic pure mathematics surveyed kreisel robinson kreisel krivine 
higher order logic provides sufficient resources carry essentially metatheoretic reasoning sense operates syntactically subsets logic way tampering extending simple inference mechanisms 
datatypes representing syntactic objects terms set interpretation functions logic defined connect internal representation corresponding constructs logic 
example usual set theoretic semantics order logic respect interpretation environment valuation defined obvious manner bound variables nontrivial consideration easily dealt 
simple logic boyer moore prover allows evaluation function meaning defined terms variable assignment 
boyer moore emphasize magic meta function 
reasons connected truth demonstrated tarski possible define semantics logic inside 
useful subsets dealt rich type theories nuprl stratification universe level allows come close ideal 
howe implemented scheme nuprl verified embedded term rewriting system including matching algorithms 
appears go reflection proper nuprl discuss 
stress howe verifying theorem proving procedures 
author experimenting proving mathematical results similar techniques hol 
reiterate cases done formal system stands system higher order supports set theory 
full internalization semantics impossible tarski theorem may show practice type system providing obstacle 
lot interesting things including usual metatheorems order logic done way 
logical reflection godel showed quite simple logical theories act metatheory derived important metamathematical results exercise 
straightforward tedious matter encode formulas lists formulas proofs numbers write godel number formula oe poeq 
furthermore sensible encoding important syntactical operations encoded formulas substitution recursive computable provability 
detailed development discusses points touch see nski 
quite spartan number theory representable relations functions precisely recursive ones provided set axioms recursive define quantifier free predicate rov rov poeq means intuitively godel number encoded proof encoded counterpart oe 
wishes explicit system axioms writes rov abbreviation poeq rov poeq prove formally derivability conditions hold 

oe poeq 
poeq poe 
poeq pp poeq easy true existential formula form quantifier free provable true 
purely decidable fact elementary logic 
second routine piece syntax manipulation modus ponens usually basic proof rules 
third bit harder 
converse hold poeq oe sufficient additional assumption consistency provable existential formulas true poeq existential statement true precisely oe 
diagonalization argument godel able exhibit statement oe expressed system 
oe poeq similar techniques applied formal systems including hereditarily finite sets free recursive datatypes possible advantage form formula may quite readable just huge number 
oe poeq means oe system inconsistent 
assuming system consistent oe unprovable furthermore true asserts precisely 
godel incompleteness theorem 
note depends derivability condition 
consistency sufficient rule oe 
consistency certainly oe poeq provable existential statements true oe contradicting consistency 
godel argument shows consistent oeg consistency general imply consistency 
rosser modified godel proof defining rov poeq rov poeq rov oeq oe analog godel sentence oe new notion provability turns just assuming consistency oe oe provable 
assuming system consistent evidently 
godel argument may formalized provability predicate 
essentially means seen remove 
note combining see 
applying poeq oe true construction oe denotes false find pp poeq poeq 
poeq pp poeq poeq 
hand oe trivial poeq 
shows oe 
assertion system consistent usually abbreviated con cons system explicit 
assuming derivability conditions deduced godel second incompleteness theorem system kind considering unable prove consistency 
shown statement consistency logically equivalent unprovable sentence produced proof godel theorem 
noted feferman involved assertion consistency 
fact rosser notion provability get notion consistency con assuming system consistent con con 
manifestly assume rov rov definition system assumed consistent rov 
trivially provable logic second decidable bounded quantification 
putting find rov 
course pain contradicting godel second theorem proved inside logic fail satisfy derivability conditions significance regards transfinite progressions theories discussed 
standard notion provability feferman showed theories zf pa prove consistency finitely axiomatized subsystems produce alternative predicates representing set axioms trick reminiscent rosser construction con provable 
means needs distinguish carefully natural pathological representations axiom set 
resnik discusses philosophical significance fact 
strictly oeq read neg poeq neg negation function encoded formulas 
reflection principles transfinite progressions godel theorems show limitations formal systems point systematic way making system stronger 
axiom system natural way strengthening addition new axiom amounting statement consistency 
gives new system corresponding new provability predicate assertion consistency 
procedure iterated giving 
iteration continued ff 
ff investigated turing showed limiting system constructive ordinals ff arising peano arithmetic repeatedly adding statements consistency capable proving true universal sentences number theory form quantifier free 
example prove fermat theorem true 
turing explorations carried feferman coined term reflection principle assertion statement consistency amounts expression trust system axioms presumably called arises reflecting axioms outside 
contrast arbitrary procedure moving reflection principle provides axioms shall express certain trust system axioms stronger reflection principle assertion soundness respect standard model natural numbers arithmetic theories 
poeq rue poeq stands called global reflection schema expressed logic shown tarski definable predicate rue corresponding arithmetic truth 
express intuitively similar schema oe sentence poeq oe schema known local reflection schema considered turing 
special case oe statement consistency statement strong 
fact proved lob instance schema provable precisely corresponding oe provable 
note godel second theorem special case lob theorem setting oe 
turing conjectured limiting system repeatedly adding local reflection schema properly stronger resulting repeatedly adding statement consistency 
conjecture refuted feferman fact limiting systems equal power 
stronger schema uniform reflection principle poe oe poe really shorthand subst poeq result substituting encoding numeral unique free variable oe 
function subst primitive recursive 
shown kreisel evy respect order number theory equivalent transfinite induction precisely additional property gentzen consistency proof number theory feferman showed transfinite iteration proves true sentences number theory 
possible consistent theory inconsistent addition local reflection schema simple statement consistency 
example godel theorem shows consistent cons con implies cons addition con yields inconsistent system 
follows feferman consistent system remains additions uniform reflection schema 
exposition matters feferman 
original meaning reflection principle slightly specialized statements local reflection schema connection theory metatheory form oe provable true 
example kreisel evy say reflection principle formal system mean roughly formal assertion stating soundness statement oe formalism provable oe valid 
may slight shift perceived metaphor changed usage representation mirrors actual proof system 
stressing role making logical system stronger kreisel evy exploit fact reflection schema unprovable yield way comparing strengths logical systems 
system prove reflection principle properly stronger claimed intuitive significance reflection schema tends proofs easier find simple statement consistency noted special case principle weaker 
nski gives results strength reflection principles 
observe full reflection schema unprovable may happen suitably restricting kinds provability allowed rov analogous schema provable 
particular happens peano arithmetic zermelo fraenkel set theory provability allowed fixed finite set axioms 
discuss situation zf set theory appendix 
troelstra logical complexity formulas proofs heyting arithmetic restricted refer partial reflection schemas 
computational reflection contrast reflection principles consider reflection rule poeq oe addition may inconsistent consider inconsistent system 
consistency guarantees new system consistent theorems 
consistency includes assertions form rov poeq provable true weil referred gentzen justified induction natural numbers induction higher ordinal 
rov poeq true precisely oe 
form reflection different logical systems rule poeq oe provided consistent conservative extension follows usually assume simplicity dealing single logical system 
case important note provability predicate original notion provability new reflection rule 
assuming consistency noted new notion provability extensionally old 
certainly prove consistency inside system expect able duplicate fact 
wishes embed applications reflection rule inside formalized proofs natural gives new notion provability example pp poeq poeq wishes apply reflection inside formalized proof provability predicate results 
possible close procedure single syntactic notion provability satisfies derivability conditions pp poeq poeq lob theorem consistency oe oe system inconsistent 
infinite tower provability predicates ways see description nuprl examples 
suppose predicate dp class formulas oe prove dp poeq poeq case schema conservative extension dp poeq oe forms basis computational reflection theorem proving 
dp recursive predicate encoding efficient decision procedure formulas proofs difficult 
prove correctness theorem dp poeq poeq class formulas oe may prove dp poeq order deduce oe 
fact dp may include condition formula concerned chosen class allowing correctness theorem proven restriction oe 
generalities idea computational reflection formal system stronger deductive process efficient utilizing information avoids having construct formal proofs full detail 
question ask expect achieve worthwhile gains efficiency 
davis schwartz earliest advocates marshal convincing arguments basis ordinary mathematical experience reason expect difficulty precise sense defined various important theorems greatly decreased way 
unable formulate prove metatheorems serve formal demonstration conjecture point suggestive evidence 
known proof theoretic research addition new rules inference called cut free systems drastically decrease length proofs 
seen appropriate algebra rule inference shortens difficulty sentence asserts algebraic identity 
appeal ordinary mathematical experience vague 
experience mizar hol pure mathematics shown hint expansion primitive inferences feasible 
admittedly tiny part mathematics formalized obvious reason expect branches different regard 
proofs involving lot geometric insight prove hard formalize example supported practical experience 
bourbaki project developed large parts mathematics set theory covered volume 
large proofs written formal detail interesting question 
cut free sequent proofs theoretical device dream basing general computer theorem prover second point irrelevant hardly surprising artificially logic sizes proofs explode 
similar way deduction theorem hilbert style proof systems dramatically shorten proofs obviating need lot intermediate steps conceded matthews smaill basin theorem prover hilbert style axiomatization 
judging efficiency basis number inferences regard computational complexity inferences acceptable argument supposed practical utility 
discuss detail 
theoretical potential theoretical perspective certainly true theorems long proofs interesting deductive systems total recursive bound length smallest proof terms logical system decidable bounded proof search required 
modification godel diagonalization argument allows total recursive function exhibit sentence oe property oe rov poeq length poeq proofs oe length bounded poeq decidable oe provable iff true 
false mean exists proof stated length bounds 
oe true proof stated bounds hand proof 
exhibited sentence true provable proofs long interpreting length number symbols proof finite alphabet reasonable measure far practical feasibility goes 
slight gloss recursive functions representable general may represented relation 
suitable large constant function example 
godel pointed lengths proofs provable facts may decrease dramatically logic extended higher orders treatment see buss 
hope reflection rule allow similar savings 
doesn justify quote contained crucial word important 
real question sentences oe just theoretical pathologies hit theorem feasible proof course theorem prover mathematics verification 
far know grounds deciding question discussed papers 
moment examples doesn prove 
analogy incompleteness peano arithmetic theoretical examples unprovable sentences known godel emerged examples paris harrington conceivably called mathematically mainstream 
harder find unfeasible statement say higher order logic set theory 
systems natural deduction called accident appears really correspond mathematicians prove theorems 
gentzen says remarkable existing mathematics easily classifiable constantly recurring forms inference extension methods may desirable theory insignificant practice 
certainly message admittedly limited usage theorem provers pure mathematics 
theoretical grounds bury lcf approach till comes example 
exceptional extension axiom system reasonable response 
examples frequently recur highly implausible 
case adding reflection principle help deal instances yields recursively enumerable set theorems talking machine implementation 
unfeasible statements occur practice 
practical potential seen evidence supposing lcf approach inadequate proofs pure mathematics 
theorem provers usually verification tasks theorems tackled different bigger shallower 
possible sheer size theorems create new problems lcf approach size fully expanded proofs poorer asymptotic behaviour complexity decision procedure 
consider system classical biconditional logic 
logical connective bi implication 
axioms substitution instances sole rule inference variant modus ponens aka detachment le pointed formula provable system propositional variable occurs number times 
showed equivalent valid usual sense observation obtains fragment conventional axiomatization propositional logic 
metatheorem justify saying formula provable simply pairing propositional variables 
striking realistic example algebraic simplification associative commutative laws cancellation 
assertion form justify truth just showing sets fa fb equal 
produce proof primitive inferences need rewrite associative commutative laws sides identical 
look critically example 
compare sets fa fb 
course depends terms represented inside theorem prover 
case problem testing element sets equality known see knuth example worst case assuming constant time pairwise equality test available 
subterms pairwise orderable better log 
hard devise algorithms primitive inferences complexity 
thing exists hol called ac conv 
weren possible techniques explained earlier write higher order function operating syntax special metatheory 
course may significant constant factor difference example hardly especially persuasive perspective efficiency 
argument lcf style coding natural 
extent true encoding algorithm strict formalism programming language unnatural just question degree 
get worthwhile gains reflection may move away simple examples consider kinds complex specialpurpose algorithms implemented provers 
want reason real programs execute real programs simulating inside logic encounter dramatic slowdown probably worse sticking lcf approach 
raises host new questions 
computational reflection code verification reasonable logic quite capable representing wide variety theorem proving procedures encoded formulas recursive functions inside logic 
higher order type theory systems hol nuprl corresponds nicely idealized functional programming language functions total 
similarly nqthm logic corresponds closely pure lisp 
verification nontrivial algorithms may reach way 
example verified boolean simplifier formalized nuprl corresponding lines standard ml code 
going verify recursive function logic run implementation real programming language probably implementation language theorem prover lisp ml ask 
exactly process iteratively adding code running implementation 
trying repair hull ship sailing bringing dry dock 

justify correspondence idealized mathematical description inside logic implementation real programming language 
know awkward features finite limits arithmetic complicated evaluation orders subtle semantics nontermination exceptional conditions 

represent inside logic imperative language features arrays pointers 
argued important reason features want implement certain important proof procedures effectively 
satisfactory answer question depends implementation language 
languages lisp seamless compiled interpreted code easier 
lcf style system quite formidable problems rip open type tinker add new constructor close 
alternative perform final addition code informally performing proof restart enhanced system 
user take responsibility correctly sequencing additions editing source code 
call informal reflection 
completely satisfactory answer second third points don just verify version algorithm verify actual code formal semantics implementation language means embedding syntax formal semantics implementation language logic 
presuppositions notably implementation language suitable formal semantics stable adequate tractable serious proofs 
properties satisfied languages 
difficulty code verification kind serious far aware substantial examples exist 
porting theorem prover language different ml dialect harder system modified proofs formalized semantics old language 
existing instances reflection leap concrete implementation naive syntactical transformation complete formal justification 
correctness proof easier practical purposes distinction description concrete implementation trip 
third point problematical belief efficient proof procedures imperative code required easy associate constructs parts logic convincing way 
arrays identified functions versions floyd hoare logic care needs taken indexing exceptions problem aliasing proofs harder 
difficult question mean correct context 
minimal requirement procedure terminates produces valid 
partial correctness condition prove termination may best cases 
resolution methods performing unbounded search algorithms huet higher order unification great success practice tps isabelle lambda systems may fail terminate 
case complicated heuristic procedures course doubt compiler correctly implements language various issues abstracted away running memory really irrelevant new problems arising reflection 
may quite impossible demarcate formally instances termination expected 
termination proved proof may require complex mathematics required prove partial correctness 
aware particularly convincing practical instances justifying bounds solution diophantine equations requires deep analytic number theory see baker regard 
may happen termination provable stronger logic kreisel fashionable research topic classify logics basis functions prove total 
event want prove complexity bounds need go resources day mathematics 
example consequence efficiency important number theoretic algorithms primality testing discussed bach apparently dependent truth extended riemann hypothesis 
main reason question termination interest versions proof procedures modelled logic total functions 
reasoning partial functions widely believed difficult 
serious attempt address partiality reflected proof procedures surveyed giunchiglia armando cimatti traverso 
extreme point efficient algorithms aren correct strict sense 
may assume machine arithmetic overflow example 
may entirely justifiable assumption basis machine resources exhausted happen 
carry details formal proof complicated 
take analogy physics want analyze dynamics person riding bicycle intuitively know neglect relativistic effects classical mechanics 
arriving general theorem fact read extremely difficult harder simply applying relativistic mechanics place 
computational reflection practice reflection popular topic investigation theorem proving expect large numbers real systems experimented 
experiments limited small projects 
shall examine significant implementations relevant proposal 
fol actual reflection formal reasoning system weyhrauch 
fol system implementation order logic allows reasoning multiple theories 
provides notion simulation structure may described computable partial model 
full model unattainable facts ground terms may uncomputable 
associate logical system simulation structure giving restricted part information model provide shape kind evaluator 
example associate addition symbol evaluator rewrites expressions involving addition ground terms 
process association called semantic attachment stands place full model 
resulting couple called pair context related context includes currently proved set theorems 
standard settheoretic account order logic semantics tweaked simulation structures full models weyhrauch talcott 
contexts fol called meta formalizes syntax fol logic including structure formulas logical derivability 
reflection principle asserted justifies transition object oe meta object poeq 
principle allows statements ways processes usually referred reflection left right reflection right left 
simplest connects inference object theory computation metatheory 
syntax operations inference rules object logic just function symbols metalogic may semantic attachment associated natural operations formulas 
identification theorem proving theory evaluation metatheory coin fol slogan reminiscent lcf 
full logic available formalize metatheory general 
metatheorems proven justify certain kinds inference needing expand original primitives 
simple illustrative example weyhrauch hilbert style axiomatization propositional logic 
obvious defect fol approach check user attaching arbitrary actions function symbols 
logical consistency enforced 
example evaluator transform 
doesn affect fol appeal ai project approach formal verification community better needed 
worked number researchers italy 
fol reimplemented reengineered getfol attempts achieve formal demarcation acceptable proof strategies permitting arbitrary attachments 
interesting summary armando cimatti 
proof strategies object theory simply terms metatheory 
possible demarcate purely syntactically terms implement safe proof strategies called logic tactics 
built existing primitives simple connectives conditional lcf 
possible general metatheoretic reasoning prove necessary 
step considered compile proven proof procedures implementation language apparently naive transliteration efficient interpreting metatheory 
flattening process investigated distinct related basin giunchiglia traverso 
nqthm nqthm prover described detail boyer moore fully automatic theorem prover quantifier free order logic 
logic roots primitive recursive arithmetic pra developed skolem allows arbitrary recursive types just natural numbers 
separate class formulas 
induction rule available explicit quantifiers 
logic represented lisp syntax 
prover real interactive features user may direct prover choosing suitable chain lemmas proved automatically 
earliest practical applications reflection major theorem prover earliest stress placed soundness boyer moore adding reflection principle nqthm 
note word reflection describe process talk adding 
implement simplifier performs cancellation arithmetic equations 
including tautology checker verified 
apparently metatheoretic extension facility widely practice just theoretical flight fancy 
implementation reflection boyer moore prover entail full internalization logic rules inference 
denotation function meaning defined just ordinary recursive function mentioned 
gives value encoded term coding simple logic lisp syntax start assignment variables 
user wishes introduce term transforming function fn new logical primitive usual definitions nqthm prover show recursion equations define unique total function 
eval meaning allows partial recursive functions 
users stick total functions probably easier 
prover prove metatheorem states formula assignment fn formula system untyped automatic second meaning meaning fn 
simplified term equal original term variable assignment 
note transformation function may parametrized free variables provided obeys assignments 
obligations proved system installs compiled interlisp code corresponding fn 
jump deserves detailed consideration 
interlisp behave quite encoded pure lisp environment 
particular finite limit integers silent wrapping overflow 
boyer moore pay careful attention difficulties example custom addition function fails overflow 
applied reasons efficiency correctness 
approach careful informal 
versions nqthm common lisp obviating need precautions 
point note systems automatic type correctness conditions example fn maps terms terms untyped world lisp proved explicitly 
system extended user may posit inconsistent axioms precisely order derive inconsistency 
proof may nonsense newly installed just derive falsity fail arbitrary damaging ways 
guarded 
said cancellation function easily implemented lcf style adequate efficiency 
boyer moore report correctness proof easy authors just day take example truly indicative potential state art 
aware verification imperatively implemented extensive imperative program verification nqthm described boyer yu 
moore produced efficient purely applicative version bdd algorithm verification may tractable depend hash tables 
nuprl nuprl described constable lcf descended theorem prover supports extension including example inductive types type theory described martin lof 
intended environment constructive mathematics computer programming exploring connections 
richness nuprl type theory generates profusion additional primitive inferences compared hol furthermore system stores proof trees concrete objects invocation primitive inferences particularly expensive space clear kinds optimizations looking particular theorems render problematic 
garbage collection time 
applied decision procedures nuprl user community accustomed desirable place theoretical footing 
facts computational reflection especially appealing 
discussed howe connection internalization derivability logic function logic 
nuprl researchers experimented adding explicit reflection rules allowing deduction ph gq 
noted problems fixing single provability predicate allowing embedded instances reflection rule 
nuprl possibilities pursued 
explained knoblock constable 
idea repeatedly adding reflection rules gives rise sequence logics prl prl prl 
reflection rule connects formalized provability level logic level 
complex infinite number levels 
purposes provability prl taken standard notion provability 
far aware practical done scheme 
second alternative described allen constable howe aitken just logic restrict reflection rule 
reflection rule parametrized natural number called reflection level instance reflection rule embedded instances lower reflection level 
feature reflection rule remains conservative extension logic proofs proven inside logic 
step direction described howe 
proposes slight modification nuprl type theory including example denotation better evaluation function allows particularly clean internalization logic semantics 
presence dependent types blurs distinction syntax semantics shouldn read terminology critically 
semantics stratified universe level level evaluation semantics lower universe levels completely formalized 
internal semantics howe able derive reflection rule extending logic 
reflection proper appears theoretical aware practical applications 
position nuprl community issues raised regarding real programming languages entirely clear 
hol reflection done hol slind interesting proposals 
approach distinguished considered previously important respects 
focuses proving properties programs written standard ml formal semantics milner tofte harper 
contrasts approaches examined final jump function inside logic concrete implementation serious programming language appears correspond glaring leap faith 
second points absolute program verification necessary 
suffices show new piece code behaves way piece code implemented normal lcf way composition primitive inference rules 
precisely ml function safe derived rule returning theorem prove function returns term list term pair dest thm may safely incorporate mk thm new rule 
mk thm dest thm abstraction representation functions move concrete implementation sequents type thm theorems 
realistic proposal 
modest requirement proofs program equivalence considerable promise 
suited simple lowlevel proof procedures straightforward inefficient proof terms primitive inferences 
program equivalence appealing instances reasonable proof primitive inferences deviate substantially standard presentation 
far goes may allow reasonably tractable correctness proofs forcing practitioner worry low level codification semantics 
conceivable useful set equational transformations reasoning standard ml programs derived operational semantics standard ml 
hand semantics standard ml trivial certain defects point view correctness proofs 
example says behaviour arithmetic operations practice implementations machine arithmetic infinite precision arithmetic 
takes program verification seriously issues addressed 
hol formal semantics ml syme gunter gunter 
early stages just formalized semantics needed program verification tractable 
approach isolate sufficient core ml implementation hol attempt produce formal semantics 
difficulty arguments correct appeal reflection greatest verification imperative code 
known difficult see mason talcott preliminary direction 
interesting observe slind dealt problem inserting compiled code lcf style implementation 
technique essential class environments relatively new feature new jersey compiler 
may holds interesting lessons incremental extension data types general just connection lcf style theorem proving 
extensibility theorem provers important issue demands rigour taken seriously relative merits reflection pure lcf approach analyzed carefully 
purposes ostensibly metatheoretic reasoning implemented logical extensions 
case various subtly different notions described reflection important distinguish 
interesting point theorem proving technology computational reflection inferences efficient addition new rules 
programming derived rule lcf requires certain discipline complex cases programming skills needed 
certainly argument verifying direct implementation natural 
coding algorithm appears naturally imperative pure functional language 
convincing evidence fundamentally inadequate efficiency point view 
claims hopeless inefficiency lcf style provers real examples limited support theory contradicted practice hol 
looked techniques render lcf proof procedures quite efficient 
clearly established efficient proof procedures implemented hol derived rule moderately large constant factor slowdown 
constant factor may practically important seldom separates tractability intractability 
remarked efficiency proof procedures reason major issue interactive theorem proving 
reflection intellectually attractive idea offers way adding efficient proof procedures maintaining guarantee soundness 
fact despite research reports proposals major practical prover practice speaks 
furthermore argued interesting proof procedures binary decision diagrams depend efficiency imperative features arrays shared data structures 
real implementations written difficult language reason formally 
reflection principles accommodate programs state art program verification needs advance correctness proofs difficult 
difficulties dynamically adding code running implementation need taken seriously 
hard exploit reflection time generating checkable low level proof log 
considerable intellectual practical benefit sticking pure lcf approach hol case questionable 
hol exhibits unusual synergy regard interesting question correct hol necessarily extend systems 
reflection offers interesting ideas challenges isn ready push back boundaries feasible theorem proving 
attempts practical necessity panacea theorem proving real world applications naive 
am grateful john herbert roger hale sri international asking write valuable discussions 
profited conversations advice richard boulton thomas forster mike gordon doug howe ken kunen joseph andy pitts especially konrad slind 
views expressed responsibility identified people named sri 
apart mentioned comments draft version paul tim leonard tom melham john staples especially bob boyer helpful hope led improvements 
appendix kinds reflection interesting survey giunchiglia smaill propose distinction reflection principle strengthening logic process reflection merely making deductive process efficient 
corresponds distinction logical reflection computational reflection 
uses term reflection literature attempt clarify 
add instances fit easily categorization chosen 
example reflection logic programming proposed bowen kowalski blend logical procedural reflection 
perlis perlis discuss self order logic bears relation logical reflection 
mathematical treatment nski gives readable account godel theorems logical reflection schemas 
set theoretic reflection zermelo fraenkel set theory modern variants set theoretic universe cumulative hierarchy sets built empty set possibly collection urelements iterating powerset construction 
successive levels usually written ff ff runs ordinal numbers 
recursive definition splits cases successor limit ordinals ff ff ff 
ff complete universe usually written write ff ff aware set really speech formal assertion ff ordinal ff ff sets contained 
vn finite ordinal hereditarily finite finite members turn hereditarily finite 
infinite set 
zermelo axioms satisfied universe set 
sets arise applying powerset operation finitely empty set infinite set 
axiom replacement available zf zermelo original system show set 
follows recursion axiom replacement construct function range 
axiom union allows collect range new set 
iteration may similarly continued transfinite ordinal 
consequently hierarchy extends need replacement 
set theoretic reflection principle asserts roughly speaking restricted initial portion zf hierarchy course set occurring level reflects structure universe 
crudely speaking property true true ff vague statement taken literally 
example set member clearly false replaced ff consistent relativization set ff member ff true 
kind interpretation reasonable statements obtained 
particular restrict properties expressible orthodox order axiomatization zf set theory natural formalization reflection principle turns provable 
shown montague evy coined term reflection principle initiated thorough study principles 
write oe relativization formula oe set obvious change class means restricting quantifiers oe follows 
reflection schema states formula oe free variables xn ff fi fi ff xn fi oe oe fi ubiquitous picture arrived zermelo years original axiomatization 
proof see example kunen krivine 
special case oe sentence see exist arbitrarily large ordinals fi oe relativization fi simple consequences see zf finitely axiomatizable order logic 
finite set axioms sufficed axiomatize zf form conjunction oe 
reflection schema yields model precisely proves zf existence model oe inside zf 
amounts proving zf consistency inside zf know impossible godel second theorem 
direct proof relying godel theorem possible reflection principle 
sharpening observations demonstrates interesting connection logical reflection principles poeq means oe provable axioms zf hard see partial reflection schema zf poeq oe know zf oe oe zf oe zf oe zf axioms zf 
abbreviating second disjunct know reflection theorem zf ff ordinal ff 
replicating routine proof order logic soundness inside zf zf poeq ff consequently zf poeq oe 
noteworthy consequence reflection principle noted kreisel universes popular category theorists interested providing set theoretic foundation probably unnecessary 
axioms amount asserting reflection principle axioms zf 
finitely axioms proof reflection theorem hold set ff apart applications deductive strength related principles studied evy 
presence zf axioms order reflection schema turns equivalent axioms infinity replacement taken 
raises possibility axiomatize set theory reflection principles 
extended reflection principles example higher order versions introduced bernays turn equivalent additions zf axioms inaccessible cardinals regular fixed points normal functions cardinals 
provide persuasive way motivating additions 
eschew kind formalization simply regard reflection principles quasi philosophical assertions endless indefinitely extensible nature zf hierarchy 
proposal kreisel notions semantic validity second order logic interpreted formal cumulative set theory zf informal set theory permitting example proper classes similar consequences 
formalizations kreisel principle turn equivalent higher order reflection principles 
see example shapiro 
procedural reflection computer programs ultimately run machine code exists memory machine 
purposes useful able step back simple picture contemplating changing relationship running program original source 
obvious examples starting routine exotic connection goes right back montague term reflection different idioms cases 
ffl debugging desirable relate execution program original source code syntax benefit user allow user step program inspecting altering state machine various points 
ffl profiling want associate runtimes function bodies original source may simple relationship portions eventual machine code order identify hot spots code 
ffl self modification commonplace artificial intelligence programs modify light interaction environment 
example chess program may alter play basis past experience 
implementing facilities ad hoc way quite involved easy ordinary users add related facilities 
argued smith general reflective programming language offers uniform flexible way doing things 
compares reflection recursion 
complicated arcane inefficient way programming danger infinite regress 
experience may come seen natural tend implemented efficiently 
promises provide highly flexible facility may implement inexpressible programming constructs adding exception handling language 
developed treatment des rivi eres smith 
smith approach start dialect lisp called lisp lisp mention confusions smith detects mainstream version 
smith argues lisp crosses semantic levels confusing separate processes passing syntax denotation evaluating denotation 
example acceptable lisp scheme implementations 
programs run interpreter code data concrete explicit datastructures 
results lisp ability run code different levels interpretation 
running program level concrete representation run interpreter level 
interpreter may run interpreter level ad infinitum 
crucial points properties program interpreter concrete secondly concrete versions may modified affecting program behaviour 
lisp implementations happens limited extent procedure calls eval supported uniformly compiled code interpreted expressions 
running basic interpreter cpu exhibits multiplicity levels 
reflective approach distinguished unlimited scope homogeneity successive levels 
gives rise potential infinity levels called reflective tower 
smith idea program find lowest level available layers interpretation inefficient rising higher levels necessary 
far practical implementations go experience limited may comprehensive form reflection proposed smith concrete representations separate code executed partial called declarative reflection acceptably efficient 
smith give rigorous discussion intended semantics reflective tower 
undertaken wand friedman gave denotational description additional metacontinuation parameter store state interpreters currently considered 
slightly refined terminology reification process interpreter state available reflection program changes state installs new data 
originally proposed procedural reflection attracted considerable attention object oriented programming community initiated explicitly maes 
approach fits nicely object philosophy programmer world supposed open redefinition facilities communication processes sophisticated ways may hard implement existing systems 
survey maes nardi 
clear reflection practical utility convincingly demonstrated 
procedural reflection high level functional programming language see zhu 

verifying logic synthesis tool nuprl case study software verification 
probst 
eds computer aided verification proceedings fourth international workshop cav number lecture notes computer science montreal canada pp 

springer verlag 
aiello 
representation metaknowledge 
proceedings ieee 
aiello weyhrauch 
meta theoretic reasoning algebra 
bibel kowalski 
eds th conference automated deduction volume lecture notes computer science les arcs france pp 

springer verlag 
allen constable howe aitken 
semantics reflected proof 
proceedings fifth annual symposium logic computer science los alamitos ca usa pp 

ieee computer society press 

quadratic non residue 
annals mathematics 
archer joyce levitt 
eds 
proceedings international workshop hol theorem proving system applications university california davis davis ca usa 
ieee computer society press 
armando cimatti 
building executing proof strategies formal metatheory 
torasso 
ed advances artifical intelligence proceedings third congress italian association artificial intelligence ia ai volume lecture notes computer science torino italy pp 

springer verlag 

issues implementing high integrity proof tool 
see basin giunchiglia kaufmann pp 

bach 
explicit bounds primality testing related problems 
mathematics computation 
baker 
transcendental number theory 
cambridge university press 
bar hillel rabin robinson 
eds 
essays foundations mathematics dedicated fraenkel anniversary 
press hebrew university jerusalem 
edition published jerusalem academic press barwise keisler 
eds 
handbook mathematical logic volume studies logic foundations mathematics 
north holland 
basin giunchiglia kaufmann 
eds 
th international conference automated deduction workshop correctness metatheoretic extensibility automated reasoning systems inria lorraine 
basin giunchiglia traverso 
automating meta theory creation system extension 
trends artificial intelligence proceedings nd congress italian association artificial intelligence ia ai number lecture notes computer science pp 

springer verlag 
basin 
constructive metatheoretic extensibility 
see basin giunchiglia kaufmann pp 

basin constable 
metalogical frameworks 
see huet plotkin jones pp 

reprinted huet plotkin pp 

bernays 
zur der der mengenlehre 
see bar hillel rabin robinson pp 

english translation problem schemata infinity axiomatic set theory muller pp 

bjrner ershov jones 
eds 
partial evaluation mixed computation proceedings ifip tc workshop partial evaluation mixed computation denmark 
north holland 
boulton 
efficiency fully expansive theorem prover 
technical report university cambridge computer laboratory new museums site pembroke street cambridge cb qg uk 
author phd thesis 
bowen kowalski 
amalgamating language metalanguage logic programming 
clark 
eds logic programming number apic studies data processing pp 

academic press 
boyer moore 
computational logic 
acm monograph series 
academic press 
boyer moore 
proving correct efficiently new proof procedures 
boyer moore 
eds correctness problem computer science pp 

academic press 
boyer yu 
automating correctness proofs machine code programs commercial microprocessor 
see kapur pp 

de bruijn 
survey project automath 
seldin hindley 
eds curry essays combinatory logic lambda calculus formalism pp 

academic press 
bryant 
symbolic boolean manipulation ordered binary decision diagrams 
acm computing surveys 
bundy van smaill 
experiments proof plans induction 
journal automated reasoning 
buss 
godel theorems lengths proofs number lines speedup arithmetics 
journal symbolic logic 
carnap 
logical syntax language 
international library psychology philosophy scientific method 
routledge kegan paul 
translated logische syntax der sprache smeaton von new sections german original 

model theoretic algebra 
journal symbolic logic 
chou 
wu method mechanical theorem proving geometry 
journal automated reasoning 
gordon 
eds 
proceedings ifip tc wg international workshop higher order logic theorem proving applications volume ifip transactions computer science technology leuven belgium 
north holland 

eds 
arithmetic proof theory computational complexity 
clarendon press 
constable 
implementing mathematics nuprl proof development system 
prentice hall 
constable murthy 
extracting computational content classical proofs 
huet plotkin 
eds proceedings workshop logical frameworks pp 

reprinted huet plotkin pp 

danvy 
bridge reflection partial evaluation 
see bjrner ershov jones pp 

davis 
ed 
undecidable basic papers undecidable propositions unsolvable problems computable functions 
raven press ny 
davis schwartz 
metatheoretic extensibility theorem verifiers proof checkers 
computers mathematics applications 
dudley 
real analysis probability 
wadsworth brooks cole mathematics series 
wadsworth brooks cole 
edwards 
kronecker views foundations mathematics 
rowe 
eds history modern mathematics volume ideas reception pp 

academic press 

principle local functors 
proceedings ams 
feferman 
metamathematics general setting 
fundamenta mathematicae 
feferman 
transfinite recursive progressions axiomatic theories 
journal symbolic logic 
feferman 
finitary inductively logics 
ferro 
eds logic colloquium studies logic foundations mathematics padova italy pp 

north holland 
feferman 
reflecting incompleteness 
journal symbolic logic 
felty miller 
specifying theorem provers higher order logic programming language 
see lusk overbeek pp 

gentzen 
uber das logische 
mathematische zeitschrift 
gentzen dissertation 
english translation investigations logical deduction szabo 
giunchiglia armando cimatti traverso 
steps provably correct system synthesis system code 
see basin giunchiglia kaufmann pp 

giunchiglia smaill 
reflection constructive nonconstructive automated reasoning 
abramson rogers 
eds meta programming logic programming pp 

mit press 
godel 
uber formal der principia mathematica und systeme fur mathematik und physik 
english translation formally undecidable propositions principia mathematica related systems van heijenoort pp 
davis pp 

godel 
uber die lange von 
ergebnisse eines mathematischen 
english translation length proofs davis pp 


recursive number theory 
studies logic foundations mathematics 
north holland 
gordon 
representing logic lcf metalanguage 

ed tools notions program construction advanced course pp 

cambridge university press 
gordon hale herbert von wright wong 
proof checking hol system 
see basin giunchiglia kaufmann pp 

gordon melham 
hol theorem proving environment higher order logic 
cambridge university press 
gordon milner wadsworth 
edinburgh lcf mechanized logic computation volume lecture notes computer science 
springer verlag 
harper honsell plotkin 
framework defining logics 
proceedings second annual symposium logic computer science ithaca ny pp 

ieee computer society press 
harrison 
hol decision procedure elementary real algebra 
see joyce seger pp 

harrison 
binary decision diagrams hol derived rule 
computer journal 
appear 
harrison th ery 
extending hol theorem prover computer algebra system reason reals 
see joyce seger pp 

van heijenoort 
ed 
frege godel source book mathematical logic 
harvard university press 
hoffmann donnell 
pattern matching trees 
journal acm 
hoover mccullough 
verifying launch interceptor routines asymptotic method 
ora internal report 
howe 
computational metatheory nuprl 
see lusk overbeek pp 

howe 
reflecting semantics reflected proof 
aczel simmons wainer 
eds proof theory pp 

cambridge university press 
huet 
unification algorithm typed calculus 
theoretical computer science 
huet plotkin 
eds 
logical frameworks 
cambridge university press 
huet plotkin 
eds 
logical environments 
cambridge university press 
huet plotkin jones 
eds 
proceedings second workshop logical frameworks 
available ftp ftp dcs ed ac uk export bra proc dvi joyce seger 
eds 
proceedings international workshop hol theorem proving system applications volume lecture notes computer science ubc vancouver canada 
springer verlag 
joyce seger 
hol voss system model checking inside general purpose theorem prover 
see joyce seger pp 

jutting van checking landau grundlagen automath system 
ph 
thesis eindhoven university technology 
kapur 
ed 
th international conference automated deduction volume lecture notes computer science saratoga ny 
springer verlag 
knoblock constable 
formalized metareasoning type theory 
proceedings annual symposium logic computer science cambridge ma usa pp 

ieee computer society press 
knuth 
art computer programming volume sorting searching 
addison wesley series computer science information processing 
addison wesley 
kreisel 
interpretation non proofs part ii interpretation number theory applications 
journal symbolic logic 
kreisel 
uses metamathematics 
british journal philosophy science 
kreisel 
mathematical logic 

ed lectures modern mathematics vol 
iii pp 

wiley 
kreisel 
informal rigour completeness proofs 
lakatos 
ed problems philosophy mathematics proceedings international colloquium philosophy science bedford college regent park london pp 

north holland 
see discussion pp 

kreisel krivine 
elements mathematical logic model theory revised second ed 
studies logic foundations mathematics 
north holland 
edition 
translation french el ements de logique math ematique th eorie des 
kreisel evy 
reflection principles establishing complexity axiomatic systems 
zeitschrift fur mathematische logik und grundlagen der mathematik 
krivine 
axiomatic set theory 
synthese library 
reidel publishing 
translation french th eorie des ensembles published presses de france paris 
translated david miller 

proof logging proof checking 
see basin giunchiglia kaufmann pp 

kumar schneider 
integrating order automatic prover hol environment 
see archer joyce levitt pp 

kunen 
set theory independence proofs volume studies logic foundations mathematics 
north holland 
landau 
foundations analysis arithmetic rational irrational complex numbers 
supplement textbooks differential integral calculus third ed 
chelsea publishing 
translated german grundlagen der analysis 
le 
eines systems der grundlagen der mathematik 
fundamenta mathematicae 
english translation fundamentals new system foundations mathematics barnett vol 
ii pp 

evy 
principles reflection axiomatic set theory 
fundamenta mathematicae 
lob 
solution problem leon henkin 
journal symbolic logic 
lusk overbeek 
eds 
th international conference automated deduction volume lecture notes computer science argonne illinois usa 
springer verlag 
maes 
concepts experiments computational reflection 
meyrowitz 
ed object oriented programming systems languages applications proceedings oopsla orlando florida pp 

association computing machinery 
special issue sigplan notices vol 
number 
maes nardi 
eds 
meta level architectures reflection 
north holland 
gunter 
studying ml module system hol 
see melham pp 

martin lof 
constructive mathematics computer programming 
hoare shepherdson 
eds mathematical logic programming languages prentice hall international series computer science pp 

prentice hall 
mason talcott 
local variables operational reasoning 
proceedings seventh annual ieee symposium logic computer science santa cruz ca usa pp 

ieee computer society press 
matthews 
theory metatheory fs publication unknown 
matthews smaill basin 
experience fs framework theory 
see huet plotkin jones pp 

reprinted huet plotkin pp 

melham 
automating recursive type definitions higher order logic 
birtwistle subrahmanyam 
eds current trends hardware verification automated theorem proving pp 

springer verlag 
melham 
higher order logic hardware verification volume cambridge tracts theoretical computer science 
cambridge university press 
revision author phd thesis 
melham 
eds 
higher order logic theorem proving applications proceedings th international workshop volume lecture notes computer science 
springer verlag 
milner 
implementation applications scott logic computable functions 
acm sigplan notices 
milner tofte 
commentary standard ml 
mit press 
milner tofte harper 
definition standard ml 
mit press 
mod 
procurement safety critical software defence equipment 
interim defence standard uk ministry defence directorate standardization house brown street glasgow ex uk 
montague 
fraenkel addition axioms zermelo 
see bar hillel rabin robinson pp 

edition published jerusalem academic press moore obdd algorithm atp community 
journal automated reasoning 
muller 
ed 
sets classes paul bernays number studies logic foundations mathematics 
north holland 
owre rushby shankar 
pvs prototype verification system 
see kapur pp 

paris harrington 
mathematical incompleteness peano arithmetic 
see barwise keisler pp 

paulson 
logic computation interactive proof cambridge lcf 
number cambridge tracts theoretical computer science 
cambridge university press 
paulson 
isabelle generic theorem prover volume lecture notes computer science 
springer verlag 
contributions tobias nipkow 
perlis 
languages self foundations 
artificial intelligence 
perlis 
languages self ii knowledge belief modality 
artificial intelligence 
pottinger 
completeness hol logic preliminary report 
posted info hol mailing list th jan 
available info hol archive anonymous ftp ftp cl cam ac uk directory info hol archive 
ramsey 
foundations mathematics 
proceedings london mathematical society 
reif 
reflection mechanism kiv structured specifications 
see basin giunchiglia kaufmann pp 

resnik 
philosophical significance consistency proofs 
journal philosophical logic 
reprinted shanker pp 

des rivi eres smith 
implementation procedurally reflective languages 
conference record acm symposium lisp functional programming pp 

association computing machinery 
robinson 
model theory metamathematics algebra 
studies logic foundations mathematics 
north holland 
rosser 
extensions theorems godel church 
journal symbolic logic 
rudnicki 
overview mizar project 
unpublished available anonymous ftp cs ualberta ca pub mizar mizar tar rushby 
design choices specification languages verification systems 
see archer joyce levitt pp 

schneider kumar 
efficient representation computation tableaux proofs 
see gordon pp 

seidenberg 
new decision method elementary algebra 
annals mathematics 
shankar 
metamathematics machines godel proof volume cambridge tracts theoretical computer science 
cambridge university press 
shanker 
ed 
godel theorem focus philosophers focus series 
helm 
shapiro 
foundations case second order logic 
number oxford logic guides 
clarendon press 
slind 
implementation higher order logic 
technical report university calgary computer science department university drive calgary alberta canada tn 
author masters thesis 
slind 
adding new rules lcf style logic implementation 
see gordon pp 

smith 
reflection semantics lisp 
conference record th acm symposium principles programming languages pp 

association computing machinery 
nski 
consistency reflection 
colloque international de logique volume pp 

editions du centre national de la recherche scientifique 
nski 
self modal logic 
springer verlag 
nski 
incompleteness theorems 
see barwise keisler pp 

barnett 
eds 
law le collected works 
kluwer academic publishers 
syme 
reasoning formal definition standard ml hol 
see joyce seger pp 

szabo 
ed 
collected papers gerhard gentzen studies logic foundations mathematics 
north holland 
takeuti 
applications logic mathematics 
number publications mathematical society japan 
tokyo 
number memorial lectures 
talcott weyhrauch 
partial evaluation higher order abstractions reflection principles system building tools 
see bjrner ershov jones pp 

tarski 
der den sprachen 
studia philosophica 
english translation concept truth formalized languages tarski pp 

tarski 
ed 
logic semantics metamathematics 
clarendon press 
taylor 
constructions metalanguage 
lfcs report series ecs lfcs laboratory foundations computer science department computer science university edinburgh king buildings edinburgh eh jz uk 
troelstra 
metamathematical investigation intuitionistic arithmetic analysis 
number lecture notes mathematics 
springer verlag 
second corrected edition available series number university amsterdam 
turing 
systems logic ordinals 
proceedings london mathematical society 
reprinted davis pp 

gunter 
hol ml 
see joyce seger pp 

wand friedman 
mystery tower revealed description reflective tower 
conference record acm symposium lisp functional programming pp 

association computing machinery 
weil 
foundations algebraic geometry volume ams colloquium publications 
american mathematical society 
revised edition 

efficient conversions partial evaluation 
poster session hol users meeting published participants supplementary proceedings 
available web www dcs glasgow ac uk hug sproc html 
weyhrauch 
prolegomena theory mechanized formal reasoning 
artificial intelligence 
weyhrauch 
example fol metatheory 
loveland 
ed proceedings th conference automated deduction number lecture notes computer science new york pp 

springer verlag 
weyhrauch talcott 
logic fol systems formulated set theory 
jones hagiya sato 
eds logic language computation festschrift honor satoru number lecture notes computer science pp 

springer verlag 
wong 
recording hol proofs 
technical report university cambridge computer laboratory new museums site pembroke street cambridge cb qg uk 
von wright 
representing higher order logic proofs hol 
see melham pp 

wu wen decision problem mechanization theorem proving elementary geometry 
sinica 
zhu 
computational reflection 
acm sigplan notices 

