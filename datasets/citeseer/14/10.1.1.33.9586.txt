fault tolerance replication distributed systems rachid guerraoui andre schiper departement informatique ecole polytechnique de lausanne lausanne switzerland 
tutorial fault tolerance replication distributed systems 
start de ning linearizability correctness criterion replicated services objects main classes replication techniques primary backup replication active replication weintroduce group communication infrastructure providing adequate multicast primitives implement primary backup replication active replication 
discuss implementation fundamental group multicast primitives total order multicast view synchronous multicast 
dependability reliability availability biggest trends software technologies 
past considered acceptable services unavailable failures 
rapidly changing requirement high software reliability availability continually increasing domains nance booking reservation industrial control telecommunication solution achieving fault tolerance build software top faulttolerant replicated hardware 
may viable solution application classes successfully pursued companies tandem 
economic factors motivated search cheaper software fault tolerance software replication 
principle readily understood techniques required implement replication pose di cult problems 
presents survey techniques developed mid eighties implement replicated services called objects 
discuss fault tolerance need specify types failures considered 
assume general model distributed system system consists set processes connected communication links processes exchange messages 
process correct 
correct process process behaves speci cation 
incorrect process process crashes process behaves maliciously 
crashed process stops receiving sending appears proc 
reliable software technologies ada europe springer verlag lncs 
messages malicious process send messages follow speci cation 
consider crash failures ignore malicious behavior called byzantine failures 
considering behavior communication links distinguish basic system models asynchronous system model synchronous system model 
synchronous system model assumes transmission delay messages sent communication links bounded known value 
asynchronous system model set bound transmission delay messages 
asynchronous model attractive practical point view consider model 
property require communication links channel reliability message sent process process eventually received correct 
possibility message retransmission channel reliability property prevent link failures assume link failures eventually repaired 
characterizes distributed system consider 
rest organized follows 
section de nes correctness criterion replicated servers called linearizability 
criterion gives client processes illusion non replicated servers 
section introduces main classes replication techniques ensure linearizability 
classes primary backup technique active replication technique 
section introduces group communication framework de nition multicasts primitive required implement primary backup replication active replication 
section discusses implementation important group multicast primitives total order multicast view synchronous multicast 
section concludes mentioning existing distributed platforms support replication 
replica consistency basic model notations consider set sequential processes fp set objects 
object state accessed processes set operations 
operation process object pair invocation response 
issuing invocation process blocked receives matching response 
operation invocation noted op arg arg arguments operation op 
operation response noted ok res res result returned 
pair invocation response noted op arg ok res 
order tolerate process crash failures logical object physical replicas located di erent sites distributed system 
replicas object noted invocation replica located site handled process located assume crashes exactly crashes 
replication transparent client processes means replication change way invocation operations corresponding responses noted 
consistency criteria consistency criterion de nes result returned operation 
seen contract programmer system implementing replication 
main consistency criteria de ned literature linearizability sequential consistency causal consistency 
cases operation performed state object 
consistency criteria di er de nition state 
linearizability restrictive consistency criteria linearizability de nes strongest consistency criterion causal consistency de nes weakest consistency criteria 
linearizability sequential consistency de ne informally called strong consistency criterion causal consistency de nes weak consistency criterion 
causal consistency includes sequential consistency execution satis es sequential consistency satis es causal consistency sequential consistency included linearizability execution satis es linearizability satises sequential consistency 
applications require strong consistency linearizability sequential consistency programmers illusion non replicated objects 
consider linearizability 
reason considering linearizability sequential consistency justi ed practical considerations 
turns linearizability easier implement just sequential consistency 
words implementations strong consistency turn ensure linearizability 
linearizability give informal de nition linearizability 
formal de nition 
operation pair invocation response op arg ok res 
consider global real time clock inv bethe time invokes operation op object res time matching response received operations said sequential noted response precedes invocation res inv 
operations said concurrent hold 
note concurrent operations 
relation de ne linearizability follows 
execution linearizable exists sequence including operations conditions hold operations appears sequence sequence legal object subsequence operations belongs sequential speci cation illustrate de nition consider object de ning fifo queue initially empty enqueue noted enq dequeue noted deq operations execution invocations responses time enq time enq time xok time xok time deq time deq time xok time xok execution consists operations enqueue operation pi invoked global time completed time enqueue operation pj invoked time completed time dequeue operation pi invoked time completed time dequeue operation pj invoked time completed time 
execution linearizable exhibit legal sequence 
sequence legal belongs sequential speci cation fifo queue enqueued rst operation operation rst dequeue operation correctly returns second dequeue operation correctly returns consider operation returned time 
case execution linearizable sequence belongs sequential speci cation fifo queue constructed execution 
discuss section circumstances happened 
ensuring linearizability consider fifo queue order fault tolerant implemented replicas consider execution section assume replicas observe sequence events replica receives invocations order enq enq deq deq replica receives invocations order enq enq deq deq 
replica handles invocations sequentially order received 
replica sends responses ok top ok top replica sends replies ok ok consider responses received replica get execution section linearizable 
considers response considers response processes get response ok execution linearizable 
problem scenario replicas receive invocations order 
similar problem occur crash client process replica say handles invocation replica 
su cient condition ensure linearizability replicas agree set invocations handle order handle invocations conditions expressed formally follows atomicity 
invocation op arg replica object handles invocation correct non crashed replica handles invocation op arg 
order 
invocations op arg op arg replicas handle invocations handle order 
replication techniques linearizability correctness criterion replicated objects 
section fundamental classes techniques ensure linearizability primary backup replication technique active replication technique 
rst technique process called primary ensures centralized control 
centralized control second technique 
read write techniques designed context le systems databases 
primary backup replication primary backup strategy replicas called primary plays special role fig 
receives invocations client process sends response back 
object primary replica noted prim 
replicas called backups 
backups interact primary interact directly client process 
consider invocation op arg issued absence crash primary invocation handled follows process sends invocation op arg replica prim 
primary prim receives invocation performs 
operation response res available state prim updated 
point prim sends update message res backups identi es invocation res response state update describes state update primary resulting invocation 
reception update message backups update state send back primary need res discussed 
primary received ack correct non crashed backups response sent top client process primary replica backup replica backup replica op arg ok res pi invocation response update ack ack fig 

primary backup technique object primary crash scheme obviously ensures linearizability order primary receives invocation de nes total order invocations object 
ensuring linearizability despite crash primary di cult 
case crash primary cases distinguished primary crashes sending update message backups fig 
primary crashes sending update message client receives response fig 
primary crashes client received response fig 

cases new unique primary selected 
cases client receive response invocation suspect failure 
having learned identity new primary client reissue invocation 
case invocation considered new invocation new primary 
case di cult case handle 
atomicity ensured backups receive update message receive come back issue section 
backups receive message case similar case 
backups receive update message state backups updated operation client process client get response reissue invocation 
information res needed case avoid handling invocation twice produce inconsistent state invocation idempotent 
new primary receives invocation handling invocation immediately sends response res back client 
assume perfect failure detection mechanism apart atomicity issue raised primary backup replication technique relatively easy implement 
implementation complicated case asynchronous system model failure detection mechanism reliable 
view synchronous communication paradigm section de nes communication semantics ensures correctness primary backup protocol called blocking primary send reply client having received certain number acks backups 
non blocking protocol possible speci system assumptions 
client process replica replica replica op arg invocations ok res responses fig 

active replication technique object primary backup technique case unreliable failure detection mechanism 
main advantages primary backup technique allow non deterministic operations 
case active replication technique described 
active replication active replication technique called state machine approach replicas play role centralized control technique 
consider object invocation op arg issued fig 
invocation op arg replicas replica processes invocation updates state sends response back client client waits receives rst response receives majority identical responses 
replicas behave maliciously byzantine failures excluded client process waits rst response 
replicas behave maliciously byzantine failures replicas needed tolerate faulty replicas 
case client waits receive identical responses 
active replication technique requires invocations client processes received non faulty replicas order 
requires adequate communication primitive ensuring order atomicity property section 
primitive called total order multicast atomic multicast 
precise semantics total order multicast primitive section 
apart byzantine failure issue tradeo active replication primary backup replication active replication requires operations replicas deterministic case primary backup technique 
determinism means outcome operation depends initial state replica sequence previous operations performed replica 
active replication crash replica transparent client process client needs reissue request 
primary backup technique crash backups transparent client crash primary 
case crash primary latency experienced client time invocation reception response increase signi cantly 
unacceptable real time applications 
active replication technique uses resources technique invocation processed replica 
read write techniques replication techniques introduced speci context le systems databases 
techniques viewed combination primary backup active replication techniques additional assumptions replicated objects accessed read write operations underlying concurrency control protocol ensuring total order provided 
available copies replication method ensures atomicity bya read write technique read operation performed available copy write operation executed available copies 
available copies de ned reliable failure detection mechanism 
copy object crashes removed set available copies 
requirement reliable failure detection mechanism clearly means technique prevent inconsistencies case communication link failures 
quorum methods introduced prevent inconsistencies case link failures 
basic idea initially introduced gi ord consists assigning votes replica object de ning read quorums write quorums read quorums write quorums intersect write quorums intersect 
read operation performed replica seen preceding write operations ensures atomicity condition 
mentioned ordering condition assumed guaranteed underlying transactional system locking mechanism 
technique called static voting read write quorums change life time system 
static voting serious drawback case failures quorums impossible obtain 
dynamic voting introduced burkhard problem 
basic idea crash system recon gures new subset replicas new quorums de ned 
dynamic voting techniques extended allow non identical read write quorums el abbadi toueg 
quorum technique extended general operations just read write operations herlihy 
group communication group abstraction constitutes adequate framework de nition multicast primitives required implement replication techniques introduced previous section 
consider replicated object group noted abstractly represent set replicas members replicas address message set replicas group constitutes convenient logical addressing facility sending message replicas done explicitly naming set replicas object static groups vs dynamic groups fundamentally di erent types groups static groups dynamic groups 
group group membership change life time system 
mean members group supposed crash 
simply means membership changed re ect crash members replica crash possible recovery remains member group static groups adequate context active replication active replication require speci action taken case crash replicas 
true primary backup replication technique primary crashes membership group changed order elect new primary 
dynamic group group membership changes life time system 
membership changes example result crash member crashed replica removed group 
recovers rejoins notion view model evolving membership initial membership noted th membership history group represented sequence views 
group communication active replication wehave seen section active replication requires total order multicast primitive 
group note total order multicast message group primitive formally de ned properties order 
consider primitives replicas ifx deliver deliver messages order 
atomicity 
consider primitive 
replica delivers correct replica delivers termination 
consider primitive executed process ifp iis correct crash correct replica eventually delivers properties consider message delivery message reception 
basically replica rst receive message perform coordination replicas guarantee properties deliver message execute invoked operation 
termination condition liveness condition prevents trivial implementation order atomicity conditions consisting delivering message 
liveness condition ensures progress system 
implementation primitive discussed section 
de nition uses notion correct replica 
tricky issue system model replicas crash recover 
replica crashed time obligation deliver message 
time replica recovers delivered messages multicast time problem handled mechanism called state transfer replica recovers crash state transfer mechanism allows get operational replica date state including messages state transfer 
state transfer implemented follows cast primitive 
replica recovers crash fig 
replica starts executing state req message requesting state containing identity ofthe replica replica delivery state req sends current state necessary replica send state sends state discuss optimization 
note state sent primitive 
replica waits deliver state req message ignoring message delivered state req message message 
message state req delivered waits receive current state members bu ers messages delivered state req message 
reception state message initializes state handles sequence bu ered messages updates state accordingly 
done replica handles usual messages delivered state message 
client process client process replica replica replica recovery state req state fig 

state transfer state req messages group communication primary backup replication group primary backup replication scheme require primitive 
primary de nes order invocations 
primary backup technique requires dynamic groups order de ne new primary current primary crashed 
primary object easily de ned sequence views group assume view replicas ordered deterministic rule primary de ned view rst replica rule example fx ordering de ned replica number primary view new view fx de ned replica new primary 
view delivered correct members replica able learn identity primary 
notice sequence views de ning history group irrelevant replica removed view really crashed incorrectly suspected crashed 
words irrelevant failure detection mechanism reliable 
summarize primary backup technique uses primary order invocations requires mechanism order views 
ensuring order views su cient ensure correctness replication technique 
illustrate problem consider example initially view fx primary fig 
primary receives invocation handles crashes sending update message backups update message received new view fx de ned new primary 
states inconsistent 
client process primary replica backup replica backup replica op arg invocation crash update ack group fig 

primary backup technique atomicity problem vertical dotted lines represent time view delivered replicas inconsistency due non atomicity update multicast sent primary backups update message received backups 
inconsistency avoided primary sends update message backups correct backups receive message 
atomicity semantics context dynamic membership called view synchronous multicast 
start de ning view synchronous multicast noted show semantics ensures consistency replicas primary backup technique 
view synchronous multicast 
consider dynamic group sequence views 
local time replica delivers message containing composition view 
time stamps message current view number assume message time stamped view number members view 
view 
replicas deliver delivering deliver 
illustrates de nition 
view synchronous multicast property satis ed scenario scenario scenario 
scenario delivers 
scenario delivers delivering new view violating de nition view synchronous multicast 
understand de nes atomicity condition de ne replica correct view 
view atomicity ensures message multicast members delivered correct members 
primary view crashes new view de ned replicas deliver update message primary 
replicas new scenario scenario scenario group group group fig 

view synchronous multicast scenario satis es de nition scenario view share state ensures consistency 
state transfer 
state transfer mechanism required dynamic groups 
case static group state transfer requested recovering replica 
dynamic groups need recovering replica ask state transfer 
recovery calls join operation 
join operation launches view change protocol leading de nition new view including delivery member primary view sends state implementation issues section speci cation total order multicast primitive required active replication 
de ned view synchronous multicast primitive context dynamic groups primary backup replication technique 
discuss implementation multicast primitives 
total order multicast asynchronous systems total order multicast algorithms asynchronous system model proposed literature 
algorithms classi ed symmetric asymmetric symmetric algorithm processes perform code asymmetric algorithm process plays special role de nes ordering messages 
asymmetric algorithms require phases cient subject contamination problem 
token algorithms classi ed symmetric asymmetric algorithms 
algorithms assume dynamic group model underlying layer implementing view synchronous multicast 
total order multicast related fundamental result faulttolerant distributed computing impossibility solving consensus problem asynchronous systems consensus de ned section 
result known fischer lynch paterson impossibility result flp impossibility result states deterministic algorithm solves consensus asynchronous system single process crash 
result applies total order multicast problems equivalent 
equivalence problems de ned concept reduction problem reduces problem algorithm ta transforms algorithm algorithm problems equivalent reduces reduces problems equivalent problems solved solved 
consensus total order multicast equivalent algorithm implementing primitive asynchronous system single process crash 
means algorithm implementing possible de ne run conditions de ning order atomicity termination violated 
show section get flp impossibility result augmenting asynchronous system model unreliable failure detectors 
show section augmented system model de nes framework total order multicast problem solved primitive implemented 
view synchronous multicast asynchronous systems view synchronous multicast introduced isis system implementation uses output group membership protocol delivers sequence views dynamic group model ush protocol 
pointed ush protocol lead certain circumstances violate view synchronous multicast de nition proposes correct implementation view synchronous multicast 
shown consensus reduces view synchronous multicast problem view synchronous multicast problem solved consensus solved 
flp impossibility result applies view synchronous multicast problem implementation primitive 
circumvent impossibility result consider asynchronous system model augmented unreliable failure detectors 
sketch section algorithm consensus solves view synchronous multicast problem implements primitive 
consensus problem previous sections pointed fundamental role played consensus problem fault tolerant distributed computing 
consensus problem de ned set processes 
process proposes initially value taken set possible values said initial value processes decide common value properties hold agreement 
correct processes decide di erently 
validity 
process decides proposed process 
termination 
correct process eventually decides 
agreement condition allows incorrect processes decide di erently correct processes 
stronger version consensus problem called uniform consensus forbids incorrect processes decide di erently correct processes 
uniform consensus de ned uniform agreement property uniform agreement 
processes correct decide di erently 
failure detectors order overcome flp impossibility result chandra toueg proposed augment asynchronous system model notion unreliable failure detector 
failure detector seen set failure detector modules module attached process system 
failure detector module maintains list processes currently suspects crashed 
process suspects process local time means local time process list suspected processes maintained suspicions essentially implemented time outs means failure detector module mistakes incorrectly process suspicions stable 
time suspects learns suspicion incorrect removes list suspected processes 
chandra toueg de ne various classes failure detectors 
class speci ed property accuracy property 
completeness property puts condition detection crashed processes accuracy property restricts mistakes failure detector 
failure detector classes de ned chandra toueg consider class eventually strong failure detectors noted de ned strong completeness eventual weak accuracy properties strong completeness 
eventually crashed process permanently suspected correct process 
eventual weak accuracy 
eventually correct process suspected correct process 
failure detector class important failure detector class allows solve consensus asynchronous system majority correct processes majority processes crash 
algorithm solving consensus assumptions described 
shown weakest class possible solve consensus asynchronous system majority correct processes shown algorithm solves consensus asynchronous system unreliable failure detectors solves uniform consensus problem 
problems identical assumptions 
reduction total order multicast consensus sketch chandra toueg algorithm total order multicast 
algorithm transforms total order multicast problem consensus 
transformation called reduction total order multicast consensus 
enables implement primitive consensus 
consider static group processes messages algorithm launches multiple independent instances consensus processes various consensus instances identi ed consensus number decides batch messages noted batch 
process delivers message order messages batch delivered messages batch messages batch delivered deterministic order order de ned identi ers 
various instances consensus de ned follows 
message message rst multicast unordered multicast 
received put bu er undelivered messages noted starts consensus say consensus number initial result proven failure detector class 
failure detector classes equivalent 
value consensus number current value process executes consensus algorithm 
consensus solved batch decided process delivers messages batch deterministic order removes messages batch point non empty starts consensus number 
starts consensus number non empty 
reduction view synchronous multicast consensus transformation view synchronous multicast consensus complicated transformation total order multicast consensus 
main ideas sketched 
additional details reduction instance generic paradigm called dynamic terminating multicast 
consider implementation view synchronous multicast group solution consists launching multiple independent instances consensus identi ed consensus number decides batch messages batch membership view 
process learning decision consensus number rst delivers messages batch delivered delivers view 
consensus number performed processes initial view processes current view various instances consensus notion stable message 
message multicast view stable local predicate true knows process received process received message time period stable hold multicasts message req view view order launch consensus number decide view 
process receiving req view message replies multicasting non stable messages reply multicast set processes solve consensus problem number way replies de ne initial value consensus problem 
concluding remarks survey problems related achieving fault tolerance replication distributed systems 
linearizability introduced correctness criterion active replication primary backup main classes replication techniques 
total order multicast primitive introduced adequate primitive support active replication view synchronous multicast primitive options equivalent di erence discussed 
introduced adequate primitive support primary backup technique 
conceptual di culty implementing primitives asynchronous system related fischer lynch paterson impossibility result consensus 
shown chandra toueg impossibility result overcome augmenting asynchronous system model unreliable failure detectors satisfy de ned completeness accuracy properties 
de nes framework total order multicast view synchronous multicast primitives implemented 
reduction consensus constitutes framework right way implement primitives 
real issue achieving fault tolerance replication related implementation group multicast primitives 
led development group communication platforms provide application programmer adequate multicast primitives required implement replication 
isis best known systems 
initially developed cornell university academic project isis commercial product marketed rst isis distributed systems ids subsequently computers 
platforms built world include horus cornell university transis hebrew university jerusalem totem university california santa barbara amoeba free university amsterdam university arizona tucson delta esprit project phoenix federal institute technology lausanne 
systems delta assume asynchronous system model 
despite existence various platforms provide nal answer application needs 
systems unnecessarily complex way di cult er right abstractions application programmer ensure correctness speci scenario cases nally provide precise characterization conditions liveness ensured system 
design implementation adequate group communication platforms remains interesting active research area 

el abbadi toueg 
maintaining availability partitioned replicated databases 
acm trans 
database systems june 

ahamad burns 
causal memory de nitions implementations programming 
tr git cc georgia institute technology july 

amir moser melliar smith agarwal 
fast message ordering membership logical token passing ring 
ieee th intl 
conf 
distributed computing systems pages may 


de de systemes 
phd thesis universite sud centre orsay january 

birman 
process group approach reliable distributed computing 
comm 
acm december 

birman joseph 
reliable communication presence failures 
acm trans 
computer systems february 

birman schiper stephenson 
lightweight causal atomic group multicast 
acm trans 
computer systems august 

marzullo schneider toueg 
primary backup approach 
mullender editor distributed systems pages 
acm press 

chandra hadzilacos toueg 
weakest failure detector solving consensus 
technical report department computer science cornell university may 
preliminary version appeared proceedings eleventh acm symposium principles distributed computing pages 
acm press august 

chandra toueg 
unreliable failure detectors reliable distributed systems 
technical report department computer science cornell university august 
preliminary version appeared proceedings tenth acm symposium principles distributed computing pages 
acm press august 

chang 
reliable broadcast protocols 
acm trans 
computer systems august 

burkhard 
consistency recovery control replicated files 
proceedings th symposium operating systems principles pages 

fischer lynch paterson 
impossibility distributed consensus faulty process 
journal acm april 

gi ord 
weighted voting replicated data 
proceedings th symposium operating systems principles pages december 

skeen chan dayal fox ries 
recovery algorithm distributed database system 
proc 
nd acm sigmod symposium principles database systems march 

gopal 
fault tolerant broadcast multicasts problem inconsistency contamination 
phd thesis cornell university ithaca ny march 

guerraoui 
revisiting relationship non blocking atomic commitment consensus 
th intl 
workshop distributed algorithms pages 
springer verlag lncs september 

guerraoui schiper 
transaction model vs virtual synchrony model bridging gap 
theory practice distributed systems pages 
springer verlag lncs 

hadzilacos toueg 
fault tolerant broadcasts related problems 
mullender editor distributed systems pages 
acm press 

herlihy 
quorum consensus replication method data types 
acm trans 
computer systems february 

herlihy wing 
linearizability correctness condition concurrent objects 
acm trans 
progr 
languages syst 

kaashoek tanenbaum 
group communication amoeba distributed operating system 
ieee th intl 
conf 
distributed computing systems pages may 

kaashoek tanenbaum hummel bal 
cient reliable broadcast protocol 
operating systems review october 

lamport 
computer correctly executes multiprocess programs 
ieee trans 
computers 

gligor 
fault tolerant protocol atomic broadcast 
ieee trans 
parallel distributed syst july 

malki amir dolev kramer 
transis approach high available cluster communication 
technical report cs institute computer science hebrew university jerusalem 


conception implementation toolkit building fault tolerant distributed applications large scale networks 
phd thesis federal institute technology lausanne epfl 
appear 

mishra peterson schlichting 
communication substrate fault tolerant distributed programs 
distributed systems engineering journal 

moser amir melliar smith agarwal 
extended virtual synchrony 
ieee th intl 
conf 
distributed computing systems pages june 

powell editor 
delta generic architecture dependable distributed computing 
springer verlag 

ricciardi birman 
process groups implement failure detection asynchronous environments 
proc 
th acm symposium principles distributed computing pages august 

schiper 
uniform reliable multicast virtually synchronous environment 
ieee th intl 
conf 
distributed computing systems pages may 

schneider 
replication management state machine approach 
mullender editor distributed systems pages 
acm press 

van renesse birman cooper stephenson 
horus system 
birman van renesse editors reliable distributed computing isis toolkit pages 
ieee computer society press 

wilhelm schiper 
hierarchy ordered multicasts 
th ieee symp 
reliable distributed systems srds pages bad germany september 
