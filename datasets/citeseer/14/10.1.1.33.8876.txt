department computing science deforestation higher order functional programs simon david marlow thesis submitted degree doctor philosophy computing science university glasgow september fl simon marlow functional programming languages ideal medium program optimisations source source transformation techniques 
referential transparency affords opportunities wide range correctness preserving transformations leading potent optimisation strategies 
thesis builds deforestation program transformation technique due wadler removes intermediate data structures order functional programs 
contribution reformulate deforestation higher order functional programming languages show resulting algorithm terminates certain syntactic typing constraints input 
constraints entirely reasonable possible translate typed program required syntactic form 
show translation performed automatically optimally 
higher order deforestation algorithm transparent 
possible determine examination source program optimisation applicable 
investigate relationship deforestation cut elimination normalisation property logic sequent calculus 
combining cut elimination algorithm order deforestation derive improved higher order deforestation algorithm 
higher order deforestation algorithm implemented glasgow haskell compiler 
describe deforestation fits framework haskell design model implementation allows automatic list removal additional deforestation performed basis programmer supplied annotations 
results applying deforestation implementation example haskell programs 
supervisor phil wadler constant supply ideas encouragement possible 
committee dave sands simon peyton jones david watt provided useful comments suggestions 
functional programming group glasgow university especially andy gill andr santos david king providing varied stimulating environment research 
supported engineering physical sciences research council 
express companies establishments indirectly supported research especially writing period benson hedges little italy restaurant lane 
gave encouragement support need 
mi mo 

contents optimisation transformation 
transparency 
unfold fold transformations 
example 
removing intermediate data structures 
deforestation 
extensions deforestation 
foldr build deforestation 
contribution thesis 
structure thesis 
higher order deforestation history 
syntax semantics 
treeless form 
transformation algorithm 
ii knot tying 
example 
deforestation theorem 
summary 
transparency treeless form 
linearity 
generalising algorithm real programming languages 
cut elimination 
natural deduction 
sequent calculus 
cut elimination 
hybrid language 
algorithm 
proof termination 
recursion 
cyclic terms 
recursion equations 
order deforestation 
terms 
algorithm 
higher order deforestation 
syntax 
contents iii algorithm 
knot tying 
proposition termination 
issues conversion treeless form 
languages 
algorithm 
linearity 
duplication 
full laziness 
losing opportunities full laziness 
loss laziness 
static argument transformation 
summary 
transparency 
implementing deforestation design goals 
model deforestation compiler pass 
user annotations vs automatic compiler annotations compromise module system 
summary 
structure deforestation implementation 
glasgow haskell core language 
iv treeless form 
labelled terms 
conversion treeless form 
algorithm 
transformation expressions 
nested letrec expressions 
top level transformation 
knot 
improving knot 
back loops 
boring expressions 
extracting lets 
loop merging 
improving performance knot 
avoiding name capture 
unique name supplies 
debruijn numbers 
splitting name supplies 
monadic name supplies 
results analysis description measurements 
queens 
results 
contents life 
life 
results 
pattern matching 
results 
summary 
deforestation algorithm 
implementation 
results 
research 
deforestation algorithm 
relationship foldr build deforestation 
implementation 
code examples queens 
chapter optimisation transformation problem productive software development frustrated conflicting aims develop software reliable develop software efficient develop software quickly 
developing reliable software entails organised approach software engineering making high level languages constructs abstractions 
techniques essential software portable extensible 
general rule higher level generality abstraction greater penalty efficiency program 
functional programming languages provide high degree flexibility reliability program developers 
strong type systems give programmer increased confidence program correctness 
features lazy evaluation datatypes overloading facilitate efficient software development 
unfortunately imposes burden efficiency functional programs 
order fast programs retaining desirable language features onus optimisation falls compiler 
build compilers capable programs written clear style produce programs run efficiently possible 
raises question scope obviously possible build compiler knows example equivalent compiler conceivably translate chapter optimisation transformation algorithm improve complexity 
transformational approach program optimisation takes view program improvements expressed source source mutations subject program 
powerful technique show chapter transformation system consists simple correctness preserving transformation rules capable providing framework powerful optimisations expressed including alter complexity original algorithm 
thesis examines aspect global program optimisation transformation removal intermediate data structures 
transparency program optimisation techniques usually generally applicable imperative programmer knows exactly program optimised 
call property transparency 
small low level optimisations generally transparent regarded acceptable effect optimisation averages size program increases 
specific optimisations powerful aspect transparency important 
non transparent optimisations tend produce unpredictable results small change original program produce wild variations performance optimisation changes applicability 
subjective nature transparency subject rigorous definition optimisations lie fully transparent opaque extremes 
rule thumb definition optimisation guarantees applicable programs meet syntactic criterion transparent 
renders optimisations analysis techniques non transparent optimisations program transformation transparent 
exceptions rule thumb example binding time analysis partial evaluation close transparent results analysis programmer restructure program 
chapter optimisation transformation programmers generally comfortable purely transformation optimisations effect optimisation determined solely examination source program 
reason consider transparency important factor design optimisation techniques 
unfold fold transformations unfold fold transformation system devised burstall darlington bd basis program transformation techniques developed optimising functional programs 
system consists basic rules applied set equations 
initial set equations program transformed equations may added transformation takes place 
equation left hand side form right hand side arbitrary expression similar pattern matching function definitions seen functional programming languages 
rules applied program follows 
definition 
new equation introduced left hand side overlaps equation set 

instantiation 
new equation introduced substitution instance existing equation 

unfolding 
equations contains substitution instance se may replaced se 
folding 
equations contains substitution instance se may replaced se 

abstraction 
clause may introduced equation replacing right hand side chapter optimisation transformation 
laws 
laws primitives expressions may instance associativity commutativity 
laws sufficiently general transform program 
system entirely complete transform functions xs xs xs extra rule called redefinition suggested burstall darlington allow transformations 
noted transformation system partially correct 
mean result transformation program gives result result original program 
unfortunately possible transformation produce program defined original 
happen arbitrary fold step allowed example equation set application fold rule replace obviously non terminating function 
people proposed solutions 
showed correctness guaranteed provided number unfold steps greater equal number fold steps certain conditions transformation 
scherlis sch proposes restriction fold step guarantee total correctness 
sands san provides general improvement theorem guarantee correctness higher order unfold fold program transformation schemes 
theorem verify particular transformation strictly improves program 
generality system means possible obtain transformation program efficient original program chapter optimisation transformation efficient 
means order transform program profitably transformation steps guided user defined set strategies tactics 
examples burstall darlington user guided sense involve central eureka step allows subsequent transformation process achieve desired result 
eureka steps classified type optimisation achieve fact specialise automate transformation strategy 
basis proposed automatic transformation techniques chi 
feather shows semi automation unfold fold system ease transformation large systems fea fea 
burstall darlington recognised transformations followed similar style proposed strategy applying rules 
goes follows necessary definitions instantiate unfold repeatedly trying apply laws abstraction folding 
strategy show instance quadratic function transformed equivalent function linear complexity list processing functions transformed avoid building intermediate structures 
example give example unfold fold transformation system action 
particular example chosen program fragment performs useful computation find length initial segment sequence specifies certain predicate 
expression performs required function length takewhile iterate broken problem manageable sub problems simple combinator perform part 
length function takes list returns length 
takewhile function takes list returns initial segment values satisfy predicate iterate function generates list repeatedly applying function initial value 
definitions combinators 
chapter optimisation transformation iterate iterate takewhile xs takewhile xs length length xs length xs definitions program clearly expresses intention programmer unfortunately doing serious inefficiency introduced 
expression written generates intermediate data structures list generated iterate consumed takewhile result takewhile turn consumed length 
aim transformation derive program performs computation manipulating intermediate lists 
gives transformation sequence achieves desired result 
defining function equal expression 
explain step turn 
define new function identical second argument iterate abstracted 
eureka step sequence 

fold original expression respect program represented single call new function 
unfold call iterate right hand side 
unfold call takewhile right hand side 
law chapter optimisation transformation length takewhile iterate define length takewhile iterate fold unfold length takewhile iterate unfold length takewhile iterate law length takewhile iterate length unfold theta length takewhile iterate fold unfold fold example valid provided function strict 
law push call length inside branches length strict 

unfold call length 

instance original right hand side apply fold rule 
program fragment transformed recursive function performs function combinator composition original expression 
general components program specialised task hand gains benefit longer intermediate structures program chapter optimisation transformation store 
translate real improvements observed run time program 
removing intermediate data structures algorithms involve intermediate data structures common programs written declarative style 
expressions built components combinators performs particular function 
example previous section illustration methodology 
kind modularity program design seen just lowest level demonstrated example structure programs 
part program built smaller components aids readability extensibility software reuse detrimental performance 
rewriting program order remove inefficiencies imposed modularity programmer degrade clarity maintainability program 
modern software engineering techniques dictate programs developed easily maintainable burden falls compiler writer lessen impact efficiency 
methods automatically remove intermediate data structures especially lists proposed researchers 
wadler wad proposed small set list combinators equivalent map foldl showed composition combinators effectively reduced single function application wouldn build intermediate structure 
augustsson aug describes method eliminate intermediate sequence values list comprehensions tur common form known abstracting nil component list achieve constant time list append hug effectively removing intermediate lists chains appends 
wadler wad uses technique suggest systematic transformation remove calls append functional programs example shows transform chapter optimisation transformation tt tt tt case tt fp tt tt treeless form quadratic time reverse function linear version 
burge bur goes step abstracting cons nil allowing simple list processing functions fused similar technique perform intermediate list removal gill see section 
deforestation wadler deforestation algorithm grew wad wad 
transformation system unfold fold strategy burstall darlington designed automatically remove intermediate data structures trees functional programs 
viewed strategy applying unfold fold rules performed automatically stand transformation algorithm 
deforestation applies order functional programs composed functions written certain form called treeless form shown 
suggested name function treeless form guaranteed generate intermediate data structures trees 
additional restriction functions treeless form function arguments linear argument referred body function 
deforestation theorem expressed deforestation algorithm remove intermediate data structures expression involving calls treeless functions definitions treeless form 
algorithm takes input program consisting treeless functions non treeless term yields program consisting treeless functions treeless term 
chapter optimisation transformation defined case fp case fp case fp case fp defined case case case fp fp case case fp case fp deforestation algorithm informally algorithm works follows 
transformation function shown applied initial composition functions continuously unfolds function calls applying reduction commuting conversion transformations expression 
time sub expression occurs renaming expression previously transformed fold step triggered 
fold step generates new recursive function guaranteed treeless form 
algorithm continues sub expressions transformed exist expression treeless form new set treeless functions 
definition treeless form means result include intermediate data structures 
termination algorithm solely fact fold step occur eventually 
treeless form formulated way happen wadler provides outline proof termination 
complete proof termination ferguson wadler fw 
chapter optimisation transformation unfortunately treeless form restrictive language form expressiveness 
order modern functional programming languages higher order 
restrictions arguments function application variables function arguments linear mean isn possible write arbitrary function treeless form 
wadler goes way removing restrictions methods ffl relaxes restriction variable arguments allowing expressions numeric non recursive type argument positions 
expressions generate simple result don really count intermediate data structures 
blazed deforestation algorithm extension basic algorithm expressions blazed minus transformed expressions blazed plus processed normal 
extends range functions input deforestation algorithm fails encompass possible functions 
ffl known technique called higher order macros enables certain functions arguments function type represented macros abstracting offending arguments 
enables higher order functions map represented order treeless form 
remaining restriction function arguments linear ensure deforestation algorithm produce program efficient original 
happen unfold phase function application replaced instance function definition 
argument allowed occur multiple times body function expression duplication occur result unfolding 
cause arbitrarily large computation duplicated run time restriction 
prospect lifting restrictions obtaining algorithm performs deforestation wider variety programs subject inspired wadler deforestation discussed section 
chapter optimisation transformation attractive property deforestation algorithm completely transparent 
syntactic restriction input deforestation ensures intermediate data structures removed 
deforestation generalised property difficult maintain concern far addressed acceptably 
example going details transformation deforestation produces result example program section suitable redefinitions functions blazed treeless form case true false equivalent result derived unfold fold style transformation 
result optimisation program obviously efficient original complexity algorithm remains 
true deforestation general achieve constant factor speedups 
show thesis constant factor large optimisation produce significant increases efficiency 
extensions deforestation chin recognised thesis wadler deforestation generalised cover wider range functions extending definition treeless form modifying algorithm accommodate changes chi 
firstly definition treeless form changed allow functions non linear arguments 
chin extended concept function parameters chapter optimisation transformation parameter minus non linear 
relaxes restriction function arguments parameter minus call function exists non variable expression position 
textual linearity criterion treeless form replaced chin extended treeless form definition sharing analysis hg 
non linear arguments subject substitution argument evaluated execution time 
particular extension means algorithm gains power expense transparency 
chin extends deforestation cover order functions introducing construct language indicate presence intermediate data structure deforestation algorithm attempt remove 
functions converted treeless form 
chin doesn attempt identify lets added functions 
intermediate structure normally removable deforestation algorithm residual proper control construct 
chin extends deforestation algorithm higher order functions process higher order removal combined extensions algorithm essentially ignore residual higher order features input 
consider method valid unacceptable reasons increases size program adds complexity deforestation algorithm results loss transparency 
chin extends ideas giving generalised annotation scheme order deforestation uses producer consumer model determine certain fusion safe terminate 
proof termination 
chin doesn comment scope technique effect generalised deforestation real example programs 
hamilton ham extends order deforestation relaxing definition treeless form 
chin recognises textual linearity strong criteria avoid duplication introduces sharing analysis accurately detect nonlinearity 
hamilton relaxes treeless form showing non variable function argu chapter optimisation transformation ments represent intermediate data structures successfully 
impact function arguments non variable provided called function doesn decompose structure equivalent argument position 
example second argument append renders definition concat treeless form 
hamilton usage analysis performs function detecting non intermediate structures 
hamilton adds construct language order able express functions treeless form 
construct identical chin indicates presence intermediate structure removed deforestation algorithm 
hamilton attempts theoretical study extended deforestation commenting 
hamilton ham gives new deforestation algorithm higher order language gives termination proof 
hamilton influenced author formulating material chapter see section 
gluck jones extended deforestation order able derive optimal knuth morris pratt kmp specialised pattern matchers general matching algorithm 
extension involves adding rule basic deforestation algorithm enable partial evaluation style optimisation take place 
sands provides insight proving semantic correctness unfold fold style transformations uses method prove higher order variant deforestation correct san san 
foldr build deforestation gill launchbury peyton jones gil take entirely different approach deforestation 
motivation approach achieve deforestation minimum effort sacrificing generality way 
technique combinators 
purpose list reducing function foldr encapsulates standard way lists consumed incidentally chapter optimisation transformation foldr fold rule burstall darlington 
defined follows foldr foldr xs foldr xs list consuming functions written foldr including sum append map 
second combinator ways partner foldr called build definition build list producing functions abstracted cons nil redefining applications build 
example map defined follows map xs build foldr xs advantage lists built build consumed foldr removed foldr build rule foldr build foldr build rule isn valid values valid lists truly abstracted list constructors values satisfy polymorphic type fi ff fi fi fi fi restriction show foldr build rule valid free theorem concept rey wad 
chapter optimisation transformation foldr build rule embodies essence removing intermediate lists 
instance left hand side foldr build rule occurs program indicates intermediate list eliminated replacing right hand side 
main argument favour method deforestation simplicity 
need unfold transform fold strategy classical deforestation associated complex termination proofs 
disadvantage loss generality 
functions defined terms foldr build done performing transformation automatically ls gil 
difficulties arise functions zip take multiple list arguments successfully classical deforestation 
difficulties functions foldr version foldr takes list length treat certain cells list differently 
detailed comparison foldr build deforestation classical deforestation left section 
contribution thesis viewed exploration topic deforestation 
section list main contributions thesis 
ffl major contribution thesis show deforestation performed arbitrary higher order functional programs 
give deforestation algorithm programs written language lambda calculus satisfies transparency property 
ffl identify conditions satisfied input deforestation algorithm show conditions ensure termination algorithm 
ffl relate deforestation cut elimination principle logic 
merging algorithm simple order deforestation obtain new higherorder deforestation algorithm advantages generality previous algorithm 
chapter optimisation transformation ffl show arbitrary functions converted automatically form required deforestation 
conversion process optimal sense converted functions allow greatest amount intermediate data structure removal 
ffl describe problem ensuring transformed programs efficient original 
rules concerning form input deforestation transformations performed deforestation adhered ensure safety 
ffl transparency property deforestation algorithm described detail 
show identify intermediate structures removed input program 
ffl design model implementing deforestation optimisation real functional language case haskell 
model involves compromise user intervention automatic optimisation allows certain classes intermediate lists removed automatically deforestation possible programmer explicitly directs deforestation algorithm annotations 
ffl implement deforestation implementation glasgow haskell compiler 
details implementation independent compiler language 
ffl propose implement certain extensions basic deforestation scheme discovered experimentation essential applying deforestation implementation larger programs 
ffl apply prototype implementation example programs 
results show maximise benefit deforestation annotating program 
ffl identify avenues research 
chapter optimisation transformation structure thesis chapter chapter describe complete deforestation algorithm lambda calculus language 
transformation knot tying new function generation algorithms described separately provide proof termination algorithm 
algorithm chapter shortcomings dealt rest thesis 
chapter chapter take principle logic cut elimination show relates deforestation 
propose new language formulation derived sequential calculus natural deduction give cut elimination algorithm language prove termination 
deforestation algorithm simple order recursive language formulated style cut elimination algorithm 
languages algorithms combined yield higher order deforestation algorithm 
provide proposition termination arguing certain restrictions input restrictive algorithm chapter algorithm terminate 
chapter chapter looks issues related deforestation necessary deforestation put practice 
automatic conversion treeless form enables arbitrary recursive functions automatically translated treeless form language required deforestation 
translation involves residual data structures intermediate data removed deforestation 
transformation transparent residual data structures introduced process easily identified required 
second issue treated chapter linearity 
linearity criterion required ensure deforestation generate program efficient chapter optimisation transformation original happen expressions duplicated transformation example 
subject treated separate issue impact operation termination deforestation algorithm 
examine transparency properties deforestation algorithm 
show programmer identify parts program optimised particular exactly data structures removed deforestation 
chapter chapter give detailed description prototype deforestation implementation glasgow haskell compiler showing part system implemented practically efficiently 
provide optimisations improvements basic scheme developed result experimenting early versions prototype 
chapter chapter give results obtained applying deforestation number example programs displaying different facet scope deforestation optimisation strategy 
provide discussion deforestation real world compiler give suggestions improvements optimisation scheme 
chapter chapter give describe topics research 
chapter optimisation transformation chapter higher order deforestation chapter new deforestation algorithm removes intermediate data structures arbitrary higher order functional programs 
approach taken start scratch extending order deforestation algorithm accommodate higher order constructs take view lambda calculus core higher order programming language simply extension order recursion equations 
goal stated develop algorithm removing intermediate data structures arbitrary higher order lazy purely functional programs 
decision apply algorithm lazy functional languages languages evaluation strategy normal order values subexpressions updated evaluated motivated mainly preference requirement pure functionality essential transformation techniques significantly complicated presence transparent language features 
goal leads number subgoals ffl algorithm generally applicable 
apply programs including contain data structures removed deforestation process 
ffl algorithm transparent 
obvious examining subject chapter higher order deforestation program data structures removed deforestation process left place 
ffl algorithm lead naturally implementation acceptable efficiency suitable optimising compiler 
algorithm chapter meets goals number shortcomings addressed rest thesis 
history chapter inspired extent hamilton deforestation ham provoked author re evaluate old research new light 
deforestation algorithm chapter discovered time earlier dismissed having great advantages algorithm previously mw 
hamilton discovered similar algorithm independently inspired go back algorithm attempt termination proof 
resulting proof somewhat simpler algorithm previously working 
main difference algorithm hamilton hamilton uses indicate residual data structures non linear function arguments construct see section 
modulo difference definition treeless form identical hamilton 
syntax semantics introduce syntax semantics language deforestation algorithm apply 
language chosen lambda calculus straightforward extensions explicit recursion top level letrec chapter higher order deforestation variable lambda abstraction ts application ts constructor application case alts case expression expression xs sequence variables ts sequence terms alts fc xs xs alternatives defs ff declarations prog letrec defs program language non recursive expressions special meaning algorithm see constructs building examining algebraic data structures 
language represents smallest subset functional languages haskell rest language translated 
algebraic data structures identical user definable data structures haskell 
algebraic datatype sum products general algebraic datatype consists number constructors number arguments 
enumerated types special case algebraic datatypes set constructors arguments 
similarly product types consist single constructor argument element product 
example list type defined list ff nil cons ff list ff nil cons constructors 
nil arguments cons list element type ff rest list type list ff 
chapter higher order deforestation structure built applying constructor correct number arguments 
partially applied constructors simulated functions cons xs cons xs data structures examined case expression 
case expression consists selector arbitrary expression set alternatives constructor datatype 
alternative consists simple pattern constructor fully applied variables expression 
semantics expressed informally follows selector evaluated weak head normal form top level constructor matched correct alternative 
variables pattern bound corresponding field data structure expression right alternative evaluated presence new bindings 
require programs typed recursive types program defined algebraic data types list example 
type restrictions correspond type system haskell similar functional languages 
constructs missing simple language expect find real programming language 
firstly primitive objects integers operations 
simulated algebraic data types include basic language 
secondly nested letrec deforestation algorithm extended quite straightforwardly handle programs nested done prototype implementation 
nested letrec expressions treated section 
denotational semantics language specified reduction rules ts 
ts case 

letrec ff 

chapter higher order deforestation operational semantics language call need lazy evaluation 
rest chapter terms normal form weak head normal form 
term normal form reduction rules applied 
term weak head normal form lambda expression constructor application 
treeless form treeless form subset full language previous section 
term treeless form term full language vice versa 
essential property term treeless form evaluating intermediate storage certain defined cases 
define intermediate storage structures generated possibly consumed computation appear directly result 
order define treeless form need distinguish types variable bound definition top level letrec 
types variables distinguished treated separately algorithm follow 
distinction relevant refer letrec bound variables identifiers forms application treeless form syntax application letrec bound variable application normal variable 
argument list cases consist variables empty 
consider definition treeless form ignore construct 
terms form normal form respect reduction rules language 
evaluating term form succeed immediately returning original term intermediate storage 
add construct removed normal form property 
essential concept captured intermediate structures built term treeless form indicated explicitly construct 
contrast treeless form wadler wad treeless form allows intermediate data structures making clear exactly intermediate structures exist 
chapter higher order deforestation tt tu tv xs application xs recursive function application tu lambda case case expression tts constructor application tt tu expression xs sequence variables tts tt tt sequence terms fc xs tv xs tv alternatives ff tt tt declarations letrec program syntax treeless terms treeless form sufficiently general term full language rewritten treeless form usually judicious addition ensure argument application variable 
raises important point normally way term may converted treeless form way better sense 
optimal translation 
purpose construct allow intermediate data structures removed deforestation program 
deforestation algorithm remove data structures protected construct remove exception discussed 
entirely possible prevent useful deforestation place construct 
show section optimal translation performed automatically 
program treeless form precisely input transformation system expect 
consists set treeless recursive definitions arbitrary non treeless expression 
restriction expression obtainable repeated substitutions treeless terms free variables initially treeless term term order see section 
straightforward check term satisfies restriction 
chapter higher order deforestation criteria covers majority terms including terms composed just applications variables 
disallows terms express term treeless substitution making name capture term ruled input deforestation algorithm 
rewrite term expression admissible lost possibility eliminating intermediate structure argument introducing residual 
possible transform expressions represented treeless substitutions valid ones addition suitable expressions 
possible algorithm identify non variable function arguments case selectors bound variables appear rebind expressions 
transformation algorithm describe higher order deforestation algorithm stages section describes transformation process section describes termination conditions generation new recursive definitions 
transformation 
recursive operation terms treeless terms 
recursive definitions bound top level letrec represented mapping variables expressions 
strictly speaking write td depends subscript omitted readability 
rules replace recursive function variables definitions 
operation examines head applicative expression input 
head chapter higher order deforestation ts ts ts ts case alts ts case alts ts case fc xs ts 
case fc xs ts case alts ts case alts ts case xs ts xs ts case case fc xs alts ts case fc xs case ts case alts ts case alts ts transformation scheme chapter higher order deforestation term case expression pattern matching performed head applicative expression selector case 
operation comparatively complex delve deeply input term find reduction perform 
compared approach simpler transformation steps mw scheme nested calls efficient implementation algorithm simpler termination proof 
rules algorithm consider applicative terms note argument list case empty exceptions rules perform fi reduction 
enables algorithm concise manner consider applicative non applicative terms separately 
implicit argument list flattening operation algorithm assumed vs automatically replaced vs 
number places transformation name capture occur binding capture free variable name expression binding moves outside expression 
avoided problem assuming variable names unique retain clarity rules 
implementation problem means trivial discussed chapter 
rules algorithm introduce lets output rules 
contrary intuition says intermediate data structures bound input removed deforestation 
cases introduced places hope remove intermediate structure question variable head application bound lambda case expression value known 
consider lets deficiency algorithm 
subject discussed section propose solution chapter 
chapter higher order deforestation knot tying transformation algorithm terminates call argument renaming occurred 
happens new recursive definition looping transformation replaced call new function 
terminology introduced burstall darlington bd defining new functions folding respect new functions 
call process knot tying 
explanation concrete considering possible implementation procedure 
order simplify matters note isn necessary remember single call order detect renamings 
subset rules rules terminate 
application unfolding rules lead non terminating transformations calls invoke rules need memorised compared calls detect loops 
separate transformation knot tying stages deforestation having transformation generate infinite annotated output knot tying process examining output discover loops making new recursive definitions 
formulation requires algorithm implemented lazy functional language infinite intermediate structure stages 
need way annotate output transformation history calls done introducing new term form label fields contain label terms second contain labels treeless 
terms fields semantically identical furthermore free variables second field subset free variables field label concept proposed mw 
idea annotate output depositing label argument field result transformation second 
knot tying process descend output term collecting field label term continue descending second field looking labels renamings encountered far 
transformation algorithm modified annotate output 
new rules chapter higher order deforestation ts label ts case alts ts label case alts ts syntax provide single identifier refers term avoid having duplicate right hand side 
unfolding reduction rules annotates output record call 
complete knot tying process need define mean loop loops generate new recursive definitions 
definition expression renaming expression exists substitution oe variables variables excluding letrec bound variables note renaming substitution oe may possibly map different variables result 
recall field label term identical meaning second field contains labels define mean loop definition loop defined term form label subterm form label renaming generate new set mutually recursive functions identify loops output transformer 
loop replaced new recursive function call follows free variables excluding loop label new expression takes form function added list top level definitions expression looping subterm label renaming replaced free variables chapter higher order deforestation order oe substitution renaming oe 
note may contain knots tied leading nested recursion output 
definition suffices proof termination section note implementation perform optimisations simple scheme 
example similar loops may occur branches transformed expression sense combine single new recursive definition create identical modulo renaming 
additionally beneficial cache calls just unfold definitions enables algorithm terminate earlier generate smaller output 
example provided section 
topic optimising knot tying process discussed chapter 
example section examine particular example application deforestation algorithm detail provide insight remove intermediate data structures higher order programs 
goal expression xs concat map map xs definitions 
intermediate data structure wish remove entire list lists produced map map xs consumed concat looking definitions see treeless form foldr application non variable argument concat append occurs right application 
render foldr treeless form addition chapter higher order deforestation append xs ys case xs nil ys cons xs cons append xs ys foldr xs case xs nil cons xs foldr xs map xs case xs nil nil cons xs cons map xs concat foldr append nil example definitions foldr xs case xs nil cons xs foldr xs add function treeless exist residual data structure intermediate structure removed deforestation definition foldr case part result function topic discussed section 
technique write treeless version concat ideal involve rebinding append append residual calls reduced 
technique non treeless expressions making treeless staring face apply deforestation algorithm 
obtain treeless version concat foldr append nil set definitions contains append treeless version foldr transformation shown 
point knot tie new definitions 
call chapter higher order deforestation foldr append nil xs case xs nil cons xs foldr xs append nil xs case xs nil nil cons xs foldr append nil xs append xs case xs nil nil cons xs foldr append nil xs append xs case xs nil nil cons xs foldr append nil xs append xs case xs nil nil cons xs foldr append nil xs append xs case xs nil nil cons xs xs append nil xs append xs case xs nil nil cons xs case xs nil nil cons xs foldr append nil xs append append converting concat treeless form chapter higher order deforestation occurred generate new function 
call append simply yield identical definition append modulo renaming applied variables intermediate data structure removal take place 
won bother expand just leave call append place 
knot tying definition concat xs case xs nil nil cons xs xs append concat xs xs optimal definition concat save residual prevents output concat 
result definition foldr required represented treeless form 
alternative definition concat considered failure albeit easily rectified 
fact append doesn call expression append xs substitute result subexpression xs append definition remove intermediate structure 
yields optimal definition concat details omitted definition suffices example 
aside note don cache calls call tie knot wouldn recognised call 
example tradeoff amount caching performed size resulting code mentioned section 
note technique finding treeless version foldr yielded result achieved manual insertion 
order treat foldr free variable transforming body foldr 
technique general stages applying deforestation algorithm non treeless function new definition deforestation need modify contents may render definition chapter higher order deforestation non treeless 
separate treeless form conversion process required 
go ahead goal expression new definition concat subsidiary function steps transformation figures 
point calls occurred 
knot tying produces program letrec xs case xs nil nil cons xs xs xs case xs nil cons xs cons xs xs xs result treeless program builds intermediate structure 
see examining code list built result computation 
example demonstrated power higher order deforestation algorithm showing non treeless functions treeless application deforestation algorithm deforestation performed expressions generic higher order functions map foldr deforestation theorem order prove deforestation algorithm terminates shall show size terms occurring recursive invocations operation bounded quantity 
size terms bounded finite number recursive function variables constructors case alternatives available operation eventually discover renaming previous call terminate 
chapter higher order deforestation xs concat map map xs xs concat map map xs xs map map xs xs case map map xs nil nil cons xs xs append xs case case xs nil nil cons xs cons map map map xs nil nil cons xs xs append xs case xs nil case nil nil nil cons xs xs append cons xs case cons map map map xs nil nil cons xs xs append xs case xs nil nil cons xs case cons map map map xs nil nil cons xs xs append xs case xs nil nil cons xs map map xs append map xs case xs nil nil cons xs map map xs append map deforestation concat ffi map map chapter higher order deforestation xs case xs nil nil cons xs map map xs case map nil cons xs cons append xs xs case xs nil nil cons xs map map xs case case xs nil nil cons xs cons map nil cons xs cons append xs xs case xs nil nil cons xs map map xs case xs nil cons xs cons append map xs case xs nil nil cons xs map map xs case xs nil cons xs cons append map deforestation concat ffi map map continued chapter higher order deforestation proof similar structure wadler proof termination order deforestation wad 
separated parts firstly show bound nesting treeless terms input secondly actual size terms bounded 
definition expression said order denoted superscript formed fold substitution treeless terms 
term order zero non letrec bound variable 
term order formed term order follows tt tt free variables tt arbitrary treeless terms 
lemma term order formed term order terms order follows free variables proof induction case definition order 
case decompose definition order tt tt chapter higher order deforestation free variables assume occur achieved simply choosing unique expression rewritten tt tt induction hypothesis rewritten tt tt definition order term order required 
proof extends straightforward way values 
syntax treeless terms includes variables relation refer set terms order ae ae ae possible assign unique order term term minimum order minimum number substitutions treeless terms required obtain term 
placing bound minimum order term bound nesting treeless terms term 
small syntactic convenience order superscript sequence ts example means terms sequence specified order 
definition order formulate useful lemmas lemma applicative expression order subterms order applicative expression letrec bound variable order subterms order proof treeless form permits variables applicative term term formed substitutions chapter higher order deforestation lemma terms order term order 
equivalent version lemma applies case selectors extract selector case term order term order lemma term order term order term order 
proof decompose term lemma follows tt free variables tt lambda expression derived tt substitution deduce free tt term rewritten tt term order 
lemma term form case fc order term order gamma expression order proof lemma similar proof lemma 
chapter higher order deforestation definition term order form case gamma fc xs case zero argument list empty 
words term order sequence gamma case expressions term order orders selector cases increase starting selector gamma order lemma term order order 
proof induction base case term order order 
term order order show term order order case gamma fc xs gamma induction hypothesis order 
order term order need show selector gamma order gamma term order lemma 
definition term order term order note terms order terms order term order term order lemma terms order order 
position state main lemma proof termination chapter higher order deforestation lemma mapping variables treeless terms invocation operation form ts gamma recursive invocations form ts gamma 
proof examining rule turn assuming input form show recursive calls correct form 
rules deal case expressions give case input term form ts gamma case term order subset general case 
rule ts gamma ts gamma replace recursive function variable definition terms order safe 
rule gamma gamma gamma gamma rule rule gamma gamma gamma gamma term order lemma 
rule chapter higher order deforestation rule ts gamma ts gamma rule case gamma alts ts gamma case gamma alts ts gamma rule case gamma fc xs ts gamma gamma 
gamma case fc xs ts gamma rule case gamma gamma alts ts gamma case gamma gamma alts ts gamma lemma gives order rule case xs ts gamma xs ts gamma term xs order lemma 
rule chapter higher order deforestation case case gamma fc xs gamma alts ts gamma case gamma fc xs case gamma alts ts gamma recursive call right form gamma ts gamma required form 
input term order special case rule applies input term order empty 
rule string case terms input 
applied indefinitely length case sequence limited rule case gamma alts ts gamma case gamma alts ts gamma having shown bound nesting treeless terms input invocation lemma show size terms bounded 
define stringent measure size term definition depth expression zero variable plus maximum depth subexpressions 
note application binary operator applicative expression depth plus maximum depth applicative expressions implicitly flattened applicative term 
lemma term order treeless terms construct maximum depth depth theta proof induction zero case variable depth zero required 
form chapter higher order deforestation tt tt inductive hypothesis maximum depth variable theta substitution replace variable term depth depth new expression theta theta lemma call form exists bound depth argument recursive calls generated initial call 
proof define constant depth maximum depth treeless term occurring input transformation 
includes recursive definitions treeless terms construct initial term 
know lemma recursive calls form ts gamma need show terms calls form bounded depth 
maximum depth term ts gamma theta order gamma 
maximum depth theta term order nested sequence case expressions term order 
assuming expression passed invocation satisfies depth properties show recursive calls satisfy properties 
proof rule rule inspection ffl rules simply invoke subterms input depth properties preserved 
ffl rules replace call recursive function definition 
function call order definition maximum depth ffl rules apply substitutions new terms 
lemma substitution new term way yields new term depth theta chapter higher order deforestation ffl rule flattens case expression possibly increasing depth argument recursive call generates term order gamma term order 
depth original term gamma theta new term depth gamma gamma theta bound lower bound 
term form ts gamma operation invoked term depth greater theta initial call term order form ts gamma exists bound depth terms occur recursive calls shown bound depth terms occur input proof termination established bound width applicative terms limit 
example illustrates problem apply encounter increasing terms input terms bounded depth 
reason placed restriction recursive types occur input terms functions 
recursive types defined algebraic data types recursive type pass constructor argument function satisfy restriction 
lemma exists bound width applicative terms occur transformation 
proof 
assumption transformation algorithm preserves typedness original program verified simple examination chapter higher order deforestation algorithm 
infinitely wide applicative expressions occur ill typed 
considering term head application possibilities ffl term recursive type recursive types defined algebraic data types value expression recursive type constructor application applicative term ill typed 
ffl term infinitely large type form infinitely large types occur typed program 
consider polymorphism typed program type variable polymorphic type instantiated finite type 
theorem deforestation theorem 
transformation knot tying algorithm applied term order set treeless definitions process terminates yields treeless term new set treeless functions 
proof follows lemma 
summarise structure proof follows ffl establish measure treeless term nesting order 
ffl extend order cover sequences case terms occur transformation 
ffl show input term certain order recursive calls transformation function expressions order 
ffl relate order actual depth terms 
ffl show stringent depth property preserved bound depth term occurring argument transformation function 
ffl show restriction typedness input term guarantees infinitely wide applicative terms occur transformation 
completes proof 
chapter higher order deforestation implication termination proof size resulting code related number permutations label expressions linear size input expressions 
size result deforestation bounded far larger size inputs 
summary chapter described new algorithm performing deforestation higherorder functional programs 
key insight formulating deforestation algorithm higher order language designing treeless form way algorithm guaranteed terminate 
proof termination identified invariant measure size terms occur transformation show size terms bounded 
approach described chapter number shortcomings areas remain resolved 
issues summarised addressed rest thesis 
transparency treeless form deforestation algorithm chapter entirely transparent 
removes intermediate data structures denoted terms input removed placed bindings transformation see rules 
extra lets required keep output treeless form immediately clear adding residual data structures output 
fact consequence formulation treeless form doesn correspond directly normal form language 
differs terms allowed right application normal form allow arbitrary terms right application head variable terms allowed selector case normal form allow chapter higher order deforestation variable applied number terms 
treeless form generalised way need additional lets introduced transformation 
additionally treeless form correspond normal form language meaning evaluation term treeless form intermediate storage key property treeless form 
unfortunately making generalisation render proof termination invalid lemma true 
chapter derive new deforestation algorithm generalised treeless form properties logics natural deduction sequent calculus 
linearity far chapter mentioned efficiency program generated deforestation 
ideally guarantee program efficient original intermediate structure removed program efficient suitable operational semantics 
unfortunately world lazy evaluation property hard guarantee 
topic discussed fully section 
generalising algorithm real programming languages issues remain solved deforestation algorithm described chapter applied programs written practical programming language haskell 
problem convert user written functions treeless form 
optimal translation general terms treeless terms optimal sense translated function keeps largest subset eliminable structure original possible described section 
remainder issues applying deforestation real world programming languages dealt chapter describe prototype implementation glasgow haskell compiler 
chapter cut elimination chapter borrow fundamental principle logic derive higherorder deforestation algorithm 
particular principle interested cut elimination concerned simplification logical proofs 
curry howard isomorphism links proofs logic natural deduction terms simply typed lambda calculus simplification proofs cut elimination corresponds normalisation lambda calculus terms exactly goal deforestation normalising term equivalent eliminating intermediate data structures 
cut elimination invented gentzen gen wrote logics natural deduction sequent calculus 
showed proposition sequent calculus restructured way resulting proof contains uses cut rule 
furthermore done automatically proof containing cuts 
gentzen similar theorem natural deduction 
strong normalisation property natural deduction proofs discovered prawitz pra years 
curry howard isomorphism firmly bonds mathematics logic science programming languages 
curry cf noticed relationship natural deduction combinatory logic howard showed equivalent toone correspondence natural deduction simply typed lambda calculus 
chapter cut elimination propositions logic viewed types proofs terms lambda calculus 
addition simplifying proof corresponds reduction terms 
way lambda calculus terms strongly normalising natural deduction proofs simplest form 
exists isomorphism analogous curry howard relates logic sequent calculus equivalent programming language 
programming language sequent calculus appears similar lambda calculus important differences 
important difference sequent calculus contains cut rule 
difference syntax application discuss section 
term form corresponding cut rule logic cut construct 
cut gamma gamma gamma cut cut possible write proofs terms normal form 
contrast natural deduction possible write arbitrary terms elimination rules various logical constructs 
theorem cut elimination states sequent calculus proof cut equivalent proof cuts program sequent calculus language written cut transformed cuts normal form 
distinguish cut important reason convention represent residual data structures removed transformation cut represent eliminable data structures 
cut elimination similar normalisation natural deduction process view essence computation 
reducing term lambda calculus step step process removing intermediate structures yielding term normal form 
essence computation essence deforestation 
cut elimination program transformation scheme possesses important property missing normalisation terms lambda calculus 
property transparency sequent calculus term intermediate structure marked cut removed cut elimination 
base deforestation algorithm cut chapter cut elimination elimination mean algorithm sound logical principle truly transparent 
important problems possible 
firstly apply cut elimination language similar lambda calculus apply modern programming languages system 
secondly certainly largest mountain climb deforestation useful applied recursive programs cut elimination applies non recursive terms 
approach take problem define hybrid language draws features language natural deduction language sequent calculus 
language describes subset terms lambda calculus normal form 
adding cut term language regain full power simply typed lambda calculus benefit cut terms removed cut elimination algorithm 
second problem take simple order recursion deforestation algorithm known terminate 
reformulate order deforestation form similar formulation cut elimination 
non recursive cut elimination algorithm order deforestation yielding fully transparent higher order deforestation algorithm 
said termination properties resulting algorithm fully known give conjecture conditions algorithm terminates convincing arguments sufficient 
remainder chapter organised follows 
sections give brief overview natural deduction sequent calculus 
section presents cut elimination algorithm hybrid sequent calculus natural deduction style language gives proof termination 
section discusses ways explicit recursion may added lambda calculus explains decided order recursion equations represent recursion language 
section describes order deforestation algorithm 
section describes merged algorithm goes give version loop creation explicit 
arguments termination examples 
chapter cut elimination id gamma gamma gamma gamma gamma gamma gamma ts gamma ts fc gamma fc gamma xs gamma xs gamma case fc xs xs multi gamma gamma gamma natural deduction natural deduction shows logic natural deduction associated programming language simply typed lambda calculus 
pure natural deduction obtained simply removing terms typing rules left including 
syntax types fc range types range type variables ranges constructors ranges sequences types 
terms chapter cut elimination ts case alts alts fc xs xs ts xs range terms range variables alts ranges lists case alternatives ts ranges sequences terms xs ranges sequences variables 
single sum products type modelled system constructed datatypes languages haskell 
type fc datatype containing constructors type argument list object type built expression ts ts sequence terms length term sequence ts corresponding type objects type case term form 
chapter notation fc abbreviation fc fc xs abbreviation fc xs xs apart multi rule merely syntactic convenience rules system correspond elimination logical construct 
presentation natural deduction include explicit weakening contraction rules called structural rules incorporate weakening id rule allow assumptions freely duplicated 
simplification natural deduction proofs equivalent reduction lambda calculus 
basic reduction rules case ts fc xs ts xs expressions left reduction rules correspond proofs rule appears elimination rule 
proofs simplified applying reduction rules 
rule appear elimination rule requiring apply commuting conversions chapter cut elimination proof fully simplify 
additional rules involved case fc xs case fc xs case case fc xs alts case fc xs case note assuming variables named capture occur rewrite rules 
rewrite rules sufficient reduce normal form expression language 
equivalent transformations proof trees reduce proof normal form 
sequent calculus give logic sequent calculus programming language 
grammar types identical grammar terms apply ts case alts cut alts fc xs xs ts xs sequent calculus language application takes form apply term similar meaning natural deduction term 
difference sequent calculus term strict natural deduction term may example appear 
put precisely value sequent calculus form application value chapter cut elimination id gamma gamma gamma gamma gamma gamma apply gamma ts gamma ts fc gamma xs gamma xs gamma fc case fc xs xs cut gamma gamma gamma cut multi gamma gamma gamma sequent calculus term 
course true semantics language includes 

grammar sequent calculus describes terms normal form cut term form removed 
attractive representation terms purposes gives complete transparency normalisation process normalising term language sequent calculus takes term involving cuts yields term containing cuts 
equivalently proof involving cuts proof cuts 
full explanations cut elimination girard lafont taylor book glt gallier tutorial gal 
logician important property sequent calculus rules logic cut formulas appearing line proper subformulas 
natural deduction intuitive proof methodology sequent calculus interesting proof theoretic point view 
point view chapter cut elimination wish best worlds transparency cut elimination applied familiar language lambda calculus 
cut elimination section hybrid language 
give algorithm cut elimination prove termination 
eventual goal algorithm remove intermediate data structures programs written lambda calculus programming language leads formulate cut elimination way important differences gentzen 
noted language corresponds sequent calculus different syntax application lambda calculus 
applicative expression normal form lambda calculus term takes form variable applied number terms normal form 
simple translation lambda calculus form application sequent calculus form 
term equivalent looks apply apply apply gamma translation direction general 
closest get translate apply strict second 
strictness property means sequent calculus form application sense expressive natural deduction form 
extra flexibility superfluous needs fact turns important add recursion language 
second difference cut elimination gentzen algorithm transformation terms programming language chapter cut elimination lambda abstraction ts constructor application ts application case ts alts case expression ts sequence terms xs sequence variables alts fc xs xs case alternatives syntax terms manipulation proofs logic 
rule logic corresponds term form programming language styles necessarily dual 
chose program transformation style clearly shows relationship deforestation 
third final difference cut elimination algorithm removes arbitrary number cuts simultaneously multi cut elimination algorithm 
extension occurs naturally consequence case construct examine data structures case reduction step gives rise cuts may removed simultaneously 
course able remove multiple cuts single pass leads efficient implementation 
restriction cuts interdependent 
intermediate values removed depend 
serious restriction order set cuts dependence recursively remove inner ones 
cut elimination algorithm explicit cut terms algorithm begins term normal form list variable bindings form environment yields new term normal form 
hybrid language grammar types section 
chapter cut elimination gamma gamma gamma ts gamma ts gamma ts gamma ts fc gamma ts fc gamma xs gamma xs gamma case ts fc xs xs multi gamma gamma gamma type system treatment types syntactic abbreviation long function types 
sequence types stands language cut elimination algorithm lambda calculus language terms normal form represented 
assume straightforward non strict semantics language evaluator evaluator takes term value environment returns value value environment complete map free variables type system language 
rule associated term form expect 
curry howard isomorphism removing terms left type system gives natural deduction logic albeit proofs normal form 
algorithm algorithm multi cut elimination shown 
consists mutually recursive operations gt ga gc 
gt gc require environment ae chapter cut elimination gt ae gt ae gt ae ts gts ae ts gt ae ts ga ae gts ae ts gt ae case ts alts gc ae ga ae gts ae ts alts gts ae gt ae gt ae ga ga ts ga gt ts ga ts ts ts ts ga case ts fc xs ts case ts fc ys ga ts gc ae ts xs gt ae ts xs gc ae ts fc xs case ts fc ys gt ae gc ae case ts fc xs alts case ts fc ys gc ae multi cut elimination idempotent mapping variables terms 
idempotence context means terms ae refer variables domain ae 
assumption environment idempotent pervasive cut elimination algorithm attempt substitute terms originate environment 
substitution syntax environments 
environment list form elements represents mapping write ae term associated environment ae 
notation ae refers environment maps maps ae 
abbreviations related environments compactness representation algorithm 
xs ys ts notation ts xs short notation ae xs ys short chapter cut elimination ae ae 
meanings operations expressed terms evaluator gt ae ae ga ts ts gc ae alts case alts ae notation ae shorthand ae 
aside possible merge functionality ga gc enabling call ga rule omitted 
takes recursive calls rule triple nested double nested exchange additional complexity gc 
nesting turns factor proof termination rule opted clearer form 
proof termination lemma typed term environment ae binding free variables typed terms call gt ae terminates 
proof 
prove termination cut elimination algorithm multiset ordering 
multiset finite set tokens 
tokens support founded partial ordering equivalence 
multiset contain multiple copies token set strict sense word 
partial ordering tokens extended multisets follows fy fx informally multiset smaller derived repeatedly removing token replacing number smaller tokens 
chapter cut elimination property multisets key proving termination algorithm cases beta reduction case reduction transformation exchanges large object number smaller objects 
ordering defined amounts decrease size multiset 
size term written siz defined variable plus sum sizes subterms 
size type written siz defined type variables plus sum sizes subtypes 
operation occ gives number occurrences variable term type term typ 
set variables domain environment ae written dom ae 
define multiset index operations gt gc ga index operation pair multisets multiset contains types expressions call second multiset contains sizes expressions call 
partial order types subtype sizes 
notation theta shorthand copies index gt ae theta typ ae dom ae theta siz ae dom ae index gc ae fc xs theta typ ae dom ae theta siz ae dom ae siz index ga ts indices ordered lexicographically index smaller type index component smaller type index remains size index second component smaller 
note provided type index gets smaller size index may larger ordering holds 
goal proof show rule cut elimination algorithm index recursive call right smaller index call left 
argument algorithm guaranteed terminate foundedness ordering indices recursive calls continue decrease indefinitely 
chapter cut elimination examine rule algorithm recursive calls show indices decreasing required 
rules 
size index recursive call smaller call subterm original recursive call environment ae original type indices equal 
rule 
inner calls gt smaller size indices equal type indices 
call ga smaller size index size ae element size index original call type index larger mapping may mapping ae type index smaller 
rule 
inner calls gt subterms identical type indices smaller size indices 
call ga type index definitely larger original equal binding ae size index smaller 
call gc smaller type index type replaced term type result ga call 
rule 
suppose expression type element type index call left 
inner call gt type index contains element possibly times 
multiset ordering index smaller original 
call ga type index containing element smaller note cases size index larger ordering indices irrelevant 
note type recursive guarantee type indices smaller reason insist input algorithm typed 
rule 
recursive call subterm size index smaller 
type index remains 
rule 
size index smaller due multiset ordering 
size replaced possibly multiple elements size terms type index gets smaller multiset ordering replace type fc left possibly multiple items types rules 
recursive call subterm identical type index smaller size index 
chapter cut elimination note allow recursively typed terms doing mean reasoning rules invalid 
embed positive recursive datatypes polymorphic lambda calculus known strongly normalising believe proof termination algorithm enables sum product types positively recursive 
proof termination cut elimination provided girard lafont taylor glt 
recursion section describe methods adding recursion typed lambda calculus language 
goal find suitable framework extending cut elimination recursive programs 
cyclic terms method strikingly simple just allow terms infinite size 
infinite terms number advantages methods introducing recursion language 
ffl recursive types involved 
way add recursion language allow recursively typed expressions permits definition fixpoint combinator define arbitrary recursive functions 
ffl modifications required transformation algorithm order operate infinite terms 
tricky bit try algorithm terminate come 
ffl infinite terms regular structure finite representation 
infinite terms regular structure interested obviously guarantee termination transformations input infinite irregular 
chapter cut elimination way represent regular infinite terms cyclic terms system labels 
add extra term forms grammar language labelled cyclic term label 
labelled cyclic term takes form label name term 
term may contain label label example function map represented cyclic term map xs case xs nil nil cons xs cons looking closely definition realise slightly strange going variables rebound cycle case xs variables just example scope entire infinite term 
fact cyclic term bears striking resemblance loop construct imperative languages variables updated time loop remain constant 
labelled cyclic term syntax making shadowing provide infinite number different variables name 
nature variable rebinding cyclic term just curiosity complicates matters substitution 
imagine right hand side map definition substituting easy textual substitution works fine 
try substituting xs 
textual substitution substituting xs get map xs case nil nil cons xs cons clearly wrong 
time loop case analyses intended 
correct answer unroll loop chapter cut elimination map xs case nil nil cons xs cons case xs nil nil cons xs cons way write cyclic term recursive system equations defining part term 
method proposed mark hopkins hop 
hopkins showed free variable bound variable operators defined regular infinite terms fixed point operator equation system defining term 
hopkins formalised idea substitution regular infinite terms proved regular infinite terms related ordinary lambda terms 
hopkins system definition map look map xs map map case xs nil nil cons xs cons map course possible define cyclic term infinite type 
example positive recursive type negative recursive type 
cyclic terms simple elegant way introduce recursion lambda calculus 
subtleties introduced rebinding shadowing technique define mean practical problems implementation 
experience implementation cut elimination cyclic terms rejected method favour recursion equations 
chapter cut elimination recursion equations normal approach specify recursive function recursion equations style burstall darlington program transformation bd 
definition map familiar map xs case nil nil cons xs cons map xs rebinding explicit form arguments function 
order recursion equations recursive function calls fully applied define simple order deforestation algorithm 
defining language lambda calculus language section order recursion equations merge simple deforestation algorithm cut elimination yield higher order deforestation 
order deforestation simple order deforestation algorithm 
algorithm equivalent order deforestation wadler wad wad sense identical inputs algorithms produce identical output 
formulation somewhat different 
shall see deforestation algorithm restructured fit framework cut elimination ways simpler wadler algorithm 
terms treeless terms described language 
need definition non treeless terms occur algorithm follows 
included residual expressions language denote intermediate values chapter cut elimination variable ts constructor application case alts case expression expression xs recursive function call ts sequence terms xs sequence variables alts fc xs xs case alternatives treeless terms simple removed algorithm way chapter 
addition term form possible represent order recursive function language 
important point term treeless correspond normal form addition construct 
shall tackle problem optimal conversion treeless form chapter 
implicit operation term global set recursive function definitions definition form xs free variables subset xs 
assume straight forward semantics language embodied evaluator evaluator takes term value environment returns value free variables evaluator course depend value global opt omit places 
wish explicit subscript ed algorithm algorithm order deforestation shown 
dt operation takes term value environment ae returns term environment ae idempotent mapping free variables terms 
idempotence environment defined way section 
evaluator semantics chapter cut elimination dt ae ae dt xs ae dt ae xs ys ys dt ts ae dts ts ae dt case alts ae dc ae alts ae dt ae dt ae dt ae dts ae dt ae dt ae dc fc xs ae case fc xs dt aeg dc xs alts ae dc xs ys alts ae ys dc ts xs ae dt ae ts xs dc case fc xs alts ae case fc xs dc alts aeg dc alts ae dc alts ae simple dt expressed ed dt ae ed ae ae defined way section 
ae restricted idempotent invocation dt performs level substitution 
example simplify expression invocations dt required dt fy dt 
major difference algorithm original deforestation algorithm wadler 
formulation justified analogy cut elimination goal merge deforestation recursive functions cut elimination 
termination algorithm straightforward possible proof methodology chapter cut elimination induction 
proof included 
higher order deforestation far algorithm removes intermediate data structures arbitrary typed lambda calculus terms algorithm removes intermediate data structures compositions calls order recursive functions 
combining higher order deforestation algorithm 
higher order deforestation algorithm conservative extension order algorithm yields results order terms functions order algorithm 
applying cut elimination recursive programs lose strongly normalising property cut elimination replaced general termination property combined algorithm 
far unable prove resulting algorithm terminates section give necessary conditions termination conjecture sufficient 
syntax grammar treeless terms hybrid language 
note domain recursive function names separate domain variable names recursive functions fully applied 
restriction serious possible write recursive function partially applied lambda expression example note grammar describes terms normal form save construct 
intermediate structures removed environment transformation process 
chapter cut elimination lambda abstraction constructor application ts function application case ts alts case expression expression xs recursive function call ts sequence terms xs sequence variables alts fc xs xs case alternatives treeless terms higher order simple deforestation algorithm assume global set recursive function definitions definition form xs assume evaluation function language algorithm algorithm combining cut elimination deforestation shown 
environment ae idempotent earlier algorithms 
meanings constituent operations defined terms evaluation function follows gt ae ae ga ts ts gc ae alts case alts ae knot tying knot tying algorithm achieved ways knot tying merged transformation algorithm adopt stage process trans chapter cut elimination gt ae gt ae gt ae ts gts ae ts gt ae ts ga ae gts ae ts gt ae case ts alts gc ae ga ae gts ae ts alts gt ae gt ae gt ae gt ae xs gt ae xs ys ys gts ae gt ae gt ae ga ga ts ga gt ts ga ts ts ts ts ga case ts fc xs ts case ts fc ys ga ts ga ts ga ts ga xs ts ga xs ys ts ys gc ae ts ys gt ae ts ys gc ae ts fc xs case ts fc ys gt ae gc ae case ts fc xs alts case ts fc ys gc ae gc ae alts gc ae alts gc ae xs alts gc ae xs ys alts ys multi cut elimination loops chapter cut elimination formation generates labelled expressions subsequent knot tying process analyses labels new function definitions appropriately algorithm chapter algorithm implemented chapter 
believe method may better facilitate proof termination 
proposition termination claim terms finite application depth negative recursive types algorithm terminate 
give arguments restrictions necessary guarantee termination 
guiding principle formulating restrictions input user able define general fixpoint operator input deforestation algorithm 
allow surely invalidate termination property user define arbitrary recursive functions fixpoint operator applied non recursive lambda expressions 
possible guarantee termination algorithm arbitrary recursive functions reasonable restrict input algorithm way general fixpoint combinator formulated 
possible define combinator resulting definition involve residual data structures safe transform 
ways fixpoint operator may defined 
firstly recursively typed expression fix definition grammar gave input algorithm reformulated 
property definition interested type cyclic type known negative recursive type 
rank cyclic type number times cycle passes argument position arrow 
rank type positive negative 
terms involving positive types known chapter cut elimination strongly normalising involving negative types possess property 
supported fact negative types required define fixpoint combinator type type rank 
insufficient just dis recursive types cycle passes sum products type common practice hindley type systems modern programming languages haskell ml allows fixpoint combinator defined 
simply negatively recursive types 
second way define fixpoint combinator recursion mechanism provided language fix fix doesn involve recursive types 
definition possess infinite application depth means definition fully expanded descent expression tree pass infinite number application nodes 
requiring terms finite application depth 
straightforward determine set recursive functions infinite application depth descending expression tree function expanding function calls call function previously expanded encountered 
descent required passing application node application depth infinite 
note sensible impose slightly stronger restriction recursive calls appear argument application 
appear useful property base termination proof far unsuccessful finding proof believe exists 
case reason lenient criteria sufficient guarantee termination 
provided restrictions input deforestation algorithm argued necessary ensure termination 
restrictions sufficient termination 
able find counter example succeeded finding proof 
topic 
chapter cut elimination chapter issues conversion treeless form deforestation algorithm previous chapter took input recursive function definitions treeless form 
treeless form includes construct renders complete sense function represented language addition appropriate lets 
construct acts barrier deforestation introduces residual data structure removed transformation 
danger converting arbitrary function treeless form data structures eliminable rendered residual addition superfluous 
example fundamental list processing function foldr written foldr xs case xs nil cons xs foldr xs term infinite application depth addition required represent treeless form chapter issues foldr xs case xs nil cons xs foldr xs enables elimination input list xs result recursive call foldr residual 
insertion extra input list residual preventing removal data structure foldr xs ys xs case ys nil cons xs foldr xs section show optimal conversion arbitrary expression extended lambda calculus language treeless form previous chapter 
optimal mean largest subset data structures resulting expression eliminable deforestation algorithm 
aside note definition treeless form relaxed cases data structures removed deforestation algorithm cases algorithm may fail terminate 
instance original definition foldr admitted treeless form deforestation algorithm adjusted accordingly straightforward call foldr xs bound xs cons xs yields list eliminable 
standard append function instance foldr bound xs foldr xs algorithm fail terminate encounters increasing nesting calls foldr somewhat lower level description conversion treeless form algorithm section apply principles section language deforestation implementation 
chapter issues languages grammar full language shown grammar treeless subset language shown 
domains function symbols ordinary variables distinct range variables range recursive functions 
previous chapter assume global set recursive function definitions full language restriction recursive function symbol treeless form may applied sequence variables 
grammar treeless form prohibits terms infinite application depth 
fact restrictive recursive function application appear right application 
restriction formulated way treeless form easily specified grammar 
strictly speaking difference way treeless form defined section algorithm optimal respect definition treeless form chapter 
additional restriction purely enable clearer presentation algorithm easily extended treeless form chapter restricted treeless form chapter 
algorithm algorithm translate expression full language treeless form consists stages 
firstly expression translated normal form applicative expressions variables head case expressions applicative expressions selector 
stage involves addition terms 
second stage enforces rules concerning recursive function calls calls variable arguments appear argument application selector case expression 
stage certain expressions may residual 
terms full language converted normal form cut elimination algorithm previous chapter constitutes stage conversion treeless form 
chapter issues variable recursive function identifier lambda abstraction ts constructor application ts application case alts case expression residual expression ts sequence terms xs sequence variables alts fc xs xs case alternatives full language lambda abstraction ts constructor application ts application xs recursive function application case ts alts case expression residual expression lambda abstraction ts constructor application ts application case ts alts case expression residual expression ts sequence terms ts sequence terms xs sequence variables alts fc xs xs case alternatives alts fc xs xs case alternatives treeless form chapter issues second stage consists key transformations 
transformations applied term repeatedly treeless form may applied order 
transformation enforces variable argument rule recursive function calls consists rules applies function calls arguments non variables ts 
xs 
occurs extract non variable arguments recursive function application residual 
transformation optimal sense alternative way translate call treeless form introduce fewer residual expressions 
reason side condition second rule expressions binding variables occur multiple times enforce linearity constraints see section 
remaining transformation rules extract recursive function calls appear argument application 
grammar treeless terms provides places applicative terms may appear ground level selector case expression 
rule extracts recursive function calls ground level applicative terms 
fu minimal free expressions containing recursive calls 
substitution sequence expressions minimal free expressions containing recursive calls set smallest subexpressions expression contain recursive calls additional constraint expression set contain free instances variables bound original expression 
reason extracting set wish remove chapter issues recursive calls arguments application bind outside application expressions 
terms extract contain free instances variables unbound lifted application 
formally minimal free expressions containing recursive calls expression set smallest subexpressions satisfying criteria ffl subexpression contains recursive call 
ffl expression set contains subexpression 
ffl set free variables expression set subset free variables example expressions give minimal free sets ts ff tsg ts ff ts ff xg fx xg zg extracting minimal free expressions simply extracting argument application contains recursive calls ensure maximum possible number reductions performed deforestation 
example translated cons cons cons inhibit elimination cons instantiated case expression deforestation 
third final transformation applied case selectors similar second transformation chapter issues case alts 
case alts minimal free expressions containing recursive calls expressions replaced extract maximal free expressions arguments application placed outside case selector 
applying conversion normal form followed repeated application rules yields optimal translation treeless form 
algorithm perform automatic conversion treeless form deforestation implementation described section 
linearity blindly applying deforestation algorithm arbitrary programs carries inherent risk resulting program may efficient original 
surprising result due non linear features input program 
terms linear non linear informally direct connection linear logic 
shall discuss problems cause degradation performance 
case give solution problem involving addition bindings expression additional transformations recover sharing 
conjecture rules section loss performance incurred applying deforestation algorithm program defining performance number reductions performed 
techniques relevant deforestation algorithms previous chapters algorithm implemented section 
chapter issues duplication loss efficiency arise result expression duplicated transformation 
expressions duplicated applying reduction rules algorithm case reduction fi reduction recursive function unfolding 
variable case pattern recursive function argument lambda abstracted variable appears body construct say variable non linear 
nonlinear variables potential source duplication expressions duplication resulting program executed 
obvious example function non linear argument square square theta expression square possibly large expensive compute term yield result theta problem evident time taken evaluate transformed expression roughly double time taken evaluate original result evaluating longer shared 
consider alternative definition square square theta expression square get theta worse better original 
difference non linear argument protected residual expression 
unfolding argument function captured allowed duplicate 
note previously possible eliminate data structure represented passed non linear function forcing residual opportunity lost 
possible determine statically case assume worst non linear variables residual 
established prevent expressions duplicated add construct non linear variable function definition 
unfortunately chapter issues sufficient guarantee result program efficient original 
full laziness program executed fully lazy evaluation strategy hug pey expressions updated value computed 
ensures expression value required times evaluated expression replaced value evaluation 
illustrate difference full laziness semi lazy evaluation strategy modern compilers including glasgow haskell compiler consider simple function square time function applied value expression square required 
value depend argument value evaluated cached calls behaviour characteristic fully lazy evaluation strategy ordinary laziness loses sharing 
non fully lazy implementation time function applied definition copied call site replicating subexpressions may fact independent argument function applied 
transformation scheme called full laziness transformation transform program fully lazy operational semantics evaluation strategy fully lazy 
full laziness transformation modifies program maximum sharing occurs execution 
process consists recursively extracting lambda binding maximally free expressions largest subexpressions contain variables referred binding 
chapter issues losing opportunities full laziness possible performing deforestation optimisation program affect behaviour subsequent full laziness transformation 
serious problem optimising compilers perform full laziness transformation part optimisation process removing opportunities full laziness impair transparency full laziness transformation 
program exhibits problem described map map xs sum sum program contains function takes argument returns result applying followed element list xs 
intermediate data structure exists nested calls map definition removed deforestation 
expression map xs independent shared multiple calls full laziness transformation yield ys map xs map ys sum sum expensive function apply transformation dramatic effects execution time program non fully lazy compiler 
perform deforestation full laziness transformation result xs sum sum xs case xs nil nil cons xs cons xs opportunity extract second call map definition lost chapter issues calls map merged remove intermediate list 
removing intermediate list provides benefit limited compared benefit sharing list calls table compares effect deforestation full laziness number times called length list xs 
deforestation full laziness removes construction lists 
replaces construction lists list 
removes deconstruction lists 
effect deconstruction 
effect calls replaces theta calls calls 
assume calls arbitrarily expensive deforestation beneficial case 
values full laziness better 
decide general exact value safest option perform full laziness transformation deforestation 
loss laziness deforestation remove opportunities full laziness provide benefit remove sharing opportunities ordinary laziness 
phenomenon called loss laziness 
illustrate problem suppose input deforestation contains plus notice non linear argument protected 
expression plus arbitrarily large term get term chapter issues original expression updated value computed second demand yielded cached result 
expression deforestation longer case 
detected problem 
cause stems pushing expression inside lambda term happened example argument plus substituted 
result substitution normal form recalculated time applied 
sure way avoid problem substitute expressions inside lambda term hamper process deforestation opportunities remove intermediate data structures 
force arguments residual 
inserted plus captures pushed inside lambda 
justification change function plus non linear fashion program danger losing laziness wish introduce residual data structures unnecessarily 
fact correct place insert original application plus replacing plus plus problem decide general ffl particular expression function cause loss laziness ffl place ensure expression danger maintained 
answer don 
notice valid transformation deforestation result chapter issues contain free variables 
just full laziness transformation 
expression unfolded inside lambda automatically candidate full laziness transformation 
provided compiler implements full laziness transformations safe loss laziness results substitution reversed full laziness transformation 
combining result previous section discover order guarantee deforestation impair efficiency program perform full laziness transformation program deforestation 
strategy successfully implementation deforestation described chapter 
static argument transformation enable full laziness transformation extract free expressions result deforestation necessary employ extra transformation stage 
consider example involving function map map xs case xs nil nil cons xs cons map xs function applied element list 
computation performed applied duplicated element list subsequently demanded 
expression map plus xs expensive expression compute definition plus obtain result chapter issues xs xs case xs nil nil cons xs cons xs free variables 
expression recomputed element list previously value cached evaluation 
reverse state affairs known transformation techniques 
task remove arguments introduced knot tying process 
arguments prevent expression extracted full laziness transformation 
fortunately arguments time called subject static argument transformation san 
applying optimisation get letrec xs case xs nil nil cons xs cons xs inlining function call site occur chapter issues letrec xs case xs nil nil cons xs cons xs apply full laziness transformation extract expression function contain instances bound variable letrec xs case xs nil nil cons xs cons xs xs evaluated exactly time expression evaluated identical situation deforestation applied 
summary summarise rules applied ensure deforestation impair efficiency program 
ffl avoid duplication expressions non linear bindings protected 
ffl full laziness transformation applied program prior deforestation opportunities increase sharing lost transformation 
ffl deforestation static argument transformation applied new function definitions enable free expressions extracted 
chapter issues ffl full laziness transformation performed recover sharing lost inlining expressions inside bindings 
conjecture rules deforestation algorithm program efficient 
alternative simpler solution problem linear type system 
traditional linear type systems suitable reasons consider expressions required non linear assign non linear types expressions required shared lazy evaluation 
type system proposed turner wadler mossin solves problems provide suitable framework base deforestation algorithm guarantees lose efficiency transformed program 
investigation alternative technique planned 
transparency motivation formulating deforestation algorithm cut elimination previous chapter came desire optimisation transparent 
achieved syntactic constraint program guarantees intermediate data structures removed 
furthermore construct enables program contain residual data structures making treeless form expressive function represented 
effects transformation data structures eliminated algorithm obvious simply examining source program 
construct possible residual 
binding expression put place barrier deforestation elimination structure represented expression bound take place 
cases obvious effect deforestation 
example consider standard definitions map sum chapter issues sum xs case xs nil cons xs sum xs map xs case xs nil nil cons xs cons map xs see observation residual data structure definitions integer result recursive call sum know structures eliminable 
example deduce intermediate list sum map xs removed deforestation 
prevent removal list insertion ys map xs sum ys clear placement data structure represented map xs residual 
fact deforestation algorithm applied new expression result simply renaming original program 
cases difficult assess impact inserting residual program 
consider altered definition map map xs case xs nil nil cons xs ys map xs cons ys data structure residual 
expand result call version map get ys ys cons ys cons ys chapter issues representation clear elements result list residual head 
expression sum map xs definition map head element intermediate list applications sum map removed rest list left place 
result case xs nil cons xs ys xs ys xs case xs nil nil cons xs ys xs cons ys xs case xs nil cons xs xs knowing effect adding construct function definition useful necessary convert function treeless form assess result automatic conversion section 
example treeless form version foldr function looks foldr xs case xs nil cons xs foldr xs result recursive call foldr residual 
result call data structure kind removed deforestation 
example argument foldr xs cons xs yielding list append function 
recursive call foldr residual head resulting list eliminated 
function requires addition render treeless form iterate iterate cons iterate chapter issues written treeless form follows iterate cons iterate elements result list residual list 
summarise residual construct gives programmer precise control data structures program removed deforestation 
thought possible examine function definition converted treeless form decide parts result residual 
chapter issues chapter implementing deforestation chapter approach implementing higher order deforestation functional language compiler 
cover design optimisation pass showing higher order deforestation algorithm works context real compiler 
chose glasgow haskell compiler pey basis implementation designed way implementors plug optimisation passes 
provides number features particularly helpful including ability pass compiler specific optimisation details modules program separate compilation situation 
techniques described chapter specific glasgow haskell compiler haskell 
implementation deforestation constructed lines functional language compiler 
section describes design goals implementation deforestation entirely language independent 
section describes resolved design goals real deforestation model contains details mapped design haskell glasgow haskell compiler 
section go detail structure implementation describing algorithm solutions problems facing practical realisation deforestation 
chapter implementing deforestation design goals main concern design optimisation pass transparency 
control give user 
higher order deforestation algorithm ability provide programmer complete control allowing augment program lets indicate residual data structures 
course programmer burdened task making sure recursive functions treeless form 
burden 
cases programmer want simply instruct compiler perform deforestation compilation process compiler remove intermediate data structures possible 
useful existing programs needing alter code way 
shown optimal conversion arbitrary higher order language treeless form stage automated 
fact problem theory applying deforestation algorithm parts program meet criteria legal input algorithm 
pragmatic problem fully automatic scheme 
deforestation algorithm allowed run unchecked program create code explosion increase code size 
informally reason recursive functions expanded call site creating copy function call 
cases unfolded function subject deforestation combining unfolded functions produce new specialised functions intermediate store 
cases function call suitable position deforestation occur result copy original function call site possibly specialised respect higher order arguments small additional benefit 
unnecessary unfolding functions theory adversely affect efficiency program practice increase code size problem compilation run time 
stages compiler deal unduly large program resulting longer compilation times 
unreasonably large executable put extra strain virtual memory system computer leading large increases perceived execution time program 
chapter implementing deforestation fully automatic scheme desirable compromises order practical 
section solution problem 
model deforestation compiler pass section detail decisions implementing deforestation optimisation glasgow haskell compiler including solutions problems outlined previous section 
user annotations vs automatic compiler annotations compromise solution chose problem allows existing programs certain extent programmer intervention allows programmer full control deforestation process prepared provide annotations guide 
choice recursive functions unfold left programmer 
indicate particular function unfolded deforestation programmer places special annotation pragma program 
example indicates function unfolded 
syntax normally denotes comment haskell compiler understand form annotation ignore 
converting function definitions treeless form done automatically programmer having option forcing expressions residual 
residual expression converted expression transformation time intermediate data structure represents removed deforestation 
indicate expression residual programmer applies pseudo function residual 
term form special meaning deforestation algorithm represents residual data structure 
see section chapter implementing deforestation standard prelude appears description order deforestation performed programmer place annotations program 
case haskell large number functions built language available programs 
set functions collectively called standard prelude 
standard prelude prelude short includes wide range list processing functions map filter sum foldr definitions functions invisible programmer semantics specified language definition compiler writers free annotate deforestation 
approach taken implementation annotate unfolding prelude functions successfully deforestation 
yield modest increase code size see chapter allowing maximum amount intermediate data removed user annotations 
enumerated lists enumerated lists haskell take forms 
compile time enumerated list constructs converted calls prelude list generating functions respectively 
accordingly need lists annotate corresponding functions prelude deforestation 
list comprehensions number conversions list comprehension syntax equivalent expression list comprehensions pey 
glasgow haskell compiler uses conversion recursive function definitions wadler pey foldr build conversion gill launchbury peyton jones 
strategy permits deforestation foldr build method 
chapter implementing deforestation method automatically annotate function definitions introduced unfolded deforestation 
enables lists consumed produced list comprehension removed deforestation 
instance remove intermediate list expressions form translation inside compiler produces expression similar letrec xs 
case xs nil 
nil cons xs 
cons xs function annotated intermediate enumerated list removed deforestation 
note function generated treeless form true functions produced list comprehension translator 
common uses list comprehensions source intermediate lists include expressions zip xs ys eliminate list pairs produced zip 
arrays haskell array built array function type array ix 

assoc 
array chapter implementing deforestation construction array requires upper lower bound index type index member ix class list association pairs initialise array 
association pairs defined assoc datatype data assoc association pair list passed array initialises element array placing value index example suppose construct lookup table sin operation 
construct array indices value index sin 
haskell expression builds array array sin pi definition clear suffers serious inefficiencies 
intermediate lists ffl list built immediately consumed list comprehension 
previous section describes list removed deforestation 
ffl list association pairs produced list comprehension consumed array construction final array 
second list removed unfolding definition array deforestation 
may problems implementations haskell array primitive operation haskell definition 
glasgow haskell array function defined terms lower level primitive array operations unfold definition normal 
module system separate compilation presents barrier global optimisation techniques 
means information propagated modules optimisations chapter implementing deforestation lost 
example desirable available information regarding strictness functions module whilst compiling separate module refers functions 
haskell module system defines interface files allow information passed modules program 
module associated interface gives types functions defined module 
interface module consulted compiling modules functions module 
interface files may written programmer fact required modules mutually recursive commonly interface module generated automatically whilst compiling module 
glasgow haskell compiler additional form inter module communication placing optimisation information interface file form pragmas 
normally pragma function defined module takes form 
replaced large amount optimisation information including strictness arity update behaviour function 
cases pragma contain definition function importing modules inline function call sites 
typically small functions speed advantage outweighs small increase code size result inlining 
deforestation implementation facility forcing definition function annotated deforestation placed interface pragma function 
module imports annotated function definition available deforestation phase compositions involving imported function normal 
technique essentially bridges module gap penalty spreading program modules 
prelude just collection haskell modules bar primitive objects built compiler definitions annotated functions appear interface prelude available compiler compiling user program 
chapter implementing deforestation summary shown implementation deforestation user point view including standard haskell functions constructs need special annotations 
advantages scheme outlined summarised follows ffl programmer full control deforestation program optional annotations program 
ffl annotations omitted removal intermediate lists may take place programmer enumerated lists list comprehensions array constructions prelude list processing functions 
ffl compromises deforestation transformation simply picks expressions fit input criteria transforms unfolding functions annotated 
disadvantages ffl deforestation user written functions data structures take place user annotates program 
example user writes tree processing functions wishes annotated 
probably common problem occurs user writes list processing functions versions prelude list processing functions unfolded specifically annotated 
ffl deforestation pass unfold annotated functions intermediate structures removed 
result increase size object code typically increase small quantified chapter 
fact glasgow haskell compiler inlines number functions speed including map append foldr scheme somewhat limited attempt remove intermediate lists ignore user defined data structures effective compromise 
programmer free annotate program gain maximum benefit deforestation 
chapter implementing deforestation structure deforestation implementation algorithm implementation variant higher order deforestation algorithm described chapter 
algorithm chosen improved algorithm chapter reasons ffl termination proof essential optimisation included production compiler 
ffl efficient cut elimination algorithm 
due nested calls transformer algorithm transforms code twice 
disadvantage algorithm obey slightly restrictive definition treeless form correspond exactly normal form language 
avoid problem extra bindings section requiring result normal form treeless form 
may sound abandoning transparency fact noted chapter intermediate structures rebound transformation fact removable 
opting separate knot tying pass requires implementation transformation system lazy presents problems avoiding name capture 
difficulties solutions described section 
section describes core language 
small functional language internally glasgow haskell compiler 
haskell source code passes dependency analyser type checker translated core 
optimisation passes compiler take program core yield result core called core core passes deforestation implementation 
section describes subset core define treeless form 
noted definition treeless form chapter extended extra constructs core language 
section gives algorithm automatic conversion arbitrary core expressions treeless form 
conversion process simplification algorithm chapter implementing deforestation described section adapted treeless form definition section 
applied functions annotated user deforestation transformation 
section gives algorithm deforestation implementation parts transformation scheme core expressions letrec transformation scheme core programs transformation scheme letrec expressions 
section describes method avoiding name capture transformation process 
section gives algorithm knot tying 
glasgow haskell core language glasgow haskell core language forms input deforestation implementation shown 
core language derived second order polymorphic lambda calculus additional constructs manipulation primitive values integers floating point numbers algebraic data types similar earlier chapters 
range variables range literals range terms xs ys zs range sequences variables ts vs range sequences terms alts range lists algebraic primitive case alternatives defs range lists recursive definitions 
types variables annotated associated function definition annotated user compiler 
wish distinguish types represent variables 
language includes explicit type abstraction application 
additionally variable core program variable instances bindings associated type stored program 
type information kept consistent transformation type substitutions 
range types ts range sequences types 
actual grammar types little bearing algorithm chapter implementing deforestation literal variable lambda abstraction type abstraction ts constructor application phi ts primitive application ts application ts type application case alts case expression residual expression letrec defs letrec expression ts ht sequence terms ts ht sequence types xs hx sequence variables alts fc xs xs vg algebraic case alternatives fl vg primitive case alternatives defs hx recursive function definitions core language assume operations involving types denotes type substituting type type variable type denotes term substituting type variable types contained term including associated variable instance 
constructor applications primitive applications core saturated constructor applications yield algebraic type primitive applications yield primitive type 
kinds case expression core algebraic datatypes primitive types 
case constructs slightly different encountered necessary complete set alternatives list incomplete default case included 
default case takes form chapter implementing deforestation binds value selector expression term cases match 
default case may omitted algebraic case expressions alternatives constructor datatype provided may omitted primitive case expressions 
worth noting core expression case fx vg equivalent haskell case expression form core version strict semantics 
value value expression necessarily true equivalent haskell expression 
core expression equivalent haskell expression form chapter abbreviation fc xs vg fc xs xs vg fl vg fl vg 
regard typing core expressions require terms input deforestation algorithm typed hindley milner type system 
enforced type checker compiler code passed deforestation algorithm automatically satisfies restriction 
core language differs slightly core language rest glasgow haskell compiler transformations compiler convenient restrict expressions argument position application atomic variables primitive values 
implementation simple transformation standard glasgow haskell core modified form involves inlining certain expressions 
transformation careful duplicate expressions expand expression cause duplication run time 
assume straightforward non strict semantics core embodied evaluator evaluator takes core term environment mapping free variables values returns value term 
exact domain values important suffice say includes base types haskell algebraic datatypes defined program standard prelude 
chapter implementing deforestation literal lambda abstraction type abstraction ts constructor application phi ts primitive application ps function application ps normal function application case alts case expression residual expression letrec defs letrec expression term argument type argument variable argument type argument ps hp sequence variable arguments ts ht sequence terms xs hx sequence variables alts fc xs xs vg algebraic case alternatives fl vg primitive case alternatives defs hx recursive function definitions core treeless terms chapter implementing deforestation treeless form grammar core terms treeless form 
essentially subset terms core normal form exceptions indicate residual data structures function arguments variables types case selectors variables 
labelled terms transformation scheme shortly takes core term treeless recursive core functions yields infinite labelled term 
knot tying process takes infinite result transformation produces finite treeless term new treeless recursive functions 
intermediate language core augmented label construct takes form label restrictions terms form ffl semantically subterms identical 
ffl labelled term unlabelled term 
ffl may contain functions may component label subterms 
ffl set free variables subset free variables conversion treeless form function definitions deforestation converted core treeless form 
stage process 
stage convert core term normal form applicative expressions form variable applied list terms types case selectors applicative expressions 
arbitrary core term reduced form applying deforestation transformation section oe equal hi 
chapter implementing deforestation fs fs fs fs fs fs ts fs fs ts fs phi ts phi fs fs ts fs app fs hi fs case alts app fs hi case alts fs alts fs fs fs fs fs ht hf fs fs app fs hi bs bs app fs bs app fs bs ht app fs bs app fs bs hz app fs bs fs app fs bs hz alts fs fc xs vg fc xs fs fs vg alts fs fl vg fl fs fs asg conversion treeless form chapter implementing deforestation second stage converts normal form term treeless form account set variables unfolded subsequent deforestation transformation 
algorithm stage 
set variables unfolded changes deforestation conversion procedure takes argument list variables currently considered fs 
conversion treeless form optimal sense way convert term treeless form allow intermediate structures removed see section 
algorithm describe deforestation algorithm implemented glasgow haskell compiler 
section give basic transformation scheme core expressions letrec 
section gives transformation scheme letrec expressions section describes deforestation algorithm applied programs 
algorithm required letrec top level transformation schemes described detail section 
transformation expressions transformation scheme core expressions letrec shown figures 
consists mutually recursive operations support operations ts alts operation transforms term applied number arguments list arguments may empty contain terms types transforms case expression applied list arguments selector applied list arguments 
ts operation transforms sequence terms alts transforms lists case alternatives 
note transformation scheme split functions clarity certainly possible single function performs transformation avoid duplicating case terms left opted operation approach 
chapter implementing deforestation oe hi oe ts oe oe label oe oe oe hi oe hi oe oe oe hi oe hi oe oe oe ts hi ts oe ts oe phi ts hi phi ts oe ts oe ts oe ts oe ts oe ts oe case alts oe hi alts oe oe hi oe ts oe ht ht oe hi oe hii transformation core expressions chapter implementing deforestation oe hi alts case alts oe alts oe alts bs case ts oe alts oe alts bs oe alts bs label case alts oe oe alts bs oe alts bs oe alts bs oe alts bs oe alts bs oe ts hi xs oe ts xs oe ts hi vg oe ts oe phi ts hi alts case phi ts oe ts alts oe alts oe ts alts bs oe ts alts bs oe ts alts bs oe ts alts bs oe case fc xs vg alts bs oe hi xs 
case alts 
case alts bs oe case fl vg alts bs oe hi 
case alts 
case alts bs oe alts bs oe hi oe alts bs alts oe fc xs vg fc xs oe oe asg alts oe fl vg fl oe oe asg transformation case expressions chapter implementing deforestation transformation operations depends environment oe contains definitions functions unfolded transformation 
environment oe updated letrec subterm transformed see section 
transformation scheme nested recursive calls transformation operations explicit substitution arguments recursive calls 
substitution implemented extra environment argument transformation operations yields transformation scheme linear complexity 
meanings transformation operations expressed terms core evaluator follows oe ae letrec oe ae oe alts bs ae letrec oe case alts bs ae nested letrec expressions section deal letrec expressions expression 
time solution problem techniques described adapted difficulty algorithms chapters 
transformation letrec expressions requires knot tying function describe section 
invocation takes form labelled core term 
result form defs treeless term defs sequence treeless definitions extracted functions defined letrec may annotated occur result automatic recursive function generation tagging compiler example list comprehension expressions translated core section 
nested list comprehension translated recursive functions contain defining recursive functions 
recursive functions may contain expressions wish desirable apply transformation algorithm knot recursive function definition placed environment oe unfolding chapter implementing deforestation oe letrec defs defs letrec defs oe hf defs hx defs hv ht oe hi oe hii defs hx gs gs hk oe hi oe hi hs dom oe hf hu hf hs hs oe oe hf gs gs transformation scheme letrec expressions transformation rest program 
right hand side recursive definition transformed current environment oe 
side effect leaving definition normal form job converting treeless form somewhat easier 
transformation scheme letrec functions shown 
split definitions normal functions transform right hand side definition 
apply knot transformed right hand sides functions collect new definitions result 
new definitions converted treeless form respect new oe built original oe augmented extracted functions knot tying new functions letrec expression 
body letrec transformed new environment 
leave letrec binding just non tagged function definitions 
scheme function definitions environment may contain letrec expressions contain functions avoiding possibility transformation getting infinite loop processing functions 
chapter implementing deforestation tp oe hi hi tp oe defs defs defs tp oe hf defs hx defs gs gs hk oe hi oe hi hs hs hk oe hi oe hi hs dom oe hf hu hf hs hs defs hx hf gs gs hs hs oe oe hf gs gs top level transformation scheme top level transformation core program sequence mutually recursive function groups arranged dependency order earlier function groups refer ones 
top level transformation scheme simply treats program nested letrec expression body see 
transformation scheme group definitions similar letrec expression split definitions 
transformed functions extracted functions knot placed new environment transforming rest program keep transformed definitions case exported module 
knot knot tying process takes infinite labelled output transformation yields finite treeless term treeless recursive functions 
order search chapter implementing deforestation defs defs kt hi kt ls label loops hi xs xs hf xs xs defs fresh tagged xs freevars xs defs kt xs xs ls xs xs hf hi xs xs loops loops xs xs xs xs ls tg knot loops input term 
loop defined follows term label looping term subterm label strict renaming term strict renaming untagged variables non variables renamed 
renamings consistent example term renaming term reverse true 
algorithm knot tying shown 
infinite labelled term algorithm return finite term list new function definitions 
new definitions closed free variables provided free variable property labels true input section 
algorithm auxiliary functions freevars set free variables set free type variables type mapping variables variables term mapping applied free variables 
term consistent strict renaming term chapter implementing deforestation substitution expresses renaming function kt forms heart knot tying process 
takes list tuples current term 
tuple list label term current term subterm second component 
tuple takes form xs xs ffl component label term ffl function name allocated label ffl xs list free variables label ffl xs list free type variables type label 
call kt returns tuple form defs ffl result term ffl list function names loops ffl defs list new function definitions referred result 
term form label encountered input checked elements list tuples ls 
elements ls form xs xs renaming loop 
call function generated point xs xs argument list substitution indicate loop particular label return list hf second component result 
renaming construct new tuple xs xs fresh function name xs list free variables duplicates removed xs list free type variables type new tuple added ls invoking kt match label subterm indicated second component result recursive call new definition needs extracted point 
right hand side definition simply result term chapter implementing deforestation applying kt construct call new function return result 
described case kt label terms rest cases form straightforward traversal input term 
term form subterm lists bindings function names applying kt subterms concatenated produce result knot tying term 
generating new function definitions knot free variables free type variables function order keep type information program consistent 
note functions generated knot marked reason provided convert definitions treeless form 
conversion treeless form necessary definition treeless form depends set functions domain oe new set function definitions added oe converted treeless form respect new oe 
improving knot consider number improvements basic knot tying algorithm previous section 
improvements related quality output deforestation algorithm number cases experimentation simple knot inefficient finding loops leads increase size code generated 
output knot input deforestation example transforming functions unfolded unnecessary increase code size amplified code re transformed 
consider cases unnecessary code explosion occurs propose solutions 
techniques implemented noted 
section consider technique improving performance definition expensive computation 
technique described reduces complexity average case leading important improvements efficiency chapter implementing deforestation deforestation optimisation 
back loops experimentation knot described discovered certain cases output larger expected 
particular knot appeared skipped labels finding loop generating new function 
intermediate structure removed expected resulting program larger necessary 
problem illustrated append function defined follows append xs ys case xs nil ys cons xs cons append xs ys suppose deforestation algorithm required transform expression zs zs intermediate data structures expect transformation yield function isomorphic append 
output oe append zs zs label append zs zs case zs nil zs cons xs label append xs zs case xs nil zs cons xs label append xs zs attempt finding renaming attempt match label append xs zs append zs zs 
invalid renaming inconsistent zs chapter implementing deforestation renamed xs zs 
match succeed append xs zs valid renaming append xs zs new function generated point label 
result ignoring free type variables case zs nil zs cons xs xs zs xs zs case xs nil zs cons xs xs zs loss efficiency occurred terms extra computation size code needlessly larger expect imposes penalty execution speed program 
observations led develop simple principle allows extra code examples eliminated 
key idea term inconsistent renaming may case valid renaming situation called back loop 
call kt finds back loop original label outer call replaced result inner call applying substitution arises renaming 
operationally call kt finds previous expression renaming current expression applies substitution result current call returns new expression back loop requires extra field tuple returned kt containing list function name back loop expression pairs 
outer call checks back loops result recursive call returns corresponding expression 
extra complexity adds knot compensated reduction code size results implementation back loops 
chapter implementing deforestation boring expressions source superfluous code output knot failure detect loop early original expression input contains expressions labels variables 
example consider input form map represents data structure eliminated call external function 
map defined usual way output transformation label map case nil nil cons xs cons label map xs case xs nil nil cons xs cons label map xs attempt find loop tries match map map xs renaming 
loop second iteration map xs renaming map xs yielding result case nil nil cons xs cons xs xs case xs nil nil cons xs cons xs back loop example body function appears unrolled effectively doubling size result 
chapter implementing deforestation variable non application case case expression fc xs xs mg algebraic case alternatives fl mg primitive case alternatives boring expressions solution problem adopted implementation extract expressions involved removal intermediate data structures rebind construct 
instance term map example map knot tying succeed iteration 
subclass core terms boring represent eliminable data structures grammar 
consider expressions boring include grammar 
dealt differently described section 
extraction implemented simply adding new transformation rules dealing application oe ts hmi oe oe ts hmi alts bs oe alts bs boring expressions extracted application transformed head examined appear label expressions may generated result unfolding head application impair knot tying process identifying renamings iteration 
extracting expressions may introduce residual data structures impair transparency 
happen transforming body recursive definition order unfold expressions extracting boring chapter implementing deforestation respect transformation unfolding may represent eliminable data structures 
solution problem remove lets generated transformation conversion treeless form 
expression extracted way safely inlined transformation risk duplicating expression provided linearity rules section adhered 
order remember expressions appear output result extraction simply special class variable names generating new binding 
extracting lets extracting boring expressions labels match situation arises label form required match renaming boring expression extraction technique described 
transformation valid achieves required effect oe ts vi oe oe ts hvi transformation sufficient extract expressions argument application 
may deeply nested terms wish extract 
experimentation necessary extract lets possible argument descending term left side applications selector case expressions 
lets occurring argument extracted transformation process 
define general extraction scheme follows 
idea float terms top level may extracted similar rule 
order term rewriting scheme define precisely subterms subject term rewrite rules applicable 
extraction context expression hole represented definition chapter implementing deforestation ts case alts context hole replaced term written 
rewrite rules define extraction ts ts case alts case alts rules applied possible application argument transformed 
call transformation new rule expressing extraction transformation oe ts hvi oe oe oe ts note extraction done advance done transformation 
substitution operations cause lets appear argument position applicative terms previously 
extensions transformation algorithm improve compactness code generated deforestation implementation improve efficiency 
loop merging common deforestation module new functions essentially identical modulo renaming 
occur example program calls function map result elimination intermediate chapter implementing deforestation list 
knot tying process extract new function case identical map 
beneficial cases merge definitions updating calls old functions point new 
achieved module comparing definitions newly created functions find duplicates merging described 
implemented technique believe reduce code size penalty deforestation certain cases 
improving performance knot knot tying algorithm quadratic number labels deep search progress loop new label compared previous labels 
full label comparison linear size labels compared 
reduce complexity average case improving method labels compared 
standard approach comparing data structures apply hash function tree compare hash values constant time operation 
hash values identical full comparison trees required establish equivalence 
approach take apply hash function label placed history 
new label hashed value compared hash values previous labels 
match labels compared 
worst case hash values identical complexity unchanged 
average case comparisons constant time hash value comparisons match 
implementing optimisation dramatic effect efficiency knot tying algorithm expressions label comparisons required find loop 
avoiding name capture ensuring name capture occur presents real problems implementation deforestation algorithm 
goal sure variable chapter implementing deforestation captured binding name 
example suppose subexpression occurs transformation deforestation transforms variable moved inside binding name 
clearly invalid transformation allowed take place 
far circumvented problem name capture treatment deforestation making assumption variable names unique 
approach fine theoretical treatment ensuring assumption holds times problematic implementation 
rename variables original program distinct deforestation replaces function calls definitions function unfolded multiple times bindings refer variables name arise 
methods avoiding name capture described leading final solution implemented glasgow haskell compiler 
unique name supplies simplest programming technique avoid name capture involves name supply 
name supply object represents infinite sequence unique variable names 
name supply single threaded manner program duplicated variables generated guaranteed unique 
transformation proceeds follows 
expression bindings refer variables name 
time expression duplicated replace chapter implementing deforestation bound variables new unique names 
name capture occur 
simple name supply implemented integer increased fresh variable requested 
example representing variables strings type integer 
string ns show ns ns fresh variables form integer different new variable 
minor problem implementation variables original mnemonic names lost 
avoided keeping track original names including 
real problem technique clear try adapt deforestation algorithm include name supply 
suppose implement deforestation transformation function trans type trans expression 
expression order straightforward translation specification algorithm function type language lazy evaluation 
reason transformation sequence infinite able examine result prune produce finite expression separate knot tying process 
unfortunately name supply introduced fragile balance laziness upset 
type trans function chapter implementing deforestation trans expression 

expression order return name supply trans function completed transformation expression argument 
call trans generate infinite expression output require infinite number fresh variables name supply returned 
see problem consider fragment hypothetical implementation trans trans ns ns ns trans ns ns trans ns transform expression recursively transform branches 
transformation body requires name supply ns returned transformation right hand side binding suppose transformation yields infinite expression ns second recursive call trans trans soon call trans requires name supply result result transformation expression branches 
avoid problem merge knot tying process transformation result calls trans finite 
fact essential working language strict evaluation 
retain modularity provided splitting algorithm way desirable find way avoid name capture introducing errant strictness implementation 
debruijn numbers debruijn numbering method alternative naming scheme lambda calculus inherently prevents name capture occurring 
idea simple replace variable name number obtained counting intervening bindings variable occurrence binding refers 
example expression chapter implementing deforestation turns 
scheme extended include constructs case natural way 
debruijn numbering scheme simple elegant way avoid name capture transformation presents problems 
main disadvantage substitution complex term substituted kept consistent term substitution place 
free variables term substituted increased number bindings substitution site original instance term 
addition act substitution removes binding common occurrence beta case reduction free variables subterms adjusted accordingly 
fact additional manipulations emerges debruijn numbering method purposes creates problems solves 
reason rejected method avoiding name capture 
splitting name supplies splitting name supply modification original name supply idea copes neatly strictness issues introduced 
idea treat name supply single threaded object operations 
firstly name supply produce new unique name 
secondly name supply split new name supply objects 
easy way understand splitting name supply associate possibly infinite set supply unique names drawn 
splitting operation name supply splits set yielding disjoint sets 
split yields disjoint name supplies new supplies safely different parts transformation danger name clashes 
behaviour splitting name supply specified names produced individual supply different names produced supplies common ancestor 
simplify matters restrict number names produced supply 
serious restriction perform number splits generate unique names supply 
simple splitting name supply type implemented representing names lists booleans chapter implementing deforestation type bool 
string ns ns split 
split ns false ns true ns implementation simulates binary tree splitting operation prepends new item current supply false left branch true right branch 
resulting names interpreted binary numbers purpose printing names 
small excerpt code transformation process section trans 
expression 
expression trans ns trans ns trans ns ns ns split ns name supply split dependency second recursive call trans removed 
disadvantage technique names generated splittable name supply large splits performed names 
names map easily strings treating names binary numbers yield extremely large numbers 
solution rename program transformation imperative techniques implementation name supply shall see section 
chapter implementing deforestation monadic name supplies name supply single threaded manner sense force monad 
monads mog concept category theory popular functional programming wad wad allow wide variety programming paradigms expressed single framework 
monad encapsulates particular kind computation 
kind interested single threaded object object treated state 
state monad provides exactly capabilities require state case name supply held monad manipulated monadic operations 
monad enforces single threaded access state 
sample implementation monadic name supply basic name supply type functions section type ns 

ns ns ns ns 

ns 
ns ns case ns ns 
ns ns string techniques io system glasgow haskell compiler monadic io pw represent name supply global integer variable yields increase performance 
explained single name supply deforestation algorithm need splittable name supply order retain sufficient laziness algorithm terminate 
fortunately splittable name supply embodied monad 
idea bind operation monad performs chapter implementing deforestation split operation name supply new name supply passed argument bind 
example type ns 

ns ns ns 

ns 
ns ns ns ns ns ns split ns ns string ns ns danger duplicating name supply multiple computations joined receive different name supplies result call split definition 
danger calls returning name calls separated receive different name supplies 
clever programming represent name supply global integer variable 
idea due augustsson ars described detail launchbury peyton jones lj implement underlying name supply follows data splittable name split splittable splittable chapter implementing deforestation ccall genname 


code non standard glasgow haskell calls function increments global variable time new name supply generated time supply split 
change new names generated needed possible wrap call call call name required 
code referentially transparent monad possible means glasgow haskell extensions write code referentially transparent 
advantage placing name supply monadic control code written monadic style anyway book keeping required name supply little impact rest program improvement cluttered style example section 
chapter implementing deforestation chapter results analysis chapter examine effect applying deforestation implementation described previous chapter small functional programs 
case show examining source program possible predict intermediate data structures eliminated deforestation 
give evidence data structures eliminated giving output deforestation transformation measurements memory usage execution time running transformed program 
compare code size program original assess impact unfolding functions deforestation 
examples programs chosen illustrate situations deforestation effective 
description measurements compiled example program twice modified version glasgow haskell compiler derived version 
compilation default set optimisations requesting normal optimisation compiler alternatives optimisation extra optimisation 
second compilation additional deforestation full laziness passes inserted appropriate points compilation cycle 
chapter results analysis set normal core core optimisations includes ffl general simplification 
consists large number small local transformations designed improve quality code san 
examples fi reduction case reduction 
simplification pass typically invoked stages compilation cycle clean major optimisation pass 
ffl specialisation 
optimisation generates versions overloaded functions instantiated particular type 
ffl strictness analysis 
strictness analyser glasgow haskell compiler pj primarily useful removing repeated boxing unboxing primitive data types integers characters recursive functions 
applies product single constructor datatypes usefulness sum multi constructor datatypes limited due difficulty utilising strictness information types 
ffl full laziness 
full laziness pass extracts maximally free expressions technique known floating san 
required deforestation described section 
ffl static argument transformation opposite lambda lifting 
optimisation transforms function number arguments identical recursive call local function definition arguments free variables 
functions implemented efficiently glasgow haskell compiler lambda lifted equivalents spineless tagless machine machine ghc doesn require lambda lifted input 
functions respond static argument transformation occur frequently output deforestation 
exact order passes performed critical due subtle interactions different optimisations 
current version glasgow haskell compiler performed order chapter results analysis 
specialisation 
simplification 
full laziness 
strictness analysis 
simplification 
static argument transformation insert deforestation compilation cycle order passes follows 
specialisation 
simplification 
full laziness 
deforestation 
simplification 
full laziness 
strictness analysis 
simplification 
static argument transformation full laziness optimisation performed twice deforestation deforestation pass 
reason applying deforestation program full laziness remove opportunities full laziness decreases efficiency program compared version compiled deforestation 
measurements unloaded sparcstation 
program measured wall clock execution time total heap allocation code size chapter results analysis object program 
useful ultimately execution time goal optimisation strategy reduce 
measuring actual elapsed time implicitly take account factors ffl mutator time time spent actual computation program 
includes heap allocation updates elements execution lazy functional programs 
mutator time reduced deforestation fewer heap allocation examination existing data 
reducing heap accesses significant impact modern architectures memory impose larger penalty execution time purely computation 
ffl garbage collection time 
number garbage collections performed execution dependent amount heap allocation amount live data heap garbage collection time 
time spent garbage collection typically dependent amount live data garbage collector traverse tree reachable data collection determine keep 
deforestation tends reduce total heap allocation program data eliminates short lived case simple list processing computations constitute majority situations deforestation effective 
ffl input output system operations paging 
measuring execution time versions program fixed heap size fits real memory hardware paging factor 
deforestation course effect time spent performing input output 
relationship amount computation performed program computation defined actual number instructions executed wallclock execution time best due memory cache effects hbh 
argued provide realistic comparisons functional programs find optimal heap size program maximise cache hits minimise cache misses caused interaction heap stack accesses 
chapter results analysis measurements due large number timed runs required find optimal configuration 
elapsed execution time program measured best result runs 
total heap allocation provided glasgow haskell run time system request 
code size version size compiled object produced linking takes place eliminate large constant factor prelude library code linked final program 
include time taken compile program results compilation time affected significantly inclusion deforestation compilation process 
queens example traditional queens problem find number ways queens placed chessboard queen row column diagonal queen 
program written style heavy lists standard list operators convenient programming tools express problem 
algorithm implemented backtracking means common lazy functional programming technique known list solutions technique bw :10.1.1.100.9674
backtracking achieved defining list solutions problem recursively finding solutions queens starting expanding solution appending possible positions queen filtering resulting positions aren valid 
list solutions evaluated lazily demand element list search solution space depth backtracking finds valid solution 
backtracking aspect important require total number solutions necessitates evaluation entire list 
intermediate lists removed deforestation additional annotations program 
chapter results analysis safe int 
int 
bool safe zip 
length queens int 
int queens queens queens safe main print sum concat queens haskell code queens ffl enumerated list queens function consumed list comprehension removed automatically deforestation 
ffl enumerated list 
safe function consumed standard prelude list processing function zip eliminated 
ffl list pairs produced zip consumed list comprehension removed 
ffl list booleans produced list comprehension safe function consumed prelude function removed 
intermediate core program generated glasgow haskell compiler queens program appendix core output deforestation transformation 
seen examining code intermediate lists eliminated 
code shown direct output deforestation simplifications chapter results analysis code size bytes heap allocations bytes execution time unknown unknown deforestation results queens applied 
optimisations applied compiler post deforestation 
include ffl removal multiple unboxing integer variables 
example variable safe function 
performed general simplifier 
ffl strictness analysis remove boxing unboxing integer arguments functions 
queens example safe local recursive functions queens recurse integer variables strictness analysis profound effect efficiency functions 
ffl static argument transformation useful removing static arguments local recursive function safe argument queens 
results results applying deforestation queens performed tests shown 
looking results see large reduction total memory allocations program heap usage transformed program roughly seventh original 
reflected time taken execute program transformed program executes time original 
general direct relationship reduction heap usage increase efficiency depends time spent program doing non heap intensive computation 
intermediate list queens program eliminable deforestation technique list generated consumed queens function 
technique chapter results analysis termed worker wrapper deforestation developed gill part foldr build deforestation scheme capable removing type intermediate structure 
adapting technique deforestation scheme planned 
example somewhat pathological expect see dramatic improvements larger programs program spends great deal time working intermediate structures eliminated deforestation 
example serves illustrate upper bound improvements achieved relation memory allocation behaviour execution time 
life section examine haskell implementation conway life written john launchbury taken nofib benchmark suite par 
game life simple played fixed grid cell begins alive dead 
successive generation evolved previous simple rule cell live neighbours alive generation dead 
implementation life fixed starting position evolves pattern stable configuration reached 
generation printed standard output stream live cells represented dead cells blank space 
program written style 
time explicit programmer annotations obtain maximum benefit deforestation 
reason annotations required trade code size speed involved compiler leaves decisions programmer 
life examining code definitions prelude functions see intermediate structures removed deforestation ffl function disp chapter results analysis module main main inp stdout ff life start start int start gen board map row shift copy board row zipwith elt shift shift shift elt tot tot tot tot xs append init xs xs append tail xs shift xs zip xs xs xs copy int 

copy copy copy disp gen xss gen foldr glue map concat map star xss star star glue xs ys xs ys life foldr glue copy vt map disp zip map show limit iterate gen initial initial xss take map take copy xss copy copy limit xs limit xs haskell implementation conway life chapter results analysis list concat second call map list foldr call map constant string consumed ffl function life list foldr map list map disp zip list zip map show 
list map 
ffl function initial list call take map list second call take remove large number intermediate lists annotations lists part inner loop program part program performs majority computation run 
inner loop case function gen computes generation life universe 
see somewhat disappointing results performing deforestation program annotations ver deforestation 
looking program see number opportunities deforestation missed intermediate structure question arises result top level function 
example produce lists consumed shift function 
inlined call site calls append fused call zip removing intermediate lists 
ways top level functions may inlined call site ffl compiler automatically provided 
function recursive 
called chapter results analysis 
inlining result duplication 
function exported module 
ffl providing annotation function instruct deforestation phase compiler unfold definition place called 
option functions called multiple times believe benefit deforestation outweigh increase code size results unfolding definition times 
life program functions default exported satisfy criteria automatic inlining 
single module program safely change module header module main main function main exported 
gives compiler freedom inline functions start gen disp initial star 
intermediate structures removed deforestation ffl lists generated ffl pairs list map disp zip life 
results applying deforestation modified program ver deforestation 
removed important lists lists generated inner loop 
better annotating functions deforestation remove important intermediate lists greatly improve space consumption program 
firstly annotate limit remove lists function life ffl list generated iterate consumed limit chapter results analysis ffl list generated limit consumed zip annotate shift function heavily calculating generation remove structures ffl row lists triples produced calls shift consumed zipwith elt 
ffl gen list triples produced shift consumed map row 
annotating glue copy remove lists ffl lists generated disp copy consumed glue life ffl lists generated copy initial 
annotations deforestation process dramatic effect total heap allocation life program execution see ver 
provide core output deforestation large verified structures indicated removable fact removed 
particular resulting program contains tuples original program uses extensively calculation generation 
worth mentioning life program demonstrates advantages higher order deforestation algorithm short cut deforestation schemes foldr build 
short cut deforestation remove intermediate lists functions consume multiple lists simultaneously zip 
requires programmer rewrite recursive list processing functions terms combinators foldr build technique need remove lists involving copy limit life program eliminated simply annotating functions deforestation 
chapter results analysis code size bytes heap allocations bytes run time ver deforestation ver deforestation ver deforestation ver deforestation ver deforestation deforestation results life results final results applying deforestation annotated life program 
heap usage program original execution time decreased 
program uses large amount heap 
due factors ffl list lists produced generation built closures contain large number free variables 
consider example closure new cell contain free variables neighbour 
closures evaluated immediately generation printed output device 
powerful strictness analyser able detect strictness program avoid creating large closures strictness analyser glasgow haskell compiler currently able detect strictness lists 
ffl program prints generation standard output converting printable form 
converting internal representation generation string consumes large amount heap printing takes time 
expect deforestation remove intermediate representation internal form determine stable state reached 
notice code size version higher 
due code explosion created gen involved unfolding shift times 
partly expected shift means chapter results analysis trivial function code size larger necessary inspection output deforestation revealed duplicated code 
improvements algorithm required reduce code explosions kind lines enhancements chapter back loops boring expression transformation 
pattern matching illustrate usefulness deforestation eliminating data structures lists tuples chose program performing simple pattern matching strings 
pattern matcher implementation unix tm filename matching pattern sequence pattern elements 
pattern element forms ffl characters matches single instance ffl matches single character 
ffl matches sequence zero characters 
single character exact matches represented character match 
pattern matching function match takes pattern string returns true pattern matches string false 
application pattern matcher known pattern intermediate structure representing pattern removed version pattern matcher specialised pattern generated 
guise deforestation algorithm acting restricted form partial evaluation albeit terminates eliminate static pattern argument 
example eliminating small intermediate data structure profound effects execution time program 
eliminating structure repeatedly examined 
deforestation performs deconstruction compile time 
chapter results analysis module main main data pat char match true match cs false match ps ps cs case chars 
case cs 
false cs 
elem chars match ps cs 
case cs 
false cs 
match ps cs 
case cs 
match ps cs 
match ps cs true match ps cs main readfile usr dict words abort 
print length filter match pat lines pat abc def ghi haskell implementation unix filename matching chapter results analysis experiments chose sufficiently complicated pattern abc def ghi counted number matching lines dictionary containing words 
results order application match static pattern pat annotate definitions 
added annotations program match pat annotations deforestation algorithm transforms call match pat specialised matcher pat 
simplifications new matching function consists mutually recursive functions occurrence pattern 
recursive functions generated calls match case passed input pattern termination case knot tying process discovering renaming generating new recursive definition 
recursive calls match passed subexpression original pattern simply expanded pattern reached 
worth noting expression case match equivalent boolean case expression call match selector expression treeless form case match ps cs true 
true false 
match ps cs automatic conversion process extracts call match making result expression residual chapter results analysis code size bytes heap allocations bytes run time deforestation results match match ps cs case true 
true false 
match ps cs treeless form restriction prevented generating optimal specialised pattern matcher transformer eliminate static pattern data structure 
results 
see execution time program improved accompanied small reduction code size increase heap usage 
attribute relatively small improvement efficiency slow character input output haskell 
example demonstrates advantages deforestation removal intermediate structure possible 
similarity drawn example gluck jones extend deforestation order able derive optimal pratt kmp specialised pattern matchers general matching algorithm 
chapter results analysis chapter summary deforestation algorithm chapter deforestation algorithm higher order language 
significant generalisation wadler order deforestation scheme applies higher order programs applicable majority modern programming languages lambda calculus incorporates mechanism residual data structures program 
enables function input deforestation algorithm suitable translation function treeless form 
goals formulate higher order deforestation transparent optimisation strategy 
ensure optimisation applicable program isn expect remove intermediate data structures program programmer aware means syntactic specification exactly deforestation applicable 
achieved introducing construct means indicating residual data structures left place deforestation process 
construct ensure expressions duplicated chapter tion protecting non linear bindings 
ensure program efficient original employed full laziness transformation extracts expressions rebinding 
construct turns universally useful way indicate residual structures ensure termination algorithm prevent loss efficiency transformed program 
having formulated original algorithm recognised deficiency treeless form correspond exactly normal form language consequently algorithm insert lets output keep treeless form 
counterintuitive overly restrictive cases 
wanted generalise treeless form corresponded normal form modulo calls recursive functions transformation extra restrictions placed ensure termination 
principles logic formulate new deforestation algorithm 
logic sequent calculus important property cut elimination 
cut elimination reduction process proof trees renders proof normal form eliminating applications rule cut rule 
logic translated programming language language normal form save single construct call cut construct identical meaning cut avoid confusion 
situation exactly required deforestation reduces terms normal form albeit recursive functions covered cut elimination 
merged languages natural deduction sequent calculus obtain new normal form language defined cut elimination language proved algorithm terminated 
defined simple order language recursion formulated deforestation algorithm 
merging transparent deforestation algorithm sound logical basis generalised treeless form 
unfortunately efforts find termination proof algorithm unsuccessful provide convincing arguments termination certain restrictions input terms 
restrictions intrusive imposed treeless form terms algorithm arbitrary terms allowed right application cases 
chapter chapter tackled issues closely related deforestation algorithm 
firstly examined subject automatic conversion general terms treeless form performed optimally definitions treeless form gave algorithm process 
secondly topic linearity covered showed situations basic deforestation scheme impair efficiency program 
remedy matter provide set rules adhered ensure safety conjecture sufficient 
discussed transparency property deforestation demonstrated possible effects deforestation examining subject program 
conversion treeless form syntax directed transparent process programmer determine examining original definitions recursive functions deforestation data structures removed residual 
implementation having suitable deforestation algorithm constructed prototype glasgow haskell compiler demonstrate algorithm fits real compilation setting 
designed implementation varying amounts programmer intervention 
intervention algorithm attempt perform deforestation possible making dangerous trade offs speed memory usage 
worthwhile approach large number functions standard haskell prelude operate lists features list comprehensions deforestation transparently programmer 
involves modest increase code size functions involved unfolded call site benefit terms reduced memory usage outweigh code bloat small functions involved 
programmer wishes intervene deforestation process greater amount flexibility available potent optimisation strategy available 
major chapter technique annotation functions deforestation 
annotating function programmer indicates unfolded call site intermediate structures creates consumes eliminated possible 
enables user defined list processing functions applicable intermediate list removal functions manipulate datatypes trees 
devised scheme annotated function definitions communicated haskell modules compilation time 
enables deforestation performed function definitions module program standard prelude 
deforestation algorithm chapter extended glasgow haskell core language 
required modifying algorithm transform expressions involve arbitrarily nested 
incorporated version treeless form conversion algorithm described chapter 
gave full description knot tying algorithm 
experimenting earlier versions implementation discovered situations simple knot tying algorithm improved order reduce size generated code 
techniques described chapter turned vitally important applied algorithm larger examples 
additional techniques described code size explode dramatically increasing compilation time size resulting binary 
extreme cases hamper execution time program cancelling beneficial effects deforestation intermediate structures removed 
results chapter applied prototype deforestation implementation non trivial example programs 
algorithm remove intermediate data structures predicted removable transparency property 
effects memory usage run time program dramatic especially intermediate structure removed part inner loop 
functions expressions complex chapter resulting code size larger expected 
prevented larger examples successfully concluded techniques lines chapter necessary reduce size output deforestation 
research deforestation algorithm intend continue generalise deforestation algorithm 
investigation termination properties improved algorithm chapter hopefully leading termination proof 
significant improvement allowing implementation new algorithm generalised definition treeless form 
aim investigate linearity restrictions deforestation develop scheme may relaxed certain conditions 
possible avenue research lies linear type systems turner wadler mossin assign linearity annotations bound variables providing information deforestation expressions danger duplicated 
relationship foldr build deforestation section outlined combinator deforestation gill launchbury peyton jones gil 
section give detailed description relative power systems propose possible avenue research findings 
searched long time find clear relationship deforestation scheme foldr build rule believing deforestation superset scheme 
appears case obvious theorem relating gm 
informally describe differences ffl foldr build deforestation express removal intermediate lists consumer producers 
reason translation chapter foldr allows single argument foldr build rule 
zip function classic example zip xs ys foldr xs ys ys ys deforestation scheme remove intermediate lists multiple list consumer producers problems 
ffl cumbersome express irregular list consumers foldr 
term irregular somewhat subjective general applies functions treat elements list differently 
examples foldr tail halve function new list consisting element input 
deforestation difficulty eliminating intermediate lists consumed functions 
ffl list consuming functions naturally expressed foldl foldr 
examples include sum reverse 
translation foldl foldr necessary foldr build introduces inefficiency removed additional transformations intermediate lists eliminated 
ffl foldr build list producer represented simply abstracting existing function cons nil deforestation adhere treeless form list producers 
facilitates removal intermediate lists foldr build residual respect deforestation 
classic example reverse treeless form forces list produced residual reverse xs ys case xs nil ys cons xs cons ys reverse xs reverse function defined build simply abstracting cons nil build output list incurring penalty allowing list removed foldr build deforestation 
chapter ffl deforestation natively handles arbitrary data structures foldr build defined lists 
believe equivalent foldr build definitions corresponding combination rules defined straightforward way algebraic data structures 
knowledge technique implemented 
summarise important points foldr build problems irregular list consumers functions consume multiple lists deforestation problems irregular list producers 
plan assess possibility hybrid scheme draw deforestation methods remove intermediate data structures possible system 
implementation higher order deforestation prototype distributed glasgow haskell compiler requires number improvements production situations 
code size inherent bound size code generated deforestation transformation turned major stumbling block 
system keep promises intermediate structures indicated removable transparency property removed resulting code far larger necessary cases complex functions combined 
illustrated life example chapter removed intermediate structure possible annotations ended program nearly twice large original 
code explosion significant impact compilation time perceived usability system 
incorporated additional techniques address code size issue chapter form extra rules transformation system improvements knot chapter tying process 
techniques essential appears investigation problem required enable deforestation practice 
possible approach define maximum size resulting code initial function definitions expression 
known quantity termination proof algorithm take worst case 
believe worst case far large practice 
example maximum depth result transformation determining maximum depth labels number possible permutations label expressions 
examples algorithm terminates earlier guarantee 
techniques chapter help reduce number permutations extracting lets applicative terms example may case sophisticated techniques reduce maximum code size acceptable level 
minor code size issue unfolding function call site 
wasteful situations deforestation performed 
impossible determine general specialised cases useless unfolding detected prevented 
automation order perform deforestation simple intermediate list removal programmer employ explicit annotations direct transformation 
situation improved possible derive safe annotations circumstances 
functions useful deforestation identified simple criteria non residual inputs outputs operate recursively inputs having recursive datatypes 
necessary impose size restriction functions annotated avoid dangerous code size speed tradeoffs 
performed short cut deforestation identifying functions translated automatically applications combinators foldr build ls 
similar techniques applied deforestation setting translation required just annotation suitable functions 
appendix code examples queens code glasgow haskell core intermediate output queens program section 
safe 
case length int 
case 

letrec ijs 
case ijs nil 
nil ij ijs 
case ij tup 
case 
case 
chapter case 
true 
case 
case 

case 
case 

case 
true 
case 

case 


false 
false false 
false cons ijs zip int int queens 
case 
case 
cons nil nil letrec ps 
case ps nil 
nil cons ps 
letrec appendix code examples 
case nil 
ps cons 
case safe true 
cons int cons nil false 
case 

queens main print int text int sum int concat int queens safe letrec 
case cons 
case 
case 
case 
true 
case 
case 

chapter case 
case 

case 
true 
case 

case 

case 
false 
false true 
case 
case 

false 
false false 
false nil 
true 
case length int 
case 

queens letrec ps 
appendix code examples case ps nil 
nil cons ps 
ps ps 
case 
case 
case 
true 
ps false 
case safe true 
int cons nil case 

ps cons false 
case 

ps 
case 
case 
cons nil nil ps case 

queens ps main print int text int sum int concat int queens chapter bibliography ars augustsson 
generating unique names 
journal functional programming jan 
aug augustsson 
compiling lazy functional languages part ii 
phd thesis department computer science chalmers university technology goteborg november 
bd burstall darlington 
transformational system developing recursive programs 
journal acm january 
bur burge 
examples program optimisation 
technical report rc ibm thomas watson research centre oct 
bw richard bird philip wadler :10.1.1.100.9674
functional programming 
international series computer science 
prentice hall 
cf curry feys 
combinatory logic volume 
north holland 
chi chin 
automatic methods program transformation 
phd thesis university london march 
fea feather 
system developing programs transformations 
phd thesis university edinburgh 
fea feather 
system assisting program transformation 
acm transactions programming languages systems jan 
fw ferguson wadler 
deforestation 
functional programming glasgow workshops computing 
springer verlag august 
chapter gal gallier 
constructive logics part tutorial proof systems typed calculi 
theoretical computer science march 
gen gentzen 
investigations logical deduction 
mathematische zeitschrift 
gil andrew gill 
cheap deforestation non strict functional languages 
phd thesis department computing science glasgow university september 
gill launchbury peyton jones 
short cut deforestation 
functional programming languages computer architecture pages 
acm 
glt 
girard lafont taylor 
proofs types 
cambridge tracts theoretical computer science cambridge university press 
gm andrew gill simon marlow 
personal communication 
road glasgow 
ham hamilton 
compile time optimisation store usage lazy functional programs 
phd thesis university stirling october 
ham hamilton 
higher order deforestation 
technical report university keele 
hbh hammond burn howe 
spiking caches 
functional programming glasgow ayr scotland 
springer verlag 
hg hudak goldberg 
serial combinators optimal grains parallelism 
proc ifip conf functional programming computer architecture volume lncs pages nancy aug 
hop mark hopkins 
regular infinite lambda calculus 
note distributed usenet group comp lang functional october 
howard 
formulas types notion construction 
seldin hindley editors curry essays combinatory logic lambdacalculus formalism pages 
academic press 
bibliography hudak peyton jones wadler report functional programming language haskell 
acm sigplan notices may 
version 
hug hughes 
design implementation programming languages 
phd thesis programming research group oxford july 
hug hughes 
novel representation lists application function reverse 
technical report programming methodology group chalmers inst sweden 
kmp knuth morris pratt 
fast pattern matching strings 
siam journal computing 

transformation system theoretical study 
proc 
rd symposium programming pages paris 
lj launchbury peyton jones 
state haskell 
lisp symbolic computation volume pages dec 
ls john launchbury sheard 
warm fusion 
simon peyton jones editor functional programming languages computer architecture san diego california june 
acm sigplan sigarch acm 
mar simon marlow 
update avoidance analysis interpretation 
functional programming glasgow ayr scotland 
springer verlag 
mog moggi 
computational lambda calculus monads 
symposium logic computer science asilomar california june 
ieee 
mw marlow wadler 
deforestation higher order functions 
functional programming glasgow workshops computing ayr scotland 
springer verlag workshops computing 
par partain 
nofib benchmarking suite 
launchbury sansom editors functional programming glasgow ayr scotland 
springer verlag workshops computing 
chapter pey peyton jones 
implementation functional programming languages 
prentice hall 
pey peyton jones 
glasgow haskell compiler technical overview 
joint framework information technology conference keele 
pj partain simon peyton jones 
effectiveness simple strictness analyser 
functional programming glasgow ayr scotland 
springer verlag 
pra prawitz 
natural deduction proof theoretical study 
almquist stockholm 
pw peyton jones wadler 
imperative functional programming 
symposium principles programming languages pages charleston jan 
rey reynolds 
types abstraction parametric polymorphism 
information processing volume pages 
north holland 
san sands 
proving correctness recursion automatic program transformations 
mosses nielsen schwartzbach editors sixth international joint conference theory practice software development tapsoft volume lecture notes computer science pages 
springer verlag 
san sands 
total correctness local improvement program transformation 
symposium principles programming languages san francisco california january 
san andre santos 
compilation transformation non strict functional languages 
phd thesis department computing science glasgow university 
sch scherlis 
expression procedures program derivations 
phd thesis stanford university aug 
bibliography gluck jones 
unifying partial evaluation deforestation supercompilation gpc 
programming languages systems volume lecture notes computer science pages 
springer verlag april 
tur turner 
recursion equations programming language 
darlington henderson turner editors functional programming applications 
cambridge university press 
david turner philip wadler christian mossin 
type 
simon peyton jones editor functional programming computer architecture san diego california june 
acm sigplan sigarch acm 
wad wadler 
applicative style programming program transformation list operators 
wad wadler 
better laziness lazy evaluation garbage collection compile time 
acm symposium lisp functional programming pages 
wad wadler 
better laziness ii composing functions 
proc 
workshop programs data objects volume lncs copenhagen 
springer verlag 
wad wadler 
concatenate vanishes 
technical report dept computing science glasgow university 
wad wadler 
deforestation transforming programs eliminate trees 
european symposium programming volume lncs nancy 
wad wadler 
theorems free 
functional programming languages computer architecture 
addison wesley 
wad wadler 
comprehending monads 
acm symposium lisp functional programming nice june 
version appear mathematical structures computer science 
chapter wad wadler 
deforestation transforming programs eliminate trees 
theoretical computer science 
wad wadler 
essence functional programming 
symposium principles programming languages 
