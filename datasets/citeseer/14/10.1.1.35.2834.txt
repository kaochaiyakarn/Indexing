issn de recherche institut national de recherche en informatique automatique taxonomy functional language implementations part call value rmi douence pascal fradet programme calcul programmation unit de recherche inria rennes irisa campus universitaire de beaulieu rennes cedex france taxonomy functional language implementations part call value rmi douence pascal fradet douence fradet irisa fr programme calcul programmation projet rapport de recherche pages unified framework describe compare functional language implementations 
express compilation process succession program transformations common framework 
step different transformations model fundamental choices optimizations 
benefit approach structure decompose implementation process 
correctness proofs tackled independently step amount proving program transformations functional world 
paves way formal comparisons estimating complexity individual transformations compositions 
focus call value implementations describe compare diverse alternatives classify known machines 
aims open design space functional language implementations suggest distinct choices mixed yield efficient hybrid machines 
key words compilation optimizations program transformations calculus combinators research report extended version taxonomy functional languages implementations appeared proc 
th int 
symp 
programming languages implementations logics programs :10.1.1.35.2834:10.1.1.35.2834
includes thorough presentation formal framework connection calculus cps conversion presents new alternate abstraction algorithms 
adds annex gathering proofs properties 
une des des langages appel par nous un cadre pour les de langages 
nous le processus de compilation comme une suite de transformations de programmes dans le cadre 
les de mise en ainsi que les optimisations comme des transformations 
les de cette approche sont de de la compilation de simplifier les de correction de des en chaque transformation ou leur composition 
nous nous sur les mises en de appel par les options les ou machines 
ce travail aussi pour de perspectives nous comment dans des plus 
mots cl compilation optimisations transformation de programmes calcul ce rapport de recherche est la version de article taxonomy functional languages implementations dans proc 
th int 
symp 
programming languages implementations logics programs :10.1.1.35.2834:10.1.1.35.2834
il une plus du cadre la connexion avec le calcul la conversion cps plusieurs autres algorithmes abstractions 
les de nonces dans le 
taxonomy functional language implementations studied issues concerning functional languages implementation 
seminal proposal landin years ago plethora new machines compilation techniques proposed 
list existing machines includes surely limited secd fam cam tim zam machine krivine machine :10.1.1.43.208:10.1.1.53.3729
implementations described machine collection transformations compilation techniques cps compilers 
furthermore numerous papers optimizations adapted specific machine specific approach 
looking myriad distinct works obvious questions spring mind fundamental choices 
respective benefits alternatives 
precisely common points differences compilers 
particular optimization designed machine adapted machine 
finds comparatively papers devoted questions 
studies relationship individual machines best knowledge global approach describe classify compare implementations 
presents advance general taxonomy functional language implementations 
approach express common framework compilation process succession program transformations 
framework considered hierarchy intermediate languages subsets lambda calculus 
description implementation consists series transformations 
tn compiling particular task mapping expression intermediate language 
language consists functional expressions seen machine code essentially combinators explicit sequencing calls 
step different transformations designed represent fundamental choices optimizations 
benefit approach structure decompose implementation process 
seemingly disparate implementations share compilation steps 
approach interesting payoffs far correctness proofs comparisons concerned 
correctness step tackled independently amounts proving program transformation functional world 
paves way formal comparisons estimating complexity individual transformations compositions 
steps cause greatest impact compiler structure implementation reduction strategy searching redex environment management compilation reduction 
steps include implementation control transfers calls returns representation components data stack environments various optimizations 
task clearly huge presentation means complete 
concentrate pure expressions source language lx fundamental choices described simple language 
second focus callby value reduction strategy standard implementations 
section describe framework model compilation process 
section resp 
section alternatives optimizations compile call value resp 
environment manage rmi douence pascal fradet ment 
section includes comparison main options 
section devoted simple steps leading machine code 
section describe easily extended deal constants primitive operators fix point call name strategies 
mention remains done model call need graph reduction 
indicate possible mix different choices single compiler section conclude short review related works 
taxonomy functional language implementations general framework transformation sequence involves intermediate languages close described unrestricted applications reduction strategy explicit sequencing combinator 
second excludes unrestricted uses variables encodes environment management 
handles control transfers calls returns 
language seen machine code 
focus intermediate language overview briefly described 
control language defined combinators push construct seen shorthand combinator applied lx 
language subset expressions substitution notion free bound variables calculus 
push vars notable syntactic feature rules unrestricted applications 
main property choice redex relevant anymore redexes needed 
key point compile evaluation strategies explicit primitive intuitively sequencing operator read evaluate evaluate push returns result binds previous intermediate result evaluating combinators different definitions possible definitions 
pick specific point simply impose definitions satisfy equivalent conversions push push occur free usual imperative sequencing operator natural enforce associativity combinator property prove especially useful transform programs 
assoc omit parentheses write push push 
reduction consider reduction rule corresponding classical reduction push rmi douence pascal fradet standard implementations interested modelling weak reductions 
sub expressions inside push considered redexes write redex resp 
reduction normal form weak redex resp 
weak reduction weak normal form 
note compatible closure reduction natural inductive rules reflexive transitive closure redexes clearly disjoint reduction left linear term rewriting system orthogonal confluent 
furthermore redex needed rewrite suppress redex consequence property reduction strategies normalizing 
property key point view transformations compiling reduction order 
typed subset interested expressions transformations source programs produce expressions denoting results reduced expressions form push 
order express laws easily convenient restrict type system 
rs push rs typed subset impose restrictions source expressions 
example allow reflexive types aa type source expression 
restrictions enforced type system results functions combined 
example composition restricted denote result type rs type constructor denote function 
property subject reduction property 
type system restricts set normal forms general includes expressions push push natural facts 
property closed expression canonical push reducible 
deduce properties property closed expression rs normal form push closed expression normal form taxonomy functional language implementations consequence type system reduction typed closed expressions specified natural semantics push normal form general expressions add inference rule push normal forms property normal form note assoc may produce ill typed programs 
assoc laws long final expression typed single rule reduction sufficient 
allow unrestricted assoc reduction done modulo associativity 
rule assoc specifies string reduction confluent modulo assoc 
laws framework enjoys number algebraic laws useful transform functional code prove correctness equivalence program transformations 
list 
occur free rs occur free rs rs rules permit code moved inside outside function bodies invert evaluation results 
example sound occur free hypothesis push push assoc subst rest introduce laws express optimizations specific transformations 
rmi douence pascal fradet connection calculus convenient abstraction express reduction strategies 
recall subset calculus combinators 
important point give precise definition combinators 
just assume respect properties assoc 
definitions chosen step 
order provide intuition give possible definition alternative definitions section 
def lc push lc lc lx fresh la lb lc push la lc la lc lx lx push general reduction rules combinators form 

push 

components code acts control data stack registers 
words code seen state machine 
want commit definite definition combinators want reduction left right rules combinators simulates reduction say property 

normal form order enforce property sufficient check exits closed expressions 
push 




example def push lc lx push lc lx vg establishes property holds def 
final stage compilation process convenient assoc reshape code 
example may want code form 
basic instructions 
shape left right reduction reduction expressions akin execution machine code 
want combinators classical reduction implement naturally assoc sufficient check 
contrary rule valid change termination properties weak calculus 
left right reduction weak call name assoc applied restrictions 
taxonomy functional language implementations connection calculus established inverse transformation 
push lx 
back expressions expressions convertible corresponding source expressions equal extensional calculus 
property bs hs lh reverse implication clearly true expressions encode specific reduction order possibly unsafe call value equality calculus bound normal order 
example push push push lx lx lx ly ly loops head normal form 
overview compilation phases describing implementations formally give idea different phases choices hierarchy intermediate languages 
phase compilation control described transformations pair push specifies component storing intermediate results data stack 
main choice eval apply model va push enter model vm 
va family describe minor options avoiding need stack va va right left va vs left right evaluation va 
transformations compile reduction 
language avoids unrestricted uses variables introduces pair push 
behave exactly push corresponding properties hold 
just act conceptually different component stack environments 
main choice shared environments vector copied environments ac 
choice transformations depending way environments copied rmi douence pascal fradet ac ac ac 
family generic transformations modelling choices related management environment stack representation closures 
transformation compile control transfers step avoided transformation sl expressions 
language calls returns explicit 
introduces pair push specifies component storing return addresses 
control push va va va va vm sl abstraction push ac ac ac ag family instantiations transfers push summary main compilation steps options gathers different options described sections 
transformations different phases combined superscript 
stack components avoided underlined transformations 
combinators expressed terms push described transformations 
simplify presentation syntactic sugar tuples pattern matching taxonomy functional language implementations compilation control consider left right vs right left fundamental choice implement callby value 
radical dichotomy explicit applies vs marks 
option standard technique secd cam second hinted zinc :10.1.1.53.3729
compilation control apply eval apply model scheme applications compiled evaluating argument function applying result result standard transformations compilation right left call value described 
normal forms denote results abstractions variables strict languages bound normal forms transformed results push 
va va push va lx push va va va va app app compilation right left cbv explicit applies va rules explained intuitively reading return value push evaluate va apply app 
va produces typed expressions result type property 
property closed va rs rt type variable correctness stated property establishes reduction transformed expressions simulates call value reduction cbv source expres sions 
property closed cbv va va clearly useless store function apply immediately 
optimization expressed law push app push bs example 
lx ly lz simplifications rmi douence pascal fradet va push push push push push push push push push va lz choice redex matter anymore 
illicit call value reduction ly lz occur va illustrate possible optimizations take standard case function applied arguments lx lx 
va lx lx 
va va push push va 
app app va va push va 
app app va va push va 
app app assoc va va push push va 
app app app 
va va va app combinators statically removed 
doing avoided construction intermediary closures corresponding unary functions denoted lx lx optimization generalized implement phase implementations 
important point note framework denotes function applied arguments push 
sophisticated optimizations designed 
example closure analysis ensures set binary functions bound variables applied arguments app push combinators eliminated 
information requires potentially costly analysis functions application contexts satisfy criteria 
usually implementations assume higher order variables bound unary functions 
functions passed arguments considered unary compiled accordingly 
transformation va describing left right call value expressed rule composition va va va app app push derived va follows va va va app va va push push app taxonomy functional language implementations va va push property holds va expressed involves slightly complicated shifts 
equivalent rule rs push app variants transformations va va may produce expressions push push push 
reduction expressions requires structure stack able store arbitrary number intermediate results 
implementations choice data stack disallow pushes row 
case rule compositions va changed va va va push new rule easily derived original 
similarly rule compositions va changed va va va expressions component push act may single register 
possible motivation transformations produced expressions possess unique redex reduction 
reduction sequence sequential unique 
compilation control marks push enter model evaluating function argument applying results solution evaluate argument apply unevaluated function right away 
implementation natural call name function evaluated applied argument 
call value function evaluated argument case immediately applied returned result 
order detect evaluation way distinguish argument absent role marks 
function evaluated test performed mark function returned result closure built argument function applied 
technique avoids building closures price dynamic tests 
standard transformation mark supposed value distinguished 
functions transformed grab intended reduction rules push grab push push grab push rmi douence pascal fradet combinator grab mark defined practice grab implemented conditional tests presence mark 
transformation right left call value described 
vm vm grab vm lx grab vm vm push vm vm compilation right left call value marks vm correctness vm stated property establishes reduction transformed expressions simulates call value reduction source expressions 
property closed cbv vm vm new laws corresponding reduction rules grab push grab push rs grab example 
lx ly lz simplifications vm push push grab grab grab push grab grab grab push grab grab grab grab vm lz function lx lx known applied arguments code optimized save dynamic tests 
appears vm subject kind optimizations va related optimizations expressed rules 
take expression lx lx 
vm lx lx 
push vm push vm grab grab vm 
example grab push push push push push argument associated mark pair 
mark selects alternative apply function id mark associated dummy function id selecting second alternative yield result 
taxonomy functional language implementations push vm push vm grab vm 
push vm push vm push vm grab 

push vm push vm vm grab statically removed avoided dynamic tests 
variants sense consider left right strategy 
point approach prevent building closures testing argument 
argument evaluated function closely related transformations marks 
generic transformation described follows vm vm lx vm vm push vm vm combinators push push push push generic compilation right left call value marks vm get back vm grab id second canonical transformation see page vm grab sl id reduction rule grab sl recursive making grab explicit code vm permits simplifications alternative 
example vm lx ly push vm push mark grab simplified transformation vm yields push grab sl vm push grab sl executed twice 
comparison compare efficiency codes produced transformations va vm 
emphasize point section just illustrate advantage unified framework making formal comparisons possible finding complexity upper bounds pathological examples 
course style comparisons take place benchmarks remain needed order take account complex implementation rmi douence pascal fradet interactions memory cache gc compare different reduction strategies call value vs call need 
saw transformations subject identical optimizations examined unoptimized codes 
code produced vm builds closures corresponding va code 
mark represented bit bit stack parallel data stack example vm average greedy space resources 
concerning time efficiency size compiled expressions gives approximation overhead entailed encoding reduction strategy assuming push grab app constant time implementation 
easy show code expansion linear respect size source expression 
precisely va vm size size 
upper bound reached example lx occurrences 
thorough investigation possible associating costs different combinators encoding control push cost pushing variable mark clos cost building closure push app grab cost corresponding combinators 
take number abstractions number occurrences variables source expression cost va clos push app cost vm grab push benefit vm va replace closure construction app test app 
clos comparable test example returning closure amounts build pair section vm produce expensive code va closure building constant time operation section vm arbitrarily better va change program complexity pathological cases 
practice situation clear 
mark grab implemented test followed app 
mark test followed push variables closure building abstractions 
cost vm test app clos push push resp 
representing likelihood presence resp 
absence mark depends program 
best situation vm closure built 
take reasonable hypothesis test app find cost closure construction times costly app test vm advantageous 
favorable odds clos worth app 
lead conclude vm considered copy scheme closures 
tests may costly practice compared construction small closures 
best way probably perform analysis detect cases vm profitable 
information taken account get best approach 
section va vm mixed 
taxonomy functional language implementations connection cps conversion transformations vx share goal compiling control cps transformations 
cps expressions redex reduction closest transformations ones 
take definitions def section combinators va fischer cps transformation :10.1.1.15.8355
definitions def rewrite va follows va push lc def va lx push va lc lc lx va def va va va lc va lm va def lc va lm va lm exactly fischer cps 
far types concerned saw va rs rt recognize cps types giving meanings rs ans ans rt ans ans ans distinguished type answers 
note ary functions allowed add rule ans ans cps expressions possible design inverse transformation 
transformation section seen generic direct style transformation 
easy show property va va va va na nm proof 
structural induction 
example proof va va push lx va push va va lx 
va induction hypothesis lx va va va va va induction hypothesis lx rmi douence pascal fradet compilation reduction compilation step implements substitution transformations transformations akin abstraction algorithms consist replacing variables combinators acting environments 
value variable fetched environment needed 
lexical scope paths values environment static 
compared adds pair push uses fixed number variables order define combinators 
generic abstraction denotational transformation ag generic abstraction specialized model choices subsections 
transformation done relatively compile time environment initially empty closed expression 
integer denotes rank variable environment 
ag env ag dupl ag swap se ag ag push push ag mkclos ag mkbind ag ag access appclos generic abstraction ag ag needs new combinators express saving restoring environments dupl swap se closure building opening mkclos appclos access values access adding binding mkbind 
combinator pair defined dupl push push swap se push push closure combinators mkclos appclos different definitions long verify property push push mkclos appclos push example possible definitions mkclos push appclos push mkclos push push appclos app option uses pairs way concrete 
second option abstracts representation considerations 
simplifies expression correctness properties rest 
taxonomy functional language implementations way environment combinators mkbind access instantiations different definitions detailed subsections state common property push push push mkbind access push transformation ag optimized adding rules ag app ag appclos ag pop se ag free pop se push variables bound closures stored environment 
original rules ag push build closure 
useless boxing avoided rule ag push access abstraction naive definition grab result inefficient combinator 
introduce new combinator grab add rule ag ag grab grab ag push push grab push push mkclos rs push grab push variables bound closures stored environment 
previous rules ag grab builds closure 
boxing avoided new combinator grab rule ag grab grab access push push grab access push access rs push grab access push access appclos mark constant closure necessary case ag push push swap se ag shared environments choice instantiate ag linked environments 
specialization noted widely functional machines 
structure environment tree closures closure added environment constant time 
hand chain links followed accessing value 
access time complexity number occurrence binding de bruijn number 
rmi douence pascal fradet specializing ag amounts define environment combinators follows mkbind push access fst snd fst push snd push combinators instantiation abstraction shared environments example 
push mkbind mkbind dupl push mkclos swap se access appclos bindings added mkbind mkbind current environment access coded access fst snd 
correctness stated property 
property closed push example 
come back example previous section lx ly lz illustrate reduction expressions 
simplifications va push push push push push push push push push push dupl dupl push mkbind access mkclos swap se mkbind access swap se mkbind access push push dupl push mkbind access mkclos swap se mkbind access swap se mkbind access push push mkbind access push lz noted framework denotes function applied arguments 
corresponding links environment collapsed loss sharing 
list environment vector locally variable accesses modified consequently 
allows formalize optimization described closure analysis result 
copied environments choice provide constant access time 
case structure environment vector closures 
code copying environment length operation inserted ag order avoid links 
scheme prone space leaks allows suppress useless variables copies 
taxonomy functional language implementations macro combinator copy produces code performing copy structure 
copy dupl access swap se dupl access swap se access push mkbind see structure environment tree closures effect copy prevent sharing occur 
environments represented vectors mkbind adds binding vector access constant time operation 
mkbind push access push adds value empty cell vector combinators instantiation abstraction copied environments ac index designates free cell vector 
statically computed rank variable associated mkbind occurrence static environment example ac mkbind ac rank stored fourth cell environment 
maximum size vector statically calculated 
simplify presentation leave administrative tasks implicit 
abstractions time copies 
rules differing ag 
solution copy environment just adding new binding :10.1.1.53.3729
step know ary functions fully applied shared need copy environment 
overhead placed function entry closure building remains constant time operation 
transformation produces environments shared closures 
indirection accessing environment 
ac copy mkbind ac copy function entry ac abstraction environment represents restricted variables occurring free subexpression example 
ac push copy mkbind dupl push ac mkclos swap se access appclos rmi douence pascal fradet code builds vector environment specialized copy previous environment new bindings mkbind access coded access second solution copy environment building opening closures 
copy opening time necessary order able add new bindings contiguous memory environment remain vector 
transformation produces environments shared may accessed directly packed code pointer form closure 
ac push copy push copy ac mkclos copy closure building opening ac abstraction refinement option copy environment building closures :10.1.1.43.208
order able add new bindings closure opening local environment needed 
closure built concatenation specialized environments copied 
code variables specify environment accessed 
transformation scheme remains similar rule redefined take account environments 
ac dupl ac swap se ac ac push copy push push ac mkclos ac mkbind ac ac access appclos ac access appclos dupl push push push push swap se push push push mkbind push push push mkbind push el push abstraction local environments ac abstraction local environments compatible vm ac grab generate different versions ac may appear closure may applied 
code duplication obviously realistic 
taxonomy functional language implementations comparison assuming basic combinator implemented constant time size abstracted expressions gives approximation overhead entailed encoding reduction 
easy show entails code expansion quadratic respect size source expression 
precisely size size va number abstractions number variable occurrences source expression 
expression reaches maximum 
upper bound approached example lx lx nl nl product indicates efficiency depends equally number accesses length 
ac size size ac va clear efficiency ac dependent accesses 
abstractions complexity order may adapted individual source expressions 
complexities highlight main difference shared environments favors building copied environments favors access 
point bounds related quadratic growth implied turner abstraction algorithm 
balancing expressions reduces upper bound nlogn 
technique applied expressions get nlogn complexity environment management 
abstractions compared memory usage 
ac copies environment closure ac may share bigger copy 
code generated ac consumes memory implies frequent garbage collections code generated ac may create space leaks needs special tricks plug see section 
family abstractions starting different properties ag swap ag example collection abstractions derived form ag 
variations introduce different environment manipulation schemes avoiding stacks elements reordering swap environment duplication dupl environment building mkbind closure building specify ones suited shared copied environments 
study necessary define rules dealing grab define rules presence copied environments compare mix variations 
transformations introduce indexed combinators generalizations previously combinators notion arity definition expression type rs said arity rmi douence pascal fradet swap abstraction variation suppresses occurrences swap se ag 
pushed environments stay fixed distance bottom stack popped swapped 
shared environments copied ones 
ag derived equation ag swap ag ag store ag arity ag env ag dupl ag ag arity ag push push repl ag mkclos arity ag mkbind ag arity ag take appclos arity swap push push push store push push push dupl push push push push repl push push push mkbind push push mkbind push push take push push push push access swap abstraction ag indexed combinators enjoy properties allowing code transformations 
store swap swap dupl swap dupl swap swap dual ag swap ag ag store ag property ag abstraction variations correct construction 
illustrate ag derived ag take rule compositions ag swap ag ag property swap dupl ag swap se ag unfolding swap dupl ag swap ag swap dupl definitions taxonomy functional language implementations dupl swap ag swap ag swap dupl properties dupl ag swap ag folding ary dupl ag ag folding ary dupl abstraction variation suppresses occurrences dupl ag duplications postponed really needed closure building opening 
change order magnitude depth environment stack needed reduce expression 
example depth environment stack ag ag ag derived equation ag copy ag dually ag ag pop arity note copy generalized dupl copy dupl 
ag env ag ag swap se ag arity ag push push ag pop mkclos arity ag mkbind ag arity ag copy access appclos arity copy push push push push pop push push mkclos push push push mkclos push push push property push push mkbind push dupl abstraction ag abstraction algorithm exploits sequencing encoded compositions 
saving restoring environment ag passed may add new bindings remove expressed nesting mkbind ag rule passing environment transformation shared copied environments 
ag may inefficient environment stored context copy closure evaluation 
compilation schemes closures arity rmi douence pascal fradet greater unevaluated basic values unary functions 
case copy basic constant time operation 
mkbind abstraction variation occurrences mkbind ag 
environments unfolded data stack 
avoids indirection provides direct access values 
denotes length environment ag derived equation ag push init mkbind ag dually ag ag ag env ag ag swaps ag ag push push ag mkclos ag ag ag appclos push push push push push push swaps push push push push mkclos push mkbind push mkclos push access push access push mkbind abstraction ag scheme variations example suited copied environment schemes 
closure building mkclos opening necessarily copy environment 
previous definitions component temporary fold unfold closure environments 
completely suppressed alternative definitions mkclos push push push id id id taxonomy functional language implementations transformation unfolds environment data stack 
general property ag move etos push mkbind ag environments unfolded environment stack closure stack move etos push push environments unfolded data stack merging components choice takes component instantiation step see section 
dupl swap abstraction variation mixes effects dupl swap transformations 
shared copied environments 
derived ag equation ag ds swap ag swap copy ag dupl ag dually ag store ag ds pop arity equation derivation general ag ds dupl ag arity ag ds env int ag ds ag ds ag ds ag ds push push store ag ds pop mkclos arity ag ds mkbind ag ds arity ag ds take appclos arity mkclos xl push push push push push mkclos dupl swap abstraction ag ds explained compilation schemes closures arity greater 
cases combinator store ag ds inserts element stack constant time operation store 
way swap bind abstraction dupl mkbind abstraction defined 
dupl swap mkbind abstraction variation mixes effects ag ds ag environments unfolded stack fixed place bottom stack grow shrink rmi douence pascal fradet bindings scope 
previously said mkbind abstractions suited shared environments 
denotes length environment ag dsb derived equation ag dsb push mkbind ag arity dually ag stores ag dsb arity ag dsb env int ag dsb ag dsb ag dsb ag dsb push push stores ag dsb mkclos arity ag dsb stores ag dsb ag dsb stores appclos arity stores push push push push push push dupl swap bind abstraction ag dsb mkclos abstraction variation suppresses occurrences mkclos ag 
closures allocated anymore 
code environment manipulated stacks bound environment tim :10.1.1.53.3729
macro combinator transforms environment structure list closures list unfolded closures list alternating codes environments inverse operation 
ag derived equation ag ag length dually ag ag dsb mkclos ag env ag dupl ag ag ag push push ag ag mkbind mkbind ag ag dupl access swap se access app taxonomy functional language implementations push push mkclos push push etos push push cx ce push ce push cx push mkbind push push mkbind push access etos push access etos push mkbind push access push access mkclos push access push access mkclos push mkbind mkclos abstraction ag abstraction manipulates data needs deeper stacks longer environments previous ones suppresses indirection level closure manipulation 
instantiated copy scheme ag bigger memory allocation granularity abstractions 
duplicates closures code environment cause trouble implement update operation lazy languages see tim 
order compare different options imperative determine cost indexed combinator constant linear 
indexed combinators constant time implementation assuming stack machine 
may useful express previous indexed combinators terms ones 
complexity may depend components merged kept separate see 
read push push push push write push push push flush indexed combinators rmi douence pascal fradet compilation machine code section explicit control transfers propose combinator definitions 
steps functional expressions seen realistic machine code 
control transfers conventional machine executes linear code instruction basic 
explicit calls returns 
framework reducing expressions form appclos involves evaluating closure returning solutions save return address 
model transformation expressions 
saves code function call push returns rts push function ends 
intuitively combinators seen implementing control stack 
compared expressions code sequences 
push push push rts rts push general compilation control transfers correctness stated property 
property closed normal form optimized version ag easily derived 
example dupl swap se push push push push dupl swap se push push push push push push push push push push push push taxonomy functional language implementations dupl push swap se swap ke dupl def 
get dupl swap se dupl push swap se swap ke push mkclos push mkclos rts mkbind mkbind appclos push appclos swap ke access access rts compilation control transfers expressions appclos code sequences 
combinator swap ke push push necessary order mix new component ones 
resulting code simplified avoid useless sequence breaks rule push push rts push get real machine code step introduce labels name sequences code push 
alternative transformation sl control abstraction phases 
transforms expression continuation passing style 
continuation encodes return addresses abstracted environment ordinary variable 
solution known chosen new jersey sml compiler 
prevents control stack relies heavily garbage collector 
appel claims simple inefficient suited implement callcc 
sl sl push push sl sl sl push push sl sl push sl sl sl app sl push app cps compilation control sl rmi douence pascal fradet top level expression called initial identity continuation id push 
optimization removes unnecessary manipulations continuation push push push correctness sl stated property 
property closed normal form push sl push sl separate vs merged components pairs combinators push push push definitions 
pair seen encoding component underlying machine definitions specify state transitions 
choose keep components separate merge 
options share definition composition 
keeping components separate brings new properties allowing code motion simplifications 
sequencing combinators different components commutative administrative combinators swap se useless 
possible definitions fresh variables follow lc push lc ls lc ls push lc ls le lc ls le push lc ls le lk reduction expressions seen state transitions machine push push push second option merge components 
administrative combinators remain necessary 
underlying machine components code control stack 
lc push push push lc lz push previously claimed transformations compared code size expansion assuming combinators constant time operation 
comparisons take taxonomy functional language implementations account components instantiation step change size combinators 
example swap se useless null size component component merged 
way copy cost merged cost kept separate 
rmi douence pascal fradet extensions describe extensions needed order handle realistic languages describe wider class implementations 
constants primitive operators data structures considered pure expressions fundamental choices described simple language 
realistic implementations deal constants primitive operators data structures 
concerning basic constants question results form push component introduced push 
options chosen 
advantage marking difference pointers values exploited garbage collector 
case type information available transform variables abstractions correctly 
conditional fix point operator primitive operators acting basic values introduced language straightforward way 
far data structures concerned choose treat closures separately 
interesting choice represent tags higher order functions :10.1.1.53.3729
rec lx push rec cond push plus cons cons head head push push plus push cons push tag head tag push extension constants primitive operators lists describes possible extension data stack store constants tagged cells lists 
call name mixed evaluation strategies choices discussed remain valid call name implementations 
compilation computation rule described 
presents possible transformations 
considers abstractions values evaluates function taxonomy functional language implementations applying unevaluated argument 
second tim krivine machine directly applies function argument 
scheme functions considered results 
na na na lx push na na push na na app nm nm nm lx nm nm push nm nm transformations call name na nm transformation nm simpler avoids overhead na 
hand making nm lazy problematic needs marks able update closures :10.1.1.50.4314:10.1.1.53.3729
exactly problem vm marks know function represents result applied 
case call value implementation return vm call need implementation update closure nm 
strictness analysis taken account order produce mixed evaluation strategies 
fact interesting optimization brought strictness information change evaluation order avoiding thunks unboxing 
assume strictness analysis annotated code denotes strict function variable defined strict abstraction na extended follows na push na na na app underlined variables known evaluated represented unboxed values 
example strictness information expression lx compiled push push push plus 
code push represented closure evaluated call boxed representation 
strictness annotations push push push plus evaluation call value closure built 
general forms unboxing optimizations expressed :10.1.1.50.4314
rmi douence pascal fradet call need graph reduction call need brings options 
update mechanism implemented closures modifying continuation :10.1.1.53.3729:10.1.1.53.3729
updating central implementations graph reduction 
expressing redex sharing updating notoriously difficult 
framework straightforward idea add store component new combinators 
expression takes returns store sequencing ensures store single threaded 
suspect adding store updates framework complicate correctness proofs 
hand done late stage compilation call name reduction 
transformations correctness proofs optimizations previously described remain valid 
complications involved updating confined single step 
currently working issue 
taxonomy functional language implementations classical functional implementations descriptions functional compilers hide fundamental structure implementation tricks optimizations 
states main design choices structuring classical implementations 
cosmetic differences descriptions real implementations 
extensions optimizations described 
state precisely differences categorical machine 
cam va simplifying composition transformations get cam fst snd cam lx push bind cam mkclos cam dupl cam swap se cam appclos fst snd dupl swap se combinators match cam fst snd push swap 
sequence push mkclos equivalent cam cur 
difference comes place bind closure case 
shifting combinator place closures evaluated merging appclos get push bind exactly cam sequence cons app 
strict krivine machine compiles control push enter model pp 

simple machine served basis zinc machine 
starting vm get grab fst snd appclos lx grab bind dupl push swap se swap se push swap se push push grab push push mkclos rts rs push grab push sequence dupl push swap se swap se push swap se equivalent sequence reduce uses stack store copy dupl environment return code mark 
main difference comes instruction grab merge bind recursive version grab see 
code grab grab bind access fst snd appclos grab fst snd appclos 
rmi douence pascal fradet compiler transformations components secd va id cam va id id vm id sml nj va sl ac id registers cbv va id ac dsb cbn na id ac dsb tim cbn nm id ac id classical compilation schemes quickly review differences real implementations 
secd machine saves environments bit scheme 
furthermore control stack environment stack gathered component called dump 
data stack saved dump 
replica closer idealized version derived 
sml nj compiler uses heap represented framework unique environment includes registers optimizations described 
compiler product greatly inspired study 
implements strict non strict languages program transformations 
environments unfolded environment data stack mkbind dupl swap see version ac 
call name tim unfolds closures environment mentioned :10.1.1.53.3729
environment copying included transformation ac effect preliminary lambda lifting phase tim 
taxonomy functional language implementations hybrid implementations study different options proved universal best choice 
natural strive get best world 
framework intricate related correctness proofs possible 
describe va vm mixed mix shared copied environments 
cases mixing compile time choice suppose static analysis produced annotated code indicating chosen mode subexpression 
mixing different control schemes annotations form types resp 
apply resp 
marks mode 
intuitively function takes argument evaluated mode body evaluated mode 
style annotation imposes variable evaluated fixed mode 
lx push id app grab push id hybrid compilation right left call value suppose possible distinguish special closure 
values produced mode form coercion necessary 
just adds push evaluation argument mode app evaluation function mode results returned push grab associated mode 
mixing different abstraction schemes solution uses coercion functions fit environment chosen structure vector linked list 
compilation switch world 
particular switching ac creates kind strict display comparison lazy display 
list vect ac solution uses environments mixing lists vectors :10.1.1.34.3197
mixa mix mkbind mixa rmi douence pascal fradet mixa access mixa mixa access mixa mixa access appclos mixa access appclos access access version access list access access version access vector hybrid abstraction extract abstraction annotated new mixed environment structure indicates bind current value vector link 
mixed structures built mkbind mkbind macro combinator mix copies restructures environment annotation 
paths values expressed sequences access access abstraction algorithm distinguishes vectors lists compile time environment constructors 
taxonomy functional language implementations framework describe prove compare functional implementation techniques optimizations see summary 
intermediate language bears strong similarities cps expressions 
take combinator definitions def section naturally get fischer cps transformation va section :10.1.1.15.8355:10.1.1.15.8355
hand combinators fully defined just respect properties 
see powerful framework cps express different reduction strategies 
pointed hatcliff danvy moggi computational metalanguage alternative language cps :10.1.1.53.3729:10.1.1.41.840:10.1.1.41.840
arising different roots surprisingly close moggi 
particular may interpret monadic constructs push get back monadic laws ass :10.1.1.53.3729:10.1.1.41.840
hand disallow unrestricted applications expressions general merely combinations 
related includes derivation machines denotational operational semantics :10.1.1.50.4314:10.1.1.50.4314
aim providing methodology formally derive implementations potentially large class programming languages 
works explore relationship machines tim machine tim 
goal show equivalence seemingly different implementations 
mention asperti provides categorical understanding krivine machine extended cam 
approach focuses description comparison fundamental options 
program transformations appeared suited model precisely completely compilation process 
standard optimizations unboxing hoisting peephole optimizations expressed program transformations 
unified framework simplifies correctness proofs possible reason efficiency produced code complexity transformations 
mid term goal provide general taxonomy known implementations functional languages 
tricky task standing way expression destructive updates 
crucial order completely describe call need graph reduction machines 
hinted section done currently investigating issue 
suggested section options optimizations able describe naturally expressed framework 
prevent completing study call value call name implementations 
rmi douence pascal fradet appel 
compiling continuations 
cambridge university press 

asperti 
categorical understanding environment machines 
journal functional programming pp 
argo 
improving instruction machine 
proc 
fpca pp 

burn peyton jones robson 
spineless machine 
proc 
lfp pp 

burn le 
proving correctness compiler optimisations global analysis 
journal functional programming 
appear cardelli :10.1.1.43.208
compiling functional language 
proc 
lfp pp 

cousineau 
curien mauny categorical machine 
science computer programming pp 


machines environnement pour la valuation 
de universit de paris vii 
danvy 
back direct style 
proc 
esop lncs vol 
pp 

douence fradet 
taxonomy functional language implementations 
proc plilp lncs pp 

fairbairn wray :10.1.1.53.3729
tim simple lazy machine execute supercombinators 
proc fpca lncs pp 

fischer :10.1.1.15.8355
lambda calculus schemata 
proc 
acm conf 
proving properties programs sigplan notices vol 
pp 

fradet le 
compilation functional languages program transformation 
acm trans 
prog 
lang 
sys pp 

hannan 
operational semantics machines 
math 
struct 
comp 
sci pp 

hatcliff danvy 
generic account continuation passing styles 
proc 
popl pp 

johnsson 
compiling lazy functional languages 
phd thesis chalmers university 
joy smith burton 
efficient combinator code 
computer languages 
kranz rees hudak philbin adams 
orbit optimizing compiler scheme 
sigplan notices pp 
taxonomy functional language implementations landin 
mechanical evaluation expressions 
computer journal pp 
leroy 
zinc experiment economical implementation ml language 
inria technical report 
lins 
categorical multi combinators 
proc 
fpca lncs pp 

lins thompson peyton jones 
equivalence cmc tim 
journal functional programming pp 

meijer paterson 
lambda lifting 
copies available erik cs kun nl 
moggi :10.1.1.53.3729:10.1.1.41.840
notions computation monads 
information computation 
peyton jones :10.1.1.53.3729
implementing lazy functional languages stock hardware spineless tagless machine 
journal functional programming 
peyton jones lester 
implementing functional languages tutorial 
prentice hall 
peyton jones launchbury :10.1.1.50.4314
unboxed values class citizens non strict functional language 
proc 
fpca lncs pp 
sestoft :10.1.1.50.4314
deriving lazy machine 
technical report technical university denmark 
shao appel :10.1.1.34.3197
space efficient closure representations 
proc 
lfp pp 

turner 
new implementation technique applicative languages 
soft 
pract 
exper pp 

wand 
deriving target code representation continuation semantics 
acm trans 
prog 
lang 
sys pp 

rmi douence pascal fradet annex proofs property property property property property 
clearly sufficient show property reduction step 
proof inductive rules obvious 
interesting rule reduction proof boils proof shown structural induction 
definition substitution enforces occur free variable renaming convention induction hypothesis implies rt induction hypothesis get rt push push rt induction hypothesis push rt property 
structural induction 
show expression rs reducible 
push redex hypothesis redex reducible 
hypothesis redex reducible 
property 
rt normal form property rt property reducible push push thing property 
induction reduction tree 
evident canonical implicit rule 
reduction strategies normalizing push push taxonomy functional language implementations push push induction hypothesis typed case closed expression resp 
reduces push resp 
property inference rule natural semantics sufficient 
proofs laws laws valid generality corresponding classical consistent extension calculus identification unsolvable terms rule weak normal form closed intuitively motivation extension concern equal terms behave reduction 
accept replace expression long equal free variables instantiated replace looping expression looping expression 
law normal form expressions normal forms 
seen equal free variables closed closed 
property exists push push free push law similar 
rmi douence pascal fradet proof property property property 
induction reduction tree 
prove condition verified property holds 
typed normal form property holds trivially push induction hypothesis 
push 




condition 


property 
need lemma proof analogous lemma see lemma check property case definition equality 
push push lx 
lemma push occur free push lx 
occur free implies occur free 
induction hypothesis thing push push generic substitution lemma lemma useful proofs 
context said closed expressions variable closed context introduce free variables bind free variables 
lemma closed contexts transformation lx lx proof 
structural induction 
taxonomy functional language implementations closed introduce free variables lz lz lz lz lz induction hypothesis lz closed lz induction hypothesis closed particular transformations va va vm verify conditions lemma 
va va va push vm vm vm grab proof property prove stronger property expression free variables va rs 
proof 
structural induction 
push va ra lz induction hypothesis va rt va rt push va va lz induction hypothesis rmi douence pascal fradet va va app va app va va app rt proof property need lemma lemma closed va va proof 
lx ne 
va va va app 
property property va push derivation va push va push push induction hypothesis va push va push lx va 
va va lemma va push deduce induction hypothesis va push call value reduction described natural semantics normal forms cbv lx cbv cbv cbv proof property shape reduction trees 
axioms 
reducible form lx closed va lx push va reducible 
va reducible form lx closed alternative lx 
va reducible redex push va app 
reducible 
induction 
reducible cbv lx cbv cbv induction hypothesis va va lx va va va va 
closed va push lemma va va va push va app va va va va va va app va 
va reducible va 
va typed property reduction tree form va push va push 
lemma know va push va push lx lx va va taxonomy functional language implementations induction hypothesis cbv lx cbv lemma va va induction hypothesis cbv cbv proof property technical problem grab typed returns result applies function depending marks 
expressions composed regular way complicated extend type system accept style expressions extension detect result expressions needed law 
gs rs grab gs push rs proof property done way property 
show needed properties lemmas holds new type system 
exhibit alternative proof close previous relying types 
correctness proof va proof relies fact normal forms vm canonical form vm corresponding lemma 
lemma closed normal form vm form grab vm true vm lx 
case show structural induction expression vm reducible 
push grab vm reducible 
hypothesis vm reducible vm reducible lemma normal forms closed expressions vm form vm prove induction shape reduction trees vm normal form normal form vm vm vm case vm reducible vm push vm vm 
vm normal form vm vm normal forms hypothesis vm vm vm vm 
lemma implies vm grab vm grab vm vm vm vm lemma 
vm normal form vm 
induction hypothesis vm vm vm vm 
tackle proof property induction shape reduction trees 
axioms 
reducible form lx closed vm lx grab vm reducible 
vm reducible vm grab vm lemma 
form lx reducible 
rmi douence pascal fradet induction 
reducible cbv lx cbv cbv induction hypothesis vm vm lx vm vm vm vm closed vm grab lemma 
push vm push grab push vm push vm vm push grab vm vm vm lemma vm vm reducible vm push vm vm vm normal form vm possible strategy reduce vm vm normal forms 
lemma vm vm vm vm 
lemma know vm grab vm grab vm vm push vm vm vm vm lemma vm vm conclude vm vm 
induction hypothesis cbv lx cbv cbv cbv proof property order prove push prove induction general property push fv fv set free variables fact fv closed easy check 
push push dupl swap se push push push push push push push induction hypothesis push version induction hypothesis push push push push push mkclos push push mkclos def push induction hypothesis taxonomy functional language implementations push push bind push push bind def 
push push closed push induction hypothesis push push access appclos push appclos access def appclos def proof property introduce type system push typed subset subject reduction property holds shown exactly property 
corollary reduction normal form expression form push generic substitution lemma defined proved way lemma 
instance lemma lemma prove property induction reduction tree 
normal form push property true 
reducible push push push induction hypothesis push push push rmi douence pascal fradet push push push induction hypothesis lemma induction hypothesis proof property corresponding lemma sl lemma sl sl sl proof property induction reduction tree 
normal form push property true 
reducible typed push push sl push push push sl sl push push sl sl push push sl sl push induction hypothesis push push sl push sl push sl push sl push sl push sl induction hypothesis push sl push push sl push sl push sl push sl sl push sl lemma push sl induction hypothesis inria domaine de voluceau rocquencourt bp le chesnay cedex france issn unit de recherche inria lorraine de nancy rue du jardin bp ls nancy unit de recherche inria rennes irisa campus universitaire de beaulieu rennes cedex unit de recherche inria alpes avenue grenoble cedex unit de recherche inria rocquencourt domaine de voluceau rocquencourt bp le chesnay cedex unit de recherche inria sophia antipolis route des lucioles bp sophia antipolis cedex 
