extension system subtyping luca cardelli simone martini john mitchell andre scedrov system known typed calculus polymorphic types provides basis polymorphic programming languages 
study extension called pronounced ef sub combines parametric polymorphism subtyping 
main focus equational theory related models notion parametricity 
study categorical properties theory restricted closed terms including interesting categorical isomorphisms 
investigate proof theoretical properties conservativity typing judgments respect demonstrate set examples range constructs may encoded 
include record operations subtyping hierarchies related features object oriented languages 
appears international conference theoretical aspects computer software ito meyer eds lecture notes computer science pp springer verlag 
appear information computation 
src research report december 
revised january 
digital equipment 
may copied reproduced part commercial purpose 
permission copy part payment fee granted nonprofit educational research purposes provided partial copies include notice copying permission systems research center digital equipment palo alto california acknowledgment authors individuals contributors applicable portions copyright notice 
copying reproducing republishing purpose shall require license payment fee systems research center 
rights reserved 
digital equipment systems research center lytton ave palo alto ca 
dipartimento di informatica universit di pisa corso italia pisa italy 
author partially supported cnr stanford collaboration 
computer science department stanford university stanford ca 
department mathematics university pennsylvania south rd street philadelphia pa 
author partially supported onr contract nsf ccr 
page contents 

system syntax rules basic properties derived rules semantics conservativity typing normal minimal proofs typing conservative typing typing conservative modulo equality typing 
expressiveness booleans naturals products simple tuples simple records lists 
category closed terms definitions basic properties cl finite products coproducts terminal objects binary products initial objects binary coproducts cl isomorphisms double negation existentials cl isomorphisms acknowledgments page 
system gir rey known typed calculus polymorphic types provides basis polymorphic programming languages 
study extension combines parametric polymorphism str subtyping 
call language symbol subtype relation 
closely related language identified curien curien ghelli primarily test case certain mathematical techniques ghe cg 
turn fragment language fun cw 
spite apparent minimality apparent range constructs may encoded include record operations subtyping features car cm related connected operations object oriented programming 
illustrate power section see car 
study raises semantic questions independent interest 
major concern equational theory terms 
equational axioms systems typed calculi arise naturally consequence characterizing type connectives adjoint situations example 
addition case provable equality may captured reduction system obtained orienting equational axioms straightforward way 
properties appear fail 
simple example illustrates basic issues 
consider polymorphic type type commonly referred bool system related systems definable elements type 
elements written normal forms true false additional normal forms type bool 
arise maximal type top types subtypes 
main idea additional terms change type argument body term top term type left operand respect 
gives normal forms type bool 
true top false top true true completely equivalent terms considered type bool 
specifically type terms true true define extensionally equal functions type put proof theoretically take term containing true property reducing normal form apply occurrence true arguments may replace occurrences true true obtain provably equal term 
reason natural consider true true similarly false false terms different normal forms 
add equations theory restore page pleasing property bool contains precisely equivalence classes normal forms 
initial examination equational theory motivated vague intuition observable properties normal forms primary guide semantics polymorphic calculus subtyping bl cl ghe sce 
relevant characteristic models parametric behavior polymorphic functions 
specifically polymorphic functions operate independently type parameter may considered equivalent type instances 
state consequence notion parametricity type instances common supertype equal considered elements supertype see rule eq appl section 
syntax state extent semantic notion parametricity investigated rey fre ms 
general principle followed adopt axioms express parametricity properties satisfied models capture explicitly exact theory models mit 
leads new angle parametricity may prove useful study gives set axioms sufficient prove true true expected equations appearing contrived fit particular examples 
differs calculi mentioned properties transfer easily related particular differs cg equational theory 
syntactic properties strong normalization ghe canonical type derivations coherence minimum typing cg confluence equational theory cg 
semantics follows easily bl cl ghe sce 
alternative semantics developed style fre explore possibility 
main results equational theory properties developed section including conservativity typing set examples section demonstrating expressiveness reported earlier cl ghe attribution section categorical properties theory restricted closed terms 

system obtained extending gir rey see appendix notion subtyping 
extension allows remain pure calculus 
introduce basic types structured types normally associated subtyping programming languages 
show programming types obtained encodings pure calculus 
particular encode record types subtyping relations car 
syntax subtyping reflected syntax types new type constant top supertype types subtype bound second order quantifiers page bounded quantifiers cw 
ordinary second order quantifiers recovered setting quantifier bound top top syntax values extended constant top type top convenience subtype bound polymorphic functions top syntax types type variables top supertype types function spaces bounded quantifications values value variables top canonical value type top functions applications bounded type functions type applications operator associates right 
scoping extends right far possible 
types terms parenthesized 
subtyping judgment added judgments 
equality judgment values relative type important values types values may may equivalent depending type values considered possessing see example rule eq collapse section 
judgments env formed environment type type subtype type equal members type dom set variables defined environment usual identify terms renaming bound variables substitution fv sets free variables fv fv fv identifications directly syntax knowing terms involved product formal derivations system 
page adopting identifications avoid need type equivalence judgment quantifier renaming 
environments identified renaming variables domains environment variables kept distinct construction 
formal approach de bruijn indices free bound variables deb 
rules inference rules listed essential difference ones ghe cg general eq appl rule 
comment interesting aspects rules 
see discussion eq appl section subtyping judgment reflexive transitive relation types subsumption property member type member supertype type 
type subtype top 
function space operator antimonotonic argument monotonic second 
bounded quantifier antimonotonic bound monotonic body assumption free variable 
rules typing judgment corresponding rules extension bounded quantifiers 
additional typing power hidden subsumption rule allows function take argument subtype input type 
equivalence rules unremarkable 
provide symmetry transitivity congruence syntax equivalences 
rules stand 
eq collapse called top collapse rule states terms equivalent seen type top operations available members top values indistinguishable type 
second eq appl congruence rule polymorphic type application giving general conditions expressions equivalent type rule intriguing consequences amply explored 
occasionally write 
environments page env apple env env type dom type dom apple env env env types type type top env env type top type type type type type type type type subtypes sub refl sub trans type sub sub top env type top sub sub values subsumption val val top env env top top val fun val appl val fun val appl equivalence eq symm eq trans eq eq collapse top top top eq fun eq appl eq appl eq fun page page eq eta eq eta dom dom eq beta eq beta basic properties state basic lemmas derivations 
proven simultaneous induction size derivations proofs long straightforward carried order indicated 
conclude section application lemmas showing typing preserved reductions 
notation stand type lemma renaming assume dom env env equal size derivations equal size derivations assume dom env env equal size derivations equal size derivations lemma implied judgments env env env env env type env type env type lemma bound change env type env type type type lemma weakening stand assume env dom env env lemma multiple weakening assume env dom dom apple 
env env proof induction length lemma implied judgments continued sub type type type lemma bound weakening stand 
assume env env lemma type substitution assume env env lemma value substitution assume env env lemma value strengthening fv env env lemma implied judgments continued val type type eq val lemma eq subsumption proof sub type lemma type 
take dom 
env weakening lemma subsumption eq eq fun hypothesis eq appl eq beta eq symm eq beta eq symm eq trans lemma implied judgments continued val eq lemma congruence lemma exchange page page stand stand 
assume env 
env env lemma substitution exchange stand 
env env type type lemmas draw shape terms derivations fact certain subtyping typing judgments derived 
lemma subtyping decomposition type variable 
top top 
top 


top 


proof sketch cases proven induction size derivations order circumvent sub refl sub trans rules follow structure terms 
proofs straightforward 
lemma typing decomposition top top 
top 

top 

proof sketch cases proven induction size derivations order circumvent subsumption rule follow structure terms 
proofs straightforward 
conclude proposition preservation typing reduction 
second order case far hardest requires lemma elimination unused free variables fv 
lemma non occurring type variable fv fv proof induction derivation interesting cases val appl val appl subtyping decomposition lemmas 
show val appl case dom fv induction type ab fv ab ab ab subtyping decomposition lemma ab ab fv ab 
fv comes fv 
fv hyp 
fv 
uses sub subsumption cases sub trans fv bound weakening lemma type substitution lemma 
take 
proposition preservation typing reductions page fv fv proof cases obtained easily applying appropriate decomposition lemmas weakening bound weakening value type substitution value strengthening 
case goes follows 
typing decomposition lemma fun appl obtain omitting easy case top 
fv non occurring type variable lemma fv subtyping decomposition lemma obtain subcases lead fv type strengthening lemma obtain final goal subsumption need show type substitution lemma get 
bound weakening lemma twice get type substitution lemma bound weakening lemma 
note proposition nontrivial example case follow simply eq beta rule eq val lemma 
derivation general quite different shape derivation page derived rules lemmas previous section written derived inference rules 
discuss derived rules special significance 
eq subsumption lemma previous section gives interesting rule lifts subsumption equality judgment 
proven eq beta rule 
eq subsumption note general true imply lemmas concern equivalence functions modulo domain restriction find useful application section 
lemma domain restriction equivalent restriction smaller domain seen type eq fun proof sketch derive eq subsumption eq beta 
pass eq subsumption eq eta 
conclude transitivity 
lemma bound restriction equivalent restriction smaller bound seen type eq fun proof similar previous lemma eq beta eq eta 
turn eq appl rule 
rule asserts polymorphic function instantiated types instantiations evaluate value respect result type upper bound 
eq appl page page note rule asserts result independent proper result type 
simpler derived rule cg obtained setting eq appl eq appl rule useful find nontrivial upper bound 
fact motivates derived rule practice 
denote substitution negative occurrences positive ones 
take proof may ghe section nontrivial common supertype 
fact justifies rule eq appl rule fact special case dinaturality type application dinaturality required respect coercions subtypes diagram arrows left instances generic type application variable type type variable free 
arrows right coercions induced 
constant coercion effect type 
diagram just brief version id id horizontal arrows instances 
terminology family dinatural coercions 
conclude section application eq appl sections 
proposition eq substitution assume positive proof prove eq appl eq appl positive 
similarly 
eq appl eq appl 
conclude eq trans beta beta 
proposition easily generalized case variables positive terms 
semantics semantics reader consult bl cl ghe sce 
interpretation explained papers rule eq appl shown sound 
proof rests fact types denoting interpretation function types 
observation interpretation terms erasing type information straightforward 
conservativity typing presence subtypes main new feature respect lies equational theory extends standard equality directions page adding terminal type top introducing rule eq appl 
nonessential syntactic variants language included language sense investigate conservative may consider intermediate system property language inclusion splits 
system interested obtained adding type constant top rule eq collapse making top terminal type 
want compare underlying subtype free systems need system known terminal type definable conservativity result prove respect holds proves trivial subtype judgments types situation complex analysis sheds light structure subtype proofs 
equational theory conservative rule eq appl 
consider example proposition type top top proof top top top val eq lemma eq appl eq collapse eq appl top val eq lemma eq appl eq appl top top eq trans 
applying fact twice eq trans show page bool bool true bool false bool judgment equating different normal forms 
known judgment derivable application eq fun produces closed terms property 
typing theory rules designed maintain carefully generalize subsystems 
writing derivations derivations derivations prove result 
theorem language 
ii language exists term proof statements inspired results ghe requires detour normal form proofs 
normal forms studied cg slightly different system share typing judgments 
reason detour trivial proofs induction derivation cut rules 
subsumption sub trans val appl may introduce non non types 
normal minimal proofs single typing judgment may proofs 
non determinism proof search arises freedom order rules subsumption sub trans applied 
showed cg freedom provide additional proving power 
subtype proofs sub trans uses smallest type variable appearing environment 
type proofs restrict subsumption derive type term may larger type single application subsumption 
ideas inspiration notions normal minimal normal proofs 
subtype proofs normal form proof proof nf obtained formal system nf consisting rules sub top sub sub replaced nf plus rules sub refl sub trans nf type nf top nf nf type proofs normal form proofs minimal normal form proofs simultaneously defined follows 
normal form proof nf minimal normal form proof mnf minimal normal form proof followed single nontrivial subsumption case final step form mnf nf nf minimal normal form proof mnf proof rules val val top val fun val fun replaced mnf rules notation 
variable variable variable 
val appl min mnf nf mnf val appl min mnf nf mnf page proposition provable judgment exists unique derivation nf proof cg typing conservative typing difficult see subsystem 
define translation function language page top top trivially defined constructs 
formed environment consists collection type variables list type assumptions type variables appear free 
top top 
obvious derivations mapped derivations properties 
resulting derivations subsumption subtyping rules top rules eq appl applied special case 
argue directly language dispensing 
lemma environment types 
iff 
proof direction routine induction 
direction take normal form proof sub sub proceed induction sub refl trivial 
sub trans nf derived top nf top implies top subtyping decomposition lemma absurd type 
lemma environment term mnf ftype proof induction derivation mnf 
val mnf type environment 
val fun rule mnf mnf hypothesis term type 
induction hypothesis type 
val fun analogous val fun 
val appl min rule mnf nf mnf consider premise mnf show variable 
case top environment contrary side condition function type 
variable induction hypothesis type consider proof nf claim minimal normal form proof 
fact proved type type 
case step proof nf mnf nf nf induction hypothesis type previous lemma 
proof nf minimal normal proof mnf induction hypothesis 
val appl min rule mnf nf mnf note term type 
previous case variable induction hypothesis type top making trivial premise nf top top 
theorem conservativity typing environment term type 
proof consider unique normal form proof nf step mnf nf page page nf previous lemma type lemma 
proof nf proof mnf previous lemma allows obtain 
typing conservative modulo equality typing case system easily viewed subsystem 
consider subsystem obtained restricting env case top dropping subtyping rules sub top removing subsumption restricting eq appl case 
identify subsystem write derivations 
reason typing theory conservative expressed lemma previous subsection trivial subtype judgments proved types 
situation types interesting due sub top nontrivial inclusions proved 
typing conservative course top top top top failure pragmatic reasons programming language design viewpoint introducing subsumption mechanism program method function inherited types 
look conservativity modulo equality 
language exists term say example obvious top top top top top top eq top 
start preliminary lemmas 
id top lemma identity coercions environment types exists term id proof induction normal form proof nf note sub trans rule proof premise top nf top environment imply top subtyping decomposition lemma impossible side condition requiring top 
cases take inductively defined explicit coercion details follows 
sub refl trivial 
sub top top 
take top top 
rules eq collapse eq fun give top id top 
sub define ka nf induction hypothesis easy argument eq eta transitivity eq fun sub nf top types 
top top define kc top nf induction easy argument top top eq eta transitivity top thesis eq fun 
lemma environment term mnf type ii exists term proof induction mnf 
val mnf type environment ii follows eq 
val top mnf top top 
top top take top 
val fun rule mnf mnf hypothesis term type 
induction hypothesis type exists term thesis follows eq fun 
val fun analogous val fun 
page page val appl min rule mnf nf mnf consider left premise mnf observe variable environment top contradicting assumption induction applies type obtain term consider premise nf happens minimal normal form proof mnf induction hypothesis term step nf mnf nf nf induction hypothesis type get term 
proved type type 
nf identity coercions lemma gives term ka ka ka id take ka 
simple computations give eq appl 
val appl min rule mnf nf mnf note term type 
previous case mnf variable 
left premise mnf induction hypothesis type top second premise trivial term top top 
prove conservativity result theorem conservativity typing language exists term proof take normal form proof nf minimal normal form proof thesis follows previous lemma 
hand consists minimal normal form proof mnf followed subsumption premise nf previous lemma type term 
thesis follows identity coercions lemma eq appl 

expressiveness extension carry standard encodings algebraic data types possible bb 
clear interest obtained subtyping rules involve apparently useless type top simple rules 
section show fact construct rich subtyping relations familiar data structures 
booleans rest section concentrate inclusion structured types sense need show nontrivial inclusions level basic types 
investigate type booleans illustrating consequences rules 
starting encoding church booleans define subtypes bool follows cf 
fai bool true top false top top top true false true bool false bool looking closed normal forms elements types true bool bool false bool bool true true true top false false false top page obtain elements type bool addition usual true bool false bool extra true true false false type bool subsumption 
somewhat surprising computationally booleans 
intuitively arguments arbitrary type ways providing result type 
coincides fact removing type information terms obtain distinct untyped terms 
fortunately show true bool true true provably equivalent type bool domain restriction lemma eq fun section 
page top top top top top eq fun top top top true true true bool bool similarly show false false false bool bool 
really different values bool value true false 
naturals encoding booleans previous section generalize algebraic types 
different style encoding applied booleans works better naturals 
encoding nat stands type naturals nat type zero naturals singleton zero nat type non zero naturals 
nat nz ns nz ns nz ns nz ns nz nats nz ns nz ns ns closed normal forms minimal type nat usual church numerals zero natural nats non zero naturals 
obtain nat nat nat nat zero nat succ nat nat nat products standard encoding pairs shown exhibits useful subtyping properties 
occur monotonic positions placed left left 
obtain expected monotonic inclusion products derived rule operations pairs defined usual pair fst snd abbreviations disambiguated context pair fst fst fst snd snd snd simple tuples tuple type iterated product type 
factor iterated product type variable extensible tuple type 
top simple tuple type 
discuss simple tuple types 
tuple top top tuple top top 
derived rule example 
type 
type tuple top tuple top tuple top tuple top top top monotonic 
note type top assumes useful role allowing longer tuple type subtype shorter tuple type 
intuition longer tuple value regarded shorter tuple value forgetting additional components possible forgotten top 
tuple values tuple top top tuple top top 
page derived rules page 
tuple top tuple top 
tuple top tuple top tuple top basic tuple operations dropping components tuple selecting th component defined iterating product operations omit typing information snd fst obtain derived rules tuple top tuple top tuple top 
tuple top tuple ai top tuple ai top 
tuple top 
simple records restrict encoding simple records ones fixed number components cl extensible records treated car 
countable set labels enumerated bijection nat 
indicate li superscript th label enumeration 
need refer list distinct labels enumeration subscripts ln may example precisely ln stands injective nat 
record type form rcd ln presentation top 
enumeration labels fixed record type encoded tuple type record components allocated tuple slots determined index labels 
component label li allocated th tuple slot remaining slots filled top padding 
example rcd top tuple top top record type components canonically sorted encoding record types differ order components equal encoding 
consider record components unordered 
encoding derive familiar rule simple records car 
type 
type rcd top rcd top holds additional field left absorbed top padding right max final top 
example rcd top tuple top tuple top top rcd top record values similarly encoded example rcd top tuple top top obtain rules 
rcd top rcd top 
rcd top rcd top rcd top record selection encoded follows rcd top note subsumption derived rules 

rcd top rcd top 


rcd top rcd top rcd top rcd ln top li ai second rule particularly interesting 
expresses form observational equivalence records equivalent coincide components observable type 
holds ultimately values equivalent type top 
page 
lists pattern encoding naturals define algebra parametric lists bb 
list stands homogeneous lists type page list list list nil list cons list list hd tl list hd tl length list nat list nat zero nat succ application eq appl show interesting facts 
null lists equal list top length nat 
similarly singleton lists 
proof eq substitution proposition section 
take appl nil nil list top eq appl length top nil length top nil nat eq appl eq cons nil cons nil list top eq substitution starting top list cons list length cons nil length cons nil nat eq substitution starting top list length nat note proven interesting property behavior length uniquely type function list nat property 
fact related theorems proved wad types terms 
difference proof carried wadler uses semantic parametricity properties proof system 
category closed terms known usual second order encodings products coproducts logically sound define equality true categorical constructions 
easily prove existence term making certain diagram commute uniqueness follow standard equational rules 
example expressive power eq appl show encodings really categorical constructions underlying equational theory 
vein motivated semantic isomorphisms obtained fre consequences parametricity investigate provable isomorphisms suitable setting 
framework discussion category objects sets closed terms closed type 
definitions basic properties recall typed calculus language theory category cl determined objects cl closed types ls ms 
morphisms choose variable type define morphisms equivalence classes typing judgments chosen variable type equivalence relation equality judgments write morphism judgment identity composition defined substitution category cl obtained applying construction terminal object top 
object canonical morphism top top top uniqueness guaranteed eq collapse 
arbitrary small category terminal object consider canonical functor sets object set morphisms morphism mapping composing note faithful pointed defined 
set theoretical mappings order sufficient 
values functor sets objects morphisms give subcategory sets denoted 
category interested cl 
prove consequences eq appl finite products coproducts 
convenient introduce category cl equivalent cl give explicit description 
type reads closed type reads closed term closed type definition cl equality page page say cl iff objects cl type sets morphisms top 
eq collapse congruence top top top 
term top closed top top iff top object cl isomorphic set equivalence classes closed terms closed type equivalence relation equality judgments 
write type set 
sets objects category cl morphisms cl morphism cl mappings top top top 
conversion obtains category equivalent cl stipulating morphism cl type type equivalence class derivable term judgments morphism equivalence iff cl identity judgment id composition judgment ambiguously 
morphism equivalence provable equality 
morphisms equal sufficient agree closed terms type similarly definitions correspond isomorphism uniqueness morphisms cl definition cl isomorphism say cl iff exist cl id cl id definition cl uniqueness say cl unique satisfying iff satisfying cl order prove cl finite products coproducts need lemmas especially crucial consequence eq appl expressed eq var substitution lemma 
lemma type monotonicity type 
positive ii negative proof induction derivation type 
trivial case type 
assume positive 
induction hypothesis type bound change lemma type conclude induction sub 
definition pointed type variable type pointed iff positive 
lemma generalized collapse top type pointed type top top proof 
type monotonicity lemma top top top top 
top top top top 
val weakening subsumption top top eq appl eq appl top top analogously obtain top top top top eq collapse top top eq fun eq fun eq eta eq eta top top 
generalized collapse eq substitution property section obtain lemma expresses parametricity property possibly open term closed type provably equal term obtained substituting specific types terms free variables 
lemma eq var substitution assume top type pointed top type type proof generalized collapse lemma page page top top 
eq substitution proposition sect 
allows conclude 
cl finite products coproducts section show equational theory strong entail basic categorical properties cl 
terminal objects proposition object type unique morphism top 
proof take top 
take morphism top 
top weaken top top eq collapse top top eq fun top eq eta fortiori cl top 
binary products definition proposition pair objects type type object type categorical product 
exist type exists unique cl unique cl cl proof define px py px py pair pair couple pair couple fix object type morphisms existence 
take couple pair morphism defined 
just show cl cl implies couple cl couple uniqueness 
show couple normal form shape top top top bound weakening lemma top top eq fun conversion px px px py py py 
eq var substitution lemma top top top eq appl eq fun eq fun couple pair show conversion type couple couple cl unique follows usual argument 
corollary cl cl cl proof standard diagram chasing existence products 
initial objects definition bot proposition page object type unique morphism bot proof take bot 
take morphism bot terms bot vacuously true bot cl bot bool bot initial object argument terms type bool bot 
unique map equivalence class bool bot true includes bool bot false 
generally empty type exists term bot initial 
canonical morphism equivalence class cl unique closed terms binary coproducts definition proposition pair objects type type object type categorical coproduct 
exist type exists unique cl unique cl cl proof define page case case normal form shapes top top top top top top bound weakening lemma top top eq fun fix object type morphisms existence take case 
morphism defined 
show cl cl implies case cl case case case conversion case case case case case similar eq var substitution lemma gives top top infer terms closed 
conclude cl uniqueness 
show case cases normal form 
case case 
eq var substitution lemma top top eq appl eq fun eq fun def case equation second case similar 
show type case case cases normal form 
page page case case case eq var substitution lemma top top conclude transitivity eq appl 
second case similar 
uniqueness shown standard argument 
corollary cl cl cl proof standard diagram chasing existence coproducts 
category terminal object pointed iff pair objects iff proposition cl pointed 
type type cl top cl top proof top top eq collapse eq appl top top similarly top top top hypothesis weaken top top top eq trans eq fun top take consider top top top hypothesis eq beta cl cl isomorphisms isomorphisms inspired fre 
double negation prove type isomorphism holding models studied known proof 
see section 
proposition type cl proof define id take conversion id id take closed normal form shape top top bound weakening lemma top id eq var substitution lemma top id top id id combining equations christine paulin mohring shown closed provable isomorphism proof 
known isomorphism 
see term page convertible term form closed term type roberto di cosmo dic shown isomorphic usual sense isomorphisms opposed 
existentials prove section terminal type top isomorphic cl programming point view consistent intuition value encapsulated object type way object type 
prove generally cl lemma type proof hypothesis eq eq appl fv type hypothesis eq appl hypothesis eq eq appl hypothesis eq appl definition id definition page proposition type cl proof id take id id take closed normal form shape top top bound weakening lemma eq fun id id id id id id eq var substitution lemma id top id lemma top id id combining equations corollary top cl cl isomorphisms isomorphisms derived techniques developed previous sections 

page domain restriction categorical top top bot bot various top simple top collapse top top simple top collapse top analyzing normal forms bot top analyzing normal forms bot bot nonempty vacuous cl id conditions types empty suffices study extension system subtyping equational theory 
equational rules complete models main inspirations novel rules come models categorical notions parametricity 
proof system conservative extension system prove conservativity typing judgments respect study categorical properties theory restricted closed terms including interesting categorical isomorphisms 
isomorphisms provide confidence strength proof system 
additional evidence set encodings include record operations subtyping hierarchies related features object oriented languages 
important area studied adequate computation system 
ideally notion reduction provably equal terms reduce common term 
possible reductions terminate 
standard approach orient equational axiom direction 
equational rules lead immediate problems eq collapse eq appl obvious produce oriented reduction rule 
furthermore order capture equivalence set oriented rules proved confluent 
computational characterization equality decidability equational system absence decidability remains open problem 
final form eq appl rule investigation 
insights acc suggest eq appl taken 
specifically formal systems considered acc page consequence 
eq appl rule adopted valid simpler syntactic form 
acknowledgments simone martini andre scedrov john mitchell computer science department center study language information stanford university hospitality authors extended stay research done 
luca cardelli simone martini pierre louis curien giorgio ghelli giuseppe longo stimulating discussions related 
particular curien helped early proof top luca cardelli mart abadi careful readings draft 
page appendix system environments page env apple env env type dom env dom apple env env env types type type type env type type type type type type values val val fun val appl env val fun val appl type equivalence eq symm eq trans eq eq fun eq appl eq fun eq appl type eq eta eq eta dom dom eq beta eq beta type acc abadi cardelli curien formal parametric appear 
ms mitchell scedrov relators parametricity manuscript 
bb hm berarducci automatic synthesis typed programs term algebras theoretical computer science pp 

bainbridge freyd scedrov scott functorial polymorphism theoretical computer science vol pp 
bl bruce longo modest model records inheritance bounded quantification information computation 
car cardelli semantics multiple inheritance information computation pp 
car cardelli extensible records pure calculus subtyping appear 
cl cardelli longo semantic basis quest proceedings th acm lisp functional programming conference acm press 
cm cardelli mitchell operations records mathematical structures computer science vol pp 
cw cardelli wegner understanding types data abstraction polymorphism computing surveys vol pp december 
cg curien ghelli coherence subsumption mathematical structures computer science appear 
short version proc 
caap lecture notes computer science 
cg curien ghelli subtyping extensionality confluence top reductions ito meyer eds 
theoretical aspects computer software sendai japan lecture notes computer science pp 
springer verlag deb de bruijn lambda calculus notation nameless dummies 
math 
pp 

dic di cosmo invertibility terms valid isomorphisms proof theoretic study second order lambda calculus surjective pairing terminal object technical report tr liens ecole normale sup rieure paris 
fai fairbairn types inclusion properties technical report university cambridge computer laboratory 
fre freyd structural polymorphism appear tcs 
ghe ghelli proof theoretic studies type system integrating inclusion parametric polymorphism ph thesis td universit di pisa dipartimento di informatica 
page gir girard une extension de interpr tation de del analyse son application des coupures dans analyse la th orie des types proceedings second scandinavian logic symposium fenstad ed 
pp 
north holland 
ls lambek scott higher order categorical logic cambridge university press 
mit mitchell type inference approach reduction properties semantics polymorphic expressions logical foundations functional programming ed 
huet addison wesley 
ms mitchell scott typed models cartesian closed categories categories computer science logic gray scedrov eds 
contemporary math 
vol 
amer 
math 
soc pp 
pit pitts polymorphism set theoretic constructively category theory computer science proceedings edinburgh pitt poign rydeheard eds 
springer lecture notes computer science vol 
pp 
rey reynolds theory type structure colloquium sur la programmation pp 
springer verlag lecture notes computer science 
rey reynolds types abstraction parametric polymorphism information processing pp mason ed north holland amsterdam 
sce scedrov guide polymorphic types logic computer science pp odifreddi ed academic press 
str strachey fundamental concepts programming languages lecture notes international summer school computer programming copenhagen august 
wad wadler theorems free proc 
fourth international conference programming computer architecture acm press 
page 
