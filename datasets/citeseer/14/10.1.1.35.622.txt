proving java type soundness don syme email drs cl cam ac uk june technical report describes machine checked proof type soundness subset java language called java formal semantics subset developed drossopoulou eisenbach sketched outline type soundness proof 
formulation developed complements written semantics proof correcting clarifying significant details demonstrates utility formal machine checking exploring large detailed proof operational semantics 
development serves case study application declarative proof techniques major property operational system 
contents java 
type soundness java 
tool declare 
outline 
semantics java syntax java 
static semantics 
type checking environments 
subclasses widening 
traversing class interface hierarchies 
formedness type checking environments 
static typing compilation rules 
runtime semantics 
configurations runtime terms 
program state 
rewrite system 
runtime typechecking 
local variables method calls 
steps formalized machine checked human readable proof java type soundness carried phd 
program computer laboratory university cambridge uk 
developing machine acceptable model java comments process machine formalization 
specification declare 
validating model formulating key properties type soundness 
typing 
conformance 
heap widening 
formalized type soundness 
key lemmas 
type soundness compilation 
sketching outlines proofs sketching machine checking 
complicated case 
detailed machine checking proofs 
mistakes runtime typechecking array assignments exceptions 
side effects types 
methods visible interfaces 
summary formal techniques specify languages 
formal proofs find mistakes 
related 

declare proof language 
working environment 
automation 
full widening rules full traversal rules technical report describes machine checked proof type soundness subset java language called java formal semantics subset developed drossopoulou eisenbach sketched outline type soundness proof de 
formulation develop serves roles complements written semantics proof correcting clarifying significant details demonstrates utility java trademark sun microsystems formal machine checking exploring large detailed proof operational semantics contributes distinct fields formal reasoning ffl contributes understanding java formal perspective acting highly detailed analysis significant property language providing proofs corrections existing proofs interesting right 
ffl contributes development proof tools formal methods major case study declarative proof techniques 
ffl contributes study detailed formalization language theory particular highlights tools methodology applied task 
familiarity drossopoulou eisenbach may required understand technical details report 
report clear readers simple understanding operational semantics formal specification 
java java rapidly spreading programming language developed sun microsystems aims support safe distributed programming 
developers describe follows gjs java simple robust platform independent multi threaded dynamic general purpose programming environment 
best creating applets applications internet intranets complex distributed network 
java notable attractiveness existing base programmers avoiding features unsafe pointers portability implementations implement ieee floating point numbers large standardized library memory management garbage collection dynamic linking precise language definition 
complete language description available language extremely widespread rate increase usage steep 
main language features java primitive types characters integers booleans ieee floats strings classes inheritance instance class variables methods interfaces class signatures shadowing instance variables dynamic method binding statically resolvable overloading methods exceptions arrays subtyping arrays dynamic type checking casts array assignments class modifiers private protected public final classes methods nested scopes separate compilation dynamic linking extensible security management constructors 
java subset consider covered version drossopoulou eisenbach 
includes primitive types classes inheritance instance variables instance methods interfaces shadowing instance variables dynamic method binding statically resolvable overloading methods object creation null pointers arrays minimal treatment exceptions 
subset excludes initializers constructors class variables class methods local variables class modifiers final classes methods super strings numeric promotions widening concurrency handling exceptions dynamic linking packages latest version proofs specifications described document available world wide web www cl cam ac uk users drs java proofs html 
updated reflect formalization 
separate compilation 
advantage approach formalization take report new features language treated possible incrementally adjust existing definitions proofs 
type soundness java 
studies uncovered flaws security java system including type system pointed need formal semantics complement existing language definition gjs 
formal treatment important aspects language dynamic linking performed 
type soundness states welltyped java program go wrong runtime sense reach state violates conditions implied typing rules 
illustrate aspect type soundness captured statement taken directly java language specification gjs type variable expression limits possible values variable hold expression produce run time 
run time value null refers object array class necessarily compatible compile time type 
type soundness property particular interest java language type system key mechanism ensure java bytecodes downloaded untrusted sites breach integrity user machine executed expensive runtime checks 
report concerned java language java virtual machine jvm 
closely related difference non trivial example jvm bytecodes correspond java text 
remains challenge formalize verify corresponding type soundness property jvm 
type systems java jvm closely related comprehensive study useful precursor study 
course model java jvm verified guarantee soundness particular implementation just ideal case 
formulate type soundness 
question ask observable effects expect language unsound type system 
case expect protection violations form core dumps 
java tend concerned breaches system security policy transmission private data java program 
ideally relate notion type soundness absence effects 
practice step doing look inside runtime mechanisms language prove certain type soundness invariant maintained execution machine 
approach taken drossopoulou eisenbach report 
type soundness initially expressed terms inner workings runtime model develop java scope demonstrate ensures security breaches occur 
precise formulation type soundness described section 
main focus issues associated computer help reason properties programming languages 
demonstrate right tools mechanically checked formalization significant problem language research achieved 
main aim find errors significant errors formulation adopted drossopoulou eisenbach discovered 
outline error section discuss aspects tools methodology allowed discovery 
addition error interesting mistakes omissions note proceed 
independently rediscovered fairly significant omission java language specification described section 
tool declare described document exists part larger project help develop effective tools tackling language research problems 
similar attempted researchers languages including syme van standard ml sym van van proof type soundness standard ml van nipkow proofs mini ml nn semantics hol 
learnt efforts particularly regard representational issues utility certain kinds automated reasoning tools 
past researchers generally tackled problems tools designed purposes hol designed structured hardware verification 
time ripe tools really appropriate assist reasoning operational semantics 
need better tools really appreciated consider problems tools available difficulty task hand 
factors affect utility tool applied tasks kind considering ffl underlying logic expressiveness 
ffl automated reasoning support provided avoid tedious reasoning 
ffl language specifications specifications written natural style 
ffl proofs expressed arguments formulated succinctly naturally 
ffl assistance construction proofs 
ffl tool support maintenance specifications proofs incremental changes 
ffl documents produced readable 
validated researchers unfamiliar tool 
ffl tool support exploratory modes 
existing tools fall short number categories proofs developed hol pvs typically unreadable provers automated support provided weak 
importance readability clarity proofs specification important feature report 
existing tools consistently force user expressing proofs manner awkward obscure exception automation tools sufficient solve problems question 
tool called declare sym developed author year 
declare appendix semantics java java oe java compiles java gamma 
java theta state gamma java theta state type type type type components semantics relationships outline remainder report organised follows 
section outline formal semantics java basis rest 
heavily semantics developed drossopoulou eisenbach reproduced completeness contains important corrections 
section outlines steps need take complete task describes tool called declare create check formal proof type soundness property java sections describe steps detail 
section major errors discovered drossopoulou eisenbach proof described independent rediscovery error java language specification 
summarize discuss related section 
semantics java section operational semantics java heavily developed drossopoulou eisenbach version de 
specification result iterations waterfall model formal development outline section 
description semantics necessarily brief places details consult de 
define ffl subset java containing features listed section ffl small step term rewriting system describe dynamic execution java programs ffl type inference system describe compile time type checking 
picture components semantics shown 
main concern annotated language java java terms runtime machine 
main differences semantics java version drossopoulou eisenbach ffl correct minor mistakes missing rules null pointers definitions founded fdec typing mistakes misleading ambiguous definitions definition incorrect assertion primitive type widens null type 
ffl choose different representations environments tables partial functions lists declarations 
ffl carefully differentiate java source language runtime terms 
model execution subtly different typing rules 
semantics java ffl adopt suggestion von oheimb formedness environments specified declaration order 
ffl allow primitive class object arbitrary set methods drossopoulou eisenbach restrict object methods 
ffl substitution typing turns unnecessary representation environments 
ffl runtime choose arbitrary new names local variables calling procedure system frames local variables reasoning substitution easier closer real implementation stacks offsets 
ffl careful identify types judgments relations operate clear picture needed writing machine model 
ffl modelling multi dimensional arrays version drossopoulou eisenbach faithful java sub array dimensions constant 
ffl arrays java support methods supported class object 
include model non trivial consequences model 
model arrays incomplete java arrays support certain array specific methods fields treatment 
ffl stringent formedness conditions types turns widening typing relations implicitly ensure formedness required 
grateful drossopoulou eisenbach opportunity discuss points incorporated suggestions latest version de 
syntax java java programs consist sequence classes see 
class name super class set super interfaces sequence field declarations sequence method bodies 
fields name type 
methods return type possibly void list parameters types sequence statements followed optional return expression 
statements considered conditionals assignments blocks expressions 
statements type void 
java distinguishes variables akin lvalues eventually correspond locations memory expressions 
variables occur left assignment statement expressions 
expressions include primitive values variable dereferencing method calls class array allocation 
variables include identifiers field lookup array lookup 
primitive values obvious literals primitive types bool char byte short int long float double 
component types types form basis arrays class types interface types primitive types array types component types raised number dimensions array sizes part java array types 
types classes interfaces arrays regular types just primitive types types 
expression types may void standard ml void primitive type array voids possible 
argument types method types give signatures argument lists method declarations 
special type nullt added assign null values source text 
semantics java prog class 
class programs class extends sup implements 
field 
field method 
method class declaration field type field name field declaration method expr type method type 
type xn stmt 
stmt return expr 
method declarations stmt expr expr expr conditionals var expr assignment stmt 
stmt blocks expr evaluation programs classes fields methods var id local variable expr field name object field expr expr array element expr prim literal value var dereferencing expr method name expr method call new object creation new expr array creation expressions variables primitive type bool char short int long float double simple type class name interface name component type simple type primitive type array type component type type simple type array type nullt type primitive type type expr type type void arg type list type method type arg type expr type types semantics java class env class names table gamma 
class dec interface env interface names table gamma 
interface dec variable env variable names table gamma 
type class dec super class name interfaces set interface names fields field names table gamma 
type methods method names theta arg types table gamma 
expr interface dec superinterfaces set interface names methods method names theta arg types table gamma 
type checking environments static semantics static semantics complex simple set inference rules 
complicating factors ffl java allows classes defined 
restrictions non circular class interface hierarchy result 
ffl java implementations disambiguate key pieces information compile time 
method calls may statically overloaded confused object oriented late binding mechanism fields may hidden superclasses 
resolution field method done compile time 
widening primitive types covered decided compile time inserting coercions 
accommodate difficulties drossopoulou eisenbach define notion type checking environment extracted entire programs formedness condition 
environment contains class interface hierarchies subclass widening subtyping relations derived 
formedness excludes circular class interface hierarchies imposes constraints 
rules static typing compile time disambiguation constructs developed 
type checking environments type checking environments contain components 
tables class interface declarations 
contain type information extracted definition constructs write records omit record tag names obvious context referred 
typechecking inside method bodies environment contains table variable declarations 
gamma composite environment gamma gamma gamma respective components gamma lookup appropriate table 
general understood gamma contains component environments necessary construct hand sense 
gamma indicate defined relevant table gamma 
component types array types types regular types said formed written gamma object syntax classes interfaces scope 
give details note special class object scope 
semantics java subclasses widening define subclass class int implements imp relations shown 
classes subclass special class object mention explicitly formedness conditions environments ensure 
gamma class gamma class gamma super sup gamma sup class gamma class gamma gamma int gamma interfaces gamma int gamma int gamma interfaces gamma imp implements subtyping java combination subclass implements relations called widening 
defining widening accurately turns tedious instructive process define incrementally different kinds types simple types component types comp array types arr regular types 
careful avoid errors creep approaches drossopoulou eisenbach presentation appears primitive types narrower object fact types 
types subtypes object classes virtue subclassing rule nullt type null pointers narrower types 
full rules widening shown appendix important rules arrays variant rule eventually leads need runtime typechecking 
gamma ty arr object array object gamma ty comp ty gamma ty arr ty array traversing class interface hierarchies functions fdec traverse subclass graphs starting particular class interface collect ffl fdec visible definition field starting particular class 
set returned element formed environments 
ffl fields including hidden ones class super classes 
ffl methods visible type 
methods identical argument descriptors hide methods hierarchy return types may different 
object methods visible interfaces arrays 
drossopoulou eisenbach formulation definitions recursive functions 
definitions sense formed environments search terminate circular class interface hierarchies 
constructs definition formedness 
functions better formulated inductively defined sets 
definitions rules appendix defined defining visible methods different types 
methods visible arrays interfaces include methods type object 
case interfaces subject discussion section 
semantics java formedness type checking environments turn formedness type checking environments 
drossopoulou eisenbach originally formulated incremental process sequence definitions built entire environment somewhat mimicking process separate compilation 
originally followed formulation von oheimb pointed necessary definition independent ordering constraints finiteness constraint needed 
formed te class declaration environment satisfy constraints de ffl class object defined superclass superinterfaces fields 
ffl superclass implemented interfaces defined circularities occur hierarchy ffl methods name argument types ensured construction ffl methods override inherited methods having name argument types narrower return type ffl interfaces implemented methods narrower return types 
written gamma hc sup fields gamma sup class gamma sup class gamma meth rt methods meth rt gamma meth rt sup gamma rt rt gamma meth rt rt gamma meth rt gamma rt rt likewise interface declaration satisfy conditions ffl inherited interfaces defined circularities occur hierarchy ffl methods name argument types ensured construction ffl methods override inherited methods narrower return type written gamma gamma gamma int meth rt methods meth rt gamma meth rt gamma rt rt semantics java static typing compilation rules define static typing system input language 
mentioned information disambiguated typing process 
conceptually languages type systems involved 
harm comes prove compilation process preserves types 
give full details typing rules follow rules drossopoulou eisenbach closely 
example typing rule local stack variables unannotated annotated languages id type gamma id type typing rule method calls unannotated language gamma obj gamma arg gamma rt gamma obj arg arg rt definition de determines set special applicable methods static types arguments 
method exist typing error occurs 
note resolution methods static argument types means unique typing essential java 
give typing rule construct annotated language 
exact method descriptor simply check argument types match widening 
corresponding rule annotated procedure calls gamma obj gamma method rt size ty gamma arg ty gamma ty gamma obj method arg arg rt completes presentation static checks performed java language 
move runtime model execution 
runtime semantics drossopoulou eisenbach model execution small step rewrite system configuration represents expressions evaluated partial results steps executed far 
configuration progressively modified making reductions 
rewrite system best thought specifying machine considered inefficient simple interpreter java small step system chosen big step want model non determinism concurrency want reason non terminating programs 
unfortunately small step system imposes significant overheads type soundness proof big step rewrite system intermediary configurations need considered unavoidable 
semantics java prim primitive value addr option addresses addr null exn packet id frame num theta id local variable rexp lookup class rexp rexp array access rexp simple value dereference rexp rexp method call new object creation new type rexp array creation statements return expression rexp rexp rexp rexp rexp syntax configurations runtime terms configuration runtime system state runtime term runtime terms language java contain artifacts source language notably addresses exception packets bodies methods called 
kinds expressions variables statements really different kinds configurations 
top level configuration contains expression java programs execution main static method class machine gets started really important 
syntax shown 
terminating expressions eventually values 
program state program state consists components list frames local variables heap containing objects arrays 
components quite different properties distinguish 
frames heap objects garbage collected heap objects objects arrays annotated types case arrays type values stored array 
symbol phi indicate adding new frame available frame index id addr looking local variables objects id val addr heap obj assigning things respective components state 
versions semantics garbage collection rule allows collection inaccessible items time may added 
garbage collection semantically visible java presence methods get called object deallocated 
semantics java state frames list id table gamma 
val heap addr table gamma 
heap heap object ld 
val ld 
val ae object val val type array state rewrite system reduction specified relations syntax category exp gamma var gamma stmt gamma global parameters environment gamma containing class interface hierarchies needed runtime typechecking program executed 
term ground normal form reduction 
groundedness syntactic test depend syntax category term viewed 
example local variable lookup id ground id variable ground expression 
variables represent locations memory treated expressions represent values locations 
formally groundedness defined follows ffl value ground iff primitive value address 
ffl expression ground iff ground value 
ffl variable ground iff component expressions ground 
ffl statement ground iff empty block statements ground expression 
rules rewrite system 
redex rules specify reduction expressions cases sub expressions reductions 
sample stmt stmt gamma stmt stmt gamma rules specify generation exceptions null pointer dereferences bad array index bounds bad size creating new array runtime type checking assigning arrays 
simple example ground exp ground val null exp val stmt gamma cover rules array assignment method call 
omit rules field dereferencing variable lookup class creation field assignment local variable assignment conditionals straight forward covered de 
example array access rule case index bounds heap addr val val gamma type addr exp gamma val semantics java array creation rule dim ground non negative integer value val heap alloc heap type new type dim dim exp gamma val frames heap alloc represents process allocating theta gamma arrays containing pointers arrays eventually pointing arrays containing initial values appropriate type type 
process described detail gjs runtime typechecking java performs runtime typechecks just places array assignment casting values 
runtime typechecking needed array assignment known problem variant array typing rule 
casts covered report 
runtime typechecking performed simply checking real runtime type object stored state narrower real type array cell assigned 
means runtime system access program class interfaces hierarchies jvm 
aside drossopoulou eisenbach notion runtime type checking weak conformance little strong allows runtime machine check conformance primitive values primitive types realistic implementation java checks runtime primitive type int fits slot 
addressed model plan near 
array assignment rules utilise runtime type checking sval ground heap addr val val gamma type typecheck sval type fails addr sval exp gamma sval ground heap addr val val gamma type typecheck sval type succeeds heap addr val val gamma sval val val gamma type addr sval exp gamma void function typecheck checks stored type compatible type 
succeeds address addr type ty heap ffl addr ae ty wider ffl addr ty ty wider ty versions semantics perform compatibility checks primitive null values 
model array creation need modified threads constructors considered array creation atomic respect thread execution 
may involve executing constructors may terminate may raise memory exception 
steps java type soundness local variables method calls local stack variables annotated frame number indicates instance variable referred reminiscent de bruijn indices lack higher order features things simpler 
reasoning substitution method call easier 
aside initial rexp created method called 
body method fetched program translated annotating local variables fresh frame number 
rule arg ground value addr ae meth body frames phi fx 

addr meth arg arg exp gamma body body process translating input syntax body java term annotating local variables available frame number steps formalized machine checked human readable proof java type soundness sections process develop formal proof type soundness java methodology applied exploratory theorem proving exercise 
steps follows ffl step understand problem ffl step develop machine acceptable model ffl step validate model generating interpreter ffl step formulate key properties ffl step sketch outline proof ffl step convince machine methodology somewhat waterfall methodology software development step require return previous steps iterate task complete 
steps validation highly automated skipped iterations 
step step develop strong understanding problem 
tool called declare sym designed help users express proofs specifications fairly mental picture proof proceed 
stronger understanding user effective tool 
step second step rough understanding system question specify system higher order logic 
normally system previously specified process uncovers significant errors simplifications unexpected complications arise insufficiently expressive logic mechanised tool 
specify entire system proceeding 
developing machine acceptable model java step third step involves applying techniques check logical specifications written represent valid model java language 
validation specification non trivial topic ignored theorem proving community 
instance researchers rely process proof debug simple translation mistakes specifications 
tends slow reduces value proof performed 
case techniques validation eye typechecking automatic generation interpreter java directly specification 
possible remove mistakes specification technique surprising number caught 
step hopefully valid model java language form computer accept 
fourth step formulate terms logic properties expect hold specification 
typically involves writing typechecking propositions relate various parts semantics 
may simple typically learn lot doing thorough job writing properties terms logic forces state problem logically clear precise fashion step successful proof 
step step involves writing rough machine acceptable proof outline format close accepted declare 
declare supports expression proofs language resembles mathematicians allows migratory path rough outline machine acceptable outline 
surprisingly valuable stage process major flaw original proof discovered 
important product stage lemma discovery identify key facts component constructs pin argument 
ignored theorem proving community formalising established corpus mathematics necessary lemmas obvious priori support top proof development essential 
step sixth step lengthy completes ultimate aim fill details rough proof outlines point declare automated proof support takes 
surprisingly process turned unforeseen difficulties specifications proofs contributed process lemma discovery 
result proof outline machine checkable human readable claim maintainable features added language 
developing machine acceptable model java section sketched runtime typing semantics java language developed drossopoulou eisenbach 
section describe formalization simple type theory 
declare system give examples documents written machine checked 
documents described abstracts summaries theories checked consistent extensions higher order logic 
model formalization interesting uncovers ambiguities formal definition 
results disambiguation process modified semantics section 
simply small ex developing machine acceptable model java amples process formalization benefit readers unfamiliar techniques 
comments process machine formalization specification fully formal framework requires attention detail normally glossed written mathematics 
particular notational conveniences traditionally mathematicians available formal systems 
conveniences essential readability journal presentation proof discarded machine presentation 
addition journal presentation operational semantics frequently rely concrete means describing construct 
example representation environments java journal presentation environments represented list declarations declaration class interface variable 
logically fine expense having explicitly disallow repeated declarations class variable 
previous section representation terms partial functions 
representation automatically excludes ill formed environments clarifies mechanized presentation 
specification declare declare specifications act high level specifications interpreted axioms appropriate logic specification interpreter rules executable 
declarative forms available simple non recursive definitions recursive datatype definitions mutually recursive recursive positive type functions list inductive relations mutually recursive monotonic operators recursive functions wellfounded measure 
syntax classes described section easily defined declare datatypes give example 
inductive relations formulated specifying set rules giving name 
treated logical specification declare generates appropriate axioms fixed point set rules axioms derived conservatively known techniques cm pau 
example class class relations defined text object rw prolog te object decl rw prolog te te subclassof refl rw prolog te subclassof features listed fully implemented current version declare example monotonicity conditions currently checked 
validating model step prolog te class te subclassof te subclassof te type environment contains partial function table class names class declarations 
note necessity extra syntactic detail omitted written presentation indicate class domain ce 
pragmas rw prolog provide interpretative information proof tools specification interpreted set logical axioms particular rw indicates rule safely conditional rewrite prolog rule safely backchaining prolog style rule 
formalizing static semantics compilation runtime rewrite system runtime typing runtime terms relatively straight forward declare collection background theories 
iterated constructs replaced bounded universal quantification side condition arg ground value val 
ground el args len vals len args 
el args rvalue el vals note index change take advantage theory natural numbers lists inclusion syntax constructor rvalue injects values domain expressions list operators el len 
machine acceptable specification runs lines total 
specification easily read understood authors original journal shown 
validating model claim specification developed previous section correct formulation language semantics section 
know specification represents model java subset considering sense 
definitions logically consistent 
style definition relying fixed point simple recursive definitions consistency specification essentially trivial 
validity harder question measure java language standard gjs addition understanding meaning constructs subset 
techniques validate specification 
eye 
type checking higher order logic 
compiling ml running test cases 
formulating key properties concentrate third 
appendix describe compiling manifestly executable specifications executable ml code generate interpreter language directly definitions 
interpreter able typecheck execute concrete java programs concrete environment 
interpreter efficient sufficient test small programs 
example required 
class relation shown sections compiles ml function semantically equivalent caml syntax target variant ml rec subclassof ce fun 
fail fun 
match ce 
fail 
subclassof ce seq nil seq cons infix operator seq obvious operations lazy lists implement backtracking 
subclass return lazy list identifiers acts non standard model relation defined inductive rules 
likewise translate recursive functions ml code backtracking needed 
course inductive relations higher order logic terms executable scheme 
exact executable subset large importantly inductive relations satisfy strict mode constraints allowed 
arguments divisible inputs outputs inputs defined previous inputs generated outputs 
concept familiar prolog mode constraints class relation 
choose translate directly prolog rules unification required expressing manifestly executable rules 
elimination implicit unification steps way existence algorithm demonstrated 
validate semantics written java declare produces caml module written 
modules compiled linked module implements core functionality 
test cases expressed higher order logic expressions better ability parse compile run java programs directly source code 
approximately errors discovered techniques 
breakdown follows ffl typing mistakes led mode violations 
ffl logical mistakes typing rules 
ffl logical mistakes runtime rules 
formulating key properties step formulate terms validated machine acceptable model properties expect true 
particular outline formulation type soundness property 
type soundness loosely speaking theorem says evaluation progresses configuration rewrite system conforms types expect terms narrow type 
formulating key properties formulation differs drossopoulou eisenbach assume reduction deriving non ground term 
formulation scale non deterministic threaded language constructs 
frame typing list tables types local variables 
frame typing indicates types expect local variables conform 
define auxiliary concepts typing conformance frame typings states self consistency heap heap widening heaps heap frame typings sections follow 
theorem type soundness state conforms frame typing typed term rewrites new state represents raised exception exists new larger frame typing narrower type new state environment conforms ffl ffl gamma ffl gamma ffl gamma ty ffl gamma represents exception exists ty ffl gamma ffl gamma ffl gamma ty ffl heap ffl ffl gamma ty ty proof induction derivation typing judgement outline sketched drossopoulou eisenbach guide rough edges 
drossopoulou eisenbach limit invariant state conformance 
fact stronger invariant widening heaps needed ensure type soundness 
discuss section 
typing define mean typing 
central consideration somewhat overlooked drossopoulou eisenbach led part error proof described section 
typing rules generally follow annotated java expressions addition rules addresses typing relation dependent current heap addr ae gamma addr addr ty gamma addr ty formulating key properties gamma null gamma null gamma null ty note longer demand unique typing null values considered type 
rule assignments different new rule drops requirement source type narrower target type case array assignments checked runtime type checking 
return issue section 
rule local variables gamma ty gamma id ty gamma ty ty gamma id void rule arrays gamma ty gamma arr idx ty gamma arr idx void conformance notion state conforming frame typing statement type soundness theorem defined follows 
definitions corrected version de 
value weakly conforms type ty heap type environment gamma ffl ty primitive type element primitive type ffl ty type null pointer ffl address instance class type gamma ty ffl address array element type ty gamma ty ty 
value conformance states components object array weakly conform 
value conforms type ty heap type environment gamma weakly conforms ty ffl address ae field idx ty field defined weakly conforms ty ffl address vec ty val vec weakly conforms ty heap conforms self consistent gamma written gamma hold ffl addr address addr ae addr conforms ffl addr address addr vec ty addr conforms ty 
set frames conforms frame typing heap gamma written gamma ffl local variable frame conforms corresponding type formulating key properties heap widening define notion widening heaps notion new report required induction invariant type soundness proof 
heap widening strong property essential proving maintenance types state changes 
expect heaps maintain value conformance way environment gamma heap narrower heap wider set addresses written gamma heap ffl addr addr conformed type ty context addr conforms ty context restrict definition set addresses allow possibility garbage collection demand continued conformance set active addresses 
current working definition universal 
formalized type soundness type soundness expressed section fact properties syntax category 
variables property stated declare follows te te heap te heap te frames heap frames heap var te var te heap var ty var ty heap heap te frames te heap te heap var ty te ty ty formulation straight forward transcription property expressed section 
property expressed similarly expressions statements 
syntax categories types statements simpler 
prove type soundness strengthen induction invariant ways ffl field variable ty ty needed field types left assignments narrow runtime typechecking needed 
ffl array variable similarly stack variables 
key lemmas selective list lemmas proved form basis type soundness proof 
formulating key properties object class ffl te te object class object 
widening transitive reflexive ffl result holds class int ref comp arr relations 
ffl transitivity results holds formed environments 
visibility maintained narrower types ffl te te class fld vt gamma fld vt gamma 
ffl similarly te te ref rt te exists rt te rt rt rt te methods visible possible narrower return types 
method fetching behaves correctly ffl te te prog rt te method te method rt 
ffl fetching body method runtime results method type expect 
relations monotonic heap ffl holds typing value conformance frame conformance relations 
state manipulations preserve heap heap frame conformance ffl holds object array allocation 
ffl holds field array local variable assignment method call 
type soundness compilation complement type soundness proof prove process compile time disambiguation preserves types 
easy state ce ce ce ce property proved demonstrating similar property holds syntax classes expressions class bodies 
sketching outlines proofs sketching outlines proofs ready proof type soundness theorem formulated previous section 
reader keep mind proof begun guide available rough proof outline de formulation problem subsequently flawed 
process proof discovery proof transcription 
section describe process proof discovery section major flaw proof discovered technique described 
proof type soundness proceeds derivation typing judgment term clear 
consider case rule inductive relation 
aim write cases proof language close declare proof language level close machine checkable 
sketching machine checking give example demonstrates difference scratch proof outline machine checkable version case proof 
scratch outline trivial case case var id var reduction stack vars resolved contradiction var reduces machine acceptable form typing rule case induction len ft el ft id varty ce ft id varty final machine acceptable version proof case var id auto len ft el ft id var ty contradiction rule cases var reduces things added get machine accept proof 
various reasons declare demands inductive hypotheses listed induction case gives assistance constructing listed document 
secondly extra fact rule case analysis applied added justification claim contradiction arisen tag auto added implicitly include fact justifications 
typical examples machine checking requires user precise helpful small ways 
sketching outlines proofs complicated case scratch proof outline case field access variables 
proof decomposes cases sub expression reduces 
proof outline deliberately left documentation notes included 
case field var obj fld te ft obj vt class 
te ft obj vt class obj types 
te subclassof subclass 
te class fields methods 
fields fld var ty 
obj ty vt class case analysis obj reduction suppose obj obj obj reduces 
obj give exception 
cases obj reduces 
case obj easy var exceptional case obj reduces narrower 
case ft ft te ft te ft obj obj ty te obj ty obj ty obj class subclass note sure didn start object finish array 
object cos got field 
ll need lemma 

object auto object field lemma consider st obj ty vt class te subclassof subclass 
class widens lemma subclass te subclassof 
subclass trans subclass subclass proce typing judgment var 
type field types change 
te ft var var ty folks 
qed bits pieces var ground access left unresolved var 
contradiction obj reduces proof outline follows discipline mathematician computer scientist taught decompose problem assess information available assess proved determine correct plan action determine lemmas required construct solution accordingly 
simply different medium pen progressively heading machine checked proof 
sketching outlines proofs detailed machine checking proofs previous section outlined cases type soundness proof indicated involved getting declare proof checker accept proof 
process repeated major cases type soundness proof 
typically pass case proof result ffl steps logical leaps proof accepted immediately ffl steps require addition supporting facts occasionally explicit instantiations ffl cases require thought anticipated 
completed field case shown 
exp types macro induction invariant 
case field var obj fld auto obj 
te ft obj vt class 
te ft obj vt class obj types 
te subclassof subclass 
te class fields methods 
fields fld var ty 
obj ty vt class case analysis obj reduction suppose obj obj obj reduces 
obj give exception 
cases obj reduces 
case obj auto qed exceptional obj reduces narrower 
case ft ft ft larger 
te ft conforms 
te ft obj obj ty obj ty 
te obj ty obj ty obj narrower 
object cos got field 
suppose object auto contradiction object field lemma consider st te subclassof subclass 
obj ty vt class auto class widens lemma obj narrower prove var welltyped type te subclassof 
subclass trans subclass subclass te ft var var ty var types 

fields methods obj ty qed ft larger conforms var types var narrower var ground access left unresolved var 
contradiction obj reduces rule cases var reduces mistakes machine checking proofs various lemmas initially assumed took minutes hour case 
reader note powerful automated routine may able find proof fact process writing proof corrected significant errors confounded best automated routines increased automation correct formulation 
mistakes section describe major error major omission drossopoulou eisenbach presentation type soundness proof 
error discovered outlining proof omission performing detailed machine checking 
describe error language spec independently rediscovered 
runtime typechecking array assignments exceptions drossopoulou eisenbach original formulation type soundness property stated lines emphasis added theorem typed term ground rewrites new state environment gamma 
furthermore eventually rewrites exception narrower type new state environment 
iterated rewriting attempted fix problem demonstrated program void silly arr arr runtime arr may array narrower type say subclass array assignment appears badly typed exception detected rewriting left side narrower type right 
allow exception appear number additional steps 
arr narrower subsequently fail terminate 
exception raised arr loop problem occurs simpler cases arr narrower types 
left side evaluated array assignment appears badly typed typed right side evaluated 
fix problem requires different understanding role types assign 
types intermediary exist just help express type soundness invariant machine allowable states typed instance machine reach 
particular array assignment rule relaxed allow appear badly typed assignments get caught runtime typechecking mechanism 
problem interesting case attempted re typing rules different setting runtime setting typechecking setting led subtle error believe detected kind detailed analysis mistakes machine formalization demands 
mistake setting 
surprisingly difficult exercise discover exact logical step drossopoulou eisenbach original proof flawed 
side effects types significant omission drossopoulou eisenbach proof follows term subterms arr idx arr reduction arr types idx may change narrower due side effects state 
possibility considered drossopoulou eisenbach requires strengthening induction invariant incorporating heap widening heap number significant new lemmas stating typing monotonic respect frame heap relationship relationship 
foremost lemmas mentioned section 
problem discovered doing detailed machine checking rough proof outline proofs lemmas surprisingly complex entire proof 
methods visible interfaces 
process finishing proofs lemmas described section independently rediscovered significant flaw java language specification developers java implementation pb 
theory flaw effect type soundness authors language specification confirmed specification needs alteration 
problem java interfaces arrays considered subtypes type object sense cast interface array type object permitted 
type object supports primitive methods object object getclass total 
question expressions static type interface support methods 
morally speaking interfaces support object methods class implements interface support methods virtue subclass object array 
sun jdk toolkit allow methods called static interface types indicated successful compilation execution code public interface public class public static void main string args null null hashcode getclass equals language specification clearly says interfaces support methods listed interface superinterfaces implicit corollary mother classes object interfaces members interface type fields methods 
members interface ffl members declared direct superinterfaces ffl members declared body interface 
summary 
analogue class object interfaces class extension class object single interface interfaces extensions 
gjs pages summary report corrections semantics java machine formalization semantics technique partially validate semantics example new mechanized proof techniques prove type soundness property language 
formal techniques specify languages developed demonstrates part formal techniques convincingly help specify major language 
java far complicated java covered initial groundwork 
drossopoulou eisenbach formalization inspiration excellent example operational semantics 
suggest form specification may ultimately provide better repository information formal especially flexible tools provided read interpret 
specification interpreter basis formal proofs 
formal proofs find mistakes disciplined approach enforced writing proof accepted mechanized tool ensures errors described section detected 
encourages high degree clarity formalization problem place 
declarative proof language played crucial role allowed author think clearly language preparing proof outline computer 
error simply preparing proof outline checking detail 
process preparation question machine accept proof consistently asked ensured unwarranted logical leaps 
independent rediscovery mistake language specification described section indicates errors discovered process formal proof 
mistake discovered presumably implementors attempting follow language specification precisely 
formal specification logic known value discovering bugs specifications 
demonstrated proof sketching proof checking formal framework detect serious mistakes theoretical framework language development 
interesting note major errors discovered late stage formal proof 
related tobias nipkow david von oheimb working developing proof type soundness property similar subset java isabelle theorem prover 
am extremely grateful chance talk adopted suggestions 
works provide valuable case study utility various theorem proving methods kind problem 
isabelle mature system complementary strengths declare notably strong generic automation manifest soundness 
tool unites concrete experience exciting prospect 
computational logic released formal model subset java virtual machine jvm coh 
model called defensive jvm includes sufficient run time checks assure type safe execution detect prevent unsafe execution 
standard jvm checks 
extending cover type safety jvm partly model 
model article scope extended directions 
treatment expanded encompass features exceptions constructors access modifiers static fields static methods major problems involve significant expansion size proofs 
features threads java semantically visible garbage collection pose greater problems possible 
began case study application declarative proof language operational reasoning ways declare similar systems improved experience 
necessary feature degree computer aided proof writing described briefly sym 
acknowledgments sophia drossopoulou khurshid excellent day imperial spent discussing possible relevance project 
david von oheimb tobias nipkow mark staples michael mike gordon frank useful discussions concerning 
cm melham 
reasoning inductively defined relations hol theorem prover 
technical report university cambridge computer laboratory august 
coh richard cohen 
defensive java virtual machine version alpha release june 
published www www cli com software 
de sophia susan eisenbach 
java type system sound 
june 
submitted special edition theory object systems 
de sophia susan eisenbach 
java type safe probably 
th european conference object oriented programming 
june 
published 
gjs james gosling bill joy guy steele 
java language specification 
addisonwesley 
gm gordon melham 
hol theorem proving assistant higher order logic 
cambridge university press 
har john harrison 
proof style 
technical report university cambridge computer laboratory january 
declare muzalewski 
outline pc mizar 
foundation philippe le 
nn dieter tobias nipkow 
formal verification algorithm monomorphic case 
grundy von wright harrison editors theorem proving higher order logics th international conference lecture notes computer science pages 
springer verlag august 
michael 
dynamic semantics technical report university cambridge computer laboratory may 
orr owre rajan rushby shankar srivas 
pvs combining specification proof checking model checking 
rajeev alur thomas henzinger editors computer aided verification cav volume lecture notes computer science pages new brunswick nj july august 
springer verlag 
pau paulson 
isabelle theorem provers 
odifreddi editor logic computer science pages 
academic press 
pau paulson 
fixed point approach implementing inductive definitions 
bundy editor th international conference automated deduction pages 
springer 
pb peter bertelsen 
unofficial java bug report june 
published www www vo lu homepages java htm 
sym don syme 
reasoning formal definition standard ml hol 
higher order logic theorem proving applications th international workshop hug number lncs vancouver august 
springer verlag 
sym don syme 
declare prototype declarative proof system higher order logic 
technical report university cambridge computer laboratory march 
van 
hol ml 
higher order logic theorem proving applications th international workshop hug number lncs pages vancouver august 
springer verlag 
van 
type preservation core sml 
journal automated reasoning january 
submitted special issue formal proof 
declare declare declarative proof system polymorphic simple higher order logic 
designed aid production clear readable maintainable specification proof documents 
declare complete polished system developed aim testing various features incorporated existing supported theorem provers hol isabelle pvs 
influenced heavily mizar hol gm isabelle pau pvs orr 
lcf style deductions reduced primitive deductive framework 
features interest ffl declarative language express proof outlines 
declare ffl support modularization separate processing top formalization leads structured efficient working environment 
ffl automated proof support 
proof language try achieve simplest means possible results machine checkable human readable 
declare proof language inspired mizar harrison har way specifying outline proof induction case decomposition arbitrary substantiated claims 
language demonstrated example section 
proof languages called declarative place contrast procedural tactic mechanisms specifying proofs 
declarative proof language advantages ffl declarative proofs readable tactic proofs 
ffl proof interpretation terminates tactic proofs expressed turing complete language 
ffl declarative proofs potentially maintainable changes specification prover 
ffl declarative proofs potentially portable 
specification proof documents developed declare principle portable proof systems 
ffl declarative style may appeal wider class users helping deliver automated reasoning formal methods mathematicians 
working environment declare large bodies broken series articles may interface called 
articles checked relative abstracts import implement export 
abstracts may pre compiled combination system gives simple light weight effective means maintaining coherence large collections specifications proofs 
approach means declare typically uses mb memory executing 
automation declare proofs proof outlines require automation fill gaps argument 
way proof language acts bridge human automated capabilities proof checker 
automation report fairly straightforward ffl boyer moore isabelle style simplification conditional higher order rewriting normalize expressions 
simplification performed auspices sided sequent calculus pvs 
simplification researchers take view human readable proofs generated output mechanized proofs may possible highly complex process results convincing 
approach input readable place 
full widening rules apply safe elimination rules choosing witnesses splitting conjuncts goal formulae apply unwinding rules eliminate local constants existential universal formulae sequent pair tuple record values case split constructs conditionals quantified structural variables booleans options apply large background set rewrites collected imported abstracts normalize arithmetic expressions exploratory unwinding definitions style pvs 
support controlled left right simplification certain guarded expressions helps avoid common causes non terminating rewriting strategies 
ffl simplification simple tableau prover iterative deepening minor equality rules search values unknowns 
level automation sufficient exploratory proof development important stage content guiding prover proof expecting complex steps inductions automated 
significant problems arise venture problem space requires significant equality proof search reasoning major research area equality reasoning amenable rewriting completion declare decision procedures help 
automation declare guided purely declarative tags lemmas declarations weightings hints specified lemma 
ensures proof documents overly reliant quirks underlying prover 
full widening rules rules determine widening subtype relation 
gamma class gamma gamma int gamma gamma gamma object gamma class gamma imp gamma int gamma ty prim types gamma ty comp ty ty ty simple ref types gamma ty ty gamma ty comp ty ty component types gamma ty arr object gamma ty comp ty gamma ty arr ty ty ty array types gamma ty arr ty gamma ty ref ty ty ty simple ref types gamma ty ty gamma ty ref ty ty ref types gamma nullt ref ty ty prim types gamma ty ty ty ty ref types gamma ty ref ty gamma ty ty full traversal rules full traversal rules rules determine methods fields visible class 
relations evaluate graphs formed environments determine partial functions 
gamma field ty gamma ty fdec field gamma hc sup field undef gamma ty fdec sup field gamma ty fdec field gamma field ty gamma field ty gamma hc sup gamma field ty sup gamma field ty gamma meth rt gamma meth rt gamma hc sup meth undef gamma meth rt sup gamma meth rt 
