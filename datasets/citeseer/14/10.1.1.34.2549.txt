survey reverse engineering program comprehension michael nelson april cs software engineering survey reverse engineering standard practice hardware community time 
years reverse engineering program comprehension grown current sub discipline software engineering 
traditional software engineering primarily focused development design new software 
programmers software people designed developed 
software maintainers time spent determining intent source code 
growing demand reevaluate reimplement legacy software systems brought proliferation clientserver world wide web technologies need reverse engineering tools techniques 
introduces terminology reverse engineering gives obstacles reverse engineering difficult 
reverse engineering remains heavily dependent human component number automated tools aid reverse engineer 
motivation reverse engineering reverse engineering origins analysis hardware commercial military advantage 
purpose deduce design decisions products little additional knowledge procedures involved original production 
techniques currently researched application legacy software systems industrial defense ends recover incorrect incomplete unavailable documentation 
software reverse engineering program comprehension understanding research area devoted developing tools methodologies aid understanding management increasing number legacy systems 
traditional software engineering research development focuses increasing productivity quality systems development planned 
maintenance existing systems estimated consume resources total software budget 
maintenance function reverse engineering activities comprehension require total time enhancement correction tasks respectively 
diminishing importance software engineering activities focusing initial design development empirical evidence suggests significant resources devoted reversing effects poorly designed neglected software systems 
perfect world software systems past developed maintained benefit structured software engineering guidelines 
real world systems structured design negated tools methodologies handle cases 
reverse engineering defined better define area reverse engineering necessary explain larger context software system lifecycle 
terms definitions adapted canonical taxonomy forward engineering term obvious opposite reverse engineering offered distinguish traditional software engineering process reverse engineering 
reverse engineering process identifying software components interrelationships representing entities higher level abstraction 
reverse engineering involves analysis change 
program comprehension program understanding terms interchangeably reverse engineering specializations reverse engineering offered increasing level impact weakest form reverse engineering involves merely creation existed revision system documentation level abstraction 
design rediscovery uses domain knowledge external information possible create model system higher level abstraction 
restructuring lateral transformation system level abstraction 
maintains level functionality semantics 
reengineering radical far reaching extension 
generally involves combination reverse engineering comprehension forward engineering reexamine functionalities need retained deleted added 
substituting business process organization software system subject area popular business process reengineering 
techniques just applied large scope 
illustrates relationship forward degrees reverse engineering 
difficulties reverse engineer reverse engineering challenging task involves mapping different worlds distinct areas 
application domain programming language programming language just model environment solve real problem 
tools exist assist understanding code doing code perspective little assist reverse engineer determining occurring code domain perspective 

machines programs high level design simple concepts sort list customers name quickly lost minutia detail programming 
computer science education largely mapping detailed implementation little assist reverse mapping 

original coherent structured system actual system structure decaying documentation available system maintenance time causes structure drift original specification 
reverse engineer able reconcile synchronize documented design current implemented design 
xyz tomorrow product today design forward engineering today product yesterday reverse engineering design rediscovery produce documentation design leave system unchanged system design docs system restructuring transforms system functionality remains intact reengineering changes functionality direction system system forward engineering reverse engineering derivatives 
hierarchical programs cognitive association computer programs formal hierarchical expressions 
humans think associative chunks data 
reverse engineer able build correct high level chunks low level details evident program 

bottom code analysis top application analysis code analysis nature bottom exercise 
requires simultaneously higher level meaning extracted code fragments higher level concepts mapped lower level implementations 
task difficult engineer able handle interleaving 
interleaving intentional optimization accidental poor design sloppy maintenance colocation logically separate tasks spatial sequence 
currently reverse engineering currently heavily dependent human interaction steering enc 
tools assist reverse engineer program comprehension fully automated process 
human element program comprehension subject field software psychology pioneered shneiderman 
software psychology measures human performance interacting computer information systems 
surveys software psychology reader referred 
approaches automating reverse engineering variety approaches automated assistance available reverse engineer program comprehension 
full list reverse engineering approaches available 
prominent approaches include 
textual lexical syntactic analysis approaches focus source code representations 
include unix lex lexical metrics counting assignments identifiers outlined automated parsing code searching 
standard approaches problem solving extracted source code give hints design decisions 
unit examination program source 

graphing methods variety graphing approaches program understanding 
include increasing order complexity richness graphing control flow program data flow program program dependence graphs 
unit examination graphical representation program source 

execution testing variety methods profiling testing observing program behavior including actual execution inspection walkthroughs 
dynamic testing debugging known tools available function 
large systems technique called partial evaluation available identify test isolate components system 
interpretation method denotational semantics perform static testing simulating behavior actual system 
unit examination full partial simulated execution program 
synchronized refinement representative hybrid method program understanding known synchronized refinement 
synchronized refinement consists parallel activities synthesis functional nonfunctional behavioral descriptions code level analysis program text 
parallel relationship depicted 
synchronized refinement iterative process automated tools code analysis human steering course correction 
initial supposed design decisions acquired documentation domain knowledge additional non source code information source seed process 
detailed source code analysis performed verify proposed design decision observed implementation 
differences noted design decisions revised 
accurate model design decisions process repeated continuously refining adjusting direction analysis 
developers synchronized refinement report results number reverse engineering projects including military telephony real time systems tools developed assist synchronized refinement 
application legacy systems applying reverse engineering legacy systems growth business 
hundreds billions lines source code world cobol 
realm scientific computing code entirely fortran 
takes little imagination speculate condition style code presence quality documentation lack corporate memory understanding codes 
cases organizations consider software systems capital assets current documentation processes conducted 
official documentation organization unsynchronized reality limited resources deadlines encourage design comprehension code comprehension high level low level understanding design figures synchronized refinement iterating actual design staff allow traditional documentation stale 
time organization dependent software system answer fundamental questions 
software system effectively oracle organization 
additional observed side effect poorly documented legacy systems personnel easily rotate organizations charged maintaining systems high learning curves 
decreases competitive flexibility organization having staff unqualified perform tasks qualified perform subset tasks 
mentioned traditional software engineering presupposes new development efforts 
ideal scenario practice chance start systems clean sheet happens infrequently 
functional system totally rewritten current hardware software available generally replacing previous functionally similar system understood retired 
increasingly recognition evidenced ways self describing data files scientific applications having support legacy systems explicitly included 
legacy software problem prevalent research literature organizations realize problem legacy systems tools methods program understanding immature 
examples reverse engineering support military legacy systems include 
significant events accelerating pace legacy systems reexamined 
growth client server systems 
includes supporting technologies driving area proliferation cheap powerful workstation class machines advances database management systems 
active commercial market years 
second event acceptance world wide web www universal interface 
fourth world wide web conference boston december significant focus application www legacy systems 
events technologies directly aid reverse engineering 
responsible creating larger demand reverse engineering tools techniques 
clientserver proliferation lesser extent www mainframe codes receive sort wholesale reevaluation 
traditional software engineering primarily focuses doing right time reverse engineering addresses expensive area maintenance pays cost having done right time allowing decay time 
software reverse engineering program comprehension difficult task recovering design information software system 
difficult perform intrinsic difficulties performing mapping language high level design requirements details low level implementation 
reverse engineering depends heavily human loop variety automation methodologies available support 
synchronized refinement hybrid method involving iterative application automation human intuition observation briefly 
driver interest reverse engineering world source code written modern languages systems lifecycle cost consumed maintenance 
comprehension existing systems consumes maintenance resources 
changing hardware network information architectures forcing revisitation legacy systems particularly mainframe databases 
largest catalyst date proliferation client server computing received renewed energy popularity world wide web technologies 
belady lehman programming system dynamics meta dynamics system maintenance growth ibm technical report rc september 
boehm software engineering economics prentice hall englewood cliffs nh 
sparks maintaining legacy systems process driven software engineering technology old dominion university computer science technical report tr january 
chikofsky cross ii reverse engineering design recovery taxonomy ieee software vol 
pp 
january 
cousot cousot interpretation unified lattice model static analysis programs construction fixpoints fourth annual acm symposium principles programming languages los angeles ca january pp 

ferrante ottenstein warren program dependence graph optimization acm transactions programming languages systems vol 
july pp 

application program maintenance study report respondents proceedings guide philadelphia pa april 
haines mehrotra van oo approach data file interoperability icase technical report july 
maurice halstead elements software science elsevier 
hammer don automate harvard business review july august pp 

hammer reengineering manifesto business revolution new york 
hecht flow analysis computer programs north holland 
moler nash numerical methods software hall englewood cliffs nj 
rugaber reverse engineering methodology data processing applications georgia tech technical report git serc march 
mcclure rs software automation hall englewood cliffs nj 
von vans program understanding survey colorado state university computer science technical report cs august 
partial computation construction language processors prentice hall 
reverse engineering resolving conflicts expected actual software designs proceedings conference software maintenance orlando florida november pp 

robson bennet munro approaches program comprehension journal systems software vol 
february pp 

rugaber leblanc jr recognizing design decisions programs ieee software vol 
january pp 

rugaber program comprehension reverse engineering aaai workshop ai automated program understanding san jose california july 
rugaber transition application programs cobol fourth generation language conference software maintenance montreal canada september 
rugaber wills interleaving problem program understanding nd working conference reverse engineering toronto ontario canada pp 
july 
rugaber program comprehension encyclopedia computer science technology draft appear april 
shneiderman software psychology human factors computer information systems little brown 
linda wills attributed flow graph parsing recognize programs workshop graph grammars application computer science williamsburg virginia november 
edward yourdon structured walkthroughs yourdon press 
