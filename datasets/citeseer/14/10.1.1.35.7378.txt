exploiting duality maximal frequent itemsets minimal infrequent itemsets ecient association rule mining loo chi lap yip ben kao david cheung department computer science information systems university hong kong hong kong 
kao hku hk algorithm mining association rules discover set maximal frequent itemsets maxl database 
set itemsets verify maxl conditions checked itemset frequent dual set minimal infrequent itemsets mins 
observation leads family algorithms mining association rules 
reasonable guess mins maxl verify duality relationship re ne sets conditions hold 
show previously proposed algorithms apriori members algorithm family 
study member algorithm called flipflop 
series experiments show flipflop signi cantly reduces requirement mining association rules 
keywords data mining association rules lattice association rule mining hottest topics data mining wide applicability areas decision support sales planning association rule induction rule form non empty non overlapping sets items 
problem association rules mining decomposed subproblems 
find frequent itemsets support counts 
frequent itemset set items contained suciently large number transactions respect support threshold minimum support 

set frequent itemsets nd association rules con dence value exceeding con dence threshold minimum con dence 
solution second subproblem straightforward major research orts spent rst subproblem eciently nd support notation de nition set items database ug set itemsets set frequent itemsets set infrequent itemsets fx lj jxj ig set size frequent itemsets fxj jxj set candidate itemsets generated feg apriori th iteration notational convenience max fx yg return maximal itemsets min fx yg return minimal itemsets maxl max set maximal frequent itemsets mins min set minimal infrequent itemsets yg set subsets set yg set supersets set min set maximal itemsets nd dual set minimal itemsets max set minimal itemsets nd dual set maximal itemsets table notation de nition counts frequent itemsets algorithms devised nd frequent itemsets apriori algorithm 
apriori algorithm nds frequent itemsets iteratively 
th iteration apriori generates number candidate itemsets size apriori scans database nd support count candidate itemset 
itemsets support counts smaller minimum support discarded 
apriori terminates candidate set generated 
key apriori algorithm apriori gen function wisely generates candidate itemsets potential frequent 
database scan candidate itemsets size generated 
consequently number database scans required apriori algorithms depends size largest frequent itemsets 
example database contains size frequent itemset passes database required 
large databases containing gigabytes transactions cost big 
goal devise ecient algorithm nding frequent itemsets 
see shortly trick lies duality property maximal frequent itemsets minimal infrequent itemsets 
frequent itemsets maximal proper subsets frequent itemset set maximal frequent itemsets denoted maxl nding support counts frequent itemsets simple 
essentially generate maximal frequent itemset maxl set yg set subsets union table shows symbols notations de nitions 
size itemset number items itemset contains 
sets obtain maxl scan database obtain support count itemset maxl notice property itemset frequent implies subsets frequent maxl procedure obtain support counts frequent itemsets 
discussion suggests discover maxl eciently potentially cut number database scans required mining process 
discuss obtain maxl fast rst consider dual problem 
suppose set itemsets set infrequent itemsets equal itemsets minimal sense proper supersets itemset denote set containing minimal infrequent itemsets mins 
maxl theoretically uniquely determine mins evaluating expression mins maxl min maxl min function set returns minimal itemsets see table formal de nition 
symbol denote transformation maxl corresponding mins 
conversely note mins maxl determined maxl mins max mins xg called set set supersets max returns maximal elements set 
symbol denote transformation mins corresponding maxl 
set maximal itemsets set minimal itemsets equivalently say duals 
suppose oracle suggests mins maxl guesses real mins maxl respectively 
verify true mins maxl satisfy necessary sucient conditions mins infrequent maxl frequent mins maxl equivalently maxl mins 
proof see appendix 
note condition requires mins maxl duals 
conditions hold maxl maxl task nding support counts assume mins maxl contain minimal maximal itemsets respectively 
mins min mins maxl max maxl 
algorithm find freq item set mins maxl itemset mins frequent itemset maxl infrequent mins maxl maxs mins re ne mins re ne maxl maxl scan count supports itemsets supports counted 
finding support counts frequent itemsets frequent itemsets done easily discussed previously 
hand conditions hold scanning database discover itemset mins frequent need modify re ne sets mins maxl 
re ned sets tested conditions re ned conditions satis ed 
strategy leads framework association rule mining algorithms shown 
point may question approach lead ecient practical algorithm 
approach requires guesses mins maxl traditional algorithms apriori require guesses 
see approach encompasses family mining algorithms 
particular previously proposed algorithms apriori special cases approach 
argue approach potential outperforming traditional mining algorithms especially guesses maxl mins available example mining sample database 
illustrate advantage approach proposing analyzing algorithm flipflop falls algorithm framework 
rest address issues check conditions 
checking members mins maxl frequent easily done scanning database 
checking duality condition mins maxl maxl mins may straightforward 
evaluates dual operators de nition expressions see table needs handle set subtraction involving set itemsets 
cases simply big handle computation infeasible 
show dual operators implemented eciently section 
previous algorithms described framework 
show apriori pincer search fall algorithm framework 
section shows example apriori 
particular discuss mins maxl maintaining apriori re nes sets apriori checks termination conditions 
obtain initial guess mins maxl 
section show obtain guess mins maxl mining small sample database 
show algorithm signi cantly outperforms cost mining sample taken account 
applications guesses readily available 
example supermarket database may store transactions performed months 
month new set transactions added database transactions months old deleted 
old updated databases overlap large extent large itemsets mining old database guess large itemsets updated database 
algorithm framework leads ecient algorithm 
propose discuss algorithm flipflop section takes advantage educated guess maxl mins discover frequent itemsets 
compare flipflop ecient algorithms pincer search dic 
show performance gain achieve flipflop previous algorithm 
dual operators section discuss dual operators eciently implemented 
correctness proofs algorithms appendix 
computing rst consider 
set maximal itemsets itemset proper subset itemset de ned min set itemsets 
brute force algorithm enumerate itemsets collect itemsets subset itemset resulting set algorithm computes min discarding itemsets proper supersets itemset method clearly infeasible cardinality exponential respect number items database 
observations tell need consider itemsets observation size largest itemset itemset contains items 
proof clear itemset size larger itemsets size itemset size minimal result contain itemset items 
recall size itemset refers number items contained itemset 
observation itemset fx fx distinct fx fx proof fx fx fx fx minimal contradiction 
distinct fx fx fx fx implies contradiction 
observation suggests order compute needs consider itemsets size size largest itemset itemset fx observation implies exist distinct fx fx intersection contain items particular fx 
note observation strategy computing goes follow determine size largest itemset 
consider pair jt generate itemsets picking items item item verify size subsets subset subset 
add size itemsets subset shows algorithm computing maximal set returns itemsets size equals 
shows algorithm computing returns itemsets larger equal compute simply calls 
computing argue algorithm computing works eciently practice 
algorithm framework operator applied approximation maxl maxl 
maxl reasonable estimate expect size largest itemset maxl close maxl 
practice number small 
example largest frequent itemset database size close 
loop computing executed times 
compute need consider possible size itemsets derived members maxl 
search space heavily pruned 
fact algorithm flipflop section uses procedure consumes similar amount cpu apriori signi cant saving 
function foreach 
fa fa fa fa 
foreach return computing function size largest itemset return computing function itemset itemset fmg item feg subset itemset fm return computing method computing quite lead ecient implementation 
similar reasoning observation allows conclude size smallest itemset itemset contains items 
unfortunately observation means need consider itemsets sizes total number items database 
numerous handle 
pincer search authors invented ingenious way discovering frequent itemsets 
informally pincer search maintains set called mfcs satis es constraint frequent itemset database subset itemset mfcs 
scanning database pincer search may discover certain set itemsets infrequent 
function called mfcs gen executed re ne mfcs newly discovered knowledge due re ected new mfcs 
due space limitation interested readers referred details 
discovered function mfcs gen ecient way computing disguise 
shows algorithm computing set minimal itemsets algorithm originates mfcs gen proposed 
algorithm maintains set itemsets algorithm terminates gives 
initially set contain lone set items database 
processes itemset turn 
itemset superset know removed line 
generate immediate subsets formed removing item itemsets check maximal added example suppose set items fa fg initially ffa fgg 
suppose ffa bg fa cgg 
rst consider fa bg 
fa fg superset fa bg removed new itemsets fa fg fb fg generated 
subsets itemset empty point added ffa fg fb fgg 
consider itemset fa cg see fa fg superset fa cg 
fa fg removed itemsets fa fg fc fg generated 
subset itemset added subset fb fg discarded 
algorithm terminates ffa fg fb fgg 
apriori section discuss apriori described algorithm framework 
apriori iterative algorithm 
rst iteration apriori scans database obtain set size frequent itemsets nd iteration candidate set size itemsets fxj jxj size subsets generated 
database scanned count supports itemsets frequent ones put set frequent size itemsets 
general th iteration discovered counted set fxj jxj size subsets generated 
note rst database scan apriori discovered consider apriori rst guess true maxl 
shown set items database 
consider set apriori rst guess mins 
notational convenience alias general th iteration consider sets maxl max mins apriori guess maxl mins prove observation observation mins maxl duals 
mins maxl maxl mins 
proof see appendix 
recall framework see algorithm nding frequent itemsets terminate conditions sati ed 
observation know apriori ensures guess mins maxl satisfy duality condition 
de nition itemsets maxl max frequent 
condition left check itemsets mins infrequent 
amounts checking set itemsets supports counted veri ed infrequent previous iterations 
interestingly exactly apriori th pass database 
apriori terminates equivalent saying mins contains infrequent itemsets 
show apriori special case algorithm framework 
flipflop nice property apriori maxl max guess maxl verifying dual maxl contains infrequent itemsets amounts checking itemsets veri cation process simple 
unfortunately special structure apriori maxl essentially requires complete set known order derive size itemsets need checked 
result checking supply apriori information itemsets size larger implies re nement maxl performed steps apriori initial guess maxl 
initial guess maxl apriori obtained scanning database 
guess usually fairly far real maxl 
example largest frequent itemset database contains items takes apriori passes re ne maxl real maxl 
rst database scan ectively utilized obtain guess 
alternatively take sample database obtain reasonable guess maxl mining sample 
previous study shown sampling cost ective technique nding approximate solution mining problem 
example size largest frequent itemset mining sample apriori requires sample times 
cost scanning complete database obtain maxl obtained mine sample method closer real maxl ecient mining algorithm better guess maxl 
propose algorithm flipflop follows principal 
maxl obtained mining sample database flipflop rst computes dual mins maxl 
itemsets mins maxl put counting set cs 
database scanned obtain support counts itemsets cs 
itemset subset itemset maxl included cs maxl reasonable guess maxl itemsets maxl frequent supports counted anyway order generate association rules 
count rst pass 
set cs partitioned sets set frequent itemsets fcs set infrequent itemsets 
result counting update mins maxl 
speci cally maxl max fcs mins min 
point know maxl contains maximal frequent itemsets mins contains minimal infrequent itemsets 
guaranteed duals 
flipflop applies dual operators construct new cs maxl mins mins maxl 
duality condition hold cs non empty 
database scanned determine supports itemsets cs 
result counting update maxl mins 
process repeats cs empty 
shows algorithm algorithm flipflop maxl cs maxl maxl maxl mins repeat scan database count supports itemsets cs fcs frequent itemsets cs infrequent itemsets cs maxl max maxl fcs mins min mins cs maxl mins mins maxl cs return support counts itemsets maxl algorithm flipflop flipflop 
experiments results evaluate performance flipflop performed extensive simulation experiments 
goals study amount saving achieved flipflop apriori ecient algorithms dic pincer search sampling construct guess maxl 
compare algorithms terms cpu usage 
section representative results experiments 
synthetic data generation experiments followed approach synthetic data test databases 
brie describe synthetic database generation procedure 
readers referred details 
generate transaction database rst generate pool potentially frequent itemsets 
itemset generated rst determining itemset size poisson distribution mean jij 
jw itemsets divided groups itemsets 
group items rst itemset picked randomly set items 
itemsets fraction items rst itemset duplicated 
fraction determined poisson distribution mean equal 
rest picked randomly 
generated generate database size transaction generated poisson distribution mean jt random itemset chosen items added transaction generated 
transaction acquired desired size move generate transaction 
pick itemset repeat procedure transaction parameter description value jdj database size number transactions number items jw number potentially frequent itemsets jij average size potentially frequent itemsets jt average size transactions group size table parameters database generation model got desired number items 
table summarizes parameter setting baseline experiment 
mining sample discussed mining sample ective way obtaining guess maxl 
performed set simulation experiments study sampling done order obtain estimate maxl 
experiments synthetic database generated 
fraction transactions extracted database samples 
mined samples apriori 
maximal resulting frequent itemsets discovered maxl flipflop 
repeated experiment number times di erent set samples 
experiment recorded total cost spent number itemsets supports counted 
costs included spent mining samples apriori mining database flipflop 
express cost terms database scans 
example suppose apriori takes passes samples amount spent apriori applied samples equivalent database scan 
flipflop takes passes database total cost database scans 
similarly expression measure amount ort flipflop spends counting itemset supports total 
itemsets counted itemsets counted sample 
itemsets counted flipflop value costs itemset counting costs spent di erent experiment runs corresponding di erent sets samples taken averaged 
average costs compared apriori apriori applied database directly 
table shows result typical experiment 
experiment database generated baseline setting table 
support threshold set 
table rows labeled mining sample shows costs applying sample rows labeled flipflop shows costs executing flipflop supplied maxl mining sample rows labeled flipflop include sampling shows total costs mining process 
apriori applied database directly took passes number candidate itemsets sample size cost mining sample flipflop flipflop include sampling apriori itemset counting cost mining sample flipflop flipflop include sampling apriori table performance flipflop versus sample size counted 
table see larger sample size fewer passes flipflop requires 
example flipflop takes passes complete average 
maxl suggested mining big sample close real maxl 
bene ts flipflop greatly 
costs mining sample increases increasing sample size large values counter productive 
table see picking range gives performance total cost required passes half apriori needs passes 
cpu requirement algorithms measured itemset counting cost 
similar case cost smaller sample size causes amount counting performed mine sample phase counting ort spent flipflop phase 
smaller sample gives accurate estimate maxl result infrequent itemsets counted flipflop super 
table see picking causes amount total counting ort 
comparing counting cost apriori flipflop requires cpu time 
cpu overhead brings cost reduction 
shown mining samples slightly lower support threshold required database improves accuracy estimate 
re ran experiments mine sample phase done smaller support threshold sample table shows performance algorithm di erent values sample experiment sample size xed database 
table see setting smaller value sample dramatically reduces cost 
example sample cost saving compared apriori took passes data 
cost reduction comes expense higher itemset counting cost 
mining sample cost flipflop include sampling itemset counting cost flipflop include sampling table performance flipflop versus sample algorithm apriori dic pincer search flipflop flipflop table performance sample small support threshold itemsets considered frequent sample phase 
recall flipflop generates rst counting set cs cs maxl maxl line essentially itemsets considered frequent mine sample phase included cs 
large cs mixed blessing causes itemsets counted higher itemset counting cost allows information obtained supports itemsets determined scanning database better re nement maxl mins leading fewer passes 
wants trade cpu better eciency especially system slow storage component flipflop shown provide exibility tuning sample ecient algorithms compare performance flipflop ecient algorithms dic pincer search 
experiment applied algorithms synthetic database recorded costs various values support threshold 
table shows result 
rows numbers flipflop shown 
corresponds sample labeled flipflop corresponds sample cases costs include spent mining samples 
table see flipflop outperforms terms performance 
example sample saving cost comparing apriori obtained 
reduction improved support threshold mining sample 
dic pincer search performed better apriori cost savings gained flipflop 
terms cpu requirement flipflop slightly ecient 
example experiment flipflop higher itemset counting cost algorithms sample system really slow component cost reduction important cpu overhead lower sample case experiment registered cpu overhead ranging 
described algorithm framework discovering large itemsets transaction database duality property set maximal frequent itemsets maxl set minimal infrequent itemsets mins 
proved number observations governed duality property 
observations propose ecient algorithms implement dual operators 
operators allow derive new algorithm flipflop nding large itemsets 
argued flipflop particular ecient guess maxl available 
obtain estimate maxl sampling techniques applied 
showed small sample usually sucient generate approximate maxl fairly accuracy 
showed algorithm achieve signi cant reduction cost compared algorithms apriori dic pincer search 
signi cant improvement obtained expense mild increase cpu overhead 
flipflop ecient practical algorithm mining association rules 
agrawal srikant 
fast algorithms mining association rules large databases 
proc 
twentieth international conference large databases pages santiago chile 
sergey brin rajeev motwani je rey ullman shalom tsur 
dynamic itemset counting implication rules market basket data 
proceedings acm sigmod conference management data 
dao lin zvi kedem 
pincer search new algorithm discovering maximum frequent set 
proceedings th conference extending database technology edbt valencia spain march 
jong soo park ming chen philip yu 
ective hash algorithm mining association rules 
proc 
acm sigmod international conference management data san jose california may 
imielinski agrawal swami 
mining association rules sets items large databases 
proc 
acm sigmod international conference management data page washington may 
hannu toivonen 
sampling large databases association rules 
proceedings nd conference large data bases vldb september 
appendix prove observations mentioned 
notational convenience overload set set operators sets itemsets necessary sucient conditions suggested sets mins maxl real mins maxl prove set minimal itemsets mins set maximal itemsets maxl mins mins maxl maxl mins infrequent maxl frequent mins maxl equivalently maxl mins 
proof necessary mins mins maxl maxl de nition conditions satis ed 
maxl maxl min maxl min min mins mins condition follows 
sucient clear max maxl maxl 
maxl contains maximal itemsets maxl maximal maxl max maxl maxl max maxl 
max maxl maxl maxl maxl min maxl maxl mins condition mins condition maxl implies subset frequent itemset condition 
maxl maxl combining equation maxl max maxl max maxl prove mins mins similar argument 
proof observation prove mins maxl maxl mins proof recall de nitions fx jxj size subsets mins maxl max itemset mins minimal de nition exist itemset mins subset itemset mins mins min mins de nition itemsets maxl maximal set maxl denote set itemsets size maxl min maxl min equation min min itemsets minimal min min de nition itemset proper infrequent subset taken min operator 
maxl min min mins mins equation maxl mins duals 

