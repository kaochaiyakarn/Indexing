semantics imprecise exceptions simon peyton jones microsoft research cambridge simonpj microsoft com alastair reid yale university reid alastair cs yale edu tony hoare cambridge university computer laboratory comlab ox ac uk simon marlow microsoft research cambridge microsoft com fergus henderson university melbourne cs mu oz au modern superscalar microprocessors provide imprecise exceptions 
guarantee report exception encountered straightforward sequential execution program 
exchange er increased performance decreased chip area amount thing 
performance precision tradeo far explored programming language level 
propose design imprecise exceptions lazy functional programming language haskell 
discuss designs conclude imprecision essential language enjoy current rich algebra transformations 
sketch precise semantics language extended exceptions 
shows extend haskell exceptions language compilers 
experience new mechanism know strikes appropriate balance expressiveness performance 
current programming languages support exceptions take granted language de nition specify program exception raised program executed 
case microprocessor architecture longer 
processors notably alpha provide called imprecise exceptions 
cpus execute instructions parallel order follows study leave oxford university computing laboratory rst exception divide zero say encountered necessarily rst encountered simple sequential execution 
approach provide lots hardware sort mess maintain programmer illusion simple sequential execution engine pentium 
taken alpha give precise indication whereabouts exception 
explore idea level programming language 
compiler programmer want improve performance changing program evaluation order 
changing evaluation order may change exception encountered rst 
solution ban transformations restrict evaluations provably raise exceptions 
alternative propose trade precision performance permit richer transformations language semantics precise respect exception raised 
note imprecise exceptions programming language level due imprecise exceptions hardware level 
may prove ephemeral 
arise motivation permitting better optimization 
quite possible imprecise exceptions programming language level hardware level vice versa 
imprecise exceptions programming language level may easier implementations generate ecient code hardware imprecise exceptions 
concrete considering particular programming language haskell currently lacks exceptions 
contributions follows review critique folk lore lazy language haskell section 
non functional programmers may nd idea exceptions values opposed exceptions ow interesting 
new design sets exceptions model imprecision exceptions occur section 
sketch semantics resulting language layers denotational semantics pure expressions including exception raising ones operational semantics top deals exception handling input output section 
informed semantics show various extensions basic idea resource exhaustion interrupts readily accommodated pure exception handler troublesome section 
small proposals papers exception handling haskell 
distinctive feature focus semantics resulting language 
trick lies getting nice features exceptions eciency implicit propagation throwing baby bath water language design 
interested functional programming se may nd interesting development old idea exceptions values trade precision performance 
status quo ante haskell managed exceptions long time natural ask necessary appropriate 
brie explore question way setting scene rest 
worth identifying di erent ways exceptions typically languages support disaster recovery uses exception signal hopefully rare error condition division zero assertion failure 
language ml haskell may add pattern match failure function applied value de ning equation head empty list 
programmer usually raise exception primitive raise 
exception handler typically catches exceptions large chunk code performs kind recovery action 
exception handling way provides degree modularity part system protect failure part system 
alternative return 
exceptions alternative way return value function error condition necessarily implied 
example looking key nite map necessarily error key isn map languages support exceptions unusual see way 
exception handler typically catches exceptions relatively circumscribed chunk code serves mainly alternative continuation call 
asynchronous events 
languages asynchronous external event programmer typing timeout re ected programmer model exception 
call things asynchronous exceptions distinguish previous categories synchronous exceptions 
exceptions values lazy functional programming language far supported exceptions apparently persuasive reasons 
firstly lazy evaluation control ow 
evaluation demand driven expression evaluated value required 
result programs don readily predictable control ow productive way think expression consider value computes way value computed 
exceptions typically explained terms changes control ow exceptions lazy evaluation appear compatible 
secondly exceptions explicitly encoded values existing language exceptions case unnecessary 
example consider function takes integer argument returns integer raises exception 
encode haskell data ok bad exception int int defn 
data declaration says value type form bad ex ex type exception form ok val val type type signature declares returns result type int int exception value 
short exception encoded value returned consumer result forced willy rst perform case analysis case ok val normal case 
bad ex handle exception 
things approach extension language necessary type function clear raise exception type system impossible forget handle exception 
idea exceptions values old 
subsequently realised exception type constructor forms monad 
having lots ad hoc pattern matches ok bad standard monadic machinery haskell notation hide away plumbing 
inadequacies exceptions values encoding exceptions explicitly un modi ed language works beautifully alternative return usage exceptions badly disaster recovery asynchronous events 
distinct prob lems increased strictness 
adding exception handling lazy program easy accidentally program strict testing function argument errors passed 
excessive clutter 
principal feature exception mechanism exceptions propagate implicitly requiring extra clutter code place exception raised handled 
stark contrast explicit encoding approach forces intermediate code deal explicitly exceptional values 
resulting clutter absolutely intolerable situations exceptions signal disaster cases propagation required 
example originally written forced write case bad ex bad ex ok xv case bad ex bad ex ok yv ok xv yv apply exceptions alternative return mechanism 
case approach works beautifully propagation isn nearly important 
built exceptions un 
haskell causes failure recognised language divide zero pattern match failure treated semantically bottom treated practice bringing program halt 
haskell allows program trigger similar failure calling standard function error type error string evaluating call error halts execution printing standard error 
language ers way catch recover synchronous events 
serious problem writing programs composed large pieces little control just way recover failure sub component 
loss modularity code re especially higher order functions 
example sorting function takes comparison function argument need modi ed comparison function 
poor eciency 
exceptions cost little don occur 
alas explicit encoding haskell values forces test propagate call site substantial cost code size speed 
loss transformations 
programs written monadic style fewer transformations pure counterparts 
elaborate problem section 
asynchronous exceptions 
asynchronous exceptions nature value monadic version nearly bad 
unfortunate expression happens evaluation external event occurs 
arise external sources clearly dealt explicitly encoded value 
goals thoughts mind goals haskell programs don invoke exceptions unchanged semantics clutter run unchanged eciency 
transformations valid ordinary haskell programs valid language extended exceptions 
turns quite achieve goal reasons section 
possible reason exceptions program raise 
example hope able prove non recursive programs terminate programs don arithmetic raise division zero 
far non determinism arises possible programmer con ne non determinism clearly delineated part program 
properties may obvious little tricky achieve 
existing languages support exceptions ml ada need maintain exception semantics noticeably constrains valid set transformations optimisations programmer compiler perform 
compilers attempt infer set possible exceptions view lifting restrictions power inference limited example pessimistic module boundaries presence separate compilation 
claim design retains useful opportunities transformation monadic type system built haskell 
separate ect analysis required 
new design adding exceptions lazy language opposed encoding exceptions un extended language received relatively little attention 
hammond discussed adding exceptions pure non part lazy language activity 
drawing propose programming interface exceptions mechanism 
sets scene core semantics resulting language 
basic idea discussed section rst design decision forced fact haskell lazy language exceptions associated data values control ow 
di ers fundamentally standard approach exceptions taken imperative strict functional languages exceptions associated control ow data ow 
place exceptions values show imperative world number ieee oating point standard certain bit patterns encode exceptional values propagated oating point operations 
extend exceptions values idea uniformly values type 
value type normal value exceptional value 
exceptional value contains exception say data type exception type exceptions 
new algebraic data type supplied part haskell prelude de ned data exception overflow string 
imagine simpler type encoding exception integer string richer type user extensible data type provided ml useful compromise 
say depends exact choice constructors data type 
type new primitive function raise maps exception exceptional value type raise exception immediately see di erence approach 
type language contains values previously type possibility 
see exception type serves represent exception regardless type exception embedded 
previously primitive function error readily de ned raise error string error str raise str need able catch exceptions 
new primitive function getexception takes value determines exceptional value getexception ect getexception rei es implicit presence absence exception argument explicit discriminated union represented new prelude data type data ok bad exception example getexception case getexception ok val normal case val bad exn recovery case exn getexception catches exception raised evaluated presents result value type 
case expression value takes appropriate action 
see fundamental problem giving getexception type defer discussion point section 
propagation point exceptions course propagate automatically 
integer addition example deliver exceptional value arguments exceptional value 
lazy language re examine notion propagation 
particular exceptional value inside unevaluated function argument data structure 
example consider zipwith function zipwith zipwith xs ys zipwith xs ys zipwith xs ys error unequal lists call zipwith may return exception value directly example zipwith 
call zipwith may return list exception value example zipwith 
may deliver list spine fully de ned elements exceptional values example zipwith 
repeat values calls may exceptional exceptional values may example hide inside lazy data structures 
sure data structure contains exceptional values force evaluation elements structure done haskell built seq function 
implementation advantage story far readily cheaply implementable 
certainly want space time cost explicitly tagging value indication normal exceptional 
fortunately standard exception handling mechanisms procedural languages perfectly getexception forces evaluation argument head normal form begins evaluation marks evaluation stack way 
raise ex simply stack top getexception mark returns bad ex result getexception 
evaluation argument getexception completes provoking call raise getexception returns ok val val value argument 
matters quite simple suggest 
particular trimming stack call raise ex careful overwrite thunk evaluation raise ex 
way thunk evaluated exception raised details described need concern 
real implementations overwrite thunk black hole evaluation begun avoid celebrated space leak 
exception causes evaluation abandoned overwritten informative 
main point eciency programs invoke exceptions una ected 
eciency function invoke exceptions explicitly una ected 
notice exceptional value behaves rst class value explicitly represented 
exception occurs building value represents look exception handler right away 
semantic model exceptional values quite di erent implementation evaluation stacks stack trimming situation similar lazy evaluation value may behave nite list certainly explicitly represented 
problem solution known diculty approach just described invalidates useful transformations 
example integer addition commutative expression 
getexception error deliver 

known ways address problem shall adopt fix evaluation order part language semantics 
example semantics state evaluates rst argument rst rst argument exceptional exception returned 
common approach adopted ml fl proposals haskell 
gives rise simple semantics bad feature invalidates useful transformations particular ones alter order evaluation 
loss transformations serious weakness 
williams aiken wimmers give numerous examples presence exceptions seriously weaken transformation algebra strict language fl 
lazy language loss transformations catastrophe 
particular haskell compilers perform strictness analysis turn call need call value 
crucial transformation changes evaluation order evaluating function argument function called argument demanded 
remove transformations altogether optimising compilers perform variant effect analysis identify common case exceptions occur 
information enable invalid transformations 
williams aiken wimmers describe calculus language fl expresses absence exceptions special program annotation give precise characterisation transformation algebra augmented language 
approaches common useful transformations disabled sub expressions provably exception free 
go non deterministic 
declare non deterministic choice argument evaluate rst 
compiler free choice likes 
alas approach exposes non determinism source language invalidates useful laws 
particular reduction valid 
example consider error getexception getexception stands value expression presumably true 
occurrences replaced right hand side non deterministic principle di erent choice occurrences expression false 
count high price pay 
choice return exceptions 
rede ne exceptional value contain set exceptions just takes union exception sets arguments 
error returns exceptional value including semantically regardless order evaluates arguments 
beauty approach transformations remain valid presence exceptions section 
discusses 
analysis required 
fixing getexception allegedly choice may xed commutativity exceptional value contain set exceptions revisit question getexception 
possibilities 
alternative getexception return complete set exceptions argument value 
absolute disaster implementation point view 
mean implementation really maintain set exceptions rst argument failed second evaluated anyway exceptions gathered 
choice alternative getexception choose just member set exceptions return 
course simply exposes non determinism employ standard trick put getexception io monad 
give getexception type getexception io sense new de nition digress brie introduce haskell io monad 
haskell value type io computation perform input output eventually returning value type value type io rst class value passed arguments stored data structure evaluating side ects 
performed ect 
entire haskell program single value type io run program perform speci ed computation 
example complete haskell program gets character standard input echoes standard output main io main getchar ch putchar ch return types various functions involved follows io io io return io getchar io char putchar char io combinators io computations sequence passing result rst second 
return input output simply returning argument 
getchar gets character standard input returns putchar reverse 
main performed performs getchar reading character standard input performs computation obtained applying ch abstraction character case putchar ch 
complete discussion monadic 
return type getexception 
giving io type allow getexception perform input output 
choosing exceptions set choose getexception free absolutely required consult external oracle ft share index say 
call getexception di erent choice call getexception di erent runs program di erent choice 
beta reduction remains valid 
example meaning error getexception getexception return una ected occurrences replaced right hand side getexception error getexception error return 
substitution getexception performed twice making independent non deterministic choice time 
io computation getexception shared evaluated performing nondeterministic choice 
happens computation performed 
really nice thing approach implementation change 
set exceptions associated exceptional value represented single member exception happens encountered rst 
getexception works just mark evaluation stack evaluate argument 
successive runs program compiler optimisation level practice give behaviour program recompiled di erent optimisation settings order evaluation change di erent exception encountered rst haskell notation exception returned getexception change 
idea single representative stand set values non deterministic choice old hughes donnell 
contribution apply idea setting exception handling 
key observation non determinism exceptions kept separate non determinism normal values program 
semantics far reasoned informally 
section give precise semantics fragment haskell augmented exceptions 
diculties 
consider loop error loop expression evaluation diverges 
declared loop true loop error loop forever return exceptional value 
answer depends evaluation order 
case bottom waters 
equation true 
case case case case haskell answer going evaluate doesn matter order evaluate 
point strictness analysis gure things sure evaluated evaluated advance 
bound exceptional values order cases clearly determines exception encountered 
case far obvious combine exceptional value sets general right hand side case alternative depend variables bound pattern unpleasant semantics depend 
rest section gives denotational semantics haskell extended exceptions addresses problems 
solve rst identifying set possible exceptions solve semantically evaluating case alternatives exception nding mode 
domains describe domain associated haskell type standard monadic translation monad de ned 
overflow equation coalesced sum bottom element coalesced bottom element 
set set possible synchronous exceptions simplify semantics neglect string argument 
lattice subsets ordering bottom element set top element empty set 
corresponds idea fewer exceptions exceptional value information value contains 
informative value contains exceptions 
entire lattice lifted adding extra bottom element identify set exceptions rst distinguished set exceptions turns 
identify set exceptions adding new constructor nontermination exception type data exception 
nontermination construction 
standard semantic coding trick closely analogous canonical representation smyth powerdomain domain 
alternative perspicuous way de ne tag normal values ok exceptional values including bad fok tg wonder sort value bad fg exceptional value containing empty set exceptions 
value denotation term see shortly useful value de ning semantics case reasoning section 
constructed exception monad translate haskell types domains usual way int 

refrain giving complete encoding arbitrary recursive data types complicated 
point simply replace normal haskell monad lifting new monad variable constant application abstraction en constructors case matching raise raise exception primitives fix xpoint xn pattern syntax tiny language combinators give denotation meaning form language expression 

gives syntax small language treat 
denotation expression environment written 
start ok ok bad rst equation arguments normal values 
second argument exceptional value case exceptions arguments unioned 
auxiliary function returns empty set normal value set exceptions exceptional value ok bad auxiliary function simply addition checking ow ok bad de nition monotonic respect 
fact strict arguments consequence fact set exceptions moment thought convince argument result 
deal raise raise bad bad bad fcg ok equipped understand semantics problematic expression loop error meaning union set exceptions value loop singleton set course just set exceptions 
rules function abstraction application ok ok bad bad lambda abstraction normal value 

identi cation values impossible implement getexception distinguish 

fortunately haskell 
distinct values 
applying normal function value straightforward matters interesting function exceptional value 
case union exception set argument circumstances notably function strict legitimately evaluate argument rst neglected union argument exceptions semantics allow standard optimisation 
simpler de nition ok bad bad traded transformations precision 
notice union argument exceptions function normal value lose reduction consider rules constants constructor applications simple return normal values 
constructors nonstrict propagate exceptions arguments 
variables xpoints easy 
ok en ok fix case expressions haskell contains case expressions give semantics 
slightly surprising rule case ok matches bad bad fg bad rst case usual case scrutinee evaluates normal value select appropriate case alternative 
notation little informal means environment free variables pattern bound appropriate components second equation interesting 
scrutinee turns set exceptions recall includes obvious thing return just set doing invalidate case switching transformation 
intuitively semantics explore ways implementation deliver exception evaluate branches anyway exception nding mode 
model denotations right hand sides binding pattern bound variables strange value bad fg 
union exception sets result exception set scrutinee 
idea exactly special case function application rst argument raises exception union exceptions second argument 
case scrutinee raises exception union exceptions alternatives 
remember implication implementation return rst exception happens encountered 
curious semantics validate transformations change order evaluation section 
semantics getexception far mentioned getexception 
semantics operations io monad getexception may involve input output non determinism 
straightforward way modelling aspects giving operational semantics io layer contrast denotational semantics purely functional layer 
give operational semantics follows 
semantic point view regard io algebraic data type constructors return putchar getchar getexception 
behaviour program set traces obtained labelled transition system acts denotation program 
advantage presentation scales extensions adding concurrency language 
structural transition rules 
return 
rst ensures transitions occur inside rst operand constructor second explains return constructor just passes value second argument enclosing 
rules input output quite simple getchar return putchar return top arrow indicates transition takes place reading character environment inversely 
get semantics exceptions 
rules getexception ok return ok ok getexception bad return bad getexception bad getexception bad nontermination getexception normal value just returns wrapped ok constructor 
exceptional values choices pick arbitrary member set exceptions return nontermination set exceptions transition state 
transition rules getexception deliberately nondeterministic 
particular argument getexception getexception may diverge may return arbitrary exception 
execute haskell program performs computation main type io 
presence exceptions value returned bad ok 
simply corresponds uncaught exception implementation report 
transformations goal add exceptions haskell losing useful transformations 
true lose transformations 
example haskell stands equation holds error error 
semantically equal 
semantics equality longer holds rightly 
semantics correctly distinguishes expressions haskell currently identi es 
transformations identities haskell re nements new system 
consider lhs case true false rhs case true false raise raise get lhs bad fe xg rhs bad feg 
lhs rhs lhs rhs 
argue legitimate perform transformation increases information case changing lhs rhs reduces uncertainty exceptions raised 
currently lack systematic way say identities continue hold turn re nements longer hold 
conjecture lost laws deserve lost optimising transformations identities re nements 
interesting try formalise prove conjecture 
variations theme asynchronous exceptions exceptions discussed far synchronous exceptions section 
evaluation expression yields set synchronous exceptions evaluation expression yield set 
asynchronous exceptions interrupts resource related failures timeout stack ow heap exhaustion 
di er synchronous exceptions recur program run 
obviously inappropriate regard exceptions part denotation expression 
fortunately general framework 
enrich exception type constructors indicating cause exception 
simply add getexception abilities 
getexception io monad easily say evaluation argument goes long terminate evaluation return bad timeout similarly interrupts 
express formally follows getexception return bad asynchronous exception arrow indicates transition may take place asynchronous event received evaluator 
notice exceptional value say event received getexception free discard return asynchronous exception 
case keyboard interrupt event injected case timeout presumed external monitoring system injects event timeout evaluation takes long 
fascinating implementation asynchronous exceptions trimming stack overwrite thunk evaluation kind continuation computation raises exception 
details 
detectable bottoms sorts divergence detectable compiler runtime system 
example suppose black declared black black black readily detected called black hole graph reduction implementations 
circumstances getexception black permitted required return bad nontermination going loop 
implementation choice implementations compete skill detect errors 
fictitious exceptions continuum semantics xed evaluation order semantics fully determines exception raised 
moves spectrum proposal compiler transformations valid price pay 
price semantics exceptions raised non termination occur 
view optimise exception case accepting go wrong program semantics guarantee precisely exception show 
extreme slightly troubling case getexception loop loop value getexception semantics justi ed returning bad quite ctitious exception principle compiler re nement 
sought way give loop denotation bad informative know consistent way 
modelling non termination include behaviours characteristic denotational semantics non determinism 
means set inclusion gives simple interpretation program correctness encompassing safety liveness properties 
ensures recursion de ned weakest xed point monotonic function xed point computed limit set wise descending chain approximations 
important purposes gives maximal freedom compiler assuming non termination programmer intends operational semantics model precisely happens su er problem ctitious exceptions 
arguably reasoning divergent programs programmer operational semantics anyway 
compiler report ctitious exception program gets loop semantic technicality practical consequences 
pure functions exceptional values possible exceptional value choose exception getexception 
possibility suggests new primitive function de nable primitives far described exception exception number situations useful able assume value 
example law holds case true false compiler ag bottoms enables transformations exchange programmer undertaking proof obligation sub expression program value 
semantically applies functional argument member set exceptions second argument normal values 
implementation point view applies function sole representative set 
example catch exceptions raise notice need io monad preserve determinism 
short raises new technical di culties usefulness desirability debatable 
maps kind exception doesn get exceptions back normal values 
possible go 
possible example ask exceptional value 
bool easy de ne monadic type io bool question pure non monadic type 
rst looks reasonable hides just exception raised turns problematic 
value expression 
loop compiler evaluates rst argument rst result true compiler evaluates second argument rst computation terminate 
di erent implementations delivered di erent values 
quite possible give perfectly respectable denotational semantics fact di erent semantics optimistic bad true ok false pessimistic bad nontermination bad true nontermination ok false trouble semantics eciently implementable require implementation detect nontermination 
consider example loop implementation evaluates arguments left evaluate loop call loop evaluate returning true optimistic semantics requires 
conversely implementation evaluates arguments left right evaluate loop call return true pessimistic semantics requires 
want implementations able evaluate arguments order optimistic pessimistic semantics 
number possible things say 
banned 

programmers may undertake proof obligation argument 
assumed implementation diculty section 

denotational semantics pessimistic implementable language semantics changed result program de ned value de ned program denotation 
program yields value delivered 
alternative undesirable property program goes nite loop justi ed returning io computation say deleted entire 

denotational semantics optimistic implementable language semantics changed result program de ned value de ned program denotation 
valid result 
alternative undesirable property implementation theory abort error message fail terminate program including programs 
comparison previous alternative failure mode severe semantics allow implementation loop abort perform arbitrary operations 
options require signi cant global change haskell semantics really captures intended behaviour sucient precision 
possible re ne approaches give precision cost additional semantic complexity 
prefer second option renaming highlight proof obligation 
declarative languages particularly logic programming languages odel mercury distinction declarative denotational semantics operational semantics similar mentioned fourth possibility 
mercury example operational semantics allows non termination situations declarative semantics speci es program result nontermination 
proposal haskell adopted languages operational semantics incomplete sense respect declarative semantics re nement fourth alternative best approach 
languages described design incorporating exceptions haskell 
section brie relate design languages 
clear design somewhat expressive languages take ml typical example 
ml completely encapsulate function exceptions declare exception locally raise handle implementation visible function caller 
design handle exception io monad 
furthermore io monad design trap door encapsulate performing computation inside pure function rightly 
experience exceptions haskell speculate fact getexception io monad prove awkward practice reasons exception handling getexception ected 
raise exception involving io monad 
disaster recovery exception handling done near top program input output case performed 
local exception handling done encoding exceptions explicit values section 
doubt remain situations lack pure getexception prove annoying 
alternative provide analogous section associated proof obligations programmer 
second big payo approach lose useful transformations compared free program 
technique languages ml java 
hard see apply directly approach depends crucially distinguishing computations io monad transformations restricted possibility side effects non determinism purely functional expressions transformations unrestricted 
standard ect analyses ml java seek nd portions program raise exception system transformations limited parts program handle exceptions 
speculate ect system focused yield scope optimisation 
directly address question exception raising behaviour function manifested type 
java requires methods declare checked exceptions may throw approach scale higher order languages 
design explicitly encoded exceptions certainly manifested function type exceptions generated raise 
usual implementation ahead theory glasgow haskell compiler implements raise getexception just described 
hidden implementation traps 
useful practical outcome writing clear idea semantically justi able programming interface 
example originally implemented version fully understanding impact semantics 
know feature require signi cant haskell semantics may acceptable haskell programmers added due consideration 
incidentally exceptions io monad handled way implementation io monad ecient greedy code space 
previously operation test propagate exceptions 
experience exceptions haskell 
proof eating 
bon 

gratefully acknowledge helpful feedback cedric fournet corin pitcher nick benton pldi referees 
augustsson 
generating unique names 
journal functional programming january 
hammond 
exception handling lazy functional languages 
technical report cs department computing science university glasgow jan 
henderson 
non deterministic exceptions 
electronic mail haskell mailing list june 
henderson conway somogyi je ery 
mercury language manual 
technical report department computer science university melbourne melbourne australia 
version available html 
jones 
tail recursion space leaks 
journal functional programming jan 
moggi 
computational lambda calculus monads 
ieee symposium logic computer science june 
mycroft 
theory practice transforming call need call value 
proc th international symposium programming pages 
springer verlag lncs 
leroy 
type analysis uncaught exceptions 
proc principles programming languages popl san antonio jan 
pl wadler 
comprehending monads 
mathematical structures computer science 
pl wadler 
replace failure list successes 
proc functional programming languages computer architecture la jolla 
acm june 
plotkin 
domains 
technical report department computer science university edinburgh 
reid 
handling exceptions haskell 
research report yaleu dcs rr yale university august 
reid 
putting spine back spineless tagless machine implementation black holes 
proc implementation functional languages workshop ifl 
springer verlag lncs appear sept 
hughes :10.1.1.100.8004
functional programming matters 
computer journal april 
hughes jt donnell 
expressing reasoning non deterministic functional programs 
davis hughes editors glasgow functional programming workshop pages 
springer workshops computing 
sl peyton jones aj gordon finne :10.1.1.30.8705
concurrent haskell 
rd acm symposium principles programming languages st petersburg beach florida pages 
acm jan 
sl peyton jones pl wadler 
imperative functional programming 
th acm symposium principles programming languages popl charleston pages 
acm jan 
spivey 
functional theory exceptions 
science computer programming jul 
william aiken wimmers 
program transformation presence errors 
proc principles programming languages popl san francisco pages 
acm jan 
wj cody proposed radix word length independent standard oating point arithmetic 
ieee micro aug 

