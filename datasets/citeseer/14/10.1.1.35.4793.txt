survey distributed file systems satyanarayanan department computer science carnegie mellon university february survey current state art design implementation distributed file systems 
consists major parts overview background material case studies number contemporary file systems identification key design techniques examination current research issues 
systems surveyed sun nfs apollo domain andrew ibm aix ds rfs sprite 
coverage background material includes taxonomy file system issues brief history distributed file systems summary empirical research file properties 
comprehensive bibliography forms important 
copyright satyanarayanan author supported writing national science foundation contract 
ccr defense advanced research projects agency order contract ibm faculty development award 
views document author represent official policies funding agencies carnegie mellon university 

sharing data distributed systems common pervasive systems grow scale importance 
user distributed system potentially creator consumer data 
user may wish actions contingent information remote site may wish update remote information 
physical movement user may require data accessible 
scenarios ease data sharing considerably enhances value distributed system community users 
challenge provide functionality secure reliable efficient usable manner independent size complexity distributed system 
survey current state art design distributed file systems widely class mechanisms sharing data 
consists major parts brief survey background material case studies number contemporary file systems identification key design techniques today examination research issues challenge decade 

background examining basic abstraction realized file systems proceed develop taxonomy issues design 
section traces origin development distributed file systems middle current decade systems described section came 
sizeable body empirical data file usage properties available today 
section summarizes observations shows influenced design distributed file systems 

basic issues permanent storage fundamental abstraction computing 
consists named set objects come existence explicit creation immune temporary failures system persist explicitly destroyed 
naming structure characteristics objects set operations associated characterize specific refinement basic abstraction 
file system refinement 
perspective file system design computing models classified levels 
set design issues level subsumes lower levels 
consequently implementation file system higher level sophisticated adequate lower level 
lowest level exemplified ibm pc dos apple macintosh user single site performs computations single process 
file system model address key issues 
include naming structure file system application programming interface mapping file system abstraction physical storage media integrity file system power hardware media software failures 
level exemplified os involves single user computing multiple processes site 
concurrency control important consideration programming interface implementation file system 
survey bernstein goodman treats issue depth 
classic timesharing model multiple users share data resources constitutes third level taxonomy 
mechanisms enforce security important 
unix archetype timesharing file system 
distributed file systems constitute highest level taxonomy 
multiple users physically dispersed network autonomous computers share common file system 
useful way view system think distributed implementation timesharing file system abstraction 
challenge realizing abstraction efficient secure robust manner 
addition issues file location availability assume significance 
simplest approach file location embed location information names 
examples approach newcastle connection cedar vax vms 
static binding name location inconvenient move files sites 
requires users remember machine names difficult feat large distributed environment 
better approach location transparency name file devoid location information 
explicit file location mechanism dynamically maps file names storage sites 
availability special significance usage site data different storage site 
failure modes substantially complex distributed environment 
replication basic technique achieve high availability introduces complications 
multiple copies file changes propagated replicas 
propagation done consistent efficient manner 

evolution user initiated file transfer earliest form remote file access 
inconvenient limited functionality served important mechanism sharing data early days distributed computing 
ifs alto personal computers file repository arpanet exemplify approach 
major step evolution distributed file systems recognition access remote file resemble access local files 
property called network transparency implies operation performed local file may performed remote file 
extent actual implementation meets ideal important measure quality 
newcastle connection early examples systems provided network transparency 
cases name remote site prefix remote file name 
decade saw profusion experimental file systems 
examines comparative survey 
systems felix xdfs alpine swallow amoeba explored issues atomic transactions concurrency control remote files 
cambridge file system cmu cfs file system examined naming structure distributed file system separated function permanent storage repository 
addressed access control caching transparent file migration archival media 
cedar file system practically demonstrate viability caching entire files 
design decisions motivated intended application base program development 
locus landmark system important ways 
identified location transparency important design criterion 
second proposed replication mechanism detecting inconsistency achieve high availability 
locus provided support atomic transactions files generalized notion transparent remote access aspects operating system 
weighted voting alternative way replication availability demonstrated violet 
rapid decline cpu memory costs motivated research workstations local disks permanent storage media 
system disk server exports low level interface emulates local disk operations 
diskless operation successfully demonstrated systems 
lazowska depth analysis performance diskless workstations 
diskless operation impacts autonomy scalability availability security viewed fundamental design constraint 
remains seen considerations continuing improvements disk technology eventually outweigh cost benefits diskless operation 
distributed file systems widespread today 
section describes prominent systems 
major vendor supports distributed file system users view indispensable component 
process evolution far complete 
elaborated section decade see significant improvements functionality usability performance distributed file systems 

empirical observations substantial amount empirical investigation classic scientific mold done file systems 
results guide high level design determine values system parameters 
example data file sizes efficient mapping files disk storage blocks 
information frequency different file operations degree read write sharing files influenced design caching algorithms 
type specific file information useful file placement design replication mechanisms 
empirical file systems involves practical difficulties 
instrumentation usually requires modifications operating system 
addition impact system performance minimally 
total volume data generated usually large needs stored processed efficiently 
addition difficulty collecting data basic concerns interpretation 
generality concerns 
specific observations system observed 
data widespread applicability obviously value 
independent investigations variety academic research environments 
systems examined include ibm mvs dec pdp unix 
studies differ details substantial overlap set issues investigate 
results exhibit serious contradictions 
confidence understanding file system characteristics academic research environments 
unfortunately little publicly available information kinds environments 
second concern relates interdependency design empirical observations 
observed properties artifact existing system design intrinsic 
little known influence system design file properties existence influence undeniable 
example design uses file transfer substantial creation large files 
long run may affect observed file size distribution 
important revalidate understanding file properties new systems built existing systems mature 
studies file systems fall broad categories 
early studies static analysis snapshots file system 
data studies unweighted 
studies dynamic analysis continuous monitoring file system 
data weighted frequency file usage 
studies done timesharing file systems results assumed hold distributed file systems 
premise user behavior programming environment characteristics primary factors influencing file properties 
assumption factors changes significantly moving distributed environment 
studies done validate assumptions 
consistent observation studies skewing file sizes low 
words files small typically neighborhood kilobytes 
common observation read operations files frequent write operations 
random accessing file rare 
typical application program sequentially reads entire file address space performs nonsequential processing memory data 
related observation file usually read entirety opened 
averaged files system data appears highly mutable 
functional lifetime file defined time interval read write skewed low 
words data files tends overwritten 
mean functional lifetime small tail distribution long indicating existence files long lived data 
files read written user 
users share file usually case modifies 
fine granularity read write sharing files rare 
important emphasize observations derived research academic environments 
environment large collaborative projects extensive databases may show substantially greater write sharing data 
file show substantial temporal locality 
file referenced high probability referenced near 
short periods time set referenced files small subset files 
characteristics described apply file population 
focus files specific type properties may differ significantly 
example system programs tend stable rarely modified 
consequently average functional lifetime system programs larger average files 
temporary files hand show substantially shorter lifetimes 
fine grained classification files possible demonstrated investigations mentioned earlier 

case studies section examine distributed file systems widely today focusing design goals naming location mechanisms replication caching support provide security system management 
due constraints space provide sufficient detail highlight differences similarities designs 
addition touch noteworthy features contemporary file systems section 

sun network file system 
design considerations sun microsystems network file system nfs widely industry academia 
addition technical innovations played significant educational role exposing large number users benefits distributed file system 
vendors support nfs significant fraction user community perceives de facto standard 
portability heterogeneity considerations played dominant role design nfs 
original file system model unix nfs ported non unix operating systems pc dos 
facilitate portability sun careful distinction nfs protocol specific implementation nfs server client 
nfs protocol defines rpc interface allows server export local files remote access 
protocol specify server implement interface mandate interface client 
design details caching replication naming consistency guarantees may vary considerably different nfs implementations 
order focus discussion restrict attention implementation nfs provided sun workstations run sunos flavor unix 
specified term nfs refer implementation rest 
term nfs protocol continue refer generic interface specification 
sunos defines level indirection kernel allows file system operations intercepted transparently routed variety local remote file systems 
interface referred vnode interface primary data structure exports incorporated versions unix 
view simplifying crash recovery servers nfs protocol designed stateless 
consequently servers required maintain contextual information clients 
rpc request client contains information needed satisfy request 
degree functionality unix compatibility sacrificed meet goal 
locking instance supported nfs protocol locks constitute state information server 
sunos provide separate lock server perform function 
sun workstations configured local disk 
ability operate workstations significant performance degradation goal nfs 
early versions sun workstations separate remote disk network protocol support diskless operation 
protocol longer necessary kernel transforms device operations file operations 
high level overview nfs walsh 
details design implementation sandberg 
kleiman describes vnode interface rosen comment portability nfs 

naming location nfs paradigm treats workstations peers fundamental distinction clients servers 
workstation may server exporting files 
may client accessing files workstations 
common practice installations configured small number nodes run dedicated servers run clients 
nfs clients usually configured sees unix file name space private root 
extension unix mount mechanism subtrees exported nfs servers individually bound nodes root file system 
binding usually occurs unix initialized remains effect explicitly modified 
workstation free configure name space guarantee workstations installation common view shared files 
collaborating groups users usually configure workstations name space 
location transparency obtained convention basic architectural feature nfs 
name site bindings static nfs require dynamic file location mechanism 
client maintains table mapping remote subtrees servers 
addition new servers movement files servers renders table obsolete 
mechanism built nfs propagate information changes 

caching replication nfs clients cache individual pages remote files directories main memory 
cache results pathname vnode translations 
local disks caching 
client caches block file caches timestamp indicating file modified server 
validate cached blocks file client compares cached timestamp timestamp server 
server timestamp client invalidates cached blocks file demand 
validation check performed file opened server contacted satisfy cache check cached blocks assumed valid finite interval time specified client remote file system mounted 
block file interval forces validation check 
cached page modified marked dirty scheduled flushed server 
actual flushing performed asynchronous kernel activity occur unspecified delay 
kernel provide guarantee dirty pages file flushed server close operation file completes 
directories cached reading manner similar files 
modifications directories performed directly server 
file opened cache validation check performed parent directory 
files directories different revalidation intervals typical values seconds files seconds directories 
nfs performs network data transfers large block sizes typically kbytes improve performance 
read ahead employed improve sequential access performance 
files corresponding executable binaries fetched entirety smaller certain threshold 
originally specified nfs support data replication 
versions nfs support replication mechanism called automounter 
automounter allows remote mount points specified set servers single server 
time client traverses mount point request issued server earliest respond chosen remote mount site 
requests client cross mount point directed server 
propagation modifications replicas done manually 
replication mechanism intended primarily frequently read rarely written files system binaries 

security nfs uses underlying unix file protection mechanism servers access checks 
rpc request client conveys identity user behalf request 
server temporarily assumes identity file accesses occur servicing request checked exactly user logged directly server 
standard unix protection mechanism user group world mode bits specify protection policies individual files directories 
early versions nfs mutual trust assumed participating machines 
identity user determined client machine accepted validation server 
level security nfs site effectively secure system environment 
reduce vulnerability requests behalf root unix superuser workstation treated server come non existent user 
root received lowest level privileges remote files 
versions nfs configured provide higher level security 
des mutual authentication validate client server rpc request 
file data rpc packets encrypted nfs vulnerable unauthorized release modification information network physically secure 
common des key needed mutual authentication obtained information stored publicly readable database 
stored database user server pair keys suitable public key encryption 
key pair stored clear stored encrypted login password user 
entities registered database deduce unique des key mutual authentication 
taylor describes details mechanism 

system management sun provides mechanisms assist system managers 
yellow pages yp mechanism maintaining key value pairs 
keys values application specific interpreted yp 
number unix databases mapping usernames passwords hostnames network addresses network services internet port numbers stored yp 
yp provides read replication master slaves 
lookups may performed replica 
updates performed master responsible propagating changes slaves 
yp provides shared repository system information changes relatively infrequently require simultaneous updates replication sites 
yp usually nfs installations mandatory 
automounter mentioned section context read replication mechanism simplifying system management 
allows client lazy evaluate nfs mount points avoiding need mount remote files interest client initialized 
automounter conjunction yp substantially simplify administrative overheads server reconfiguration 

apollo domain file system 
design considerations domain system built apollo computers distributed workstation environment development began early 
goal system provide usable efficient computing base close knit team collaborating individuals 
scale dominant design consideration large apollo installations exist 
largest located apollo corporate headquarters encompasses nodes 
apollo workstations range hardware capability small diskless units large configurations disks peripherals 
underlying network technology proprietary mbit token ring 
installations may choose treat nodes dedicated servers run system software nodes clients performing user computations 
dichotomy matter convention 
domain software treats nodes peers 
domain provides support distribution typed files object storage system oss 
system wide single level store sls provides mapped virtual memory interface objects built top oss 
domain distributed file system layered sls presents unix file interface application programs 
facility called open systems toolkit uses file typing mechanism oss create extensible system 
users write non kernel code interpret operations 
file opened type determined code implementing operations type object dynamically loaded system 
levine presents design rationale domain file system 
goals include location transparency data consistency system enforced uniform naming scheme uniform mechanism access control 
full functionality performance ease administration stated goals domain 
addition survey levine papers file system architecture object oriented development tool distributed applications user registry 

naming location object system uniquely named bit identifier called uid 
apollo workstation unique node identifier time manufacture 
identifier forms component uid object created workstation 
time object created forms component 
components guarantee uniqueness uids 
location specific information uids violate goal location transparency sole function guarantee uniqueness 
instant time object home node associated 
oss maps objects homes hint server 
name implies hint server performs mapping number heuristics 
updated normal system operation diverse components domain software discover location objects 
heuristic frequently successful assume objects created node located 
distributed naming server maps string names uids built top oss 
server provides hierarchical unix location transparent name space files directories system 
directories domain merely objects map name components uids 
network wide root directory name space implemented replicated distributed database server instance site replica 
naming facility source hints hint manager objects located parent directory 

caching replication domain system transparently caches data attributes objects usage node 
mapped virtual memory accesses sls interface file accesses file system interface translated object oss level 
manages cache individual pages objects write back scheme periodic flushing data home objects 
timestamp associated object indicating time home node modified 
cached page object contains timestamp 
consistency locally cached data pages verified comparing timestamps timestamp object home node 
invalid pages merely discarded 
course object missing pages obtained demand paging network home node 
fetch ahead currently kb improve sequential access performance 
cache management domain integrated concurrency control mechanisms 
node runs lock manager synchronizes accesses objects home node 
modes locking supported 
mode allows multiple distributed readers single writer access object 
mode allows access multiple readers writers located single node 
lock managers queue requests 
lock object granted immediately requesting node periodically retry request 
cache validation performed object locked 
write lock object released implicit purify operation performed 
operation atomically flushes updated pages object home node 
application software responsible ensuring objects locked mapped virtual memory opened file access 
responsible releasing locks appropriate 
domain support read read write replication data 
object home instant time 
replicated services replicated user registry replicated naming service supported domain 

security security domain predicated physical integrity apollo workstations trustworthiness kernels 
network assumed secure communications sent clear 
network component kernel node uses special field header packet indicate originator packet user level program kernel 
prevents user level programs masquerading trusted system software 
distributed user registry stores user login password encrypted form unix 
user logs node local kernel encrypts password typed user fetches login entry registry validates user comparing encrypted passwords 
instance logged user associated unique identifier called identifies user project organization belongs node login instance occurred 
access checks behalf logged instance user 
nodes cache registry information enhance availability 
user registry called replicated database master site multiple read slaves availability 
replica contains entries users system 
updates master site propagates asynchronously slave sites 
direct authentication master authentication handshake required update performed 
protection policies specified access lists objects 
access list entry maps set rights 
components 
multiple entries applicable access check specific matching entry overrides 
checking access done home node objects releases domain usage node releases 
logically equivalent kernels trust 

system management concern ease administration important influence design domain user registry described previous section 
design allows multiple mutually suspicious groups single registry system management information 
group distinct system administrator person manipulate entries pertaining group 
decentralized administration specification usage policies effectively supported mechanism 
registry supports heterogeneity initially form client interface sun workstations 
interactive tool provides structured interface registry 
possesses substantial semantic knowledge contents registry guides administrators 
detects notifies administrators potentially serious side effects actions 

andrew file system 
design considerations andrew distributed workstation environment development carnegie mellon university 
combines rich user interface characteristic personal computing data sharing simplicity timesharing 
primary data sharing mechanism distributed file system spanning workstations 
set trusted servers collectively called vice andrew file system presents homogeneous file name space workstations 
clients servers run bsd version unix 
relatively heavyweight operation configure machine andrew server 
contrast systems sun nfs trivial machine export subset local file system 
scalability dominant design consideration andrew 
design decisions andrew influenced anticipated final size nodes careful design necessary provide performance large scale facilitate system administration 
scale renders security serious concern enforced left user community 
goals directions andrew project described morris 
file system discussed extensively papers focusing architecture performance security influence scale 
andrew file system undergone complete revision second revision way 

naming location file name space andrew workstation partitioned shared local name space 
shared name space location transparent identical workstations 
local name space unique workstation relatively small 
contains temporary files files needed workstation initialization 
users see consistent image data move workstation files shared name space 
name spaces hierarchically structured unix 
shared name space partitioned disjoint subtrees subtree assigned single server called 
assignment relatively static reassignment operational reasons possible 
internally andrew uses bit file identifiers uniquely identify files 
identifiers visible application programs 
server contains copy fully replicated location database maps files 
database relatively small subtrees individual files 
temporary inaccuracies database harmless forwarding information left data moved server 

caching replication files shared name space cached demand local disks workstations 
cache manager called venus runs workstation 
file opened venus checks cache presence valid copy 
copy exists open request treated local file open 
date copy fetched 
read write operations open file directed cached copy 
network traffic generated requests 
cached file modified copied back file closed 
cache consistency maintained mechanism called callback 
file cached server note fact promises inform client file updated 
callbacks may broken client server 
callback checking open substantially reduces client server interactions 
mechanism version andrew 
andrew caches large chunks files reduce client server interactions exploit bulk data transfer protocols 
earlier versions andrew cached entire files 
mechanism orthogonal caching read replication data frequently read rarely modified 
done enhance availability evenly distribute server load 
subtrees contain data may read replicas multiple servers 
read write replica updates directed 
propagation changes read replicas done explicit operational procedure 
concurrency control provided andrew emulation unix flock system call 
lock unlock operations file performed directly 
client release lock minutes timed server 

security design andrew pays serious attention security ensuring mechanisms enforcing inhibit legitimate system 
security predicated integrity small number vice servers 
servers physically secure accessible trusted operators run trusted system software 
network workstations trusted vice 
authentication secure transmission mechanisms encryption provide secure access servers workstations 
responsibility user ensure compromised malicious software workstation 
protect trojan horse attacks concerned user maintain physical integrity workstation deny remote access network 
protection domain andrew composed users corresponding human users groups sets users groups 
membership group inherited user accumulates privileges groups belongs directly indirectly 
inheritance membership simplifies maintenance administration protection domain 
membership special group called system administrators endows administrative privileges including unrestricted access file system 
andrew uses access list mechanism protection 
total rights specified user union rights collectively specified groups direct indirect member 
access list specify negative rights 
entry negative rights list indicates denial specified rights denial overriding possession case conflict 
negative rights intended primarily means rapidly selectively revoking access critical files directories 
conceptual simplicity vice associates access lists directories files 
access list applies files directory giving uniform protection status 
addition owner bits unix file mode indicate readability executability 
andrew bits indicate done file 
reasons compatibility andrew replace original authentication system kerberos authentication system project athena 
resemble closely architecture differ substantially details 
step authentication scheme 
user logs workstation password establish secure communication channel authentication server 
pair authentication tokens case andrew authentication ticket case kerberos obtained authentication server saved 
needed establish secure rpc connections behalf user individual file servers 
authentication server run trusted machine systems 
robustness multiple instances server 
server master accepts updates 
slaves respond queries 
changes propagated slaves master 

system management operability major concern andrew account scale 
system easy small staff run administer 
regular operational procedures performed manner cause minimal disruption service users 
operational mechanisms andrew built data structuring primitive called volume 
volume collection files forming partial subtree vice name space having 
volumes glued mount points form complete name space 
usually volume user number volumes containing system software 
volume sizes usually small allow volumes disk partition server 
disk storage quotas applied volume basis 
operations moving volume server performed volume online 
read replica volume created clone operation 
replicas improve availability performance 
read volumes implement orderly release process system software 
volumes form basis backup restoration mechanism 
backup volume frozen snapshot files created cloning 
asynchronous mechanism transfers clone staging machine dumped tape 
handle common case accidental deletion users cloned backup volume user files available read subtree vice 
andrew extended allow decentralized operation 
cooperating group cells adhering standardized set protocols naming conventions jointly provide image single file name space 
cross cell authentication translation user identities different administrative domains key issues addressed mechanism 

contemporary systems systems described section important widely occupies unique position space distributed file system designs 
interests brevity condensed descriptions distinctive aspects systems 

ibm aix distributed services name aix distributed services ds collection distributed system services developed ibm workstations running aix operating system 
aix derivative system version unix 
primary component ds distributed file system design goals include strict emulation unix semantics ability efficiently support databases ease administering wide range ds installation configurations 
ds client access remote files extension unix mount mechanism 
ds allows individual files directories mounted contrast distributed file systems allow mounts granularity entire subtree 
server explicitly export advertise files wishes share 
files assumed remotely accessible subject access checks 
file system operations behave identically local remote files 
significant exceptions inability access remote devices inability map remote files address space process 
restriction removed release ds 
ds uses client main memory write cache individual pages files 
clients notify servers open file reading writing 
behavior caching mechanism depends read mode clients reading clients writing async mode client reading writing full sync mode multiple clients writing 
read mode caching enabled clients 
async mode caching enabled writer sites directing read requests server 
client caching disabled full sync mode 
cache consistency maintained mechanism reminiscent andrew callback mechanism 
server aware remote opens files keep track clients opened file time modified 
accepting open modification notifies list clients invalidate pages file caches 
ds uses virtual circuit communication sna lu protocol 
versions ds able run tcp ip protocol 
node node des mutual authentication provided part lu implementation 
users groups bit network wide ids 
ds translates network ids unix compatible bit ids 
kerberos authentication mechanism supported option 
sauer levitt describe design ds 
sauer presents detailed description fine granularity mount mechanism 
sauer discuss rationale maintaining client state servers aspects ds avoiding state aspects 

remote file sharing remote file sharing rfs distributed file system developed system version unix derived earlier implementation unix edition 
distinctive feature rfs precise emulation local unix semantics remote files 
operation remote file indistinguishable corresponding operation local file 
aspect rfs extends areas concurrency control semantics ability access control remote devices 
rfs uses client server model virtual circuit communication unix system streams provide easy portability variety transport protocols 
server advertises subtree wishes export network wide symbolic name root subtree 
clients explicitly import remote subtrees symbolic names 
name server performs translation symbolic names server addresses 
accuracy unix system call emulation achieved executing remote file system calls server 
client merely intercepts forwards calls server 
exact execution environment client recreated server duration call information passed client request 
initial version rfs caching 
extended provide caching client main memory retaining exact emulation unix semantics 
caching simple files directories devices 
cache write consistency checked opens 
single writer multiple readers caching disabled readers 
caching writer closes file time interval modification writer exceeds predefined threshold 
caching system disabled multiple writers 
rfs clients servers trust 
protection files directories specified exactly unix 
mechanism map user group identities allows files shared administrative domains 
rfs provides mechanism restrict privileges remote users coarse granularity 
rationale architecture implementation rfs described rifkin 
bach describe rfs extended incorporate caching 
shows rfs coexist sun nfs vnode interface 
comparison sun nfs rfs hatch 

sprite network file system sprite operating system networked uniprocessor multiprocessor workstations designed university california berkeley 
goals sprite include efficient large main memories support multiprocessor workstations efficient network communication diskless operation 
distributed file system sprite provides distributed system facilities process migration 
workstations sprite network diskless 
design sprite rigid distinction clients servers machines disks usually dedicated file servers 
servers jointly location transparent unix file system interface clients 
clients explicitly import files individual servers 
server respond location queries remote links embedded file system server 
remote links effectively pointers files servers 
client maintains local prefix table maps pathname prefixes servers 
substantial performance improvement achieved cached information prefix table locating files 
sprite intended collection collaborating users incapable subverting kernels workstations trust 
consequently sprite kernels trust communication authenticated encrypted 
exact emulation unix file system semantics important goal sprite 
client opens closes file reading writing notifies server stores file 
sprite client usually caches pages file validating pages time file opened 
caching disabled multiple clients file open clients open writing 
caching disabled clients concurrently file closed 
strategy enables sprite provide consistency granularity individual read write operations 
sprite provides location transparent remote access devices files 
provide performance wide variety workloads physical memory sprite workstation dynamically partitioned virtual memory subsystem file cache 
sprite uses ordinary file shared name space paging simplifies process migration backing files visible sprite workstations environment 
ousterhout provide overview sprite 
welch ousterhout describe prefix mechanism file location 
detailed performance analysis caching sprite nelson 

mechanisms techniques purpose section highlight discuss certain mechanisms significant value design distributed file systems 
mechanisms general applicability mount points unix specific 
mount points widely majority distributed file systems time unix 
dominance unix file system model remarkable 

mount points mount mechanism unix enables glueing file name spaces provide applications single seamless hierarchically structured name space 
startup unix file name space consists single root file system 
individual mount commands may issued bind root external file system internal leaf node local name space 
mount internal node hides original subtree beneath node 
simplify implementation unix imposes certain restrictions inability place hard links mount points 
mount originally conceived mechanism allow self contained file systems removable storage media added removed unix 
performing name lookup kernel uses internal data structure called mount table direct search appropriate storage device 
single lookup may span devices multiple mounts effect 
distributed file system mount mechanism provides natural hook hang remote subtree 
fundamentally different ways mechanism numerous variants 
simpler approach systems nfs client individually mounts subtrees servers 
centralized management mount information 
servers unaware subtrees exported mounted 
approach easier implement disadvantage shared name space guaranteed identical clients 
movement files server requires client affected subtree 
practice systems approach usually provide auxiliary mechanisms yellow pages automounter nfs automate centralize mounts 
alternative approach embed mount information data stored file servers 
andrew example uses mount points embedded volumes 
sprite uses remote links similar purpose 
approach trivial ensure clients see precisely shared file name space 
operational tasks moving files server involve updating mount information servers 

caching clients caching data clients undoubtedly architectural feature contributes performance distributed file system 
distributed file system serious today uses form caching 
rfs initially avoided caching interests strict unix emulation uses 
caching exploits locality 
high probability file data reused soon 
obtaining local copy data client avoid interactions server 
meta data directories protection file status information file location information exhibit locality candidates caching 
key issue caching size cached units data 
distributed file systems cache individual pages files 
early versions andrew cached entire files 
simplifies cache managment offers simpler failure semantics suffer inability access files larger client cache 
versions andrew cache large portions typically kb files 
unit caching closely related bulk transfer protocols discussed section 
systems clients maintain cache main memory 
andrew exception caches local disk level caching main memory 
providing larger cache sizes disk caching preserves cache contents system reboots 
validation cache contents done fundamentally different ways 
approach systems client contact server validation 
alternative approach andrew ds server notify clients cached data rendered stale 
complex implement approach produce substantial reductions client server traffic 
existing systems wide spectrum approaches propagating modifications client server 
async mode ds propagates changes server file explicitly flushed 
andrew propagates changes file closed writing 
sprite delays propagation dirty cache pages reclaimed maximum seconds 
deferred propagation improves performance data overwritten increases possibility server data stale due client crash 
file exhibit spatial locality 
page file read substantial likelihood succeeding pages read 
property exploited systems read ahead file data 
client overlap processing page fetching page set pages server 

hints context distributed systems hint piece information substantially improve performance correct semantically negative consequence erroneous 
maximum performance benefit hint nearly correct 
terry discusses hints detail provides examples may distributed systems 
caching hints obtain substantial performance benefits incurring cost maintaining cache consistency 
information self validating amenable strategy 
instance treat file data hint cached copy data reveal current stale 
hints file location information distributed file systems 
sprite instance caches mappings pathname prefixes servers 
similarly andrew caches individual entries volume location database 
systems client cached location information server rejects request longer stores file referred request 
client obtains new location file caches information fresh hint 
elaborate location scheme incorporating hint manager apollo domain 

transferring data bulk network communication overheads typically account major portion latency distributed file system 
transit time small amounts data local area network insignificant delays caused protocol processing substantial 
transferring data bulk reduces overhead source sink data 
source multiple packets formatted transmitted context switch 
sink avoided packet 
bulk transfer protocols better disks source sink 
multiple blocks data may obtained source single seek 
similarly packets buffered written en masse disk sink 
effect bulk transfer amortizes fixed protocol overheads consecutive pages file 
bulk transfer protocols depend spatial locality files effectiveness 
high probability succeeding pages file soon referenced client earlier page referenced 
mentioned section substantial empirical evidence indicate files read entirety opened 
degree bulk transfer exploited varies system system 
andrew instance critically dependent performance 
early versions system transferred entire files current version transfers files kb chunks 
systems nfs sprite exploit bulk transfer large packet sizes typically kb 
systems depend link level protocol fragment reassemble smaller packets media access level 
bulk transfer protocols increase importance distributed file systems spread networks wider geographic area greater inherent latency 

encryption encryption indispensable building block enforcing security distributed system 
kent classify threats security actions cause unauthorized release information unauthorized modification information unauthorized denial resources 
encryption primarily value preventing unauthorized release modification information 
national standard des commonly form private key encryption 
seminal needham schroeder encryption authentication basis current security mechanisms distributed file systems 
heart mechanisms handshake protocol party challenges prove identity 
secret encryption key known legitimate client server assumed prima facie evidence authenticity 
communicating entities mutually suspicious confident identity transmitting shared secret key clear 
basic scheme distinct ways current systems 
difference lies way user passwords stored servers 
scheme kerberos andrew authentication server physically secure maintains list user passwords clear 
contrast public key scheme sun nfs maintains publicly readable database authentication keys encrypted user passwords 
approach attractive characteristic physical security authentication server unnecessary 
encryption usually implemented rpc level 
ds contrast uses node node encryption 
systems andrew encryption protect data headers packets exchanged authentication 
systems sun nfs provide capability 
difficult problem justifying cost encryption hardware management users 
extra memory processor speed graphics capability encryption devices provide tangible benefits users 
importance security perceived late 
encryption hardware viewed expensive 
hopefully emerging awareness encryption indispensable security rapid cheap encryption universally available capability 

current issues distributed file systems continue subject considerable activity innovation industry academia 
done areas availability scaling support heterogeneity database access 
briefly consider issues sections 

availability reliance distributed file systems increases problem availability acute 
today single server crash network partition seriously inconvenience users large distributed file system 
growing need distributed file systems highly resilient failures 
availability focus coda file system currently built carnegie mellon university 
coda goal provide highest degree availability face realistic failures significant loss usability performance security 
orthogonal mechanisms replication disconnected operation achieve goal 
key architectural features coda caching callback file transfer rpc authentication encryption aggregation data volumes inherited andrew 
consistency availability performance tend mutually contradictory goals distributed system 
coda strategy provide highest availability best performance 
considers inconsistency tolerable rare occurs conditions failure detected allowed propagate little possible 
relative simultaneous write sharing files multiple users viable strategy 
high availability key concern echo file system built system research center digital equipment 
design uses replication strategy differs substantially coda 
time exactly servers replica file primary site 
clients interact primary site assumes responsibility propagating changes replication sites 
case partition file updates allowed partition containing majority replication sites 
primary site new primary site elected 
experimental efforts area include cornell university gemini university california san diego 

scalability certain problems induced scale exposed extensive large distributed file systems 
problem need decentralization 
ability delegate administrative responsibility lines parallel institutional boundaries critical smooth efficient operation 
ideal model decentralization users perceive system monolithic accesses span administrative domains 
practice course accesses client directed server administrative domain 
mentioned section apollo andrew file systems extended support decentralized administration 
aspect scaling extension distributed file system paradigm wide geographic areas 
virtually distributed file systems today designed local area networks mind 
open question designs extended networks longer latencies greater chances network congestion 
effort currently way extend andrew operate wide area network 
emphasis caching minimization client server interactions design andrew quite appropriate extension 
basic question arises large scale single hierarchically organized name space appropriate model sharing data 
paradigm originally invented timesharing systems tens hundreds users successfully extended distributed file systems nodes 
best model orders magnitude nodes 
pathnames longer increasingly difficult search files name precisely known 
quicksilver file system currently development ibm almaden research center addresses issue 
approach provide mechanisms user customize name space 
customization location transparent user retains context moves node system 
similar approach proposed plan system bell labs 
network topology increasingly important aspect distributed systems 
large networks complex topologies caused variety factors 
electrical considerations limit lengths individual network segments density machines 
maintenance fault isolation simplified network decomposable 
administrative functions assignment unique host addresses decentralized network partitioned 
distributed file systems mask underlying network complexity performance inhomogeneities hidden 
routers introduce load dependent transmission delays common source performance inhomogeneity 
uneven loading subnets cause 
interaction network topology distributed system performance poorly understood 
preliminary investigation issues reported context andrew 

heterogeneity distributed system evolves tends grow diverse 
variety factors contribute increased heterogeneity 
distributed system increasingly valuable resource grows size stores larger amounts shared data 
considerable incentive pressure allow users outside scope system participate resources 
second source heterogeneity improvement performance decrease cost hardware time 
effective hardware configurations change period growth system 
functional specialization third reason heterogeneity 
certain combinations hardware software may appropriate specific applications 
distributed file system community gained experience heterogeneity 
pinkerton describe experimental file system washington focuses heterogeneity 
tops product offered sun microsystems allows personal computers running pc dos macintosh operating systems share files 
pc nfs sun allows pc dos applications access files nfs server 
surrogate server mechanism andrew called enables pc dos applications access files vice 
coping heterogeneity inherently difficult presence multiple computational environments notions file naming functionality 
general principles applicable idiosyncrasies new system ad hoc mechanisms 
unfortunately heterogeneity ignored widespread 

database access mentioned introductory section file system refinement permanent storage abstraction 
database alternative refinement differs file system important ways 
difference storage model application programs users 
file system views data file uninterpreted byte sequence 
contrast database encapsulates substantial information types logical relationships data items stored 
ensure constraints values satisfied enforce protection policies fine granularity 
second fundamental distinction area naming 
file system provides access file name database allows associative access 
data items accessed modified database user specified predicates 
difference storage model naming priori difficult build distributed databases file systems 
circumstances lead database precisely distribution data difficult 
databases common applications data concurrently shared reading writing large number users 
applications usually demand strict consistency data atomicity groups operations 
total quantity data database may large granularity access update usually quite fine 
combination application characteristics implementation distributed databases substantially harder implementation distributed file systems 
distributing database particularly difficult large scale 
general form problem hopelessly difficult 
database conceptually focal point enforcing concurrency control atomicity properties 
control structures enforce properties physically distributed resulting network protocols substantially complex 
feasibility fully distributing data control small scale demonstrated systems 
extension larger distributed systems trivial 
ambitious approach attempts provide distributed access data single large database server 
data located single site transparent access data possible sites 
model database requirements large distributed system met small number powerful database servers exporting standardized network interface 
example system scylla demonstrated carnegie mellon university integrating shelf relational database system informix rpc package 
similar approaches announced microsoft oracle vendors 

earliest days distributed computing file systems important widely form shared permanent storage 
continuing interest distributed file systems bears testimony robustness model data sharing 
understand implement distributed file systems span nodes 
scaling formidable challenge 
elaborated preceding section availability heterogeneity support databases key issues 
security continue serious concern may fact turn bane large distributed systems 
regardless specific technical direction taken distributed file systems decade little doubt area considerable industry academia 
brent callaghan michael kazar james kistler paul leach paul levine john ousterhout charlie sauer ellen siegel chris carl smith warren smith alfred spector peter weinberger valuable comments contributed technical accuracy readability 
accetta robertson satyanarayanan thompson design network central file system 
technical report cmu cs department computer science carnegie mellon university 
adler developing sql server database applications db library 
microsoft systems journal november 
heterogeneous registry client side release document apollo computer 
part 
apple computer inside macintosh volume ii 
addison wesley 
bach melamed remote file cache rfs 
summer usenix conference proceedings phoenix 

bernstein goodman concurrency control distributed database systems 
computing surveys june 
birrell needham universal file server 
ieee transactions software engineering se september 
brown taft alpine file system 
acm transactions computer systems november 
marshall randell newcastle connection 
software practice experience 
cabrera wyllie quicksilver distributed file services architecture horizontal growth 
proceedings nd ieee conference computer workstations santa clara 
march 
available tech report rj april computer science department ibm almaden research center 
callaghan lyon automounter 
winter usenix conference proceedings san diego 

rfs sunos 
summer usenix conference proceedings phoenix 

cheriton zwaenepoel distributed kernel performance diskless workstations 
proceedings th acm symposium operating system principles woods 
october 
burkhard consistency recovery control replicated files 
proceedings th acm symposium operating system principles orcas island 
december 
vms system software handbook digital equipment 
leach mishkin network computing architecture system environment developing distributed applications 
summer usenix conference proceedings phoenix 

floyd short term file patterns unix environment 
technical report tr department computer science university rochester 
floyd directory patterns unix environment 
technical report tr department computer science university rochester 
older felix file server 
proceedings th acm symposium operating system principles asilomar 
december 
lyon callaghan open network computing environment 
spring 
gifford violet experimental decentralized system 
technical report csl xerox palo alto research center september 
gifford weighted voting replicated data 
technical report csl xerox palo alto research center september 
hatch katz rees 
rfs sun rfs 
unix world ii december 
howard kazar menees nichols satyanarayanan sidebotham west scale performance distributed file system 
acm transactions computer systems february 
disk operating system version ibm 

ibm 
remote virtual disk subsystem 
academic operating system volume iii 
kleiman vnodes architecture multiple file system types sun unix 
summer usenix conference proceedings atlanta 

lampson hints computer system designers 
proceedings th acm symposium operating system principles woods 
october 
lazowska zahorjan cheriton zwaenepoel file access performance diskless workstations 
acm transactions computer systems 
leach hamilton levine uids internal names distributed file system 
proceedings symposium principles distributed computing ottawa 
august 
leach levine hamilton nelson architecture integrated local network 
ieee journal selected areas communications november 
leach levine hamilton file system integrated local network 
proceedings acm computer science conference new orleans 
march 
inside os 
microsoft press 
levine apollo domain distributed file system 
banatre 
editors nato asi series theory practice distributed operating systems 
springer verlag 
levitt ibm rt gets connected 
byte 
lindsay haas mohan yost computation communication distributed database manager 
acm transactions computer systems february 
satyanarayanan tool monitoring network locality 
proceedings th international conference modelling techniques tools computer performance evaluation 
september 
available tech 
rept cmu cs department computer science carnegie mellon university 
mace oracle fox detail strategies database servers 
infoworld november 
majumdar bunt measurement analysis locality phases file referencing behaviour 
proceedings performance acm sigmetrics raleigh 
may 
marill stern network data utility 
proceedings afips national computer conference 
may 
marzullo schmuck supplying high availability standard network file system 
technical report department computer science cornell university december 
meyer cryptography new dimension computer data security 
john wiley sons 
mitchell dion comparison network file servers 
communications acm april 
morris satyanarayanan conner howard rosenthal smith andrew distributed personal computing environment 
communications acm march 
mullender tanenbaum distributed file service optimistic concurrency control 
proceedings th acm symposium operating system principles orcas island 
december 
mullender tanenbaum design capability operating system 
computer journal march 
needham schroeder encryption authentication large networks computers 
communications acm december 
nelson welch ousterhout caching sprite network file system 
acm transactions computer systems february 
mcgrath israel framework networking system summer usenix conference proceedings atlanta 

ousterhout da costa harrison kunze kupfer thompson trace driven analysis unix bsd file system 
proceedings th acm symposium operating system principles orcas island 
december 
ousterhout douglis nelson welch sprite network operating system 
computer february 
paris 
voting witnesses consistency scheme replicated files 
technical report computer systems research group department electrical engineering computer science university california san diego 
paris 
voting variable number copies 
technical report computer systems research group department electrical engineering computer science university california san diego 
martin davis user account registration system large heterogeneous unix network 
winter usenix conference proceedings dallas 

pinkerton lazowska notkin zahorjan heterogeneous remote file system 
technical report department computer science university washington august 
popek walker chow edwards kline thiel locus network transparent high reliability distributed system 
proceedings th acm symposium operating system principles asilomar 
december 
presotto plan bell labs network 
european unix user group conference proceedings london 
april 
cmu pc server project 
technical report cmu itc information technology center carnegie mellon university february 
rees levine mishkin leach extensible system 
summer usenix conference proceedings atlanta 

empirical study file patterns 
technical report rj ibm research division april 
rifkin forbes hamilton shah rfs architectural overview 
summer usenix conference proceedings atlanta 

ritchie thompson unix time sharing system 
communications acm july 
rosen wilde fraser campbell nfs portability 
summer usenix conference proceedings atlanta 

rowe birman local network unix operating system 
ieee transactions software engineering se march 
sandberg goldberg kleiman walsh lyon design implementation sun network filesystem 
summer usenix conference proceedings portland 

satyanarayanan study file sizes functional lifetimes 
proceedings th acm symposium operating system principles asilomar 
december 
satyanarayanan synthetic driver file system simulations 
proceedings international conference modelling techniques tools performance analysis paris 
may 
satyanarayanan integrating security large distributed environment 
technical report cmu cs department computer science carnegie mellon university 
satyanarayanan influence scale distributed system 
proceedings th international conference software engineering singapore 
april 
satyanarayanan howard nichols sidebotham spector west itc distributed file system principles design 
proceedings th acm symposium operating system principles orcas island 
december 
sauer presenting single system image fine granularity mounts 
login july august 
sauer johnson gouda smith rt pc distributed services overview 
operating systems review july 
sauer johnson gouda smith distributed services 
proceedings dallas 
february 
schroeder gifford needham caching file system programmer workstation 
proceedings th acm symposium operating system principles orcas island 
december 
sidebotham volumes andrew file system data structuring primitive 
european unix user group conference proceedings 
august 
available technical report cmu itc information technology center carnegie mellon university 
smith analysis long term file patterns application file migration algorithms 
ieee transactions software engineering july 
spector kazar wide area file service afs experimental system 
unix review march 
steiner neuman schiller kerberos authentication service open network systems 
winter usenix conference proceedings dallas 

file migration 
phd thesis stanford university 
stroud tops 
spring 
reliable object oriented data repository distributed computer system 
proceedings th acm symposium operating system principles asilomar 
december 
file servers network distributed systems 
computing surveys december 
taylor secure networking sun environment 
summer usenix conference proceedings atlanta 

taylor framework network security 
spring 
terry caching hints distributed systems 
ieee transactions software engineering se january 
thacker mccreight lampson sproull boggs alto personal computer 
siewiorek bell newell 
editors computer structures principles examples 
mcgraw hill book 
kent security mechanisms high level network protocols 
computing surveys june 
walker popek english kline thiel locus distributed operating system 
proceedings th acm symposium operating system principles woods 
october 
walsh lyon sager chang goldberg kleiman lyon sandberg weiss overview sun network filesystem 
winter usenix conference proceedings dallas 

weinberger version network file system 
summer usenix conference proceedings salt lake city 

welch ousterhout prefix tables simple mechanism locating files distributed system 
proceedings th international conference distributed computing systems cambridge 
may 
design specification cellular andrew environment 
technical report cmu itc information technology center carnegie mellon university june 
table contents 

background 
basic issues 
evolution 
empirical observations 
case studies 
sun network file system 
design considerations 
naming location 
caching replication 
security 
system management 
apollo domain file system 
design considerations 
naming location 
caching replication 
security 
system management 
andrew file system 
design considerations 
naming location 
caching replication 
security 
system management 
contemporary systems 
ibm aix distributed services 
remote file sharing 
sprite network file system 
mechanisms techniques 
mount points 
caching clients 
hints 
transferring data bulk 
encryption 
current issues 
availability 
scalability 
heterogeneity 
database access 

