comprehending monads philip wadler university glasgow category theorists invented monads concisely express certain aspects universal algebra 
functional programmers invented list comprehensions concisely express certain programs involving lists 
shows list comprehensions may generalised arbitrary monad resulting programming feature concisely express pure functional language programs manipulate state handle exceptions parse text invoke continuations 
new solution old problem destructive array update 
knowledge category theory assumed 
way combine impurity purity 
impure strict functional languages standard ml mil hmt scheme rc support wide variety features assigning state handling exceptions invoking continuations 
pure lazy functional languages haskell miranda tur eschew features incompatible advantages lazy evaluation equational reasoning advantages described length hug bw 
purity programmers pure functional languages recall moment impure feature tempted 
instance counter required generate unique names assignable variable just ticket 
cases possible mimic required impure feature straightforward tedious means 
instance counter simulated modifying relevant functions accept additional parameter counter current value return additional result counter updated value 
miranda trademark research software limited 
author address department computing science university glasgow qq scotland 
electronic mail wadler cs glasgow ac uk 
appeared mathematical structures computer science volume pp 
copyright cambridge university press 
version corrects small errors published version 
earlier version appeared acm conference lisp functional programming nice june 
describes new method structuring pure programs mimic impure features 
method completely eliminate tension purity impurity relax little bit 
increases readability resulting programs eliminates possibility certain silly errors arise accidentally passing wrong value counter parameter 
inspiration technique comes eugenio moggi mog mog 
goal provide way structuring semantic description features state exceptions continuations 
discovery notion monad category theory suits purpose 
defining interpretation calculus arbitrary monad provided framework describe features 
relatively straightforward adopt moggi technique structuring denotational specifications technique structuring functional programs 
presents simplified version moggi ideas framed way better suited functional programmers particular knowledge category theory assumed 
contains significant new contributions 
contribution new language feature monad comprehension 
generalises familiar notion list comprehension wad due originally burstall darlington tur miranda haskell languages 
monad comprehensions essential structuring technique described provide pleasant syntax expressing programs structured way 
second contribution new solution old problem destructive array update 
solution consists data types operations 
approach usual typing discipline hindley milner extended data types sufficient guarantee array update may safely implemented overwriting 
knowledge solution proposed discovery comes surprise considering plethora elaborate solutions proposed include syntactic restrictions sch run time checks hol interpretation hud hud blo exotic type systems gh wad wad 
monads led discovery solution count point favour 
solution discovered 
reason data types involve higher order functions essential way 
usual axiomatisation arrays involves order functions index update newarray described section apparently occur search data type higher order functions 
incidentally higher order nature solution means applied order languages prolog obj 
casts doubt goguen thesis order languages sufficient purposes gog 
monads monad comprehensions help clarify unify previous proposals incorporating various features functional languages exceptions wad spi parsers wad fai fl non determinism ho 
particular spivey spi notable pointing independently moggi monads provide frame exception handling 
translation scheme calculus arbitrary monad 
schemes yielding call value semantics yielding call name 
systematically transform languages state exceptions continuations features pure functional language 
applications 
derive call value call name interpretations simple non deterministic language fits hughes donnell ho general framework 
apply call value scheme monad continuations result familiar continuation passing style transformation 
remains open question translation scheme corresponds call need opposed call name 
key feature monad approach types indicate parts program may sorts effects 
similar spirit gifford lucassen effect systems gl 
examples haskell lazy functional language incorporating hindley milner type system 
remainder organised follows 
section uses list comprehensions motivate concept monad introduces monad comprehensions 
section shows variable binding terms control evaluation order modelled trivial monads 
section explores monads structure programs manipulate state presents new solution array update problem 
examples considered renaming bound variables interpreting simple imperative language 
section extends monad comprehensions include filters 
section introduces concept monad morphism gives simple proof equivalence programs 
section catalogues monads parsers exceptions continuations 
section gives translation schemes interpreting calculus arbitrary monad 
examples considered giving semantics non deterministic language deriving continuation passing style 
comprehensions monads lists write data type lists elements type 
haskell usually written 
example int char write map higher order function applies function list map 
haskell type variables written small letters type constructors written capital letters example code char int maps character ascii code map code 
observe map id id ii map delta map delta map id identity function id delta function composition delta 
category theory notions type function generalised object arrow operator object object combined operator map arrow arrow map satisfying ii called functor 
prefer symbol operators write write map function unit converts value singleton lists function join concatenates list lists list unit join example unit join 
observe iii map delta unit unit delta iv map delta join join delta map map laws iii iv may derived systematic transformation polymorphic types unit join 
idea deriving laws types goes slogan theorems free wad consequence reynolds abstraction theorem polymorphic lambda calculus rey 
categorical terms unit join natural transformations 
treat unit single function polymorphic type treat family arrows unit object satisfying map delta unit unit delta objects arrow 
treat join similarly 
natural transformation simpler concept polymorphic function stick polymorphism familiar concept functional programmers 
comprehensions functional languages provide form list comprehension analogous set comprehension 
example general comprehension form term qualifier 
letters range terms range qualifiers 
qualifier empty generator variable list valued term composition qualifiers 
comprehensions defined rules unit map join jq haskell terms written common 
note reversal qualifiers rule nesting inside right hand side means expect variables bound may vice versa 
familiar list comprehensions empty qualifier parentheses qualifier compositions appear strange 
needed 
shortly prove qualifier composition associative empty qualifier unit 
need write parentheses qualifier compositions equivalent need write equivalent simpler remaining write abbreviate 
languages include list comprehensions allow form qualifier known filter treatment postponed section 
simple example sqr fby map sqr comprehension initial example computed fby join fby join map 
fby join map map 
join map join iv may derive laws map function contain free occurrences variables bound qualifier term stands term term substituted free occurrence variable similarly qualifier law proved induction structure qualifiers proof uses laws ii iv 
law immediate consequence laws 
law proved induction structure qualifiers proof uses laws 
promised show qualifier composition associative empty qualifier unit ii iii observe iii equivalent respectively join delta unit id ii join delta map unit id iii join delta join join delta map join see ii ii equivalent start left side ii simplify fby join fby join unit fby join map unit ii implies ii immediate 
converse take apply 
equivalences seen similarly 
second observe laws iii hold 
example join unit join join map unit join join join join join map join join induction lists prove ii list lists prove iii 
monads comprehension notation suits data structures lists 
sets bags obvious examples shall encounter 
inspection foregoing lets isolate conditions comprehension notation sensible 
purposes monad operator types triple functions map 
unit join satisfying laws iv iii 
monad gives rise notion comprehension laws 
laws establish correspondence components monad forms qualifier associates unit empty qualifier associates map generators associates join qualifier composition 
resulting notion comprehension guaranteed sensible necessarily satisfies laws iii 
follows need distinguish monads 
write stand monad leaving triple map unit join implicit write indicate monad comprehension interpreted 
monad lists described written list example take set set type constructor map set image set function unit set function takes element singleton set join set union set sets map set unit set join set resulting comprehension notation familiar sets 
instance set specifies cartesian product sets recover unit map join comprehension notation unit map join adopt convention type type type 
derive comprehensions monads derive monads comprehensions 
define comprehension structure interpretation syntax comprehensions satisfies laws iii 
monad gives rise comprehension structure laws seen imply iii 
conversely comprehension structure gives rise monad structure laws easy verify imply iv iii 
concept arrived generalising list comprehensions mathematicians arrived different route 
arose homological algebra name standard construction sort mathematical equivalent hey 
name triple improvement 
monad 
nowadays standard text category theory mac bw ls 
concept call monad slightly stronger means name call strong monad cartesian closed category 
speaking category cartesian closed structure interpret calculus 
particular associated pair objects types object representing space arrows functions recall functor arrow arrow map satisfying ii 
functor strong represented single arrow map 
second nature generous functional programmer provides structure needed 
needed evidenced moggi requirement computational monad strength function satisfying certain laws mog :10.1.1.26.2787
cartesian closed category monad strength equivalent monad strong functor described 
framework strength defined 
haskell write pairs corresponding product type 
monads conceived list comprehensions 
quite independent origins fit remarkably 
happens common truth may underlie apparently disparate phenomena may take decade underlying commonality 
trivial monads identity monad identity monad trivial monad specified type id map id unit id join id map id unit id bind id just identity function 
comprehension identity monad term id similarly sequence qualifiers corresponds sequence nested terms id bound appears inner term 
comprehensions identity monad written preference terms equivalent 
hindley milner type system terms terms differ may introduce polymorphism 
key factor allowing terms play role syntax pairs bound variable binding term 
monad comprehensions similar property reasonable introduce polymorphism 
require comprehensions introduce polymorphism leave exploration issue 
strictness monad necessary control order evaluation lazy functional program 
usually achieved computable function strict defined strict operationally strict reduced reducing weak head normal form whnf reducing application alternatively safe reduce parallel allow access result whnf 
function basis monad type str map str strict unit str join str identity monad definition map str monad laws iii iv iii satisfied law ii inequality map str delta map str map str delta str quite monad call lax monad 
comprehensions lax monads defined laws just monads 
law remains valid laws inequalities 
str comprehensions control evaluation order lazy programs 
instance operational interpretation str follows reduce whnf bind value reduce whnf bind value reduce alternatively safe reduce parallel allow access result whnf 
manipulating state procedural programming languages operate assigning state possible impure functional languages standard ml 
pure functional languages assignment may simulated passing value representing current state 
section shows monad state transformers corresponding comprehension structure programs written style 
state transformers fix type states 
monad state transformers st defined type st 
map st id unit st 
join st id recall equivalence id comprehensions terms explained section state transformer type takes state returns value type new state 
unit takes value state transformer 
returns leaves state unchanged 
st id applies state transformer state yielding value new state applies second transformer state yielding value newer state returns value consisting paired final state useful operations monad fetch st fetch 
assign st assign 
fetches current value state leaving state unchanged second discards old state assigning new state value 
type contains value 
third useful operation init st init id applies state transformer initial state returns value computed state transformer discarding final state 
example renaming say wish rename bound variables lambda term 
suitable data type term representing lambda terms defined standard ml haskell 
new names generated counting assume function int name integer computes name 
assume function subst name name term term subst substitutes free occurrence solution problem impure functional language standard ml shown 
impure feature concerned state solution uses assignable location containing integer 
functions types newname name renamer term term rename term term note newname renamer true functions depend state 
particular newname returns different name time called requires dummy parameter give form function 
rename true function generates new names starting 
understanding program requires knowledge functions affect state 
easy see renamer true function contain direct state contain indirect newname rename true function renamer equivalent solution pure functional language shown 
explicitly passes integer generate new names 
functions types newname int 
name int renamer term int 
term int rename term term function newname generates new name integer returns incremented integer function renamer takes term integer returns renamed term names generated integer paired final integer generated 
function rename takes term returns renamed term names generated 
program straightforward difficult read contains great deal plumbing pass state 
relatively easy introduce errors programs writing intended 
plumbing problem severe program greater complexity 
solution problem monad state transformers shown 
state taken int functions types newname st name renamer term st name rename term term monadic program simply different way writing pure program expanding monad comprehensions simplifying yield program 
types monadic program seen correspond directly types impure program impure function type affects state corresponds pure function type st renamer type term term impure program type term st term monadic program newname type name impure program type st name isomorphic st name pure program 
impure program types monadic program manifest state affected st comprehensions 
plumbing handled implicitly state transformer explicitly 
various kinds errors possible pure program accidentally writing place impossible monadic program 
type system ensures plumbing handled appropriate way 
example tempted write say app renamer renamer right hand side equation defining renamer detected type error 
safety ensured making st data type map st unit st join st fetch assign init operations 
guarantees mix state transformer abstraction functions handle state inappropriately 
idea pursued section 
impure functional languages standard ml restricted strict call value order evaluation effect assignments difficult predict 
programs monad state transformers written languages strict call value lazy call name order evaluation 
state transformer comprehensions clear exactly order assignments take effect regardless order evaluation 
reasoning programs impure functional languages problematic impossible see mt approach 
contrast programs written monads pure programs reasoned usual way substituting equals equals 
satisfy additional laws laws qualifiers fetch fetch fetch st assign fetch assign st assign assign assign terms init st init assign st init st init assign st init st comprehension laws gamma gamma iii allow equational reasoning prove properties programs manipulate state 
array update arr type arrays indexes type ix yielding values type val key operations type newarray val arr index ix arr val update ix val arr arr newarray returns array entries set index returns value index array update returns array index value remainder identical equations index newarray index update index update index efficient way implement update operation overwrite specified entry array pure functional language safe pointers array extant update operation performed 
consider monad state transformers state type arr type st arr 
arr variants fetch assign operations defined act array entry specified index variant init defined initialise entries array value fetch ix st val fetch index str assign ix val st assign 
update init val st init newarray id str comprehension fetch force entry fetched available access essential order safe update overwriting 
say st data type operations values type st map st unit st join st fetch assign init straightforward show operations passed sole pointer array returns second component sole pointer array 
operations may build term type st guarantees safe implement assign operation overwriting specified array entry 
key idea data type 
monad comprehensions essential merely provide desirable syntax 
example interpreter consider building interpreter simple imperative language 
store language modelled state type arr take ix type variable names val type values stored variables 
syntax language represented data types data exp var ix const val plus exp exp data com asgn ix exp seq com com exp com com data prog prog com exp expression variable constant sum expressions command assignment sequence commands conditional program consists command followed expression 
version interpreter pure functional language shown 
interpreter read denotational semantics language semantic functions exp exp arr val com com arr arr prog prog val semantics expression takes store value semantics command takes store store semantics program value 
program consists command followed expression value determined applying command initial store variables value evaluating expression context resulting store 
interpreter uses array operations newarray index update 
happens safe perform updates place program discover requires special analysis techniques cited 
interpreter rewritten state transformers 
semantic functions types exp exp st val com com st prog prog val semantics expression depends state returns value semantics command transforms state semantics program just value 
types semantics expression alter state fact expressions depend state change return problem shortly 
data type st guarantees safe perform updates indicated assign place special analysis technique required 
easy see monad interpreter derived original definitions earlier proof equivalence straightforward 
program written state transformers simple imperative reading 
instance line com seq com com st read evaluate command seq evaluate evaluate 
types st comprehension clear operations transform state values returned type clear effect state interest 
drawback program introduces sequencing 
line exp plus exp exp st read evaluate plus evaluate yielding value evaluate yielding value add 
unfortunate imposes spurious ordering evaluation original program implies ordering 
order matter exp depends state change 
noted way express just monad state transformers 
remedy introduce second monad state readers 
state readers recall monad state transformers fixed type states type st 
monad state readers type states type sr map sr id unit sr join sr id variable type sr just variable type st state reader type takes state returns value type new state 
unit takes value state transformer ignores state returns sr id applies state readers state yielding values returned pair 
easy see sr sr order computed irrelevant 
monad property called commutative follows sr sr term qualifiers binds free variables vice versa 
state readers capture notion order independence desire expression evaluation interpreter example 
useful operations monad fetch sr fetch ro sr st ro id equivalent previous fetch expressed state reader state transformer 
second converts state reader corresponding state transformer returns value state reader leaves state unchanged 
name ro abbreviates read 
specific case array type arr define fetch ix sr val fetch index order guarantee safety update overwriting necessary modify definitions str comprehensions id comprehensions map sr str ro str correspond str comprehension st version fetch 
arrays complete collection operations state transformers state readers consists fetch ix sr val assign ix val st ro sr st init val st map sr unit sr join sr map st unit st join st operations defined constitute ways manipulating mutually defined data types sr st straightforward show operation type sr passed array returns value contains pointer array reduced weak head normal form whnf operations type st passed sole pointer array returns second component sole pointer array 
operations may build values types sr st guarantees safe implement assign operation overwriting specified array entry 
reader may check str comprehensions map sr ro essential guarantee property 
returning interpreter example get new version shown 
difference previous version occurrences st changed sr ro inserted places 
new typing exp exp sr val clear exp depends state alter 
proof versions equivalent appears section 
excessive sequencing previous version eliminated 
line exp plus exp exp sr read evaluate plus evaluate yielding value evaluate yielding value add 
order qualifiers sr comprehension irrelevant perfectly permissible evaluate order concurrently 
interpreter derived similar structure wad uses type system linear logic guarantee safe destructive update arrays 
related type systems discussed gh wad 
linear type system uses construct suffers unnatural restrictions requires evaluation prohibits certain types involving functions 
contrast monad approach requires strict evaluation places restriction types 
suggests careful study monad approach may lead improved understanding linear types construct 
filters far ignored form qualifier list comprehensions filter 
list comprehensions define filters boolean valued term 
example odd join odd join odd odd odd join define filters general comprehensions arbitrary monad answer define monads admit useful definition 
recall comprehensions form defined terms qualifier unit qualifier composition similarly define comprehensions form terms new qualifier require zero qualifier composition value independent recall introduced function unit satisfying laws iii map delta unit unit delta join delta unit id ii join delta map unit id defined unit similarly introduce function zero satisfying laws map delta zero zero delta iv join delta zero zero join delta map zero zero define zero law specifies result zero independent argument derived type zero see rey wad 
case lists setting zero laws iv hold join join 
ignores happens zero applied considered 
monad zero extend comprehensions contain new form qualifier filter defined boolean valued term 
recall laws proved induction form qualifiers show new forms qualifiers defined hold 
new laws boolean valued terms qualifier binding variables free dealing potential value care required 
strict language functions including zero strict problem 
lazy language case lists laws iv hold law inequality join delta map zero zero join map zero zero 
case laws valid law holds 
case law inequality 
second example monad zero consider strictness monad str defined section 
monad zero may defined zero str 
easy verify required laws hold lists laws hold zero applied 
example gamma str returns positive 
monad morphisms monads monad morphism preserves monad operations delta map map delta delta unit unit delta join join delta delta map map delta composites equal equation 
define effect monad morphism qualifiers follows follows monad morphism terms qualifiers proof simple induction form qualifiers 
example easy check unit monad morphism id follows id explains trick occasionally functional programmers writes qualifier inside list comprehension bind value achieve effect qualifier id comprehension 
second example function ro section monad morphism sr st prove equivalence interpreters figures 
write exp st exp st val exp sr exp sr val versions figures 
equivalence versions clear show ro delta exp sr exp st proof simple induction structure expressions 
expression form plus ro exp sr plus exp sr ro exp sr exp sr sr fby ro exp sr ro exp sr st exp st exp st st exp st exp st plus cases equally simple 
extends straightforwardly monads zero 
case require delta zero zero define action morphism filter observe holds contains filters 
monads section describes monads parsers expressions input output continuations 
basic techniques new parsers discussed wad fai fl exceptions discussed wad spi monads monad comprehensions provide convenient framework expression 
parsers monad parsers type parse string list string map parse list unit parse list join parse list string type lists char parser accepts input string returns list pairs 
list contains pair successful parse consisting value parsed remaining unparsed input 
empty list denotes failure parse input 
parse list applies parser input binds value parsed applies second parser remaining input binds value parsed returns pair value input parsed 
fails parse input returning empty list combined parser fail 
suitable zero monad zero parse list parse parser fails parse input 
follows may filters parse comprehensions list comprehensions 
alternation operator combines parsers parse parse parse 
operator concatenates lists 
returns parses argument followed parses second 
simplest parser parses single character parse char head tail null list list comprehension filter 
parser succeeds input non empty case returns character 
may define parser recognise literal lit char parse lit parse parse comprehension filter 
parser lit succeeds character input example parser fully lambda terms yielding values type term described previously written follows term parse term term var name parse lam lit lit name lit term lit parse app lit term term lit parse name parse name name parse simplicity assumed names consist single lower case letter name char characters 
exceptions type consists value type written just exceptional value written data just names due spivey spi 
operations yield monad map just just map unit just join just just just join just join returns just just just returns 
suitable zero monad zero just example gamma returns positive 
useful operations test argument corresponds value return value exists bool exists just true exists false just observe exists assume easily checked monad morphism str gamma gamma str immediate consequence monad morphism law 
mapping embodies common simplification considering error values identical 
biased choice operator chooses possible values defined 
exists operation associative unit 
appeared early versions ml gmw similar operators appear languages 
example term gamma returns predecessor non negative zero 
wad proposed lists represent exceptions encoding value unit list exception empty list 
corresponds mapping list list list just list list list monad morphism list list list list sublist relation 
exception comprehensions represented list comprehensions biased choice represented list concatenation 
argument wad list comprehensions provide convenient notation manipulating exceptions mapped morphism argument favour exception comprehensions 
input output fix input output program strings input sequence characters keyboard output sequence characters appear screen 
input output monads type string 
string type string string input monad function string input program pair value string input rest program 
output monad pair value function string output rest program string output program 
input monad identical monad state transformers fixing state string operations map unit join identical monad 
useful operations input monad eof bool eof 
null read char read 
head tail returns true input read second reads input character 
output monad map ot ot id unit join ot delta ot ot ot id second component pair output transformer output rest program produces output part 
unit produces output output transformer identity function 
join operation composes output transformers 
useful operation output monad write char write adds character written head output list 
alternative definitions output monad possible behave formulation 
alternative treats output state transformer type string 
string map unit join state transformer monad 
write operation write char write 
formulation strict output appear program terminates 
alternative type string map id unit join id write formulation time perform concatenation operations quadratic size output worst case 
output input monads combined single monad type inout string 
string string string suitable definitions map unit join left reader 
useful operations monad inout id inout ot ot id fun inout 
string string fun ot ot id monad morphisms inout take input output operations input output monad 
takes value input output monad function input output 
continuations fix type results 
monad continuations type cont map cont unit cont join cont continuation type takes continuation function specifies take value type result type returns result type unit takes value continuation applies continuation function value 
cont read follows evaluate bind result evaluate bind result return pair 
useful operation monad callcc cont cont cont callcc mimics call current continuation call cc operation popular scheme rc 
example scheme program call cc lambda esc esc translates equivalent program callcc esc esc cont cont programs bind esc escape function returns argument value entire callcc expression 
return value divided return zero 
translation section saw function type impure functional language manipulates state corresponds function type st pure functional language 
correspondence drawn informal way ask assurance program translated similar way 
section provides assurance form translation calculus arbitrary monad 
allows translate programs manipulate state programs raise exceptions call continuations 
shall see translations call value call name 
target language translations pure non strict calculus augmented comprehensions 
perform translations simple typed lambda calculus 
range types range base types 
type base type function type product type range terms range variables 
term variable abstraction application pair selection fst snd usually give case fst omit snd nearly identical 
range assumptions lists associating variables types write typing indicate assumption term type inference rules typings calculus known seen left hand sides figures 
call value translation lambda calculus monad 
translation type written translation term written rule translating function types read call value function takes argument value type returns computation type corresponds translation section function type impure source language translated function type pure target language 
rules translating terms straightforward computational reading 
example rule applications read apply evaluate call result evaluate call result apply call result return expect call value language argument evaluated function applied 
typing source language translation typing target language 
arguments function free variables correspond values result function term corresponds computation 
demonstrates call value translation preserves typings term typed source language translates typed target language 
call name translation calculus monad 
translation type written translation term written rule translating function types read call name function takes argument computation type returns computation type rule applications read apply evaluate call result apply term call result return expect call name language argument passed unevaluated evaluated time 
typing source language previously translates typing target language 
time free variables term correspond computations reflecting call name language free variables correspond computations closures evaluated time 
demonstrates call name translation preserves typings 
particular call value strictness monad str section yields usual strict semantics calculus call name interpretation monad yields usual lazy semantics 
monad say state transformers call value interpretation yields usual semantics calculus assignment 
call name interpretation yields semantics state transformation specified variable occurs time variable accessed 
explains second translation titled call byname call need 
course target call value call name translations pure non strict calculus problem executing programs translated scheme lazy call need implementation 
example non determinism detailed example application translation schemes consider small non deterministic language 
consists calculus defined syntax extended include non deterministic choice operator simple arithmetic delta delta delta ranges integer constants 
language typed just lambda calculus 
assume base type int additional constructs typed follows type int int int int example term type int call value interpretation expect return call name interpretation expect return 
give semantics language interpreting calculus set monad specified section 
follows write preference cumbersome set call value interpretation language provided rules choosing monad set rules fng rules translate term type non deterministic language term type set pure functional language augmented set comprehensions 
example term translates fag fag value expected 
call name translation language provided rules 
rules call value rules replacing gamma gamma term translates value expected 
similar approach non taken hughes donnell ho 
suggest adding set type lazy functional language set represented non deterministic choice elements set 
primitive operations provide sets just map unit join set monad plus set union represent non deterministic choice 
address issue sets behave respect elegant derivation non deterministic parallel tree search algorithm 
provide argument programs traditional non deterministic functional language encoded approach 
argument provided translation scheme 
example continuations final example consider call value interpretation monad continuations cont section 
applying straightforward calculation simplify cont comprehensions yields translation scheme simply continuation passing style transformation theorists compiler writers plo aj 
rules retains straightforward operational reading 
example rule applications read apply evaluate call result evaluate call result apply call result return similar calculation translation scheme yields call name version continuation passing style 
known rey plo 
eugenio moggi ideas time took explain john launchbury enthusiasm suggestions 
helpful comments arvind stephen olivier danvy kevin hammond john hughes karsten kehler holst michael johnson austin melton nikhil simon peyton jones andy pitts andre scedrov carolyn talcott phil trinder glasgow summer school category theory constructive logic anonymous referee 
aj appel jim passing closure passing style 
th acm symposium principles programming languages austin texas january 
blo bloss update analysis efficient implementation functional aggregates 
th symposium functional programming languages computer architecture acm london september 
bw barr wells toposes triples theories 
springer verlag 
bw bird wadler functional programming 
prentice hall 
fai fairbairn form follows function 
software practice experience june 
fl frost launchbury constructing natural language interpreters lazy functional language 
computer journal april 
gog goguen higher order functions considered unnecessary higher order programming 
technical report sri csl sri international january 
gl gifford lucassen integrating functional imperative programming 
acm conference lisp functional programming pp 
cambridge massachusetts august 
gh guzm hudak single threaded polymorphic lambda calculus 
ieee symposium logic computer science philadelphia june 
gmw gordon milner wadsworth edinburgh lcf 
lncs springerverlag 
hol holmstrom simple efficient way handle large data structures applicative 
proceedings serc chalmers workshop declarative programming university college london 
hud hudak semantic model counting abstraction detailed summary 
acm conference lisp functional programming pp 
cambridge massachusetts august 
hmt harper milner tofte definition standard ml version 
report ecs lfcs edinburgh university computer science dept 
hud hudak arrays non determinism side effects parallelism functional perspective 
fasel keller editors workshop graph reduction santa fe new mexico september october 
lncs springerverlag 
hug hughes functional programming matters 
computer journal april 
ho hughes donnell expressing reasoning non deterministic functional programs 
davis hughes editors functional programming glasgow glasgow workshop august workshops computing springer verlag 
hudak peyton jones wadler editors report programming language haskell version 
technical report yale university glasgow university august 
ls lambek scott higher order categorical logic cambridge university press 
mac mac lane categories working mathematician springer verlag 
mil milner proposal standard ml 
acm symposium lisp functional programming austin texas august 
mt mason talcott operational equivalence presence side effects 
ieee symposium logic computer science asilomar california june 
mog moggi computational lambda calculus monads :10.1.1.26.2787
ieee symposium logic computer science asilomar california june 
longer version available technical report university edinburgh 
mog moggi view programming 
course notes university edinburgh 
plo plotkin call name call value calculus 
theoretical computer science 
rc rees clinger eds revised report algorithmic language scheme 
acm sigplan notices 
rey reynolds relation direct continuation semantics 
colloquium automata languages programming saarbrucken july august lncs springer verlag 
rey reynolds types abstraction parametric polymorphism 
mason editor information processing north holland amsterdam 
sch schmidt detecting global variables denotational specifications 
acm transactions programming languages systems 
spi spivey functional theory exceptions 
science computer programming june 
tur turner recursion equations programming language 
darlington henderson turner editors functional programming applications cambridge university press 
tur turner miranda non strict functional language polymorphic types 
proceedings nd international conference functional programming languages computer architecture nancy france september 
lncs springer verlag 
wad wadler replace failure list successes 
nd symposium functional programming languages computer architecture nancy september 
lncs springer verlag 
wad wadler list comprehensions 
peyton jones implementation functional programming languages prentice hall 
wad wadler theorems free 
th symposium functional programming languages computer architecture acm london september 
wad wadler linear types change world 
broy jones editors programming concepts methods ifip working conference sea israel april north holland 
wad wadler linear logic 
conference partial evaluation semantics program manipulation pepm acm new haven connecticut june 
datatype term var name lam name term app term term fun rename val ref fun newname val val fun renamer var var renamer lam val newname lam subst renamer renamer app app renamer renamer renamer renaming impure functional language standard ml data term var name lam name term app term term newname int 
name int newname renamer term int 
term int renamer var var renamer lam newname renamer lam subst renamer app renamer renamer app rename term term rename renamer renaming pure functional language haskell data term var name lam name term app term term newname st name newname fetch assign st renamer term st term renamer var var st renamer lam lam subst newname renamer st renamer app app renamer renamer st rename term term rename init renamer renaming monad state transformers exp exp arr val exp var index exp const exp plus exp exp com com arr arr com asgn update exp com seq com com com exp com com prog prog val prog prog exp com newarray interpreter pure functional language exp exp st val exp var fetch st exp const st exp plus exp exp st com com st com asgn exp assign st com seq com com st com exp com com st prog prog val prog prog init com exp st interpreter state transformers exp exp sr val exp var fetch sr exp const st exp plus exp exp sr com com st com asgn ro exp assign st com seq com com st com ro exp com com st prog prog val prog prog init com ro exp st interpreter state transformers readers types terms fst fst assumptions typings call value translation 
fst fst call value translation preserves typing 
types terms fst fst assumptions typings call name translation 
fst fst call name translation preserves typing 
fst fst call value continuation passing style transformation fst fst call name continuation passing style transformation 
