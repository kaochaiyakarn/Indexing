language oriented programming ward computer science department science labs south rd durham dh le january describes concept language oriented programming novel way organising development large software system leading different structure finished product 
approach starts developing formally specified domain oriented high level language designed suited developing kind program 
development process splits independent stages implement system middle level language implement compiler translator interpreter language existing technology 
approach claimed advantages domain analysis rapid prototyping maintenance portability user systems reuse development providing high development productivity 
give example method successfully conjunction rapid prototyping development large software system fermat reverse engineering tool 
major benefit approach software development compared usual sequential waterfall model speed products brought market 
due concurrent engineering effective overlap development stages 
middle development style compared contrasted usual top bottom outside development methods 
keywords language oriented programming high level languages domain oriented languages rapid prototyping user systems reuse 
problems designing developing large scale software systems documented research program development methods confined toy programs small systems 
brooks notes properties large software systems cause problems systems developed maintained traditional methods complexity essential property large pieces software essential abstracted away 
leads problems ffl communication difficulties large team developers lead product flaws cost overruns schedule delays ffl may difficult impossible visualise states system impossible understand system completely 
states lead security loopholes side effects extending modifying system ffl difficult get overview system maintaining conceptual integrity increasingly difficult ffl hard ensure loose ends accounted ffl steep learning curve new personnel 
conformity systems constrained need conform complex human institutions systems example wages system greatly complicated need conform current tax regulations 
change successful system subject change ffl modified enhance capabilities apply original domain ffl surviving normal life machine runs ffl ported machines environments 
invisibility complex mechanical electronic machines large buildings designers constructors blueprints provide accurate overview geometric representation structure 
complex software systems geometric representation 
distinct interacting graphs links parts system considered including control flow data flow dependency time sequence way simplify attempt control complexity cut links graphs hierarchical structures 
accurate model abstraction system may unreliable system enhanced modified period time 
mid survey software development projects bill curtis colleagues produced main findings ffl thin spread domain knowledge software developers projects ffl customer requirements extremely volatile 
survey software development projects narrower area requirements definition produced specific findings ffl requirements invented elicited 
thirds projects potential market customer 
requirements preferences prioritised low priority requirements abandoned schedule slipped ffl development maintenance 
system evolution common development scratch exception rule ffl specification incremental 
customer rarely able provide complete specification stage project ffl domain knowledge important ffl gulf developer user 
developers adequate knowledge user 
led major misunderstandings system purpose ffl user interface requirements continually change 
describe novel way organising development large software system leading different structure finished product 
term language oriented programming describe approach stage development method design formally specified domain oriented high level programming language 
stressed aims language design capture domain knowledge form readily programmers 
thesis suitable language way domain knowledge available effect developing language stage development process dramatically reduce development effort required increasing maintainability enabling reuse 
give examples successful system developments final system structure involves middle level language 
systems necessarily developed middle order designing language proceeding development system implementation language language oriented nature system contributed success 
describe major development project fermat tool explicit middle development approach conjunction rapid prototyping achieve highly successful result 
compare contrast middle development top bottom outside development methods 
language oriented programming history computer science greatest single gain software productivity achieved development high level languages suitable compilers interpreters 
high level language allows program implemented order magnitude fewer lines code written assembler 
addition lines code typically easier read analyse understand modify 
experience developing fermat program transformation system see section suggests large factor productivity gain achieved developing suitable problem oriented high level programming language language implement software system 
case fermat domain oriented language 
addition benefits smaller code size increased readability benefit high level languages encapsulate great deal programming knowledge easily usable form 
example programmer compiler deal subroutine call return linking procedure arguments simple optimisations 
second aim language oriented programming addition reduction total code size domain oriented language form repository domain knowledge form readily useable programmers working domain 
common objects domain appear language common operations domain readily available language constructs implementation operations may large complicated 
case fermat foreach fill constructs enable programmer write complex program transformations lines code leaving system deal details tricky special cases 
approach representing domain knowledge form programming language compared intelligent knowledge system representing domain knowledge form rule system 
rule bases system repository domain knowledge gives rise problems knowledge elicitation problem transferring knowledge brains domain experts collection rules suitable implementing rule system enabling programmers extract information repository 
done problem notable successes area medical diagnosis hardware software fault diagnosis 
areas human knowledge readily form interacting rules software system development direct rule base achieve functions 
areas example development transformation systems difficult see programmers rule representation domain knowledge high level domain specific language certainly re large software development projects domain 
stage language oriented development language design providing formal syntax semantics language 
language consists set primitive operations language constructs specialised data types 
having completed language design development system breaks largely independent stages carried order parallel 
implement software system new language 
implement language existing computer language write compiler interpreter translator language 
stages may benefit recursive application method 
recursive development result series language layers lower level languages bottom high level domain specific languages top 
level implemented terms lower level process interpretation compilation translation may formal semantic preserving transformation 
interpretation translation compilation stage may involve optimisation source target language levels 
essential middle level languages formally specified availability formal specification allows system development language implementation carried independently 
important languages conceptually simple easy parse humans computers benefit latest developments programming language design implementation 
advantages language oriented programming separation concerns method provides complete separation concerns design issues addresses domain specific language implementation issues addressed implementation language separated design system 
addition making research programming language design implementation possible keep language design simple powerful expressive 
greatly reduce complexity system implementation 
high development productivity experience fermat experiences projects indicate system implemented language oriented method series language levels ends smaller bottom top implementation system 
due fact problem specific high level language lines code sufficient implement highly complex functions 
implementation language kept small features relevant particular problem domain need implemented 
small size final system means total amount development required reduced increasing complexity system higher functionality 
leads improved maintainability fewer bugs improved adaptability 
high level language means small amount code language achieve great deal 
noted general purpose high level languages order magnitude increase productivity recorded 
called gls forth generation languages attempt achieve similar increase productivity development general purpose high level languages 
successful anticipated partly due lack formal specification syntax semantics partly tried general purpose languages 
large financial organisation currently planning abandon gl altogether attempt maintain lines machine generated cobol 
experience shows restricting language specialised domain hoped gains productivity achieved 
highly maintainable design studies shown important factor affecting maintainability size software system lines code generally require maintenance effort 
small total size system produced language oriented approach implies highly maintainable 
addition major functions system implemented lines code appropriate language means bug fixing enhancements easy reduced chance unexpected interaction parts system 
traditional programming methods design decisions representation data object file structure algorithms implement high level operations spread code 
difficult maintainers determine impacts particular design decision conversely determine design decisions led particular piece code written way 
language oriented development effects design decision usually localised part system 
example decision particular algorithm localised procedure algorithm written appropriate language short easy understand 
similarly decision implement represent data structure particular way normally repercussions code case effects localised part interpreter translator 
advocates modular design arguments suggest solution localise design decision single module 
fundamental design decisions captured module 
highly portable design porting new operating system programming language greatly simplified middle language needs re implemented new machine implementation system written language copied change 
especially case hierarchy language levels developed starting middle level language implementing terms lower level language basis implementing higher level domain problem specific language 
case lowest level language need ported different machine operating system simple task 
reason high portability program web web programs ported megabyte tex web source file copied compiled change 
case fermat tool lowest level translator support library consists lines lisp code 
translates low level lisp rest system written 
port system new version lisp new base language requires rewriting lowest level translator comparatively small task fact version translator written man days 
fermat system currently ported unix environment pc environment lisp implementation language 
database language ported machines operating systems possible system written macro language built small core primitive database functions user interaction functions 
advantage portability exclusive language oriented programming similar advantage similar reasons claimed bottom development developments tools class libraries 
argued class library fact example domain specific language albeit highly restricted syntax 
opportunities reuse great potential re middle level languages similar development projects 
languages encapsulate great deal domain knowledge including knowledge data types operations execution methods important domain best ways implement 
kind knowledge extremely useful requirements elicitation new systems new system development program comprehension existing system 
opportunities reuse project including reuse language similar projects 
designed language generally reusable collection functions data types objects understand fact imagine writing typical program assembler compiler replaced large library assembler routines 
main advantages designed domain specific language new programming constructs combined orthogonally various ways 
case perl language provides convenient notation regular expression searches associative array handling programmer freed worrying memory allocation freeing 
foreach construct captures intricate details components statement terminal statements way programmer write programs manipulate terminal statements needing know precisely calculate 
area opportunities reuse particularly valuable companies serving niche markets 
companies produce range software specific domain competitive advantage coming specialised knowledge domain speedy response new product opportunities rapid turnaround users requests enhancements 
project recognised value capturing domain knowledge form language project 
aims encourage reuse design information program development projects domain languages recorded results domain analysis 
system development written number different domain languages programs refined languages domains ultimately executable code 
contrast approach approach uses single domain related development projects small domains project 
contention best representation domain knowledge programming purposes design implementation domain specific programming language 
domain languages implemented programming languages need refinement existing programming language 
user system system built hierarchy language levels top level language highly domain specific high level formally specified 
language certainly interpreted compiled lines code language sufficient implement operations software system interpretation overhead negligible 
suitable interface user provided high degree control functionality system calling editing code specific functions top level language powerful macro language access function system 
note implemented functions written language provide templates user modify enhance provide functions extend existing ones 
lowest level provides macro language user 
major problem macro query languages languages hoare basic principles language design see section 
formally specified designed scratch full programming language usually designed people trained language design familiar languages 
problem rare find systems functions available macro language 
contrast language provided language oriented development implement system designed fully tested language systems facilities guaranteed available language 
customisation system trivial 
easy give user power enhance system various ways writing functions top level language modifying ones provided cf qed fermat emacs see section 
user access source code system small program collection small programs highly domain specific language 
case qed source code lines interpreted code added lines code implement personal functions 
sparc executable interpreter high level language nearly megabyte code 
fermat transformation system includes transformations imple mented ranging size lines pages code 
users construct transformations composing existing transformations transformations automatically guaranteed correct writing new procedures 
fermat program manipulation system possible case system maintain enhance source code 
typesetting system written collection macros 
user able extend system writing macros commonly style files macros written people 
addition knowledgeable users modify standard style files achieve effects 
danger giving users full access source code system enhancements may degrade damage system period time 
serious damage caused user go back previous working version 
importantly enhancements total size system small complete reverse engineering system turns necessary fairly small task 
highest level language safe sense code written user meaningful terms problem domain crashing system unhelpful error code 
see section 
reasonable requirement toplevel language restricted small problem domain uses concepts operations domain 
example code interpreter qed default terminate loop executes iterations 
ample vast majority operations limit raised removed necessary 
result user hang editor writing endless loop 
fermat system user able construct new program transformations meta programs combining existing transformations tests 
provided editing operations invoked meta program carried existing transformations meta program valid transformation 
problems main problem introducing development method language design hard 
highly skilled task requiring grasp problem domain system requirements available options terms computer science technology 
benefits design enormous ways alleviate problems see 
emphasised aim de skill programming task opposite enhance abilities skilled designer domain expert 
aim capture useful body domain knowledge form domain specific language skilled programmer develop powerful useable system highly productive manner 
user system skill level required knowledgeable user reduced implementation language uses familiar domain concepts implementation provides templates show language achieve various results 
potential problem writing high level language distance programmer certain efficiency constraints programmer needs understand efficiency implications various constructs language 
may management issues address development method introduced successfully 
example programmers want start designing coding system unfamiliar kind high level thinking problem domain required produce middle level language design 
mathematics finding notation take half way solution example tensor notation calculus notation enabled mathematicians solve problems extremely difficult older notations 
similarly computer science great advantage suitable notation express certain classes algorithms writing yards source code 
example bird notation functions acting sequences 
language design better language design appropriate skills built applied developments 
potential problem designing programming language design tools needed support programming debugging language 
problem greatly alleviated suitable tools public domain commercial packages available assist building language parsers compilers interpreters 
simple interpreted provide debugging environment translator existing language available debugging tools language provided structure translator output roughly matches structure input 
low level optimisations constant propagation loop unrolling procedure inlining constant subexpression elimination safely left compiler 
middle layer middle layer language design may imperative functional object oriented lazy evaluated appropriate particular problem domain 
essential language precisely specified syntax semantics preferably formal notation set theory logic 
noted hoare basic principles language design valid today early 
security syntactically incorrect program rejected compiler interpreter translator executing syntactically correct program produce result error message expressed terms source code 
words core dumps segmentation violations 
implies instance array subscript access checked occurrence 
implies sensible restrictions pointers 
hoare comments respectable branch engineering failure observe elementary precautions long law 
brevity object code compactness run time working data cost highspeed memory fallen dramatically early true processors cheap comparison amount main store address backing store orders magnitude slower 
programmer nearly take advantage spare capacity increase program quality simplicity ruggedness reliability 
case system constructed series language layers principle vital layer compounded 
entry exit codes procedures functions compact efficient tightly coded machine code subroutines generally impediments convenient high level facilities language 
case gnu compiler gcc point taken stage compiler optimisation automatically select procedures functions turned inline code calling overhead 
language parsable single pass simple recursive descent parser compiler able compile quickly 
reasons ffl language read people prefer read single pass possible 
ffl modern multi window workstations compilation time generally wasted time ffl easier ensure correctness compiler structure compiler closely follows structure language 
clearly case parser 
interpreted language compiled translated language need rapid parsing human machine just great 
higher level languages highly domain specific efficiency interpretation important 
real done calling lower level language components 
language form basis user system simple syntax essential 
textual redundancy example requiring variables declared types procedure function arguments declared best protection programming typing errors extremely expensive detect running program expensive 
language design highly skilled task best languages produced single person small team high skill levels development team 
cf chief programmer teams approach programming language oriented approach maximises skill language designer encapsulates knowledge domain expert making available development team 
language designers ideally receive training design implementation existing programming languages possible 
able learn mistakes stand shoulders toes 
designers basic grasp different languages different paradigms imperative procedural functional higher order functions parallel languages communicating processes object oriented languages need training program specification notations especially set theory order logic 
precise formal specification middle level language essential success method 
needs training language implementation program analysis issues providing basic understanding implementation cost complexity various language features interact 
mixing lazy evaluation destructive update operations lists lead incomprehensible programs 
language typically include just procedures functions objects adts new constructs encapsulate aspects problem domain 
example language fermat includes construct iterating reachable terminal statements currently selected program 
construct enables complex editing operations required define certain program transformations written just lines code 
example event procedures qed executed certain conditions arise example event jump font numb called current editing position moved character different font 
general data types operations constructs language mixture general purpose domain specific constructs 
document typesetting system essentially defines typesetting language commands section headings mathematics enumerated lists parts document 
language encapsulates great deal knowledge high quality typesetting documents including calculate exact spacing items break paragraph lines lay complex mathematical equation 
fermat case study fermat program transformation system theory program refinement equivalence developed applied software development reverse engineering omitted comma fortran statement caused loss mariner venus probe statement silently re interpreted assignment new variable 
oft quoted comment programmers newton said seen farther stood shoulders 
problem programming stepping toes 

transformation system intended practical tool software maintenance program comprehension reverse engineering program development 
prototype transformation system called maintainer assistant written lisp 
included large number transformations academic prototype aim test ideas practical tool 
particular little attention paid time space efficiency implementation 
despite drawbacks tool proved highly successful capable reverse engineering moderately sized assembler modules lines equivalent high level language programs 
system semantic preserving transformations wide spectrum language called wsl 
language includes low level programming constructs high level non executable specifications 
means refinement specification implementation determine behaviour existing program carried means semantic preserving transformations single language 
version tool fermat decided extend wsl add domainspecific constructs creating language writing program transformations 
called 
extensions include data type representing programs tree structures constructs pattern matching pattern filling iterating components program structure 
transformation engine fermat implemented entirely 
implementation involves translator lisp small lisp runtime library main data types wsl runtime library high level constructs foreach fill 
aim tool maintain source code proved possible transformations applied simplify source code transformations 
aim test theories language oriented programming expected see reduction total amount source code required implement efficient powerful rugged system 
anticipated noticeable improvements maintainability portability 
expectations fulfilled achieving high degree functionality small total amount easily maintainable code current prototype consists lines lisp code previous version required lines lisp 
fermat design recursive application language oriented programming involving layers domain specific languages 

fairly high level general purpose language executable constructs wsl data type adt recording analysing manipulating programs fragments programs 
implemented lisp wsl lisp translator lisp runtime library functions procedures implement adt 
adt includes facilities loading saving programs moving records current selection current program editing operations 
consists lines lisp entire rest transformation engine written wsl code 
porting system language version currently development entail writing lines code 
top base wsl language implemented high level domain specific language writing program transformations called 
includes high level constructs involved writing transformations see example 
implemented entirely wsl extensions wsl lisp translator number wsl libraries compiled lisp linked translated 
encapsulates expertise developed years research program transformation theory transformation systems 
result expertise readily available programmers joined project 
working takes small amount training new programmers effective implementing transformations enhancing functionality existing transformations 
foreach construct example high level construct consider variants foreach construct 
foreach iterate components currently selected item satisfy certain conditions apply various editing operations 
construct takes care details example components deleted expanded edited 
consider procedure implementation transformation taken fermat system proc delete skips code data foreach statement spec type item skip delete fi od 
purpose transformation delete occurrences skip statements currently selected item 
skip effect transformation clearly valid 
various syntactic considerations shown examples skip od bg skip fi fi skip od abort var skip fi variant foreach construct iterates simple terminal statements 
components statement executed cause termination statement 
see detailed definition 
program simple terminal statements marked asterisk line line item number item write line exit fi item write line exit exit fi line line number fi od line item number od skip fi note second occurrence exit considered terminal statement reachable 
occurs part statement follows exit statement 
typical transformation involves finding simple terminal statements absorb right 
suppose previous program followed statement item error exit fi statement absorbed terminal positions preceding statement give equivalent version line line item number item write line item error exit exit fi fi item write line item error exit exit fi exit fi line line number fi od line item number od item error exit fi fi note absorbed statement incremented having exit statements increased value clause added appropriate exit inserted loops 
unreachable exit modified 
selected statement part action system collection mutually recursive parameterless procedures complexities arise 
action calls may return action subsequent called special action causes immediate termination action system 
regular action system action terminates action call action calls return absorbed action call 
hybrid action system true call complexities special cases dealt high level features foreach sts structure finds simple terminal statements increment deals moving statements lower depth gen improper 
tests insertion required case 
transformation implemented lines code taken directly fermat system proc absorb right code data right cut left foreach sts depth spec type item exit value item depth spec type item exit depth splice increment buffer type depth elsif gen improper item type skip elsif spec type item skip spec type item exit paste buffer paste buffer fi fi od 
examples language oriented programming described lop novel approach find examples successful large scale software development projects middle language layer 
necessarily developed middle order designing language provide formal specifications middle language 
simulation languages areas value domain specific languages recognised especially languages domain specific constructs monte carlo simulations 
interpreted language writing monte carlo simulations 
constructs include random sampling distributions management queues building histograms event event scanning 
csl control simulation language designed field complex logical problems 
uses set operations specialised constructs including iteration elements set finding element set meets various criteria 
csl compiled fortran ratio csl fortran statements order 
ratio time spent writing similar programs csl fortran order 
users reported problems previously tackled due difficulty formulation formulated little trouble 
qed word processor qed powerful mouse word processor implemented specially designed language interpreted functional high level language special data types operations document manipulation 
function key actions menus mouse operations implemented functions source code supplied generally lines code required implement function 
system consists lines code interpreter 
emacs text editor gnu text editor emacs implemented version lisp comes compiler interpreter emacs lisp 
qed function key bound emacs lisp function 
case system supplied lines emacs lisp code define editing modes various types file emulators text editors facilities 
typesetting programs knuth typesetting program written web literate programming language aim remove deficiencies pascal allow source code documentation intertwined source file 
implemented small set primitive typesetting operations macro processor 
plain set macros designed knuth form basic typesetting package 
extensive set macros built top modified plain package forms basis package 
package allows user concentrate structure text formatting commands 
effect implements structured typesetting language author uses implement document see section 
project currently developing new version planning language level built top macro language 
quote development team illustrates adopting explicitly middle style new development important interface programming language producing enhancements extensions entirely new language data structures operations suited kind programming required document processing applications expression visual components layout process 
built language high level generic functions allow straightforward expression common layout components 
perl larry wall perl interpreted language optimised scanning arbitrary text files extracting information text files printing reports information 
language system management tasks 
perl encapsulates part domain text file processing including pattern searching replacement arbitrarily sized strings arrays associative arrays provides uniform access mechanism various operating system functions 
effect perl programmer write highly portable moderately efficient code having worry memory allocation freeing hash table implementation optimised pattern matching incompatibilities operating systems similar details 
perl users reported order magnitude increase productivity text binary file processing applications prototyping simple user interfaces 
databases area database programs middle level language sql developed 
user theory purchase database program sql sql engine produced different 
database language designed macro processor top simple language 
language high level features database operations interactive manipulation screen data 
writing simple multi user interactive database requires lines code system software written language 
language implemented pascal ported wide range systems 
visual basic applications latest version spreadsheet high level programming language called visual basic applications 
fermat program transformation system fermat tool implemented translated lisp high level language designed implementing program transformation systems 
language constructs pattern matching filling program fragments schemas constructed looping statements terminal statements free variables see section details project 
potential applications method suitable editors word processors interactive databases interactive systems generally 
addition accounting software benefit suitable domain language especially frequent changes required keep pace changing tax regulations 
spreadsheets section discussing development large spreadsheet example financial model development spreadsheet package 
spreadsheet program thought high level language developing financial models cash flow forecasts applications figures arranged rows columns 
typical spreadsheet program fairly powerful input language facilities entering equations row column high level facilities manipulating rows columns blocks data 
spreadsheet created stored form array numbers strings formulae 
structure indicates cells belong groups cells related lost 
changes cell level imposing new structure trying remember original structure 
errors updating part column formulae time consuming track 
effect user entered program example large complex financial model high level language system immediately compiles low level language cells contents throwing away source code 
changes patching object code updating source code re compiling 
need domain specific languages higher level abstraction typical spreadsheet example language defining exercising financial models 
typical program language take raw accounts data produce cash flow forecasts balance sheet projections comparison methods top development top program development method called stepwise refinement advocated people way mastering complexity large programs constructing rigid hierarchical structure 
method starts high level description system developed may informal description formal specification 
specification refined top level structure gaps may formal specifications informal descriptions 
gap treated turn structure elaborated function re expressed terms operations simpler functionality 
idea small part program worked stage details keep track easy ensure structure correct 
component elaborated correctly stage theory program correct construction 
method successfully small examples severe problems emerge larger programs attempted 
specifications informally serious danger ambiguity misinterpretation 
example user specification interpret meaning implementor interprets different meaning 
led publication incorrect program 
formal specification language stage development theory ambiguities arise method leads valuable separation concerns user implementor specification 
implementor need know program specification user need know specification implemented practice may efficiency concerns 
refinement calculus morgan example approach software development 
successfully development number small programs specification implementation 
major problem approach method provides clue top level structure look particular case 
problem understood toy programs top level structure obvious 
large programs choosing wrong structures initial stages serious repercussions uncovered development 
serious mistake development repeated point mistakes early stages development 
example problem described 
case studies designed evaluate suitable different flavours object oriented analysis different types system 
case studies real project develop engagement system missile 
developers divide missiles subclasses navigational properties 
categorised tactical exercise missiles 
taxonomies entirely orthogonal suggested multiple inheritance categorisations 
development orthogonality broke types exercise missiles carry nuclear missiles 
continuing original top level design produced inelegant artificial models exceptional case buried mass details easy bottom development bottom development starts implementing lowest level general purpose utility routines 
implement higher level routines data types 
higher level routines data types increasingly domain specific problem specific 
eventually top level structure program implemented 
advantage method unit testing partial integration testing carried stage development 
performance various subsystems monitored development process 
general purpose domain specific routines reused different development projects 
development project domain presumably able previous 
may difficult especially middle stages development determine precisely build order ensure real progress 
high level routines may turn implement wrong functions example may may really required 
may needed 
cases wasted development 
top design problems greatly exacerbated application novel previous experience indicate kinds high level routines useful 
top development absence formal specifications user routine may different interpretation behaviour implementor routine case user implementor person 
providing concise formal specification routine developed minimise risk allow top development routine 
outside development outside development combination top bottom developments working parallel team designers start high level specification refined code 
time team implementors commonly team start implementing useful utility routines domain specific data types 
hopefully developments meet middle 
method designers implementers start straight away parallel may advantage lot people kept busy 
implementation team may able re previous projects 
unfortunately design method appears combine problems top bottom design worst worlds 
additional problem getting top design bottom implementation meet may significant gaps teams products overlap teams implement similar functions 
large development project priori reason suppose set implemented functions particular stage top design particularly close match functions provided bottom implementation 
middle development previous sections covered top bottom outside development methods suggested severe problems scaled large software system developments 
top decomposition analyst complete concept system 
bottom development tell lower level developments fit big picture 
outside development started determined boundaries system environment major design decision 
obvious missing method order complete pattern middle development 
mean start middle abstraction hierarchy outwards higher lower levels abstraction 
middle layer hierarchical design 
claim middle layer forms starting point middle development high level language machine specially designed easy implement kind software system required 
middle development fact descriptive name language oriented programming 
rapid prototyping rapid prototyping approach requirements elicitation software development combined methods discussed 
observations 
easier design large complex system properly built similar system past effect reuse designer previous experience 
users difficulties articulating precise requirements system want quickly find 
rapid prototyping requirements elicitation program design method number releases planned development period 
initial release concentrates implementing major functions basic user interface aim get hands users quickly possible order start giving useful feedback 
matter releases quick hacks release complete re implementation scratch necessarily reusing actual code earlier prototypes 
old saying plan throw away anyway 
traditional program design called slow prototyping 
rapid prototyping language oriented programming language design principles discussed adhered language implementation simple task 
prototype parts system produced quickly aid suitable tools user interface toolkits suit simple user interface toolkit garnet language development toolkits txl eli 
experience prototype provide valuable input language design stage prototype 
giving users prototype design excellent method acquiring domain knowledge uncovering poor design decisions users point prototype 
domain knowledge captured design middle language available ftp cs virginia edu directory pub suit distribution gp cs cmu edu directory usr garnet garnet ca directory txl ftp cs colorado edu directory pub cs eli prototype implementation experience gained implementing prototype extremely valuable design middle layer language prototype 
combination rapid prototyping middle development prototype appear development approach large scale software development projects 
language oriented approach provides handle problem scale 
fundamental limit complexity software system manageable requires information understand component system component understood fully 
extremely difficult enhancements fix bugs fix introduce errors due incomplete knowledge 
best way reduce total size large system produce understandable system implement high level language 
way may possible repeat order magnitude increase productivity achieved moving assembler language high level programming languages 
current high level programming languages capture knowledge programming domain example programmer deal details register allocation subroutine parameter passing 
perl programmer deal memory management data type conversion 
higher level languages required capture domain knowledge example programmer deal complex rules concerned laying mathematical formulae programmer determine components statement terminal statements combine effects editing operations applied simultaneously complex program structure 
language oriented approach programming directly addresses problems large software systems discussed brooks see section 
complexity complexity language oriented system greatly reduced source code divided independent sections 
implementation system high level domain oriented language 
translator interpreter language 
strongly domain oriented nature middle level language means complex functions system implemented just lines code 
complexities domain concepts encapsulated language form data types new programming constructs 
user language concentrate domain level issues 
large system recursive application middle development involving language layers reduce complexity conformity domain oriented language conformity easier achieve example wages system written language uses concepts current tax regulations 
easier ensure system conforms complex requirements change small size source code domain oriented nature language means enhancements system trivial carried users see section 
addition porting new operating systems machines implementation languages simplified see section invisibility scope research visualisation complex system designs anticipated suitable high level domain oriented language able hide complexity domain specific objects operations language constructs 
easier designer ensure correctness design concentrating problem specific aspects 
supported serc science engineering research council project proof theory program refinement equivalence extensions 
bennett buxton helpful comments earlier draft 
bird lectures constructive functional programming oxford university technical monograph prg sept 
brooks silver bullet ieee computer apr 
brooks theory comprehension computer programs international journal man machine studies 
bull wsl program transformer conference software maintenance th th november san diego nov 
buxton laski control simulation language comput 

conway suit manual university virginia 
cordy txl programming language syntax informal semantics version dept computing information science technical report queen university kingston canada june 
curtis krasner field study software design process large systems comm 
acm nov 
dijkstra discipline programming prentice hall englewood cliffs nj 
freeman conceptual analysis approach constructing software systems ieee trans 
software eng 
se july 
henderson experiment structured programming bit 
hoare emperor old clothes acm turing award lecture comm 
acm feb 
kelly buxton interpretive program monte carlo comput 

knuth literate programming computer journal 
donald knuth addison wesley reading ma 
lamport document preparation system addison wesley reading ma 
littman pinto letovsky soloway mental models software maintenance empirical studies programmers soloway iyengar eds ablex norwood nj 
potts richter developing initial ooa models proc 
intl 
conf 
software eng los alamitos calif 

potts richter review state practice requirements modeling proc 
int requirements eng 
symp los alamitos calif 

macro buxton craft software engineering addison wesley reading ma 
morgan programming specifications prentice hall englewood cliffs nj 
morgan specification statement trans 
programming lang 
syst 

morgan robinson paul gardiner refinement calculus oxford university technical monograph prg oct 
myers dannenberg zanden marchal garnet comprehensive support graphical highly interactive user interfaces ieee computer nov 
neighbors approach constructing software reusable components ieee trans 
software eng 
se sept 
parnas designing software ieee trans 
software eng mar 
potts software engineering research revisited ieee software sept 
priestley ward multipurpose backtracking algorithm symb 
comput 
qed users guide de software farm avon 
soloway empirical studies programming knowledge ieee trans 
software eng 
se 
stallman emacs manuel free software foundation 
stallman porting gnu cc free software foundation sept 
waite lex yacc generate compiler university colorado technical report boulder colorado 
wall schwartz programming perl reilly associates cambridge ma 
ward proving program refinements transformations oxford university thesis 
ward recursion removal theorem proof applications durham university technical report 
ward derivation data intensive algorithms formal transformation submitted ieee trans 
software eng 
ward foundations practical theory program refinement transformation durham university technical report 
ward abstracting specification code software maintenance research practice june 
ward bennett practical program transformation system reverse engineering working conference reverse engineering may baltimore ma 
ward munro maintainer assistant conference software maintenance th th october miami florida 
wirth program development stepwise refinement comm 
acm 
wirth systematic programming series automatic computation prentice hall englewood cliffs nj 
wirth algorithms data structures prentice hall englewood cliffs nj 

