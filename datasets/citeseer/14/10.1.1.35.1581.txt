building program optimizers rewriting strategies eelco visser el benaissa andrew tolmach paci software research center dept comp 
science engineering oregon graduate institute box portland oregon usa dept computer science portland state university box portland oregon usa describe language de ning term rewriting strategies application production program optimizers 
valid transformations program terms described set rewrite rules rewriting strategies describe various rules applied order obtain desired optimization ects 
separating rules strategies fashion easier reason behavior optimizer compared traditional monolithic optimizer implementations 
illustrate expressiveness language describe simple optimizer ml intermediate representation 
basic strategy language uses operators composition choice recursion build transformers set labeled unconditional rewrite rules 
de ne extended language contextual rules arise realistic optimizer speci cations expressed rewrites 
show features basic extended languages expressed breaking rewrite rules primitive building blocks matching building terms variable binding environments 
gives low level core language clear semantics implemented straightforwardly optimized 
current implementation generates code strategy speci cation 
compiler components parsers pretty printers code generators routinely produced program generators 
component speci ed high level language program generator produces implementation 
program optimizers di cult labor intensive components usually developed manually despite attempts producing optimizer generators 
supported part air force materiel command contract national science foundation ccr 
appear hudak queinnec editors 
international conference functional programming icfp 
acm baltimore md september 
visser acm org benaissa cse ogi edu apt cs edu program optimizer transforms source code program program meaning cient 
level speci cation documentation optimizers set rewrite rules transform code fragments equivalent cient code fragments see table 
particularly attractive functional language compilers operate successive small transformations don rely analyses requiring signi cant auxiliary data structures 
paradigm provided conventional rewrite engines compute normal form program respect set rewrite rules 
optimizers usually implemented way 
algorithm produced implements strategy applying optimization rules 
strategy contains meta knowledge set rewrite rules programming language applied order control application rules guarantee termination optimization optimization cient 
ad hoc implementation rewriting system drawbacks implemented language support pattern matching haskell 
transformation rules embedded code optimizer making hard understand maintain reuse individual rules transformations 
secondly strategy specied level abstraction transformation rules making hard reason correctness optimizer individual rules correct 
host language awareness transformation domain underlying implementation domain knowledge optimize optimizer 
desirable apply term rewriting technology directly produce program optimizers 
standard approach rewriting provide xed strategy innermost outermost normalizing term respect set user de ned rewrite rules 
satisfactory usually case optimizers rewrite rules con uent terminating 
common encode strategy rules explicit function symbol controls rewrites allowed 
approach disadvantages ad hoc implementation rewriting described rules hard read strategies expressed low level abstraction 
argue better solution explicit speci cation rewriting strategies 
show program optimizers built means set labeled rewrite rules user de ned strategy applying rules 
approach transformation rules de ned independently strategy designer concentrate de ning set correct transformation rules programming language 
transformation rules independent strategies speci ed formally de ned strategy language 
highlevel speci cation program optimizer compiler generate cient code executing optimization rules 
starting simple unconditional rewrite rules atomic strategies introduce section basic combinators building rewriting strategies 
give examples strategies de ne operational semantics 
section explore optimization rules rml programs intermediate format ml programs 
example shows gap unconditional rewrite rules rewriting transformation rules optimization 
reason need enrich rewrite rules features conditions contexts 
order avoid complicating implementation ad hoc features re ne language breaking rewrite rules notions matching building terms section 
gives low level core language clear semantics implemented straightforwardly optimized 
current implementation generates code strategy speci cation 
section show core language encode highlevel rules conditions contexts 
section resulting language give formal speci cation rml rules earlier 
section describes implementation section discusses related 
rewriting strategies rewriting strategy algorithm applying rewrite rules 
section introduce building blocks specifying algorithms give examples application 
strategy language section extension previous authors 
terms represent expressions object language means rst order terms 
rst order term variable constant tuple terms application constructor terms 
summarized grammar tn tn represents variables lowercase identi ers represents constants uppercase identi ers integers represents constructors uppercase identi ers 
denote set variables set terms variables set ground terms terms variables terms typed means signatures 
simplicity presentation consider untyped terms section 
assume signature function mapping operators arities 
shorthand notation lists 
term tn denotes term cons cons cons tn nil constants considered constructors zero arity tuples considered constructed special constructor arity 
rewrite rules labeled rewrite rule form label rst order terms 
example consider calculus lists constructed cons nil boolean values true false de nes transformation rules constructor member mem member nil false mem member cons ys true mem member cons ys member ys rewrite rule speci es single step transformation term 
example rule mem induces transformation member cons cons nil mem 
member cons nil general rewrite rule de nes labeled transition relation terms reducts formalized operational semantics table 
reduct term denotes failure 
rst rule de nes rule transforms term term exists substitution mapping variables terms instance left hand side instance right hand side second rule states attempt transform term rule fails substitution instance instance membership example member cons cons nil mem note rewrite rule applies root term 
introduce operators applying rule subterm 

table operational semantics unconditional rules 
reduction graph traversal reduction graph induced set rewrite rules transitive closure single step transition relation 
forms space possible transformations performed rules 
instance path reduction graph induced rules mem mem member cons cons nil mem 
member cons nil mem 
member nil mem 
false 

test 









strategy algorithm exploring reduction graph induced set rules 
rewrite rules atomic strategies describe path length 
section consider combinators combining rules complex strategies 
operational semantics strategy operators de ned table 
fundamental operation compounding ects transformations sequential composition strategies 
rst applies succeeds applies 
example reduction path described strategy mem mem mem 
non deterministic choice chooses strategies strategy chosen succeeds 
instance strategy mem mem applies mem mem 
note due operator way strategy succeed 
non deterministic choice operator programmer control strategy chosen 
deterministic left choice operator biased choose left argument rst 
consider second strategy rst succeed 
operator give higher priority rules 
example rule mem mem overlapping rules 
express mem applied certain mem apply strategy mem mem mem 
strategies repeatedly apply rules dened recursion operator 
instance strategy test 
positive rules negative rules mem mem mem repeatedly applies rule mem possible rule mem mem applicable 
strategy fails mem mem applicable 
note higher precedence 
mem mem mem written mem mem mem 
table operational semantics basic combinators 
identity strategy succeeds 
conjunction left choice build optional strategy tries apply fails just succeeds failure strategy dual identity fails 
strategy test test strategy succeed fail having transforming ect negation strategy similar test tests failure see examples application operators section 
redex normal form call term redex transformed rule normal form 
generalize terminology general strategies 
redex normal form 
strategy de nitions order name common patterns strategies strategy de nitions 
de nition xn new ary strategy operator 
application sn strategies denotes instantiation xn sn ofthe body de nition 
strategy de nitions recursive higher order possible give strategy operator argument strategy operator 
example common pattern application strategy term possible 
expressed de nitions repeat repeat repeat strategy repeat applies times zero possible 
strategy repeat repeat succeed 
repeat de ne strategy repeat mem mem mem equivalent mem mem mem 
applies rules mem mem mem possible succeed 
ti 
ti tn tn tn sn tn sn 
ti ti tn tn tn tn ng ti ti 
ti ti tn tn tn ti ti tn ti si tn sn tm sn 
tn tn ti tn 
tn tn positive rules negative rules table operational semantics term traversal operators 
rules schemata de ne rule rules backtracking operationally non deterministic choice operator randomly chooses strategy apply fails backtracks attempts apply 
backtracking local rst strategy succeeds second attempted 
succeed order tried ect outcome larger strategy encompasses choice 
example suppose 


depending 
choice 
left choice operator local backtracking operator order alternatives tried xed 
strategy composed deterministic fails succeeds 
term traversal operators introduced apply strategies root term 
adequate achieving transformations 
instance consider extension list calculus concatenation operator conc cnc conc nil xs xs cnc conc cons xs ys cons conc xs ys application rule cnc leads opportunity apply rules root term 
example consider reduction path conc cons nil cons nil cnc 
cons conc nil cons nil cnc 
cons cons nil second step reduction application rule cnc second argument cons 
general want able apply transformation rules arbitrary depth term 
purpose introduce basic operators applying transformation children constructor 
operational semantics operators de ned table 
conjunction operators de ned su cient de ne wide range full term traversals 
fundamental operation term traversal application strategy speci child term 
strategy applies strategy th child 
succeeds child replaced result transformation 
fails application fails 
fails greater arity constructor term applied 
saw example cnc applies rule cnc second argument root 
congruence operators specify application strategies children terms constructed speci constructor 
term constructor dom corresponding strategy operator arity 
strategies strategy applies terms outermost constructor applies si th child example strategy cons applies cons terms applies head list tail 
example cons cnc equivalent cnc 
apply concatenation rules application conc eliminated strategy cnc cnc cons strategy terminates rule cnc applies rule cnc recursively applies strategy conc created tail list 
example congruence operators strategy map applies strategy element list map nil cons path congruence operators useful constructing strategies speci data structure 
construct general strategies traverse arbitrary data structures introduce operators 
operators de ned generically terms signature strategy applies child root succeeds succeeds child 
fails fails children 
case constants constructors arguments strategy succeeds children 
consequence strategy succeeds exactly constants 
allows de ne general traversal strategies 
example strategies apply strategy node term preorder top postorder bottom combination pre postorder topdown bottomup example strategy topdown cnc cnc tries apply rules cnc cnc term topdown traversal 
succeeds escape strategy dual applies nondeterministically child succeeds 
fails child succeeds 
particular fails constants succeed 
consequence strategy succeeds exactly non constants 
duals pre post order traversals de ned apply strategy exactly term traversing term top bottom order strategy rst tries apply root terminates succeeds 
fails root tries apply strategy children 
strategy rst tries nd application root 
fails succeed root 
instance strategy cnc cnc succeeds nds application rule cnc cnc term fails 
applies children 
succeed child applies children 
di erence succeed children 
analogue strategy de ned nds single subterm succeeds nds subterms possible applies 
soon succeeds subterm applied nodes spine aversion strategy nds subterms apply de ned applying subterms possible tried root 
succeed subterm succeed root strategy succeed 
analogous pre order strategies strategies perform single traversal term 
normalization strategy strategy keeps traversing term nds redexes 
examples wellknown normalization strategies reduce repeatedly nds redex term outermost repeatedly nds redex starting root term innermost looks redexes leafs term 
de nitions reduce repeat outermost repeat innermost repeat note de nition innermost reduction cient 
nding redex search redex starts root 
cient de nition innermost reduction 
innermost rst normalizes subterms strict subterms normal form 
tries apply root 
fails means term normal form normalization terminates reduct resulting applying normalized 
traversal strategies de ned wide range alternative normalization strategies de ned 
see examples alternative evaluation strategies 
case study rml optimizer rml strict functional language essentially similar core standard ml restrictions 
consider subset rml includes basic features functional languages basic constants integer boolean primitive built functions tuples selection bindings mutually recursive functions 
programs pre processed compiler rml normal form 
syntax restriction rml table 
table describes set meaning preserving source transformation rules rml 
transformations intended improve performance programs directly dead dead perform dead code elimination enabling improving transformations hoist hoist code 
depth discussions intent correctness rules refer reader literature transformation functional programs 
particular rules inspired 
sequel concentrate details implementation rules 
rules notation auxiliary notions write list phrases appropriate separator list type 
function vars produces set free variables expression 
expression safe contains calls side ecting primitives user de ned functions safe function guaranteed pure terminating 
expression small 
vars letrec fdec 
letrec fdec fdec vars hoist hoist 
vars safe dead letrec fdec 
fdec vars dead se 
se xg prop letrec se 
letrec rename se xg inline vars se vars small se sen ine select 
se sen ine se select 
letrec ine bjt 
tn types se xjc simple expressions fdec xn function declarations variable bindings se expressions se sen se sen se sen select se letrec fdec range variables constants primitive built functions integers expressions basic types types 
variable bound twice 
table syntax rml contains nested declarations inlining function body small increase size program measured number expressions 
straightforward implement rules rewriting system strategy combinators introduced previous section 
unfortunately case 
gap transformation rules simple rewrite rules de ned 
hoist hoist conform format 
conditions rules redundant case variable bound twice 
rules features provided basic rewrite systems 
dead dead conditional rewrite rules remove pieces dead code 
condition dead tests variable de ned occurs body 
condition dead tests functions de ned list function declarations occur body 
prop performs constant variable xj tj xi fresh variables safe table transformation rules rml propagation requires substitution free occurrences variable expression 
inline context sensitive rule replaces application function expression body function 
expressed context se 
inlining occur appears expressed vars se vars body small 
inline uses simultaneous substitution list expressions list variables 
furthermore rule renames occurrences bound variables fresh variables preserve invariant variable bound twice 
invariant simpli es substitution testing occurrence variable expression 
requires generation variables fresh respect entire program 
re ning strategy language rml example shows simple unconditional rules lack expressivity describe optimization rules programming languages need enriched rewrite rules features side conditions contexts support variable renaming substitution object variables 
applications need features list matching matching modulo associativity commutativity 
adding features ad hoc extension basic rewrite rules language di cult implement maintain 
desirable nd uniform method deal extensions 
take closer look features discussed observe strategy behaviour 
instance rule context left hand side right hand side seen strategy traverses subterm matches applies rule checking term occurs subterm term requires traversing 
creating complex primitives rules contexts break rewrite rules primitives matching term patterns building terms 
primitives implement wide range features strategy language translating rules features strategy expressions 
match 
ife wt build vars dom 

en sg ej 
sn tn en en tn sn 
en tn en en tn ng ti tn en ti ei 
ei ti ti ei ei ei tn en match wt build vars dom en sg ti ei tn sn sn ti ei tn 
tn tn positive rules negative rules match build scope rst de ne semantics matching building terms 
rewrite rule rst matches term left hand side producing binding subterms variables builds new term instantiating right hand side variable bindings 
introducing new strategy primitives match build break strategy match build 
requires carry bindings obtained match sequential composition build 
reason introduce notion environments explicitly semantics 
mapping variables ground terms 
denote instantiation term bye 
extension dom 
smallest extension ofe respect term ife dom dom vars 
formally de ne semantics match build 
extend reduction relation 
relation terms reducts relation pairs terms environments strategy transforms term transformed term extended denoted 
fails denoted 
operational semantics environment operators de ned table 
change format operational semantics re ected semantics operators introduced earlier 
remainder rules tables read follows transition 
denotes transition 
exceptions rules congruence 
see table de nitions extended semantics 
table operational semantics environment operators 
variable bound rebound different term 
variable name introduce variable scopes 
sg locally unde nes variables binding variable xi outside sg visible inside binding xi inside scope visible outside 
bindings variables ej denotes restricted strategy operator similar test operator section tries strategy returns original term succeeds 
keeps transformation environment 
operator encode local computation binds answer variable outside transforming term 
note de nition supports matching nonlinear patterns 
variable occurs pattern match succeeds occurrences bound term 
variable bound previous match match tothe exact term bound 
example consider strategy tests subterm de ned fx match test build match rst match matches pair terms binding build replaces pair 
traversal searches occurrence matching bound subterms 
strategy succeeds nds matching subterm 
test ensures predicate ect term applied 
implementation transformation rules strategy language consists match build atomic strategies rewrite rules combinators introduced section 
re ned strategy language implement transformation rules translating strategy expressions 
higherlevel view strategies low level features match build scope high level features conditions 
start de ning meaning unconditional rewrite rules terms strategy language 
unconditional rewrite rules revisited labeled rewrite rule strategy de nition fvars match build introduces local scope variables vars rule matches term builds binding obtained matching 
subcomputation transformation rules require subcomputation order achieve transformation left hand side right hand side 
instance inlining rule table applies substitution renaming expression right hand side 
clause basic extension rewrite rules achieve subcomputations 
rule corresponds strategy fvars match build rst matches tests nally builds strategy strategy ects environment order bind variables just tests property left hand side 
note transform original term ect canceled 
side ect environment matters 
boolean conditions conditions check predicate holds implemented strategies clause 
failure strategy means condition hold success means hold 
predicates user de ned strategy operators 
conditions combined means strategy combinators 
particular conjunction conditions expressed means sequential composition disjunction means choice 
conditions corresponds build instance encoding dead code elimination rule dead dead var tests subterm de ned safe tests expression terminating side ect free 
matching condition kind subcomputation application strategy term built variables left hand side matching result pattern variables right hand side notation shorthand match 
combined stands build match 
rst applies matches result binding variables 
application right hand side annoying introduce intermediate name result applying strategy subterm right hand side 
directly right hand side rule abbreviation hsi new variable 
notation denotes term speci occurrence subterm replacement byt subterm denoted 
contexts useful class rules left hand sides match xed pattern match top pattern inner patterns occur contexts 
instance consider inline select rules table 
contexts implemented clause 
rule 
context occurring left hand side right hand side corresponds rule fvars match build fresh variable 
strategy clause traverses subterm matching nd occurrences replaces result traversal bound righthand side rule 
note variables locally scoped common variables instantiated strategy operator speci ed conjunction contexts indicates strategy traversal 
determines rule applied 
example consider encoding select rule sel ses select 
ses ses uses traversal strategy replace occurrences select corresponding element record 
strategy index takes th element list ses simple 
encoding de ned rule translates rule sel ses 
ses fi match select build ses note variable local context traversal instantiated value 
discussed rules context 
rules context scope 
variable renaming important feature program manipulation bound variable renaming 
major requirement isto provide renaming object language independent operation 
means designer indicate binding constructs language 
done mapping binding construct list variables binds 
example rules map variable binding constructs rml list variables bind 
bind bind letrec 
ff match fdec build bind fdec xs xs rules couple additional rules indicating arguments constructs binding see appendix strategy rename renames bound object variables 
strategy uses built strategy new generates fresh names 
see appendix de nition 
rules strategy rml rules table presents speci cation rml optimization 
consists signature rewrite rules strategy de nitions 
signature de nes syntax object language optimizer 
rules section de nes individual transformation rules 
strategies section de nes strategies combining rules optimization algorithm 
module imports auxiliary modules de ned appendices 
observe speci cation rules close original rules table 
main di erence inline rule split rules 
rule inl handles case body function small inlined body letrec 
rule inl condition replaces exactly occurence application function body letrec 
achieve condition rule applied occur body letrec inlining rule followed application dead 
dead succeeds guarantees occur anymore 
strategies advantage approach separating speci cation rules strategies ability experiment alternative strategies set rules 
strategies optimize optimize rml transformation rules 
optimize optimize applying repeatedly rule terminating 
optimize optimize rst apply term 
strategy optimize uses generic strategies innermost see appendix apply rules 
strategy applies strategy positions term going term way back 
fails applications succeed 
succeeds know redex reduced 
repeat normalize term 
optimize uses generic strategies optimize uses properties rules order apply restricted way 
rst tries hoist root 
notice repeats hoist may reapply root hoist reapply application 
letrec expressions redexes 
case speci rules apply 
leads de ne sub strategy case compose non deterministically 
cases rst normalize body letrec expression 
try rules prop sel dead 
letrec rst normalize bodies functions letrec expression 
try inl inl succeed try dead 
inlining gives rise new opportunities optimization try reapply strategy term 
implementation strategy language implemented standard ml 
programming environment consists simple interactive shell load speci cations terms apply strategies terms interpreter inspect result 
simple inclusion mechanism provided speci cations 
current implementation implement sort checking rules strategies 
addition interpreter programming environment contains compiler generates code 
compilation non deterministic strategies reminiscent implementation prolog wam success failure continuations stack implement backtracking 
run time environment compiled strategies aterm library 
provides functionality building manipulating term data structure count garbage collection parser pretty printer terms 
important feature full sharing terms maintained hash consing reduce memory usage 
implementation experiment optimizer rml discussed 
performance results available 
compiler implements straightforward translation strategy expressions programs performs optimizations 
currently bootstrapping compiler specifying strategy language 
gives opportunity apply optimizations strategies 
levels optimization considering simpli cation expressions applying simple algebraic laws factoring common pre xes alternatives choices propagating knowledge matching history traversals 
considering automatic derivation re ned strategies specializing applications generic strategies speci rules 
example derive strategy style optimize strategy style optimize table 
alternative approach implementation language library functions general purpose language functional language ml haskell 
operator core language corresponding function de ned 
fact interpreter uses library 
advantage imple mentation run time environment borrowed host language 
general framework host compiler take advantage knowledge speci domain term transformation 
related program optimization attempts build frameworks program analysis optimization special purpose formalisms 
systems closest spirit probably 
system ideas term rewriting emphasize separating declarative speci cation rewrite rules strategy applying 
system support xed set pre de ned strategy options strategy rules tree 
options provided systems similar traverse tree top bottom traverse children left right right left rewrite node traversal iterate xed point reached 
strategy language easily implement options general purpose library de ne ne grained strategies needed 
numerous systems provide mechanisms generating transformation code appears er exible combination generic rule speci strategies 
dfa opt sharlit genesis primarily designed analyzer generator systems focused particular style analysis 
published descriptions give details transformation capabilities appears give user control transformation order 
opposite extreme khepera txl puma provide succinct primitives matching building subtrees part require tree traversal programmed explicitly imperative style node node 
txl includes searching version match operator behaves application strategy 
khepera provides built construct iterate immediate children node 
approaches high level description optimizations include aspect oriented programming advocates domain speci aspect languages describe optimization program ir trees practice lisp generally intentional programming provides library routines manipulating asts 
approaches particularly encourages separation rules strategies application 
strategies conventional term rewriting languages rewrite systems assumed con uent terminating strategies considered metalevel language design implementation 
particular algebraic speci cation formalisms asf sdf provide xed strategy normalizing terms respect set rewrite rules 
common implement strategies setting encode strategy rewrite system providing extra outermost constructor determines point term rewrite rule applied 
theorem proving xed strategies su cient theorem proved ways 
theorem proving framework lcf introduced tactics proving theorems 
tactic transforms goal proved list subgoals proof 
repeatedly applying tactics list goals reduced empty list indicates original goal proven 
series basic tactics provided including simpli cation tactic applies set rewrite rules xed strategy 
new tactics formed existing ones tacticals 
standard tacticals similar identity sequential composition left choice repeat strategy operators somewhat di erent semantics apply subgoal root term 
theorem proving domain need traversal tacticals 
speci cation formalism elan notion transformation goals list subgoals generalized arbitrary term rewrite rules 
strategies regular expressions set rule labels 
approach de ne constraint solvers consist rules rewrite list constraint new list constraints 
strategy repeatedly applies rules solution 
versions language set strategy operators extended congruence operators support term traversal 
elan provide generic traversal operators analogous 
traversals de ned explicitly datatype congruences 
recursive strategies expressed elan recursive strategy de nitions 
di erences elan negation test operators breakdown rules primitives 
elan xed syntax rewrite rules strategy language easily extended expressive features implemented terms core language 
maude speci cation formalism rewriting logic 
provides equations interpreted innermost rewriting labeled rules outermost strategy 
strategies applying labeled rules de ned maude means re ection 
language described inspired strategy language elan 
rst version described presents strategy language identity sequential composition choice recursion generic pushdown operator de ne 
design guided process algebra acp 
interpreter strategy expressions speci ed algebraic speci cation formalism asf sdf 
basic strategies unconditional asf sdf rewrite rules 
extended rst language operators failure negation test path congruence 
furthermore cater expressive set rules means breakdown rewrite rules match build scope 
addition current language implemented compilation technical contributions setting strategy languages include modal operators enable concise speci cation term traversal set general purpose traversal strategies explicit recursion operator re nement rewrite rules match build encoding complex rewrite rules strategies particular expression rules contexts 
describe core strategy language implement conventional term rewriting engines extended non standard evaluation strategies 
module rml imports traversal imports list imports substitution imports renaming imports rml aux signature sorts texp fdec se exp operations list texp texp texp type expressions list texp texp string texp texp string exp variable declarations fdec texp string list string exp fdec function declarations const texp string se simple expressions var string se simple se exp expressions record list se exp select int se exp papp string list se exp app se list se exp exp exp letrec list fdec exp exp rules hoist hoist letrec letrec dead var safe dead letrec map match fdec var prop simple se var simple se se inl letrec fdec xs app var ss letrec fdec xs xs ss small inl letrec fdec xs app var ss letrec fdec xs xs ss sel record ss select var record ss simple index ss ts letrec fdec ts xs ts app var ses safe new map new ts xs map xs ses strategies opt innermost hoist hoist inl inl dead sel prop repeat dead dead repeat dead dead optimize bottomup try repeat opt opt rec repeat hoist try hoist try id try prop sel try dead letrec id dead try letrec map fdec id id id id try inl try dead inl dead optimize bottomup try opt table speci cation rml transformation rules illustrated separating transformation rules application strategy promote concise understandable descriptions complex rewriting tasks 
example compiler optimizer takes lines corresponding handwritten standard ml code lines 
completely alter optimizer rewriting strategy changing just lines add new transformation rule inserting tag appropriate place strategy similar changes ml version require extensive structural edits code 
concentrate program optimizers believe techniques equally applicable areas source source transformations including simpli cation typechecking interpretation software renovation 
bas discussions started strategies 
ideas didn included 
implementation strategy language speeded considerably tim sheard programs generation code pieter olivier aterm library 
eugenio moggi philip wadler remarks semantics patricia johann remarks previous version 
hassan kaci 
warren machine 
tutorial reconstruction 
mit press cambridge massachusetts 
william aitken brian paul oege de moor david richter charles 
transformation intentional programming 
proceedings june 
appear 
andrew appel 
compiling continuations 
cambridge university press 
andrew appel trevor jim 
shrinking lambda expressions linear time 
journal functional programming september 
uwe 
uniformly specify program analysis transformation graph rewrite systems 
proceedings compiler construction number lecture notes computer science 
bergstra klop 
process algebra synchronous communication 
information control 
peter claude kirchner kirchner 
controlling rewriting rewriting 
jose meseguer editor proceedings international workshop rewriting logic applications volume notes theoretical computer science asilomar paci grove ca september 
elsevier 
manuel clavel steven eker patrick lincoln jose meseguer 
principles maude 
jose meseguer editor proceedings international workshop rewriting logic applications volume electronic notes theoretical computer science pages asilomar paci grove ca september 
elsevier 
james cordy ian russell halliday 
txl programming language version april 
van deursen heering klint editors 
language prototyping 
algebraic speci cation approach volume amast series computing 
world scienti singapore september 
faith lars jan prins 
khepera system rapid implementation domain speci languages 
proceedings usenix conference domain speci languages pages october 
charles donald 
pattern languages prototyping compiler optimizers 
phd thesis university california berkeley 
technical report csd 
pascal fradet daniel le metayer 
compilation functional languages program transformation 
acm transactions programming languages systems january 
gordon milner wadsworth 
edinburgh lcf 
mechanised logic computation volume lecture notes computer science 
springer verlag berlin 
joseph 
puma generator transformation attributed trees 
technical report gesellschaft fur mathematik und mbh der universitat karlsruhe november 
gregor kiczales john lamping anurag mendhekar chris maeda cristina lopes jean marc loingtier john irwin 
aspect oriented programming 
technical report xerox palo alto research center 
kirchner kirchner vittek 
implementing computational systems constraints 
kanellakis 
lassez saraswat editors proceedings rst workshop principles practice constraint programming pages providence usa 
brown university 
marion klein jens knoop dirk bernhard ste en 
dfa opt toolkit program analysis optimization 
proceedings nd international workshop tools algorithms construction analysis systems tacas volume lecture notes computer science pages passau germany march 
springer verlag 
peter ulrich reinhard wilhelm 
language system speci cation program transformations system overview experiences 
proceedings nd workshop compiler compilers high speed compilation volume lecture notes computer science pages october 
bas eelco visser 
speci cation rewriting strategies 
sellink editor nd international workshop theory practice algebraic speci cations asf sdf electronic workshops computing berlin november 
springer verlag 
andrew 
denotational semantics functional tree manipulation language 
computer languages 
robin milner mads tofte robert harper david macqueen 
de nition standard ml revised 
mit press nd edition 
pieter olivier 
term data structure library api 
programming research group university 
unpublished software documentation 
peyton jones santos 
transformation optimiser haskell 
science computer programming 
appear 
steven tjiang john hennessy 
sharlit tool building optimizers 
acm sigplan conference language design implementation july 
andrew tolmach dino oliva 
ml ada strongly typed language interoperability source translation 
journal functional programming 
appear 
eelco visser el benaissa 
core language rewriting 
kirchner kirchner editors second international workshop rewriting logic applications electronic notes theoretical computer science france september 
elsevier 
deborah eld mary lou design implementation genesis 
software practice experience march 
auxiliary strategies rml module rml aux de nes predicates small safe 
furthermore de nes strategies substitution rml expressions renaming bound variables rml 
strategies instantiations language independent strategies subs appendix rename appendix 
module rml aux imports substitution imports renaming strategies small simple id record id select id id papp id id app id id safe app id id match papp assign rules isvar var var bind bind letrec map match fdec build bind fdec xs xs fdec xs fdec xs zip fs fs strategies subs isvar rn apply bnd id hd bnd fdec id id bnd letrec bnd rename isvar bind bind bind traversal strategies appendices sets generally applicable strategy operators 
note stand respectively 
module traversal strategies try id repeat rec try repeat repeat bottomup rec topdown rec rec rec rec rec rec rec try rec try rec try try try rec reduce repeat rec outermost repeat innermost repeat innermost rec try match test match list strategies module list signature operations nil list cons list list rules hd cons xs ind cons xs ind cons xs minus xs geq strategies index repeat ind ind map rec nil cons tail rec nil cons id fetch rec cons id cons id rules conc tail build lookup fetch match zip nil nil nil zip cons xs cons ys cons xs ys strategies zip rec zip zip substitution strategy subs isvar applied triple xs ts list strings xs list terms ts term replaces occurence variable xs corresponding term ts parameter strategy isvar rule choice rules maps term representing object variable name 
typically rule form var strategy rst matches arguments 
zips string list term list get table tbl associates variable names terms tobe substituted 
fails xs ts lists different length zip fail 
traversal term replaces variable occuring table target 
note strategy stops application argument strategy 
necessary avoid applying substitution terms substituted 
strategy assumes bound variables renamed variable bound twice 
module substitution imports traversal imports list rules fetch match strategies subs isvar tbl xs ts match xs ts zip id xs ts tbl isvar build tbl renaming strategy rename isvar bnd renames bound variables term new variables 
parameterized strategies express variables binding constructs language 
parameter isvar recognizes variables maps name 
parameter maps string variable 
parameter bnd maps binding construct list variables binds 
addition user specify strategy operator rn apply variable binding construct applied subterm containing variable applied subterms variables bound applied subterms variables bound 
example see appendix module renaming imports traversal imports list strategies rename isvar bnd match build rec ren match build rec ren isvar lookup build xs ys bnd xs map new ys conc zip id xs ys rn apply build ys match build ren match build ren ren 
