scalable object tracking unattended techniques scout satish kumar alaettinoglu deborah estrin isi edu information sciences institute university southern california scalable object location service enable users search various objects environment small networked devices attached objects 
investigate hierarchical self configuring unattended approaches efficient object location service 
approach advantages disadvantages anticipated load 
approach scout agg aggregation object names 
second approach scout map indirection information object stored locator sensor object 
relative efficiency scout agg scout map characterized query mobility update rate system 
scout agg performs better low query update rate performance deteriorates general relative scout map query update rate increases 
rate performance deterioration depends query specificity queries specific object object particular type 
scout map generally exhibits better load balancing scout agg various scenarios 
support results simulation 
computer networks rapidly ubiquitous advances technology 
wireless technologies bluetooth enable networking small low cost devices pdas domestic appliances 
networks sensors sensing actuation signal processing wireless communications module rapidly available deployment 
developments possible envision homes places equipped hundreds thousands small networked devices ordinate perform various tasks 
expect key application environment object location service 
users may desire service locate various shared objects projectors cameras common items coffee keys 
key challenge ability locate particular object scalable fashion hundreds thousands monitored objects 
examine object location problem assuming office environment people objects tagged unique pre programmed ids 
sensors monitor location tagged objects communicate form network 
user wishes find location person building projector presentation simply queries network information 
queries need efficiently directed appropriate sensors 
network may contain thousands sensors monitoring tens thousands objects 
large sensor networks techniques manual configuration individual sensors impractical 
centralized solutions scale number mobility objects query rate increases :10.1.1.12.1285
self configuring unattended distributed techniques required 
service discovery versus object location service discovery ip networks similar object location problem object location service needs deal larger system scale volatility mobility :10.1.1.12.1285
addition unattended operation key requirement object tracking service manual configuration large number sensors impractical 
service discovery techniques focussed efficiently answering complex queries matching various attributes scaling large number objects difficult 
exception service discovery service sds proposal scales larger networks hierarchy aggregation object names :10.1.1.12.1285:10.1.1.12.1285
solutions similar ideas 
describe aggregation solutions shortcomings object tracking scenarios 
investigate performance simple query types locating unique object joe 
locating object particular type projector 
address com plex queries find available conference room closest available copy machine attendees quickly copies presentation documents 
may possible resolve queries breaking simpler queries support 
describe key requirements object location service followed description possible approaches 
requirements location service main requirements location service scalability location service able support large number sensors mobile objects 
expect hundreds thousands mobile objects monitored thousands sensors 
unattended operation entire location system able operate configuration manual configuration thousands sensors single building site impractical 
robustness failures location system robust sensor failures 
sensors achieve efficient operation diverse network dynamics 
adaptation offered load load sensors balanced 
especially important sensors homogenous available resources strain resources energy sensors drastically affects system performance 
approaches simplest distributed solution object location flood queries network 
solution maintains minimal state sensors 
extreme information monitored objects flooded sensors network queries answered locally low latency 
approaches obviously excessive state bandwidth requirements scale poorly increase number sensors objects network 
hierarchical solution needed achieve better scaling 
examine hierarchical approaches tackle scaling problem 
hierarchy form aggregation distant sensors detailed view 
indirection object mapped home locator sensor sensor stores information object 
case hierarchy needed efficiently route messages network 
schemes advantages disadvantages anticipated load 
focus studying trade offs associated approaches identify conditions approach better 
refer aggregation approach scout agg 
approach sensors organize hierarchy higher level sensors summarize distribute concise information objects sensed child sensors 
remote sensors summary information direct queries sensors detailed information particular object till relevant sensor reached 
approach forms basis various hierarchical routing schemes internet proposed resource discovery sds :10.1.1.12.1285:10.1.1.12.1285
aggregation approaches suffer inefficiencies applied object tracking context 
approach sensor forwards query relevant child sensors summaries indicate object may sub tree 
aggregation usually leads loss information parent sensor know certain object located particular child branch 
query needs forwarded hierarchy till root reach relevant branches ensure response 
addition queries may need forwarded sensor child sensors object summaries child sensors indicate may object degenerate flooding worst case refer second indirection approach scout map 
approach sensors hash function map object name sensor address similar name resolution scheme landmark routing locator sensor object 
address sensor monitoring object object location stored locator sensor object 
querier performs algorithmic mapping object name derives address locator sensor 
locator sensor contacted object location address sensor monitoring object sensor needs contacted obtain information object projector ok 
indirection approaches dns dynamic data difficult self configure 
approaches appropriate context 
mobile ip uses maintain query state sensors intermediate levels queries forwarded hierarchy object available sensor sub tree 
maintaining query state limits scaling system query rate grows 
concept home agent keep track mobile hosts 
hosts know home address specifically dns translate name mobile host home address mobile host 
host address contact home agent obtain current location mobile host 
context need scalable mechanism find home agent particular object 
approaches indirection suffer inefficiencies relative aggregation schemes mobility objects network dynamics exceeds certain threshold 
objects move scout map locator sensor needs updated advertised summaries higher levels may change time object moves 
scout map employs multi level mapping reduce mobility update overhead 
sensor maps object local locator sensor close maps object global locator sensor 
excessive rate network dynamics indirection schemes inefficient objects may need re mapped different locator sensors topology change 
summary findings ffl relative efficiency scout map scout agg schemes characterized ratio query rate mobility update rate system 
high query update rates scout map performs better scout agg overhead mobility updates offset efficiency answering queries 
low query rates performance scout agg better scout map due efficient mobility update procedure low query update rates flooding better scout map overhead object mobility minimal flooding updates need generated object moves 
ffl query update ratio scout map better scout agg depends type queries 
cross ratio lower queries unique objects person book compared case queries object certain sub type projector refer query unique object specific query query object certain sub type non specific query 
specific query answered efficiently scout map query update rate scout agg better scout map depends type aggregation distribution objects various types 
simply contacting locator sensor object query may need travel branches hierarchy scout agg 
case non specific queries overhead scout agg smaller specific query probability finding object certain sub type close querier sensor higher 
ffl load balance sensors different hierarchical levels scout agg poor queries need go higher levels ensure correct response 
scout map uses hashing uniformly distribute locator sensor objects network query processing load evenly distributed sensors 
section description scout agg scout map schemes 
compare schemes simulation section discuss impact parameters comparison section 
discuss related section conclude section :10.1.1.12.1285
description schemes describe key components scout map schemes assuming underlying hierarchy sensors adapts network dynamics 
describe automatic hierarchy construction common component schemes section 
scout agg scheme describe simple naming schema objects rules aggregating object names distant sensors detailed view 
describe query processing rules followed processing rules handle object mobility network dynamics 
naming aggregation assume simple attribute value pair naming schema objects 
objects attribute 
object name attribute hierarchical value defined object class hierarchy 
example object name projector conf equipment projector unique projector id complete description projector naming schema object name conf equipment projector location status busy :10.1.1.12.1285
object name conf equipment projector location status busy object name conf equipment projector location status busy level object name conf equipment projector object name conf equipment object name conf equipment projector level level aggregation object names object name conf equipment projector location status busy object name conf equipment projector location status busy object name conf equipment projector object name conf equipment query conf equipment projector object name conf equipment projector query direction components scout agg defined object class hierarchy perform aggregation :10.1.1.12.1285
example level sensor receives information projectors child sensors names object name conf equipment projector location status busy object name conf equipment projector location status busy aggregates object name conf equipment projector :10.1.1.12.1285
observed attributes projector object advertised level sensors dropped level parent sensor 
note level sensor advertise full name projector projector reported child sensors 
aggregation repeated successively higher levels till object name consists root object types object class hierarchy 
level aggregated name object name conf equipment 
higher level sensors aggregate name conference equipment root object type 
query processing mentioned earlier consider types queries specific queries conf equipment projector non specific queries conf equipment projector :10.1.1.12.1285
queries issued users closest sensor 
queries users travel hierarchy aggregate information 
sensor receiving query user checks local database requested information 
sensor requested information sensor attaches id query forwards query level parent 
level sensor receiving query checks requested information database 
level sensor relevant information sensor checks list objects monitored child sensors forwards query relevant child sensor note level sensor complete names objects monitored child sensors 
child sensor relevant information level sensor forwards query level parent sensor 
forwarding message level sensor adds id query 
level parent sensor aggregate information objects monitored child sensors level sensor forwards query relevant child sensors parent sensor 
level sensor adds id query forwarding query 
query records ids parent child sensors message travels 
process continues leading replica query reach root get forwarded branches root 
fashion query reaches sensor monitoring object example 
sensor requested information sends back response querier reverse path recorded route query packet 
note route recorded query order number hierarchical levels increases logarithmically number sensors network 
querier sensor may get multiple responses queries query object certain sub type query projector 
higher level sensor level receives non specific query may pessimistically forward query child sensors ensure correct response deduce aggregates child sensors object certain sub type definitely available sub trees child sensors 
sensors monitor object sub type may reached generate responses back querier 
handling mobility objects object moves sensor sensors generate update message parent indicating change 
parent sensors recompute aggregates receiving updates child sensors 
aggregate list changes parent sensors send update message parents 
process continues till higher level sensor aggregate list remains unchanged reached may root worst case 
update message sensor longer sees object delayed short update message sensor sees object may reach higher level sensors 
reduce number update messages triggered hierarchy prevent case object summarized available hierarchy object summarized available shortly monitored adjacent sensor 
handling network dynamics adaptation underlying hierarchy network dynamics described section 
simply describe rules keep aggregates date 
higher level sensor loses children gains new child higher level sensor recomputes aggregates 
aggregate list changes update message sent parent sensor 
process repeats till sensor aggregate list remains unchanged reached 
parent sensor changes child sensor sends update message aggregates new parent 
scout map scheme describe various components scheme 
description hierarchical addressing routing scheme landmark routing scout map followed description process objects mapped locator sensors 
describe queries processed mapped information 
describe techniques handle mobility objects network dynamics 
hierarchical addressing routing describe main features hierarchical addressing routing scheme sensors route messages 
assume underlying hierarchy sensors single sensor root hierarchy 
parent sensor assigns consecutive integer labels child sensors starting number children parent sensor 
label child sensor unique siblings 
root sensor assigns label 
hierarchical address sensor particular level defined concatenation labels ancestors example root sensor assigns label assigns label child assigns label child turn assigns label child addresses respectively 
sensors particular level associated radius 
radius specifies number physical hops sensor advertisements travel 
sensor advertisement carries hierarchical address sets routing state simple distance vector style intermediate sensors reach advertising sensor sensor advertisements carries sensor level hierarchy number children 
sensors higher levels larger radii lower levels 
levels radii hops respectively 
sensor root sensor radius infinity advertisements flooded network 
sensor said vicinity higher level sensor distance higher level sensor equal radius higher level sensor 
example sensors hops said vicinity routing information reach information hierarchical level number children routing different sensors done longest note sensors unique pre programmed ids hierarchy construction process 
hierarchical addresses sensors identify sensors routing purposes 
sensors simply record shortest path received advertisements sensors 
global lm hops hops hops entire network hierarchical addressing sensors dst dst dst mapping object locator sensor components scout map match routing 
example sensor wishes reach sensor direct message root sensor vicinity 
message reaches sensor vicinity sensor forwards message sensor 
way sensor message reaches vicinity forwards message 
message way reaches sensor vicinity gets forwarded 
note parent child sensors ensuring reachability destination addresses 
mapping object names locator sensor address describe process locator sensor particular object 
basic idea sensor define locator sensor address amount hierarchy information available 
address gets refined message object information call map message travels actual location locator sensor 
illustrate process example see sensor wishes store information object unique object id locator sensor 
suppose root sensor children sensor children sensor children 
ffl initializes address locator sensor label root sensor levels hierarchy 
ffl hashes object name set number children obtains label 
sets locator sensor address 
ffl vicinity sensor simply sends map message destination address reaches vicinity 
ffl hashes object name set number children sensor obtains 
locator sensor address set 
ffl vicinity sensor sends map message destination address reaches vicinity 
ffl hashes set number children sensor obtains 
sets locator sensor address 
ffl labels address filled locator sensor 
sends map message 
ffl locator sensor stores information address sensor monitors location ordinates 
locator sensor sends acknowledgment message sensor mapping process done reliably 
sensor example waits acknowledgment message locator sensor re initiates mapping process message received time delay 
delay increased exponentially till certain upper limit subsequent re mapping response received locator sensor 
acknowledgment message locator sensor carries address locator sensor :10.1.1.12.1285
information stored sensor monitoring object handle network dynamics see section 
object information stored locator sensors soft state need periodically refreshed possibly low frequency hours 
multi level mapping done improve efficiency answering queries local objects 
example store information close locator sensor 
achieves fixing levels local locator sensor address map message 
example address local locator sensor sub tree rooted sends map message initial locator address 
message follow steps previously described reach local locator sensor object 
local locator sensor stores object information sends acknowledgment generates regular map message global locator sensor procedure described example section 
query processing query object sensor sends directory query message locator sensor procedure previous section 
locator sensor receiving directory query message looks object information entries find entry 
case location desired locator sensor sends object response message querier sensor information 
locator sensor sends object query message object monitoring sensor 
receiving object query message object monitoring sensor generates object response message requested information querier sensor 
note querier sensor reached hierarchical address carried query messages 
case multi level mapping querier generates directory query message local locator sensor 
local locator sensor relevant information directory query message forwarded global locator sensor 
multilevel mapping done global locator sensor information particular local locator sensor information object 
directory query message forwarded global locator sensor local locator sensor object query message generated sensor 
handling mobility objects sensor seeing new object generates map message local locator sensor case multi level mapping directly global locator sensor 
case local locator sensor generates map message global locator sensor seen time local locator sensor 
sensor longer sees object generates negative map message sent reliably relevant locator sensor 
case multi level mapping message generated short delay map message generated sensor sees object may reach locator sensor earlier negative map message 
map messages carry time stamps 
object leaves sensor range comes back sensor range small delay negative map message previously generated sensor object ride new map message due order delivery messages 
network dynamics sensors may need re map objects topology change 
periodic re mapping objects done period configured expected level network dynamics 
frequent re mapping objects may required high network dynamics unfortunately consumes lot resources 
consider approach objects periodically re mapped low frequency appropriate re map messages triggered topology change 
mainly parent sensor re assigns addresses child sensors parent sensor floods gen map message network address 
example level address assigns new addresses child sensors due addition deletion child sensor floods gen map message address network 
gen map range communicated reliably root sensor root sensor include range global advertisements 
object monitoring sensors local locator sensors case multi level mapping remap objects locator sensors fall range 
root sensor advertisements carry gen map address range time topology change occurred take care losses original gen map message 
newly elected root sensor floods special gen map message causes sensors re map objects monitor 
mechanisms suffer higher overhead high network dynamics schemes aggregation show section 
automatic hierarchy construction describe process sensors automatically organize hierarchy adapts network dynamics 
scout agg schemes hierarchy scaling 
sensors start lowest level radius hops 
sensor sends periodic advertisements sensors hops 
sensor achieves setting initial ttl advertisement sending advertisement neighbours 
sensor receiving advertisement decrements ttl forwards advertisement ttl nonzero sensor forward advertisement smaller ttl sensor advertisements carry sensor hierarchical level id parent 
sensors wait certain wait time proportional advertisement radius order allow advertisements sensors reach 
wait period level sensor starts promotion timer chosen parent 
promotion timer inversely proportional number sensors level advertisements received 
cause sensors located relatively dense regions smaller timeout values 
promotion timer value decreased level advertisement received previously node 
promotion timer expires sensor promotes level starts sending periodic level advertisements radius advertisements newly promoted sensor lists potential child sensors level sensors advertisements previously received 
level sensors appear potential children list choose level sensor parent 
ensures parent child relationships established sensors see advertisements able communicate 
level sensor sees potential child level sensor advertisement picks closest level sensor parent includes parent id subsequent level advertisements 
parent sensor initially naive rule flood sensor advertisements vicinity sensor floods advertisement neighbours ttl received advertisement decrement greater zero sensor seen advertisement 
network slight load queuing delays may cause sensor receive sensor advertisement longer path gets message shorter path message received longer path smaller ttl received shorter path 
naive rule subsequent advertisement higher ttl forwarded prevents sensors edges vicinity receiving advertisement 
hearing level advertisement adds id level sensor list child sensors addition list potential child sensors advertisements 
level sensor picks parent cancels promotion timer drops election process 
promotion level level sensors start promotion timer level hear level sensor 
hierarchy construction completed 
level sensors re start election process subsequently hear advertisement level sensor 
case level sensors set promotion timers inversely proportional number level sensors hear 
note greater ensure level sensor see level sensor multiple level sensors exist 
general radius sensors level greater gamma ensure level sensors see level sensor exist 
process performed recursively sensors level construct multi level hierarchy 
sensor re starts election process receive periodic advertisements parent sensor certain period 
similarly parent sensor drops sensor children potential children list hear advertisements sensor certain period 
level sensor may demote children potential children subset level sensor potential children 
criteria satisfied level sensor sees level sensor parent demotion 
add random component timer values prevent sensors oscillating different hierarchical levels potential children level sensors identical 
discussion rules prevent oscillations scope 
comparison scout agg scout map schemes compare bandwidth overhead incurred scout agg scout map schemes various scenarios ns network simulator :10.1.1.12.1285
consider query loss rates scenarios involve sensor failures 
stated scenarios consist connected topologies wireless sensors transmission range meters objects randomly distributed rectangular region meters 
sensor monitors random number objects 
sensors self organize hierarchy generate periodic refresh messages seconds random jitter hierarchy maintenance 
sensor generates mean queries hour randomly chosen objects 
queries directed relevant sensors scout map scheme 
simulate system performance seconds result averaged simulations different topologies random number seeds 
aggregation purposes create objects level hierarchical names simulations names form represents object type represents object sub type unique id objects sub type 
chose types average sub types type simulations 
discuss depth object class hierarchy number types subtypes affect overhead schemes section 
query messages carry object name scheme specific information 
scout agg query messages carry source route order number hierarchical levels 
assume object names bytes ids sensors carried source route bytes 
names aggregates higher level sensors scout agg bytes 
scout map assume hierarchical addresses bytes 
messages carry byte time stamp sequence number loop prevention 
assume responses fixed size bytes 
assume packets header size bytes ip header size 
model packet losses due radio interference simulations 
perform level mapping object object sub type scout map sensor monitors object stores information object local locator sensors object object sub type store information corresponding global locator sensors 
mentioned level mapping improve efficiency answering queries near objects reduce mobility update overhead 
sensor chooses local locator sensor object fixing labels highest levels locator sensor address address hierarchies greater levels object id hashed obtain labels remaining levels 
simulations queries sent sensors monitoring relevant object generate response querier sensor locator sensors directly respond querier sensor information queried object 
performance different types queries specific queries mean bytes transmitted node vs specific queries query hour sensor sensors objects scout agg scout map overhead increase specific queries shows overhead scout agg scout map percentage specific queries increased scenario objects static :10.1.1.12.1285
scout map performs better scout agg queries specific 
scout map specific queries answered simply contacting locator sensors objects query may travel sensors advertised object sub type scout agg 
example query travel sensors advertise aggregate 
performance scout agg better scout map queries non specific non specific query answered frequently nearby sensor specific query 
example query object simply needs travel branch advertises aggregate 
query need travel hierarchy intermediate sensor advertises aggregate reached 
scout map local locator sensor object sub type needs contacted answer non specific query 
overhead answering query high scout agg object located close querier sensor 
query answered locally reaches sensors higher levels query forwarded branches advertised aggregate 
overhead scout agg scout map specific queries higher overhead queries scout agg 
due high overhead scout agg specific queries scout map performs scout agg hierarchical level sensor mean number queries responses processed vs level query hour sensor sensors objects specific queries scout agg scout map specific queries hierarchical level sensor mean number queries responses processed vs level query hour sensor sensors objects non specific queries scout agg scout map non specific queries load balancing sensors different hierarchical levels mixes specific non specific queries :10.1.1.12.1285
shows average number queries responses processed function level sensors hierarchy 
self configured hierarchies sensor topologies levels 
general scout map exhibits better load balancing properties scout agg saw similar results objects mobile scout map uses hashing uniformly distribute locator sensors objects network 
number queries responses processed sensor largely independent hierarchical level sensor 
see slight increase load hierarchical level sensor higher level sensors located central portions network 
higher level sensors paths querier sensor relevant locator sensor 
scout agg queries need travel higher levels reach branches order ensure correct response 
expected load balance scout agg improves queries non specific see non specific queries may frequently answered nearby sensor :10.1.1.12.1285
see queries answered sensors level lower slight dip number queries processed root 
similarly scout map queries answered local locator sensor see small dip load hierarchical level sensors increase 
slight dip level sensors due level mapping procedure fixes highest levels locator sensor address obtain local locator sensor address 
axis scale different local locator sensor contacted querier sensor branch rooted grandparent level sensor querier sensor :10.1.1.12.1285
slight increase load root sensor level compared sensors level due central placement root sensor queries directed global locator sensors processed level sensor level sensors 
scaling shows variation overhead number sensors increased 
sensor topologies created randomly distributing sensors rectangular grid meters respectively sensors average degree respectively :10.1.1.12.1285
number objects monitored sensor kept constant query rate constant query hour sensor simulations 
number object types sub types kept constant 
repeated experiments flooding baseline comparison 
find scout map schemes scale relative flooding 
see greater increase overhead scout agg queries specific see partly due greater number objects belong sub type distributed branches hierarchy 
similarly accounts slightly slower rate increase overhead scout agg queries non specific see probability locally finding object sub type higher 
scout map non specific queries number sensors mean bytes transmitted vs number sensors query hour sensor specific queries mean monitored objects sensor scout agg scout map flood specific queries number sensors mean bytes transmitted vs number sensors query hour sensor non specific queries mean monitored objects sensor scout agg scout map flood non specific queries overhead increase number sensors objects :10.1.1.12.1285
mean objects sensor 
need travel local locator sensor object certain sub type available pretty close querier sensor 
expected flooding performs poorly number sensors increases 
flooding performs worse non specific queries compared specific queries responses generated sensors monitor object particular sub type expanding ring search may suppress extra responses 
performance various object mobility query rates simulate object mobility moving object sensor neighbouring sensors randomly selected mobility pause time 
classify objects high moderate low mobility types 
mobility pause time highly mobile objects randomly selected seconds moderately mobile objects selected seconds 
mobility pause time remaining low mobility objects selected seconds 
simulations vary percentage highly mobile objects keeping percentage moderately mobile objects rest objects low mobility type 
vary percentage highly mobile objects keeping query rate fixed query hour sensor 
fix percentage highly mobile objects vary query rate queries hour sensor 
compare performance schemes scenarios composite update metric 
query update rate particular scenario ratio query rate percentage highly mobile objects 
percentage highly mobile objects proportional rate mobile updates generated second mobile updates generated remaining objects objects move maximum times entire simulation 
mobility update message bytes contains byte object name byte indicate sensor sees object longer sees 
scout map map negative map messages reliably sent relevant local locator sensors objects move 
map messages consist object name bytes hierarchical address locator sensor bytes sensor generated map message bytes 
mobility update message sensor longer sees object delayed seconds scout agg scout map reasons mentioned section section 
scout map efficient scout agg answering queries inefficient processing mobility updates 
mobility updates scout agg efficient mobility update need travel hierarchy update reaches sensor monitors object subtype type mobility updates need travel local locator sensor mobile object scout map 
shows overhead schemes savings mobile update overhead scout agg function number objects sub type distribution objects :10.1.1.12.1285
worst case mobility updates need travel lowest common ancestor sensors object just moved 
query update rate bandwidth overhead query update rate increases specific queries sensors objects scout agg scout map specific queries query update rate bandwidth overhead query update rate increases non specific queries sensors objects scout agg scout map non specific queries variation overhead query update rate query update rate increases :10.1.1.12.1285
results confirm relative overhead scout map improves ratio query mobility update rate dominated query rate 
relative overhead scout agg scout map better queries compared specific queries query update rates 
performed experiments objects type clustered false positives due aggregation lesser 
due space constraints simply summarize observed result 
simulations clustered objects certain sub type hops objects certain type hops 
objects move clusters objects sub type hops objects type hops 
saw relative overhead scout map scout agg improves query update rate increases 
rate improvement slightly slower uniform object distribution case lesser number false positives scout agg objects clustered 
performance sensor dynamics compares performance schemes sensor dynamics 
starting simulation randomly selected sensor brought mean inter failure interval 
mean interval varied selecting delay successive sensor failures times desired mean inter failure interval 
example mean failure interval seconds achieved bringing randomly selected sensor delay uniformly distributed seconds previous randomly selected sensor failure starting simulation 
time uniformly distributed seconds 
sensors re organize hierarchy dynamics occur 
plot overhead scout agg single level mapping inter failure interval increased scenario specific queries 
performance scout map multiple level mapping slightly worse shown results sensors monitor objects local locator sensors objects may need re map objects topology change 
notice schemes perform threshold seconds simulations 
threshold percentage unanswered queries bandwidth overhead scout map increases rapidly 
due high overhead re map objects scout map topology change relative overhead incurred re computation aggregates scout agg 
discussion impact parameters discuss impact object class hierarchy query locality relative overhead scout map 
discuss bloom filters aggregation scout agg 
mean inter failure interval bandwidth overhead network dynamics query hour sensor sensors objects specific queries scout agg scout map bandwidth overhead mean inter failure interval query loss rates network dynamics query hour sensor sensors objects specific queries scout agg scout map query loss rate performance various sensor inter failure intervals discussion effects object class hierarchy relative overhead fixed number objects deeper object class hierarchy higher number object types sub types improve overhead answering specific queries scout agg expense higher overhead mobility updates :10.1.1.12.1285
mobility updates may need propagated higher levels hierarchy 
example certain number tags probability parent sensor having summaries objects level object class hierarchy aggregated higher having objects level object class hierarchy aggregated 
parent sensor able form aggregate sees object parent sensor send advertisements individual object object moves child range 
similarly probability sensor able summarize objects number types sub types increases 
due probability objects type sub type inversely proportional number sub types types object class hierarchy fixed number objects 
object class hierarchy performance scout agg non specific queries improve number objects increases 
due increase probability finding object particular sub type closer querier sensor 
performance scout agg worse specific queries branches advertise aggregate specific object sub type 
overhead degrade flooding worst case object particular sub type branches hierarchy 
scout agg perform better queries nearby objects 
scoped search performed efficiently reach sensor monitoring queried object 
efficiency answer queries scout agg improves scenario query update rate scout map performs better may increase compared case query locality 
bloom filters aggregation bloom filters provide hashed summary object names sensor :10.1.1.12.1285:10.1.1.12.1285
essentially hash functions applied object name decide bits set fixed length bit array 
bloom filter summary consists bit array data structure indicate number times particular bit set 
summarization provides zero false misses result false positives object indicated summary object 
false positive ratio controlled size bit array number hash functions summarization 
larger bit array reduces false positive ratio number hash functions required optimal performance computed particular scenario 
bloom filter help scout agg false positive ratio reduced 
disadvantage bloom filters mobility update overhead higher 
mobility updates need sent till lowest common ancestor sensors object just moved number times particular bit set needs changed summaries sensors intermediate levels object moves 
false positive ratio increases 
hierarchical object names mobility update object need travel hierarchy sensor monitors object sub type reached 
related service discovery service location protocol slp intentional naming system basically designed serve enterprise networks meant scale large networks large number services 
limited scaling achieved slp partitioning network different scopes flat name space describes different scopes 
service discovery service sds uses hierarchy sds servers lossy aggregation bloom filters scale large networks similar scheme described :10.1.1.12.1285:10.1.1.12.1285
behaviour scheme suffers similar advantages disadvantages scout agg scheme 
studying performance scout agg bloom filters part 
globe location service uses hierarchy location servers similar scout agg 
forwarding pointers stored object root leaf node monitoring object leads high state requirements root 
addition query object located different branch root querier needs travel root just scout agg causes high load root server 
authors propose mesh servers root may alleviate high state requirements potential congestion root 
higher level servers apart root modified hierarchy exhibit higher load 
mesh level hierarchy difficult self configure adapt various network dynamics 
jini system provides mechanism flexibly register delete services clients discover offered services network 
jini system targeted workgroup federation may roughly correspond enterprise 
unclear different federations interact discover services scalable fashion larger setting 
ad hoc networks refer self organizing networks mobile wireless nodes depend fixed infrastructure :10.1.1.117.2921
protocols area deal efficiently finding routes destinations 
unfortunately proposed schemes scale large networks handle high degree mobility nodes 
harter propose centralized location service efficiently handles complex queries :10.1.1.12.1285
centralized solutions scale size mobility system query rate increases 
hierarchy construction automatic hierarchy construction algorithm landmark hierarchy 
previously algorithms landmark hierarchy construction incomplete excessive convergence times 
area hierarchy constructed logically grouping hosts routers areas areas 
limited studies dynamic distributed management area hierarchy due difficulty self configuration 
cited schemes suffer problems guarantee nodes network associated cluster 
thaler proposed algorithm distributed top hierarchy construction 
algorithm single root elected nodes initially unorganized network 
process expensive especially root needs centrally located 
general difficult top methods construct hierarchies reflect topology parameters node neighbourhood densities example difficult construct hierarchy centrally located nodes higher levels 
addition root may need contacted nodes election process potentially causing congestion root 
authors suggest optimizations reduce problem root may need contacted nodes cases 
distributed algorithms organize unstructured processing elements hierarchy cooperative groups called ac hierarchy 
adaptation network failures multi level hierarchy discussed 
multicasting archie server hierarchy mash uses level hierarchy improve efficiency searches archie 
techniques hierarchy construction similar 
extend building multi level hierarchy adapts network dynamics 
summary investigated hierarchical approaches scalable self configuring object location :10.1.1.12.1285
object location problem concerned larger system scale volatility mobility service discovery ip networks 
approach called scout agg uses aggregation object names similar sds :10.1.1.12.1285:10.1.1.12.1285
second approach called scout map indirection adaptation name resolution scheme landmark routing 
relative performance scout map scout agg characterized query mobility update rate system 
scout agg perform better lower query update rates worse scout map query update rate system increases 
flooding may viable mechanism low query update rates 
scout map exhibits better load balancing general compared scout agg 
query update rate scout map better scout agg depends type queries 
cross ratio decreases percentage specific queries increases 
show simulation scout agg scout map scale increase number sensors 
investigate efficient resolution complex queries 
complex queries find printer close postal delivery box may broken simpler queries 
complex queries partial full matching various attributes object name may require optimizations schemes 
intend investigate bloom filters aggregation scout agg design hybrid scheme combines better features scout agg scout map schemes 
official bluetooth sig website 
www bluetooth com 
pottie kaiser clare 
wireless integrated network sensors 
submitted publication 
omitted preserve anonymity 
harter hopper steggles ward webster :10.1.1.12.1285
anatomy context aware application 
proc 
acm ieee mobicom august 
guttman perkins day 
service location protocol version 
rfc june :10.1.1.12.1285
czerwinski zhao hodes joseph katz :10.1.1.12.1285:10.1.1.12.1285
architecture secure service discovery service 
proc 
acm ieee mobicom august 
adjie winoto schwartz balakrishnan lilley 
design implementation intentional naming system 
proc 
th acm sosp december 
jini technology white papers sun microsystems 
www sun com jini whitepapers 
paul tsuchiya 
landmark hierarchy new hierarchy routing large networks 
proc 
acm sigcomm 
paul tsuchiya 
landmark hierarchy description analysis 
technical report mtr mitre june 
paul tsuchiya 
landmark routing architecture algorithms issues 
technical report mtr mitre september 
paul tsuchiya 
landmark routing algorithms analysis simulation results 
technical report mtr mitre december 
mockapetris 
domain names concepts facilities 
rfc november 
neufeld 
descriptive names 
proc 
acm sigcomm austin texas september 
perkins 
ip mobility support 
rfc october :10.1.1.12.1285
kevin fall kannan varadhan editors :10.1.1.12.1285
ns notes documentation 
vint project 
available www mash cs berkeley edu ns october 
van steen hauck tanenbaum 
locating objects wide area systems 
ieee communications magazine pages january 
broch maltz johnson hu jetcheva :10.1.1.117.2921
performance comparison multi hop wireless ad hoc network routing protocols 
proc 
acm ieee mobicom october 

issues routing large dynamic networks 
phd thesis columbia university may 
shacham 
directions packet radio architectures protocols 
proc 
ieee january 
david thaler ravishankar 
distributed top hierarchy construction 
proc 
ieee infocom 
weiss 
paradigms structure amorphous computer 
technical report massachusetts institute technology artificial intelligence laboratory october :10.1.1.12.1285
rosenstein li tong 
mash multicasting archie server hierarchy 
acm computer communication review july 

