effective specialization realistic programs sensitivity luke hornof charles consel hornof consel irisa fr irisa campus universitaire de beaulieu rennes cedex france jacques noy fr ecole des mines de nantes rue alfred nantes cedex france order exploit specialization opportunities exist programs written researchers outside programming language community partial evaluator needs effectively treat existing realistic applications 
empirical studies demonstrated real sized applications extensively non liftable values pointers data structures 
essential binding time analysis accurately treats values 
achieve accuracy introduce notion sensitivity sensitive binding time analysis programs obtained forward analysis followed backward analysis 
analysis implemented integrated partial evaluator called tempo 
validate effectiveness analysis demonstrate sensitivity critical obtain highly specialized programs conducted experimental studies various components existing operating systems code 
results clearly demonstrate opposed insensitivity sensitivity drastically increases static computations detected analysis practice leads successful specialization 
partial evaluation thoroughly studied wide variety programming languages :10.1.1.109.6502
theoretical practical aspects led major advances technology 
researchers illustrated potentials technology applying various problems compiler generation graphics applications scientific computing 
ultimately just compiler partial evaluator tool 
research field aim developing systems capable exploiting specialization opportunities applications written programmers experts partial evaluation 
goal requires partial evaluators include analyses transformations powerful handle programs specifically structured optimization expecting programmers intentionally write code specializes 
achieve goal designed implemented partial evaluator close collaboration researchers field operating systems 
collaborators submitted potential specialization opportunities taken existing programs protocols layers system calls 
empirical study programs revealed limitations existing partial evaluation technology importantly lack accuracy bindingtime analyses dealing complex data structures 
binding time information directly defines degree specialization partial evaluators unable take advantage specialization opportunities 
presents new form binding time analysis accuracy allows thorough specialization systems code 
analysis implemented partial evaluator named tempo 
importantly partial evaluator operating systems researchers specialize existing programs 
shown analysis drastically improves degree specialization programs compared existing analyses substantiated experimental results 
rest section detail common behavior observed systems code 
show existing analyses loose critical information subsequently lead poor specialization 
explain design analysis information lost specialization successful 
sensitive analysis empirical study existing partial evaluation technology context systems software led successfully applied existing code 
systems programs critically rely complex data structures combine values pointers structures arrays 
data structures implement system state interpreted various system components 
context partial evaluation state typically partially static static computations dynamic computations 
various uses usually treated conservatively existing binding time analyses :10.1.1.109.6502
specifically static value dynamic context static value lifted residual representation specialization 
operation performed values exists corresponding textual representation integers 
values pointers structures arrays lifted corresponding textual representation 
cases existing binding time analyses force uses values considered dynamic 
regard analyses viewed insensitive just context insensitivity flow insensitivity force objects associated unique description regardless call assignment contexts respectively 
addition forcing uses dynamic insensitivity forces corresponding definitions dynamic 
loss transitively propagated forcing definition dynamic may create new dynamic uses 
importantly uses definitions dynamic computations depend 
insensitivity incur loss accuracy 
programming languages offer textual representation types values commonly scalars 
values remain static dynamic context lifted corresponding textual representation specialization 
unfortunately realistic applications extensive non liftable values manipulate large nested data structures including pointers arrays 
binding time analyses applied programs drastically degrades degree specialization due loss accuracy mentioned earlier 
common solution circumvent problem amounts thoroughly rewriting program carefully separating static dynamic values duplicating 
presents new approach binding time analysis achieves sensitivity non liftable values 
result static values exploited turn triggers computations ultimately allows realistic applications specialized successfully 
examples consider program fragments illustrate need sensitivity 
fig 
pointer variable assigned address array subsequently twice 
example typical pointers systems code pointer assigned multiple times 
int 
pointer program program fragment analyzed binding time analysis undesirable results produced 
specifically analyzed constants static dynamic value pointer depends static value static dynamic context 
pointer values languages lifted specialization dynamic context considered dynamic 
insensitive analysis requires uses variable binding time example uses pointer forced dynamic 
fig 
shows uses lines program annotated means static underlined means dynamic program subsequently specialized respect annotations 
binding time annotations 

specialized 

insensitive binding time annotations subsequent specialization sensitivity avoids problem 
uses variable longer required bindingtime value dynamic uses interfere static uses 
sensitive binding time analysis annotates lines program fragment fig 

notice static pointer directly exploited corresponding specialization 
binding time annotations 

specialized 

sensitive binding time annotations subsequent specialization example motivates need sensitivity shown fig 
showing typical example data structures 
different fields structure assigned different values subsequently different contexts 
struct fint int 

structure program program fragment analyzed partially static static dynamic accessing field creates dynamic context forces structure dynamic pointers lifted specialization 
insensitive analysis force uses dynamic turn renders accesses structure dynamic 
resulting binding time annotations lines include uses specialized version fig 

binding time annotations 

specialized 

insensitive binding time annotations subsequent specialization sensitive analysis avoids losing information similar way 
dynamic context dynamic liftable static context remains static 
annotations lines program fragment corresponding specialization fig 

implementation validation binding time analysis performed steps 
step forward binding time analysis computes binding times propagating forward initial binding time context 
second step backward binding time analysis propagates back binding time annotations 

specialized 

sensitive binding time annotations subsequent specialization wards previously computed binding times 
results analyses indicate variable static dynamic uses definition static dynamic 
specialization time definition evaluated 
implemented sensitive binding time analysis incorporated tempo partial evaluator specifically designed treat industrial strength systems code written 
results analysis drive tempo compile time run time specializers 
reported experiments existing systems programs show approach achieves high degree specialization 
summary introduce new analysis program transformation order obtain better specialization 
differs existing ways 

introduce notion sensitivity order achieve accurate binding time analysis 

designed implemented integrated tempo binding time analysis obtains sensitivity combining forward backward analysis 

existing systems programs analyzed new analysis compared insensitive analysis 
improved accuracy led successfully specialization programs 
sect 
detail precision gained sensitivity 
forward binding time analysis sect 
backward binding time analysis sect 

experimental evidence benefits sensitivity sect 

related addressed sect 
final remarks sect 

sensitivity order clarify idea sensitivity important understand binding times variables computed 
variable considered static values variable depends static case value variable computed specialization time 
variable occurs left hand side expression depend value considered static address computed specialization time 
variable considered dynamic 
function values shown fig 
express values variable depends 
function values bt determines values static upper bound bt variable depend value values bt returns static 
secondly value variable lifted context variable affects binding time variable 
function context represent values context program point subscript indicates specific variable 
similarly binding time context expressed function context bt computes upper bound values context 
example fig 
find pointer values fag context fs context fd values bt bt context bt bt bt context bt bt bt information binding time variable corresponding variable definition calculated 
insensitive analysis computes single binding time variable uses definition shown fig 

variable value lifted binding time simply values bt defined 
context bts taken account value lifted specialization time necessary 
non liftable values binding time computed upper bound values bt upper bound context bts 
individual information merged lost 
values id values id depends context id values context depends values bt id bt values id fsg bt context bt id bt context id bt value context binding times 
liftable value non liftable value bt id values bt id values bt id uses id context bt id def bt id bt id bt id computing def bt bt insensitive 
example fig 
insensitive analysis calculates information pointer bt def bt def bt sensitive analysis computes separate binding time combines information novel way compute binding time definition 
seen fig 

binding times computed separately subscript bt program point corresponding 
variable value lifted definition binding times computed analysis 
non liftable values binding time takes account specific context variable 
sensitivity obtained 
binding time corresponding definition computed function def bt able reflect fact different uses variable may different binding times 
introduce new upper bound operation def operates new domain lattice seen fig 
fig 

purpose new lattice determine binding time variable definition 
new domain powerset normal binding time domain expresses possible cases may arise 
variable static uses needs fsg definition dynamic uses needs fdg definition 
variable static dynamic uses needs definition static dynamic fs dg 
annotation fg corresponds dead code definition variable 
sensitive analysis information calculated pointer example 
bt bt def bt def fs dg fig 
seen uses annotated transformed 
introduced novel way annotating definitions see annotations subsequent transformations corresponding definitions example 
code anno liftable value non liftable value bt id values bt id values bt id context bt id def bt id bt id uses id def bt id uses id computing def bt bt sensitive 
binding times definition binding times domain fs dg dbt ffg fsg fdg fs dgg lattice fs dg fsg fdg fg upper bound def definition binding times 
respect insensitive information seen fig 
respect insensitive information fig 
means fsg underlined means fdg means fs dg indicates fg 
cases see definition follows fact definition annotations contain dynamic component 
case fs dg annotation contains static component indicating definition evaluated specialization necessary order correctly specialize subsequent static 
second example fig 
compute information structure values fg context fs context fd values bt context bt bt bt context bt bt bt binding time annotations specialized insensitive binding time annotations subsequent specialization insensitive analysis yields information 
bt def bt bt sensitive analysis computes 
bt bt def bt def fs dg binding time annotations specialized sensitive binding time annotations subsequent specialization annotated definitions fig 
fig 

pointer example see dynamic annotations cases cause definitions 
sensitive case static component indicates definition evaluated specialization time 
binding time annotations specialized insensitive binding time annotations subsequent specialization binding time annotations specialized sensitive binding time annotations subsequent specialization intra procedural binding time analysis shall illustrate sensitive binding time analysis subset described fig 

subset small presentation self contained shall describe analyses standard data flow analysis framework see instance 
sketch extended order deal dynamic allocation function calls 
preliminaries locations states shall refer sets values propagated binding time analysis states 
states elements location bt bt previously defined lattice domains 
types locations variable locations structure component locations 
location variable variable structure represented plain identifier 
location structure type type component field denoted type field 
shall assume structure type function location returns structure component locations associated type 
notice associating locations structure components structure type field basis allows different components structure different binding times forces components different structures type binding time 
conservative handling far sufficient treat existing systems code encountered extended achieve precision needed 
shall denote binary operator state theta locations state resetting bottom fg depending lattice set locations 
aliases definitions assume prior binding time analysis alias analysis definition analysis executed 
alias analysis gives dereference expression exp program point denote program points syntax program set aliases corresponding aliases set locations expression may represent 
definition analysis computes statement program point set locations defs may defined statement see fig 

assignment set containing multiple locations computed location defined run time determined statically 
ambiguous definitions due aliasing representation structures structure field assignment 
number constructs translated subset assignment comma conditional expressions goto statements elimination procedure suggested hendren loops 
strategy followed tempo 
domains const integer id identifier bop syntax exp const constant id variable lexp exp dereference exp bop exp binary expression lexp id component selection lexp id variable exp dereference lexp id component selection stmt lexp exp assignment exp stmt stmt conditional statement stmt exp loop stmt block return exp return program program main id stmt syntax subset statements lexp exp defs defs lexp unambiguous defs defs defs fg exp stmt stmt defs defs defs stmt exp defs defs stmt 
stmt sn defs defs return exp defs fg expressions struct defs lexp locations type id defs lexp exp defs lexp aliases lexp id defs lexp ftype idg definition analysis hand static analysis deduce location defined run time statement definition considered unambiguous 
case function unambiguous defs returns unambiguously defined location subsequently produce accurate results 
example unambiguous definition permits dynamic variable static forward binding time analysis 
forward binding time analysis propagates forward binding time states elements location 
program initial state contains input parameters declared static declared dynamic 
join operator binding time states defined pointwise application upper bound operator function space range 
data flow equations relating state entry point statement program point state output statement fig 
basic transfer functions fig 

transfer function describes evolution state resulting assignment program point assigns assignment binding time stmt bt see fig 
location set possible definitions assignment 
note assignment binding time depends input state 
assignment ambiguous safe approximation taken new binding time defined location upper bound previous binding time assignment binding time 
assignment unambiguous new binding time defined variable assignment binding time 
second transfer function applied conditional statement branches loop bodies 
functions deal assignments performed dynamic control assignments scope dynamic test effects safely approximated corresponding join point 
instance consider case variable assigned static value branch conditional statement test dynamic 
specialization time value variable join point remain unknown 
execution time branch taken variable assigned new value keep value entering conditional statement 
variable considered dynamic branch general location possibly defined branch alternative perform continuation analysis code explosion problem 
upper bound binding time binding time test performs proper safe approximation 
case dynamic test locations possibly defined scope test raised dynamic 
case static test join operation effect transfer function identity function 
easy show join semilattice finite length see instance set transfer functions generated closure joins compositions monotone operation space 
means see instance set equations corresponding program solved standard iterative algorithms 
produces program point binding times locations involved computation corresponding constructs binding times constructs 
backward binding time analysis propagates backward definition bindingtime states elements location dbt 
program initial state state returns fg location meaning variable return statement executed 
join operator def definition binding time states defined pointwise application upper bound operator def function space range 
data flow equations fig 
basic transfer functions fig 

transfer function computes input state assignment output state follows 
case unambiguous assignment defined location reset fg binding time propagated 
function def bt computes definition binding time assignment upper bound definition binding times locations possibly defined assignment 
function stmt updates summary locations assignment definition binding time assignment results analysis retrieved function exp bt 
transfer function collects uses updates corresponding summaries conditional loop tests 
set transfer functions set equations corresponding program solved standard iterative algorithms 
solving equations returns updated binding times combining value binding times context binding times proper definition binding times assignments 
function exp annotates static uses dynamic context dynamic lexp exp exp stmt stmt stmt exp stmt 
stmt sn return exp forward binding time analysis data flow equations statements state loc stmt bt stmt loc defs state unambiguous defs state loc exp bt exp state loc defs state forward binding time analysis transfer functions statements stmt bt lexp exp lexp bt lexp exp bt exp stmt bt exp stmt stmt exp bt exp stmt bt stmt stmt bt stmt stmt bt stmt exp exp bt exp stmt bt stmt stmt bt stmt sn stmt bt stmt stmt bt return exp exp bt exp expressions loc bt loc state struct loc loc loc locations type loc state loc state loc right hand side expressions exp bt const exp bt id state loc bt id state exp bt lexp state lexp bt lexp state exp bt exp state exp bt exp state loc aliases state loc exp bt exp bop exp state exp bt exp state exp bt exp state exp bt lexp id state lexp bt lexp state loc bt type id left hand side expressions lexp bt id state lexp bt exp state exp bt exp state lexp bt lexp id state lexp bt lexp state forward binding time analysis binding time annotation program lexp exp exp stmt stmt def stmt exp def stmt 
stmt sn return exp state backward binding time analysis data flow equations statements state stmt def bt def state unambiguous defs state exp exp bt def state auxiliary functions statements def bt def loc defs state loc stmt def bt lexp lexp def bt def exp exp def bt auxiliary functions expressions loc loc def bt struct loc loc loc locations type loc loc def bt loc def bt right hand side expressions exp const fg exp id loc id exp id def bt exp bt liftable type id loc loc def bt exp lexp def bt lexp lexp def bt exp exp exp exp exp exp def bt exp bt liftable type loc aliases loc loc aliases loc def bt exp exp bop exp def bt exp exp def bt def exp exp def bt exp lexp id def bt lexp lexp def bt def loc type id exp bt left hand side expressions lexp id fg lexp exp def bt exp exp def bt lexp lexp id def bt lexp lexp def bt backward binding time analysis transfer functions stmt annotates definitions upper bound definition binding times locations defined 
binding times understood terms specialization actions constructs annotated fsg lead evaluation actions constructs annotated fdg actions assignments annotated fs dg dual evaluation actions 
assignments annotated fg correspond dead code simply discarded 
complete analysis subset implementation treats near full subset including arrays dynamic memory allocation break continue gotos function calls casts pre post increment decrement chosen features find particularly interesting dynamic allocation interprocedural aspects give brief summary handled tempo 
interprocedural details 
strategy treat dynamic allocation amounts determining binding time description allocated objects program point basis 
program point dynamic allocation associated single location 
result binding times objects allocated site merged 
experience strategy accurate effectively specialize systems programs 
second approach making analysis interprocedural polyvariant follows 
different call site context taken account analyzing body function allows precise treatment functions 
modeled existing polyvariant binding time analyses previously implemented functional languages see example 
imperative language function call signature includes binding times functions arguments non local variables 
necessary variables addition actual parameters determine context function call 
avoid potential variables defined function taken account 
binding time function cache avoid functions called identical contexts cache contain analyzed function bindingtime state non local variables defined function 
context needs taken account polyvariant depends information call site affects analysis function 
binding times propagated backward variable definition set uses nonlocal variable defined function taken account call site 
functions analyzed respect set different variable information 
treating bindings formal parameters actual parameters performed usual formal parameter inherits binding time corresponding actual parameter body function analyzed respect value 
bindings complicated 
definitions variables may come assignments seen intra procedural analysis actual formal binding 
binding time parameter definition assignment definition static dynamic static dynamic fg 
assignment definition information summarizes uses formal parameter function body 
assignments specializer needs capable evaluating actual formal binding 
experimental results previously identified operating systems candidates specialization hand specializing certain existing operating systems components achieving significant speedups 
current partial evaluation technology automatically obtain speedups possible existing bindingtime analyses precise determine transformations applied hand 
fact partial evaluation applied existing code 
necessary write programs scratch take existing code adapt hand order achieve successful specialization 
partial evaluation successfully applied existing code subsequently shown sensitive binding time analysis necessary 
section summarize results comparing sensitive analysis insensitive analysis variety systems programs 
give brief description program considered key invariants specialization 
program copy elim involves typical message packet manipulation network software 
packets handled pointers data 
parts data static typically headers parts dynamic message 
second program read fragment filesystem implementation 
precisely specialized higher level routines read system call respect file size read 
file descriptor partially static file mode static file offset dynamic structure handled pointer 
third fourth programs client stub marshalling code fragments coming sun remote procedure call rpc implementation 
program client stub contains client stub layer program marshalling comes marshalling layer 
specialized programs respect client server interface various descriptors file descriptors socket descriptors protocol descriptors 
partially static 
experiment consisted binding time analyzing programs twice insensitive analysis sensitive analysis 
analysis static statements expressions counted 
results table program considered number lines statements expressions 
number static statements expressions expressed percentage 
percentages obtained insensitive sensitive analysis compute gain produced analysis 
sensitive case statements expressions static dynamic sd counted static appear residual program 
main observation table sensitive analysis detects programs static statements expressions 
specialization evaluates static constructs dynamic constructs higher percentage static constructs directly translates optimized residual program 
specialization programs clearly showed invariants mentioned exploited expected 
cases resulting specialized programs competitive respect manually specialized version 
related related sensitivity considered different perspectives languages 
program transformations value representations proposed achieve forms sensitivity 
analyses developed solve similar data flow problems 
static dynamic representations value number existing analyses maintain static representation concrete value static uses dynamic representation textual representation dynamic uses value 
example partial evaluators fuse carry representations closure allowing applied depending context 
danvy show program transformations prior partial evaluation achieve similar results 
solutions suffice value dynamic representation appropriate piece text replace value needs 
comparable seeing values liftable 
imperative languages pointers arrays structure values lifted 
certain cases pointer values dynamic representations name variable address possible 
example representations valid interprocedurally local variable names passed scope dynamic memory allocation variable name 
dynamic representation exists structures 
case sensitivity required achieve accurate results 
hand sensitivity applied liftable values certain cases produce better specialization 
example incorporates form sensitivity respect data structures 
data structures lifted means dynamic uses pollute static uses lifting copies data structure introduces code memory usage residual program 
large static data structure occurs dynamic contexts desirable lift different places 
detecting situation happens unique instance data structure multiple avoiding data duplication 
mentioned analysis similar level semantics evaluate encounter similar problems 
example done area constant propagation involves phase constant values propagated followed phases computations depend solely constant values folded 
works liftable values considered 
non liftable values propagated folding expressions similar technique need developed order resolve problems discussed 
partial evaluation mix partial evaluator handles arbitrary data structures :10.1.1.109.6502
total statements expressions number total static total static lines number insens 
sens gain number insens 
sens gain copy elim read client stub marshalling table percentage gain static statements expressions systems programs due sensitivity 
binding time analysis insensitive dynamic uses non liftable values interfere static uses 
mentioned earlier way circumvent losses incurred insensitive analysis rewrite code hand carefully separating static uses dynamic uses 
mix attempts automating separation structure splitting 
technique splits data structure separate components creating new variable structure element 
process repeated recursively nested structures structures eliminated 
fields initial structure liftable values corresponding new variables liftable 
values liftable incur loss flow insensitive analyses problem resolved 
approach currently intra procedural andersen proposes interprocedural extension structure splitting introduce new function parameter field structure 
approach appear scale realistic applications 
mentioned systems programs typically maintain system state consists numerous nested data structures 
example marshalling application considered sect 
system state represented struct cu data data structure containing total fields 
pass information interprocedurally structure passed pointer avoids copying field function call 
andersen proposed interprocedural extension defeats technique new parameter introduced copying 
dealing large systems programs typically case small piece system extracted specialized 
specialization new optimized piece reinserted larger context 
reason necessary preserve interface parts 
andersen proposed interprocedural extension preserve interface 
slicing similarities analyses program slicing 
forward slicing techniques propagate information variable definitions variables uses define binding time analyses imperative programs 
forward analysis similar forward part binding time analysis 
non liftable values addressed backward analysis provided treat values different contexts 
hand backward slicing techniques similar backward part binding time analysis propagating information variable uses variable definitions 
viewed form information 
just slicing computes commands needed slice backward analysis computes binding time definitions 
main difference point domain needed needed analysis performed point domain static dynamic static dynamic fg certain definitions may evaluated 
arity raising arity raising shown useful specializing functional programs 
motivation eliminate unnecessary data constructors accessors reduce function call overhead 
example consider cons cell constructed values passed function uses values 
arity raising transforms program passing values function cons cell 
eliminates initial construction subsequent cell access 
passing values value function needs passed 
arity raising stage binding time analysis achieved combining forward analysis backward analysis 
cases forward phase determines feasibility certain transformation 
binding time analysis determines construct evaluated specialization time arity raising determines data structure passed interprocedurally split subcomponents 
backward phases perform form analysis 
binding time analysis collects information concerning variable uses order determine corresponding annotation annotate variable definition 
arity raising determines subcomponents function need passed 
notice require backwards analysis propagate information variable uses variable definitions 
introduce idea sensitivity show insensitive binding time analysis incurs loss accuracy applications contain non liftable values operating systems code 
binding time analysis sensitive consisting forward analysis followed backward analysis 
new lattice calculate binding times definitions sensitivity introduces idea evaluating definition 
implementing analysis testing existing systems code produces results precision necessary achieve high degree specialization 
authors julia lawall comments drafts fruitful discussions 
grateful help gilles muller volanschi benchmarks 
research supported part france telecom sept arpa nsf ccr 
abramov 
compiler partial evaluation 
problems applied mathematics software systems pages 
moscow state university moscow ussr 
russian 
aho sethi ullman 
compilers principles techniques tools 
addisonwesley 
andersen 
self applicable program specialization 
partial evaluation program manipulation pages san francisco ca usa june 
yale university haven ct usa 
technical report yaleu dcs rr 
andersen 
program analysis specialization programming language 
phd thesis diku university copenhagen denmark 
diku research report 
andersen 
program analysis specialization programming language 
phd thesis computer science department university copenhagen may 
diku technical report 
andersen 
partial evaluation applied ray tracing 
diku research report diku university copenhagen denmark 
baier gluck 
partial evaluation numerical programs fortran 
partial evaluation semantics program manipulation orlando florida june technical report department computer science university melbourne pages 
berlin 
partial evaluation applied numerical computation 
acm conference lisp functional programming nice france pages 
new york acm 
bondorf jrgensen 
efficient analyses realistic line partial evaluation 
journal functional programming july 
consel 
polyvariant binding time analysis applicative languages 
partial evaluation semantics program manipulation copenhagen denmark june pages 
new york acm 
consel 
polyvariant binding time analysis applicative languages 
pepm pages 
consel 
tour 
pepm pages 
consel 
tour partial evaluation system higher order applicative languages 
partial evaluation semantics program manipulation copenhagen denmark june pages 
new york acm 
consel hornof noel noy volanschi 
uniform approach compile time run time specialization 
danvy pages 
consel khoo 
semantics directed generation prolog compiler 
nski wirsing editors programming language implementation logic programming rd international symposium plilp passau germany august lecture notes computer science vol 
pages 
berlin springer verlag 
consel noel 
general approach run time specialization application conference record rd annual acm sigplan sigact symposium principles programming languages pages st petersburg beach fl usa january 
acm press 
consel pu walpole 
incremental specialization key high performance modularity portability operating systems 
pepm pages 
invited 
consel pu walpole 
making production os kernel adaptive incremental specialization practice 
technical report department computer science engineering oregon graduate institute science technology 
danvy 
type directed partial evaluation 
technical report pb computer science department aarhus university july 
danvy gluck thiemann editors 
partial evaluation international seminar dagstuhl castle number lecture notes computer science february 
danvy palsberg 
essence eta expansion partial evaluation 
lisp symbolic computation september 
das reps van hentenryck 
semantic foundations binding time analysis imperative programs 
acm sigplan symposium partial evaluation semantics program manipulation pages la jolla ca usa 
acm press 
hendren 
taming control flow structured approach eliminating goto statements 
proceedings ieee international conference computer languages may 
gluck 
bindingtime analysis applied mathematical algorithms 
editors system modelling optimization pages 
chapman hall 

automatic construction special purpose programs 
loveland editor th conference automated deduction new york usa lecture notes computer science vol 
pages 
berlin springer verlag 
gomard jones 
compiler generation partial evaluation 
ritter editor information processing 
proceedings ifip th world computer congress pages 
ifip amsterdam north holland 
hornof noy 
accurate binding time analysis imperative languages flow context return sensitivity 
acm sigplan conference partial evaluation semantics program manipulation amsterdam netherlands june 
acm press 
appear 
jones gomard sestoft 
partial evaluation automatic program generation 
international series computer science 
prentice hall june 
jones schmidt 
compiler generation denotational semantics 
jones editor semantics directed compiler generation aarhus denmark lecture notes computer science vol 
pages 
berlin springer verlag 
jrgensen 
compiler generation partial evaluation 
master thesis diku university copenhagen denmark 
student project 
gluck 
fortran program specialization 
workshop analyse entwicklung und von 
germany 
appear 
marlowe ryder 
properties data flow frameworks 
acta informatica december 
metzger stroud 
interprocedural constant propagation empirical study 
acm letter programming languages systems march december 
mogensen 
application partial evaluation ray tracing 
master thesis diku university copenhagen denmark 
mogensen 
partially static structures partial evaluator 
bjrner ershov jones editors partial evaluation mixed computation pages 
amsterdam north holland 
mogensen bondorf 
partial evaluator prolog 

lau clement editors 
workshops computing 
berlin springer verlag january 
muller marlet volanschi consel pu goel 
fast optimized sun rpc automatic program specialization 
publication interne irisa rennes france march 
muller volanschi marlet 
scaling partial evaluation optimizing commercial rpc protocol 
rapport de recherche irisa rennes france december 
published acm sigplan conference partial evaluation semantics program manipulation 
nielson nielson 
semantics applications formal 
wiley professional computing 
john wiley sons 
partial evaluation semantics program manipulation copenhagen denmark june 
acm press 
pu black consel cowan inouye walpole zhang 
optimistic incremental specialization streamlining commercial operating system 
proceedings acm symposium operating systems principles pages copper mountain resort usa december 
acm operating systems reviews acm press 
reps 
program specialization program slicing 
danvy pages 

compiler generator produced self applicable specializer surprisingly natural understandable structure 
bjrner ershov jones editors partial evaluation mixed computation pages 
amsterdam north holland 

arity raiser program specialization 
jones editor esop 
rd european symposium programming copenhagen denmark may lecture notes computer science vol 
pages 
berlin springer verlag 
sun microsystems 
network programming guide march 
tanenbaum 
operating systems design implementation 
prentice hall 
tip 
survey program slicing techniques 
report cs computer science centrum voor wiskunde en informatica 
volanschi muller consel 
safe operating system specialization rpc case study 
workshop record workshop compiler support systems software pages tucson az usa february 
volanschi muller consel hornof noy pu 
uniform automatic approach copy elimination system extensions program specialization 
rapport de recherche inria rennes france june 
weise ruf seligman 
automatic online partial evaluation 
hughes editor functional programming languages computer architecture volume lecture notes computer science pages cambridge ma usa august 
springerverlag 

