goto elimination method implementation mccat compiler ana maria school computer science mcgill university montreal may thesis submitted faculty graduate studies research partial fulfillment requirements degree master science copyright fl ana maria designing optimizing parallelizing compilers simpler efficient deal programs structured control flow 
programmers naturally program structured fashion remain important programs benchmarks include number goto statements rendering entire program unstructured 
unstructured programs handled compilers built analyses transformations structured programs 
thesis straight forward algorithm structure programs eliminating goto statements 
method works directly high level syntax tree ast representation program easily integrated compiler uses ast intermediate representation 
actual algorithm proceeds eliminating goto applying sequence transformations followed appropriate goto elimination transformation 
mccat mcgill compiler architecture testbed optimizing parallelizing compiler compositional representation program support unrestricted gotos directly 
implemented method framework mccat compiler 
experimental results study cost structuring 
results show applying small number simple transformations eliminates goto statements usually minimal effect execution speed 
exploit structured representations compilers paying minimal penalty due structuring 
esum en cr des parall il est plus simple plus de avec des programmes poss un de 
bien que la des une ee il plusieurs programmes un nombre instructions goto en des programmes non es 
de programmes ne peuvent etre utilis es avec des pour analyser transformer des programmes es 
dans cette th ese nous pr un algorithme pour les programmes en langage en les instructions goto 
la ethode utilise un de repr esentation de niveau des programmes etre int egr ee quel une repr esentation bas ee sur un de 
algorithme sous sa forme en chaque goto en une de transformations de goto movements par la transformation goto elimination 
notre mccat mcgill compiler architecture testbed parall en langage est bas sur une repr esentation du programme donc ne peut utilisation des gotos 
nous avons impl ement la ethode pour le mccat 
nous pr quelques esultats exp le cout de structuration 
les esultats que un nombre de transformations les instructions goto avec un minimal sur la ex ecution dans la des cas 
donc nous des repr esentation ees pour cr eer des tout en ne qu un prix minimal pour la structuration 
ii mother aunt iii acknowledgments want advisor laurie hendren support gave course studies mcgill 
helpful encouraging 
excellent professor organizer 
enjoyed doing master studies supervision 
am thankful members mccat group especially sreedhar emami chris rakesh ghiya luis lozano 
appreciate help steps understanding simple luis help moments stressed rakesh chris helpful advice 
sure important think nice atmosphere contribute create acaps lab friendship evolved remember 
wish acknowledge excellent administrative staff computer science department specially lorraine harper franca lise 
perfect example efficiency service 
give special institute computer science university uruguay canadian international development agency providing pursue master studies canada 
friends montreal pi javier carlos miranda perez making feel home family friends touch spite distance 
especially emphasize constant support brother ramon friend ines mail long phone conversations minneapolis brother andres 
iv contents esum ii acknowledgments iv motivation goto elimination mccat compiler thesis contributions thesis organization description goto elimination method eliminating arbitrary goto statement program goto elimination transformations goto movement transformations examples inward outward transformations avoiding capture break continue statements eliminating goto statements program optimizations simple optimizations special case optimization overview simple basic statements compositional control statements implementing goto elimination mccat compiler overview data structures initialization phases determining relationships gotos labels 
siblings directly related indirectly related elimination phase experimental results benchmarks benchmark description benchmark characteristics experimental method results discussion vi comparing transformations gte gte opt comparing new statements gte gte opt distribution transformations gte opt distribution new statements gte opt comparing execution times simple gte gte opt studying different orderings goto elimination related bibliography finite state machine example program lex specifications vii list figures mccat compiler eliminating goto conditional eliminating goto loop situations goto label relationships moving goto switch moving goto moving goto loop moving goto moving goto switch lifting goto statement containing label outward movements followed goto elimination inward movements followed goto elimination outward inward movements followed goto elimination avoiding capture break statements avoiding capture continue statements high level algorithm removing gotos viii goto label goto block goto immediately loop optimizing multiple gotos switch example simple transformations simple ast representation simple grammar tree nodes compound statements simplification loop condition expression simplification condition short circuit example switch statement simple simple representation statements compound statement example program label hash table goto linked list goto label siblings determining directly related goto label pair determining directly related goto label pair determining indirectly related goto label pair determining indirectly related goto label pair determining indirectly related goto label pair switch implementation goto elimination phase implementation goto movement transformations ix implementation transformations indirectly related goto label pairs repeated pattern transforming new compound condition simple format fsm goto label intervals interval graph maximum independent set different orderings goto elimination loop vectorization transformation control dependence elimination irreducible loop example forward branches example exit branches example irreducible loop example example program transforming program cycles chapter motivation great advances high performance architectures demand simultaneous development sophisticated compilation techniques hp 
design optimizing parallelizing compilers critical issue 
compilers perform optimizing transformation information collected various program analyses 
pragmatic point view reasons structured programs programs gotos simpler handle compilers 
important consequence programs gotos compositional structured analyses techniques compute data flow information 
example apply efficient techniques available structured data flow graphs asu simple interpretation techniques need consider continuation semantics 
program transformation standpoint compositional programs lend simpler efficient algorithms 
consider example efficient creation static single assignment ssa form structured programs consisting straight line code statements statements cfr structured transformations alpha hgs family intermediate representations designed facilitate development specific analysis transformations elegant formal system proposed hoare hoa prove correctness structured compositional programs efficient construction program dependence graphs structured programs bm 
compositional programs naturally represented trees intermediate representations compositional representations manipulated transformed wide variety strategies including attribute grammars 
thesis concerned automatic structuring programs eliminating goto statements order facilitate construction analyses transformations required optimizing parallelizing compilers 
goto elimination mccat compiler years substantial discussion explicit gotos high level programs arguments frequent gotos software engineering program understandability point view dij knu weg 
discussion led relatively infrequent gotos typical programs bm 
languages special occasions programmers gotos 
include gotos exit deeply nested conditionals loops gotos branch common piece code shared branches switch statement gotos automatically generated code code produced lex gotos handle exceptions 
fact study known benchmarks spec benchmarks find important benchmarks gotos 
compiler restricted programs gotos significant handicap 
mcgill compiler architecture testbed mccat designed test different compilation techniques different architecture testbeds 
main objectives pursued build compiler supports high level intermediate representations facilitate analyses transformations related low level transformations suitable code generation build architecture simulator tools process output compiler produce different performance results 
source language chosen compiler decision consideration fact language widely powerful supports variety features 
unique features compiler family intermediate representations 
structured intermediate representations built fulfil specific role compiler 
called high level representation accurately captures original program 
main purpose cleanly separate front processing parsing type checking back phase analysis transformations code generation 
series transformations performed create simple ast suitable high level analyses points alias ema egh dependence analysis jus jh 
low level ast obtained simple low level optimizations register allocation instruction scheduling don take place 
representation generate code variety high performance architectures 
noted intermediate representation related results analyses performed higher level representations lower level representations 
presents overview mccat compiler principal components 
mccat compiler compositional representation program 
support unrestricted gotos directly 
order restriction benchmarks test compiler structuring phase eliminates gotos automatically required 
thesis goto elimination method implementation mccat compiler 
benchmarks pass structuring phase structured intermediate representations created analyses transformations deal structured control flow 
thesis contributions thesis concentrates design general algorithm number arbitrary goto statements program 
approach eliminating gotos set simple transformations operate simple second high level structured intermediate representation built mccat 
transformations come categories goto movements goto eliminations 
intuitively method relies observations goto statement target label statement sequence goto elimination transformation directly applied eliminate goto goto statement different statement sequence target label goto movement transformations move goto statement sequence target label apply appropriate goto elimination transformation 
algorithm proceeds eliminating goto time applying sequence goto movement transformations followed goto elimination transformation goto eliminated 
straight forward algorithm works directly compiler front processing simplify native compiler code generator simple register allocation instruction scheduling low level loop transformations source linker program structuring function inlining loop unrolling gen const 
propogation points analysis dependency analysis high level loop parallelization transformations mccat compiler high level syntax tree representation program easily integrated compiler uses ast intermediate representation 
implemented method mccat compiler 
main contributions thesis include ffl design straight forward general method eliminate goto statements program 
ffl implementation method mccat compiler 
ffl design implementation optimizations method 
ffl presentation experimental results discussion cost structuring show method efficient effective 
thesis organization remainder thesis structured follows 
chapter goto elimination goto movement transformations 
show applied remove single goto statement program second high level algorithm eliminating gotos program producing semantically equivalent structured program 
third show optimizations method improve resulting code 
chapter give brief description simple chapter provide overview important aspects implementation simple 
completely implemented method chapter give experimental results unoptimized optimized methods discuss cost structuring 
chapter compare method related methods chapter conclude discuss 
chapter description goto elimination method chapter description goto elimination method 
explain process eliminating arbitrary goto program number gotos 
study optimizations applied method 
eliminating arbitrary goto statement program section goto elimination transformations goto movement transformations show apply successive order reach point goto elimination applied 
simplify explanation method assume goto statement conditional goto form condition goto li 
assume unconditional goto form goto li transformed equivalent conditional statement form true goto li 
important point chosen directly support break continue statements 
statements represent form control flow similar gotos easily handled structured data flow analysis methods sri ema 
break continue statements change controlflow programs outside scope closest enclosing loop structure 
sense program remains compositional meaning program structure meaning components 
purposes benefit eliminating break continue statements 
easily modify method eliminate required 
furthermore assume labelled statement form li stmt really represented sequence statements empty li actual statement stmt 
refer label statement referring empty statement containing label 
goto elimination transformations goto statement label statement sequence directly eliminate goto statement 
possibilities goto statement occurs program label statement label statement 
case goto eliminated replaced conditional second case goto eliminated replaced loop 
goto statement label statement goto statement label statement obvious transformation conditional statement 
illustrated goto eliminated statements goto statement label embedded conditional statement guarded negation condition original goto statement 
goto statement label statement goto statement label statement goto statement eliminated embedding statements label goto loop 
example program illustrates case 
note goto transformation rewriting general statement sequence 
rules represent general pattern transformation stmt standing simple statement including assignment statements procedure calls compositional statements conditionals loops 
stmti cond goto li stmtj 
li 
stmti cond stmtj 
li 
eliminating goto conditional stmti li stmtj cond goto li 
stmti li stmtj cond 
eliminating goto loop goto elimination transformations obvious programmer goto situations conditional loop reasonable construct 
tool generates code easily produce programs 
furthermore goto elimination transformations provide backbone complete method 
described section eliminate goto moving goto appropriate place applying goto elimination transformations 
fact transformations just inverse standard code generation strategies conditionals loops 
goto movement transformations order categorize goto movement transformations precisely introduce notions offset level sibling statements directly related statements statements 
definition offset goto label statement relative program statement nth statement goto label statement 
offsets may computed traversing source program top bottom incrementing offset counter time goto label statement encountered 
definition level label goto statement label goto statement nested inside exactly loop switch statements 
definition label statement goto statement siblings exists statement sequence stmt stmt stmt stmt label statement corresponds stmt goto statement corresponds stmt statement sequence 
definition label statement goto statement directly related exists statement sequence stmt stmt stmt stmt label goto statement corresponds stmt matching goto label statement nested inside stmt stmt 
stmt statement sequence 
offsets determine label statement occurs matching goto statement 
definition label statement goto statement indirectly related appear procedure body siblings 
definitions clear goto elimination transformations previous subsection applied exactly goto statement target label statements siblings 
goto elimination transformation offset goto statement offset target label statement goto elimination transformation applied offset goto statement greater offset target label statement 
restate strategy follows 
goto label pair eliminate goto moving goto sibling label applying appropriate goto elimination transformation 
illustrates situations may occur 
illustrates case label goto directly related level goto greater level target label 
objective move goto level label 
case apply transformations transformation moves goto level 
illustrates case label goto directly related level goto level label 
case apply transformations transformation moves goto level 
figures illustrate complicated situations goto label indirectly related 
label goto entirely different statements goto moved outward movements directly related label inward movements move goto level label 
label goto different branches switch statements goto moved outward movements directly related enclosing switch inward movements move level label 
situations may handled inward outward goto movements remaining problem define outward inward movement transformations kind construct 
paragraphs transformations statements need considered loops switch statements 
outward movement transformations switch expr expr case cond goto expr expr switch cond goto case directly related directly related level goto level label level goto level label switch case expr cond goto expr expr cond cond goto expr expr expr indirectly related indirectly related different statements different branches switch situations goto label relationships outward movement transformations straight forward 
cases moving goto loop switch statement moving goto statement 
ffl moving goto loop switch statement transformation simple break statement exit switch loop 
break compositional compiler handle easily 
note possible complicated transformation break statement desired 
complete transformation illustrated 
note new variable introduced store value conditional point goto encountered 
value reused goto statement introduced exit switch loop 
safe preserve semantic correctness program goto variable reinitialized false point label 
ffl moving goto statement case break statement 
new conditional introduced illustrated 
inward movement transformations previous subsection relatively simple outward movement transformations 
inward movement transformations slightly complicated 
firstly take advantage break statements secondly consider goto appears target label 
describe inward movement transformations cases goto appears label show apply goto lifting transformation see section move goto appears label 
ffl moving goto loop statement transformation introduces conditional embeds statements occur goto start loop modifies loop condition entered goto expression true original loop expression true 
transformation illustrated 
note short circuit evaluation ensure original loop expression evaluated entry loop due goto 
note reinitialization false goto switch case stmti cond goto stmtj break case default 

switch case stmti gotol cond gotol break stmtj break case default gotol goto 
gotol 
moving goto switch expr stmti cond goto stmtj 

expr stmti gotol cond gotol stmtj gotol goto 
gotol 
moving goto cond goto stmti stmtj expr stmtn 
gotol cond gotol stmti stmtj gotol expr gotol goto gotol stmtn 
moving goto loop variable point label preserves correct behavior loop succeeding iterations force evaluation loop expression 
transformation loops similar condition loop need modified 
handle loops labels body simply transform equivalent loop apply appropriate inward movement transformation 
ffl moving goto statement case transformation similar loop transformation condition modified differently depending label part 
label part modification condition condition 
label part condition modified lead part goto condition true condition false 
illustrates case 
ffl moving goto switch statement order move goto switch statement locate case contains target label 
order force control enter case new variable defined switch variable conditional cond goto stmti stmtj expr stmtn 
gotol cond gotol stmti stmtj gotol expr gotol goto gotol stmtn 
moving goto introduced initializes new variable constant expression case question condition goto true switch expression condition goto false 
label occurs default statement new variable set default value 
illustrates case 
cond goto stmti stmtj switch case 
default 
gotol cond gotol stmti stmtj switch case gotol goto 
gotol default 
moving goto switch goto lifting transformation previous inward movement transformations moved goto appeared target label offset goto offset label 
situations target label appears matching goto 
case move goto just statement containing target label goto lifting transformation apply appropriate transformation 
illustrates goto lifting transformation 
stmt label statement contains label matching goto statement stmt label statement sequence 
lift goto stmt label introducing loop iteration ignores goto subsequent iterations uses value conditional bottom loop 
goto lifted inward movement transformations move goto inside stmt label 
stmti stmtj contains cond goto int gotol stmti stmtj gotol goto contains gotol cond gotol 
lifting goto statement containing label examples inward outward transformations illustrates series outward movement transformations followed goto elimination transformation performed eliminate goto 
illustrates series inward movement transformations followed goto elimination transformation performed eliminate goto 
illustrates series outward movement transformations followed goto lifting transformation series inward movement transformations transformation performed eliminate goto 
note dotted arrows indicate movement just applied dashed arrows indicate movement 
switch expr expr goto cond goto break case goto goto goto switch expr expr goto cond goto break case goto goto goto goto outward movement switch outward movement switch expr expr goto cond goto break case goto goto break goto goto goto switch expr expr goto cond goto break case goto goto break 
goto goto outward movement application goto elimination outward movements followed goto elimination goto expr goto expr switch goto cond goto goto goto case goto expr goto goto goto goto expr switch goto cond goto goto case goto inward movement inward movement goto expr goto goto goto goto switch switch goto expr switch switch goto cond 
goto goto case goto expr goto goto case goto switch switch goto expr switch switch goto cond goto goto inward movement switch application goto elimination inward movements followed goto elimination cond goto cond goto break expr expr goto expr goto 
goto goto goto goto cond goto cond goto break expr expr goto expr goto 
goto goto 
goto cond goto cond goto break expr expr goto expr goto 
goto goto goto outward movements goto lifting inward mov 
goto 
goto cond goto cond goto break goto expr expr goto expr goto 
goto 
goto goto goto 
goto 
goto cond goto cond goto break goto expr goto expr goto goto expr goto 
goto goto 
goto goto 
goto 
goto cond goto cond goto break goto expr goto expr goto 
goto expr goto 
goto goto 
goto inward mov 
inward mov 
goto elimination outward inward movements followed goto elimination avoiding capture break continue statements directly supporting break continue statements twist consider applying goto elimination section section transformations introduce new loops 
transformations quite simple innocent subtle point arises due presence break continue statements 
crucial point rare occasions loop introduce captures break continue statement belongs enclosing loop switch statement 
consider example original program incorrect capturing break statement 
order avoid situation add transformation captured break continue 
illustrated need introduce new logical variable loop captures break set variables false procedure set appropriate variable true point break check variable exit introduced loop true reset logical variable false issue proper break enclosing loop 
similar method captured continue statements exit introduced loop variable true issue continue break enclosing loop 
illustrates case 
eliminating goto statements program goto elimination goto movement goto lifting transformations state complete algorithm removing goto statements program 
complete algorithm 
procedure algorithm proceeds steps 
steps simple initializations 
step collects list label goto statements procedure 
second step introduces logical variable label initializes variable false inserts reinitialization false point label 
initializations required sure value logical variable false paths path coming point appropriate conditional test evaluated true 
third step converts unconditional gotos conditional gotos 
fourth step heart algorithm goto eliminated time 
goto matching label located 
goto label pair 
li stmti stmtj exp break exp goto li original program li stmti stmtj exp break exp int li stmti stmtj exp break exp break incorrect capture break correct treatment captured break avoiding capture break statements 
li stmti stmtj exp continue exp goto li original program li stmti stmtj exp continue exp int li stmti stmtj exp break exp continue incorrect capture continue correct treatment captured continue avoiding capture continue statements procedure get list labels gotos procedure labels procedure gotos procedure introduce initialize logical variables label li introduce variable initialized false introduce stmt just label li resets false change unconditional gotos conditional gotos unconditional goto change conditional goto eliminate gotos empty select goto label pair select goto label matching force directly related move outward movement transformations directly related different branches switch move outward movement transformations directly related switch containing force siblings level level move level outward movement transformations level level offset offset lift stmt containing goto lifting transf 
move level inward movement transformations guaranteed siblings eliminate offset offset eliminate conditional eliminate loop eliminate labels label li eliminate li high level algorithm removing gotos located simply matter applying goto movement transformations goto label pair siblings applying appropriate transformation 
fifth step elimination labels gotos labels eliminated 
optimizations section optimizations goto elimination method 
simple optimizations goto elimination goto movement transformations applied 
optimization particular situation gotos occur described 
simple optimizations applying goto movement goto elimination transformations rules straight away unnecessary conditional statements null bodies introduced 
situations avoid generating statements 
goto statement label statement illustrates case goto statement immediately label statement 
situation may occur movement transformations clearly case may just eliminate goto statement 
stmti cond goto stmtn 
stmti 
stmtn 
goto label expr stmti cond goto 
stmtn expr stmti gotol cond gotol goto 
gotol stmtn goto block goto block illustrates case goto statement sequence moved 
case avoid introducing conditional statement block statements goto guarded 
goto loop contains label illustrates case goto immediately loop 
avoid introducing conditional statement loop 
cond goto expr stmti 
stmtn gotol cond gotol expr gotol goto stmti 
gotol stmtn goto immediately loop special case optimization common situation optimized occurs goto associated label inside switch loop statement 
apply transformations blindly introduce goto conditional check exit switch loop 
conditional check introduced conditional introduced guard sequence statements ii introduced create cycle control flow iii conditional containing break statement introduced exit loop switch statement 
clear goto statement label preferable insert conditional checks label 
example transformation case multiple gotos label switch 
implement optimization checking see appropriate conditional inserted avoiding duplicating code 
switch case break case goto error case break case goto error error switch case break case break case break case break goto error error optimizing multiple gotos switch chapter overview simple section overview simple 
name suggests simple simplified version intermediate representation complex program constructs translated simpler form 
simple simple grammar powerful represent constructs simplify process complex expressions statements broken simpler forms complicated variable names split possible loops switches conditionals modified adhere restricted simple format 
complete description simple scope thesis refer important features examples helpful understanding sections 
detailed description simple sri 
purposes relevant features include different types statements statement nodes relevant aspects tree representation tree representation sequences statements compound statements 
basic statements simple set fifteen basic expression statements identified complex expression statement broken sequence statements 
illustrates examples statements assignment statements function call broken series simpler statements 
tree node related basic statement simple expr stmt node 
statement node parent node called tree list node 
tree list node link sequences statements 
illustrates high level representation simple ast example 
triangles figures represent subtrees described detail irrelevant 
temp temp temp temp temp temp temp temp temp temp example simple transformations tree list expr stmt temp tree list expr stmt temp tree list expr stmt temp temp tree list expr stmt temp temp simple ast representation compositional control statements compositional control statement forms supported simple restricted simplified versions statement sequences loops loops loops switch case statements statements 
addition return supported exiting procedure function break continue supported exiting loop break supported exiting switch case statements 
illustrates syntax control statements simple corresponding ast representation 
complete description simple grammar rules refer sri 
condition expressions loops conditionals reduced equivalent simple expressions free side effects 
shows example simplifying condition loop illustrates handling typical short circuit condition 
case short circuit expressed directly introducing appropriate conditional statement 
noted switch case statements need special attention body case statement shared partially different case statements compositionality control flow lost 
case statement forced case break return continue replicate shared code 
illustrates example simplifying switch statement 
order format simple ast uniform body compositional control statement contains single statement treated compound statement statement put braces 
compound statements represented tree list node parent sequence statements formed compound statement 
illustrates sequence statements compound statement corresponding tree 
new compound statement identified presence levels tree list nodes ast 
simple allow variables defined inside compound statements 
process called unnesting removes lifting variables function level renaming necessary 
programs represented simple regular simple grammar complex statements expressions simplified compound expressions broken simple ones 
convenient point insert structuring phase 
analyses transformations phase assume structured programs 
stmt stmt stmt stmt stmt cond statement stmt expr expr stmt stmt cond body statement stmt stmt stmt cond body statement stmt stmt stmt cond body statement simple grammar tree nodes compound statements temp temp temp simplification loop condition expression temp temp temp temp 
simplification condition short circuit switch case case stmt case stmt default stmt break case stmt switch case case stmt stmt stmt break case stmt stmt break case stmt break default stmt break example switch statement simple stmt stmt stmt tv tree value tc tree chain tree list tv tree list tv stmt stmt tc stmt tree list tree list tv tv stmt simple representation statements compound statement chapter implementing goto elimination mccat compiler overview chapter presents implementation details algorithm section 
selected data structures discussed 
data structures efficiently support operations categorize goto label relationship mandatory 
information concerning goto label statements stored able implement goto elimination algorithm 
implementation goto elimination method divided 
subphase deals steps algorithm section initialization phases 
include collection label goto statements information ii creation statements define initialize reinitialize goto variables iii conversion unconditional gotos conditional ones 
second subphase goto elimination algorithm implemented 
gotos eliminated labels removed 
efficient method determine goto label statements siblings directly related indirectly related required 
information stored data structures simple ast able categorize relationship goto label pair apply required transformation 
data structures data structures handle information related gotos labels 
gotos stored linked list 
labels stored hash table 
simplest order eliminate gotos order occur linked list 
discussed chapter may better orderings considered 
goto eliminated matching label located 
efficiently hash table labels 
presents example program figures illustrate label table goto list contents program 
section describes detail information stored data structures 
cond goto 
expr cond goto stmt cond goto cond goto 

current level current offset example program initialization phases mentioned initialization phases implemented subphase 
simple ast current procedure traversed recursive manner ln set labels ln name offset ptr simple ln label hash table label name level offset ptr simple head goto linked list collecting information goto list label table creating initialization statements converting unconditional gotos conditional gotos 
specifically traversal actions performed 
global variable level maintained 
incremented time enter loop switch statement decremented time exit statements 

global variable offset maintained incremented time find goto label statement 

tree list node linked parent tree list node current level assigned level field node 
statement node tree list node associated statement access parent statement node tree list node associated parent statement know statement level 

unconditional goto transformed conditional 

goto offset incremented 
new node goto list created goto information stored 

label statement offset incremented 
new variable associated label created 
statements initialize reset new variable created 
new node hash table created label information stored 
figures observe label node inserted hash label table time label label name hash function argument 
current level offset refer label name pointer simple ast label node stored 
goto node inserted head goto list 
current level offset label name associated goto pointer simple ast goto node stored 
nodes inserted head goto list gotos eliminated order appear goto list 
observed order goto elimination reverse order order gotos appear procedure 
noted implement initialization steps pass simple ast subphase passes simple ast required 
subsequent steps performed directly information collected pass 
subphase store information location goto label statements allow direct manipulation required parts ast second subphase 
create parent pointers simple tree find common ancestors efficiently determine relationship goto label 
able support efficient operations get level offset label goto accessing data structures determine goto label indirectly related directly related siblings 
determining relationships gotos labels 
show categorize goto label pair siblings directly related indirectly related 
siblings definition states label goto statement siblings exists statement sequence stmt stmt stmt stmt label statement corresponds stmt goto stmt simple ast goto label pair siblings nodes common parent 
illustrated example means backpointer tree list node associated goto backpointer tree list node associated label point tree list node 
directly related definition states label goto statement directly related exists statement sequence stmt stmt stmt stmt stmt cond goto stmt cond goto tb tree backpointer tree list tb tree list tree list tree list tree list tb tb tb stmt stmt stmt goto label siblings label corresponds stmt matching goto nested inside stmt statement sequence ii goto corresponds stmt matching label nested inside stmt statement sequence 
level stmt represent level associated statement stmt parent stmt represent parent pointer backpointer tree list node associated stmt simple ast case specified conditions 
level goto level label 
goto nested inside stmt sibling stmt label statement 
parent label parent stmt stmt statement obtained traversing level goto gamma level label backpointers goto node 
statement contains goto label parent pointer levels followed specified chapter compound statement represented levels tree list nodes 
state condition parent label parent level goto label goto example illustrates case goto nested inside statements label statement sequence outermost statements 
label level goto level 
tree list node associated goto statement backpointers tree list nodes reach tree list node associated statement 
backpointer tree list node points tree list node backpointer tree list node associated label 
similarly second case specified conditions 
level label level goto 
label nested inside stmt sibling stmt goto statement 
parent goto parent stmt stmt statement obtained traversing level label gamma level goto backpointers label node 
state condition parent goto parent level label goto label example illustrates case 
indirectly related definition states label goto statement indirectly related appear procedure body siblings directly related 
indirectly related goto label pairs include cases goto label entirely different statements special cases goto label different branches switch statement 
categorize goto label statements indirectly related checked siblings parent goto 
parent label 
level goto level label compared 
result possibilities ffl level goto level label directly related stated indirectly related 
ffl level goto 
level label steps performed select statement goto label greater level 
statement greater level stmt statement smaller level stmt 
ii greater level stmt node pairs parent pointers traversed level smaller level stmt reached 
parent pointer cond cond stmt cond goto stmt 
cond goto li stmt tree list tree list tree list tb tb stmtn stmt tree list tree list stmt tree list tree list tree list li tb tb tb tree list tb cond cond tb level level level label goto determining directly related goto label pair cond cond stmt 
stmt cond goto cond goto li stmt tree list tree list tree list tb tb stmtn stmt tree list tree list stmt tree list tree list tree list li tb tb tb tree list tb cond cond tb level level level label goto determining directly related goto label pair statement node reached parent pointer smaller level stmt directly related 
goto label pair categorized indirectly related conditions special cases checked 
general case goto label entirely different statements case exists statement sequence stmt stmt stmt stmt goto nested inside stmt label nested inside stmt stmt 
stmt 
simple ast goto node traversing pairs parent pointers label node traversing pairs parent pointers stmt stmt nodes reached parent stmt parent stmt 
illustrates case 
goto statement nested inside statement level 
label statement inside statement level 
tree list node associated goto backpointers reach tree list node associated statement contains goto tree list node associated label backpointers reach statement contains label 
backpointers statements point tree list node 
special cases goto label nested different branches switch case goto label nested zero statements inside different branches switch 
simple ast goto node traversing pairs parent pointers label node traversing pairs parent pointers stmt stmt nodes reached parent stmt 
parent stmt parent parent stmt parent parent stmt case goto label different branches statement goto label nested inside parent pointer levels followed 
cond cond stmt cond goto stmt cond stmt 
stmt level level level tree list cond goto li stmt tree list tree list tree list tb tb stmtn stmt tree list stmt tree list tree list tb tb tb tree list tb cond cond tb goto li stmt tree list tree list tb tb tree list tree list tb cond tree list label tb tb determining indirectly related goto label pair ii parent parent parent stmt parent parent parent stmt parent parent stmt parent parent stmt case statements case goto label different branches switch 
case statement fact statement children tree list nodes points compound statement body points compound statement body unique condition format simple ast 
backpointers tree list nodes point tree list node corresponding statement 
case switch statement special condition regarding format simple ast 
specially check label goto different case switch 
illustrates case label matching goto belong different parts 
tree list node goto backpointers tree list node label backpointers tree list node reached 
illustrates case label matching goto belong different case statements switch statement 
tree list node goto backpointers tree list node associated case statement reached tree list node label backpointers tree list node associated different case switch reached 
tests categorize general special cases done greater level stmt equal smaller level stmt 
elimination phase elimination phase implemented second subphase explained 
subphase goto list traversed sequentially eliminating gotos associated nodes list 
goto matching label searched hash table 
goto list hash table contain pointers tree list nodes associated corresponding goto label statements 
making pointers backpointers cond stmt cond goto 
tree list cond goto li tree list tree list stmt tree list tree list li tb cond tb level level label goto tree list tb stmt tb tb determining indirectly related goto label pair switch expr case stmt cond goto case 
tree list cond goto li tree list tree list case stmt tree list tree list li tb expr tb level level label goto tree list tb stmt tb tb tree list case stmt tb tree list tb tree list tb switch stmt determining indirectly related goto label pair switch ffl determine goto label siblings directly related explained previous section 
ffl apply required goto movement goto elimination transformations previous classification 
ffl perform required changes fields statement nodes level backpointers need modified applying goto movement transformation 
high level description implementation transformations applied eliminate goto figures 
goto goto list find matching label label matching hash label table parent 
parent siblings move sibling goto movement transformations siblings apply goto elimination transformations offset offset apply goto elimination transformation apply goto elimination transformation implementation goto elimination phase note variables stmt stmt figures correspond call greater level stmt smaller level stmt previous section depending value goto label levels 
goto movement transformations level level determine directly indirectly related level level parent parent parent parent directly related 
move outward movements sibling level level apply outward movement transformation indirectly related 
move outward movements move inward movements indirectly related transformations level level determine directly indirectly related level level parent parent parent parent directly related 
move inward movements sibling level level offset offset apply goto lifting transformations lift apply inward movement transformation indirectly related 
move outward movements move inward movements indirectly related transformations indirectly related 
move outward movements move inward movements indirectly related transformations return implementation goto movement transformations indirectly related transformations entirely different statements different branches switch statement parent 
parent parent parent parent parent level level parent parent 
branches statement apply outward movement transformations case 
branches stmt parent parent parent parent parent parent case stmts 
branches switch statement apply outward movement transformations case 
branches switch stmt entirely different statements apply outward movement transformation level level offset offset apply goto lifting transformations lift apply inward movement transformation return implementation transformations indirectly related goto label pairs chapter experimental results chapter give experimental results implementation goto elimination method mccat compiler 
description selected benchmarks 
experimental method described results discussed 
benchmarks order test structuring method collected set benchmarks contain goto statements 
practical terms required programs contain goto wanted test effect complexity approach benchmarks contained significant number goto statements 
benchmark description brief description benchmarks 
programs part kernels designed smith test vectorizing compilers ability recognize vector structures smi 
subset functions ones contain gotos 
compress file compression program style similar described ieee computer march 
version program written spencer thomas cq program performs series tests compiler information programming language ritchie kr 
frac program finds rational approximation floating point value 
written robert craig bell laboratories 
fsm program implements finite state machine irreducible loop 
program appendix provided david chase 
indent program gnu indentation formatting program version 
tomcatv version fortran program tomcatv highly vectorizable double precision floating point mesh generating benchmark 
fortran version part spec benchmark suite 
lex yy output program generated lex 
input lex specification appendix par program filter copies input output changing white characters newlines spaces reformatting paragraph 
written adam costello 
version fortran synthetic benchmark 
benchmark characteristics benchmark characteristics relevant table 
benchmark number gotos number labels number lines source code general characterization types gotos 
provide fair comparison number lines source code ran script strips comments eliminates blank lines formats programs standard form 
help discussion results depending complexity transformations required eliminate goto classify usage gotos categories simple goto usage complex goto usage 
simple goto usage includes cases gotos siblings labels outward branches control constructs 
complex goto usage includes cases gotos branch label control construct gotos belong goto label pair overlaps goto label pairs goto jumps label region spanned goto label pair 
classification depending frequency simple complex goto usages benchmark divided set benchmarks sets simple goto usage benchmarks majority simple goto usages complex goto usage benchmarks majority complex goto usages 
refer specific characteristics benchmark discussion results 
name gotos labels stmts usage cq simple simple lex yy complex frac simple tomcatv complex compress complex fsm complex simple indent complex simple par complex table benchmark characteristics experimental method explained previous chapters structuring takes place simplification process 
simple intermediate representation dump program mccat source source compiler continue back phases mccat illustrated 
order measure effectiveness structuring phase performed experiment 
benchmark mccat compiler source compiler produced semantically equivalent versions benchmark simple version program dumped conversion high level simple intermediate representation 
goto statements remain 
gte version program dumped simple representation structured transformation rules section 
optimizations transformation rules 
gte opt version program dumped simple program structured transformation rules section optimizations section 
note gte versions eliminated goto statements reverse order appeared source code 
versions program compiled version gnu gcc version option timed resulting executables unix system call sparcstation slc 
reported user time experiments 
results discussion results experimental measurements described tables comparison number transformations applied gte gte opt versions programs table 
ii comparison number new statements created gte gte opt versions programs table 
iii concentrating gte opt version benchmarks distribution different types transformations applied table 
iv concentrating gte opt version benchmarks distribution different types new statements table 
comparison execution times times collected described previous section gte gte opt versions program table 
gte stands goto elimination comparing transformations gte gte opt subsection evaluate depending number transformations applied 
table illustrates results set benchmarks 
note gte opt version transformations goto eliminated applied gte transformations applied 
number transformations occur apply gte gte opt versions varies benchmarks lex yy compress fsm indent par 
benchmarks ones apply optimizations referred section illustrated 
case goto associated label inside switch loop statement 
gotos eliminated regular transformations 
rest gotos remaining transformations common switch loop statement exited 
avoid duplicating code 
indent example illustrate benefit obtained optimization number transformations reduced gte opt gte 
gte gte opt name transf transf benchmark transf 
goto transf 
goto cq lex yy frac tomcatv compress fsm indent par table transformations gte gte opt comparing new statements gte gte opt subsection evaluate depending number new statements created 
table illustrates results set benchmarks 
discuss special case case lex yy 
note remarkable difference number new statements goto lex yy compared benchmarks gte gte opt versions 
reason benchmark contains break statements inside statement require transformation avoid incorrect capture new statement result illustrated table 
reason new statements created relative number gotos benchmarks represents significant increase 
consider rest benchmarks 
important difference number statements created gte gte opt 
gte opt version statements created gte created 
difference due number new conditional statements 
plain application goto elimination method applying simple optimizations described section usually produces statements null bodies 
gte gte opt name new stmt new stmt benchmark new stmt gotos new stmt gotos cq lex yy frac tomcatv compress fsm indent par table new statements gte gte opt gte opt clearly efficient respect number transformations number new statements created shall concentrate studying aspects detail just gte opt version programs 
distribution transformations gte opt table presents distribution transformations performed gte opt 
transformations classified follows goto elimination transformations includes transformations goto label compound statement siblings goto occurs label ii goto movement transformations includes outward movement transformations moving gotos control constructs inward movement transformation moving gotos control constructs goto lifting transformations performed inward movement transformation order move goto occurs label label iii transformations avoid incorrect capture new statement break continue statement enclosed loop switch statement 
consider goto elimination transformations 
observe goto goto elimination performed optimizations cases goto associated label inside switch loop applied 
observe forward branches occur times backward branches 
consider goto movement transformations 
looking table observe outward movement transformations applied times frequently inward movement transformations 
indent lex yy ones highest ratio outward movement transformations number gotos 
indent big switch statement gotos branch different case statements label case cases belong switch 
lex yy presents overlapping goto label pairs gotos nested inside levels ifs 
study benchmarks suggests inward movement transformations rarely gotos rarely jump control construct 
inward movement transformations performed caused labels scope new statements introduced previous transformation goto previously eliminated 
number goto lifting transformations insignificant 
benchmarks frac number goto movement transformations goto low cases majority goto label pairs siblings seldom overlap goto label pairs labels associated single goto 
third group transformations ones performed avoid incorrect capture break continue statement illustrated table performed insignificant number times 
said section situations happen rare occasions subtle point taken account 
note results consistent study done maccabe bm indicates functions examined gotos 
gotos characterized simple gotos target label function associated gotos goto label compound statement goto exit control structure 
transformations gte opt name goto elimination goto movement capture benchmarks gotos goto label 

lift 
break cont 
cq lex yy frac tomcatv compress fsm indent par total table detail transformations gte opt distribution new statements gte opt table illustrates different types new statements created gte opt 
statements expensive added statements 
increase number transformations elimination subsequent gotos overlap eliminated 
table observe usually conditional statements goto created 
worst cases occur expected benchmarks included group complex goto usage benchmarks 
note number ifs created roughly half number gotos contained 
reason benchmark translated fortran pattern repeated times program 
illustrates pattern 
gotos goto initialization setting reinitialization goto variables new statements required gte opt 
conditional ifs need added 
gte opt substantially reduces total number ifs created benchmark resulting low ratio statements goto 
cond goto goto 
int gotol int gotol cond gotol gotol gotol gotol gotol 
repeated pattern consider new basic statements created 
include initialization reinitialization setting goto condition goto variable ii initialization setting temporary variables method iii break statements exit loops switch statements 
gotos label statements eliminated number subtracted total number new statements 
note new statements created consistent simple grammar 
performing inward movement transformation statement condition statements modified compound condition explained chapter 
case adhere simple format compound expression simplified transforming statement 
illustrates case statement 
new statements created temporary variable defined store condition 
applies statements included body evaluate condition 
order distinguish number statements created strictly method ones created consistent simple results different columns 
consider number new variables created 
include goto variables temporary variables ones created adhere simple format ii ones created save switch condition iii ones created avoid incorrect capture break continue 
single variable created label store goto condition regardless number gotos associated label 
expected number new variables goto decreases number gotos associated label high 
example benchmarks illustrate fact par indent highest ratio gotos label 
lowest ratio half new variables goto 
gotol expr int temp temp gotol temp temp expr temp 
transforming new compound condition simple format comparing execution times simple gte gte opt consider effect structuring execution time 
contains execution times different versions programs simple gte name new statements gte opt new variables benchmark gotos basic simple gte opt cq lex yy frac tomcatv compress fsm indent par table detail new statements variables gte opt gte opt 
expected structuring programs goto statements little impact execution time 
true example cq goto respectively 
important observation programs goto statements method allows handle structure compiler low cost 
hand fsm benchmark irreducible loop extreme 
overlapping goto label pairs ratio gotos total statements high consider function implements finite state machine contains gotos program spends time ratio gotos number statements 
see significant performance impact optimized gte version executing significantly slower 
section show experiments observe order goto elimination considerably influences run time example 
benchmarks difference registered execution times considerable 
compress frac ones follow fsm considering differences execution time 
complex goto usages gotos concentrated function 
second contains simple goto usages program single small function high ratio gotos lines source code 
power optimizations demonstrated benchmarks indent significant difference gte gte opt versions program 
summarize stating results show applying small number simple transformations eliminates goto statements benchmarks effect execution speed minimal 
exploit structured representations designing compilers paying minimal penalty due restructuring 
name time time time gte opt benchmark simple gte gte opt simple cq lex yy frac tomcatv fsm compress indent par table execution times simple gte gte opt studying different orderings goto elimination programs complex goto usages goto density high order gotos eliminated cause significant difference number new statements introduced cause significant change running time structured program 
fsm example illustrate fact 
principal function implements finite state machine lines code goto label pairs 
goto label pairs siblings overlap 
section results experiments performed different orderings fsm gte opt 
illustrates fsm source code intervals created goto label pairs 
distinguish different goto statements associated single label subscripts 
consider interval graph intervals illustrated 
interval graph maximum independent set calculated gav 
maximum independent set subset set vertices graph maximum cardinality edge adjacent vertices subset 
maximum independent set represents case maximum set goto label pairs overlap 
eliminate gotos corresponding intervals gotos number transformations applied new statement created minimal 
goto label pairs siblings goto elimination transformations applied transformations gotos affected new statement introduced previous goto elimination 
possibility reducing number new statements structured program high comparing possible orderings 
structuring tested eliminating gotos orderings regular ordering goto elimination reverse order appear program ii inverse regular ordering goto elimination order appear program iii eliminating gotos corresponding maximum independent set interval graph eliminating rest gotos order appear program 
elimination transformations new stmt var run ordering goto elim 
mov 
mov 
goto lif 
var times regular inverse mis table comparing different goto elimination orderings fsm results table 
observe remarkable difference results inverse goto elimination ordering 
consider overlapping case goto label pair completely contained 
start fgetc goto goto goto fail fgetc goto goto goto fail fgetc goto goto goto fail fgetc goto start goto accept goto fail fail return fail accept return accept fail fail fail start accept fail fsm goto label intervals fail fail accept fail start fail mis start accept fail interval graph maximum independent set ordering statements created 
difference execution time expected significant 
versions results similar 
number transformations regular version lower number new statements 
regular version inward movement transformations performed temporary variable created 
difference versions execution time negligible 
observe order goto elimination regular version happens 
eliminates gotos corresponding non overlapping goto label pairs gotos associated fail label 
particular case ordering choice 
goto associated start label eliminated statement introduced captures goto fail statements eliminated 
fail label statement new 
conditional break statement added eliminate goto statements associated fail label 
performed experiment simpler finite state machine state results maximum independent set ordering better compared results regular goto elimination ordering 
difficult state general best goto elimination ordering 
depends specific type goto usages program consideration 
regarding fsm benchmark eliminating gotos inverse order appear program choice 
case benchmarks 
example pattern illustrated repeated times program 
case goto label pairs siblings 
goto program eliminated outward movement transformation required 
second goto eliminated inward movement transformation required 
considering number statements created inward movement transformation expensive outward movement transformation 
new compound expression created inward movement transformation simplified extra conditional created 
case eliminate gotos regular order best choice 
difficult calculate advance number type transformation applied eliminating goto situation remaining gotos may change 
conclude hard determine general best goto elimination ordering 
believe interesting problem study 
expr goto goto 
gotol expr gotol gotol gotol gotol gotol gotol expr gotol gotol gotol gotol gotol 
gotol 
repeated pattern eliminate goto eliminate goto different orderings goto elimination chapter related approaches structuring bohm bj 
structuring method done context normalizing flowgraphs flowgraph represented mappings set 
result historical theoretical interest give complete algorithm presents set pattern matching rules transformations 
approaches structuring program flowgraphs 
peterson proof flowgraph transformed equivalent formed flowchart loops conditionals properly nested entered pkt 
graph algorithm transformation technique node splitting prove transformation correct 
william osher node splitting problem recognizing basic unstructured sub graphs show replace sub graphs equivalent structured forms wil wo 
ashcroft manna tackled problem structuring presenting algorithms converting program schemas schemas 
node splitting extra logical variables achieve transformations em 
previous methods intended structure flowcharts 
approaches suggested structure programs order expose natural structure program leaving gotos unstructured 
method baker method structuring fortran programs bak order understandable 
goal obtain understandable fortran programs structures situations clear possibility structured construct leaves gotos program 
historical interest leaves gotos program method applicable complete structuring programs goal 
cifuentes algorithm program structuring context decompilation cif 
similar spirit baker problem structures parts program correspond naturally structured control constructs 
mueller compiler back optimization method attempts eliminate unconditional branches originate gotos mw 
method eliminates unconditional branches performing code duplication 
replaces unconditional jump shortest possible sequence instructions minimize growth code size 
implemented rtl intermediate representation early stages back phase optimizations benefit simplified control flow 
results show number instructions executed decreased total cache reduced small caches despite increases code 
relevant structuring methods proposed allen vectorizing compilers parallelizing compilers amm 
method developed rice university translator converts fortran sequential programs equivalent fortran vector programs 
vectorizing compilers dependence analysis performed data dependence 
statement dependant statement uses value created 
presence complex control flow data dependence sufficient transform programs control dependences 
control dependent outcome test determines executed 
allen conversion method converts control dependences data dependences introducing logical variables control execution statements eliminating goto statements 
illustrates example control dependence transformed data dependence 
br br br br loop vectorization transformation control dependence elimination goal method structuring fact similar characteristics 
method proceeds steps 
categorize branches types exit branches exits loop forward branches backward branches 
branch classification conversion uses different transformations eliminate branches programs branch relocation branch removal 
branch relocation moves branches loops branch label nested number loops 
accomplished introducing guard expressions enforce conditional execution statements 
branch removal takes place removing forward branches 
eliminate backward branches 
figures example programs conversion goto elimination methods applied 
example program illustrates irreducible loop presents forward branch goto backward branch goto 
conversion method introduces logical variables br br eliminate forward branch 
branch flag br defined true condition goto evaluates true 
logical variable guard statements goto label avoiding execution guard true 
label associated goto inside iterative region determined goto statements region executed backward jump taken 
extra logical variable branch back flag bb needed denote case 
backward jump goto eliminated cycle control flow replaced structured loop 
extra transformation applied replace backward branch loop 
case example loop carried dependence variables bb goto introduced 
intend perform loop parallelization negative factor dependence may inhibit parallelization loop 
second example program presents forward branches eliminated 
logical variables br br created 
statements goto matching label guard generated conjoin booleans variables conditions statement executed 
example goto elimination solutions eliminates gotos regular order second order reverse 
similarities differences second solution conversion solution clearly observed 
conversion separate conditional introduced guard statements 
algorithm uses single conditional guard statements block 
statements conversion introduces compound conditionals goto elimination uses nested ifs 
conditional created conversion simplification compound conditional yield result goto elimination method 
third example program illustrates exit branch 
case statements loop statements branch affected guard 
loop entered run full course exit flag false real computation done 
authors expect speedup gained vectorization offset inefficiency 
goto stmt stmt goto br bb br br bb stmt stmt bb goto goto gotol gotol stmt gotol stmt gotol gotol irreducible loop conversion goto elimination irreducible loop example conversion method similar methods consist step step transformations applied structured intermediate representations program transformation produces structured code 
ideas branch relocation branch removal somewhat similar concepts goto elimination 
logical variables guard execution statements 
differences methods include fact structure programs treating break continue switch statements just fortran programs 
furthermore interested removing gotos just associated forward branches 
difference way introduce guards code 
interested vectorization introduced new conditional action statement method preferable introduce conditional block statements 
potential advantage approach pass program collecting information gotos labels directly modify intermediate representation program 
approach requires passes goto goto br br br br br br br br br br example program conversion gotol gotol gotol gotol gotol gotol gotol gotol gotol gotol gotol gotol gotol gotol gotol goto elimination goto elimination eliminate goto eliminate goto forward branches example stmt goto stmt stmt stmt ex ex stmt ex ex ex stmt br ex br stmt stmt stmt gotol gotol break stmt gotol stmt gotol stmt exit branches conversion goto elimination exit branches example program different stages branch categorization branch relocation branch removal 
method amm calls control flow normalization closest terms goals structuring 
wish fully structure programs order facilitate program analyses program transformations automatic parallelization 
intermediate representations structure quite different 
structure high level representation programs directly supports break continue structures lisp intermediate representation requires loops single exit 
approach problem different 
defines continuation semantic language transforms syntactic constructs program algebraic constructs 
converts program system simultaneous equations unknowns represent continuations associated programs labels 
source continuation contain solution system resolution 
transformations applied system equations distribution factorization substitution elimination system solved 
quality normalized form program terms code duplication code size running time resolution process depends order unknowns eliminated 
study order consider control flow program eliminate back cross edges graph sort resulting graph topological order 
illustrates example irreducible loop result control flow normalization solution 
illustrates example program results applying goto elimination unoptimized optimized control flow normalization 
comparison methods examples shows results similar create new logical variables store conditions guard execution statements create cycles control flow implicit cycle 
replicates code case irreducible loops study best order unknowns 
cases backward branches imply cycles introduce loop 
illustrates example 
loop execute enclosed statements times original program imply increase execution time program 
goto stmt stmt goto pred pred stmt pred pred pred stmt stmt pred pred gotol gotol gotol stmt gotol stmt gotol gotol irreducible loop control flow normalization goto elimination irreducible loop example distinction require single exit loops compiler analysis framework easily handles continue break statements 
easily modify approach force single exit loops required 
appears method easier explain straight forward implement need set simple transformations require collection solution equations 
goto goto return gotol gotol gotol break gotol gotol gotol return example program goto elimination pred pred pred pred pred return pred pred pred return control flow normalization optimized control flow normalization example program goto stmt goto stmt goto stmt pred pred stmt pred pred pred stmt stmt gotol gotol gotol stmt gotol gotol break gotol stmt gotol gotol gotol stmt example program control flow normalization goto elimination transforming program cycles chapter thesis structured approach eliminating goto statements programs 
goal transformation provide structured compositional intermediate representation amenable structured approaches analysis optimization parallelization 
method straight forward easily implemented directly tree representation programs 
approach built set goto movement transformations 
goto statement removed goto movement transformations move goto statement sequence applying appropriate goto elimination transformation 
optimizations method avoid creating unnecessary new statements 
completely implemented method simple intermediate representation mccat parallelizing optimizing compiler experimental measurements benchmark programs implementation 
appears programs goto statements relatively sparsely programs structured programs similar execution speeds original programs 
structuring performance penalty time allows structured analyses transformations phases compiler 
programs dense goto statements performance penalty 
experiments performed different goto elimination orderings show significant difference execution times resulting programs 
hard determine general best goto elimination ordering 
interesting problem study 
feel major advantage approach structuring method straight forward integrate compiler structured intermediate representation 
furthermore shown experimental results approach efficient applying small number simple transformations goto statement 
experience presence structuring phase eliminate gotos allows develop efficient simpler analyses transformations remainder mccat compiler 
bibliography allen ken kennedy carrie porterfield joe warren 
conversion control dependence data dependence 
conference record tenth annual acm symposium principles programming languages pages austin texas january 
acm sigact sigplan 
amm 
control flow normalization algorithm complexity 
ieee transactions software engineering march 
asu alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley publishing reading massachusetts corrected edition 
bak baker 
algorithm structuring flowgraphs 
journal acm january 
bj bohm 
flow diagrams turing machines languages formation rules 
communications acm may 
bm robert balance arthur maccabe 
program dependence graphs rest 
technical report university new mexico october 
cfr ron cytron jeanne ferrante barry rosen mark wegman kenneth zadeck 
efficiently computing static single assignment form control dependence graph 
acm transactions programming languages systems october 
cif cifuentes 
structuring algorithm decompilation 
xix de inform atica pages buenos aires argentina august 
centro de en inform atica 
dij dijkstra 
operating sequential processes 
editor programming languages pages 
new york academic press 
don 
structured approach design implementation backend mccat compiler 
master thesis mcgill university march 
egh emami rakesh ghiya laurie hendren 
context sensitive interprocedural points analysis presence function pointers 
proceedings sigplan conference programming language design implementation pages orlando florida june 
acm sigplan 
sigplan notices june 
em ashcroft manna 
translating programs schemas 
siam comput 
ema emami 
practical interprocedural alias analysis optimizing parallelizing compiler 
master thesis mcgill university montr eal qu ebec september 
gav 
algorithms minimal coloring maximum clique minimum covering cliques maximum independent set chordal graph 
siam comput 
hendren emami gao sridharan 
designing mccat compiler family structured intermediate representations 
banerjee david gelernter alex nicolau david padua editors proceedings th international workshop languages compilers parallel computing number lecture notes computer science pages new haven connecticut august 
springer verlag 
published 
hgs hendren gao sreedhar 
alpha intermediate representation optimizing parallelizing compiler 
acaps technical memo school computer science mcgill university montr eal qu ebec november 
hoa hoare 
axiomatic approach computer programming 
communications acm 
hp john hennessy david patterson 
computer architecture quantitative approach 
morgan kaufmann publishers 
jh laurie hendren 
supporting array dependence testing optimizing parallelizing compiler 
peter fritzson editor proceedings th international conference compiler construction cc number lecture notes computer science pages edinburgh scotland april 
springer verlag 
jus 
array dependence framework mccat compiler 
master thesis mcgill university expected december 
knu knuth 
structured programming go statements 
computing surveys pages dec 
kr kernighan ritchie 
programming language 
prentice hall 
mw mueller whalley 
avoiding unconditional jumps code replication 
proceedings sigplan conference programming language design implementation pages san francisco california june 
acm sigplan 
sigplan notices july 
pkt peterson kasami 
capabilities repeat exit statements 
communications acm 
smi smith 
experiments fast substring search algorithm 
software practice experience october 
sreedhar 
unnesting nested blocks simple 
mccat acaps design note mcgill university school computer science 
sri sridharan 
analysis framework mccat compiler 
master thesis mcgill university montr eal qu ebec september 
weg wegner 
programming languages years 
ieee transactions computers december 
wil williams 
generating structured flow diagrams nature 
comput 

wo williams ossher 
conversion unstructured flow diagrams structured 
comput 

appendix finite state machine example program function implements finite state machine experiments 
fsm int start fgetc goto goto fgetc goto goto goto fail fgetc goto goto goto fail fgetc goto start goto accept goto fail fail return fail accept return accept appendix lex specifications regular expressions lex specification generate output program lex yy unpublished book booklet manual string techreport misc article printf inproceedings printf printf 
