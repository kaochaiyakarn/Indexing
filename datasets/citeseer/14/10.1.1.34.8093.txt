java program veri cation hoare logic abrupt termination marieke huisman bart jacobs computing science institute university nijmegen toernooiveld ed nijmegen netherlands cs kun nl 
formalises semantics statements expressions sequential imperative languages includes non termination normal termination abrupt termination exception break return continue 
extends traditional semantics underlying hoare logic distinguishes termination non termination 
extension hoare logic elaborated includes means reasoning abrupt termination side ects 
prominently involves rules reasoning loops may contain exceptions breaks continues returns 
extension applies particular java 
example standard pattern search algorithm java involving loop returns proven correct proof tool pvs 
java quickly widely programming languages 
able establish correctness java programs evident importance 
tool translates java classes logical theories proof tools isabelle pvs 
translation involves particular semantics statements expressions forms basis proving correctness formulas 

reasoning correctness formulas terms semantics convenient 
promising approach reason directly level correctness formulas 
quote 
hoare logic formalism doing precisely 
rst contribution precise description semantics statements expressions underlying 
involves abrupt termination prominent feature 
description detailed aspects 
importantly formulated language pvs isabelle general type theoretical language involving records variants 
means reader need familiar particulars language pvs isabelle 
secondly semantics described especially focused java may apply languages similar forms abrupt termination 
maibaum ed fundamental approaches software engineering fase springer lncs 
second contribution consists concrete detailed elaboration adaptation existing approaches programming logics exceptions notably weakest precondition form 
elaboration adaptation done real world programming language java 
basic ideas elaboration di erent 
example forms abrupt termination just sole exception semantics statements expressions particular functions coalgebras maps kleisli category see semantics traces 
logic arise purely theoretical exercise developed actual veri cation java programs 
example ability handle abnormalities crucially needed vector class veri cation especially dealing loops return statements bodies 
regarding semantics shall recall classical program semantics hoare logic assumption statements terminate normally resulting successor state terminate see chapter section 
case says statement hangs typically non terminating loop 
statements may understood partial functions states states 
writing self state space see statements state transformer functions self lift self self element set disjoint union 
classical view statements turns inadequate reasoning java programs 
java statements may hang terminate normally may additionally terminate abruptly see 
abrupt termination may caused exception typically division return break continue inside loop 
abrupt abnormal termination fundamentally di erent nontermination abnormalities may temporary may caught stage recovery non termination impossible 
abrupt termination requires modi cation standard semantics statements expressions resulting failure semantics example section 
statements modeled general state transformer functions self stat self forms new option subdivided parts exception return break continue constituents typically consist state self extra information kind exception label break 
structure codomain java state transformer functions captured formally type statresult see section 
classical hoare logic expressions viewed functions self type result 
view quite adequate purposes involve non termination abrupt termination side ects 
contrast expression java may hang terminate normally terminate abruptly 
terminates normally produces output result type expression state may side ect 
terminates abruptly exception break continue return 
expression type view function form self expr self rst option captures situation expression hangs 
second option self occurs expression terminates normally resulting successor state output result 
nal option describes abrupt termination exception expressions 
captured suitable type section 
representation statements expressions entry functions terminology forms basis current 
give meaning basic programming constructs composition 
hoare logic particular programming language consists series deduction rules special sentences involving constructs programming language assignment composition see section 
particular loops received attention hoare logic involve judicious non trivial choice loop invariant 
information see 
call classical body hoare logic applies standard constructs idealised imperative programming language 
forms developed part theory hoare logic 
couched general terms aimed particular programming language 
generality advantage disadvantage particular wishes reason speci programming language 
extension standard hoare logic di erent output options statements expressions result di erent kinds sentences break return see section 
emphasise extension hoare logic introduced applies small sequential non object oriented part java 
hoare logics reasoning concurrent programs may reasoning object oriented programs 
remotely related hoare logic jumps see chapter de bruin logics possible reason intermediate abnormal states 
programming logic java described current state cover forms abrupt termination focus point 
organised follows 
section sketches type theory logic shall working 
section brie discusses basics hoare logic 
section discusses formalisation semantics java statements expressions type theory 
describes hoare logic normal termination 
section discusses extension hoare logic abrupt termination 
proof rules abruptly terminating loops discussed section 
section gives example hoare logic abrupt termination 
section 
basic type theory logic section shall simple type theory classical higher order logic working 
seen common abstraction type theories logics pvs isabelle hol general type theory logic means stay away particulars languages pvs isabelle accessible readers unfamiliar languages 
due space restrictions explanation sketchy 
type theory simple type theory types built type variables type constants nat bool string exponent types labeled product record types lab lab labeled coproduct variant types lab lab types new types introduced de nitions lift type def bot unit unit empty product type 
lift type constructor adds bottom element arbitrary type type variable frequently 
exponent types shall standard lambda abstraction application nl notation 
terms labeled tuple lab lab mn inhabiting labeled product type lab lab 
term lab lab product write lab selection term type similarly term labeled tagged term lab labeled coproduct type lab lab term lab lab coproduct type terms containing free variable case term cases lab 
lab xn 
ln type elimination terms labeled products coproducts required satisfy standard conversions 
certain aspects pvs isabelle hol incompatible type parameters pvs versus type polymorphism isabelle hol type theory logic really intersection 
clear translate constructions particular languages proof tools 
see detailed comparison 
non recursive types translation java constructs catch switch recursive list type constructor 
formulas higher order logic terms type bool 
shall connectives conjunction disjunction implication negation rules classical logic constants true false typed quanti ers formula 
conditional term terms type choice operator yielding term type 
shall inductive de nitions type nat natural numbers reason standard induction principle 
pvs isabelle hol 
basics hoare logic traditionally hoare logic allows reason simple imperative programs containing assignments conditional statements loops block statements local variables 
provides proof rules derive correctness complete program correctness parts program 
sentences called asserted programs logic form fqg partial correctness total correctness 
involve assertions logic usually predicate logic statements programming language wishes reason 
partial correctness sentence fqg expresses assertion holds state statement evaluated state terminates normally resulting state assertion holds total correctness expresses stronger holds terminates normally resulting state holds 
known proof rules fqg frg comp frg fp cgs fqg fp cgt fqg fpg fqg fp cgs fpg fpg fp cg predicate rule called loop invariant 
classical partial correctness proof rules immediately carry total correctness 
known exception rule statement needs extra condition prove termination 
consider example program fragment true skip 
predicate easy prove skip 
statement terminates able conclude true skip false 
extra condition guarantees termination added rule 
standard approach de ne mapping underlying state space founded set require time body executed result mapping decreases 
happen nitely loop terminate 
mapping called variant contrast loop invariant 
gives proof rule total correctness statements 
variant variant limitations hoare logic hoare logic uence way thinking imperative programming unfortunately shortcomings 
really feasible verify non trivial programs hand 
computer science students stage training verify wellknown algorithm quicksort 
moment decide 
tool proving automatically user interfere crucial steps proof 
secondly classical hoare logic enables reasoning ideal programming language side ects exceptions abrupt termination statements widely imperative programming languages ects exceptions 
project aim reasoning real widely programming languages 
far concentrated java 
rst step project provide formal semantics java statements expressions higher order logic type theory previous section 
reasoning particular java program done translated type theory translation tool 
logic user write required properties program partial total correctness sentences try prove 
appropriate rewrite rules interpreter properties non looping non recursive programs proven user interaction 
translation pvs reasoning described detail presents details formal semantics java 
underlying memory model explained 
mentioned reasoning directly semantics programming language appropriate looping recursive programs 
kinds programs require special purpose logic hoare logic 
gordon describes rules hoare logic mechanically derived semantics simple imperative language 
enables semantic axiomatic reasoning programs language 
describe may seen deeper elaboration approach building ideas 
semantics java statements expressions section describes detail semantics java statements expressions formalised type theory 
statements expressions regarded state transformer functions possibly producing new state tag telling state normal abnormal 
explained rst 
part section subsection describes rst extension classical hoare logic hoare logic normal termination java languages incorporates side ects 
section describes substantial extension hoare logic abrupt termination 
statements expressions state transformers section describe state transformers statements expressions type theory 
explained extra possibility added non termination normal termination capture abrupt termination statements expressions statements expressions modeled functions types self self self self respectively 
convenience output types represented steps variant types 
self type def hang unit norm self abnorm self type def hang unit norm ns self res abnorm de nitions involve type variables self di erent types abnormalities 
expressions terminate abruptly exception statements terminate abruptly break continue return 
section meaning statements described detail 
self type def excp es self ex reftype self break bs self blab lift string cont cs self lift string self type def es self ex reftype expression statement exception abnormality consists state exception object 
represented element special type reftype see play ole sequel 
return abnormality consists tagged state break continue abnormalities consist state possibly label string 
de ne abbreviations statresult substitution statresult self def self self self def self self summarise formalisation statements modeled functions self statresult self expressions functions self self appropriate result type 
technicality deserves attention 
expression transformed statement matter forgetting result expression 
formalisation transformation explicitly function 
self self self statresult self def self cases hang 
hang norm 
norm ns abnorm 
abnorm excp es es ex ex line expression abnormality exception transformed statement abnormality 
throwing catching abnormalities types representing statements expressions various program constructs formalised 
done subsection 
start statements dealing abrupt termination 
shall notation denote interpretation translation java statement expression type theory 
abnormalities thrown caught basically re arranging coproduct options 
shall describe constructs throwing catching type theory 
abrupt termination ects ow control arises subsequent statements ignored abnormality caught see de nition composition subsection 
moment program executes normally 
shall discuss breaks returns detail sketch continues exceptions 
break break statement exit block 
break statement labeled exits block label 
typically break statement label lab occur inside nested block label lab arbitrary goto 
unlabeled break statements exit innermost switch statement 
java break statement translated break def break break label def break label label break break label string de ned functions self statresult self break def self abnorm break bs blab bot break label def self abnorm break bs blab associated function catch break turns abnormal states breaks appropriate label back normal states 
ll lift string self statresult self catch break ll self statresult self def self cases hang 
hang norm 
norm abnorm 
cases excp 
abnorm excp 
abnorm break 
blab ll norm bs abnorm break cont 
abnorm cont java translation labeled block enclosed applied appropriate label label body def catch break label body similarly switch statement enclosed applied bot 
return return statement executed program immediately exits current method 
return statement may expression argument expression evaluated returned result method 
translation java return statement argument return return return de ned type theory return self statresult self def self abnorm statement produces abnormal state 
return abnormality undone appropriate catch return functions 
translation java programs function catch stat return wrapped method body returns void 
method body executed 
may result abnormal state return 
case function catch turns state back normal 
leaves state unchanged 
self statresult self catch stat return self statresult self def self cases hang 
hang norm 
norm abnorm 
cases excp 
abnorm excp 
norm break 
abnorm break cont 
abnorm cont translation return statement argument similar subtle 
value expression stored special local variable state abnormal return 
return function catch expr return eventually turns state back normal case returns output held special variable 
continue loop statements continue statement occur 
ect control skips rest loop body starts reevaluating update statement loop boolean expression controls loop 
continue statement labeled continue applied correspondingly labeled loop innermost 
translation loop statements function catch continue catches abnormal states continues appropriate label 
de nitions continue catch continue similar break catch break respectively 
exceptions exception occur reasons thrown explicitly implicitly run time error 
java provides statement try catch catch exceptions 
formalisation contains statements throw try catch try catch realise throwing catching exceptions 
play ole rest 
formalisation composite statements expressions semantics program constructs described compositionally 
example de ned translation statement composition operator 
de ned self statresult self self statresult self def self cases hang 
hang norm 
abnorm 
abnorm self self bool self statresult self self nat result bool state self def nat nat cases iterate hang 
false norm 
cases hang 
false norm 
res abnorm 
false abnorm 
false cases iterate hang 
result false state norm 
result true state 
result false state result false state self self bool self statresult self self nat bool def nat result cases state hang 
false norm 
res 
falseg self self bool self statresult self self nat bool def nat result cases state hang 
false norm 
false 
trueg fig 

auxiliary functions 

de nition type theory ll lift string self self bool self statresult self ll self statresult self def self iter body catch continue ll catch continue ll catch continue ll nat iterate iter body nat elsif nat iterate iter body nat iter body hang fig 

type theory de nitions statement terminates normally state resulting state hangs terminates abruptly state executed 
binary operation forms monoid skip statement unit 
skip self statresult self def self skip composition iterate function 
iterate self statresult self def self skip iterate de nition function see figures 
java language constructs formalised similar way closely java language speci cation 
translation java statement depends occurrence label immediately cond def catch break bot bot cond body lab cond def catch break bot lab cond body outer catch break bot sure loop terminates normally unlabeled break occurs body 
shows de nition type theory making auxiliary functions 
earlier function iterate applied composite statement cond catch continue lift label body lift label bot lab 
statement referred iteration body 
rst evaluates condition side ect discarding result evaluates statement making sure occurrences continue appropriate label statement caught 
sets 
characterise point loop terminate iteration condition false resulting normal termination loop abnormality occurs iteration body resulting abnormal termination loop 
de nitions follows 
non empty singleton 
non empty number 
smaller equal number 
function rst checks 
non empty subsequently 
non empty 
cases iteration body executed appropriate number times loop terminate iteration 
case normal termination followed additional execution condition side ect case abnormal termination followed execution iteration body resulting abrupt termination 
sets 

empty loop terminate normally abruptly hang returned 
basically de nition xed point see details 
hoare logic normal termination java languages having described ingredients semantics statements expressions java languages formalise notions partial total correctness context 
moment consider normal termination 
predicates 

formalise notions partial total correctness variables pre post self bool stat self statresult self 
pre stat post bool def self pre cases stat hang 
true norm 
post abnorm 
true pre stat post bool def self pre cases stat hang 
false norm 
post abnorm 
false easy prove validity known hoare logic proof rules de nitions fpg fqg 
easy incorporate side ects rules 
formulate prove extra proof rules capturing correctness abruptly terminating statements 
instance rule states labeled block containing statement followed appropriately labeled break statement suces look correctness catch break break label immediately clear formulate similar rules abnormalities 
hoare logic abrupt termination unfortunately proof rules normal termination give power reason arbitrary java programs 
achieve necessary correctness notion abnormal state execution starts state satisfying execution terminates abruptly return state satisfying introduce notions abnormal correctness 
appear forms corresponding possible kinds abnormalities 
rules formulated derive abnormal correctness program compositionally 
rules allow user move back forth various correctness notions 
rst notion introduce partial break correctness notation meaning execution starts state satisfying execution terminates abnormal state break resulting abnormal state satis es break labeled lab lab bot 
naturally total break correctness break meaning execution starts state satisfying execution terminate abnormal state satisfying break 
break labeled label lab lab bot 
continuing manner leads notions abnormal correctness 
partial break correctness partial continue correctness partial return correctness partial exception correctness total break correctness break total continue correctness continue total return correctness return total exception correctness exception tempting change standard notation fqg norm bring line new notation stick standard notation normal termination 
formalisation correctness notions type theory straightforward 
example consider predicate 
partial return correctness 
give meaning notation fpg 
pre post self bool stat self statresult self pre stat post bool def self pre cases stat hang 
true norm 
true abnorm 
cases excp 
true 
post break 
true cont 
true straightforward proof rules formulated proven correctness notions return return nally rules move correctness notions normal abnormal vice versa 
examples return statement 
fqg stat return fqg return catch stat return proof rules easy straightforward formulate provide framework reason programs java languages 
loops interesting 
hoare logic loops abnormalities classical hoare logic reasoning loops involves ingredients 
invariant predicate state space remains true long loop executed condition false normal termination loop body execution iterated number times dealing total correctness variant mapping state space founded set strictly decreases time body executed 
extend abnormal correctness rst look silly example abruptly terminating loop 
true loop terminate nd variant show termination conclude condition false 
need special proof rules case conclude termination loop hold anymore 
desire leads development special rules partial total abnormal correctness loops 
describe partial total break correctness rules full detail rules abnormalities basically 
partial break rule suppose loop executed state satisfying wish prove loop terminates abruptly break result state satis es loop invariant predicate holds abrupt termination example 
natural condition proof rule body terminates abruptly break hold 
furthermore show invariant body terminates normally 
fpg catch continue fpg fpg catch continue partial break assume iteration body catch continue executed state satisfying terminates normally holds iteration body executed state satisfying ends abnormal state break state satis es property statement executed state satisfying terminates abruptly break nal state satis es soundness rule easy see prove suppose state satisfying terminates abruptly break 
means iterated statement catch continue terminates normally number times 
times remains true 
stage iterated statement terminate abruptly break labeled resulting state satis es nal state loop get total break rule formulate proof rule total break correctness statement 
suppose state satisfying wish prove execution state terminates abruptly break resulting state satisfying show iteration body terminates normally nite number times variant iteration body terminate normally break resulting abnormal state satisfying gives catch break catch continue true fp variant ng catch continue fp variant ng fp cg catch continue break total break rst condition states execution iteration body followed catch break state satisfying terminates normally iteration body terminate normally abruptly break 
second condition expresses iteration body terminates normally invariant condition remain true variant decreases 
iteration body terminate normally nite number times 
condition rule requires iteration body terminates abruptly break resulting state satis es soundness rule easy prove 
comparable rule slightly restrictive requires abnormality occurs variant 
case require occur unspeci ed stage 
example veri cation java program pvs demonstrate hoare logic abrupt termination consider pattern match algorithm java 
class pattern int base int pattern int find pos int true pattern length return base length return base pattern algorithm pattern match algorithm described 
ti construction proposed programmed java loop condition evaluates true 
loop exited return statements 
explicit continues necessary loop body consists statement 
chapter comparable algorithm searches position element dimensional array nested loops 
element exception thrown caught 
ect return 
algorithm derived speci cation rules exceptions 
find pos algorithm particularly spectacular typical example program loop key property holds abrupt termination caused return 
task algorithm arrays base pattern determine pattern occurs base return starting position rst occurrence pattern 
algorithm checks single loop position array base starting point pattern pattern 
pattern loop terminates abruptly return 
veri cation algorithm assume pattern base non null 
proof hoare logic rules applied contain loops anymore 
principle rewritten automatically user interaction required 
shall brie discuss invariant variant exit condition 
basic ingredients invariant loop value local variable ranges pattern length value ranges base length local variable base length value sub pattern pattern pattern sub array base smaller starting point occurence pattern pattern 
prove termination loop variant codomain nat nat base length pattern length 
loop body terminates normally value expression strictly decreases respect lexical order nat nat 
increased value base length decreases remains unchanged increased case value rst component remains unchanged value second component decreases 
exit condition states pattern occurs pattern length value starting point rst occurence pattern returned pattern occur base length returned 
able handle exit conditions crucial feature hoare logic described 
correctness algorithm shown pvs lemmas 
rst lemma states pattern occurs base starting position returned lemma states pattern occur returned 
proof consists approximately proof commands 
crucial step proof application total return rule appropriate invariant 
rerunning proofs takes approximately seconds pentium ii mhz 
essentials semantics java statements expressions abrupt termination associated hoare logic 
forms part wider project reasoning java programs 
logic heavily veri cation case study focussing class java standard library 
includes extending semantics proof rules annotated java language jml consisting standard java correctness assertions added comments 
ultimately tool translate assertions appropriate veri cation conditions 
due rustan leino sharp comments earlier version joachim van den berg helpful discussions 
hans meijer suggested algorithm section example veri cation 

abadi leino 
logic object oriented programs 
bidoit dauchet editors tapsoft theory practice software development volume lncs pages 
springer verlag 

apt 
years hoare logic survey part acm trans 
progr 
lang 
systems 

apt 
olderog 
veri cation sequential concurrent programs 
springer nd rev edition 

arnold gosling 
java programming language 
addison wesley nd edition 

ashcroft clint hoare 
remarks program proving jumps functions clint hoare 
acta informatica 

de bakker 
mathematical theory program correctness 
prentice hall 

van den berg huisman jacobs poll 
type theoretic memory model veri cation sequential java programs 
techn 
rep csi comput 
sci 
inst univ nijmegen 

de boer 
wp calculus oo 
thomas editor foundations software science computation structures number lncs pages 
springer berlin 

christian 
correct robust programs 
ieee trans 
software eng 

clint hoare 
program proving jumps functions 
acta informatica 

gordon 
programming language theory implementation 
prentice hall 

gordon 
mechanizing programming logics higher order logic 
current trends hardware veri cation automated theorem proving 
springerverlag 

gosling joy steele 
java language speci cation 
addisonwesley 

gries 
science programming 
springer 

huisman 
comparison pvs isabelle hol 
grundy editors proceedings international workshop theorem proving higher order logics tphols volume lncs september 

huisman jacobs 
reasoning classes objectoriented languages logical models tools 
proceedings european symposium programming esop volume lncs pages 
springerverlag march 

huisman jacobs van den berg 
case study class library veri cation java vector class 
jacobs leavens uller poetzsch ter editors formal techniques java programs volume informatik berichte hagen 

jacobs poll 
monad basic java semantics 
techn 
rep csi comput 
sci 
inst univ nijmegen 

jacobs van den berg huisman van 
reasoning classes java preliminary report 
object oriented programming systems languages applications oopsla pages 
acm press 

leavens baker ruby 
preliminary design jml behavioral interface speci cation language java 
technical report iowa state university department computer science january 

leino 
reliable modular programs 
phd thesis california inst 
techn 

leino van de 
semantics exceptions 

olderog editor programming concepts methods calculi pages 
north holland 

owre rajan rushby shankar srivas 
pvs combining speci cation proof checking model checking 
alur henzinger editors computer aided veri cation cav volume lncs pages new brunswick nj july august 
springer verlag 

owre rushby shankar von henke 
formal veri cation faulttolerant architectures prolegomena design pvs 
ieee transactions software engineering february 

parnas 
generalized control structure formal de nition 
communications acm 

paulson 
isabelle generic theorem prover volume lncs 
springerverlag 
contributions tobias nipkow 

poetzsch ter uller 
programming logic sequential java 
swierstra editor programming languages systems lncs pages 
springer berlin 

reynolds 
theories programming languages 
cambridge university press 

