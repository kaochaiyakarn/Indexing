na time analysis theory cost equivalence david sands diku department computer science university copenhagen dk copenhagen denmark 
mail dave diku dk techniques reasoning extensional properties functional programs understood methods analysing underlying intensional operational properties neglected 
begins development simple useful calculus time analysis non strict functional programs lazy lists 
limitation basic calculus ordinary equational reasoning functional programs valid 
order buy back equational properties develop non standard operational equivalence relation called cost equivalence considering number computation steps observable component evaluation process 
define relation analogy park definition bisimulation ccs 
formulation allows show cost equivalence contextual congruence substitutive respect basic calculus provides useful proof techniques establishing cost equivalence laws 
shown basic evaluation time derived demonstrating certain form cost equivalence give axiomatization cost equivalence complete respect application 
shows cost equivalence subsumes basic calculus 
show new operational interpretation evaluation demands provide smooth interface time analysis compositional approaches retaining advantages 
keywords time analysis lazy evaluation operational semantics 
appealing property functional programming languages ease extensional properties program understood ability show operations programs preserve meaning 
prominent study algorithms general central formal activities program transformation parallelization questions efficiency running time space requirements programs 
intensional properties program properties program computes computes 
study intensional properties immediately amenable algebraic methods extensional properties readily explored 
declarative emphasis functional programs features afford expressive power modularity higher order functions lazy evaluation serve intensional properties opaque 
spite relatively little attention development methods reasoning computational cost functional programs 
motivating example consider defining equations insertion sort written haskell syntax logic computat vol 
pp 
fl oxford university press nave time analysis theory cost equivalence isort isort insert isort insert insert insert 
expected isort requires time sort list length lazy evaluation isort enjoys nice modularity property respect time specify program computes minimum list numbers head sorted list minimum head ffi isort time compute minimum 
pleasing property insertion sort example context reasoning running time lazy evaluation 
contrast time property lazy quicksort seldom reported 
typical definition functional quicksort lists qsort qsort qsort qsort return lists elements bigger strictly smaller respectively infix list append 
functional accounts quicksort quadratic time algorithms conventional wisdom label quicksort better algorithm insertion sort better average case behaviour 
pleasing property lazy evaluation replacing better sorting algorithm qsort isort definition minimum obtain asymptotically worse algorithm omega gamma length input 
overview part consider problem reasoning evaluation time terms simple measure evaluation cost 
simple set time rules derived directly call name operational model concern equations hei time evaluate expression weak head normal form hei time evaluate normal form 
approach nave sense non compositional general cost computing expression defined combination costs computing subexpressions model graph reduction 
despite simplicity method appears useful means formalizing sufficiently operational details reason rigorously necessarily formally complexity lazy algorithms 
principal limitations approach fact usual meanings equality programs provide equational reasoning context time rules 
problem motivates development non standard theory operational equivalence number computation steps viewed observable component evaluation process 
example originally due turner appears exercise informal reasoning lazy evaluation ch 
majority 
papers time analysis non strict evaluation 
nave time analysis theory cost equivalence define relation analogy park definition bisimulation processes 
formulation provides uniform method establishing cost equivalence laws key result cost equivalence contextual congruence provides useful substitutive equivalence time rules extended cost equivalent syntactic context hc ff hc ff addition show theory cost equivalence subsumes time rules providing axiomatization cost equivalence sound complete certain sense respect simple evaluation time properties expressions 
return significant flaw time model call name call need 
sketch method alleviate problem provides smooth integration simple time analysis compositional call need approaches advantages 
development theory cost equivalence somewhat technical written reader interested primarily problem time analysis programs lazy language able skip bulk technical development take advantage results cost equivalence 
remainder summarize rest 
sections develop simple time analysis order language lazy lists 
section gives background describing approaches efficiency analysis lazy functional programs 
section define language operational semantics 
section defines notion time cost operational model introduces time rules form basis calculus 
section provides examples time rules reasoning complexity simple programs 
section motivates develops theory cost equivalence 
cost equivalence cost simulation shown preserved substitution arbitrary program contexts 
shown largest relation 
section gives variants induction proof principal useful establishing cost equivalences presents axiomatization cost equivalence complete respect basic time properties expressions 
section extend language higher order functions 
time rules easily added new language theory cost equivalence extended obvious way considering applicative cost simulation shown necessary substitutivity property 
section presents example time analysis illustrating combined time rules cost equivalences 
section outlines flexible approach increasing compositionality accuracy time analysis respect call need evaluation definition family evaluators indexed representations strictness properties 
conclude consider related area intensional semantics 
preliminary version appeared summarized ch 

addition inclusion proofs examples additional technical results sections new contain number important extensions earlier 
time analysis background number researchers developed prototype time complexity analysis tools algorithm analysis expressed order call value functional program nave time analysis theory cost equivalence 
argued subject study cases functional programming se choice functional language motivated fact order language call value semantics straightforward construct mechanically functions domain function describe recursively number computation steps required function 
means problem finding solutions equations terms size measure arguments gives simple formal reading program description computational cost 
cost evaluating function application fun understood terms cost evaluating plus cost evaluating application fun value case higher order strict language cost dependent simple cost evaluating argument possible cost subsequently applying applying result application forth 
techniques handling problem introduced syntactic structures called cost closures introduced enable intensional properties carried functions 
additional techniques reasoning higher order functions complement approach described 
problem reasoning efficiency programs lazy evaluation call byname usually call need extended data structures cost computing subexpression dependent entirely way expression function fun 
generally cost evaluating sub expression dependent amount value needed context 
compositional approach approach reasoning time cost lazy evaluation parameterize description cost computing description amount result needed context appears 
approach due compositional theory time analysis primitive recursive programs martin lof type theory developed 
characterization need accurately need provided new form strictness analysis enabled wadler give simpler account approach context general order functional language 
strictness analysis perspective gives natural notion approximation description context information gives rise interpretation completely analysis reasoning approximate contexts 
context information available analysis characterize sufficient time necessary time equations provide bounds exact time cost lazy evaluation method extended higher order functions modification cost closure technique 
problem compositional approaches time analysis remains information required context uncomputable property general 
options settle approximate information interpretation related approach complete calculus contexts hope find exact solutions 
approach simplifying task reasoning context assuming implementation available lead unacceptable approximations time cost 
approach see impractically cumbersome relatively simple problems extend usefully higher order languages 
nave time analysis theory cost equivalence nave approach sections explore complementary approach begins direct operational viewpoint 
define small order lazy functional language lists define time cost terms operational model 
treatment higher order language nave approach just straightforward postponed order simplify exposition theory cost equivalence 
simplicity chosen semantics substitution call name model leads correspondingly straightforward definition time cost refined give unsophisticated calculus form time rules analyse time cost 
illustrate utility nave approach going consider extensions improvements 
simple operational model initially consider order language lists 
simplicity untyped semantics syntax suggestive typed version 
list construction sugared infix cons lists examined decomposed case expression 
programs closed expressions context function definitions xn assume strict primitive functions atomic constants language booleans integers 
expressions described grammar fig 

function call primitive function call conditional case nil xs list case expression cons identifier constant fig 

expression syntax semantic rules possible reason time complexity closed expression reasoning directly steps evaluation expression 
problem approach requires machinery operational semantics fingertips order reason formal manner 
degree operational reasoning necessary minimized appropriately choice semantics 
particular simplicity motivates choice call name calling mechanism shortcomings improvements model discussed section 
semantics defined types evaluation rule describing evaluation head normal form evaluation normal form 
including rules evaluation nave time analysis theory cost equivalence normal form somewhat non standard semantics lazy language 
talk complete evaluation programs usual define print loop describe accurately top level behaviour program 
motivation analysis time cost rules evaluation normal form give convenient approximation printing mechanism case non terminating programs need place terminating context describe time behaviour anyway 
fun fe delta delta delta xn ff ff prim delta delta delta nk apply nk ff cond true ff ff false ff ff cons const ff case nil ff case nil xs ff fe ff case nil xs ff fig 

dynamic semantics define operational semantics rules allow judgements form read expression evaluates normal form expression evaluates head normal form respectively 
rule evaluating variable evaluation defined closed expressions 
rules fig 
meta variable ff range labels normal forms ranged 
referred simply values fully evaluated expressions fully evaluated lists atomic constants head normal forms ranged simply constants arbitrary brief explanation semantic rules term head normal form confused corresponding notion pure lambda calculus term order notion weak head normal form terminology lazy functional languages 
nave time analysis theory cost equivalence ffl describe function application perform direct substitution parameters 
notation efe xg mean expression free occurrences replaced expression see comments 
ffl assume primitive functions strict functions constants meaning partial function apply constants included head normal forms sufficient evaluate arguments primitive functions lower level semantics errors 
divide zero distinguished non termination choice significant difference 
ffl evaluate case expression normal head normal form evaluate determine branch take 
evaluate expression cons node 
notation summarize notation remainder 
variables substitution list zero variables xn denoted similarly list expressions 
notation efe xng mean expression free occurrences xn simultaneously replaced expressions case expression case nil xs variables xs considered bound formal definition substitution omitted standard see 
assume substitution property standard substitution lemma variables distinct pf yg pf qf yg xg qf yg yg nf yg idea context ranged informally denote expression hole place subexpression expression produced replacing hole expression generally assume expression closed notation considered shorthand substitution 
relations relation usually write mean relation preorder transitive reflexive equivalence relation symmetric 
syntactic equivalence renaming bound variables denoted maximum relation closed expression denoted 
deriving time rules wish reason time cost evaluating expression 
simplicity express property terms number non primitive function calls occurring evaluation expression 
formal definitions usually allow free variables captured revert substitution notation need formal consider special case variable capture explicitly 
nave time analysis theory cost equivalence operational semantics evaluation process understood terms construction proof judgement semantic rules 
property evaluation corresponds number instances rule fun proof ff closed expression proof exists order extract rules reasoning property rely basic properties semantics ffl rules describe deterministic computation ff ff ffl proofs unique delta delta proofs ff delta delta identical 
range judgements form ff delta delta range proofs judgements 
definition delta number instances rule fun proof delta 
proofs finite assuming inferences labeled define inductively structure proof rule applied delta delta ae delta delta delta delta delta fun delta delta delta delta delta define equations reasoning time away structure proof express property terms structure expressions rule proof judgement determined largely expression syntax 
principal define equations hei time compute normal form hei time compute head normal form expression rules hi hi fig 

write hei ff mean provable time rules standard arithmetic identities 
include axiomatization integers addition statement completely formal sufficient non automated reasoning 
rules adequate sense proposition expressions delta proof ff delta hei ff proof proposition straightforward induction structure delta 
notice premiss proposition termination assumption evaluation sense time rules partially correct 
refine correctness statement treating run time errors separately non termination 
direct time analysis time rules fig 
simple sufficient reason directly cost evaluating closed expressions language 
illustrate utility approach proofs correspond terminating computations calculus allow conclude time properties termination assumption 
discussion point see 
nave time analysis theory cost equivalence hf ff fe xn gi ff hp ff delta delta delta hif ff ae ff true ff false case nil xs ff ae ff nil fe ff hci ff fig 

time rules small examples 
examples chosen emphasize features non strict evaluation interesting asymptotic analyses reader may consult standard text analysis algorithms associated mathematical techniques 
reason complexity consider expressions containing non specified input value normal form denote meta variable written italic font 
allow meta variables range arbitrary expressions usually awkward calculus compositional 
example consider functions lists fig 

append xs ys case xs nil ys append ys reverse xs case xs nil nil append reverse nil head xs case xs nil undefined fig 

list manipulating functions nave time analysis theory cost equivalence wish consider cost evaluating expression head reverse computes element non empty list value applying definitions fig 
reverse reverse hard show value fact induction length 
hvi reverse nil reverse nil reverse nil append nil reverse recurrence equations parameterized input value nil vs vs solution length list total cost reverse length list linear time complexity compare quadratic complexity call value reading 
example example syntax defined shows pleasing property compute smallest element list linear time element insertion sort list 
equations fig 
define insertion sort function isort 
time compute head normal form insertion sort list value easily calculated time rules 
consider insertion function 
exhaustive application time rules minor simplifications allow conclude integer valued expressions integer list valued expressions ae nil hhi nave time analysis theory cost equivalence isort xs case xs nil nil insert isort insert ys case ys nil nil insert fig 

insertion sort consider computing head normal form insertion sort applied list integers vn nil 
aid notation denote list nil denote list isort ae isort nil hv hhi isort clearly hv 
simple induction establishes isort hhi 
leaves simple recurrence giving 
example consider somewhat non standard definition fibonacci fib note call value semantics fib divergent 
nave time analysis theory cost equivalence consider time compute instance fib hf hf ae true false ae true hf false instantiating hf hf hf hf hf hf hf gamma hf hf gamma hf hf hf equations give linear recurrence relation solved exactly standard techniques asymptote hf form gamma constants theory cost equivalence motivation previous example subtly illustrates potential problems reasoning cost equations deltai deltai time rules previous examples follows simple pattern case analysis instantiation simplification leading construction recurrence simple syntactic matching 
simplification process tempting simplifications directly justifiable time rules 
potential problems stem fact know expressions extensionally equivalent clearly case general expect reasonable definition extensional equivalence expression normal form nave time analysis theory cost equivalence supposing exists equivalent 
generally context expect hc ff hc ff general ordinary equational reasoning valid time rules 
similarly expect general hc hc example simple equalities line precisely way albeit simplify cost expressions order construct recurrence 
instance simplification obviously correct current calculus justify 
take contrived example limitations method significant consider quicksort program 
equations fig 
define simple functional version quicksort qs auxiliary functions append defined earlier written infix function 
primitive functions integer comparison written infix aid readability 
definition omitted comparison place 
qs xs case xs nil nil qs qs ys case ys nil nil fig 

functional quicksort aim fairly modest show quicksort exhibits worst case behaviour require element list computed contrast earlier insertion sort example takes linear time compute element result 
consider general case hei nil qs qs ae time rules definition append simplifies hei ae nil proceeding particular problem surprising non increasing lists show omega gamma 
goal fix arbitrary family integer spelling simplification application primitive function subtraction meta constant constant larger meta simplify 
nave time analysis theory cost equivalence values fv define family non increasing lists fa induction nil goal show quadratic instantiating general equation interesting case obtain ha point manipulate expression equation sufficient convince reader quadratic time behaviour possibility successive recursive calls qs respect time equation see arguments increasingly complex increasingly costly compute respective head normal forms 
current calculus little give intuition 
able simplify generalize calls obtain simple recurrence equation 
return example 
remainder section devoted developing stronger notion equivalence expressions respects cost allows richer form equational reasoning expressions calculus 
conclude example section 
needed appropriate characterization weakest equivalence relation hi satisfies hi hc ff hc ff develop general contextual congruence relation notion simulation similar various simulations developed process algebras milner calculus communicating systems 
theory concurrency central idea processes distinguished observation identified 
observational viewpoint adopted lazy calculus equivalence called applicative bisimulation introduced 
lazy calculus observable properties just convergence untyped lambda terms 
purposes need treat cost observable component evaluation process develop suitable notion cost bi simulation 
nave time analysis theory cost equivalence cost simulation partial functions hi hi sufficient characterize completely cost behaviour expressions contexts need characterize possibly infinite observations expressions arise language non strict untyped weak head normal forms 
roughly speaking notion equivalence want satisfies equivalent iff hei head normal forms 
identical constants 
cons expressions corresponding components equivalent 
unfortunately property equivalence obey constitute definition see note wish relate expressions having infinite technique due park identifying processes notion bisimulation related proof technique 
develop equivalence relation require terms preorders called cost simulations say expressions cost equivalent simulate 
simplify presentation add notation definition binary relation closed expressions binary relation head normal forms definition cost labelled transition ff defined ff def 
ff hei ff define basic notion cost simulation analogy park bi simulation definition cost simulation binary relation closed expressions cost simulation definition relation closed expressions define relation closed expressions relates exactly easily see ffl monotonic ffl cost simulation iff means se expanding definition recover definition 
nave time analysis theory cost equivalence definition denote maximum cost simulation fs proposition maximal fixed point proof 
follows knaster tarski fixed point theorem fact monotone function complete lattice 
results useful proof technique show necessary sufficient exhibit cost simulation containing relating pair 
technique illustrated proof precongruence 
expressing terms definition cost simulation described terms evaluation head normal form 
sufficient describe properties evaluation normal form need properties relating property allows factor evaluation normal form evaluation head normal form preserving cost behaviour proposition closed ffl ffl lemma proofs outlined appendix implication lemma reversed 
example identity function expressions nil nil nil nil take time reach identical normal forms cost simulation comparable 
precongruence ready prove key property demand cost simulation cost simulation precongruence substitutive fact preorder easily established 
notation convenience abbreviate indexed family expressions fe jg similarly abbreviate substitution fe jg xg relation write 
definition defined relation ef xg ef xg fv nave time analysis theory cost equivalence lemma cost simulation 
proof 
assume closed expressions abbreviate substitutions xg xg oe oe respectively assume expression containing variables assume eoe lemma requires prove eoe establish induction structure proof eoe cases structure expression give couple illustrative cases observe contained result follows 
assume defined oe oe oe rule inference instance fun fe oe delta delta delta oe ng gamma take variables distinct yn fe oe delta delta delta oe fe delta delta delta oe fe delta delta delta oe gamma smaller proof inductive hypothesis gives fe delta delta delta yn oe gamma rule fun definition conclude oe oe required 
theorem precongruence indexed families closed expressions expressions containing variables ef xg ef xg proof 
relation ef xg ef xg contains variables lemma establishes cost simulation ef xg ef xg 
case see identically express proof way illustrates general method establishing cost simulations 
define notion cost equivalence equivalence relation definition cost equivalence hi gamma 
hi expressions cost equivalent cost simulate 
main corollary precongruence nave time analysis theory cost equivalence corollary contexts closed expressions hi hc ff hc ff ff proof 
ff immediate theorem definition viewing context expression containing single free variable ff immediate theorem lemma open expressions obvious way extend cost simulation open expressions saying closing substitutions oe eoe eoe consequence show open expressions efe xg fe xg extend congruence property open expressions free variables may captured context showing expressions containing free variables xs closed expressions case nil xs case nil xs open statement cost equivalence involving function symbol naturally assumes particular defining equation strictly speaking cost equivalence parameterized set function definitions 
semantic rule function application really rule schema proof cost simulation precongruence necessary assume particular set definitions 
result adding new function definition defining equation new function name invalidate earlier cost equivalences furthermore maximality results section imply extension language conservative respect cost equivalence 
cost simulation largest contextual cost congruence shown cost simulation precongruence sufficient substitutive respect time rules 
remaining question largest possible precongruence respect time rules 
expression pairs contexts hc ff hc ff section outline result mild condition constructs language outlined largest relation 
ff hc ff hc ff roughly speaking say expressions cost distinguishable exists context hc ff hc ff necessary show sufficient condition implication hold pair distinct constants language cost distinguishable 
refer cd condition 
cd condition particularly strong satisfied example assume primitive function providing equality test constants 
nave time analysis theory cost equivalence prove result exploring relationship cost simulation various contextual congruences 
summarize results refer reader appendix details 
ffl define cost congruence preorder closed expressions contexts 

results evaluation head normal form produced number steps results outermost form see definition 
ffl show ffl define pure cost congruence preorder pc take account actual head normal forms produced pc contexts exists ffl assuming cd condition show pc corollary hc hc extension include evaluation normal form straightforward 
proof principles axiomatization cost equivalence definition cost simulation comes useful proof technique establishing instances 
part section outline simple variations technique 
second part section show cost equivalence subsumes time rules viewed basis time calculus independently giving complete axiomatization cost equivalence respect cost labelled transition induction principles motivated theory cost equivalence need substitutive laws cost equivalence schemas augment time rules 
example laws proposition hi apply ii hi iii case case nil ys nil xs hi case nil case nil xs ys case nil xs nave time analysis theory cost equivalence proof theorem illustrates general technique establishing cost equivalence laws construct suitable relation containing instances law show cost simulation 
recall previous section functional relation closed expressions definition maximal fixed point comes useful proof technique call induction show necessary sufficient exhibit relation containing relating pair cost simulation 
minor variations technique turn useful 
proposition prove cost simulation sufficient prove conditions cost simulation modulo cost simulation cost equivalence respectively 
cost simulation 
hi hi proof 

implies monotonicity implies 
arbitrary relations hard show fact hi transitive fixed point show hi hi hi hi hi hi hi hi implies hi hi hi hi hi hi hi hi hi hi hi greater identity relation method typically taken relation syntactic equivalence 
method ii viewed semantic induction principle 
example part iii proposition proved showing relation containing instances cost simulation modulo syntactic equivalence 
goes simple case analysis possible outcomes conditionals left exercise 
nave time analysis theory cost equivalence axiomatization cost equivalence language expressive expect complete set cost equivalence laws 
give set complete respect time rules sense precise 
key axiomatization identity function represent single tick computation time 
definition identity function program definition integer write exp expression applications function exp delta delta delta exp delta delta delta write exp simply exp 
fig 
state set cost equivalence laws 
write fun hi fe delta delta delta xn prim nk hi nk prim nk hi apply cond hi cond true true hi cond false false hi case case nil xs hi case nil xs case nil case nil nil xs hi case cons case nil xs hi fe fig 

cost equivalence laws hi nave time analysis theory cost equivalence hi provable cost equivalence laws facts hi congruence relation reflexivity transitivity substitutivity rules tick elimination rule elim hi hi soundness completeness results system respect cost labelled transition relation theorem completeness closed expressions hi 
proof appendix theorem soundness closed expressions head normal forms hi hi proof 
definition fact head normal form definition cost equivalence follows hi remains show cost equivalence provable hi theorem hi hi elim example continued conclude example section illustrating cost equivalence proof techniques axiomatization 
recall definition quicksort qs 
time rules earlier analysis append function obtained time equation hei ae nil considered special case non increasing lists fa showed key showing quadratic identification cost equivalence allows simplify general instance 
define family lists fa nave time analysis theory cost equivalence inductively follows nil list valued expression just cons cell nil needed takes evaluation steps produce 
proposition hi proof 
sketch proofs proposition 
illustrates basic cost simulation proof techniques 
cost simulation proofs quite low level reason directly operational semantics 
second proof calculational style serves illustrate practical application axiomatization cost equivalence 

construct family relations containing instances proposed cost equivalence show member union cost simulation 
symmetric closure relation filter ig sufficient show contained cost simulation implies union contained cost simulation 
show cost simulation modulo identity 
pair related elements form vice versa 
proceed cases value suppose 
definitions nil nil done 
suppose 
calculation definitions heads related identity tails results related done 

induction cost equivalence laws fig 

base hi case hi case hi nil recalling earlier section just identity function denotes applications identity function convention just nave time analysis theory cost equivalence induction hi case 
hi case 
hi hi hi hypothesis proof cost equivalence laws simple induction may preferable proof method constructing cost simulation strictly powerful example allows proposition generalized include possibly infinite non increasing lists generalization relevant context sorting example 
return quicksort 
consider general case omega qs ff considering cases instantiating general time equation gives ha omega qs ff omega ff simplify right hand side proposition give omega qs ff omega qs ff recurrence easily solved simple induction sufficient check just higher order functions advantage simple operational approach reasoning programs relative ease handle higher order functions 
section show time rules easily extended cope incorporation terms evaluation rules lazy lambda calculus 
potentially difficult part extension theory cost equivalence 
sketch precongruence proof cost simulation extended modifications handle lambda terms application 
lazy lambda calculus consider extension language terms evaluation rules lazy lambda calculus 
lazy lambda calculus shares syntax pure untyped lambda nave time analysis theory cost equivalence calculus operational semantics consistent implementations higherorder functional languages evaluation lambda 
usual definitions free bound variables lambda terms apply repeat definitions 
evaluation rules application lambda terms lambda ff apply efe xg ff ff notice evaluate lambda case evaluation 
consistent printing mechanisms provided higher order functional languages allow functions top level results programs 
sequel focus purely relation 
analysis cost choose additionally count number times invoke apply rule evaluation term 
extension time rules completely obvious hx ei ff ff ff applicative cost simulation sketch ffl extension definition cost simulation applicative cost simulation ffl proof applicative cost simulation precongruence 
extension definition cost simulation handle case expression evaluates lambda expression follows definition applicative bi simulation 
definition binary relation closed expressions binary relation lambda expressions closed expressions definition define applicative cost simulation maximal fixed point monotone function binary relation closed expressions define relation say relation applicative cost simulation 
definition applicative cost simulation denote largest applicative cost simulation maximum fixed point delta fs nave time analysis theory cost equivalence straightforward show preorder 
prove preserved substitution arbitrary closed contexts direct extension proof lemma theorem 
construct relation contains closed substitution instances show cost simulation 
theorem precongruence ii indexed families closed expressions expressions containing variables ef xg ef xg proof sketched appendix term congruence challenged consider open expressions free variables captured context 
extend applicative cost simulation open expressions saying eoe eoe closing substitutions oe 
easy show example example section final example 
gives illustration proof cost equivalence derivation time property 
reader invited attempt analysis cost equivalence 
defines functions including max computes element dictionary order list words 
words represented lists characters 
max employs auxiliary binary comparison words dmax turn employs primitive function precedes tests character precedes 
abbreviations adopted aid presentation parentheses elided application unary functions function name ary written directly denotes obvious abstraction xn xn 
follows denote words just concatenation elements example aab represents list nil 
illustrate functionality dmax saying dmax aa dmax aa ab aa 
object example function computes dictionary maximum non empty tails list 
example tails aba aba ba maximum 
objective sight modest 
wish show take quadratic time length list argument produce normal form 
quadratic time result obvious interaction lazy evaluation order lazy lexicographic ordering gives performance 
example linear classes lists ffl lists strictly decreasing elements 
abcde ffl lists strictly increasing elements 
ffl stationary lists bbb 
proofs properties left exercises 
nave time analysis theory cost equivalence xs max tails xs max xs case xs nil undefined foldr dmax dmax xs ys case ys nil nil case xs nil nil dmax precedes tails ys case ys nil nil tails foldr xs case xs nil foldr fig 

overview remainder section builds proof quadratic time property 
break proof number distinct steps illustrates techniques reasoning cost equivalence 
step find simpler representation problem cost equivalence derive recursive function recast problem terms properties new function 
second step find family lists yield quadratic time result just give informal motivation point 
quicksort example find crucial simplifying cost equivalence relating family lists 
steps final time analysis straightforward 
equivalent problem cost equivalence laws including case law proposition max tails hi case tails nil undefined foldr dmax hi case nil undefined foldr dmax tails nave time analysis theory cost equivalence wish proceed analysing expression foldr dmax tails 
derive recursive function slightly general expression foldr dmax tails xs 
function fot derive satisfy fot xs hi foldr dmax tails xs initially satisfy defining fot xs foldr dmax tails xs 
consider initial specification fot proceed transforming right hand side manner unfold fold transformation maintaining cost equivalence foldr dmax tails xs hi case tails xs nil dmax foldr dmax unfold foldr hi case xs nil dmax foldr dmax tails unfold tails case law hi case xs nil case foldr dmax tails unfold dmax hi case xs nil case foldr dmax tails case law hi case xs nil dmax foldr dmax tails fold dmax hi case xs nil dmax fot fot spec 
obtain recursive definition fot xs case xs nil dmax fot proposition fot xs hi foldr dmax tails xs proof 
derivation constitutes proof fact proof needs justification depends critically fact steps cost equivalences see prove directly usual method showing simulation 
details left exercise 
nave time analysis theory cost equivalence interested computing normal form cost equivalences ei case nil undefined foldr dmax tails case nil undefined foldr dmax tails case nil undefined fot quadratic case informally speaking dmax evaluates arguments determine answer 
amount evaluation bounded length answer 
suggests obtain worst case inputs size result length input 
furthermore force dmax recurse various tails input far possible element wise equal 
inputs form ab satisfy requirements result input pair tails 
aab element wise equal including element shorter 
definition denote list consisting followed single show family lists gives rise quadratic time performance 
family functions instrumental expressing key cost equivalence definition functions ft scheme xs xs xs case xs nil nil list valued arguments traverses argument depth properties follow easily proposition 
hi 

hi 

expressions nil ht ei max hei state key cost equivalence need technical construction nave time analysis theory cost equivalence definition closed expression element cheap exists set containing expression property satisfied 
hi normal form intuition definition element cheap expressions evaluates head normal form property holds tail list tail tail 
gives example needed proposition element cheap fot 
proof 
definition need construct set containing fot satisfying condition proposition 
set take element fe element assume fot evaluates cons done 
remainder proof straightforward case analysis evaluation fot omit details 
proposition element cheap dmax hi hi dmax proof 
prove cost equivalence second similar symmetrical 
element cheap hi unfolding dmax applying tick laws outer case expression dmax hi case nil nil dmax precedes show induction cost equivalent base just nil simplifies dmax nil precedes nil hi hi hi induction case simplifies dmax precedes hi dmax normal form gamma element cheap apply inductive hypothesis dmax hi hi tm hi tm hi tm nave time analysis theory cost equivalence final analysis draw components show 
assume 
simplifying cost equivalence section bi case nil undefined fot omega fot gamma ff take advantage knowledge extensional properties proof particular normal form fot general case omega dmax fot gamma ff omega fot gamma ff rop rop omega fot gamma ff rop case direct calculation time rules solve recurrence give returning main problem bi omega fot gamma ff gamma gamma final intermediate steps general necessary obtain result 
particular technicalities definition proposition regarding element cheap expressions properties dmax eliminated direct proof final analysis help result robust respect example order tails folded 
example easy exercise show replacing foldr fold left essentially change quadratic time case 
call need compositionality calculus simple operational origins describes call name evaluation mechanism actual implementations lazy evaluation call need 
example consider definition average xs divide sum xs length xs divide primitive function sum length obvious functions lists 
reasoning evaluation instance average method overestimate nave time analysis theory cost equivalence evaluation time duplication expression substitution body average 
assuming normal form non empty list integers compute necessary calls sum length cons result computed performed independently sum length copies call need evaluation cost shared 
solution operational model takes account sharing expressions evaluations 
unfortunately may overly complicate calculus impractical promising general approaches modelling sharing storage may prove usable 
solution move compositional approaches mentioned 
suitable interface compositional approach differs genuine strictness absence information operational approach burn notion evaluator 
evaluator operational concept provides link information provided list extensions strictness analysis operational semantics 
particular strictness analysis tell application average evaluated safe evaluate argument normal form evaluation occur anyway 
terms calculus account advance amount evaluation performed argument obtain compositional analysis better approximation call need hei section describe new formalization evaluators appropriate providing smooth interface compositional non compositional call need call name approaches time analysis 
development order language higher order programs 
demands burn formalization evaluators couched terms reduction strategies typed lambda calculus constants 
evaluator defined relative particular scott closed set denotations reduction strategy fails terminate exactly denotation term set 
example leftmost outermost reduction strategy fails terminate denotation term scott closed set definition evaluator constructive 
scott closed set burn provide operational definition evaluator set 
approach taken operational semantics language issues reduction strategy internalized evaluation relations 
order evaluator concept reasoning evaluation cost need constructive definition evaluators 
define family evaluators show relations viewed instances 
starting point definition language demands 
interpret demand specification degree evaluation define evaluation relation realises demands 
holmstrom particularly simple language demands context compositional time analysis 
interpretation demand sense relative particular expression demand expression representation approximation denotation 
language demands precise purposes 
language demands closer example lindstrom lattice demands dybjer formal opens nave time analysis theory cost equivalence interpretation demand closely related strictness 
operational interpretation demand evaluator turn reminiscent definition computing expression proper evaluation degrees 
definition language demands ffl demand ffl zero demand satisfied expression 
demand satisfied expression evaluates constant including nil easily extend demands include demands individual constant 
cons demand satisfied expression evaluates cons head tail satisfy respectively 
restricted form disjunctive demand constant cons add recursive demand useful specifying demands lists 
informal reading demand easily formalized set expressions satisfy demand shown open respect usual operational preorder 
pursue formalization just focus operational interpretation demands evaluators 
definition closed demand define associated evaluator family evaluators defined inductively relations closed expressions satisfy rules ffl dfx xg note evaluators defined basic reduction engine difficult show evaluators deterministic partial function proofs evaluation judgements unique 
ff write proof uses instances rule fun 
show previous evaluation relations viewed instances evaluators proposition 
ffl ffl 
proof 

part simple 
follows definition evaluators considering cases nave time analysis theory cost equivalence 
induction size proof abbreviate clearly case follows proposition proof form induction hypothesis rules evaluation normal form proposition conclude required 
follows routine induction structure normal form appealing proposition 
details omitted 
give definition time rules extend definitions subsume definitions 
rules obvious include completeness fig 

possible show provide details cost equivalence hei ffl hei hei hei hei hei hei ae fig 

demand time rules congruence respect demanded time rules hc hc demand weakness model respect call need computation substitution operation duplicates expressions consequently share evaluations expression head normal form subsequent evaluations sub expressions 
hei need informally denote call need cost evaluating expression demand suppose know condition delta holds nave time analysis theory cost equivalence application function evaluated demand argument satisfy demand words arguments exists case refine call name model follows 
hf hei hf hf need attempt rigorous justification second inequality wewould naturally need formalize mean call need evaluation 
nontrivial task scope leave open problem 
informal explanation inequality 
difficult show condition delta holds exists expression satisfy satisfies case sub proof judgement form proof occur proof backtracking needed proof construction condition implies perform computation consider proof proof essentially structure proof evaluation aforementioned sub proofs replaced zero cost sub proofs form inequality arises costs multiply occurring sub proofs evaluation proof arising expression duplication may counted hei satisfactory proof sketch 
nice algebraic proof mention proof trees explicitly 
cost equivalence related tools improvement may useful 
demand propagation order method refining call name model need establish context demand expression placed hole satisfy satisfy demand satisfied composite expression 
course demands hole unique 
example expression placed hole satisfy trivial demand ffl 
trivial demand allow refine call name cost model 
general want determine large demand hole possible 
shall pursue problem demand propagation mention connections studied strictness analysis problem 
mentioned earlier demand propagation formalized modelling demand set expressions satisfy 
sets shown open right closed operational expressions problem viewed inverse image analysis problem albeit expressed terms operational model denotational 
corresponding problem higher order language easily tackled forwards analysis information complement demand elements satisfy propagated forwards sub expressions context 
corresponds higher order strictness analysis described 
principle approach described extended higher order language obvious higher order demand simple strictness operational interpretation remains inherently non compositional aspect 
higher order approach described ch 

constructive version burn evaluation transformer theorem investigations 
nave time analysis theory cost equivalence comparison earlier compositional approaches place approach outlined section comparison compositional methods time analysis overviewed section 
demands refine call name evaluation time give better approximation call need consistent strictness information necessary time analysis 
key difference strictness information necessary time analysis give lower bound call need computation cost give upper bound turn bounded call name cost 
cases quality demand information determines tightness bound 
argue method useful 
time analysis described wadler order instance sufficient time analysis gives upper bound call need time different manner uses information absence constancy describes parts expression evaluated 
unfortunately case quality upper bound determined quality absence information upper bound may defined program approach described holmstrom fully compositional method order functional programs lazy lists 
approach harder compare demand information exact call need time analysis exact treatment call need formalized 
precision authors note serious drawback reasoning programs step decide demand output 
language demands precise order reason computation program normal form demand exactly describes normal form words representation normal form 
immediately obvious introduce approximate demands approach running definedness problems wadler method 
summarize approach sketched section advantages ffl provides safe defined time bound lying call need call name costs ffl allows flexibility demand information targeted 
compositionality needed decompose time analysis large program 
suspected call name model crude 
method exposition inspired formulating constructive operational version burn evaluators retrospect approach closer original time analysis programs type theory operational basis 
connection evaluators occur absence non terminating computations language 
related review related theory cost simulation 
quality confused safety assume information safe sense predicts property program property hold 
nave time analysis theory cost equivalence non standard theories equivalence talcott introduced broad semantic theory side effect free lisp languages notable treatment extensional intensional aspects computation 
particular class called comparison relations introduced side effect free lisp derivative 
method definition similar definition operational approximation simulation cost aspects built definition directly 
class comparison relations said contain relations analogous cost equivalence relation considered just observation cost simulation viewed refinement pure simulation involving time properties suggested topic certain comparison relations developed provide soundness improvement proofs program transformation laws 
maximal comparison relations essentially usual operational approximation equivalence relations application considered detail 
aspects mason sketches definition family equivalence relations involving variety operation execution counts 
pure language higher order functions lazy data structures relations relatively uninteresting structure 
moggi categorical semantics computation intended suitable capturing broader descriptions computation just input output behaviour 
gurr studied extensions denotational semantics take account resource shown moggi approach model computation way program equivalence captures equivalence resource requirements 
gurr extends moggi calculus formal system reasoning equivalence sequents reasoning resource properties directly ability depends certain representability issues resource correspond type metalanguage 
resulting calculus dubbed com 
compare approach taken cost equivalence resource equivalence conjunction set time rules reason cost property directly 
analogies details gurr approach defines rules sequents form gamma com ti says expression value type consumes resource goes show rules redundant information expressed calculus addition specific axioms 
particular entailment imply gamma canonical term unit type consumes time 
notice similarity axiomatization cost equivalence uses identity function computational calculus 
important difference approach concepts derived correct respect operational model may argue operational approach provides appropriate starting point semantic study efficiency deeper connections approaches deserves study 
important difference consider lazy recursive data structure 
possible method dealing context moggi framework combine pitts induction interestingly gurr gives operational semantics call value terms com calculus leaves property corresponding theorem conjecture 
nave time analysis theory cost equivalence principal recursively defined domains 
aspects gurr concerned giving semantic framework aspects asymptotic complexity outside scope 
category theoretic approach intensional semantics brookes geva 
places heavy emphasis relationship intensional semantics underlying extensional 
key structure monad contrast gurr moggi monadic style suitability formulating kind intensional semantics described obvious 
program improvement generalizations theory cost simulation significant right potentially interesting relations preorders equivalences involving time investigated similar manner 
example consider program refinement relation largest relation 
approach cost simulation shown pre congruence consequently contexts hc ff hc ff restated efficient context 
proof technique illustrated section systematic means verifying refinement laws append append append append notion refinement possible semantic criterion albeit somewhat intensional correctness context free program transformations 
main foundation theories improvement equivalence definition appropriate simulation relation proof satisfies substitutivity property 
variation language addition new operators new definition improvement means require constructions 
somewhat tedious separate study problem finding general formulation theory improvement relations addressed 
general class lazy languages shown preorder computational properties improvement ordering induces simulation style expressions definitions cost simulation program refinement simple instances 
borrowing syntactic conventions semantic techniques conditions operators language guarantee improvement ordering precongruence 
conditions appear relatively easy check 
furthermore higher order language studied special case 
context computational property considered function proof evaluation judgement computation preordered set set properties ordered improvement 
main result generalization simulation preorder induced computational property guaranteed congruence property satisfies simple monotonicity note consider strict refinement relation replace definition contextual congruence 
nave time analysis theory cost equivalence requirement respect rules operational semantics 
result generalized howe class structured computation systems 
direct approach reasoning time cost lazy evaluation 
calculus takes form time rules extracted suitably simple operational semantics equivalence laws substitutive respect rules 
aim calculus reveal algorithmic structure operationally opaque lazy functional programs permit traditional techniques developed context analysis imperative programs initial experiments calculus suggest practical pedagogical 
desire substitutive equivalences time rules led theory cost equivalence non standard notion operational approximation called cost simulation 
cost equivalence provides useful extensions time rules showed technical point view subsumes 
interesting right suggests operationally route study intensional semantics 
initial investigations area reported 
proposed interface calculus compositional method improves accuracy analysis respect call need evaluation able retain simplicity nave approach appropriate 
compositionality operational interpretation evaluators re order computation basis properties 
model provide constructive formulation evaluation transformer theorem formally connects information strictness analysis associated optimisations 
needed strengthen relationship cost equivalence compositional approach 
idea context dependent bisimulation processes studied larsen originating appropriate suggests context demand dependent cost simulation 
partially funded esprit ii bra danish natural sciences research council dart project department computer science university copenhagen diku esprit iii bra coordination 
various contributions chris hankin sebastian hunt bent thomsen author imperial college various members project time numerous suggestions constructive criticisms particular john hughes suggesting time analysis completely expressed terms cost equivalences 
group diku torben mogensen kristian nielsen particular 
special richard bird originally suggested nave approach useful reasoning call name evaluation suggested number improvements incorporated version including example offered way challenge problem 
abramsky 
lazy lambda calculus 
research topics functional programming turner ed pp 

nave time analysis theory cost equivalence addison wesley 
aho hopcroft ullman 
design analysis computer algorithms 
addison wesley series computer science information processing 
addison wesley london 
ariola arvind 
syntactic approach program transformation 
proceedings symposium partial evaluation semantics program manipulation pp 

acm press sigplan notices september 
barendregt 
lambda calculus vol 
studies logic foundations mathematics 
elsevier science publishers nd edition 
barendregt van eekelen kennaway plasmeijer sleep 
term graph rewriting 
parle volume ii number lncs pp 

springer verlag 
bird wadler 
functional programming 
prentice hall 

time complexity programs type theory 
phd thesis chalmers university technology 
holmstrom 
compositional approach time analysis order lazy functional programs 
functional programming languages computer architecture conference proceedings pp 

acm press 
brookes geva 
computational comonads intensional semantics 
categories computer science fourman johnstone pitts eds london mathematical society lecture notes pp 

cambridge university press 
burn 
evaluation transformer model reduction correctness 
tapsoft 
number lncs pp 

springer verlag 
burn hankin abramsky 
theory practice strictness analysis higher order functions 
science computer programming 
burstall darlington 
transformation system developing recursive programs 
jacm 
cousot cousot 
constructive versions tarski fixed point theorems 
pacific journal mathematics 
dybjer 
inverse image analysis generalises strictness analysis 
information computation 
graham knuth patashnik 
concrete mathematics 
addison wesley 
gurr 
semantic frameworks complexity 
phd thesis department computer science edinburgh 
available reports cst ecs lfcs 
hickey cohen 
automating program analysis 
jacm 
howe 
equality lazy computation systems 
fourth annual symposium logic computer science pp 

ieee 
howe 
computational open martin lof type theory 
sixth annual symposium logic computer science pp 

knuth 
volume fundamental algorithms 
art computer programming 
addison wesley 
larsen 
context dependent bisimulation processes 
phd thesis department computing university edinburgh 

automatic complexity evaluator 
acm toplas april 
lindstrom 
static evaluation functional programs 
acm sigplan symposium compiler construction pp 

mason 
semantics destructive lisp 
number csli lecture notes 
csli 
mason talcott 
equivalence functional languages effects 
journal functional programming 
milner 
calculi synchrony asynchrony 
theoretical computer science 
milner tofte 
induction relational semantics 
theoretical computer science 
moggi 
computational lambda calculus monads 
technical report ecs lfcs department computer science university edinburgh 
short version fourth lics conf 
ieee 

luke ong 
lazy lambda calculus investigation foundations functional programming 
phd thesis imperial college university london 
park 
concurrency automata infinite sequences 
th gi conference theoretical computer science 
lncs springer verlag 
peyton jones 
implementation functional programming languages 
prentice hall international series computer science 
prentice hall international uk london 
nave time analysis theory cost equivalence pitts 
induction principal recursively defined domains 
technical report university cambridge computer laboratory april 

automatic complexity analysis 
functional programming languages computer architecture conference proceedings pp 

acm press 
sands 
complexity analysis higher order language 
technical report doc imperial college october 
sands 
complexity analysis lazy higher order language 
proceedings glasgow workshop functional programming workshops computing series pp 

springer verlag august 
sands 
calculi time analysis functional programs 
phd thesis department computing imperial college university london september 
sands 
complexity analysis lazy higher order language 
proceedings third european symposium programming 
number lncs pp 

springer verlag may 
sands 
operational theories improvement functional languages extended 
proceedings fourth glasgow workshop functional programming pp 
august 
springer workshop series 
sands 
time analysis cost equivalence program refinement 
proceedings eleventh conference foundations software technology theoretical computer science 
number lncs pp 

springer verlag december 
sands 
total correctness improvement transformation functional programs 
diku university copenhagen unpublished pages may 
talcott 
essence rum theory intensional extensional aspects lisp type computation 
phd thesis stanford university august 
wadler 
strictness analysis aids time analysis 
th acm symposium principals programming languages pp 
january 
wadler hughes 
projections strictness analysis 
conference functional programming computer architecture pp 
portland oregon september 
wegbreit 
mechanical program analysis 
cacm 
appendices proofs appendix contains details proofs included main text corresponding theorems restated 
proposition proposition closed 

proof 

follows routine inductions structure proofs 
induction structure proof give illustrative case fun fe en xn en suppose en follows fe en xn gamma induction hypothesis gives fe en xn nave time analysis theory cost equivalence head normal form gamma 
conclude semantics application en concludes case 
cases follow similar manner 
proof direction routine induction structure inference lemma lemma 
hei 
hei proof 
part immediate definition cost simulation 
second part proceeds induction structure value ffl suppose proposition definition cost simulation proposition ffl suppose induction hypothesis gives ea ea ea implies ea implies proposition know implies know instance induction hypothesis rule cons follows proposition 
theorem theorem closed expressions hi 
proof 
routine induction structure proof argue cases rule applied 
sketch couple cases 
fun assume en defined yn inference proof form fe delta delta delta en en follows fe delta delta delta en gamma induction hypothesis fe delta delta delta en hi gamma congruence follows fe oe delta delta delta en oe hi fun transitivity en hi 
case consider possible rules evaluation case expression assume inference form fe case nil xs nave time analysis theory cost equivalence follows fe satisfying induction hypothesis gives hi case nil xs hi case nil xs case nil xs hi case nil xs case nil xs hi fe induction hypothesis applied second sub proof gives fe hi congruence substituting right hand side left previous equation conclude case nil xs hi desired result follows fact 
theorem theorem commonly indexed families closed expressions expressions containing variables ef xg ef xg proof 
define relation ef xg ef xg contains variables sufficient show 
abbreviate substitutions xg xg oe oe respectively 
assume eoe sufficient prove eoe establish induction structure proof eoe cases structure expression cases expressions lambda abstraction application identical lemma 
remaining cases assume domain oe just rename 
axiom lambda expressions time rule eoe boe boe eoe boe boe remains show boe boe follows easily fact closed boe oe oe boe rule application follows oe bfe oe yg judgement inductive hypothesis allows conclude oe closed expression substitutions ffi ffi non empty common domain related range dffi dffi expression containing variables domain ffi 
closed loss generality assume structure satisfies cases nave time analysis theory cost equivalence 

xa 

consider judgement bfe oe yg rule application equivalent judgement oe case analysis oe 
definition oe bfe oe yg 
definition argue 
dffi dffi assume loss generality variables oe ffi fyg distinct 
substitutions details omitted easy see bfe oe yg oe yg dfe dfe oe oe yg fe oe yg shows bfe oe yg fe oe yg induction hypothesis case conclude fe oe yg rule application conclude eoe required 
largest cost precongruence appendix give details technical development outlined section characterizes cost simulation largest cost congruence 
definition 
theorem maximal fixed point prove difficult half equality sufficient show 
unable prove property induction proof pure operational simulation straightforward 
alternative definition cost simulation limit descending sequence relations proposition 
identity function ffi proof 
sufficient show anti continuous see 
decreasing sequence delta delta delta rn delta delta delta rn rn half follows directly monotonicity 
suppose rn non trivial case ef rn definition rn rn giving rn required 
sketch proof theorem 
nave time analysis theory cost equivalence proof 
follows fact precongruence monotone 
remains show show contrapositive expressions define 
form decreasing chain proposition follows exists smallest largest call maximum distinguisher 
negating definition see exists context 
call context distinguishing context 
prove induction maximum distinguisher exists distinguishing context ce 
base immediately follows simple context distinguishes 
induction maximum follows follows maximality maximum distinguisher maximal 
suppose maximal case similar 
induction distinguishing context cp easily construct context case nil nil xs cp distinguishes 
definition pure cost congruence pc defined relation closed expressions pc contexts exists say context cost distinguishes pair expressions pc 
definition say language satisfies cd condition constants pc proposition pc cd condition satisfied 
proof 
definition 
clearly pc sufficient show pc supposing exists distinguishing context 
suppose sufficient cost distinguish case 

constant case pc follows cd condition pc precongruence pc second case context form case cost distinguish pc precongruence 
cd condition particularly strong satisfied binary equality test constants included primitive functions constant consider context nil fail fail expression lacking head normal form 
hand cd condition fails distinct constants language call error error primitive functions undefined apply error undefined 
distinguish error error basis cost distinct cost equivalent 
cost equivalence largest congruence respect time rules head normal form modulo partial correctness rules reflected convergence conditions 
corollary cd condition satisfied hi hc hc nave time analysis theory cost equivalence lemma fact hi congruence allows extend corollary include evaluation normal form rules 
fact possible show completely replace corollary left exercise 
received may 
