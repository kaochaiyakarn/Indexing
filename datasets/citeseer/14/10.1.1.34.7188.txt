fusion recursive programs computational effects alberto pardo instituto de computaci universidad de la rep uruguay pardo edu uy fusion laws permit eliminate various intermediate data structures created function compositions 
fusion laws associated traditional recursive operators datatypes general transform recursive programs effects 
motivated fact addresses definition recursive operators datatypes capture functional programs effects 
effects assumed modeled monads 
main goal derivation fusion laws new operators 
new operators called monadic unfold 
captures programs effects generate data structure standard way 
operator called monadic hylomorphism corresponds programs formed composition monadic unfold followed function defined structural induction data structure monadic unfold generates 
common approach program design functional programming recursive operators datatypes tool structuring programs 
typical examples operators include map fold unfold primitive recursion 
recursive operators datatypes encapsulate common patterns computation structure programs data structures traverse generate 
key feature operators derived categorical interpretation recursive types 
categorical approach permits algebraic laws operators provides smooth framework conducting calculations :10.1.1.41.125
algebraic laws useful deforestation 
called fusion laws 
deforestation program transformation technique means intermediate data structures eliminated 
functional programming interest technique due fact programs constructed composition smaller ones intermediate data structures connect subprograms 
compositional style programming suitable program modularization 
programs developed style may inefficient time space mainly proliferation intermediate data structures caused function composition 
way structuring functional programs effects produce 
accomplished monads :10.1.1.100.9674
monads capture unified framework wide variety computational effects state exceptions input output 
encapsulate action effect data type result occurrences effect program explicit expressed terms data type operations 
effect reflected type program form mb 
monads permit imperative features destructive update input output integrated purely functional language see 
compositional style programming mentioned previously applied programs effects 
concerning deforestation fusion laws pure programs general programs effects 
basically problem programs monadic effects shapes recursion general captured recursive operators originally thought pure programs 
motivated fact address definition recursive operators permit represent programs monadic effects 
main goal derivation fusion laws operators provide cases deforestation kind programs 
works investigated interaction monads recursion specific case programs consume data structure 
interaction case captured operator called monadic fold version standard fold operator represents programs effects defined structural induction input data structure :10.1.1.41.125
concerned dual case 
investigate class recursive programs effects structure dictated values produce output 
contributions new operator called monadic unfold captures pattern recursion class programs 
monadic version standard unfold operator 
example function follows pattern recursion getline 
function defined functional language haskell reads line standard input stores characters list 
effect case modeled io monad monad input output 
computations monad denote actions perform input output operation return value 
actions combined sequence follows variable binds result 
result expression primitive action getchar reads character standard input returns 
define getline follows getline getchar eol unit nil getline unit cons action form unit performs input output returns value observe structure getline body determined construction list 
practice find programs satisfy scheme build data structure unfold means fold compute output value data contained structure 
functional programs kind called hylomorphisms 
contribution monadic version hylomorphism called monadic hylomorphism corresponds composition monadic unfold followed monadic lifting fold 
monadic hylomorphisms represent programs produce effect phase generation intermediate data structure 
programs kind uncommon programming practice 
nice property monadic hylomorphism phases joined single program avoids generation intermediate data structure 
example monadic hylomorphism function computes length line read standard input 
defined follows getline unit length length function length nil length cons length 
efficient version obtained joining parts 
getchar eol unit unit rest organized follows 
section reviews categorical approach program calculation 
section presents background material monads 
section study called monadic extension functor 
section concept defining monadic operators 
briefly review monadic fold 
introduce monadic unfold monadic hylomorphism 
section deals non trivial applications developed monadic unfold hylomorphism 
section gives concluding remarks 
preliminaries category theoretic explanation recursive types idea types constitute objects category type constructors functors setting datatype understood solution type equation fx appropriate endofunctor captures shape signature type 
section reviews relevant concepts concerning categorical approach recursive datatypes application program calculation :10.1.1.41.125
show recursive operators calculational properties derived elementary categorical constructions 
interesting feature constructions parameterized signature datatypes involved 
natural consequence resulting operators generic definitions families datatypes 
specific versions operators particular datatypes may obtained instantiation 
form parametricity type constructors basis developments generic polytypic programming precisely approach follow 
section various parts default category stand cpo category pointed cpos complete partial orders possessing element continuous functions 
main reason working cpo various recursive operators going consider sense domain theoretic setting need defined fixed points recursive equations 
case hylomorphism monadic versions unfold hylomorphism introduce 
usual function pointed cpos said strict preserves element final object cpo singleton set written 
cpo denote subcategory cpo formed pointed cpos strict continuous functions 
functors consider restricted class datatypes called regular datatypes 
datatypes declarations contain function spaces recursive occurrences arguments left hand sides 
signatures called regular functors 
start introducing consider basic functors stands identity functor defined identity objects arrows 
denotes ary constant functor maps tuples objects object tuples functions identity id simply write write pi denote th projection functor ary product category 
product bifunctor theta theta defined cartesian product theta bg set category sets total functions cartesian product categorical product cpo 
write theta theta denote left right projections 
pairing arrows written hf gi theta product associativity natural isomorphism denoted ff theta theta 
theta theta sum bifunctor theta defined separated sum theta theta 
sum inclusions inl inr defined inl inr 
separated sum fails coproduct cpo see cpo coproducts 
means continuous functions case analysis defined strict function unique mediating morphism satisfies equations ffi inl ffi inr fusion law includes strictness requirement strict ffi ffi ffi functional programming notation case analysis written case inl inr generalizations product sum components obtained obvious way 
composition functor functors arity written hg hg short omit brackets 
stands functor maps 

write gi theta regular functors functors built identities constants projections products sums type functors composition 
inductively defined grammar pi theta hf stands type functors correspond fixed points parameterized regular functors introduced subsection 
functor cpo said locally continuous operation functions continuous 
particular verified regular functors locally continuous 
fold endofunctor algebra pair consisting object called carrier morphism fa called operation 
algebra map homomorphism algebras fa fb arrow carriers commutes operations ffi ffi ff algebras homomorphisms form category 
shall refer alg 
composition identities category inherited canonical solution domain equation fx locally continuous endofunctor cpo specified pointed cpo isomorphism ff see example :10.1.1.50.8851
datatype contains partial finite infinite values 
algebra strict function encodes constructors datatype 
shall denote inverse ff exists homomorphism algebra fa see :10.1.1.50.8851
homomorphism gives rise recursive operator usually called fold catamorphism captures function definition structural recursion 
shall denote jhj fold corresponds fixed point jhj fix ffi ff ffi possible verify algebra strict jhj 
equation holds definition homomorphism 
jhj ffi ffi jhj states fold consumes input data structure replacing constructors target algebra may exist multiple homomorphisms algebra means weak initial alg 
reason define fold homomorphism algebra category initial algebra alg exists regular functor fold defined unique homomorphism initial algebra algebra 
examples categories holds set cpo :10.1.1.50.8851
illustrating specific instances fold datatypes explain parameterized datatypes modeled 
fixing argument bifunctor theta get unary functor gamma written fa fa fa id 
functor fa induces parameterized datatype da fa constructors fa fa da da canonical solution recursive equation 
example functor la theta captures signature lists elements lists usually declared functional programming language follows list nil cons theta list write list 
datatype lists corresponds canonical solution equation theta constructors nil cons theta part isomorphic algebra nil cons theta strict algebra theta fold strict function jhj la nil cons corresponds standard foldr operator functional programming 
ii leaf labelled binary trees tree leaf join tree theta tree obtained recursive equation ba theta constructors algebra leaf join tree theta tree tree 
fold operator jhj ba leaf join folds enjoy useful laws program calculation 
identity law jin id states fold constructors equal identity 
possible reading law id endomorphism 
law plays important role calculations called fusion law strict ffi ffi ff ffi jhj jh states composition strict homomorphism fold fold 
unfold functor coalgebra pair consisting object carrier arrow fa operation 
functor plays role signature structure 
coalgebra map homomorphism coalgebras fa fb arrow ffi ff ffi just algebras coalgebras homomorphisms form category coalg 
coalgebra ff inverse strict function encodes destructors datatype 
turns final coalg 
means exists unique homomorphism coalgebra fa unique homomorphism gives rise operator called unfold anamorphism denoted satisfies equation ffi ffi equivalently ffi ffi equation states unfold recursively builds data structure decomposing argument coalgebra unfold defined way category final coalgebra exists regular functor 
example set cpo 
example functor sa theta captures signature datatype streams formed infinite partial sequences elements stream coalgebra hh ti theta pairing functions final coalgebra theta gives destructors inverse scons theta constructor streams 
unfold operator unique function sa head ffi tail ffi ffi equivalently scons ffi hh ffi ti ii consider la theta coalgebra theta unfold operator lists unique function la case inl 
nil inr cons calculational laws unfold derived finality instance identity law states unfold destructors equal identity 
id corresponding fusion law ffi ff ffi ffi states composition unfold homomorphism yields unfold 
type functors da fa parameterized datatype induced bifunctor functor called type functor defining action df da db arrow equally fold unfold 
df jin fb ffi id db fa id da ffi fa fb example lists action arrows list nil cons ffi theta id la corresponds known map function list nil nil list cons cons list example shows type functors may defining datatypes 
example rose trees elements multiway branching trees declared rose fork theta list rose signature captured functor ra theta list 
algebra theta fold function jhj ra rose fork list hg theta unfold function ra rose fork ffi hg list ffi standard laws type functors called map fold fusion unfold respectively 
jhj fb ffi df jh ffi id fa df ffi fa id ffi fb hylomorphism fold unfold express standard ways consuming generating data structures respectively 
look functions composition fold unfold 
capture idea structuring computation implicit intermediate data structure 
algebra fa coalgebra fb hylomorphism hylo short function defined jhj note definition sense setting data structures produced unfolds consumed folds case cpo 
applying identity laws immediate see folds unfolds jhj equivalently fixed point definition fix ffi ff ffi alternative definition shows transform composition fold unfold single function avoids construction intermediate data structure 
expanding definition obtain equation ffi ffi expresses shape recursion comes datatype 
known examples quicksort merge sort 
sorting methods implicit data structure different kind binary tree determines shape call trees see 
example consider functor la theta theta theta hylomorphism lists la fix ffi id theta ffi functionally expressed follows case inl 
inr expressiveness rich 
practice interesting recursive function fixed point operator see expressed hylo 
fusion laws strict ffi ffi ff ffi ffi ff ffi ffi direct consequence fusion laws fold unfold respectively 
demonstrated useful effective application deforestation techniques see 
motivated existence laws usually referred acid rain theorem certain conditions permit fuse composition folds unfolds yielding new 
theorem need introduce notion transformer 
function fa 
ga converts algebra algebra carrier said transformer fa fb ffi ffi ff ffi ffi gf transformer homomorphism algebras happens homomorphism respective algebras 
obviously similar notion defined coalgebras 
function fa 
ga said transformer coalgebras fa fb holds ffi ff ffi ffi gf ffi 
theorem acid rain hylo fold fusion fa 
ga transformer 
strict jhj ffi unfold hylo fusion fa 
ga transformer 
ffi proof 
show proof hylo fold fusion case analogous 
suppose fa strict 
recall fold homomorphism algebras 
definition transformer obtain jhj homomorphism algebras gf ga addition observe jhj strict hypothesis strict 
arrive desired result 
folds unfolds particular cases write specialization theorem terms folds unfolds solely 
strict transformer jhj ffi jt jt transformer ffi hand obtain generalization theorem substituting fold unfold respective 
version theorem commonly literature see 
monads interested studying recursive programs effects 
monads permit uniformly express wide variety computational effects exception handling state computations parsing nondeterminism functional setting 
moggi proposed monads mechanism structuring denotational semantics descriptions programming languages 
wadler introduced monads functional programming showing technique applied structuring functional programs produce effects :10.1.1.33.5381
years structuring method monads style programming widely adopted haskell community 
section reviews monads need 
concept monad originates category theory defined various ways 
start formulation terms called kleisli triples appears suitable programming purposes 
definition kleisli triple unit gamma category restriction obj obj functor objects natural transformation unit extension operator gamma mb yields ma mb equations hold unit id ma ffi unit ffi ffi monads introduces explicit distinction notions value computation 
computations delivering values type regarded objects type ma 
interpretation unit understood operation turns value computation yields value producing effect 
extension operator gives way composing monadic functions passing effect kleisli monadic composition functions mb mc defined follows ffl def ffi assign meaning kleisli triple laws 
laws amount say unit left right identity respect kleisli composition expresses composition associative 
words kleisli triple laws just express monadic morphisms form category 
definition kleisli triple unit gamma kleisli category cm defined follows objects cm morphisms objects cm correspond arrows mb cm mb identities unit ma composition kleisli composition 
context functional programming monad kleisli triple unit type constructor unit ma polymorphic function ma theta mb mb polymorphic infix operator typically called bind 
kleisli triple laws translate corresponding equations terms unit 
see example :10.1.1.100.9674
expression corresponds 
keep notations bind better suits 
infix notation turns preferable writing functional programs monadic style gives graphical idea sequencing exists computations 
sense expressions form usual read follows evaluate computation bind variable resulting value continue evaluation computation kleisli star notation hand suitable performing formal manipulation 
example monads identity monad simplest unit id simply captures function application ffl ffi 
ii exception monad models occurrence exceptions program 
stands type exception values ma captures computations succeed returning value type fail raising specific exception signaled value type corresponding unit extension operator unit inl inr unit takes value returns computation succeeds 
extension operator may thought kind strict function application propagates exception case 
particular case having unique exception value unit type exception monad referred monad :10.1.1.33.5381
iii state computations modelled state transformer monad state monad short 
computations take initial state return value new state 
stands state space ma theta 
unit bind operator unit theta 
unit takes value returns computation yields value modifying state 
bind operator sequences computations state value resulting supplied second 
various proposals shown state monad effective tool encapsulating actual imperative features mutable variables destructive data structures retaining fundamental properties referential transparency see 
achieve goal hiding real state data type monad equipped operations internally access real state 
technique applied state internal external program 
typical case monad define lifting functor gamma cm identity objects unit ffi mb define functor cm objects ua ma arrows uf ma mb mb 
simple verify gamma functors form adjunction gamma cm unit ffl id alternative definition monad 
definition monad triple unit formed endofunctor natural transformations unit mm called multiplication obey laws ffi unit ma id ma ffi unit ffi ma ffi formulations monad equivalent 
fact kleisli triple components define action arbitrary arrow mf unit ffi multiplication id ma conversely kleisli triple constructed monad unit considering restriction functor objects defining extension mb ffi mf property specific monads cpo 
lemma multiplication monad cpo strict operation 
property known 
haven seen literature prove anyway 
proof 
definition ffi unit ma id ma object property holds cpo strict function see proof 
strict identity 
example list monad permits describe computations yield list results ma unit cons nil concat concat nil concatenates list lists list theta concatenates lists form longer list 
standard functions functional programming 
computations kind may thought offering choice values model form nondeterminism 
ffi mf concat ffi list concat fold applying map fold fusion law get nil ffi theta id la nil nil cons 
subsequent sections assume monads deal strong 
notion strong monad derived strong functor 
endofunctor category product called strong comes equipped natural transformation theta mb theta called strength satisfying equations ffi thetac ffi id theta ffi ff mc ff ffi thetab monad unit called strong strong functor addition unit strong natural transformations expressed equations unit thetab ffi id theta unit thetab ffi ffi mb ffi id theta example cartesian closed category set cpo correspondence strengths functors 
endofunctor enriched natural transformation oe strong functors called strong compatible strengths 
oe thetab ffi ffi ida theta oe 
exponentiation natural transformation fmap fb action arrows setting strong monad equivalent monad enriched functor 
equations say unit enriched natural transformations 
strength interpreted function unit possible define dualization strength ma theta theta satisfying similar axioms 
strengths induce natural transformation ma theta mb theta ffl mb describes monad distributes product 
says pair computations may joined new computation evaluating argument second 
functionally expressed unit equation holds ffi unit thetaid mb similarly define right left product distribution ffl ma strong monad said commutative product distributions coincide monads identity state reader called environment monad commutative :10.1.1.100.9674
monad commutative set example cpo 
suppose want join computations monad diverges fails 
computation results diverge fail 
examples non commutative monads exception multiple error values state list 
monadic extensions functors previous section saw morphisms category mapped kleisli category action lifting functor gamma cm section focus attention functors functor describe derive construction denoted acts elements kleisli category 
call construction monadic extension particular case regular functor see monadic extension defined induction structure 
analogous definitions 
main properties monadic extensions satisfy see details 
usefulness monadic extensions clear section address definition recursive operators represent functions effects 
see properties monadic extensions play relevant role calculational theory operators 
monadic extension functor construction cm cm objects fa fa recall objects cm coincide applied monadic function mb yields arrow ff fa fb ff fa fb cm action embodies observe monadic extension satisfies equality gamma gamma objects 
monadic extensions cm cm correspondence natural transformations ffi fm mf called distribution laws perform distribution monad functor 
effect distribution law ffi define action monadic extension arrows mb follows ff fa ff fmb ffi mfb conversely distribution law ffi derived monadic extension adjunction cm mentioned section ffi id ma easy verify equalities hold monadic extension mf ffi ff mg ffi ffi ff ffi monadic extension called lifting happens functor cm theorem monad unit functor cm cm lifting iff natural transformation ffi fm mf satisfies equations ffi ffi unit unit fa fa ffi ffi ffi ffi ma ffi ffi fa equations ensure functoriality axioms hold 
equation considers preservation identities unit unit fa lifting distribute composition kleisli category ffl ff ffl analyse behaviour specific functors 
start functors involving product 
proposition category cartesian 
strong monad object functor theta gamma lifting ffi strength 
holds gamma theta ffi dualization strength 
conditions theorem generalized functors straightforward manner see 
proposition uses generalization 
proposition category cartesian 
commutative monad 
product functor theta theta lifting ffi theta 
lifting product obtained right left product distribution proof proposition 
monad strong noncommutative state monad product functor hold fails ffi unit theta unit unit thetab thetab ffi ffi ma mb ffi theta words monadic extension theta strong non commutative monad lacks preservation kleisli composition 
see happens sum functor 
proposition category coproduct 
sum functor theta lifting ffi inl inr 
note interesting case obviously left proposition sum functor cpo 
reason category coproduct 
said sum functor adopted cpo separated sum 
define monadic extension separated sum uses distribution law proposition ffi inl inr 
proposition monadic extension defined lifting may lack preservation identities 
fact may happen ffi ffi unit unit unit problem inequation equality unit strict function 
unfortunately monad satisfies property 
example monads exception state non strict unit 
hand see preserves kleisli compositions provided strictness preserving functor 
words equation holds separated sum ffi ffi ffi ffi ma mb ffi ffi proof equation uses fact multiplication monad cpo strict function see lemma 
construction preserves compositions necessarily identities called semi functor 
consider regular functors general 
analyze distribution laws monadic extensions corresponding regular functors assumption underlying category product coproduct initial algebra regular functor 
regular functors cpo hand discussed section 
definition strong monad regular functor define distribution law ffi fm mf induction structure follows 
ffi id ma ffi inl inr ffi unit ffi hg ffi ffi ffi ffi gn ffi pi id ma ffi jmin fa ffi ffi da fma ffi theta analogous definitions 
abbreviation 
ffi theta defined means monadic effects products sequenced left right right left policy specified 
definition ffi form monadic fold bifunctor induces ffi known passive traversal function thread 
definition typical cases calculated ffi thetag ffi ffi theta ffi ffi inl ffi ffi inr ffi ffi example 
la theta ffi la inl inr ffl theta mx theta 

ba theta ffi ba inl inr ffl mx theta mx theta 

ra theta list ffi ra ffi unit theta ffi list ffi id theta ffi list theta mx theta ffi list nil cons ffl mx mx functor called strictness preserving action arrows maps strict function strict function mf example shown freyd locally continuous functor cpo strictness preserving 
ffi list nil unit nil ffi list cons ffi list xs unit cons xs means ffi list collect left right results accumulate effects produced list computations 
right left accumulation accomplished ffi theta defined definition derive monadic extension regular functor inl ffi inr ffi cf unit hg pi df jmin fb ffi id fa theta ffi theta particular theta ffi theta gf inl ffi ff inr ffi gf extension usually called monadic map known active traversal 
expression obtained applying map fold fusion law composition ffi ffi df example distributions laws example give rise extensions 
la inl inr ffl ffi id theta 

ba inl inr ffl ffi theta 
ba case inl unit inl inr unit inr 
ra ffi id theta list list nil cons ffl ffi theta id 
list nil unit nil list cons list unit cons theorem category product coproduct initial algebra regular functor 
commutative monad regular functor extends lifting 
proof theorem induction structure regular functors 
consists verification equations distribution laws definition see details proof 
cases product sum functors propositions 
commutativity monad product functor slightly weaker results stated eliminating assumption 
proposition category strong monad 

extension regular functor preserves identities 

regular functors containing product expressions form theta gamma gamma theta object extend lifting 
proof 
case follows fact commutativity verification equation 
recall functors theta gamma gamma theta lifting strong monad see proposition 
proof remainder regular functors proceeds theorem 
conclude section short analysis monadic extensions regular functors cpo 
see details 
observe distribution laws definition reused regular functors cpo assumptions underlying category possesses coproduct initial algebra regular functor hold setting 
fact assumptions effect definition distribution laws 
essential asserting properties deduced corresponding monadic extensions 
consequently order achieve similar results cpo need substitute invalid assumptions 
asserting general results analyze case specific functors 
example results stated propositions apply setting cartesian product categorical product cpo 
case sum functor cpo discussed note 
saw monadic extension separated sum preserves identities provided monad possesses strict unit preserves kleisli compositions functor monad strictness preserving 
possible verify essentially holds extensions type functors 
give idea fact means concrete example 
consider monadic extension list type functor list described example 
strict fold target algebra strict 
particular list unit strict 
unit strict 
case follows list unit unit 
contrary unit strict hard verify list unit unit function 
summing state 
proposition strong monad cpo strict unit strictness preserving functor 
monadic extension regular functor preserves identities 
proof induction structure regular functors 
uses fact hypothesis monadic extension regular functor strictness preserving operation see details 
concerning preservation kleisli composition stated 
proposition strong monad cpo strictness preserving functor 

commutative monadic extension regular functor preserves kleisli compositions 

monadic extension regular functor containing product expressions form theta gamma gamma theta preserves kleisli compositions 
example strong monad cpo strictness preserving functor non strict unit 
consider extensions example 
la semi functor la sum 

ba preserve identities ba sum 
preserve compositions needs commutative ba contains product expression 

note ra expressed functor composition theta gamma list 
ra semi functor list 
merging recursion monads sections different trends program design 
data driven sense programs constructed structure values generate consume 
effects driven monads structuring device 
section show structuring mechanisms combined giving rise monadic extensions recursive operators sections 
research monadic recursive operators initiated fokkinga study monadic maps folds 
perspective meijer jeuring various examples operators showed concrete applications laws 
subsection shortly review monadic folds 
subsections contain main contributions subject question 
introduce new operators correspond monadic versions unfold hylomorphism respectively 
study relevant aspects calculational theory 
fusion laws operators turn fundamental importance enclose new practical cases deforestation 
various functions take part laws required possess structure captured new operators associated concepts 
section way monads encapsulate effects demonstrate extremely helpful analyzing recursive functions effects 
monads permit focus relevant structure functions disregarding details specific effect function produces 
section assume default category cpo 
monadic fold various concepts saw section lifted kleisli category 
concept algebra 
monadic algebra pair consisting object carrier arrow fa ma operation 
homomorphism monadic algebras fa ma fb mb arrow mb ffl ffl ff definition homomorphism ma lifting datatype constructors monadic algebra fa ma satisfies equation ffl ffl ff monadic fold operator defined homomorphism shall denote jhj ma 
existence homomorphism follows fact reduces equation homomorphism normal algebras 
ff ffi ffi ff ffl ffi equation rewrites ffi ffl ffi ffi ff homomorphism ma monadic algebras homomorphism normal algebras ffl ffi ma ma viceversa 
homomorphism algebra exists desired property follows 
words monadic fold special case fold 
jhj jh ffl ffi category set cpo initial algebra exists regular functor monadic fold defined unique homomorphism lifting initial algebra monadic algebra way monadic fold usually literature 
uniqueness homomorphism setting consequence fact just proved equation 
example consider datatype lists 
monadic algebra theta mb monadic fold function jhj la mb nil cons monadic fold jhj strict fa ma ffi strict functions functor monad strictness preserving 
proof property follows directly fact fold strict target algebra 
verification algebra ffl ffi strict straightforward 
similar property states monadic fold hj fa strict ffi strict functor monad strictness preserving 
observe property reduces previous unit monad strict 
identity law monadic fold hold general 
means true unit example equation satisfied ffi strict strictness preserving unit monad non strict strict previous property unit non strict hypothesis 
hand possible prove identity law holds regular functor strictness preserving unit monad strict 
need require ffi strict regular functor follows strictness unit see details 
laws monadic fold 
monadic unfold definition monadic unfold obtained dualizing recursion scheme characterizes monadic fold 
prefer proceed way introduce monadic unfold means intuitive explanation behaviour 
development follows conducted category final coalgebra exists regular functor 
arbitrary monad 
roughly speaking monadic unfold function behaves unfold additional feature producing effect 
approximation definition got lifting kleisli category cm recursion pattern characterizes unfold 
means consider diagram ga gf gd view diagram kleisli category 
proceeding way thinking arrow effect producing function getting somewhat imperative idea recursive process produces implicit side effect generates data structure 
universe discourse need describe components diagram cm elements order get real understanding scheme means 
step description computational effect explicit 
md ga gf gd rests determine plays role objects cm coincide data structure generated recursive definition necessarily corresponds datatype signature functor means monadic extension acts elements cm gf ff gx fx fx 
type considerations immediate see lifting final coalgebra natural candidate play role intuitively arrow permits perform single observations data structure generated recursive process just propagating computational effect 
summary monadic unfold correspond function satisfying diagram md fa ff fd see solution diagram may unique force introduce monadic unfold fixed point definition 
addressing point detail introduce notion monadic coalgebra 
monadic coalgebra pair formed object carrier arrow fa operation 
coalgebras arrow may thought structure returning computation simply value 
functor plays role signature 
view definition choosing monadic extension say monadic coalgebra fa coalgebra fa viewed arrow cm structure preserving mapping monadic coalgebras arrow carriers preserves structures compatible monadic effects 
monadic coalgebra map homomorphism monadic coalgebras fa fb arrow mb ffl ff ffl homomorphisms closed composition preserves kleisli composition 
hand unit identity homomorphism provided preserves identities 
preserves identities lifting homomorphism normal coalgebras homomorphism liftings coalgebras 
coalgebras unit unit ffi ff ffi ffl ffl bg conditions show solution diagram may unique may exist various homomorphisms monadic coalgebras counterexample gives evidences fact 
example recall diagram 
monad ma functor sa theta recall example sa captures signature streams elements datatype corresponds consider natural transformation fail inr mb denotes unique arrow final object 
natural transformation represents function fails input 
functionally expressed fail inr 
satisfies absorption property ffl fail fail fail ffl show sa fail fail 
proof general possible 
carried category distribution law theta theta theta inverse map id theta inl id theta inr exists 
category product coproduct exists said distributive set typical example 
particular case cpo separated sum coproduct distribution law defined strict function case inl inl inr inr observe id theta inl id theta inr ffi inr id theta inr holds ffi id theta inr inr 
setting strength monad id ffi theta theta 
ready assert desired equality sa fail ffi id theta fail id ffi ffi id theta inr ffi id theta 
id ffi inr ffi id theta 
inr ffi ffi id theta 
inr ffi ffi inr ffi thetab fail thetab thetac absorption property sa fail ffl fail thetaa sa ffl fail shows fail satisfies diagram consider particular case unit ffi hh ti theta sa final coalgebra unfold hh ti sa unique homomorphism hh ti sa addition proposition know sa lifting 
follows lifting unfold unit ffi hh ti sa homomorphism liftings hh ti sa satisfies diagram case different solutions exist 
existence multiple solutions diagram forces define monadic unfold domain theoretic setting 
adopt solution definition monadic unfold cpo 
words defined homomorphism monadic coalgebras fa shall denote mf easy verify homomorphism exists 
homomorphism obtained considering fixed point functional oe ffl ff ffl functional arises reversing diagram done isomorphism inverse kleisli composition 
result mapping isomorphism functor gamma functors preserve isomorphisms 
definition fa monadic unfold mf defined fix oe 
example datatype lists verified unit ffi nil cons ffl la nil cons ffl ffi unit theta theta monadic unfold function type ma la fix oe oe nil cons ffl ffi unit theta ffl functionally expressed follows case inl 
unit nil inr unit cons example case streams monadic unfold sa theta function sa fix oe oe scons ffl ffi id theta ffl 
unit scons example saw monad unit ffi hh ti functions fail unit ffi hh ti sa valid solutions 
correspond monadic unfold completely undefined function ma reason case monadic unfold yields response observed chain computations iterative unfolding generates 


delta delta delta computation unit succeeds iterative unfolding proceeds infinitely 
means wait infinite time able resolve expression extract stream results 
kind resolution infinite precisely function unit ffi hh ti sa models 
correspond expected computational behaviour 
example shows inconvenience monad combination generation infinite data structures 
example function zip theta 
theta known functional programming 
takes pair lists returns list pairs elements corresponding positions 
jeuring jansson give polytypic version zip call da theta db theta zips terms type da db respectively type functor induced regular bifunctor ma monad 
monad necessary control terms shape 
function represented monadic unfold fa thetab ffi fa theta fb 
function theta fa thetab theta natural transformation inspects outermost constructors terms proceeds accordingly 
definition induction structure see 
identity law monadic unfold holds provided strictness preserving unit monad strict 
strictness preserving unit strict unit law states exactly monadic fold 
observe monadic unfold monadic fold function 
recall homomorphisms monadic coalgebras closed composition preserves compositions 
case state fusion law strictness preserving ffl ff ffl ffl verified simple fixpoint induction 
homomorphisms monadic coalgebras arrows may produce monadic effects compatible monadic coalgebras 
possible define class structure preserving mappings pure functions carriers monadic coalgebras 
say arrow pure homomorphism fa fb ffi ff ffi note monadic coalgebras connected homomorphism kind monadic effects coincide related inputs 
monadic effects produced 
arrow ff simply maps value type fa value type fb propagating monadic effect 
associated pure homomorphisms state law call pure fusion 
ffi ff ffi ffi proved straightforwardly fixpoint induction 
law called map fusion relates monadic unfolds type functors 
strictness preserving df ffi fa id ffi fb law instance proposition subsection definition action arrows type functor fold see subsection 
example recall function da theta db theta example 
define polytypic function da theta db dz maps pair data structures function theta follows da theta db theta df dz monadic unfold obtain monadic unfold 
mf id ffi fz monadic hylomorphism general version monadic hylomorphism think consists kleisli composition monadic fold monadic unfold 
monadic algebra fa ma monadic coalgebra fb denote ma 
mf jhj ma operator represents functions produce effects phase construction phase consumption intermediate data structure 
example typical case may execution input output operations recursive processes 
drawback functions kind transformed single function avoids construction intermediate data structure type problem order apply transformation need preserve compositions satisfied monadic extension regular functor state monad example 
motivated fact consider restricted version monadic hylomorphism defined composition monadic unfold lifting fold 
definition algebra fa monadic coalgebra fb define monadic hylomorphism function ma mf jhj ma observe functions kind produce effect phase construction intermediate data structure 
monadic typical programming practice 
example shall see subsection correspond application semantic actions specified fold parse trees generated parser monadic unfold 
identity law fold follows monadic unfold instance operator factorization property similar 
states monadic hylo transformed monolithic function avoids generation intermediate data structure 
proposition strictness preserving functor fix ffl ff ffl proof 
proof fixpoint induction predicate mf ffi define ffl ff ffl ffi ff ffi oe ffl ff ffl base case prove ma mf 
ma function 
mf ma strict strictness preserving 
composition mf bottom ma 
inductive case assume mf ffi recall unit ffi mf ffi min ffi id possible variant monadic hylomorphism obtained composing unfold monadic fold 
reduces normal hylomorphism monadic fold fold 
variant considered 
ffi oe mh ffi ff ffi ffi observe ff ffi ff ffi equation ff ffi mf ffi induction hypothesis mf ffi ff summing ffi oe mh ffi ff ffi ffi mh ffi ffi fix fix ffi fix oe 
example datatype lists theta theta monadic hylo la mc la fix ffi ffi unit theta ffi functionally expressed follows case inl 
unit inr unit fusion laws established combination homomorphisms algebras monadic coalgebras 
strict ffi ffi ff mf ffi ffi ff ffi ffi ji needs strictness preserving 
laws follow directly definition fusion laws fold monadic unfold respectively 
conclude acid rain theorem monadic hylo 
need notion transformer coalgebras monadic coalgebras 
function fa 
mga said transformer coalgebras fa fb ffi ff ffi ffi ffi 
theorem acid rain fold fusion strictness preserving fa 
ga transformer 
strict jhj ffi hjt hjt unfold fusion fa 
mga transformer 
ji ffi ji proof 
proof fold fusion similar hylo fold fusion theorem relying application law 
proof unfold fusion follows 
definition transformer get pure homomorphism monadic coalgebras arrive desired result 
application fold fusion shown subsection 
monadic unfold special case monadic hylo write specialization unfold fusion terms monadic unfold 
ffi example recall function example 
suppose data structures generated resp unfolds fa da fb db 
situation theta fa theta fb da theta db theta construction data structures may avoided fuse parts 
try case fusion law unfold observe law section applies considering generalizations simultaneously generated data structures 
reason meet structure functions take part laws 
desired deforestation performed fact representable monadic unfold look laws operator 
need consider generalization law case simultaneously generated data structures ffi theta define ffi theta 
way fa fb 
law composition transformed monadic unfold generate data structures 
ffi theta ffi theta fa thetab examples aim section illustrate non trivial examples monadic unfolds uses calculational laws 
example show core graph traversal algorithm dfs bfs monadic unfold 
second shows recursive structure monadic parser form recursive descent parser characterized monadic hylo 
examples 
graph traversals graph traversal understand function takes list roots entry points graph returns list containing vertices met way 
consider graph adjacency list function returns adjacency list vertex 
representation graphs sufficiently time useful algorithmic purposes 
graph traversal vertices visited 
fact leads maintain set keep track vertices visited order avoid repeats 
suppose data type finite sets operations emptyset constant theta insertion element set delta theta bool membership predicate 
operations axiomatized delta false delta true delta show possible give formulation graph traversal terms monadic unfold handles set visited nodes state monad 
operationally speaking reason state monad want consider imperative representation sets 
example finite elements ordered total order represent set characteristic vector boolean values 
representation permits time insertions lookups implemented mutable array array destructive updates 
case operations sets correspond primitives mutable array directly 
able handle imperative operations functional setting established technique encapsulate data type state monad ma theta addition unit possesses operations ma delta bool delta delta monadic operations guarantee safe place update manipulate set single threaded manner duplicating see :10.1.1.100.9674
ensure necessary add strictness requirement delta need strict input vertex set values stored 
data type define graph traversal function vs vs mv monadic unfold theta operationally speaking initial list roots vs allocates empty set applies vs yielding list vertices final state set de allocates set returns list 
iteration action monadic coalgebra begins exploration current list roots vs order find element reached 
removes front vs vertices qualify visited delta true unvisited vertex met list reached 
task performed function mv defined nil unit nil cons vs delta vs unit cons vs applied proceed visit vertex head input list mark inserting set 
new state list roots computed 
function called policy theta encapsulates administration policy list roots 
way achieve formulation parameterized strategy followed traversal 
summary case nil unit inl cons vs unit inr policy vs note data type sense adopt purely functional representation sets 
imperative solution sake illustration 
case nil unit nil cons vs policy vs ys unit cons ys consider particular traversal strategies 
example efficient way implement depth traversal adopting lifo policy holding stack roots visit 
stage dropping front stack visited vertices top removed replaced adjacency list 
policy vs vs hand breadth traversal visits roots current depth left right moving depth 
achieved adopting fifo policy managing list pending roots queue 
stage dropping visited vertices front queue removed adjacency list concatenated queue 
policy vs vs call breadth instance obtained case 
representation change 
just seen breadth traversal handles list roots queue 
operationally speaking known list representation queues quite inefficient 
fact element enqueued appended list takes time proportional length list 
eliminate inefficiency help pure fusion law calculate new formulation breadth traversal supposed better representation queues see fast functional implementations queues 
suppose data type queues comes equipped operations empty empty queue enq theta inserts new element front returns front element bool tests queue empty deq removes front element 
adt organize list roots waiting attention pair theta adjacency list currently active inspected queue containing adjacency lists waiting activation 
list empties new list taken queue new representation construct new monadic coalgebra theta theta theta defined case nil unit inl front deq cons vs unit inr vs enq consider function change theta translates representation queues 
defined change list list maps queue list delta delta delta hard see change pure homomorphism monadic coalgebras 
applying pure fusion obtain new monadic unfold corresponds desired version breadthfirst traversal alternative representation queues 
breadth ffi change search procedures interested performing calculation list returned graph traversal 
example apply fold jhj 
jhj ffi naturality ffi ffi mf push catamorphism monad jhj ffi ffi jhj ffi monadic unfold jhj ffi ffi consider case fold function filter removes elements list satisfy predicate bool fil nil inl 
cons inr inr case composition filter ffi ffi represents search procedure explores graph determining order aim finding vertices fulfilling predicate 
specifying concrete traversal strategies typical search procedures depth search breadth search accomplished 
monadic parsing parsing technique called recursive descent popular functional programming 
means functional parser language constructed replacing grammar collection mutually recursive functions corresponding syntactic categories nonterminals grammar 
syntactic category goal corresponding function parser analyze sequence input symbols usually called tokens form string language return representation recognized string 
stand set tokens 
consider parsers functions type parser 
theta parser takes string tokens yields list alternative manners input string parsed 
parser may fail succeed recognize string 
failure represented empty list results meaning way parse input string 
hand parser succeeds alternative parsing composed value type representing parsed input remaining unparsed suffix input string 
parser literature type usually corresponds type parse trees describe structure recognized strings 
functional parsers typically functions return values arbitrary reason parsers return remaining unprocessed string may call parsers recursively order parse substructures 
body grammar production delta delta delta terminal syntactic category thought sequence goals fulfilled order deduce input string belongs syntactic category sequence goals resolved calling respective parser function order appear composing help combinator sequencing 
goal corresponding terminal satisfied terminal just symbol input string 
task performed elementary parser tok parser tok nil nil tok cons nil notation stands singleton list cons nil 
grammars usually various alternative productions syntactic category delta delta delta xm delta delta delta jy delta delta delta functional parser choice production apply represented combinator alternation 
amounts see logical structure functional parser context free grammar language 
fact just grammars bnf notation build parsers parsers combinators sequencing alternation 
observed wadler functional parsers structured called parser monad :10.1.1.33.5381
monadic approach combinators sequencing alternation primitive operations monad 
permits focus relevant structure parsers 
purpose example give formal characterization recursive structure recursive descent parsers help monadic unfolds hylomorphisms 
best knowledge constitutes attempt give characterization 
summarize main results achieve 
regard definition functional parser composition phases syntax analysis process string recognized parse tree generated ii semantic actions process values kind calculated parse trees result syntax analysis 
result recognize syntax analysis phase expressed monadic unfold datatype representing concrete syntax language datatype parse trees 
semantic actions usually defined induction structure parse trees fold 
application semantic actions syntax analysis phase expressed monadic hylomorphism 
words shape recursion followed functional parser dictated signature parse trees trees appear explicitly 
parser monad parser monad defined parser unit concat ffi list ffi denotes uncurry mb 
parser unit consume input succeeds returning bind operator corresponds combinator sequencing 
input string parser applies parser yielding list alternative parsings 
parsing mapped resulting new list elements lists parsings 
lists joined list delta delta delta concat 
parser monad particular case monad zero plus 
equipped zero ma phi ma theta ma ma type triple ma phi zero forms monoid structure zero phi phi zero phi phi phi phi parser monad zero nil phi parser zero fails input 
operator phi corresponds combinator alternation 
string parser phi applies appends parsings yielded 
parser zero zero zero zero zero zero 
addition distributes phi left phi phi 
terms kleisli star says ffi phi phi ffi theta 
parsers useful 
item nil nil cons unit zero parser item mt returns token input string fails input empty 
means operator ma theta bool ma filter results parser predicate 
running example simple language arithmetic expressions concrete syntax specification expressions exp term exp term terms term fact term fact factors fact exp num num stands set numerals 
assume numeral natural number represents 
set terminal symbols corresponding grammar defined grammar construct monadic parser recognizes expressions returns natural number arises evaluating 
parsers terminals terms elementary parser tok 
parser numerals combination item filter predicate written 
write add theta prod theta denote addition product 
parser mn parser parser tok parser unit add phi parser parser mn parser parser tok parser unit prod phi parser parser mn parser tok parser tok unit phi item syntax analysis technique described completely general sense context free language 
exposition essentially focus language arithmetic expressions 
syntax analysis understand process strings tokens recognized returned form parse trees 
build syntax analyzer language need give datatype representation concrete syntax specifies definition parse trees 
language arithmetic expressions datatype declarations exp sum term plus exp term term term mult factor mult term factor factor factor brackets left exp right num num plus mult left left right right num reason introducing datatype token parse trees structurally represent details recognized strings inclusive connectives operators parenthesis 
shall see presence datatypes tokens turns determinant achieving formulation syntax analyzer terms monadic unfold force invocations parsers tokens exactly places required 
syntax analyzer language composed function syntactic category terminal 
functions monadic parser syntax mdx yields parse trees corresponding type dx instance expressions syntax mexp 
achieve formulation syntax analyzer terms monadic unfold need trick consisting regarding functions functions unit type 
example syntax mexp 
usefulness considering unit type clear 
logical structure function syntax dictated recursive structure parse trees returns structure dx 
observation express monadic unfold 
interesting note functions turn mutually recursive parse tree types 
example mutually recursive monadic unfolds 
build monadic unfolds need identify functors capture signature parse tree types 
various datatypes defined simultaneous recursion functors reflect fact having variables involved datatypes see 
concretely example functors variables 
write am short 
theta theta theta am theta theta theta fm course datatypes tokens recursive depend 
consider part simultaneous recursion definition assign variable position functors 
presence variables constant types functors permits automatically force invocations corresponding parser functions 
parser functions corresponding non recursive types obviously non recursive seen monadic unfolds 
omitting unit type syntax tok unit syntax tok unit syntax tok unit left syntax tok unit right syntax item address definition parser functions syntactic categories 
mutually recursive 
analyzer expressions syntax expressed monadic unfold fe certain monadic coalgebra means function satisfying diagram syntax mexp syntax exp num sum term syntax stands tuple parser functions syntax syntax 
observe definition theta theta exp num term theta plus theta exp term inl ffl ffi theta theta inr ffl ma theta delta delta delta theta ma theta delta delta delta theta ary generalization product distribution monad 
sum term ffi sum ffl ffi theta theta term ffl monadic coalgebra phi ffi inl ffi delta delta hid id idi 

unit inl phi unit inr 
carrier monadic coalgebra represents notion control 
occurrences type theta theta indicate positions recursive computation proceed parsing goals productions 
sense monadic coalgebra behaves trigger 
product models fact parsing goals need sequenced 
note existence alternative productions exp concrete syntax definition modeled occurrence phi fact distributes phi left perform calculation arbitrary ffi phi ffi theta ffi inl ffi delta phi ffi hh ffi delta summing syntax phi ffi sum ffl ffi syntax syntax term ffl syntax omitting applications unit type syntax syntax syntax syntax unit sum phi syntax unit term coincides analyzer directly written hand 
likewise analyzers terms factors syntax syntax expressed monadic unfolds respectively formal manipulation deduce syntax phi ffi mult ffl ffi syntax syntax factor ffl syntax syntax phi ffi brackets ffl ffi syntax syntax num ffl syntax adding semantic actions want incorporate semantic actions parser sense computing values parse trees generated syntax analyzer 
parsing theory typically corresponds association attributes grammar symbol semantic rules production 
setting regarded definition fold 
application semantic actions syntax analyzer normally called monadic parser parser syntax semantics ma syntax analyzer monadic unfold semantic actions fold jhj composition monadic hylomorphism parser proposition function parser transformed function generate parse trees 
inlined simplified function coincides expression monadic parser written hand 
interpretation recursive structure interpreter compiler language characterized shape recursion comes monadic hylomorphism concrete syntax datatype 
gather benefits expressing syntax analyzer monadic unfold parser monadic hylomorphism 
says construct parser modular way 
develop separately phase parser join single function performs tasks avoids generation parse trees 
addition representation monadic parsers terms monadic hylomorphism permits perform formal reasoning 
example subject fusion transformations 
fusion transformations necessary semantics phase semantic actions usually represent complex operations interpreter compiler language 
shown meijer semantic actions interpreter compiler developed modular way calculational approach followed 
meijer starting point syntax language 
able couple meijer development result syntax analyzer need convert parse trees syntax trees 
roughly speaking consider signature syntax concrete syntax 
function maps concrete syntax syntax specified fold jt target algebra defined terms transformer fa 
ga 
semantic actions specified syntax sem jhj components build composite syntax mf sem ma observe ffi syntax hjt apply fold fusion law theorem ffi hjt hjt obtaining complete interpreter compiler monadic hylo turn transformed single function avoids construction parse trees syntax trees 
concluding remarks addressed definition recursive operators capable representing functions effects studied associated calculational theory 
examples aimed showing operators capture functions commonly practice 
possible direction research design implementation transformation system automatically performs deforestation programs effects essentially acid rain theorem corresponding monadic hylomorphism 
system constitute framework testing effectiveness fusion laws real programs 
experience line carried context transformation system called hylo performs deforestation purely functional recursive programs applying acid rain theorem corresponding hylomorphism 
proposal development system analogous hylo monadic hylomorphism 
system conservative extension hylo sense apply deforestation programs 
reason purely functional program viewed monadic program identity monad 

anonymous tcs referees helpful suggestions gustavo comments 
partially supported daad scholarship 
diagrams drawn paul taylor macros 
abramsky jung :10.1.1.50.8851
domain theory 
abramsky gabbay maibaum editors handbook logic computer science volume pages 
clarendon press 

sorting morphisms 
advanced functional programming lncs 
springer verlag 
backhouse jansson jeuring meertens 
generic programming 
advanced functional programming lncs 
springer verlag 
bird 
functional programming haskell nd edition 
prentice hall uk 
bird de moor 
algebra programming 
prentice hall uk 
peterson report programming language haskell version 
technical report yaleu dcs rr yale university 
fokkinga 
law order algorithmics 
phd thesis universiteit twente netherlands 
fokkinga 
monadic maps folds arbitrary datatypes 
memoranda informatica university twente june 
freyd 
recursive types reduced inductive types 
th ieee symposium logic computer science pages 
gibbons jones 
appreciated unfold 
proc 
rd 
acm sigplan international conference functional programming 
acm september 

theory semi functors 
mathematical structures computer science 
hu iwasaki 
promotional transformation monadic programs 
fuji international workshop functional logic programming pages 
world scientific july 
available www ipl tokyo ac jp hu 
hutton 
fold unfold program semantics 
proc 
rd 
acm sigplan international conference functional programming 
acm september 
iwasaki hu takeichi 
manipulation mutually recursive functions 
rd 
fuji international symposium functional logic programming flops 
world scientific april 
available www ipl tokyo ac jp hu 
jacobs rutten 
tutorial algebras induction 
bulletin eatcs 
jeuring 
theories algorithm calculation 
phd thesis utrecht university 
jeuring jansson 
polytypic programming 
advanced functional programming lncs 
springer verlag 
peyton jones launchbury 
lazy functional state threads 
sigplan symposium programming language design implementation pldi pages 
lehmann smith 
algebraic specification data types 
mathematical systems theory 
malcolm 
data structures program transformation 
science computer programming 
manes arbib 
algebraic approaches program semantics 
texts monographs computer science 
springer verlag 
meijer 
advice proving compiler correct improve correct compiler 
phoenix seminar workshop declarative programming volume workshops computer science 
springer verlag 
meijer fokkinga paterson 
functional programming bananas lenses envelopes barbed wire 
proceedings functional programming languages computer architecture lncs 
springer verlag august 
meijer hutton 
bananas space extending fold unfold exponential types 
proceedings functional programming languages computer architecture pages 
meijer hutton 
monadic parser combinators 
technical report tr department computer science university nottingham 
meijer jeuring 
merging monads folds functional programming 
advanced functional programming lncs pages 
springer verlag 
moggi 
notions computation monads 
information computation 
moggi bell jay 
monads shapely functors traversals 
technical report disi tr universit di genova 

lifting theorems kleisli categories 
th international conference mathematical foundations programming semantics lncs pages 
springerverlag 
okasaki 
simple efficient purely functional queues deques 
journal functional programming 
hu iwasaki takeichi 
calculational fusion system hylo 
ifip tc working conference algorithmic languages calculi le france pages 
chapman hall february 
pardo 
calculational approach recursive programs effects forthcoming phd thesis 
technische universitat darmstadt 
peyton jones wadler 
imperative functional programming 
proceedings th annual acm symposium principles programming languages charlotte north carolina 
schmidt 
denotational semantics 
methodology language development 
allyn bacon boston mass 
takano meijer 
shortcut deforestation calculational form 
proceedings functional programming languages computer architecture 

categorical approach functional programming 
phd thesis fakultat fur informatik universitat ulm germany january 
wadler 
deforestation transforming programs eliminate trees 
theoretical computer science 
wadler 
comprehending monads 
mathematical structures computer science 
wadler :10.1.1.100.9674
monads functional programming 
advanced functional programming lncs 
springer verlag 

