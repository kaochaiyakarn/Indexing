express appear phase commitment protocol extended calculus martin berger department computing imperial college london email berger doc ic ac uk kohei honda department computer science queen mary west eld college london email kohei dcs qmw ac uk examine extensions calculus representing basic elements distributed systems 
spite expressiveness encoding various programming constructs phenomena inherent distributed systems hard model calculus 
consider message loss sites timers site failure persistence extensions calculus examine descriptive power phase commit protocol pcp basic instance atomic commitment protocol testbed 
extensions enable represent pcp various failure assumptions reason essential properties protocol 
eld process calculi seen major advances decades ccs csp acp 
particular advent calculus name passing process calculi diverse computational structures sequential concurrent computing uniformly representable interacting processes :10.1.1.53.1757:10.1.1.36.865:10.1.1.53.4500
enables apply standard syntactic reasoning methods developed process calculi wide variety computational phenomena 
spite high expressive power interaction computing model calculus presently suce sound description basic elements distributed computing systems 
operations phenomena frequently arise distributed systems dicult preliminary version 
nal version accessed url www elsevier nl locate entcs volume html berger honda decompose name passing low level sense represent computational mechanisms left implicit treated calculus loss message transit timers manipulation process activities process failure recovery examples 
satisfactory say compositional fully encodings exist translation name passing possible description translations su ers basic problems lack compositionality lack extensibility excessive complexity making reasoning cumbersome impossible 
extensions cleanly representing phenomena needed convenience sense aid modelling distributed systems way faithful real computing phenomena ering useful reasoning frameworks 
context may observe far described phenomena representable known computing devices way encodable turing machines 
mean turing machines provide convenient framework modelling distributed computing systems 
kinds extensions calculus consider modelling distributed systems 
wish basic incremental sense combinations simple extensions represent wide range phenomena essential distributed systems constructs interact consistently incremental addition leads feasible increase complexity equational frameworks 
constructs equipped clean operational semantics terms pure dynamics reduction behavioural semantics labelled transitions 
important equational reasoning labelled transition ers convenient method exploring semantic properties having resort quanti cation possible contexts 
generally constructs able represent distributed systems clarity rigour descriptions amenable formal analysis intuitive understanding help putting study distributed systems uniform technical footing aid comparison integration development 
background studies extensions asynchronous version calculus representing distributed computation examines descriptive power description correctness proof important distributed algorithm phase commit protocol pcp 
extended constructs chosen cover simple possible way regard essential phenomena distributed systems message loss timers process failure 
omnipresent distributed computing phenomena way captured representing distributed systems 
far claiming extensions comprehensive er coherent framework describing reasoning extended processes labelled transitions 
description berger honda correctness proof pcp extended constructs demonstrate expressive power applicability 
pcp deals key elements distributed computing systems including message loss timers process failures recoveries ideal testbed purpose 
clean description pcp obtained various failure assumptions correctness proof central property obtained equations inherent added constructs 
uses pcp application motivating extended constructs general illustration protocol due 
pcp basic instance atomic commitment protocol achieves basic properties transactions notably atomicity presence partial failures distributed systems 
atomicity mean transaction committed transactions depends commit 
pcp achieves atomic commitment assumption occurring failures kinds 
messages get delivered accurately disappear trace forging 
processes correctly fail stopping completely 
long process stopped engage interaction state change fail 
stopped processes may may restart 
particular assumes absence byzantine behaviour 
assumptions pcp known achieve atomic commitment timers countermeasures failures noted 
pcp atomic commitment protocols developed ecient respect certain metrics number messages sent achieve commitment likelihood blocking 
basic atomic commitment protocols pcp fairly complex behaviour due possibilities failures incorporation mechanisms cope 
aware previous ering fully formal description algorithm 
extensions calculus introduce simple powerful concisely cleanly represent reason full pcp 
high level structure description protocol correctness proofs remain stable versions protocol di erent failure assumptions full version 
may seen evidence extensions coherently capture basic elements distributed computing 
comparison description pcp representative textbooks transaction processing approach di ers captures interactive behaviour protocol compositional way participants pcp described interacting processes composition formally de nes behaviour pcp mathematically unambiguous way 
enables behavioural semantics berger honda formulating reasoning atomicity fundamental property protocol 
payo formalisation identi ed subtle problems classic presentation pcp 
technical summary readers may refer full proofs details 
remainder section gives informal description pcp 
section presents base calculus shows representing core protocol assumption failures 
section studies extensions base calculus message loss timers process failure uses represent pcp 
section outlines description section enables establish central property pcp concentrating key technical ideas algebraic laws 
section devoted discussions including observations relative expressiveness added constructs respect original calculus 
behaviour pcp informal description pcp distributed protocol sense consists multiple possibly faulty processes interact possibly faulty channels 
transaction manager call coordinator participating sub transaction call participants 
principal objective protocol ensure far outside observers tell participating transactions commit usually writing datum persistent storage include actions abort 
atomicity property protocol 
outline basic behaviour pcp 
describe central part protocol call core protocol assuming absence failures 
participant sends coordinator message containing vote abort commit 
message abort participant abort immediately 
waits votes participants 
coordinator waits messages 
coordinator decide commit abort 
participants coordinator voted commit coordinator send participants message telling commit 
participant voted commit commit receives message 
abort vote including vote coordinator coordinator sends participating transactions message ordering abort 
participant voted commit abort receiving message 
protocol distributed environments messages lost transit 
cope pcp uses timer 
timers core protocol augmented follows 
berger honda coordinator sets timer starting wait votes timer expires decides abort 
similarly participant voted commit waits decision setting timer timer expires assumes decision message lost requests coordinator give decision setting timer request lost case participant timer expires procedure repeated type failure process failure possibility system crash 
assume crashed systems eventually restart cf 

crucial processes restart consistent manner process failure protocol augmented 
roughly process process persistent datum recovers crash augment protocol follows initial coordinator process restart order participants abort 
crashed coordinator regarded untrustworthy 
transaction manager received votes participants commit coordinator order commit participants 
persistent orders sent 
participants initial process aborts voted commit restarted vote commit wait decision 
persistent vote sent 
essence pcp distributed protocol lies core protocol capable harnessing additional mechanisms key properties atomicity maintained presence failures 
representing pcp calculus core protocol section presents base calculus study 
calculus represent core part pcp discusses basic semantic property protocol state description 
variation protocol obtain information participants coordinator 
called 
advantageous coordinator single point failure phase protocol 
keep proofs simple shall deal text adaptation simple 
berger honda basic calculus distributed protocols pcp asynchrony messages 
information ow respect binary decision abort commit plays central role description analysis 
describing features choose asynchronous version calculus augmented branching 
role branching semantic arguments clear 
range names 
syntax processes written grammar 
jj xh yi jj pjq jj jj jj jj xh yi jj jj yi jj yi constructs called branching input left right branching output perform branching time interaction 
construct easily encodable calculus constructs presence distributed failures known simple encoding see section 
play essential role equational reasoning 
notion free bound names written fn bn convertibility standard 
assume natural sorting discipline 
name passing write input output branching input branching outputs 
leaving standard de nition structural rules reduction record dynamics branching name passing corresponding labelled transitions easily obtained zi symmetrically right branch labels 
standard strong weak referred simply bisimilarity denoted 
notation internal sum stands jc fresh 
clearly step reduction owns 
please note expressive power calculus needed model pcp assuming failures 
description pcp core protocol assume absence failure deal core protocol sense section pcp described basic calculus just introduced 
representation simple serves basic point constructs built 
readability symbols vote channels describe meaning messages carry example vote channel vote th participant 
basic aspects representation gives behaviour protocol seen external observers 
representation berger honda denoted pcp con guration 
pcp vote self vote dec protocol composition coordinator participants 
channels communication coordinator participants hidden 
coordinator composition subprocesses self wait true false self process waits votes processes including 
true process votes commit send commit decision participants 
false hand send abort decision participants sends abort vote 
self process nondeterministically decides wants abort commit 
vote vote vote self self self vote self left vote self right true self dec left dec left false dec right dec right note true needs commit votes decide commit false needs abort vote decide abort 
give representation participant denotes th participant 
true false true vote left dec commit abort false vote right abort model possible outcomes voting participant participant consists branches internal sum voting commit wait decision coordinator voting abort 
actions committing aborting represented outputting special ports practice contain various behaviours including writing databases 
replication necessary simpli es reasoning 
bisimilarity state central property core protocol 
shows central property atomic commitment protocols cleanly translated statement behavioural equivalence processes 
prove result subsumed equivalent result full protocol discuss section 
proposition abort abort commit commit pcp abort commit 
representing pcp calculus berger honda extending calculus message loss distributed computing environments internet message lost transmission example due owing router bu ers 
incorporation message loss looks simple just add rule xh yi mutatis mutandis branching outputs 
alas rule capture reality message loss processes shared memory multiprocessor computer realistically modelled possibility message loss 
method kinds channels lossy non dependable ones dependable ones cf 

distributed systems channel reliable unreliable depending carrying local message remote message 
alternative way realistically model message loss distributed systems augment calculus sites separate internal message passing interaction site external message passing interaction sites 
idea interaction site su er message loss message travelling originating site remote site may disappear trace 
able determine message communication site site impose natural restriction syntax processes 
sites play essential role subsequent development message loss process failures persistence 
incorporation sites simple 
processes de ned 
networks ranged syntax nite set names 
jj jn jj jj denotes site ready receive messages names may consider lan connected internet case may set ip addresses hosts lan 
alternatively may consider host case understood containing addresses sockets serviced networking community terminology call set access points generally set access points ap ap ap jn ap ap ap ap fxg ap 
overloaded operators understood way corresponding operators processes obey structural rules 
idea input interface process similar setting appeared context join calculus 
formedness condition henceforth assume standard variable convention names 
say occurs input subject free occurrence input bound 
say local input subject input bound 
say formed written derivable rules derivable ii berger honda local free input subject iii jn ap ap iv free bound names processes networks entirely standard note fn fn assume networks wellformed 
structural congruence processes just basic calculus 
operators networks obey structural rules processes 
addition set fxg networks smallest congruence containing rules 
reduction processes unchanged networks rules 
intra com xh yg loss zi obvious rule branching corresponding com standard rules close assuming wellformedness 
example loss obtain reduction form xh zi corresponding labelled transitions concise 
rules processes identical basic calculus 
networks de ne transitions rules 
intra xh zi yg xh zi yg yg loss xh zi obvious branching versions rules corresponding rules basic calculus 
need version alpha networks 
seen access points play central role interaction networks 
detailed illustration transition rules relegated 
weak bisimilarity networks de ned standard add rule imply fn fn fn fxg fxg fn 
network acts domain perform computation prevents networks utilizing names berger honda way 
formed networks congruence respect operators 
extending calculus timers lose messages core protocol loses atomicity possible con guration deadlocks loss say vote 
pcp distributed algorithms addresses issue timers 
timers play fundamental role areas distributed software including example tcp core internet protocols 
timer choose re ects basic character timers distributed systems simple form 
various attempts incorporate notion real time behaviour process calculi cf 
addition timer calculus lacking far 
syntax processes extended follows 
jj timer input guarded pre xed standard branching input 
subject timer timer initial input subject ranges integers greater 
timer represents clock ticks left timeout timer 
timeout continuation timer 
times timer long timed interaction input guard possible having input timer residual technical development timers hinges time stepper function 
timer timer timer qjr ticks timer discrete degree thought passing say second global clock 
note function acts non guarded timers uence timers pre xes 
indicates timer starts guarding pre taken process launched environment 
timers guarded pre xes said inactive active 
free bound names timers obtained set union timer continuations 
extended set processes set networks de ned just section 
means timers distributed di erent sites 
assumptions timers relate global clock time local site 
lamport principle local clocks take second option 
synchronisation local clocks di erent sites easily berger honda incorporated concern 
mind dynamics timers follows 
timer xh yi pf vg par pjq idle communication rule timers branching input de ned accordingly 
rules idle naturally extended reduction networks par extended networks sense implies jn assume local clocks 
idea underlying reduction rules timer pre necessarily advances reduction site 
underlying intuition reduction computation takes time represent discrete unit 
time advance computation happening natural essential wish model timeouts process waits expected message may come due say message loss 
purpose idle rule 
corresponding additions transition relation follows 
timer pf vg par bn fn pjq idle extended set processes incorporate sites message loss just 
immediately obtain weak bisimilarity processes networks result 
proposition processes preserved pre restriction parallel composition 
ii congruences networks 
simple example failure congruence consider timer 
xjp bisimilar xjp input action inevitably retain 
see discussions 
berger honda extending calculus process failure persistence message loss problem distributed systems 
machines processes distributed systems fail crash 
speci distributed systems centralized system crashes computational process comes 
notion partial failure centralized systems 
hand key characteristics distributed systems natural notion partial failures supposed tolerate type failure 
section introduces partial failure level sites 
process fail crash henceforth shall terms interchangeably means participate interactions reduce restarts 
may conceive crashed restarted processes processes restarting act process 
allow processes fail restart point time 
precise assuming failure occur interaction assume action process receiving message atomic 
gives fairly accurate abstraction real distributed systems assumption byzantine failure possible 
failures restarts sites completely non deterministic events 
process uence failure restart 
order cope possibility site failures restarts distributed systems allow processes specify restart 
achieved ways boil existence persistent memory una ected failures mechanism allows restarting processes read data persistent store nd kind process 
diverse ways save state operating systems save entire processes scheduling purposes run time 
weaker mechanism allow passive data persistent example indications process passed certain program point 
data persistent aid restart called 
note persistence received attention distributed systems community best knowledge process theoretic accounts lacking 
mechanisms skim surface complex topic hope er valuable starting point study 
extensions failure restart mechanisms pcp straightforward built top basic calculus calculus extended message loss timers 
convenience opt 
level processes introduce new pre making 
calculus distinguish state data processes allow processes 
jj berger honda notion process crash incorporated level sites 
site records latest superscript new overwriting previous ones 
additionally need represent crashed process restarted 
denote process 
networks grammar 
jj jj 
process understood site containing process latest crash restart restart precise 
require resemblance formedness conditions extended follows 
local free input subjects local free input subjects local free input subjects union free input subjects site 
represents crashed process restart 
overload operators keep algebraic laws 
de nitions including free bound names standard 
set fn fn fn fn 
fn similarly bound names 
need additional axiom de ne structural congruence 
fxg fn reduction add save 
restart 
intra rule turns process crash state leaving persistent storage 
saved state restarting process restart rule 
restart rules allow network failure recovery happen asynchronously 
note dynamics assume crashed processes restart consider case standard treatment pcp idea 
possible variant crashed processes restart labelled semantics extended calculus add labels process core calculus 
free bound names action de ned free bound names berger honda transition system de ned inductively rules addition previous calculus 
restart 
save proc rule introduces form process passing 
weaker process passing higher order calculi process interact emission 
interaction emission exclusive persistence mechanism integrated sites 
de nition symmetric binary relation processes bisimulation prq implies bn fn nd transition rq bn fn nd transition rq bisimilarity processes denoted usual greatest bisimulation 
similarly de nes strong bisimilarity processes 
extensions notions bisimulation strong bisimulation networks straightforward saving induced process passing observable networks 
proposition bisimilarity strong bisimilarity congruences networks processes 
description pcp full protocol extended calculus rigorously describe behaviour pcp incorporating failure assumptions 
discussed stages messages lost protocol votes cast sending participants coordinator decision communicated coordinator participants 
timers need incorporated occasions deal message loss 
processes fail point computation 
possibility dealt adding state changing decisions externalized 
berger honda con guration follows 
coordinator participants located separate site 
pcp vote dec false false false 
variable denotes timeout periods timers respective processes 
suitable choice number exceeding choose number greater 
access points de ned previous section vote fdec coordinator 
henceforth recursive equations form pre assuming standard encoding replication 
consider coordinator 
self vote self wait jc true jc false jc self jc jc wait self timer vote self vote self left vote self right self vote self self vote true self true true false false true true js true false false js false true dec true false dec false focus sub behaviours true true false waits vote th participant timeout vote lost transmission 
crucial protocol deadlock 
true charge sending commit decision th participant 
decision message lost participant request decision timeout 
example true rst sends commit decision waits request arrive th participant 
request comes resends decision waits true checks cast votes committing 
command participants commit true result vote 
done message loss process failure prevent outcome protocol participants eventually commit 
coordinator crashes taken restart aborting coordinator 
behaviour achieved initial false participants berger honda true false true false vote abort vote timer dec commit commit abort abort jp participant starts non deterministically deciding vote 
initial aborting th participant decision commit decision needs persistent communicated coordinator waiting decision uses timeout cope message loss timeout takes place requests decision 
message loss request repeated vote take place behaviour recursively possibly asking decision unboundedly times 
message coordinator successfully communicated appropriate taken ensuring subsequent crashed lead additional interactions coordinator 
ensures atomicity face message loss process failure essentially speaking decision coordinator constant determined may expect decision eventually communicated participant 
framework reasoning resulting behaviour section show central property pcp atomicity cleanly formulated established con guration 
proving atomicity atomicity processes process representation protocols particular computational structures general purposes precisely describe operational behaviour analyse behavioural properties description 
section discusses process description pcp preceding section reasoning atomicity key property pcp 
noted section atomicity property cleanly represented bisimilarity formulation property full protocol needs care due existence sites possibility site failures 
proof done algebraic laws associated calculus extension 
equations capture signi cant interplay timers persistence message loss general forms 
theorem commit commit abort abort commit abort 
assume fp true false false pn self abort abort berger honda ii true true true true true self pc pa iii pcp pc pa theorem asserts full pcp behaves far external observers tell ways committing process aborting process 
furthermore participants coordinator decide abort participants abort 
correctness proof basic equations essential feature proof theorem equational succession smaller equations leads desired bisimilarity 
single addition basic proof capture fundamental relationship message loss timers persistence 
proofs appropriate closures 
message loss induces certain type non determinism message may arrive may lost transmission 
natural idea simplify equation removing lossy messages reduce non deterministic choice receiver side 
possible combined suitable form timers lemma demonstrates 
formulation needs care due interaction timers persistence 
process reduction context mean context hole pre contain networks 
process context timer free save free contain timers subexpressions form 
lemma reduction context timer free process reduction context set partitioned fn fy zg timer left left ir right right ir ir note branching works ectively 
lemmas equation reduce possible loss message votes nondeterminism part coordinator 
equation concerns recursive timers 
recursive timer form timers distributed algorithms 
objective cancel ect partial failures message loss site crash repeated actions timeouts 
general equation precisely captures ect 
lemma gives indicating ect message loss ignored certain forms recursive timers 
lemma assume reduction context 
assume timer js berger honda case 
assume fx fn ni 
fx jni jni symmetric version left right 
equation natural counterpart non branching pre xes eliminating recursive timers participant waiting coordinator decision 
correctness proof main part ready embark outline proof theorem 
proof split parts lemmas establish content theorem assuming decisions 
results combined lemma iv 
proofs lemmas proceed algebraic reasoning equations established lemmas 
aid legibility highlight parts network changed step 
er algebraic reasoning establish results detail 
equations lemma tailor meet needs proofs lemmas placed 
lemma assume ng case fp true false appropriate false self abort abort proof 
shall assume self vote self left 
case self vote self right dealt similarly 
self structurally equivalent ic vote left vote left ia vote right abort vote right abort vote self left vote self self self true false false timer vote 
applying lemma lemma viii gives ic ia abort abort ic self ia self true false false lemma vii 
ic ia abort abort ic self true false false berger honda nd fn fn false apply lemma viii obtain ic ia abort abort false false ic ia abort abort false false lemma proposition false ia false ic abort abort ia abort abort false false apply lemma iii ic abort abort ia abort abort abort abort lemma ii get abort abort abort abort lemma gives abort abort abort abort required 
lemma true true true self pa pc proof 
true self structurally equivalent vote left vote left vote self left vote self self self true false false timer vote 
apply lemma lemma obtain self self true false false apply lemma ix 
true true false false true true false false berger honda nish proof show true true false pc pa false false abort abort apply lemma 
establish equation proceed parts proof lemma 
observe lemma xi guarantees true true commit commit false false abort abort imply equation 
establish proceed follows 
consider true true network bisimilar lemma proposition 
commit commit true true apply lemma iii 
commit commit lemma ii obtain commit commit commit commit lemma allows conclude commit commit commit commit proof similar 
remaining algebraic laws 
lemma 

ii iii xg fn xg fn iv ary reduction context networks rightmost argument process 
processes 
berger honda 
vii timer free timer free process reduction context fn 
pjq viii timer free process reduction context fx yg fn 
furthermore assume ng 
ix assume yg fn timer free process reduction context assume reduction context xi assume reduction context discussion extensions calculus introduced message loss timers process failure recovery mechanisms enable concisely represent reason pcp realistic distributed algorithm 
simplicity description equational reasoning extensions suggest possible applicability distributed algorithms 
er remarks constructs rst regarding name passing secondly regarding related works issues 
translation calculus expressive power name passing interaction natural question added constructs represented original calculus 
essential points involved question 
representability certain construct mean representable combined added constructs interplay diverse syntactic constructs crucial 
simple example take known encoding cf 
branching berger honda calculus vi def vi symmetrically right selection dually branching input :10.1.1.36.865:10.1.1.53.4500
encoding sound compositional base calculus branching natural encoding full calculus calculus message loss timers involved need consider case message sent remotely want message lost completely sent safely works atomically 
purpose need recursive timers just phase commitment protocol 
possible encode branching construct full calculus representation quite complex 
example suggests individual representability extensions may lead representability combination study expressiveness constructs performed care 
mind currently studying relative expressiveness extended constructs 
message loss encoded translating site collection forwarders certain kind 
essentially site translated system takes care messaging site 
hand timers provably encodable fully abstractly compositionally 
doubt non trivial sound compositional encoding compelling evidence encoding hard obtain non compositional way represent global timing speci messages representing signals may able obtain equations timers section 
site failure crucial point processes site crash partially 
purpose implementation basic calculus elaborate operational structure polled processes state crash time takes action 
resulting construction quite complex remains seen structure combined timers constructs equational properties encoding owns 
far constructions studied go translations rst enjoy satisfactory equational properties compositionality fully abstractness second hardly assist reasoning constructs concerned phenomena especially timers involved 
believe study im possibility satisfactory encodings help understand status nature added constructs 
aspects topic discussed forthcoming 
related issues process algebras syntactic tools representing various computational phenomena involving concurrency communication berger honda studies incorporation non standard features process calculi 
example addition real time process algebra studied extensively see survey 
studies extensions calculus describe various aspects distributed systems cf 

comparison di ers demonstrates constructs coherently combined semantically er uni ed reasoning framework 
saw section clear articulation related phenomena combination form timers localisation sites process crash persistence crucial reasoning distributed algorithms knowledge rst demonstrated 
note calculus base calculus arbitrary distributed software consists protocols programming languages protocols implemented programming languages 
calculus base language resulting formalism able capture part protocols distributed systems uniform basis 
interesting topic deeper study semantic properties extended calculus 
particular timers drastically change semantic theory 
strong weak bisimilarity longer preserved parallel composition noted section strong weak congruence coincide 
consequence implicit synchronisation timing engenders see discussion di erent setting 
conjecture reasonable congruences calculus timers exhibit similar properties 
suggests conventional de nitions process equivalences inappropriate timed setting 
techniques nely control sensitivity equivalences timing 
area needs done especially regards combination timers message loss process failure 
important topic additional syntactic constructs introduced systematically explored developed syntactic semantic level 
general concepts underly various notions arise distributed systems defy straightforward representation bare calculus 
rami cation introduced primitives interesting subject study 
example proposed process failure recovery may general formulation 
constructs suciently powerful describe pcp simple modeling diverse realistic process recovery mechanisms cf 

wish address related problems studies 
important remaining take study representing distributed algorithms models 
particular currently working representation sophisticated atomic commitment protocols phase commitment protocols extended calculus 
study may contribute berger honda clari cation basic building blocks structures classes distributed algorithms 
chris hankin referees helpful comments 
aziz abdulla bengt jonsson 
verifying programs unreliable channels 
journal information computation 
roberto amadio 
asynchronous model locality failure process mobility 
proc 
coordination volume lncs 
springer verlag berlin 
rapport interne lim february inria research report 
martin berger 
abstractions distributed systems 
phd thesis imperial college department computing 
appear 
martin berger kohei honda 
atomic commitment protocols extended calculi 
available request authors may 
jan bergstra jan willem klop 
algebra communicating processes 
tcs 
philip bernstein hadzilacos nathan goodman 
concurrency control recovery database systems 
addison wesley 
elnozahy david johnson yi min wang 
survey rollback recovery protocols message passing systems 
technical report cmu cs school computer science carnegie mellon university 
fournet georges gonthier 
hierarchy equivalences asynchronous calculi 
proceedings icalp 
fournet georges gonthier jean evy luc didier emy 
calculus mobile agents 
montanari sassone editors principles programming languages volume lecture notes computer science pages pisa italy january 
springer verlag 
cedric fournet laneve 
bisimulations join calculus 
appear theoretical computer science 
jim gray 
notes data base operating systems 
jim gray andreas reuter 
transaction processing concepts techniques 
morgan kaufmann 
matthew hennessy 
timed process algebras tutorial 
berger honda charles anthony richard hoare 
communicating sequential processes 
prentice hall international 
kohei honda mario tokoro 
object calculus asynchronous communication 
proceedings ecoop volume lncs pages 
springer verlag 
kohei honda mario tokoro 
small calculus concurrent objects 
oops messenger 
kohei honda nobuko yoshida 
reduction process semantics 
theoretical computer science 
leslie lamport 
time clocks ordering events distributed system 
communications acm july 
leslie lamport shostak pease 
byzantine generals problem 
acm transactions programming languages systems july 
butler lampson howard sturgis 
re ections operating system design 
fifth acm symposium operating systems principles pages november 
robin milner 
communication concurrency 
prentice hall 
robin milner 
polyadic calculus tutorial 
technical report laboratory foundations computer science department computer science university edinburgh 
robin milner joachim parrow david walker :10.1.1.36.865
calculus mobile processes parts ii 
information computation 
joachim parrow bj orn victor 
fusion calculus expressiveness symmetry mobile processes 
proceedings lics 
james matthew hennessy 
distributed processes location failures 
degano robert gorrieri alberto marchetti spaccamela editors automata languages programming th international colloquium volume lncs pages 
springer verlag berlin 
davide sangiorgi 
expressing mobility process algebras order higher order paradigms 
phd thesis university edinburgh 
fred schneider 
fail processors approach designing faulttolerant computing systems 
acm transactions programming languages systems 
dale skeen 
non blocking commit protocols 
proceedings acm sigmod international conference management data pages 
berger honda joshi 
designing optimized transaction commit protocol 
digital technical journal 
vasco vasconcelos 
typed concurrent objects 
proceedings ecoop pages 
springer verlag 

