effective multi dimensional indexing strings jagadish university michigan jag eecs umich edu nick koudas labs research koudas research att com divesh srivastava labs research divesh research att com databases expanded scope storing purely business data include xml documents product catalogs mail messages directory data increasingly important search databases wild card string matching prefix matching example common useful exact matching data 
cases matches need multiple attributes dimensions correlations dimensions 
traditional multi dimensional index structures designed fixed length numeric data mind suitable matching unbounded length string data 
describe general technique adapting multi dimensional index structure wild card indexing unbounded length string data 
key ideas carefully developed mapping function strings rational numbers representing unbounded length string index leaf page fixed length offset external key storing multiple elided tries dimension index page prune search traversal index pages 
basic ideas affect index algorithms 
efficient algorithms different types string matching 
technique applicable wide range multidimensional index structures instantiate generic techniques adapting dimensional tree string data 
demonstrate space effectiveness time benefits string tree analytically experimentally 
conventional databases index structures defined databases designed business data 
years particularly account rapid growth internet xml growing need manage index string data 
index structures string data proposed classical 
knowledge dealt indexing single string attribute 
supported part nsf iis multi dimensional indexing string data important variety contexts 
conjunctive term queries document sets standard supported information retrieval system 
move build similar functionality database systems support string matching queries effectively 
contexts strings supporting partial match queries prefix substring matching common useful exact matching crucial 
xml databases attributes elements tend string valued 
complex xml query involves selections specified multiple string valued attributes elements 
relational databases may need multi dimensional string querying 
example data warehouse imagine queries select prefix match supplier name substring match product name 
motivated need indexing context ldap directories 
find queries find person name begins sri telephone number area code 
single index search name attribute corporate directory find matches entire population smaller population area code 
single index search telephone number find area code just ones matching name 
simultaneous index attributes greatly speed search 
need multi dimensional indexes recognized business scientific contexts time rich history research multi dimensional index structures 
research tended assume numeric data 
carry directly string data number reasons 
structures require partitioning attribute space spatial distance volume metrics meaning obvious context string data 
second traditional index structures store attribute values index pages comparison purposes abce abcd abcd applying tree concepts sample string data set search page boundary demarcation forth implicitly assuming stored attribute values small 
assumption valid numeric attributes values stored small amount space frequently bytes 
unfortunately attributes string values long instance byte address field unusual byte biography capsule 
storing attribute values index pages prohibitively expensive leading search special structures 
contributions generic technique adapting wide variety multi dimensional index structures wildcard indexing unbounded length string data 
choose generic fashion plethora structures devised little agreement best specified application context 
generic technique addresses issues raised foregoing 
specifically contributions ffl map strings linear space manner ensures strings extensions particular prefix clustered preserving lexicographic ordering section 
clustering particularly important multidimensional context multiple dimensions known trick keeping sideways pointers dimensional trees 
ffl avoid storing long strings index pages store small fixed length strings 
enable comparison search elided trie trie structures similar patricia trees organize index pages section 
tries space proportional number string stored index page independent lengths strings 
ffl carefully designed index manipulation algorithms exploit tries index page minimize necessity fetching full string index operation section 
ffl render entire discussion concrete instantiate generic techniques context known tree analytical experimental evaluation string tree section 
generic string multi dimensional tree wish create index structure database objects indexed string valued attributes support indexed retrieval objects exact match prefix match attributes 
standard multi dimensional index structures see purpose extent possible 
basic problems need address 
best map strings number line standard techniques 
second avoid storing possibly long strings index pages avoid performing possibly costly comparisons long strings 
tackle problem turn solutions problems suggest generic string multi dimensional index 
numeric mapping strings comprised symbols drawn alphabet size ff 
string considered fractional number written base ff 
words map symbol integer range ff 
string length symbol mapped integer string mapped ff ff ff easy show mapping possibly infinite strings rational numbers technique 
means may appear mapped strings rational numbers solved problem performing string matching standard numeric techniques 
challenges remain 
representation long string require large precision representation corresponding rational number certainly commonly byte representations 
dealing true numbers real rational usually willing sacrifice small amount precision significant digits return fast processing 
rational numbers resulting string mapping require substantially bits symbol ff larger 
furthermore able support partial matches approach need keep mapped numbers high precision 
second subtle problem notion distance 
numbers drawn metric space meaningful speak distance 
possible intuition estimate numbers entries numbers queries fall numeric range reasonable distributions expected 
intuitions fall apart dealing strings 
difference numeric mappings strings represents sort lexicographic difference useful concept terms similarity approximation 
particular string az closer example string domain roman letters symbol alphabet 
page partitioning keep az ab ac enable effective support prefix match queries bundling az solve problem 
distance metric strings size alphabet ff established lexicographic order symbols alphabet 
choose integer fi ff 
string length symbol mapped integer ff 
string mapped fi fi fi look going example choosing fi ff 
case interval strings equal length adjacent lexicographic ordering 
extensions string character equally placed open interval 
extensions string closer value 
role fi determine margin victory 
technically sufficient set fi marginally greater ff absolutely certain forcing page splits occur desired points choosing larger value fi 
belief value fi ff sufficient 
example consider alphabet characters fa cg 
ff choose fi 
mapping shown 
able preserve prefix clustering property strings share common prefix length occur numeric range smaller numeric distance string convenience exposition alphabet comprising just lower case roman letters examples 
course real system larger alphabet including upper case letters numerals punctuation symbols control characters 
ab ac aa mapping strings rational numbers preserve prefix properties prefix string prefix 
straightforward verify metric obeys triangle inequality 
categorical attributes far considered strings assumed clustering shared prefixes lexicographic ordering natural clustering queried 
assumptions reasonable string objects databases important context true category labels 
case typically construct observed queries hierarchy categories sub categories queries ask partial matches corresponding subtrees hierarchy regard prefix lexicographic ordering labels 
simple technique prefixing category label string full path root category tree solves problem 
categories subtree category tree share common prefix labels path root category tree root specified subtree 
subtree match converted prefix match 
course lengths strings involved considerably 
exactly problem address category label strings stored index tree 
external data storage help simple data structures obtain full effect longer label physically storing shorter category label see 
external keys strings need indexed long 
inefficient terms storage terms processing time long string comparisons store string values index pages 
index structures require sort typically drawn set values indexed 
instance page boundaries marked terms smallest largest dimension values occur page 
parent index pages store boundaries children index pages 
way avoid storing long strings just store 
storing strings store pointers actual strings abce abcd mbr mbr external keys stored disk 
idea virtue providing desired savings memory challenge respect search index operations 
example illustrate idea tree concepts 
original string data set laid disk 
representation enhanced characters denote boundaries elements dimensional string pair individual string pairs respectively 
choice characters arbitrary character long member alphabet strings derived 
index leaf pages contain individual string elements 
representation requires pointer fixed size usually bytes string 
index leaf page example store dimensional strings index leaf pages 
index non leaf page store mbrs data elements child index pages 
mbrs represented offsets actual strings take fixed amount space storing external offsets 
elided tries disk index structures attention paid computes information page 
typically just performs linear scan entries page find interest 
considered acceptable database applications bound time required scan disk page linearly memory small compared time required fetch page disk 
external keys problem 
scan means pointer external key dereferenced causing amount solution proposed problem dimensional case store small memory structure elided trie 
elided trie set strings obtained follows 
construct compacted trie strings question 
edges trie multiple symbols situations symbols determined path taken trie decision point associated rest 
obtain elided trie trie eliding recording trie symbol case just keeping count elided symbols 
concept similar patricia trees 
important string elided trie proper prefix string etrie 
ensured appending string character occur alphabet 
examples show appended character simplicity sure data sets satisfy property 
shown elided trie strings constructed require space irrespective lengths strings question 
example shows sample data set 
shows compacted trie constructed data set 
notice strings need unique data set 
duplication possible duplicate strings recorded string collection leaf nodes compacted trie 
presents elided trie character edge removed count number characters path root inserted vertex 
structure number interesting properties 
consider search string 
starting root match character 
length string till node visit node test third character 
branch reach abce abcd abce elided tries node branch 
node node elided trie maximal match occurs 
choose descending leaf node case node children 
leaf important property stores strings share longest common prefix 
retrieve string 
testing find position collection strings trie 
way perform test start root trie follow correct path values missing characters maximal match specific example string located left child node test membership collection strings trie similar way 
consider problem finding positions strings having query say ab prefix 
follow similar procedure problem 
maximal match trie matches character 
retrieving strings corresponding leaves determine example strings share prefix ab 
say string maximally matched trie character matched elided non elided characters path trie 
say string completely matched trie maximally matched elided characters 
say string partially matched trie maximally matched elided characters 
trie structures efficiently stored linearizing efficiently implemented require minimal storage independent string lengths 
notion trie compacted trie extended string tuples multi dimensional space 
multi dimensional tries elided manner similar regular dimensional tries thought data structure 
turned keeping multiple dimensional tries dimension 
reason specified search predicate evaluated tries sets candidate matches obtained disk accesses performed verify candidates intersection 
multi dimensional trie indexing possibly get 
focus multiple dimensional tries index page follows 
multi dimensional structure key value occur multiple string tuples conjunction different strings time 
tries constructed dimension time 
multiple string tuples match perfectly chosen dimension pointed trie leaf node 
property external common node objects retrieved exactly value string attribute focus externally stored string tuple 
example able demonstrate structure leaf index page index non leaf page dimensional string tree 
tries constructed dimension actual string representations 
tries leaf index non leaf pages point offsets index page point actual data disk 
associations strings corresponding different dimensions string tuple implicitly recorded shared index page offsets 
similarly associations minimum bounding rectangles kept implicitly trie nodes index non leaf pages 
enhancing existing multi dimensional index trees effectively deal strings essentially requires careful manipulation elided tries various index operations search insert split merge efficiently multiple dimensions subject rest 
distance computation elided tries mapping introduced section compute distance strings determine volume hyper rectangle 
mapping assumes exact string representation available 
tries common case characters elided 
mapping course computed accessing exact string representations disk distances volumes subsequently determined 
turns incur cost abce abcd string tree index leaf non leaf pages willing accept approximate distances volume measures illustrated 
example suppose want compute trie distance strings abcd offset offset 
elided representation string complete knowledge length string positions elided characters 
know second character strings trie affect distance strings guaranteed second character affects actual numeric values mapping strings 
missing fourth character string offset impact exact distance derive lower upper bounds distance 
lower bound obtained assuming missing fourth character string offset ends qa upper bound obtained assuming missing character string ends qz 
approximate distance strings estimated average lower upper bounds 
error introduced approximate distance computation small 
generic index structure ideas propose generic string multi dimensional index follows ffl build multi dimensional tree index choice partitioning attribute space data points manner selected 
ffl page index tree maintain tries describe children pages dimensionality index structure 
role tries establish partition boundaries partition possibly unbounded length string 
ffl follow standard algorithms search insert delete manage index tree appropriate modifications account changes discussed 
nature modifications subject section 
algorithms reasons space update algorithms 
algorithms insertion deletion including page split merge bulk load available full version 
indexed data access describe modifications standard algorithms multi dimensional index structures deal prefix match queries strings dimensions ease exposition 
extensions higher dimensions exact match range match queries derived analogously 
presentation parts 
describe search index non leaf pages 
elaborate search index leaf pages 
prefix search index non leaf pages common tree index structures search starts root index structure proceeds tree 
objective search multi dimensional index structures obtain list pointers lower level index pages proceed applying search procedure lower level index pages turn reach index leaf pages 
contrast search dimensional tree index structures typically follow single path index tree point range queries 
describe generic step terms modified index pages containing dimension 
dimensional prefix query 
answer set contain string pairs database match 
denote elided tries dimensions respectively 
consider index non leaf page searching algorithmically described full version 
intuitively interested identifying minimum bounding rectangles index page extent rectangles overlaps prefix match query 
clearly achieved doing multiple disk accesses retrieve strings corresponding boundaries minimum bounding rectangles stored page approach unnecessarily expensive 
algorithm shows set mbrs identified disk access dimension 
query strings obtain longest matches tries extreme cases may roots elided tries 
note longest matches required maximal matches 
see consider prefix match query abd index pages depicted 
maximal match query string trie dimension index non leaf page 
prefix match string index leaf page mbr range 
similarly query string dimension 
example node parent left leaf elided trie node parent left leaf elided trie elided characters longest matching paths determined described section 
example elided character third character longest matching path dimension results external disk access strings offsets may fetched 
elided third character parent disk access performed dimension query string abd dimension matched characters case relevant minimum bounding rectangles dimensions identified invoking algorithm 
algorithm identifies mbrs left endpoint left query string identifies mbrs right endpoint right query string intersection desired set 
example minimum bounding rectangles stored index non leaf page mbr mbr 
illustrate rationale dimension 
discovered elided characters determined range mbr abc range second mbr denotes elided character 
independent values elided characters prefix matches query string abd fall range 
consider dimension 
discovered elided characters determined range mbr mdb range second mbr 
independent value elided character prefix matches query string fall ranges 
rationale algorithmically captured algorithm 
intersections mbrs dimensions computed 
example result left index leaf page searched subsequently query matches 
theorem index non leaf page prefix query dimensions algorithm correctly identifies minimum set children index pages need searched find answers external disk accesses 
prefix search index leaf page index leaf page stores offsets actual strings disk tries string dimension 
string ranges search index leaf page follows different strategy 
algorithm presents approach 
algorithm sx sy 
retrieve tries ex ey 
match sx ex node ex corresponding longest match sx elided non elided characters 
define node analogously matching sy ey 
elided characters longest match path px root ex choose leaf subtree rooted 
external disk access retrieve corresponding string dimension determine elided characters path px 
known values elided characters px node path px longest match sx elided characters path px node define py analogously dimension 

determine relevant minimum bounding rectangles dimensions 
ex px sx 
ey py sy 

child index pages ic minimum bounding rectangle included ic ic ic non leaf index leaf page 
algorithm identifies string including elided non elided characters longest path matches 
insert string local copy 
ls denote mbrs pointed trie nodes precede pre order traversal modified elided trie 
rs denote mbrs pointed trie nodes succeed post order traversal modified elided trie 
return ls rs prefix searching index non leaf page algorithm sx sy 
retrieve tries ex ey 
maximally match sx ex nx node ex corresponding maximal match elided non elided characters 
define node ny analogously 

sx sy match maximally matches 
return 

cx cy denote sets string pair offsets subtrees rooted nx ny 
cx cy matches 
return 
sx sy matched completely elided characters additional disk accesses required 
return cx cy 
choose string pair cx cy perform disk access retrieve string pair 
determine elided characters paths nx ny determined elided characters match sx sy return 
return cx cy prefix searching index leaf page essentially just longest matches case algorithm need performed elided tries 
intersection string pairs subtrees candidate matches 
essentially key property holds matches matches depending elided characters maximal match paths agree query strings 
components string pair assumed stored contiguously components string pair obtained single disk access elided characters determined 
consider example prefix match query abd left index leaf page 
maximal match dimension maximal match dimension 
consequently determine additional disk access query answers 
prefix match query abc maximal match abc left index leaf page determined string pairs potential matches 
similarly maximal match determined potential matches 
computing intersection algorithm determined string pair potential match 
retrieving string pair determined query answer 
general disk accesses independently performed determine elided characters tries perform disk accesses index leaf page number dimensions 
result theorem index leaf page prefix query dimensions algorithm correctly identifies string tuples answers external disk access independent number dimensions exact match search exact match query wish retrieve string pairs database exactly match dimension 
search index non leaf page proceeds exactly way case prefix match index non leaf page 
search index leaf page similar case prefix match search exact matches tries searching prefix matches 
experimental evaluation implemented string trees string trees report preliminary experiments comparative performance 
evaluate performance prefix range queries real data sets range query selectivities 
description index structures implementation page size kb 
tries data structures short bytes represent node counts 
addition char byte representation non elided characters 
case string trees record associations leaf nodes tries short 
disk offsets pointers pages long bytes 
small fraction page size auxiliary information counts 
resulting fanout string tree string tree values 
disk page pre allocate size maximum size trie 
tries linearized traversal stored page reconstructed demand 
description data sets real data sets extracted data warehouse 
data sets contain dimensional strings 
access method skew underlying data space important parameter evaluation comparative performance 
total number multi dimensional strings 
divide string domain number lexicographically equidistant segments 
results lexicographic buckets dimensional space 
expected number strings bucket real count strings bucket perform goodness fit test gamma data set refer contains names column computer generated login id second small value correlation strings data set 
second data set refer contains names column names second 
large value implying high inter column correlation 
query description evaluate performance prefix range queries data sets low medium high selectivities 
generate prefix queries uniformly selecting tuples data sets uniformly described evaluation range match queries evaluation performed simple extensions evaluation strategy prefix match queries 
prefix queries small string rtree string btree prefix queries large string rtree string btree data set data set performance prefix queries string trees string trees length strings selecting query size 
range queries uniformly choose start ranges data sets 
ask queries kind report average number disk accesses including index non leaf leaf pages performed order retrieve query answer 
high selectivity queries medium selectivity queries low selectivity queries retrieve fractions approximately gamma gamma gamma database respectively 
experimental results presents performance prefix match queries string trees string trees bulk loaded low bulk loading method trees sorting indexed dimension trees various selectivities data sets 
report comparative performance metric average number disk accesses common metric choice evaluation index structures 
data set high selectivity performance string tree close string tree 
somewhat expected number strings retrieved small small inter column correlation exists 
evident selectivity increases string trees show large performance benefits compared string trees 
overhead retrieving strings common prefix dimension high string trees main reason poor performance 
presents results experiment data set 
gap performance string trees string trees increases due higher inter column correlation 
presents performance range queries data sets 
trends performance similar prefix queries 
space considerations issue overlooked performance multi dimensional versus dimensional index structures space 
example space required trees index dimensional space smaller required tree index space 
tree essentially trading space search time tree complete search common queries faster querying independent trees 
wish carry similar evaluation case string trees string trees 
case trees trees numerical domains bytes index entry bytes pointer expect fanout rtree tree respectively kb page 
kb page numbers tree tree 
case string trees string trees efficient implementation tries crucial stored index pages size limits fanout index page 
mentioned earlier implementation short char possible concise encoding tries 
compute space requirements various entities string tree page 
assuming minimum bounding rectangles require bytes storage offset bytes 
require bytes pointer index pages 
single trie encoding technique described require bytes storage characters bytes storage node counts 
ideally range queries small string rtree string btree range queries large string rtree string btree data set data set performance range queries string trees string trees tries need additional bytes storage trie associations 
complete storage requirements case dimensional string tree bytes 
string trees defined require index structure store start offset offset minimum maximum string page opposed traditional tree approach storing value child page 
carrying similar computation case string trees total space requirements bytes 
numbers obtain values fanout index pages various disk page sizes 
example page size kb expect fanout string tree string tree sub optimal implementation 
similarly page size kb expect fanout string tree string tree sub optimal implementation 
fanout ratio tree numeric domain tree numeric domain 
ratio string domain 
presents average ratio space required trees tree page sizes kb kb data sizes ranging elements 
categories ratio numeric domain ratio achieved implementation ideal ratio 
evident due design string tree space efficiency trees improves string domain 
related idea string tree proposed 
papers authors introduce notion index structure designed unbounded length strings elided tries leaf pages btree purpose 
described specific dimensional tree 
contribution extend scheme apply wide variety index structures multiple dimensions 
multidimensional indexing long history database research 
numerous proposals indexing techniques multiple dimensions 
survey 
exist structures indexing strings dimension 
prefix classic structure capable dynamically handling dimensional variable length strings 
string trees provide better performance guarantees variable length strings prefix trees 
suffix arrays pat arrays allow fast searches strings difficult update secondary storage 
suffix trees classical index strings unbalanced tree topology dynamic maintenance secondary storage difficult 
aware dynamic structures multi dimensional string indexing secondary storage 
frequently databases index strings numbers 
believed tacitly understood index structures numeric data adapted straightforward manner deal string data 
explored pitfalls process proposed generic techniques numeric trees string trees string trees ratio space trees trees average space ratios adapt multi dimensional index structures string indexing problem 
proposed techniques generic open various optimizations specific application contexts 
evaluated benefits experimentally implementing string tree 
open problems remain 
foremost effective support substring match just prefix match described 
course obvious technique indexing suffixes just original strings basis studied suffix tree 
believe greater efficiency possible multi dimensional context subject going research 
second open problem worth mentioning index structure choice 
generic techniques adapt index structures changes costs performance structure 
performance comparisons multidimensional indexes numeric domain may carry directly string domain 
index structure different algorithms may preferred various index maintenance operations 
furthermore possibility multi dimensional indexes dimensions numeric string 
careful engineering assessment options called 
arge ferragina grossi vitter 
sorting strings external memory 
proceedings stoc el paso texas pages june 
bayer 
prefix trees 
acm transactions database systems pages jan 
beckmann 
kriegel schneider seeger 
tree efficient robust access method points rectangles 
proceedings acm sigmod pages june 
ferragina grossi 
fully dynamic data structure external substring search 
proceedings th annual acm symposium theory computing pages may 
ferragina grossi 
fast string searching secondary storage theoretical developments experimental results 
proceedings acm siam symposium discrete algorithms pages jan 
ferragina grossi 
string tree new data structure string search external memory applications 
journal acm pages mar 
gaede gunther 
multidimensional access methods 
acm computing surveys 
gonnet baeza yates snider 
new indices text pat trees pat arrays 
information retrieval data structures algorithms prentice hall 
guttman 
trees dynamic index structure spatial searching 
proceedings acm sigmod pages june 
howes smith 
understanding deploying ldap directory services 
macmillan technical publishing indianapolis indiana 
jagadish ng srivastava 
multi dimensional substring selectivity estimation 
proceedings international conference large databases edinburgh scotland uk sept 
jagadish koudas srivastava 
effective multi dimensional indexing strings 
labs research technical report 
jagadish lakshmanan milo srivastava vista 
querying network directories 
proceedings acm sigmod conference management data philadelphia pa june 
knuth 
art computer programming volume sorting searching 
addison wesley aug 
mccreight 
space economical suffix tree construction algorithm 
journal acm vol pages dec 
morrison 
patricia practical algorithm retrieve information coded alphanumeric 
journal acm pages oct 
robinson 
tree search structure large indexes 
proceedings acm sigmod pages 
roussopoulos 
direct spatial search pictorial databases packed trees 
proceedings acm sigmod may 
samet 
design analysis spatial data structures 
addison wesley june 
sellis roussopoulos faloutsos 
tree dynamic index multi dimensional data 
proceedings vldb pages sept 
sevcik koudas 
filter trees managing spatial data range size granularities 
proceedings vldb pages sept 
myers 
suffix arrays new method online string searches 
siam journal computing pages jan 

