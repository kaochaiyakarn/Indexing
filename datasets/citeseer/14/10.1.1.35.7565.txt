expressing program requirements refinement lattices dave robertson jane jordi levy artificial intelligence university edinburgh 
centre de spain 

requirements capture term software engineering referring process obtaining problem description high level account problem user wants solve 
description control generation program appropriate solution problem 
reliable requirements capture seen key component automated program construction systems small amounts information type problem tackled vastly reduce space appropriate application programs 
special purpose requirements capture systems exist logic operate tightly constrained domains 
previous research combination order sorted logic problem description prolog generated program attempt provide general purpose requirements capture system 
earlier systems connection problem description resulting program obtained ad hoc methods requiring considerable amounts domain specific information limiting domain application system 
experimenting languages provide formal connection problem description application program eliminating need domain specific information translation process 
introduces formal language requirements capture bridges gap order sorted logic problem description prolog programming language 
meaning prolog predicate characterised set bindings obtained arguments 
possible develop hierarchical arrangement predicates comparing sets results obtained stipulated variables 
hierarchical structure provide proof rules may support part requirements capture process 
describe notation refinement lattice define relationship prolog demonstrate language support requirements capture 
interactive system extracting prolog programs refinement hierarchies algorithm similar described implemented 
previous requirements capture described attempted control generation prolog programs applying domain knowledge problem description supplied user 
point having problem description separate application program enable formal language users described domain fitted closely terminology familiar intended users little programming expertise 
diagram representing general architecture main system research shown 
key mechanisms program generator constructs prolog programs assembling components library program schemata front package assists user selecting restricting template sentences form problem description 
problem description connects front package program generator statements problem description oe oe program schemata user package front template sentences problem description program generator prolog program general architecture existing requirements capture system control selection application schemata construction program 
approach attractive buffers users part programming task 
tension demands users notation relate need computational sophistication application programs 
tends create conceptual gap languages problem description application 
trade offs attempting bridge gap discussed result normally language problem description different language describe application program 
serious problem means languages interact program generation understood 
way tackle problems devise language problem description straightforward translation application programming language 
language expressive easy 
addition capable describing programming problem general terms greater detail depending users preferences 
previous bundy uschold attempted provide sort uniform language typed lambda calculus implement ideas working system complexity mathematics involved difficult see users specialist training feel confident 
solution problem dress mathematics form easily understood 
unfortunately difficult inherently complex notation appear simple 
alternative adopt start comparatively simple underlying principles manipulate obtain complex programs 
source ideas approach logic programming form pure prolog programs embodies simple powerful programming paradigm 
second source inspiration set specification languages 
particular drawn ideas cor system refinements 
core requirements capture language depends representing lattice sets results predicates 
constitutes problem description language 
section introduces notion context prolog followed section description way expressions language may translated prolog 
intended high level language axioms translate directly prolog aid proof rules control problem description 
section describe proof rules section provide guidance defining set lattices 
section describe programs differing levels detail may extracted lattices 
denoting argument sets conventional define meaning logic program set ground unit goals deducible program 
program shown grandparent parent parent parent fred joe parent joe mary parent ann joe meaning predicate grandparent program described set unit goals fred mary grandparent ann mary gives form global meaning predicate terms arguments possible define local interpretations terms stipulated arguments 
shall notation denote set instances variable obtained goal program example operator denote sets instances obtained arguments grandparent giving sets grandparent grandparent grandparent fred mary ann mary simplify descriptions shall assume single variable appears left hand side operator 
possible extend definitions general case vector variables 
order sorted logics normal restrict range objects variables formulae permitted range 
achieve effect notation permitting variables inside goal expression restricted shall pure prolog complicating features cut side effecting predicates operator 
permits predicate applied sets objects individuals case standard order predicate calculus 
interpretation predicate argument applied way defined set results variables left operator application predicate combination elements sets denoted arguments 
example take parent definitions program define set parent parent obtain set denoted expression find interpretation sub expression parent joe obtain set solutions goals parent fred fg parent joe parent ann fg union sets gives interpretation original expression parent parent terms represent sets objects introduce standard set operators follows definition set expressions allow set operators ffl intersection ffl union ffl subset allows example say set parents larger set grandparents parent grandparent operator allows arrange set expressions lattice 
provide top bottom lattice shall symbol denote entire universe discourse denote empty set objects 
full syntax refinement expressions appears interpretation obtained earlier grandparent definition refinement formula form ffl head refinement primitive set expression 
ffl body refinement set expression 
ffl primitive set expression form variable appearing prolog goal 
term form delta delta delta predicate name variable constant set expression 
ffl set expression primitive set expression union set expressions intersection set expressions difference set expressions gamma said restricted expression variable restricted way said unrestricted 
section clear restrictions syntax supplied definition needed 
worth noting passing set expressions order predicate calculus introduced different form different purposes 
mapping prolog refinement language section introduced basic notation refinement language 
purpose section show language understood terms prolog 
simplify explanation shall demonstrate correspondence unary predicates principles apply predicates arity 
operator interpreted terms operator recognising formula true successful result imply result 
rewrite formula operator interpreted terms operator intersection results goals set results conjunction goals 
expression corresponds formula similarly operator interpreted terms operator rewriting expressions form produce new expression notice set results obtainable sets denoted set expressions respectively 
nested variable restrictions operator terms converted preconditions logical rules 
expression form rewrite expression important remember refinement formulae intended translate directly prolog 
general refinement relation permissive standard implication represent wide variety information part sufficiently precise constitute prolog program 
particular possible translate refinements restricted variables head variables appear body introduce existential variables head clause 
expression guaranteed translate prolog 
example define refinement predicate add adds natural numbers obtain natural add natural natural translated prolog clause particularly useful program true natural natural natural add write refinement add natural natural natural refinement sense refinement axiom naturals included addition naturals translated prolog add natural natural natural clearly rule hold 
reason refinement defining general set property add predicate potentially generate natural number refinement defines direct relationship naturals addition 
refinement language sense flexible careful axioms allowed translated prolog 
provided checks place benefit extra flexibility problem description 
need standard proof rules topic section 
refinement proof rules expressions language refer sets proof rules set theory perform operations necessary requirements capture 
section describes proof rules currently anticipate derived rules added collection system matures instance rules describing preservation unions intersections predicates full set rules set difference operator 
subsequent sections shall show rules operation 
proof rules follow symbols denote set expressions 
proof rule universal set 
includes set proof rule set includes empty set proof rule set includes proof rule refinement relation transitive proof rule set includes union sets includes separately proof rule union set set includes original set proof rule intersection set set included original set proof rule set included independently included intersection proof rule union intersections intersection unions proof rule set expression included set expression predicate name arity terms corresponding argument positions refinements 
ease explanation shown simpler case rule predicate single argument defining refinement lattice section describe program may extracted refinement lattice 
precursor explain lattices may constructed show refinement language may help control development 
possible define complete programs entirely refinement language 
example standard append program concatenates lists second arguments form list third argument defined append hjt append append list translations described section rewritten prolog definition append hjt append append list doesn advantageous language merely replicates standard logic program 
defining refinement lattices key idea people allowed rise level application program initial stages refinement 
language supports allowing ways adding lattice creating new refinements extending existing refinements 
shall consider turn 
creating new refinements creating new refinement possible assist user ways 
flagging gaps specification created addition refinement 
happens axiom introduced refers terms defined existing refinement lattice 
example introduce refinement denoting possible refinement diagnoses set confirmed diseases diagnosis confirmed disease introduced new set expressions confirmed disease may defined refinement lattice 
wish attach disease top lattice add refinement disease note attachment says meaning disease 
merely introduces predicate arity 
extending refinements addition adding new information common want combine existing refinements order specific way apply 
support process permit users restrict size refinement expression left right sides 
result overdefined expression example restricting left hand side refinement apply test resulting expression see section 
definition refinement form extension refinement lattice ffl ffl ffl example added information locations fish included aquatic habitats aquatic habitats include rivers carp fish aquatic habitat location fish aquatic habitat river fish carp add information locations carp included rivers river location carp show valid extension follows ffl definition axiom extension location fish location carp aquatic habitat river ffl proof rule establish location fish location carp fish carp 
ffl fish carp axiom 
ffl aquatic habitat river axiom 
preventing refinements far possible protect users including refinements overdefined existing lattice 
symbol empty set expression assume new sets added potentially larger 
definition refinement overdefined conjunction axioms existing refinement lattice main purposes definition limiting ways set expressions refined reducing range choices available users constructing lattice 
shall describe techniques providing type control mutual exclusion argument restriction 
mutually exclusive set expressions provide means trapping mutually exclusive sets adding axioms stating intersections sets permitted test lattice 
definition mutually exclusive 
example want sets corresponding odd numbers number number odd add information odd adding axiom odd attempt define set call bad refinement odd axioms bad odd bad prove overdefined need show bad rule axiom odd odd bad bad rule bad odd bad odd bad preconditions rule satisfied axioms 
proved hierarchy overdefined 
argument restriction useful able define predicate range particular sets arguments 
example want say spiders eat living things 
express axiom living eats spider add constraint living dead living dead protect generalisation eats predicate 
example try add axiom eats spider dead prove overdefined follows ffl proof rule dead living dead axiom living dead dead ffl proof rule living dead dead living dead dead dead ffl proof rule living dead living eats spider axiom eats spider dead axiom ffl proof rule dead dead simple example having defined mechanisms creating extending refinements introduce section short example demonstrate way language may develop incrementally requirements specification 
shall somewhat contrived biological example wish represent populations wolves deer different probabilities survival depending location 
introduce concept probabilities refinement probability go provide specific information pertaining probabilities 
particular say restricted type probability survival factor animals probability survival animal point introduced part expression requirement animal placed lattice 
flagged gaps requirement specification plug gap adding animal 
time convenient add wolf deer refinements animal red deer refinement deer animal animal wolf animal deer deer red deer decide introduce refinement survival dependent location animals survival animal location animal animal introduces gap specification location introduce define axioms location animal location animal hill location animal decide specific types results expect obtain 
example stipulate results third argument deer hills integers argument wolves hills integers 
hill deer hill wolf specific locations particular groups animals 
example give possible locations red deer hills 
location red deer hill extracting program section demonstrated lattice refinements constructed 
lattice capable describing large number different programs vary dimensions ffl level detail program lattice described vary depending depth descend chains refinement 
travel bottom lattice detailed programs 
ffl may possible refinement set expression point lattice 
produce choice points extraction program details 
bearing considerations mind method extract program refinement lattice simple principle 
recall mapping refinements implication shown formulae 
mapping take sequence refinements lattice top level set expression translating refinements sequence axioms prolog shall produced partial program results included top level set expression 
example sequence refinements translate prolog clauses definitions allow obtain results terms 
think extracting program refinement lattice traversing lattice top level set expression supplying upper bound generality program precise set expressions supply lower bound program 
interactive system technique implemented described save space basic algorithm described 
additional complexity introduced algorithm permit nesting set expressions 
means finding sequences refinements need simply match left right sides appropriate refinements need ensure set expressions contained matching expressions coerced non empty intersection 
example refinement lattice carnivore carnivore herbivore herbivore carnivore bear herbivore bear valid refinement sequence bear bear bear bear translate prolog clauses 
note translation involves refinement requiring bear set solutions argument appear set solutions argument 
bear bear traversal refinement lattice required order constrain carnivore herbivore bear may useful retain information completed program 
algorithm unifying set expressions described accumulate refinements uses added main sequence 
final component algorithm takes care cases intersection set expressions required union set expressions required order include sequence refinements program 
instance refinement lattice linear refinement sequence extract refinements translate prolog axioms full refinement algorithm 
note recursive algorithm unifying set expressions need propagate set intersections unification right hand side smaller refinement expressions 
algorithm write refinement denote valid refinement producing axiom set refinement lattice algorithm follows ffl refinement refinement fg ffl refinement ffl refinement unify propagate bindings refinement ffl refinement delta delta delta delta delta delta refinement ffl refinement refinement refinement algorithm write unify denote set expressions shared subset defined set expression yielding axiom set algorithm follows ffl unify unify fg ffl unify refinement refinement algorithm procedure propagate bindings takes term form contained replaces occurrence yielding new term simple example example section uses axioms section provide refinement lattice 
axioms demonstrate programs containing differing levels detail may extracted 
step specify set expression potentially contains results require 
suppose interested program determining survival red deer 
top level goal refinement algorithm refinement survival red deer algorithm descend levels refinement closest top level set 
axiom reach set location red deer red deer doing unify animal red deer axioms 
refinements extracted deer red deer animal deer survival red deer location red deer red deer applying translation algorithm refinements gives partial program deer red deer animal deer survival red deer location red deer may content level detail force algorithm search lattice 
axiom extend downwards uses axiom unify location hill axiom corresponding refinement step added giving refinements deer red deer animal deer location red deer hill hill red deer survival red deer location red deer red deer applying translation algorithm refinements gives partial program deer red deer animal deer location red deer hill hill red deer survival red deer location larger example section describes refinements necessary represent larger example shows translated working logic program 
problem chosen medical diagnosis 
assume think diagnosis procedure suggests diseases symptoms know ask 
top level definition disease diagnosis decide give options consider valid types diagnoses 
say set diagnoses include diseases confirmed diagnosis confirmed second option diagnosis involve asking questions disease candidates adding list symptoms know 
assume elements know recorded data structure form symptom known value 
question contained program capable generating questions value obtained program ask user appropriate values 
definition diagnosis diagnosis question candidates ask jk definitions sufficient allow diagnoses conditions wanted ask questions diseases confirmed 
want allow diagnoses fully confirmed possible having run questions 
allow possibility add diagnosis possible need define means confirmed disease 
shall predicate succeeds result generated program satisfies test member succeeds element list shall introduce predicate symptom succeeds disease symptom value definition confirmed diseases confirmed symptom member definition possible diseases obtained similar expression confirmed diseases satisfied single symptom confirmed 
need employ predicate succeeds result generated program satisfies test possible symptom member determine symptom candidates asking questions diagnosis need find set symptoms currently known 
shall standard prolog predicates setof gives set elements form goal succeeds closed world negation operator 
candidates setof symptom member set questions simply defined member list candidate questions question member set values successfully asked user defined user successfully prompted list symptoms 
ask prompt user refinements translated program extraction mechanism logic program diagnosis confirmed diagnosis candidates question ask diagnosis jk diagnosis possible confirmed symptom member possible symptom member candidates setof symptom member question member ask prompt user language introduced embodies claim novel approach requirements capture 
features ffl space requirements described lattice refinements sets potential results prolog programs 
ffl construction prolog program achieved searching requirement space having delimited upper lower bounds completed partial program lie 
ffl guidance construction refinement lattice obtained application logically consistent set theoretic proof rules 
algorithms comparatively simple test readily applied real users 
currently producing prototype implemented prolog test ideas 
major importance activity develop new proof rules help guide users supplying extending refinements 
bundy 
uschold 
typed lambda calculus requirements capture domain ecological modelling 
research dept artificial intelligence edinburgh 
levy garcia 
ideal model extended lambda calculus refinement 
ecs lfcs laboratory foundations computer science 
mcallester givan 
taxonomic syntax order inference 
proceedings kr 
robertson bundy uschold 
eco logic logic approaches ecological modelling 
mit press logic programming series 
isbn 
robertson uschold bundy 
eco program construction system ways increasing representational power effects user interface 
international journal man machine studies 

refinement logic requirements capture program generation 
technical report department artificial intelligence university edinburgh 
unpublished msc thesis 
