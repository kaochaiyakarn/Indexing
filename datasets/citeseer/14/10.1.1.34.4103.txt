testing heuristics wrong hooker graduate school industrial administration carnegie mellon university pittsburgh pa usa may competitive nature algorithmic experimentation source problems familiar research community 
hard fair comparisons algorithms assemble realistic test problems 
competitive testing tells algorithm faster 
requires polished code consumes time energy spent doing experiments 
argues scientific approach controlled experimentation similar empirical sciences avoids alleviates problems 
confused research development competitive testing suited 
experimental studies heuristic algorithms resemble track meets scientific endeavors 
typically investigator bright idea new algorithm wants show works better sense known algorithms 
requires computational tests standard set benchmark problems 
new algorithm wins submitted publication 
written failure 
short affair organized algorithmic race outcome determines fame fate 
modus spawns host familiar algorithmic research community 
pervasive brief summary requires entire section 
particularly insidious 
emphasis competition fundamentally anti intellectual build sort insight long run effective algorithms 
tells algorithms better 
understanding accrue generally derives initial takes place design stages algorithm 
results formal competition exposed light publication observations richest information conducted informal uncontrolled manner 
second competition time resources productive investigation 
countless hours spent crafting fastest possible code finding best possible parameter settings order obtain results suitable publication 
particularly unfortunate natural advantage empirical algorithmic 
empirical sciences tends slow expensive requiring appointed laboratories massive equipment carefully selected subjects 
contrast empirical algorithms carried station single investigator 
advantage exploited conducting experiments implementing fastest possible code 
alternative competitive testing practiced empirical sciences days francis bacon 
controlled experimentation 
insight algorithm instance expect performance depend certain problem characteristic 
find 
design controlled experiment checks presence absence characteristic affects performance 
better build explanatory mathematical model captures insight done routinely empirical sciences deduce precise consequences put test 
give sort experimentation deliberately name scientific testing distinguish competitive testing 
discuss empirical models constructed defend viable necessary alternative purely deductive science algorithms 
main object show scientific testing avoid substantially alleviate stem competitive testing 
written primarily heuristic algorithms mind empirical investigation generally urgent due frequent failure purely analytical methods predict performance 
points apply equally exact algorithms tested experimentally 
fact heuristic algorithm may broadly conceived sort search algorithm suggested historical sense word popular connotation algorithm proved find right answer 
fact search algorithms eventually explore entire solution space find right answer change fundamentally heuristic nature 
section description current state affairs computational testing 
description bit stark point hasten acknowledge algorithmic community move direction recommend sections follow 
old way hasten progress 
final section scientific approach experimentation avoids competitive testing 
competitive testing obvious difficulty competitive testing making competition fair 
differences machines come mind serious impediment 
largely overcome testing identical machines adjusting machine speed 
difficult defeat differences coding skill tuning effort invested 
respect coding skill argue competitive testing levels playing field competitiveness 
investigators highly motivated win competition go great lengths learn best available coding techniques roughly techniques 
unclear coding technique best algorithm 
event scarcely imagine expensive wasteful mechanism ensure controlled testing 
particularly delicate issue degree tunes implementation 
generally possible adjust parameters algorithm effective set problems 
adjustment legitimate adjust competing code 
tuning competing code regarded commensurate tuning applied new code 
fancy problems avoided algorithm developer provided vanilla version code general purpose parameter settings 
new code written decide vanilla 
developer see rationale deliberately picking parameter settings result poor performance currently accepted benchmark problems 
question tuning legitimate recurs answer sight 
related obstacle fair testing new implementation face established codes enormous labor invested simplex codes linear programming 
literally decades development may commercial code involving clever uses registers memory caches assembly language 
certain amount incumbent advantage probably acceptable desirable 
publication funding decisions sensitive initial computational results technology commercial codes discourage development new approaches 
lustig shanno suggest example interior point methods come couple years simplex technology embodied codes cplex judged unpromising pursue 
second cluster concern choice test problems generally obtained ways 
generate random sample problems 
need dwell known pitfalls approach obvious random problems generally resemble real problems 
dangers benchmark problems equally grave appreciated 
consider problems collected 
generally appear publications report performance new algorithm applied 
publications appeared algorithm performed problems introduced 
problems existing algorithms adept solving selective advantage 
similar process leads biased evolution algorithms problems 
set canonical problems accepted new methods strengths complementary old ones disadvantage accepted problem sets 
judged successful authors published 
algorithms excel canon selective advantage 
tail dog problems design algorithms 
slightest integrity collect benchmark problems 
victims double edged evolutionary process favors narrow selection problems algorithms 
tendency corrected difficulties remain 
nearly problem set inspires complaints bias limited scope 
problems certain applications favored neglected 
worse unclear able recognize representative problem set 
rare range access problems proprietary necessary judgment new problems constantly emerge 
damaging outcome competitive testing mentioned outset failure yield insight performance algorithms 
algorithms compete packed devices authors differ respects 
usually impossible discern devices responsible differences performance 
problem compounded compares performance commercial code necessary convince research community viability new method 
commercial package may contain number features improve performance typically kept secret vendor 
scientific value comparisons practically nil 
noted informative testing usually takes place algorithm initial design phase 
tend number implementation decisions determined analysis empirical basis 
trial runs decide issue 
trials conducted care competitive trials admittedly inadequate learned 
competitive testing time energy productive experimentation 
writing efficient code requires substantial time investment low level language time profiles repeatedly run identify inefficiencies code polished root 
investigator train art efficient coding spend research money assistants know art 
competitive testing sacrifice relative ease algorithmic experimentation potential independence 
experimental projects fields typically await funding approval funding agencies industry sources 
lone experimenter algorithms contrast try ideas night station value evident 
opens door greater variety creative investigation provided course nights spent shaving machine cycles 
scientific alternative foregoing meant suggest efficient code written 
contrary fast code goals computational testing 
goal better served tests designed develop kind knowledge permits effective code engineered 
absurd ground structural engineering instance solely series competitions say entire bridges built incorporating designer knows obtain strongest bridge cost 
allow experiments year hard extract useful knowledge experiments 
current situation algorithmic experimentation 
structural engineers rely partly knowledge obtained controlled laboratory experiments regarding properties materials different software engineers 
scientific testing algorithms illustrated satisfiability problem propositional logic 
satisfiability problem asks set logical formulas truth values assigned variables formulas true 
instance set formulas satisfiable false matter truth values assigned variables 
assume formulas form shown consist variables negations joined moment effective algorithms checking satisfiability simple branching scheme 
variable set true false create subproblems successor nodes root node search tree 
truth value fixed problem normally simplified 
instance set true formulas containing term deleted satisfied occurrences deleted remaining formulas 
may create formulas fix variables process repeated 
term removed formula formula falsified search backtrack 
formulas satisfied search stops solution 
search branches variable continues depth fashion 
key success algorithm appears branching rule uses rule selects variable branch node branch explore 
hypothesis tested empirically 
prevalent style experimentation satisfiability algorithms test hypothesis definitive manner 
style essentially competitive best exemplified outright competition held 
typical activities second dimacs challenge invited participants submit satisfiability codes tested suite problems 
dimacs challenges highly beneficial stimulated interest responsible computational testing helped bring improvements see area 
codes compared sort activity differ respects participant incorporates best ideas 
hard infer better doubts benchmark problems cloud results 
proper way test branching rule hypothesis test algorithms branching rule done limited extent 
raises question branching rules better 
study considered hypotheses better branching rules try maximize probability subproblems satisfiable better branching rules simplify subproblems possible deleting formulas terms 
models constructed estimate probability satisfiability hypothesis 
issued theorems predicted certain rules perform better 
predictions soundly refuted experiment hypothesis rejected 
markov chain model built hypothesis estimate degree branching variable simplify subproblem predictions consistent experiment 
exercise take step understanding branching rules 
conventional norms study contribution best computation times branching rules reported literature 
assessment misses point 
rules deliberately implemented plain satisfiability codes isolate effect 
codes reported literature contain number devices accelerate performance obscure impact branching rules 
study intended put forward state art branching rule demonstrate superiority literature intended deepen understanding branching rule behavior way ultimately lead better rules 
illustrate construction controlled experiment suppose wish investigate problem characteristics influence behavior branching rules issue addressed 
benchmark problems inadequate differ respects rarely evident harder may fail vary parameters key determinants performance 
better generate problems controlled fashion 
type experimental design factorial design begins list factors affect performance problem size density existence solution closeness renamable horn factor levels corresponding different problem sizes densities levels need correspond values scale instance factor problem structure levels denote various types structure 
sizable problem set generated cell dimensional array average performance measured set 
statistical analysis analysis variance nonparametric tests check factor instance significant effect performance remaining factors held constant set levels 
possible measure interactions factors 
see details 
scheme requires random generation problems bears scant resemblance traditional random generation 
goal generate realistic problems random generation generate problem sets homogeneous respect characteristics affect performance 
principle illustrated satisfiability problem 
investigators noted random problems tend hard ratio number formulas number variables close critical value 
observation scarcely implies predict difficulty problem computing ratio formulas variables 
random problems ratio may differ dimensions determine difficulty practice 
example additional subtlety teaches important lesson 
experiments nearly problems critical ratio hard 
may suggest factors unimportant need control 
problem structures occur practice substantially affect performance may occur low probability random problems 
fact case practical problems formula variable ratio vary wildly difficulty 
doubly important generate problem sets control characteristics high low formula variable ratio ensure effect noticed ensure occur problems generated 
tell factors important 
easy answer question 
creativity empirical scientists manifested intuition explains phenomenon 
insight may emerge theoretical analysis examination experimental data patterns 
mcgeoch discusses techniques doing algorithmic context 
measure computational experiments measure solution quality running time 
unproblematic 
better suited competitive scientific testing 
consider satisfiability algorithms discussed earlier 
theories proposed explain effect branching rules performance branching algorithms 
theories predictions search tree size 
interested confirming refuting theories scientific context sense count nodes tree measure physical running time 
true ultimate goal minimize running time 
connection branching rules tree size understood combine estimates amount processing node predict running time 
estimates empirical 
object tree size running time node may related 
possible instance time spent node tree size small things equal order carry greater degree problem simplification node necessary produce small tree 
suggest measure total running time capture combined effect 
goal explain combined effect tree size node computation formulate test models explain combined effect 
measure predicted models number terms formulas deleted computation time 
computation time predicted basis average time required delete term formula naturally depends data structure machine factors investigated independently branching rule 
principle simple measure predicted model 
mcgeoch proposes interesting framework thinking 
suggests algorithm viewed abstraction code viewing code implementation algorithm 
words code phenomenon algorithm simplified model happens code 
may omit mention data structures machine architecture instance 
mcgeoch goes suggest algorithm simulated explore behavior 
code simulates algorithm entirely distinct polished code developed algorithm models 
instance interested node count satisfiability algorithms need write code generate nodes search tree 
data structure machine irrelevant long affect node count 
particular may slow inefficient 
may elaborate somewhat mcgeoch idea reminiscent astronomer simulation say galactic evolution 
astronomer may believe initial conditions give rise spiral galaxies initial conditions give rise spherical galaxies 
way check empirically simulate motions stars result initial conditions gravitational attraction 
algorithm simulated abstraction simplified model phenomenon omits effect matter improves understanding 
astronomer hardly bothered fact running time different real phenomenon 
algorithmic context simulates detail algorithmic model specifies 
really model predicts physical running time needs measure simulate machine count machine cycles 
case sense measure actual running time simulation run number machines fast slow 
practice high level algorithm operation various subroutines left unspecified 
simulation measure number subroutine calls 
provide crude prediction finished code behave 
flesh subroutines 
possible subroutine modeled independently calling routine 
approaches level data structures models predict accurately performance finished code 
furthermore insight gained way permits write better algorithms subroutines eventually fast commercial code 
benefits scientific testing scientific testing solves alleviates problems associated competitive testing mentioned earlier 
consider issue fair comparison algorithms 
machine speeds completely irrelevant 
simulates measured recommended results machine independent 
likewise difference data structure course model tested specifies data structure operation explicitly simulated 
case simply implement data structure specified 
coding skill irrelevant provided skill simulate algorithm correctly 
issue tune algorithm moot parameter settings factors investigate experimentally 
best parameter settings runs controlled experiments different parameter settings precisely order understand effect performance 
established algorithms implemented highly developed codes advantage 
polished code 
simulates relevant aspects algorithm rough ready implementation high level language prolog mathematica maple simulation language 
short problem fair comparison 
discussed issue choose problem sets completely transformed 
try assemble problems representative reality problems control parameters may affect performance 
problems atypical deliberately order isolate effect various characteristics 
admittedly choice factors control far trivial may demand considerable insight trial error 
problem creative scientists deal successfully disciplines task choosing representative benchmark problems confound efforts 
furthermore problem ought struggle goes heart empirical science 
necessity relying benchmark problems accompanying evaporate including unhealthy symbiosis problems algorithms described earlier 
benchmarks continue play role temptation match finished algorithm benchmarks 
play precisely benchmarking role finished products experimental role scientific study algorithms 
matter distinguishing research development benchmarks appropriate development controlled experimentation needed research 
emphasis scientific testing requires new set norms research 
asks experimental results evaluated basis contribute understanding show author algorithm win race state art 
asks scholarly journals publish studies algorithms failures failure 
inappropriate fact confused research development 
algorithmic researchers burden exhibiting faster better algorithms charge suited software houses expecting advance knowledge algorithms time 
believe researchers relieved dual responsibility freed conduct experiments sake science research development alike benefit 
recognizing disguised nr instances satisfiability problem journal algorithms 
bohm report sat competition technical report universitat paderborn germany 
hammer sun renamable horn generalized horn functions 
annals mathematics artificial intelligence 
baltzer ag basel 
hooker detecting extended horn structure propositional logic information processing letters 
cheeseman kanefsky taylor really hard problems 
proceedings international joint conference artificial intelligence 
crawford auton experimental results crossover point satisfiability problems 
proceedings eleventh national conference artificial intelligence aaai 
gent walsh sat phase transition 
cohn ed proceedings eleventh european conference artificial intelligence ecai wiley 
hooker thompson computational study satisfiability algorithms propositional logic appear orsa journal computing 
hooker needed empirical science algorithms operations research 
hooker branch cut solution inference problems propositional logic annals mathematics artificial intelligence 
hooker vinay branching rules satisfiability appear journal automated reasoning 
tsujii evidence satisfiability threshold random cnf formulas 
hirsh eds proceedings spring symposium artificial intelligence np hard problems stanford ca 
lustig shanno interior point methods linear programming computational state art orsa journal computing 
mcgeoch experimental method algorithm simulation appear orsa journal computing 
mitchell selman levesque hard easy distributions sat problems 
proceedings tenth national conference artificial intelligence aaai mit press 
trick johnson eds second dimacs challenge cliques coloring satisfiability series discrete mathematics theoretical computer science american mathematical society 

