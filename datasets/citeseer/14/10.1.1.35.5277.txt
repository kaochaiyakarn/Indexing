mark shields university glasgow mbs dcs glasgow ac uk dynamic typing staged type inference tim sheard oregon graduate institute sheard cse ogi edu dynamic typing extends statically typed languages universal datatype simplifying programs manipulate programs data distributed persistent interpretive generic programs 
current approaches limit polymorphism dynamic values syntactically awkward 
introduce new approach dynamic typing staged computation allows single algorithm execute partly compile time partly run time 
approach seamlessly extends single type system accommodate types known run time supporting type inference polymorphism 
system signi cantly expressive approaches 
furthermore implemented ciently type inference done compile time leaving residual uni cation run time 
demonstrate approach examples small polymorphic functional language type system type reconstruction algorithm operational semantics 
proposal readily adapted programming languages 
static typing static 
type information may di cult express unknown run time 
consider replicating sprintf function functional language 
write sprintf true placeholders elements argument tuple 
unfortunately giving sprintf type sprintf string 
string problematic type depends value sprintf rst argument 
examples common research supported ors award conducted visiting oregon graduate institute 
research supported usaf air material command contract nsf iri 
research conducted visiting oregon graduate institute 
appear th annual acm sigplan sigact symposium principles programming languages san diego california january 
copyright association computing machinery permission digital hard copies part personal classroom granted fee provided copies distributed profit direct commercial advantage copies bear notice full citation page 
copyrights components owned acm honored 
abstracting credit permitted 
copy republish post servers redistribute lists requires prior specific permission fee 
request permissions publications dept acm fax permissions acm org 
simon peyton jones university glasgow simonpj dcs glasgow ac uk persistent programming values type may stored retrieved stable storage 
distributed programming data code exchanged remote programs 
interpretive programming object language terms arbitrary type represented meta language constructs known type 
generic programs sprintf values arbitrary type 
approach abandon static type checking altogether tag run time value type information gracefully detect ill typed code 
expressive static type system 
example ad hoc polymorphism existential types subtyping polymorphism set types help writing programs feasible :10.1.1.35.8290:10.1.1.27.5598
third approach set types nite known compile time embed values user de ned datatype ectively tagging type 
call tagged values dynamic values 
simple verbose 
responsibility showing dynamic value appropriate type moved type checker programmer explicitly perform case analysis dynamic value 
type checking dynamic values deferred compile time run time type checking algorithm di erent stages 
set types known advance nite universal datatype required 
typically impossible user implement universal type embeds functions especially presence polymorphism 
existing proposals dynamic typing solve problem introducing universal datatype type dyn language primitive operations dynamic constructs dynamic value containing term representation type typecase :10.1.1.39.8459:10.1.1.12.5664
xn 
tng attempts match type stored dynamic value binding term appropriate xi failing gracefully match 
approach sprintf written sprintf string 
dyn string sprintf sprintf cs ds typecase nat sprintf cs dsg sprintf cs ds typecase bool sprintf cs dsg sprintf cs ds sprintf cs ds pattern matching haskell cs matches string binding remainder cs 
sprintf dynamic dynamic true typecase solution su ers drawbacks types live quite di erent worlds 
static types generally inferred may implicitly polymorphic little added complexity programmer 
dynamic types mentioned explicitly branches typecase dynamic polymorphism forbidden restricted requires complex machinery functors higher order uni cation :10.1.1.39.8459:10.1.1.12.5664
combining dynamic values construct new dynamic value tedious verbose write constituent value requires separate typecase result wrapped dynamic demonstrate instances required 
main contribution regard dynamic typing staged type inference program expressions type inference deferred su cient context known run time 
approach builds directly general notion staged computation free problems introduce operators manipulating values dynamic type creating combining dynamic values easy concise :10.1.1.28.4059
operators correspond dynamic typecase third allows new style programming possible typecase approach 
type system compile time run time decide typing dynamic values 
particular user written programs free explicit type information enjoy bene ts type inference expressions including involving dynamic values appendix 
dynamically typed polymorphism implicit convenient statically typed polymorphism 
type checking dynamic values performed compile time leaving residual type uni cation problem performed runtime 
presence evaluation remains sound 
overview staged computation called run time code generation generates code run time take advantage runtime invariants 
staged computation produces executes implementation optimised invariants 
contribution show done safe manner 
section review operators staged computation extend stage type inference operational semantics 
staged computation staged computation introduces operators construct eliminate combine pieces programs 
explicitly distribute evaluation program run time stages defer operator hti defers evaluation expression stage 
writing 
evaluation relation 
evaluated stage deferred till stage call body code run operator run evaluates deferred evaluates continuing example deferred till stage run 

evaluation brought forward stage splice operator evaluates deferred splices body surrounding deferred expression 
legal lexically brackets 
example code code code replaced stage splice expression may appear deep body deferred expression lambda abstraction code code yi yi splice possible construct deferred expressions contain free variables 
convenient constructing deferred function code code codei inh xi free bound nal expression informal operational semantics operators rewrite rules 
subterm stage nested brackets stage ht ui stage ht ui stage term free splice expressions context stage 
splice expression rewritten ht closed term free splice expressions 
run expression rewritten run ht 
operators studied davies pfenning taha sheard seen generalising nielson nielson level functional languages :10.1.1.28.4059
may improve ciency allowing programs partially evaluated line 
staged type inference proposal extends operators stage type inference dynamic expressions evaluation 
hti defers type inference evaluation stage nat inferred time 
evaluated stage hi inference deferred evaluation deferred deferred expressions allowing uniform treatment programs similar dynamic similar dyn 
run operator run takes arguments evaluate deferred expression exception expression 
run evaluates deferred infers type type compatible statically inferred type run evaluates example hi inference deferred run nat inference brought forward stage nat nat types compatible 

evaluation brought forward stage things go wrong type may incompatible ill typed 
occur run discards evaluates place 
example run true nat inference brought forward stage nat bool types compatible 
true evaluated run isvery similar branch typecase typecase 
wg return section 
evaluates splices body surrounding deferred expression 
novelty type resulting body depends type known run time 
example code yields deferred function type nat 
deferred expression code body type expression code inh code nd resulting body type nat nat 
code truei inh code true wenow nd resulting body type bool 
quite possible expression incompatible context spliced yielding ill typed deferred expression 
example code code truei truei type errors general detected statically static type code 
type inference deferred 
ill typed dynamic expressions detected run run truei false true type inference brought forward ill typed 
false exception evaluated defer run splice correspond construct previous proposals dynamic typing typecase 
particular splice ability manipulate dynamically typed code free variables dramatically improves power expression typecase approach shown inx 
readily mimic branch splices nested run 
example expressed typecase 

ug run hc run hc contexts possibly hole 
notice explicit mention types necessary 
emphasised run uses exception expression determine required type deferred expression 
practice programmer may type mind type checker con rm 
reason practical implementation allow exception expressions annotated atype type inference ensure inferred type subsumes annotated type 
semantics easily re ne rewrite rules ofx give informally semantics staged type inference 
rst rule remains unchanged ht rule run enhanced check typed matches type run ht 
done inferring type compile time run time comparing results 
denotes empty type context implying closed 
relation dynamic rewrite rule relation static typing rules 
ne speci cation practice expensive perform type inference expression run time 
inx develop cient implementation speci cation 
examples section illustrate dynamic operators 
sprintf revisited straightforward directly translate sprintf example ofx constructs sprintf string 
hi hi sprintf sprintf cs ds sprintf cs ds sprintf cs ds sprintf cs ds sprintf cs ds hc sprintf cs ds sprintf string 
hi string sprintf cs ds run sprintf cs ds error args mismatch format string sprintf traverses format string splicing code construct result string 
generated sprintf attempts run code yielding error string actual argument types agree format string 
example sprintf 
run true 
true 
true course format string constant literal string traversal occur compile time code statically type checked general case type checking deferred run time 
take advantage ability manipulate code containing free variables implement convenient pretty printer require arguments explicitly wrapped brackets sprintf string hi hi sprintf sprintf cs sprintf csh ni sprintf cs sprintf csh bi sprintf cs sprintf csh sprintf traverses format string constructing function required arguments converting required string 
argument sprintf accumulates code print arguments seen far 
notice free deferred expression passed recursive call sprintf similarly ability impossible construct function run time 
sprintf attempts run code created sprintf sprintf string 
sprintf cs run sprintf csh error function strange type looks magically return type value 
function error type places constraint result type 
reality context surrounding sprintf forces specialised particular type type dynamically tested value returned sprintf test fail error function called 
sprintf straightforward sprintf true 
run bi error true 
true 
true context forces sprintf called instantiated nat bool string occurrence sprintf convenient curried type string 
nat 
bool string 
compare type sprintf string 
hi string forces arguments wrapped brackets packed list 
precisely kind expressive power splice operator adds system 
example explicitly divides evaluation stages rst constructing print function second applying 
strategy print function may generated re applied times need re traverse format string re type check resulting code 
distributed computing distributed programming model java microsoft component object model allows library code residing potentially remote machines linked run time running program 
challenge ensure distributed programs remain typed 
show approach supports type safe distributed programming little impact underlying language 
add primitive string 
string hi library name function name returns code representing function 
resulting function may implemented locally reside remote machine 
suppose library vector supplies usual vector functions including map fft supplies fast fourier transform function window supplies high level graphics routines map 
vector 
vector nat vector complex vector complex string 
io window nat vector real window io monadic io haskell example 
side ecting computations yield value type type io constructed primitive operations construct 
furthermore ll local functions converting scalar complex numbers real real complex magnitude complex real libraries implement function displays frequency spectrum sampled waveform fresh window follows tcode hi vector map tcode fft window window nat vector real io size sample freq tcode size sample mag magnitude freq size mag wi build failed run notice rstly convenient dynamically bound function tcode ordinary statically bound function magnitude 
required single call splice call site 
particular single call return polymorphic function 
example di erent call sites di erent vector type 
secondly notice type checking localised run performed 
particular body evaluated call resulting function performs dynamic type checks 
implemented 
asked function local returned code need redirect call fft ti calls local functions performance penalty 
requested function resides remote machine possibilities 
rst return code function may run locally fft size vector body ti second new primitive rpc generate code perform remote call rpc string 
string string 
hi hi machine name library name function name list arguments rpc returns code required call function care establish network connection marshal arguments nally result fft size vector rpc fft smarter semantics incremental staged type inference na semantics ofx defers type inference run 
simple speci cation basis cient implementation run hti decide run time represented run time form amenable type inference compiled form amenable cient execution 
type checked afresh time re run 
subterm spliced type checked afresh occurrence 
subterm type checked atype assigned compile time 
cient semantics motivated analogy standard way bound polymorphism 
possible speci cation type checking polymorphic expressions rst unfold bound term body type check resulting body 
hard see resulting type derivation contain duplicated sub derivations occurrence bound term 
implementation type check bound term generalise type give atype scheme specialise type scheme body 
imagine type scheme suspended type derivation restarted 
technique moves type checking bound expression call sites unique binding site leaving small residual problem call site 
similar implementation technique appropriate deferred expressions 
na semantics type checks deferred expression splice unfolded 
deferred expression spliced times type derivation contain duplicated sub derivations 
avoid introduce dynamic type schemes represent run time suspended type derivation deferred expression 
derivation terminate splice expression pending type information 
type schemes dynamic type schemes visible type deferred expression remains 
type information stored inside runtime value representing deferred expression form type annotations 
example 
annotated deferred expression explained 
notation annotated deferred expressions intended strengthen intuition dynamic type scheme suspended type derivation 
operational semantics exploits type annotations keep track type inside deferred expression splice expression executed 
deferred spliced deferred run time suspended derivation restarted combined suspended derivation 
beauty approach combination simply matter unifying types applying resulting substitution 
rst step annotate compile time splice expression general type compatible context 
type may contain free type variables points type unconstrained 
annotate deferred expression type body 
type may mention type variables appearing splice expressions capturing dependency type spliced body 
run annotated type exception expression 
run time evaluating deferred expression come hti rst check type compatible context unifying required type annotated splice actual type annotated 
succeeds replace hti update deferred expression evaluating incorporate actual type applying unifying substitution 
types incompatible mark deferred expression ill typed detected splice run 
evaluating run hti left check type uni ed type easy maintained type evaluation type annotated run 
course run nd failed deferred expression evaluate exception expression immediately 
illustrate return example ofx modi ed include run code run code compile time type inference bound deferred expression assigns body type 
free type variable similarly type inference tells code yield nat 
function free type variable resulting deferred expression type type inference run tells expects deferred expression body type nat nat 
simply record information term roughly code run code nat 
nat nat run time rst wish splice code context unify 
nat 
give substitution 
nat 
nat nat perform splice yielding apply substitution give nat nat incorporating type body code deferred expression type 
run checks type compatibility unifying nat nat nat nat trivially succeeds continues evaluate give result distinguishes dynamic type scheme conventional type scheme uni cation type specialisation splice point 
looking previous example see making sure nat 
compatible 
required uni cation code defer expression spliced constrain types 
intuitively type information ows ways splice ows direction type specialisation 
section develop type system type annotations operational semantics necessary formal 
see system performs type inference compile time distributes residual type checking run time splice run expression 
advantages run time type processing required splice run points program depend syntax expression appear syntax expressions contain requires simple type uni cation 
possible compiled form additional type related information representation deferred expression may run multiple times duplicating type inference 
similarly deferred expression may spliced multiple times duplicating type inference 
importantly polymorphism handled naturally 
formal development formalise system dyn small call value lambda calculus extended dynamic constructs 
syntax source terms de ned implicitly typed 
usual introduces polymorphic terms letrec syntactically restricted bind lambda term 
examples assume dyn extended naturals case booleans pairs constructs obvious way 
type annotation appendix reconstructs types implicitly typed source terms rewrites explicitly typed annotated terms de ned 
annotations exploited operational semantics 
types include empty type function spaces universal type shared dynamic expressions 
take type scheme type case empty type vector 
syntax annotated terms complicated slightly need syntactically restrict bound terms splice free terms 
restriction justi ed inx 
term splice free subterms stage 
example code splice full code splice free code splice full variables constants source terms xj cj ej fj letrec syntax dyn source terms type variables types jhi type schemes annotated terms xj cj letrec tin splice free terms run min predicate extract condition formalised predicate dened uses auxiliary function walk term keeping count number defer splice expressions entered 
range splice free terms 
type annotations fall groups lambda bound variables annotated type may church style presentation type system serve purpose run time 
annotated nat 
type generalisation specialisation explicit type abstraction application system 
example term xy xin true annotated nat bool true nat nat pure type systems type abstraction usual denote kind types 
convenience allow multiple type variables bound single lambda writing denotes informally kind type vectors 
run annotated general type context 
example run syntax dyn types annotated terms annotated run nat nat nat defer annotated dynamic type scheme components splice expression annotated general type required context 
nat 
type variable placeholder lled body spliced execution 
annotated general type inferred body 
type may depend types lambda bound variables example may depend types splice expressions example nat 
course may depend 
free type variables introduced annotations listed type variable list defer expression considered bound 
previous example fully annotated 
denotes ill typed deferred expression 
assume bound variables distinct free variables context take care maintain invariant reduction 
stage numbers type contexts unit term substitutions 
unit type substitutions 
type substitutions syntax dyn substitutions type contexts type contexts substitutions type checking keep track stage free variable bound 
type context de ned ordered nite map term variables type stage lambda abstraction bound 
type variables may bound arbitrary stages map type variables kind stage pure type systems 
abbreviate sequences type variable bindings single type variable vector binding 
write ftv set free type variables appearing types term variables union set type variables domain 
write fv ftv free variables free type variables term similarly types 
de nes syntax substitutions 
name capture avoiding unit substitution terms types applied post de ned barendregt takes care rename bound variables lambda abstractions type abstractions letrec expressions type variable list deferred expressions :10.1.1.26.4391
important inx 
unit type substitution naturally extended type contexts 
non unit type substitution composition unit type substitutions special substitutions id fail 
type substitutions applied pre id identity map id fail failure substitution action types terms unde ned 
dom denote set substitutions 
de ning abbreviate 


emphasise notation denote parallel substitution require 
unify general idempotent substitution dom uni er exists 
unspeci ed substitution domain unconstrained 
write denote substitution type checking unify source program processed compile time type reconstruction algorithm 
infers types translates source program language annotated terms 
algorithm translation quite standard appendix section concentrate type checking algo rithm checks annotated term typed 
judgement proof subject reduction show typed program remains typed reduction ii underpin run time type checks needed run splice 
presents rules deciding typing annotated term 
intend judgement true term stage type type context 
judgement describes typed static terms basis deciding typing dynamic terms 
importantly judgement cases 
rules system parameterised stage numbers 
rule var enforces binding time correctness preventing access variable bound 
hi bound stage accessed stage rejected 
enforce type rules keep track stage subterm 
rule supports cross stage persistence allowing variable bound earlier stage stage coercion 
accepted 
nat rule side condition discuss inx 
possibilities type checking deferred expressions 
rule defer requires type annotated stage 
bound type variables introduced 
rule fail handles case deferred expression body longer valid type splicing expression incompatible type 
deferred expression remains typed 
rule splice requires yield deferred expression previous stage type required context formed 
auxiliary judgement holds formed type scheme stage type context 
type variables scope binding time correct exactly term variables 
de nition straightforward 
rule run ensures yields defer expression exception expression type consistent run expression context 
operational semantics wright felleisen operational semantics rewrite system explicit redex contexts 
small step semantics entirely syntactical simpli es proof type soundness 
distinguish subset terms values shown 
defer expression splice free body considered value analogously lambda abstraction splice free 
contexts nx 
nt abs nh hi var abs hi splice typeof const nt 
nu tu defer 
app app letrec hi hi run type checking dyn terms ground types ftv values xj cj jh stage contexts je je jh stage contexts je je letrec uj letrec jh run syntax dyn ground types values rewrite contexts call value semantics application semantics defer splice run contexts de ned 
context special term single hole denoted syntax 
write denote context hole lled note operation perform alpha conversion context rewriting terms values allows hole appear provided stage ii underneath type term lambda abstraction binding letrec binding iii subterms stage left values 
similarly context rewriting terms splice free terms allows hole appear provided hole stage context 
note allow hole appear lambda abstraction equal numbers nested splice defer expressions 
allow hole appear type variable abstraction 
syntactic fail run letrec restriction bound terms form context required rewriting 
extend type term substitution rewrite contexts obvious way 
notions reduction reduction relation de ned rules notions reduction 
constants functional type rewritten delta function obey delta constraint typeof 
implies delta de ned rules reduction term abstractions type abstractions letrec expressions standard 
call value semantics enforced allowing values substituted term 
call value call name lambda calculus avalue may deferred expression containing free type term variables care taken avoid free cv 
de ned letrec 




letrec 

letrec length length fail unify splice run run fv fail 
unify dom run fail run 
variable capture substitution 
example code code xi inh yi rename inner 
rename bound type term variables renaming issue real implementation semantics 
rule splice shows defer expression may spliced 
uses context allow splice expression rewritten defer expression provided stage 
term level rule splice simple simply replaces entire splice expression body inner expression type level things slightly complicated 
rst check type inner defer matches required context unifying types relative free type variables 
practice call value free type variable constraint uni cation may safely ignored 
uni cation succeeds rule splice applies resulting substitution entire deferred expression including type annotations 
discards type variables just bound storing remainder result deferred expression 
uni cation fails deferred expression longer typed rewritten 
actual implementation represent free type variables types application done constructed 
rule splice fail catches attempt splice ill typed deferred expression 
failure simply propagated outer defer rewritten 
rule run allows deferred expression brought forward evaluated immediately 
rule restricted left hand right hand sides 
left hand side rule applicable body defer expression fully expanded splice free ii required type ground 
reason rst requirement splice expressions legal brackets fully evaluated brackets removed run 
second requirement subtle prevents free type variables rewriting dyn annotated terms escaping deferred expression body 
call value restriction hold 
right hand side rule run rst run time check closed 
test essential preserve type soundness motivated inx 
closed rule attempts unify type type expected run context 
successful unifying substitution applied give rewritten term 
tests failed result exception expression nal subtlety run 
consider run fst nat na rewriting fst introduce free type variable preserve subject reduction allow residual free type variables escape scope deferred expression 
parametric free type variables may safely instantiate empty type 
rule run rewrites example fst rule run fail catches attempt run ill typed deferred expression evaluates exception expression immediately 
reduction relation 
induces step rewrite relation dened 
notice context allows rewrites term stage deeply nested brackets splices 
write 
re exive transitive closure 
slight thorn side 

induce evaluation function eval 
unfortunately deterministic location hole 
example possible decompositions easily xed see de ning family terms contexts indexed stage number 
choose ignore problem assume faced choice splice redexes eval chooses leftmost 
syntactic soundness show type system operational semantics agreement 
full proof 
lemma 
type preserving 
proof case analysis cases standard usual lemmas term type substitution extended handle multi stage system 
proof splice requires additional lemmas dealing contexts type uni cation key lemma introduce type variables scope allows show rng ftv rewrite allow type variables escape scope outer deferred term 
proof run requires small lemma lemma 
progress value exists unique context terms 

proof induction 
cases straightforward 
lemma showing term splice full exists context reaching leftmost splice expression required deferred expression 
theorem syntactic soundness diverges 
theorem subject reduction 
ensure dyn remains faithful na semantics ofx despite optimisations 
particular run succeed exactly terms 
unfortunately require rigorous development na semantics defer 
subtleties section address subtle aspects type checking encountered inx 
dynamic generalisation inx careful prevent spice full terms bound 
motivate restriction 
consider illegal term true consider depends yi nat bool nat nat ill typed clearly depends type body types called 
dependency captured 
solution type generalise just run 
takes back na semantics associated drawbacks 
solution express dependency functor constructed higher order uni cation splicing 
free functor variable example annotated nat bool true nat bool dependency types specialised explicit 
evaluate toh splicing construct higher order uni cation problem unique solution nat 


nat resulting type 
evaluates toh problem nat nat 
solutions 
nat 

nat 
nat may appear arbitrary number splice expressions complexity constraint satisfaction exponential 
abadi introduced su cient syntactic condition functor variables guarantee de niteness solutions uni cation problems 
argue approach reject terms altogether simpli es semantics greatly allows signi cant implementation optimisations reduce expressibility critically 
particular defer expressions tend small bound splice full terms may unfolded bodies risk excessive code duplication 
importantly restriction applies bound terms defer expression way defer expressions spliced run 
compare system abadi requires higher order uni cation able manage dynamic values polymorphic type 
practice restriction severe careful reader noticed bound expressions example ofx splice free 
practical implementation need prevent type generalising bound splice full expressions 
monomorphic splice full expressions polymorphic splice free terms may safely bound 
closed vs open code inx argued incremental staged type inference replacement na semantics ofx 
looking na rewrite rule run see type checked empty environment implicitly requiring closed 
replaced rewrite rule run see implicit test explicit 
explicit test expensive jt 
unfortunately eliding test incremental setting destroys subject reduction property 
example evaluating run hxi typed rst evaluate run hxi 
succeed yield result binding time incorrect xi ill typed bound stage stage 
problem depends environment binding lost run 
body deferred expression depend variables bound stage bindings lost 
safe depend variables bound earlier stages call value semantics variables replaced values time defer expression evaluated 
example rejected syntactically obviously open 
expressions code run code inh clearly require constraint code closed propagated call site suggesting check belongs type system 
brie outline enhancement type system reject examples compiletime run time 
type system developed previous 
deferred expressions partitioned environment type checker keeps track environment variable belongs addition usual type stage 
type annotation assign deferred uses variable environment importantly locally bound variables appear type context free 
accept closed deferred expressions type rule run simply checks argument free 
run rank polymorphic type run hi 
con rming intuition runnable dynamic expression runnable environments 
formal description type system 
unfortunately dynamic context rank polymorphism run quickly spreads functions requiring type explicit annotation requiring sophisticated type system deal :10.1.1.27.5598
clearly contradicts claim require explicit types 
reason prefer leave check closed code run rewrite rule 
related dynamic typing concentrated soft typing static analyses determine run time type checks may safely elided programs untyped languages :10.1.1.52.5004
solutions dual problem adding dynamic types statically typed language appear clu cedar mesa see discussion rst considered ml unpublished mycroft :10.1.1.39.8459
proposals date variations typecase construct illustrated 
vary resolving power ability distinguish dynamic values type typecase 
simpler spectrum system abadi allows typecase patterns contain type variables order express type dependencies dynamic values :10.1.1.39.8459
means family dynamic values may matched single typecase arm 
dynamic values monomorphic 
approaches supporting polymorphic dynamic values explored leroy mauny :10.1.1.12.5664
simplest system allows polymorphic dynamic value distinguished instances allows polymorphic dynamic value type specialised pattern matching 
complex system allows type variables patterns :10.1.1.39.8459
pattern matching typecase formalised rst order uni cation mixed quanti er pre universally quanti ed variables denote pattern may match family dynamic values existentially quanti ed variables denote pattern may match suitably polymorphic dynamic values 
dubois allow functions implicitly bind types arguments provide typecase construct support generic programming :10.1.1.28.4059
extension arbitrary polymorphic dynamic values considered abadi :10.1.1.39.8459
proposal extends patterns higher order functor variables order match dynamic values arbitrary polymorphic types 
adds signi cant complexity language functors syntactically restricted avoid requiring full higher order uni cation 
example apply dyn 
dyn dyn apply df dx typecase df ff gg 
typecase dx ftg 
dynamic gg applies dynamic value dynamic function polymorphic single type variable encoding required type check typecase patterns 
bound functors run time explicitly type specialised type result explicitly recorded resulting dynamic value 
approach requires programmer perform complex type checking explicitly 
fairly verbose compared solution apply hi hi hi apply df dx df dxi approach motivated davies pfenning taha sheard staged computation :10.1.1.28.4059
operators correspond prev constructs extended allow persistence :10.1.1.28.4059
run operator corresponds unbox pop operation appropriate dynamic check closure :10.1.1.28.4059
approach dynamic typing extends staged computation stage type inference demonstrated convenience programming examples type information di cult impossible express compile time 
demonstrated additional expressiveness staged computation splicing open code multiple stages programming dynamically typed values convenient 
system de nitely lies complex spectrum dynamic typing systems sketched inx 
complexity justi ed 
monomorphic dynamic values required simply stored retrieved printed answer probably 
polymorphism introduced picture clear 
argue proposal conceptually simpler abadi 
argue additional expressiveness system leroy mauny exploited add features pretty printing dynamic code linking language simply addition primitive functions :10.1.1.12.5664
main avenues research 
currently implementation superset dyn feasibility known machine compiled implementation exist 
implementing code splicing run time type uni cation ciently primary challenges 
lee leone run time code generation suggests overhead splicing may small factor extensive body research cient uni cation prolog suggests type uni cation inexpensive :10.1.1.43.7639
wish develop denotational semantics semantic soundness theorem complement purely syntactical presentation 
models monomorphic dynamic values level languages developed isolation :10.1.1.39.8459
combination generalisation polymorphic dynamic values non trivial 
note generalisation arbitrary stages just problematic stages may collapsed single dynamic stage 
dyn call value calculus 
known embedding call name lambda calculus call value calculus dyn intermediate language call name language bound expressions create thunks closures whichwe represent deferred expressions tagged statically dynamically typed 
add simple form dynamic typing haskell 
walid taha anonymous referees helpful comments 
abadi cardelli pierce plotkin :10.1.1.39.8459
dynamic typing statically typed language 
acm transactions programming languages systems apr 
abadi cardelli pierce remy 
dynamic typing polymorphic languages 
journal functional programming jan 
aiken wimmers 
type inclusion constraints type inference 
proceedings acm sigplan conference functional programming languages computer architecture pages 
aiken wimmers lakshman 
soft typing conditional types 
proceedings annual acm symposium principles programming languages portland oregon pages 
barendregt 
generalized type systems 
journal functional programming 
barendregt :10.1.1.26.4391
lambda calculi types 
abramsky gabbay maibaum editors handbook logic computer science volume chapter pages 
oxford science publishers 
cardelli martini mitchell scedrov :10.1.1.35.8290
extension system subtyping 
information computation 
cartwright fagan 
soft typing 
acm sigplan conference programming language design implementation toronto ontario pages 
acm press jun 
davies 
temporal logic approach bindingtime analysis 
clarke editor proceedings eleventh annual ieee symposium logic computer science new brunswick new jersey pages 
ieee computer society press jul 
davies pfenning :10.1.1.28.4059
modal analysis staged computation 
proceedings rd annual acm sigplan sigact symposium principles programming languages st petersburg beach florida pages 
acm press jan 
dubois weis :10.1.1.28.4059
extensional polymorphism 
proceedings nd annual acm sigplan sigact symposium principles programming languages san francisco california pages 
acm press jan 

girard 
system variable types fifteen years 
huet editor logical foundations functional programming ut year programming series chapter 
addison wesley 
danvy 
thunks lambdacalculus 
journal functional programming may 
ftv idj 
var 
ftv defer hi ne unify hi 
run 
run henglein rehof 
safe polymorphic type inference dynamically typed language translating scheme ml 
proceedings acm sigplan conference programming languages computer architecture pages 
acm press jun 
jones gomard sestoft 
partial evaluation automatic program generation 
prentice hall international 
lee leone :10.1.1.43.7639
optimizing ml run time code generation 
acm sigplan conference programming language design implementation pages philadelphia pennsylvania may 
leroy mauny :10.1.1.12.5664
dynamics ml 
journal functional programming 
microsoft 
component object model speci cation 
technical report microsoft 
milner 
theory type polymorphism programming 
journal computer system sciences 
moggi 
categorical account oftwo level languages 
proceedings thirteenth annual conference mathematical foundations programming semantics electronic notes theoretical computer science volume 
elsevier science publishers 
mycroft 
dynamic types ml 
unpublished draft article 
nielson nielson 
level functional languages 
cambridge university press 
odersky laufer :10.1.1.27.5598
putting type annotations 
proceedings rd annual acm sigplan sigact symposium principles programming languages st petersburg beach florida pages 
acm press jan 
peterson hammond 
report programming language haskell version apr 
shields sheard peyton jones 
dynamic typing staged type inference 
technical report tr university glasgow department 
ftv ftv nf 
ftv 
unify hi 
run type annotation dyn terms extract splice computing science aug 
available www dcs gla ac uk mbs pub tr ps gz 
taha sheard 
multi stage programming explicit annotations 
partial evaluation semantics program analysis pages 
acm press 
wadler blott 
hoc polymorphism ad hoc 
proceedings sixteenth annual acm symposium principles programming languages pages 
wright felleisen 
syntactic approach type soundness 
information computation nov 
type annotation presents type reconstruction algorithm straightforward extension algorithm 
deductive style motivated presentation :10.1.1.27.5598
elide rules const abs app letrec de nition straightforward 
intend true source term rewritten annotated term general type context 
typed rules ftv 
quick check shows relation functional inputs outputs 
rules splice run annotate terms general type inferred context 
rule defer annotates deferred expression general type body collects type variables type body bound outer scope 
step mimics generalisation done bound terms 
rule defer reject ill typed defer expression body statically ill typed 
xi rejected annotated typed probably useless 
system enjoys principle type property defer showing soundness completeness type annotation type checking 

