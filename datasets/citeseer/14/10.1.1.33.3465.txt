vldb journal manuscript 
inserted editor unql query language algebra semistructured data structural recursion peter buneman mary fernandez dan suciu university pennsylvania labs received date revised version date presents structural recursion basis syntax semantics query languages semistructured data xml 
describe simple powerful query language pattern matching show expressed structural recursion introduced top recursive function similar way xsl defined xml trees 
cyclic data structural recursion defined equivalent ways recursive function evaluates data top remembers calls avoid infinite loops bulk evaluation processes entire data parallel traditional relational algebra operators 
possible optimization techniques relational queries applied structural recursion 
show composition structural recursion queries expressed single query basis optimization method mediator systems 
formal properties established structural recursion expressed order logic extended transitive closure data complexity ptime relational data conservative extension relational calculus 
underlying data model value equality formally defined bisimulation 
structural recursion shown invariant respect value equality 
interest semistructured data sparked years ago development object exchange model oem pgmw data format exchange arbitrary database structures applications 
novel oem ability accommodate irregular semistructured data data assigned schema 
immediate application data integration modeling forms irregular data scientific data formats web aqm bdhs ffk 
parallel development xml emerged standard format data exchange web con 
roots xml data models document markup languages markup convey structure layout document 
despite disparate origins different superficial appearance oem xml approaches remarkably close underlying data model see example abs 
model extremely simple labeled graph 
new data model immediately invites development query language model 
relational query languages taken yardstick desirable query language underlying optimizable algebra simple surface syntax sql oql ability define views compose queries surprisingly number languages developed adapted semistructured extensive list desiderata xml query language see maier ql peter buneman data xml graphlog cm msl unql bdhs lorel aqm strudel ffk xsl cla cla xql rob xml ql dff :10.1.1.32.3916
aspects languages set apart standard database query languages 
capable extent treating schema information attribute names data need perform searches graph incorporate form recursion 
aspect unusual clearly available relational database systems schema information table available complex object languages logic kw schema way queried 
second aspect challenging 
established recursive query optimization techniques developed deductive databases context semistructured data 
allowing arbitrary recursive programs optimization difficult probably allows nonterminating programs 
existing systems adopt ad hoc rules bound recursive searches 
unql unstructured data query language bdhs new approach querying semistructured data introduced structural recursion :10.1.1.32.3916
idea limit form recursive program tying closely recursive structure data 
unql query languages semistructured data met criteria optimizable algebra simple query language compositionality database query language 
addition exploiting structural recursion unql introduced idea patterns templates simple surface syntax 
somewhat different model oem 
roughly speaking unql model relational model value allows analogous optimizations relational databases 
purpose explain detail various components unql model query language internal algebra optimizations 
believe quite general design implementation query languages semistructured data 
activity world wide web consortium brought structural recursion center discussion xml query languages 
xml best explained database person syntax semistructured data 
xml languages adopted far industry xsl cla cla relative xql rob 
original goal xsl express transformations xml html called stylesheets idea xml authors associate stylesheet xml document 
browser execute stylesheet obtain html representation document displayed 
xsl evolved general xml xml transformation language 
xml language shipped commercial products substitute xml query language influence xml languages 
query language xsl close declarative query language database person familiar 
consists collection rules pattern template 
input xml tree processed top matching pattern current node 
match occurs template rule evaluated possibly triggering rules applied recursively node children 
xsl semantics best understood terms recursive functions declarative semantics 
show follows programming paradigm structural recursion 
believe structural recursion position bridge gap document database communities working xml query language 
time optimization evaluation techniques show structural recursion apply xsl 
patterns templates semistructured query languages pioneered unql important context xml 
xsl xml ql query language specifically designed xml patterns templates xml ql unql style quite closely 
unql value data model general interest 
relational databases relations treated equivalent observably equivalent 
distinguished query 
relations queried relational algebra means relations sets order multiplicity tuples relation unimportant 
graph databases queried unql relevant notion bisimulation 
compared graph isomorphism appropriate notion observable equality oem bisimulation certain advantages 
example efficiently check existence bisimulation decide graphs observably equal 
duplicate elimination efficiently performed performed place query affecting semantics 
html subset xml 
unql query language algebra semistructured data structural recursion interest bisimulation semistructured data goes unql 
model bisimulation adopted dgm describe relationship semistructured data description logics 
relevant query languages fact bisimulations useful building indexes 
languages semistructured data including xsl incorporate form regular path expression evaluate efficiently researchers investigated path indexes data structures summarizing paths data 
example structure data guide gw 
assuming data nondeterministic automaton data guide deterministic powerset automaton 
data guides certain data instances especially trees scale highly connected instances 
shown bisimulation successfully replace powerset construct purpose index construction 
indexes ms example scale better data guides cyclic data 
complete description unql data model query language optimization techniques formal properties 
announced previously bds bdhs details proofs published 
techniques properties transcend unql scope applicable contexts example conservativity result announced bdhs proved prove similar properties struql reduction unql ffls :10.1.1.32.3916
put techniques show optimizations structural recursion mediator data integration system query rewriting 
reports time unql implementation 
specifically contributions describes structural recursion query language trees explains relationship xml 
describes declarative syntax subset language subset uses select syntax patterns templates translation syntax structural recursion 
describes original semistructured data model labeled graphs 
model value opposed object value equivalence certain notion bisimulation 
large class results obtained graphs bisimulation simply establishing finite trees 
shows structural recursion lifted trees graphs defines calculus graphs structural recursion 
describes different evaluation techniques structural recursion top bulk proves equivalent 
bulk evaluation implemented traditional database operators top evaluation restricted trees typical xsl processors 
describes optimization structural recursion shows applied mediator systems 
optimization relies certain algebraic laws validity proved 
establishes proves formal properties calculus queries invariant bisimulation calculus expressed order logic extended transitive closure calculus conservative extension relational calculus relational data 
reports implementation unql ml 
related graph query language graphlog cm deserve credit possibly languages querying semistructured data 
graphlog datalog recursive datalog queries graph queries 
uses graph model data conforms functional data model query transformation language exploits pattern matching graphs 
removes distinction kinds edge labels forgets schema arrives semistructured data model close model describe 
query languages considered semistructured data 
lorel aqm query language lore semistructured data management system 
lorel adapts oql query semistructured data extending regular path expressions implicit coercions 
lorel extended query xml implementation described mw 
msl logic language semistructured data extending datalog semistructured data tsimmis data integration project pgmw 
language skolem functions semistructured data 
struql query language strudel project web site management system ffls ffk 
especially designed allow complex graphs easily constructed declaratively uses skolem functions block structure unique feature struql 
xml ql dff query language xml combining unql patterns templates struql skolem functions block structure 
peter buneman structural recursion known functional programming community years appears reduce fold operators languages lisp ml haskell 
proposed database languages fad machiavelli obb 
semantics recursive programming constructs collection types described tannen subrahmanyam bts 
phil wadler observed connection comprehension collection types lists bags sets wad structural recursion :10.1.1.33.5381
query language built comprehension described bls properties languages described 
structural recursion described extends principles trees graphs 
skolem functions discussed context databases maier mai 
ak logic kw ilog hy 
courcelle cou considers hypergraphs sources distinguished nodes hypergraph 
defines hypergraph operators proves hypergraph constructed operators 
related data model consists graph distinguished input nodes output nodes define constructors 
courcelle operators directed distinguish input output nodes 
structural recursion related top tree transducers rs powerful express joins cartesian products expressed top transducers 
topdown transducers closed composition words enjoy optimization similar theorem 
reason top transducers express non terminating queries form side effect structural recursion 
bisimulation considered process algebra mil 
efficient algorithm computing bisimulation described paige tarjan pt best known algorithm computing simulation 
bisimulation applied indexes semistructured data ms 
organization organized follows 
sec 
introduces semistructured data model structural recursion restricted trees 
sec 
describes applications structural recursion paradigm querying ordered trees querying transforming xml usage mediator systems 
sec 
model extended arbitrary graphs calculus graphs uncal sec 

formal properties optimization techniques established sec 

evaluation strategies implementation reported 
conclude sec 

semistructured data structural recursion start describing simple tree model semistructured data show structural recursion works trees 
introduce query language unql traverse data arbitrary depth regular path patterns describe semantics trees 
restricting data trees structural recursion unql queries easier define understand 
course real data cyclic show sections operations extend naturally arbitrary graphs 
semistructured data modeled trees fig 
illustrates typical example semistructured data adapted www gov cia publications factbook index html contains information countries geography people government data viewed tree nodes correspond objects leaves atomic values 
simple syntax textual representation semistructured data example text form appears fig 

atomic values include quoted strings ireland numbers possibly basic types 
structured values internal nodes tree denoted labels country name atomic values structured values 
apologize central intelligence agency liberties taken excerpt useful database 
unql query language algebra semistructured data structural recursion country name geography people coordinates area population ethnicgroup ethnicgroup ethnicgroup lat long total land 
luxembourg legislative 
italian portuguese executive country country government fig 
example semistructured data instance 
factbook country name ireland geography coordinates long lat area total land water people population ethnicgroup ethnicgroup english government executive name ahern function prime minister legislative country name luxembourg geography coordinates long lat area total land people population ethnicgroup ethnicgroup portuguese ethnicgroup italian government executive name jean function grand duke name function prime minister legislative country name belgium geography coordinates long lat area total land water people population ethnicgroup fleming ethnicgroup government executive name albert ii function king name dehaene function prime minister legislative 
fig 
textual representation semistructured data fig 
peter buneman different syntax tuples labels may repeated duplicate labels represent sets example having introduce special set notation 
semistructured data called schema self describing data attributes data values intermingled permits representation irregular data 
example repeated attributes ethnicgroup missing attributes water permitted attributes may different types different objects 
importantly structure data may evolve time ethnicgroup occur level level data valid 
summarize syntax trees unql fl tg ranges atomic values ranges labels 
example syntax describe regular data relation student id name simpson age student id name age student id name age repeated label student represent set subtrees 
oem pgmw model defines semistructured data labeled graph fig 

fundamental distinction unql oem models unql fl denotes set label tree pairs object 
contrast oem associates separate object identifier node tree 
unql model relational model value 
example fa fa mean unql different oem 
non atomic values sets label value pairs built basic constructors sets empty set fg singleton set fl vg union sets notation fl shorthand fl fln example fa fc shorthand fa fb fc fd fa fe 
summarize constructors trees fl tg fg ranges atomic values labels 
obviously operation sense sets atomic values 
structural recursion trees recursion usual programming idiom tree data 
introduce restricted form recursion structural recursion declarative permits optimizations expected database query language 
key idea structural recursion form program follows structure data 
restrictions syntactic ensure recursion terminates 
introduce structural recursion example give formal definition 
structural recursion operator query language may combined operators 
assume want retrieve ethnic groups database 
structural recursion write query recursive function fun ethnicgroup result uppercase symbols variables 
left hand sides equation patterns note patterns follow constructors sets 
function applied value value matched pattern turn 
set constructed union operation bind variables components evaluate right hand side 
set singleton label value pair bind variables label value respectively 
empty set variables bound 
line pattern consisting variable catch clause pattern matches particular matches atomic values 
constructors semistructured data matched unql query language algebra semistructured data structural recursion pattern 
value matched pattern follow convention functional programming languages take matching pattern 
order equations significant 
taken patterns define function 
syntax pattern matching borrowed ml borrow keyword fun fun defining function 
result query applied database result result english result portuguese result italian result fleming result 
duplicates eliminated set semantics 
note recursion twice definition 
horizontal structure value second vertical structure tree 
traditional relational object oriented query languages query languages semistructured data operate vertical dimension search tree arbitrary depth 
allow arbitrary expressions right hand side clauses structural recursion easy construct programs terminate nondeterministic see bts 
impose additional restrictions 
right hand side clause union pattern form 

recursive calls right hand side singleton clause fl tg argument results recursive calls constructors passed arguments functions predicates 
particular recursive calls form fa fb allowed 

result 
restrictions mean lines program may omit 
restrictions deal determinism matter decompose set union smaller sets including empty ones get result 
restriction guarantees recursive call argument strictly smaller input function terminates 
show constraints guarantee structural recursion deterministic terminates graphs cycles 
syntactic abbreviation line missing empty set returned default 
example reduces sfun ethnicgroup result sfun indicates defining function defaults 
may constants patterns place conditionals sfun ethnicgroup result notation 
examples structural recursion structural recursion allows express complex transformations data structure 
simple example structural recursion allows copy tree sfun example returns isomorphic copy input tree labels sfun peter buneman child child child mother father mother joe sally jane bill person person person person name name name name fig 
data graph cycles function double children node giving result apparently exponential size input sfun example tree function returns show power result expensive computation encoding result directed acyclic graph guarantees structural recursion function computed efficiently ptime 
practice useful write multiple recursive functions may call 
fig 
construct view isomorphic copy data numbers directly indirectly reachable area edge converted km mi achieved recursive function calls recursive function 
sfun area area sfun isint starts processing tree root copies reaches area calls subtree copies subtree converts numbers tree 
branches encounter area simply leaves numbers atomic values unchanged 
mutually recursive functions possible shown odd example sec 

general number mutually recursive functions defined simultaneously 
definitions restrictions remain fg fg function restriction relaxed allow right hand side clause fl tg recursive calls 
cyclic structures digress brief discussion restrictions recursion needed 
complete explanation deferred sections 
consider cyclic structure shown 
query extract names occur fun name answer view definition program loop infinitely 
alternatively view set equations find instance function satisfies left hand side right hand sides clause 
possible solution fact minimal unql query language algebra semistructured data structural recursion answer joe answer jane answer sally answer bill 
note complicated expressions right hand side clause mean finite solution equations 
suppose union replaced list append operation 
solution equations contains infinite list 
ability deal cyclic structures clean principled manner advantage unql model 
lorel cycles query arbitrarily terminated query revisits node visited 
xsl shall see certain queries cause infinite loop acyclic data 
query language addition structural recursion unql simple select surface syntax pattern matching query select result country name france people ethnicgroup db query finds ethnic groups france function assumes label ethnicgroup occur certain position database 
pattern country name france people ethnicgroup viewed tree 
matched possible ways subtree tree db 
matching binds variable node database 
binding result result constructed union results returned 
general patterns syntax similar trees pat fpe pat pen patn pat var const pe label rpp tree variables var bound nodes tree denote subtree dominated node 
const denotes atomic constant 
pe pen path patterns label regular path pattern rpp label variable 
example contains labels name people 
regular path patterns described sec 
example people ethnicgroup 
label variables variables bound label constants example select result country db result consists labels country 
regular path patterns described detail 
conditions multiple patterns clause may include conditions 
example query select result country name people population db condition evaluates true bound atomic integer value greater 
comparison operators predefined user defined unary predicates supported 
predicates return false argument bound non atomic value 
condition tests equality atomic values trees 
efficiency unql primitive check tree equality provide isempty predicate tests bound leaf node atomic value fg 
multiple patterns clause permitted peter buneman query select result name people country name people db population query returns country name information people tree variable clause bound node tree 
predefined variable db bound root 
tree variable occurs select clause subtree bound substituted result 
joins multiple patterns variable equality express joins 
query self join returns countries ethnic group common france query select result country name france people ethnicgroup db country name people ethnicgroup db nested queries nested queries select clause group results express outer joins 
query finds ethnic groups associates set countries group occurs query select result ethnicgroup select country country name people ethnicgroup db country people ethnicgroup db note occurs inner outer queries implicit join 
result contains result ethnic country ireland country luxembourg result ethnic portuguese country luxembourg country portugal 
nested queries retrieve optional fields form outer join 
query retrieves land areas available water area query select result country select water country name geography area db land general syntax semantics general syntax unql queries query select template bc bcn template fte template tem template var query te label bc pat var boolean combination equality inequality conditions externally defined predicates applied variables 
unql query language algebra semistructured data structural recursion variable unql query scope 
query select template bc bcn bc pat var bc bcn pattern variable occurs 
scope defined pat bc bcn template 
occurrences scope taken variable 
example select fa xg db fb xg db occurrences denote variable effect query bind values occur edge 
contrast select fc select fa xg db select fb xg db disjoint scopes different variables 
exists predefined variable db bound database interest scope entire query 
bind condition form pat var may occur scope var 
remainder section assume queries written variable occurs pattern 
replace subsequent occurrence fresh variable add condition example query occurrences variable transformed select fa xg db fb db 
define result query tree database defining semantics query time sub queries defined independently 
say tree included tree atomic value fl fl exists included query select template input tree 
consider set variables template scope assignment mapping nodes atomic values conditions hold 
distinguished variable db mapped root node query satisfied follows 
form pat var satisfied var node tree pat included subtree root var 
boolean condition satisfied variables occurring condition mapped atomic values boolean condition holds atomic values 
require template atomic value happen template single variable var var atomic value 
assignment evaluate subquery occurring template doing consider assignments extend new variables template denote tree obtained replacing subquery value variable var var 
define result possible assignments variables semantics query tree defined template template 
translating queries structural recursion show pattern matching translated structural recursion 
simplify presentation describe case queries regular path patterns sub queries 
step transform query query basic label value patterns repeatedly applying rules query clause fpe pat pen patn ar fpe pat ar patn ar fpe ar fpe arg ar pat ar second rule pat pattern variable constant newvar fresh variable name 
rules produce select result country db name france people ethnicgroup describe nested functions unql follow ml syntax introducing local names fun sqrt peter buneman notation define query database db sfun ethnicgroup result db created local scope function name defined apply db 
second translation step apply rules repeatedly select fpe tg rest sfun fpe tg select rest select rules rest syntactic meta variable stands remaining clauses component new function name different name scope 
example query select result country name db translated sfun country sfun name result db applied result sfun country sfun name france sfun people ethnicgroup result db functions defined structural recursion recursive 
note rules pattern matching fname france returns empty set applied structure label value pair 
regular path patterns far examples select queries horizontal structural recursion translated structural recursion produce non recursive functions 
possible express certain deep queries select regular path patterns 
seen simple instances regular path patterns 
regular path pattern simply regular expression alphabet edge labels including wild card label 
example pattern country abbreviated country geography coordinates long query select vip country government executive name db underscore wild card 
matches label equivalent introducing new variable query 
queries illustrate alternation optional labels select vip country government executive name db select vip country government executive name db unql query language algebra semistructured data structural recursion example name 
means zero occurrence label name predicate tests argument string 
query accounts irregular fashion names state represented 
kleene star may match paths data unbounded depth select name name db summary regular path patterns rpp label rpp rpp rpp rpp rpp 
rpp usual omit parentheses operator precedence clear 
regular path pattern translated structural recursion expressing regular expression automaton may non deterministic associating function state 
example consider regular expression query select fa bjc tg db 
equivalent nondeterministic automaton states transitions initial state terminal states 
query equivalent function sfun sfun sfun sfun function corresponds state pattern symbol occurring transition state 
terminal states occur right hand side result unioned translation generalizes easily regular expression language include empty string 
lang encode gamma structural recursive function define summary unql summary unql consists operators tree constructors fg fl tg fl functions defined structural recursion queries defined select gamma pattern matching translated structural recursion 
tree equality stated values sets label value pairs brief discussion cyclic structures shows importance set semantics interpretation structural recursion graphs 
question structured values equal 
example interpret set 
similarly fname joe tel tel name joe tel fname joe tel tel tel denote value means unql discard duplicates 
sql allows sets bags duplicates explicitly removed unique 
definition equality obvious deal deeper trees 
example value prompts general inductive definition value equality trees 
peter buneman definition value equality trees defined follows 
atomic values values 
fl fl mg exists ng ng exists mg definition tree equality generalize definition equality bisimulation graphs sec 

applications unql extending unql cyclic data discuss applications unql 
querying ordered trees sec 
assumed trees sets order duplicates matter 
applications xml ordered tree model children node prescribed order 
operations discussed interpreted perfect sense ordered tree data model optimizations developed sections ordered trees 
limitations techniques migrate unordered ordered model 
optimizations example idempotence fails know extended structural recursion ordered graphs 
extension unordered graphs discussed sec 

change syntax ordered trees tree list tree constructors form append replaces union structural recursion defined clause replaced 
example ethnic groups retrieved fun ethnicgroup result querying transforming xml xml 
xml standard approved data exchange format web viewed approximations syntax semistructured data 
example data written xml factbook 
country 
name 
ireland name 
geography 
coordinates 
long 
long 
lat 
lat 
coordinates 
area 
total 
total 
land 
land 
water 
water 
area 
people 
people 
government 
government 
country 
country 
country 
factbook 
unql query language algebra semistructured data structural recursion xsl 
standard query language xml 
xml language supported xsl extensible stylesheet language cla cla 
available commercial products including microsoft internet explorer 
originally designed express xml html transformations name stylesheet language xsl evolved general purpose xml xml transformation languages 
extent serve limited query language 
example consider xsl program xsl template 
xsl apply templates 
xsl template 
xsl template match ethnicgroup 
result 
xsl value 
result 
xsl template 
program consists template rules 
rule match pattern template match pattern rule empty applied second pattern ethnicgroup 
xsl proceeds recursively root document tries match current node patterns rules starting rule 
match occurs corresponding template evaluated 
applied xml data returns result 
result 
result 
english result 
result 
result 
result 
portuguese result 
result 
italian result 
result 
fleming result 
result 
result 
going details xsl xsl program equivalent structural recursion function modulo different syntax duplicate elimination 
fact large fragment xsl rewritten terms structural recursion 
example xsl template 
xsl apply templates 
xsl apply templates 
xsl template 
xsl template match 
result 
xsl value 
result 
xsl template 
equivalent note reversed order cases sfun note function sec 
create output exponentially larger input 
xsl templates express mutually recursive functions execution modes 
suggests strong connection xsl structural recursion 
important differences 
xsl restrict form recursion express nonterminating programs trees 
example consider xsl program obtained adding rule rules xsl template match 
xsl apply templates select 
xsl template 
element encountered templates applied recursively root select focuses scope xsl apply templates root tree 
results non terminating computation input tree element 
second difference xsl permit joins inadequate database applications 
peter buneman xml ql 
proposal query language xml dff 
xml ql incorporates ideas unql struql ffls pattern matching skolem functions 
example query written xml ql factbook 
country 
name 
france name 
people 
ethnicgroup 
ethnicgroup 
people 
country 
factbook 
db construct result 
result 
xml ql joins nested queries regular path patterns unql 
xml ql form recursion similar structural recursion 
function expressed structural recursion expressed xml ql done complicated encoding skolem functions encoding generalize ordered data xml 
summary unql applied xml data extends natural way xsl xml ql 
unql optimizations applications mediators structural recursion admits surprisingly powerful optimizations 
full description sec 

give simple example 
recall example fig 
define view sec 
areas km translated mi functions 
assume view virtual 
assume user wants find france land area mi combined query view plus query sfun area area sfun isint query select result country name france area land db course don want materialize entire view just retrieve value want compose queries obtain simpler query select result country name france area land db optimization requires composing query obtain query 
general problem compose queries expressed structural recursion obtain single query recall select queries non recursive instances structural recursion 
traditional optimization techniques recursive queries datalog solve problem 
describe sec 
general optimization technique structural recursion 
example typical mediator systems 
systems mediator offers virtual view data sources integrated view sources restructuring data source 
systems data sources copied restructured mediated view sources semistructured means mediator may need traverse recursively entire data tree 
mediators recursive function 
user queries general select queries retrieve tiny fraction data query 
optimizing composed query user query plus view definition critical performance 
unql query language algebra semistructured data structural recursion people people fleming fleming population population ethnicgroup ethnicgroup ethnicgroup ethnicgroup fig 
representing data values leaves edges 
graph data model simple data model defined sec 
supports finite trees practice need arbitrary graphs 
section describe graph data model show language trees extends graphs 
need notation 
assume infinite set label symbols label edges 
labels typically strings economy include base types integers reals label 
eliminates need second domain leaf values labels values placed edges see fig 

allow additional special symbol edges denote label def label marker infinite set symbols called markers graph certain nodes designated inputs certain nodes designated outputs nodes labeled markers 
need distinguished nodes markers model order describe semantics structural recursion graphs 
top definition trees graphs cycles course 
new semantics split graph small cycle free pieces apply structural recursion independently pieces glue results 
markers gluing output nodes piece glued input nodes marker piece 
markers unique feature unql data model somewhat related object identifiers object data models oem 
difference node graph marker designated input output nodes marker may graphs useful example gluing nodes marker 
contrast object model node unique object identifier 
markers queries entry points data 
markers denoted 
distinguished marker marker typically default input marker input node labeled called root finite sets markers 
definition labeled graph input markers output markers possible infinite set nodes theta label theta edges theta theta called input node called output node 
mapping input markers input nodes denote unique node associated marker possible empty case empty graph input nodes 
observe labeled graphs inputs graphs input nodes equivalent equivalent empty labeled graph statement formal sec 

need marker need occur particular may empty 
follows labeled graph inputs outputs labeled graph inputs outputs complete definition input nodes incoming edges output nodes outgoing edges leaves 
note labeled graph may infinite 
graph data model finite graphs called data graphs databases denote db set data graphs inputs outputs abbreviate db set db abbreviated db 
peter buneman trees trees defined sec 
particular cases data graphs input outputs 
example trees fa fc dg fc dgg fa fc dgg shown fig 
nodes respectively 
roots labeled marker shown output markers 
omit input marker understood context 
example tree output markers fa 
tree grammar sec 
extended fl tg finite trees graphs guiding principle unql concepts properties lifted finite trees graphs 
show certain class functions defined finite trees naturally extend graphs 
represent graph certain type infinite tree show lift definitions finite trees infinite trees 
representing graph infinite tree achieved process unfolding 
unfoldings arbitrary data graph unfold starting input node 
obtain forest tree input node may infinite need consider infinite graphs 
data graph unfold denotes unfolding 
fig 
illustrates data graph infinite unfolding 
note output marker occurs infinitely times unfold 
require def 

formally db unfolding defined unfold fp path starting xg 
label ends ig 
ends og 
path length consisting node edges enter input node 
particular mapping input nodes unfold 
plan show value equivalent unfold data graph define value equivalence formally 
assumption follows data graph value equivalent accessible part defined set nodes accessible path input node data graph unfolding accessible part 
need show operations properties lifted finite trees data graphs unfoldings 
fact proved appendix 
function labeled graphs labeled graphs 
call compact labeled graph determined actions finite trees formal definition appendix 
call unfolding unfold unfold graph fact compact unfolding functions 
finite forests data graphs 
edges think edges silent transitions automata 
necessary define operators data graphs including structural recursion 
meaning edges captured rule 
data graph edge value equivalent data graph obtained deleting edge adding edge new edge added labeled output marker labeled output marker example fig 
illustrates data graph fa fc dg bg value equivalent data graph fa bg 
nodes edges accessible root deleted unql query language algebra semistructured data structural recursion value equivalence discussed sec 
value equivalence trees 
intuition trees value equivalent equal viewed sets 
extend notion arbitrary graphs define notion value equivalence data graphs satisfies requirements 
data graphs trees value equivalence coincides trees def 

second data graph value equivalent unfold 
may infinite technically data graph 
reason definition value equivalence stated terms possibly infinite labeled graphs 
third data graph obtained eliminating edge described value equivalent requirement path labeled equivalent edge labeled repeating procedure path labeled notation equivalent edge labeled similarly exists path node output node marker may consider labeled definition value equality obtained extending known concept called graph bisimulation 
start reviewing traditional notion graph bisimulation related notion graph simulation 
review graph simulation bisimulation review pt 
graphs theta simulation relation theta satisfying property exists 
check empty relation simulation union simulations simulation graphs exists maximal simulation 
way understand simulation relaxation concept graph morphism function edge image edge function graph morphism simulation viewed binary relation 
computationally simulations graph morphisms behave differently 
deciding exists morphism np complete problem gj maximal simulation computed ptime quite efficiently 
bisimulation simulation gamma def sg simulation 
empty relation bisimulation exists maximal bisimulation 
efficient algorithm finding maximal bisimulation described paige tarjan pt runs log time space definitions simulation bisimulation properties stated carry case graphs labels edges nodes requiring relation preserves labels 
specifically labels edges definition simulation exists 
edges label 
bisimulation gamma simulations notion bisimulation process algebras mil 
labels nodes requires labeled labeled 
problem computing bisimulation labeled graphs reduces unlabeled graphs 
paige tarjan algorithm handles case labels placed nodes 
mention labels explicitly graph equivalence relation computes maximal bisimulation subset equivalently partition defined refinement defined graphs labeled nodes compute maximal bisimulation disjoint union defining equivalence relation nodes labels applying paige tarjan algorithm retaining pairs bisimulation easy check procedure computes maximal bisimulation graphs labeled nodes 
graphs labeled edges need reify 
replace edge labeled new node unlabeled edges new node labeled applying results new graphs total nodes edges 
graphs labels nodes apply previous procedure find maximal bisimulation time log space 
context semistructured data deal rooted graphs 
rooted graph distinguished node called root 
rooted bisimulation bisimulation 
peter buneman fig 
illustration definition extended simulations bisimulations 
roots 
empty relation longer rooted bisimulation general rooted bisimulation may exist 
case rooted bisimulations rooted bisimulation rooted bisimulation exists exists maximal 
easy check exists rooted bisimulation compute maximal bisimulation check value equivalence extend notion bisimulation labeled graphs inputs outputs define value equivalence terms bisimulation 
recall labeled graphs may infinite 
denote exists path labeled respectively 
definition labeled graphs inputs outputs extended simulation relation theta exists node 


exists node 

extended bisimulation extended simulation gamma extended simulation 
condition corresponds traditional definition simulation context path labeled identified edge labeled conditions treat input output markers symbols labeling nodes 
fig 
offers graphical illustration conditions 
says top left part hold right bottom 
example top nodes left path exists path right exists bottom nodes extended bisimulations implication right left hold 
condition def 
requires bi simulation rooted 
consequence empty relation extended bi simulation 
say labeled graphs value equivalent notation exists extended bisimulation easy check graphs value equivalent exists maximal extended bisimulation note condition true relation case empty relation bi simulation graphs value equivalent equivalent labeled graph denote 
shows instances equivalent graphs extended bisimulations 
illustrates requirements value equivalence spelled section unql query language algebra semistructured data structural recursion 
fig 
examples extended bisimulations graphs 
finite trees equivalent sense definition iff equivalent sense exists extended bisimulation data graph bisimilar infinite unfolding unfold unfold data graph equivalent obtained eliminating edge explained earlier 
definition function labeled graphs labeled graphs called bisimulation generic 
function arguments called bisimulation generic implies 
sub section explaining value equivalence efficiently tested 
idea eliminate edges apply paige tarjan algorithm labeled graphs 
data graph 
construct value equivalent data graph edges 
set nodes input nodes 
edges defined follows outputs defined follows exists 
easily checked identity relation extended bisimulation 
computation time dominated time needed compute transitive closure edges paths 
data graphs check value equivalent computing checking exists rooted bisimulation procedure labeled graphs 
peter buneman data constructors constructors trees fl tg fg 
saw tree constructors played crucial role definition structural recursion useful operators query language unql 
extend tree constructors set graph constructors new constructors introduce may find little front syntax query language useful definition structural recursion query optimizer internal operators 
constructors graphs hypergraphs studied courcelle cou 
defines hypergraphs sources defines constructors proving hypergraph expressed constructors 
constructors result immediately carry hypergraphs graphs 
sources graph ordered set distinguished nodes resemble inputs outputs data graphs 
unfortunately constructors include tree constructors fa tg primitives express derived operations fg primitive denoted 
mismatch data models necessitated different collection constructors cou 
data graph constructors 
fg empty tree fl dg singleton tree union trees label root node input marker data graph output marker empty data graph phi disjoint union append data graphs cycle data graph cycles explain constructors formal definition fig 

certain type discipline respect input output markers similar profile cou 
recall convention tree default input marker 
tree operators fg fl dg constructors expect return results polymorphic written fl respectively omit subscript avoid clutter 
note fig 
union defined aid edges 
example fa bg fc fa bg fc egg value equivalent fa 
constructors allow create add input output markers takes root input marker result db xg constructor returns tree single node labeled output marker default input marker fg output marker unique node 
asymmetry input marker constructor output marker constructor due fact want construct trees bottom start single node possibly labeled output marker complete entire tree adding input marker 
empty graph denoted nodes edges value equivalence unique data graph db note distinction empty graph empty tree fg contains single node 
disjoint union phi requires disjoint sets input markers set output markers phi db constructors deal vertical structure data graphs 
append operator defined db db results graph db append essentially performed gluing output node input node labeled marker formally achieved adding edges see fig 

corresponds list concatenation linear trees identified lists fa fa fan zg gg fb fb gg constructors defined sec 

needed model atomic values labels edges 
unql query language algebra semistructured data structural recursion fg fl dg 



phi 








cycle fig 
definition constructors 
fa fa fan fb fb ggg gg 
illustration consider fa fdg fe fg 
value equivalent fa fdg fe fgg 
effect simultaneously substituting output marker value corresponding input marker operator allows introduce cycles db cycle db operator certain type combination allowed input output markers 
said earlier operators polymorphic assume occurrence operator subscripted set input output markers expects drop subscripts avoid clutter 
recall sec 
union operator undefined operands atomic value fag sense 
definition constructors defined long types correct 
illustration fag defined equal fa yg recall atomic values model 
apply definition fig 
results fa fe 
peter buneman notations abbreviations 
abbreviate fl fgg flg fl dn fl fl dn write dn phi phi dn db xm dm xm extend meaning xm dm take union component wise 
extends union operator natural way rooted data graphs unique input marker data graphs arbitrary input markers 
show constructors sufficient enable express data graph value equivalence 
consider case rooted data graph single input marker fv distinct markers xn corresponding vertex 
vertex ng union expressions fa edge source output marker labeling vertex assuming root data graph value equivalent cycle xn illustration consider graph fig 
nodes output marker expressed cycle fa fb consider case data graph multiple input markers xm value equivalent graph form xm dm dm rooted data graphs apply previous construction 
data graph canonical expression denoting course expression unique general equivalent expressions denoting graph 
show constructors bisimulation generic result accidental consequence careful choice constructors definition value equivalence 
proposition data constructors bisimulation generic 
proof done applying definition directly 
illustrate operator handled similarly 
denoting def def prove extended bisimulation relation extended bisimulation relation note nodes union plus new node root call similarly nodes union plus new node denoted 
may safely assume disjoint sets nodes rename 
define relation verify extended bisimulation 
need check conditions def 

take condition 
consider path entirely fact extended bisimulation entirely fact extended bisimulation start root continue say case continues similar 
apply remainder path obtain similar path condition implies roots 
conditions checked similarly 
condition holds trivially unql query language algebra semistructured data structural recursion fig 
relation extended bisimulation weak bisimulation 
fg fl phi cycle ar jif rec ar ar ar label isempty fig 
uncal weak bisimulation extended bisimulation related distinct weak bisimulation process algebra mil silent transitions correspond edges 
graphs weakly bisimilar mil exists relation definition path condition replaced path weak bisimulation notion value equivalence constructors preserve equivalence 
illustrate singleton constructor fa dg 
consider data graphs weakly bisimilar fa fa fig 
left graph root path node weakly bisimilar node right graph 
weak bisimulations extended bisimulations incomparable 
graphs fig 
extended bisimilar weakly bisimilar graphs weakly bisimilar extended bisimilar 
uncal query language graphs uncal unstructured calculus unql internal algebra syntax depicted fig 

name calculus understood sense calculus relational calculus uncal fact closer spirit relational algebra relational calculus 
consists graph constructors introduced earlier variables conditionals structural recursion 
defined data constructors variables conditionals self explanatory 
structural recursion uncal notation rec described 
structural recursion graphs extending structural recursion arbitrary graphs impossible recursive functions run infinite loops applied graphs cycles 
give solutions problem 
memoization remember recursive calls avoid entering infinite loops 
call recursive semantics entirely different view structural recursion apply recursive functions parallel graph edges 
function applied times edges graph infinite loops avoided 
call bulk semantics semantics turn equivalent evidence robustness structural recursion 
third choice inductive definition constructor expression data graph definition possible show equivalent done technical restrictions 
encoding recursive functions define semantics structural recursion argue multiple recursive functions encoded single recursive function 
start illustrating functions peter buneman sfun sfun tree erases edges reaches copies tree replaces rewrite functions single recursive function define auxiliary function label fun case label returns graph input markers output markers 
fig 
illustrates possible shapes 
recall graph set input markers output markers example marker occurrence clearly distinguished input output 
consider structural recursion function 
fun line read type graph input markers 
technically definition extension syntax structural recursion allows function return forest tree forest particular instance graph multiple input nodes 
allow extension structural recursion sequel 
line convention union applied graphs input markers computes union trees graphs separately union trees graphs sec 
write definition structural recursion function sfun relationship hand 
finite tree sketch proof induction fg sides equation 
left hand side induction hypothesis right hand side equation equal 
fl case analysis left hand side induction hypothesis holds substituting body left hand side fa fa definitions equal fa fa 
cases similar 
follows replace mutually recursive functions single recursive function obtain computes computes 
construction generalized mutually recursive functions follows 
set markers 
function defined sfun fl tg recall expression may contain recursive calls substitute markers respectively call resulting expression 
define def 
single structural recursive function expressing functions sfun fl tg recall operator analogous marker substitution 
unql query language algebra semistructured data structural recursion note expressions argument explicitly explicitly previous example explicitly occur 
easily establish equation finite trees induction particular obtain 
consider single structural recursive function form 
syntax uncal fig 
rec simply rec label tree variables understood 
uncal operators set markers normally written subscript rec drop avoid clutter 
structural recursion markers defining structural recursion graphs need precise type set input output markers result structural recursion 
follows discussion tree single input marker output markers rec db set markers case rec arbitrary set input markers arbitrary set output markers requires care 
encounter uses structural recursion sec 
describe optimization techniques important define semantics structural recursion correctly order techniques 
specifically need way generate new markers introduce marker constructor markers delta denotes new marker 
operation delta returns different marker pair think delta skolem function markers difference assume delta associative delta delta delta delta identity delta delta words universe markers denoted marker monoid identity sets markers denote delta set delta yg 
explain types structural recursion 
function label theta db type rec defined function db db deltaz deltaz normally denoted rec usual drop subscripts 
type rec tree follows general rule type rec db delta delta 
bulk semantics structural recursion rec input data graph want define result computing bulk semantics apply body independently edges join results edges operation 
continuing example result bulk semantics illustrated fig 

illustrates effect applying function single edge bulk semantics tree fb fa fb dg bg result reads fa fc dg fc fa fc dg cg reader may compute separately recursive functions tree check 
define bulk semantics general 
fix data graph db node denote root notice consider function defined structural recursion rec body label theta db bulk semantics data graph constructed follows 
disjoint copies node identified apply edge precisely compute data graph take disjoint union data graphs 
nodes uniquely identified sequel notation vertices edges inputs outputs graph referring fig 
nodes outside boxes nodes inside boxes 
add edges connecting nodes nodes associativity delta needed theorem hold 
particular theorem related associativity law monads see wad :10.1.1.33.5381
don require delta associative messy marker renamings theorem hold 
peter buneman fig 
illustration bulk semantics structural recursion 
edges edge add edge similarly add edges 
edge add edge marker discussion leads formal definition bulk semantics structural recursion 
rec data graph data graph rec def fs zg fs def ig unql query language algebra semistructured data structural recursion fig 
chain data graph bulk semantics odd 
og def delta zg def delta zg skolem functions 
sets definable order formula 
notice db definition db deltaz deltaz type defined earlier 
interesting notice bulk semantics expressed entirely order logic extended skolem functions fact non recursive datalog needed 
may sound surprising expressing recursion introducing additional edges result aid markers 
want eliminate edges general compute transitive closure 
effect bulk semantics delays computing recursion isolates single computation transitive closure edges 
appreciate power semantics consider example sfun odd sfun odd odd function runs chain edges finds edge outputs chain length 
chain fig 
bulk semantics returns pair crossing chains fig 
apparently 
really want know unique odd depth depth need eliminate edges starting left input marker corresponding function 
important note query processor eliminate edges application structural recursion 
uncal operators cope edges 
example assume compute chain fig 
function sfun apply data graph fig 
having eliminate edges result similarly shaped graph label edge deleted 
query processor postpone elimination computation 
operator requiring elimination peter buneman isempty example compute isempty choice check unique non edge reachable left marker 
similarity duplicate elimination relational queries aggregates optimizer choice perform duplicate elimination 
definition bulk semantics introduced edges quite generously 
convenient definition practical cases save edges definition 
example fig 
connecting edges output nodes graph input nodes spared nodes glued form optimization generalized case input data graph loops edges node 
alternatively glue input output nodes graph fig 
glue input output conversely graphs boxes 
course optimizations applied example compute transitive closure 
note result structural recursion computation polynomial size input data 
exponential blowup resulting recursive processing trees avoided representing results directed acyclic graphs 
example function sec 
applied tree results essentially graph recursive semantics structural recursion idea simple 
function rec equivalently sfun fl tg compute recursively essentially unfolding input tree recursive calls avoid infinite loops 
algorithm depicted fig 
explain 
number input output markers markers algorithm traverses recursively graph function argument node graph 
visit node check list visited nodes seen far 
initially visited 
recursive call create new data graph fg fg insert visited pair 
data graph mutable object similar record components component initially fg 
input nodes represent node result graph node terminology bulk semantics set edges initially empty 
iterate edges update denotes graph node designated input 
visited retrieve graph return 
precisely return input nodes set outgoing edges may fully computed 
input tree recursive semantics coincides described sec 

non empty node fa function returns precisely structural recursive function fa tg 
equivalence bulk recursive semantics distinct definitions semantics structural recursion 
establish equivalence 
proposition recursive semantics value equivalent bulk semantics 
proof structural recursive function rec denote bulk semantics recursive semantics 
consider data graph show 
accessible part nodes accessible input nodes 
show constructs graph isomorphic notation graph isomorphism course implies value equivalence proves proposition 
strong claim hold need explain detail graph exactly algorithm fig 
constructs 
statement fg fg unql query language algebra semistructured data structural recursion algorithm recursive evaluation structural recursion input rec input graph output method assume returns graph input output markers zp assume xm dm visited fg zp rip return delta delta xm delta zp rmp fun case fg return fg zp fg return delta zp delta zp fa vng exists visited return fg zp fg visited visited dv dv graph new input return fig 
recursive semantics structural recursion returns graph nodes labeled input markers zp edges 
assignment proceeds follows 
notice returns graph input nodes 
effect assignment add edges inputs inputs graph 
similarly statement notice recursive algorithm constructs accessible graph 
claim follows immediately nodes constructed correspond nodes nodes graphs correspond nodes 
structural recursion constructors introduced graph constructors sec 
showed data graph defined expression constructors 
third alternative semantics structural recursion define inductively structure expression 
prove referring graph constructors fig 
showing structural recursion commutes constructor 
cycle constructors corresponding equations hold expression rec depend tree variable limitation adopt alternative definition structural recursion 
equations useful optimizer 
proposition data value equalities hold structural recursion rec fg fg rec fl dg rec rec rec rec rec delta rec peter buneman rec delta delta rec rec phi rec phi rec rec rec rec rec cycle cycle rec eq delta denotes delta delta 
equations additional assumption depend tree variable proof sketch proof 
graph obtained disjoint union graphs adding certain connecting edges see definition fig 

bulk semantics graph rec obtained applying edge independently obtain applying edges separately connecting edges 
set graphs precisely rec second rec third forms precisely edges connecting rec rec rec rec 
case rec cycle treated similarly cycle obtained adding edges equation follows easily 
equalities easily proved similar fashion bulk semantics structural recursion 
note obtain actual graph isomorphism bulk semantics 
cases weaker value equality 
example edges output input rec left hand side edges right hand side operator adds third 
sides value equivalent isomorphic 
note depends applied edge belongs access inspect graph obtain effect computing rec rec independently 
example illustrates case eq 
fails 
consider recursive function sfun isempty returning edges 
function defined sfun mutually recursive defined earlier allowed test isempty see condition sec 

uncal function rec isempty rec flg stands body fag 
consider linear graph fb fa compute directly recursive definition obtain fbg edge 
express fb yg fa return empty graph 
uncal queries uncal expressions built variables label constants operators depicted fig 

rec construction introduces new variables scope expression uncal query expression single free variable db 
illustrate example taken sec 
sfun country sfun name result db delta expressed constructors delta delta zp zp 
unql query language algebra semistructured data structural recursion corresponding uncal query rec country rec name result ng fg fg db recursion marker simplify rec expressions 
uncal hard read intended internal algebra unql user syntax 
discussion polymorphism carries constructors uncal expressions expressions polymorphic assumed expected input output markers explicitly stated drop marker indexes clear context 
uncal queries bisimulation generic proposition bisimulation generic structural recursion function rec bisimulation generic 
proof show data graphs rec rec 
bulk semantics structural recursion def rec def rec definition sec 

recall notation vertices edges inputs outputs data graph precisely extended bisimulation def 
construct extended bisimulation observation vertices 
graphs value equivalent recall graph considered unique input node extended bisimulation follows label bisimulation generic denote extended bisimulation 
construct bisimulation essentially disjoint union extended bisimulations def zg prove conditions def 
satisfied extended bisimulation 
show conditions easy check 
delta definition sec 
form condition extended bisimulation conclude delta condition denoting suffices observe delta delta 
prove holds proof condition identical omitted 
condition show nodes 
path exists path 
cases nodes nodes 
illustrate second case proved similarly conditions eq 
hold 
cases illustrate case node 
path highlight nodes vn zn 
definitions sec 
notice vn exists edge vn def def 
path split peter buneman segments 
proof relies finding similar path consisting number segments labeled labeled intermediate nodes bisimilar construct path inductively left right 
segments correspond group segments construct group segments consider segment separately induction step 
consider segment corresponds path output node labeled exists path output node labeled condition def 
edge edge definition sec 

writing def segment obviously eq 

prove induction step assume fi ng smallest number recall gamma 
consider entire group segments segment consists single edge edge see definition sec 
edge preserves marker include segment group segments traverses graph 
path extended bisimulation condition gives path gives node path prove exists path 
split path path edge 
edge determines edge path gamma gamma node edge input 
fact bisimilar 
segment corresponds path input node output node labeled conditions def 
find similar path input output edge 
put gives segment consider case include segment vn zn group segments 
recall see definition case zn bisimulation gives path 
previous argument split find path edge input 
fact bisimilar segment corresponds path input zn node conditions def 
find path input node gives segment completes proof 
unql query language algebra semistructured data structural recursion expressive power uncal establish results describing uncal expressive power unql expressive power 
compare uncal expressive power certain extension order logic fo 
doing assimilate order structure consisting relations arities respectively 
call standard order structure data graph fo tc immerman imm describes language fo tc order logic extended transitive closure 
extends order logic expressions form tc formula fo tc denoting binary relation tuples assume tuples 
tc denotes transitive closure 
immerman showed fo tc express ordered structures precisely queries nlogspace class boolean functions computable nondeterministic turing machine log space 
establish uncal expressed fo tc 
theorem uncal queries expressed fo tc 
proof precisely prove uncal query expressed formula fo tc standard order structure input graph 
assume expects input data graph db input markers xm output markers 
define fo tc formulas constructing relations output graph 
formulas easy construct fo tc extended skolem functions 
structural recursion rec formulas sec 

constructors depicted fig 
corresponding formulas straightforwardly expressible fo tc 
complication arises conditional gamma gamma boolean condition isempty 
compute transitive closure determine edge labeled different reachable root 
formulas eliminate skolem functions 
done standard technique described example ahv 
idea replace skolem term say tuple 
example triple tuple problems create non homogeneous relations tuples unequal arity need differentiate tuples different skolem terms arity different function names example tuple come 
problems solved padding tuples collection common length distinct constants ff fi tuple padded ff ff fi fi 
position ff changes fi encodes names skolem functions tuple 
details ahv 
note skolem terms tc operators create additional problems contrast skolem terms head datalog rules construct new nodes lead non terminating computations 
immerman result imm obtain immediately corollary uncal queries computable nlogspace ptime 
unql relational data explained sec 
relational data encoded trees student id name simpson age student id name age student id name age course cid title java course cid title advances databases enrolls id cid enrolls id cid peter buneman tree depth encoding instance db relational schema student id name age course cid title enrolls id cid 
general relational schema instance db encoded tree call tree encoding db 
note relation names attribute names occur labels 
recall uncal move values leaves edges see fig 
tree encodings relational databases depth 
unql query relational data 
easy see express relational algebra queries 
example query expresses join select class student id id name db enrolls id id cid cid db course cid cid title db id id cid cid query computes courses taken 
union primitive unql difference uses isempty predicate query returning student names course course notice variable id places express joins concisely select result student id id name enrolls id id cid db isempty select enrolls id id cid db question arises get expressive power relational algebra immediate answer express queries returning non flat results grouping students age select result age students select name student name age db student age db source additional power comes unql ability express polymorphic queries respect relational database schema 
example query returns attributes student smith id select student name smith db id polymorphic works regardless input relational schema 
example evaluate query tree representation table student id name age office phone email retrieve attributes name age office phone email 
interestingly write unql queries ignore schema 
example query returns strings database containing substring java select result db match java apart ability bypass schema question remains unql express queries relational algebra setting input output relational schemas fixed 
answer state general framework uncal queries 
precisely input relational schema output relational schema single relation 
recall ahv relational databases query defined connection input schema output schema maps instances instances 
consider uncal query suppose enjoys semantic property tree encoding instance tree encoding instance 
show exists fo query instances instances equivalent sense instance db maps tree encoding db tree encoding db 
trivial illustration consider unql query retrieving strings database containing unql query language algebra semistructured data structural recursion root fig 
illustration proof lemma 
substring java assume relational schema student id name age course cid title enrolls id cid relational output schema consists single relation single attribute 
expressed union formulas attribute relation fx student match java fy student match java fy enrolls match java important note general depends just input schema output schema remainder section state prove result formally 
start graph theoretic discussion 
graph denote path nodes 
length length number edges 
path simple nodes distinct 
say repetitions node occurs times path particular path simple repetition 
call graph short simple paths length example tree depth short tree encodings relational instances short 
example graph consisting single cycle nodes edges gamma short 
observe short graph compute transitive closure inspecting paths length establish graph theoretic lemma lemma short def gamma gamma gamma 
path repetitions length 
proof xn path repetitions 
refer sequel occurrence may denote node treat different occurrences 
arrange occurrences xn tree nodes node root labeled exactly occurrence root unlabeled 
describe tree top 
node constructed subtrees obtained processing subsequence initially construct root derive children entire sequence follows 
consider node occurrences denoting node split subsequences best visualized gamma gamma gamma xn create children root node follows 
child labeled occurrence subtrees constructed subsequence right gamma recursive manner 
usual defined def gamma peter buneman completes description simple illustration construction consider sequence corresponding tree root illustrated fig 

inspect properties obviously node children 
children parent labeled node corresponding different occurrences 
example root children labeled children labeled second children labeled edge corresponds edge illustrate example node labeled having children labeled exists edge graph occur adjacent path 
node labeled occurrence node occur descendant node 
example node labeled descendant labeled implies path root leaf corresponds simple path depth add root gamma gamma nodes 
recall 
length gamma gamma gamma 
prove remarkable property enjoyed uncal queries 
proposition uncal query exists function input data graph short output data graph short 
proof sketch tree constructors add constant lengths simple paths example fl dg increase 
cycle short markers cycle theta short 
see observe exactly input nodes xm simple path cycle occurs input nodes split simple paths fragments length represents edge connecting output node input node cycle path fragment fragment length follows length 
interesting case rec 
assume increases length function 
consider simple path rec fig 
help visualize path 
un xn nodes type occurring nodes distinct un path repetitions distinct markers xn 
follows length 
path longer nodes path length accounts gluing edges node node path length 
follows length 
theorem uncal expression 
exists fo formula computes short graphs 
proof apply theorem obtain fo tc formula occurrences tc applied short graph unfold tc operator times express fo 
straightforward derive corollary conservativity input relational database schema output relational schema 
uncal query maps tree encodings instances tree encodings instances expressed relational calculus 
unql query language algebra semistructured data structural recursion proof construct query relational calculus simulating operates steps 
step instance constructs order structure representing tree encoding obviously graph short 
query expressed relational calculus extended skolem functions 
note step uses schema step applies fo formula theorem obtain order structure 
step constructs relational output knowing tree encoding instance notice step uses schema formulas composed eliminate skolem functions outlined proof theorem 
steps new 
illustrate example general case obvious 
step assume relational schema course cid title enrolls id cid 
queries construct relations tree omit simply consists nodes mentioned straightforward root course course cid course course title course course root enrolls enrolls id enrolls enrolls cid enrolls enrolls root queries relational calculus extended skolem functions root 
note values placed edges illustrated fig 

step reversed direction easier 
assume output schema result step returns order structure representing tree encoding instance 
construct binary relation result result completes proof 
earlier discussion converse holds relational calculus queries expressed uncal 
optimizations shown sec simple equations optimizer rewriting rules 
show powerful equation optimize mediator systems 
technically involves rewriting composition structural recursion functions rec ffi rec 
recall recursion bodies functions expecting label tree argument 
theorem assume depend argument rec ffi rec rec rec ffi rec ffi rec rec rec rec peter buneman government government government name name official name name name government name name name official government government fig 
illustration optimizing structural recursion 
equations offer powerful optimizations 
left hand side describes structural recursions computed sequence evaluating rec ffi rec directly requires compute intermediate graph rec 
argue intermediate graph large input graph expensive compute 
second structural recursion rec returns small result making cost computing waste 
contrast right hand side equations consists single structural recursion albeit complex body direct evaluation function unnecessary compute intermediate result 
intuition simple 
recursion rec replaces edge new graph 
intermediate graph consists fragments 
rec traverses resulting graph replaces edge graph 
steps achieved single step replacing edge new graph edge replaced rec 
intuitive details tricky rec technically recursion unfinished graph fragment 
things correct interaction recursion markers markers tell fragment connected 
explanation 
needed depend apply fragment 
depend need replace fragment entire graph edges forward 
done substituting rec 
intuition 
proving theorem illustrate examples 
example assuming database fig construct view name attribute government relabeled official 
view computed sfun government government sfun name official query view asks names view sfun name name sfun defined simpler replacing clause sfun fname tg fname tg body directly violating condition theorem 
modified copy aid function 
answer query obtained 
obviously answer obtained directly database returning names government label 
theorem allows derive optimized query automatically 
express rec rec see fig 
assume illustration purposes depend unql query language algebra semistructured data structural recursion case government government government name name official case name name name view defined component rec query answer component rec component rec rec 
optimization theorem allows compute component rec rec ffi 
look body recursion def rec ffi see fig 
case government government government name name name official note returns tree markers 
express rec mutually recursive functions named sfun government sfun name name sfun government government sfun name official observe fg tree calls recursively constructing result 
farther simplify functions sfun government name name sfun government government sfun name official interesting compare informal description earlier compute query directly database retrieve names government 
replaces value name view 
reader may check correct answer query 
example consider example sec 
functions define view areas converted mi query returns land area france 
task simplify structural recursion function followed select query query select area country name france area land db write structural recursive function rewriting sec 

apply step rewriting peter buneman sfun country bh fun bh body select result name france area land query obtained result 
rewrite rec rec case area area area isint case country bh goal compute rec ffi rec theorem equivalent rec rec rec rec rec ffi def rec 
examine obtained unfolding recursion rec replacing markers recursive function calls case area area area isint compute def rec ffi case country bh bh rec db translates structural recursion functions need second unnecessary recursive 
rewritten query query sfun country select area name france area land db repeat process inner select query 
steps obtain simplified query sec 

rest section dedicated proof theorem 
start looking carefully types theorem label theta db label theta deltaz db rec db db deltaz deltaz rec db deltaz deltaz db deltaz deltaz deltaz deltaz rec ffi rec db db deltaz deltaz deltaz deltaz rec db db deltaz deltaz rec ffi label theta db deltaz deltaz rec rec ffi db db deltaz deltaz deltaz deltaz unql query language algebra semistructured data structural recursion recall delta associative 
delta delta delta delta 
shows expressions rec ffi rec rec rec ffi type 
stated repeatedly expressions uncal polymorphic state expected makers explicitly occurrences rec equation different types 
written formally equation rec deltaz deltaz ffi rec rec deltaz rec ffi prove theorem 
proof possible prove statements directly examining graphs sides equation proving value equivalent 
proof complete quite technical 
prefer alternative proof method show equations hold finite trees induction tree structure fact argue hold graphs 
caution reader proof somewhat restrictive appendix substantiate fact subclass uncal queries positive ones prefer complete highly technical direct proof 
precise need prove equalities hold finite forest suffices check finite trees value rec forest fully determined value component tree recall rec phi rec phi rec prop 

prove equations induction finite tree rec rec rec rec ffi rec rec rec rec rec start 
fg sides fg 
fl tg rec rec fl tg rec rec rec rec rec rec ffi rec rec ffi rec rec ffi fl tg eq prop 
fact eq holds induction hypothesis 
rec rec rec rec rec rec rec rec rec rec rec ffi rec rec ffi rec rec ffi induction hypothesis output marker sets markers results directly marker types rec rec rec delta delta delta delta delta delta delta delta delta delta delta rec rec ffi peter buneman prove 
cases fg handled similarly previous proof omitted 
interesting case fl tg 
key observation right hand side single iteration recursive call denoting rec rec right hand side rec fl tg rec 
right hand side recursion remaining tree hidden expression technically follows fact delta output markers occurring output markers rec consumed append operation 
see technical details illustrate types case fg entire recursion applied trees 
label theta db db label theta db db rec db db rec label theta db db ae db rec rec label theta db db deltaz ae db deltaz deltaz rec rec rec db db deltaz types illustrate doesn occurrences output markers delta case fl tg follows immediately rec rec fl tg rec rec rec fl tg rec rec concludes proof 
getting practical evaluate unql unql evaluated ways top bulk 
describe strategies 
assume unql query translated uncal essentially semantics structural recursion sec 
recursive bulk 
illustrate query variation query sec 
query select result country name france ethnicgroup db translated structural recursion query sfun country sfun name france sfun ethnicgroup result db notice go back original data model sec 
data values stored leaves edges 
unql query language algebra semistructured data structural recursion top evaluation uncal query strategy evaluates operators order appear query 
constructors evaluated directly 
structural recursion evaluated recursive algorithm fig 

example query evaluated input graph db follows 
apply recursive evaluation algorithm compute db 
algorithm needs traverse db recursively top evaluate recursion body edge graph 
recursion body function structural recursion function evaluated recursively graph starting current node recursive function computed algorithm fig 

advantage method simplicity 
tree data method proceeds functional programming language 
cyclic data algorithm fig 
adds cleverness avoids chasing infinite loops 
disadvantage method optimizations possible operators evaluated precisely order occur uncal query 
small medium data sets xml documents strategy results acceptable performance 
bulk evaluation consists construction query plan optimized evaluation 
plan starts ternary input relation constructs ternary output relation denoting result graph 
result graph may usually edges removed final step transitive closure operation see sec 

alternatively edges may removed intermediate subexpressions 
query plan operators selections generalized projections dependent joins 
generalized projections allow apply skolem function columns input relation construct new nodes column output relation 
dependent joins see flms non commutative bind variables values left operand evaluate right operand value 
fig 
illustrates query plan example omitting ffl edge removal operation 
obtained applying bulk semantics sec 
recursive function doing simplifications 
general query expressed relational calculus expressions sec 
translated query plan 
results unnecessarily complex plan needs simplified order practical 
fig simplifications hand general framework simplifications scope 
explain plan fig 

recall terminology bulk semantics sec 
structural recursion function returns graph consisting types nodes nodes nodes 
query plan union operator function left operand computes edges edges right operand computes actual body edges 
topmost union operator example corresponds body nonrecursive output markers edges type left operand 
applied root node optimized selecting root 
function constructs nodes skolem functions root root db connection node right operand 
right operand repeats selection oe root country potential optimization retains bindings variable passes right operand dependent join 
top union operator corresponds 
relation scanned column bound searched label name name value france edge new edge created new skolem function 
right operand corresponds variables bound dependent join 
plan traverses entire graph recursive simplifications possible exploit fact called node plan contains different simplification nodes eliminated 
label contributes labeled edge ethnicgroup edge 
optimization mentioned sec 
possible way reduce number edges result 
note original query recursive execution plan non recursive 
plan constructs graph possible edges corresponding recursion 
fact plan just replaces label different ethnicgroup edge 
eliminated final step shown fig 
described sec 

advantage bulk evaluation perform separate optimizations 
powerful apply known optimization techniques non recursive queries optimize structural recursion 
example optimizations dependent joins considered context object oriented peter buneman name france ethnicgroup ethnicgroup root country db root root country fig 
query plan bulk evaluation 
databases bcd cd semistructured data flms 
restriction comes original query boolean predicate isempty introduces transitive closure operators query plan optimizations harder 
practical applications require positive fragment unql isempty benefit known relational optimizations 
implementation unql implemented unql standard ml am att 
unql queries translated uncal implemented top evaluation strategy 
input graphs loaded main memory query interpreter works directly graph representation 
inaccessible memory automatically garbage collected ml explicit memory management necessary 
adequate small input graphs graphs nodes edges scale large graphs nodes 
large scale inputs secondary storage manager accessing graph elements directly disk necessary 
entire implementation unql uncal lines commented ml code 
implementation performs additional optimization naive recursive evaluation strategy 
keeps track markers needed parts recursive function needed evaluated 
example assume mutually recursive functions call data graph translated uncal expression rec recursion body returning graph inputs outputs 
evaluation algorithm sec 
compute def rec compute recall precisely 
short evaluated unnecessarily 
avoid implementation uses smarter evaluation strategy 
top operator append recursive evaluation computes left operand resulting def 
interpreter computes set output markers case complex cases may require traversal fact implementation avoids traversal altogether computing set output markers result evaluation 
unql query language algebra semistructured data structural recursion interpreter evaluates right operand rec knows input marker needed 
proceeds algorithm fig 
root node computes component 
proceeds recursively computes required component node 
course cycles graph logic query may force compute eventually component root computed belongs accessible part result 
believe principles unql useful describing foundations query languages xml semistructured data 
illustrated query constructs structural recursion shown related practical query languages xsl proved powerful optimization techniques 
believe foundations query language design implementation 
important interesting areas research may bear fruit 
connection xml shown principles unql ordered tree model clear extended ordered graph model graph model discussed section unordered graph 
query primitives dealing order provided xml ql lack complete picture topic 
area connection graphlog see sec 
datalog graphs 
elegant formalism querying semistructured data connection structural recursion connection optimization techniques recursive datalog queries br remain unexplored 
optimizations recursive queries example xsl exciting research area 
techniques illustrated provide equational tools needed combine cost model optimization algorithm 

deeply indebted susan davidson collaboration topic getting interested semistructured data place 
gerd hillebrand contributions anonymous reviewer suggested example sec 
numerous constructive criticisms 
abs abiteboul buneman suciu 
data web relations semistructured data xml 
morgan kaufmann 
ahv serge abiteboul richard hull victor vianu 
foundations databases 
addison wesley publishing 
ak abiteboul kanellakis 
object identity query language primitive 
proc 
acm sigmod conference pages portland may 
am andrew appel david macqueen 
standard ml compiler 
functional programming languages computer architecture 
aqm abiteboul quass mchugh widom wiener 
lorel query language semistructured data 
international journal digital libraries april 
att bell laboratories murray hill nj 
standard ml new jersey user guide february 
bancilhon briggs khoshafian valduriez 
fad powerful simple database language 
proceedings th international conference large data bases pages 
bcd bancilhon cluet delobel 
query language object oriented database system 
proceedings nd international workshop database programming languages pages 
morgan kaufmann 
bdhs peter buneman susan davidson gerd hillebrand dan suciu :10.1.1.32.3916
query language optimization techniques unstructured data 
proceedings acm sigmod international conference management data pages 
bds peter buneman susan davidson dan suciu 
programming constructs unstructured data 
proceedings workshop database programming languages italy september 
bls buneman libkin suciu tannen wong 
comprehension syntax 
sigmod record march 
peter buneman br bancilhon ramakrishnan 
amateur recursive query processing strategies 
proc 
acm sigmod conference pages washington dc usa may 
breazu tannen buneman naqvi 
structural recursion query language 
conf 
database programming languages dbpl 
bts breazu tannen subrahmanyam 
logical computational aspects programming sets bags lists 
lncs proceedings th international colloquium automata languages programming madrid spain july pages 
springer verlag 
cd sophie cluet claude delobel 
general framework optimization object oriented queries 
stonebraker editor proceedings acm sigmod international conference management data pages san diego california june 
cla james clark 
xml path language xpath 
www org tr xpath 
cla james clark 
xsl transformations xslt specification 
www org tr wd xslt 
cm consens mendelzon 
graphlog visual formalism real life recursion 
proc 
acm sigact sigmod sigart symp 
principles database sys nashville tn april 
con world wide web consortium 
extensible markup language xml 
www org tr rec xml 
cou courcelle 
graph rewriting algebraic logic approach 
formal models semantics volume handbook theoretical computer science chapter pages 
elsevier amsterdam 
dff deutsch fernandez florescu levy suciu 
query language xml 
proceedings international world wide web conference www toronto 
dgm calvanese giacomo lenzerini 
knowledge representation semi structured data proceedings fifteenth national conference artificial intelligence aaai 
ffk mary fernandez daniela florescu kang alon levy dan suciu 
catching boat strudel experience web site management system 
proceedings acm sigmod international conference management data 
ffls mary fernandez daniela florescu alon levy dan suciu 
query language web site management system 
sigmod record september 
flms florescu levy manolescu suciu 
query optimization presence limited access patterns 
proceedings acm sigmod international conference management data philadelphia june 
gj garey johnson 
computers intractability guide theory np completeness 
freeman san francisco 
gyssens paredaens van den bussche van gucht 
graph oriented object database model 
acm symposium principles database systems pages 
gyssens paredaens van den bussche van gucht 
graph oriented object database model 
ieee transactions knowledge data engineering august 
gw roy goldman jennifer widom 
dataguides enabling query formulation optimization semistructured databases 
proceedings large data bases pages september 
monika henzinger thomas henzinger peter 
computing simulations finite infinite graphs 
proceedings th symposium foundations computer science pages 
hy hull yoshikawa 
ilog declarative creation manipulation object identifiers 
proceedings th international conference large data bases pages 
imm neil immerman 
languages capture complexity classes 
siam journal computing 
kw kifer wu 
logic programming complex objects 
journal computer system sciences 
mai maier 
logic objects 
proceedings workshop deductive database logic programming washington august 
mil robin milner 
communication concurrency 
prentice hall 
ms tova milo dan suciu 
index structures path expressions 
proceedings international conference database theory pages 
mw mchugh widom 
query optimization xml 
proceedings vldb edinburgh uk september 
obb ohori buneman breazu tannen 
database programming machiavelli polymorphic language static type inference 
james clifford bruce lindsay david maier editors proceedings acm sigmod international conference management data pages portland oregon june 
unql query language algebra semistructured data structural recursion papakonstantinou abiteboul garcia molina 
object fusion mediator systems 
proceedings large data bases pages september 
pgmw papakonstantinou garcia molina widom 
object exchange heterogeneous information sources 
ieee international conference data engineering pages march 
pt robert paige robert tarjan 
partition refinement algorithms 
siam journal computing 
ql query xml position papers 
www org ql ql pp html 
rob jonathan robie 
design xql 
www whitepapers xql design html 
rs rozenberg salomaa 
handbook formal languages 
springer verlag 
wad philip wadler :10.1.1.33.5381
comprehending monads 
mathematical structures computer science 
lifting equations finite trees graphs appendix establish formally fact enabling lift equations finite trees graphs 
concerned infinite graphs inputs outputs sets finite implies graph finite set input nodes 
recall finite graph referred data graph 
appendix concerned graph isomorphism bisimulation notation means isomorphic 
infinite graph called locally finite node set outgoing edges finite 
consider locally finite graphs sufficient purposes need consider infinite graphs form unfold data graph forest graph input node root finite infinite tree 
words forest finite set trees distinct input marker finite set 
tree special case forest single input node 
compactness forests inputs outputs say occurs notation exists isomorphism subgraph require isomorphism preserve marker labeling input markers output markers 
obviously reflexive transitive antisymmetric follows fact forests locally finite 
straightforward fact possible infinite forests inputs outputs iff finite forest note property holds locally finite easy find counterexamples 
example take flat trees consisting root single level children infinitely children edges label difference countably children uncountably 
finite trees occurring form fa ag trees isomorphic 
rest appendix deals functions labeled graphs 
precisely writing set labeled graphs inputs outputs consider functions type map isomorphic inputs isomorphic outputs map forests forests 
sets determine function type 
functions type needs prove equalities form data graphs functions labeled graphs type 
easier prove finite forests appendix state sufficient conditions allow lift equations finite forests graphs 
show lift equations finite forests infinite forests 
key property definition function forests forests 
say compact property holds iff 
range finite forests 
peter buneman note compact function necessarily monotone imply 
uncal isempty operator allows define non monotone functions 
example consider function sfun sfun isempty takes tree returns set labels descendants labeled example negation sec 

tree label may result extend introducing label monotone 
show compact 
suppose 
choose consists subtree includes edges label edge include ancestor edges 
extension include edges edges descendant didn 
proposition compact functions 
finite forest forest proof 
plan fact prove done reverse proved similarly 
compactness property apply compactness property obtain exists 

compactness property conclude show lift equations infinite forests graphs 
definition function labeled graphs labeled graphs 
say unfolding unfold unfold data graph proposition unfolding 
forest implies data graph proof follows directly unfold unfold 
theorem fact theorem compact unfolding finite forest implies data graph proof simply combine propositions 
appendix showing theorem applied uncal queries 
turns uncal queries compact 
trivial example consider query returns fcg exists subtree form fa fgg returns fdg 
consider infinite chain fa fa ggg 
fdg finite subtree fcg 
prove compactness property important class uncal queries 
call uncal query positive occurrence isempty operator form isempty fg note positive queries may contain unrestricted conditionals testing label equality form prove positive uncal queries compact 
positive uncal queries monotone course function earlier appendix example non monotone uncal query compact 
need discuss uncal semantics carries finite graphs infinite graphs 
constructors definitions fig apply structural recursion adopt bulk semantics 
particular uncal query returns locally finite graph constructors introduce finitely outgoing edges cycle may introduce infinitely incoming edges unql query language algebra semistructured data structural recursion nodes structural recursion rec check bulk definition outdegree node outdegree corresponding node outdegree node outdegree node refer notations sec 
rec locally finite 
uncal query map forests forests 
example consider trees edges leading root output node 
similarly cycle rec fail return forest general 
get uncal query apply theorem function unfold 
precisely prove 
proposition positive uncal query 
def unfold compact unfolding 
proof proof done induction uncal query referring uncal definition fig 

recall uncal query expression unique free variable 
subexpressions may multiple free variables assimilate expression function 
definitions compactness invariance unfolding extended naturally functions 
illustration purposes show proofs case single free variable 
consider cases proved similarly 
case unfold trivially unfolding 
compactness trivial prove show details 
notice forest pick def notice trivially proves direction 
direction choose def conditions satisfied gives case 
technically similarly prove invariance unfolding unfold unfold unfold unfold apply induction hypothesis claim follows immediately 
prove compactness showing direction direction similar omitted 
assume cases single node contains edges contains 
illustrate case similar simpler omitted 

apply induction hypothesis says compact gives implies similarly choose union recall containment means isomorphic finite union refers finite consider follows compactness 
similarly compactness 
follows case rec 
general form may depend illustration purposes assume depends sketch proof invariance unfoldings 
start noticing unfold unfold rec unfold unfold words doing unfoldings early doesn hurt want unfold final result anyway 
omit details simple fact illustrate intuition graph fig 

unfold graph right get infinite forest 
obtained unfolding graph left reader may help visualize looking fig 
contains similarly shaped graph shows unfolding applying structural recursion unfolding structural recursion creates directed acyclic graph 
invariance unfoldings follows immediately unfold unfold rec unfold rec unfold applied induction hypothesis 
sketch proof compactness illustrating direction 
start unfold rec 
consists finite set nodes finite set nodes 
set gives tree second set gives edge tree notations defined sec 
assume trees apply compactness property gives tree peter buneman apply compactness property times trees gives trees take union discussed trees fact compact follows contains nodes nodes need include furthermore compactness argument combined graphs contain nodes follows rec contains nodes nodes words rec 
illustrate case isempty fg 
invariance unfolding notice isempty isempty unfold isempty isempty fg 
unfold isempty fg apply fact unfolding 
compactness show direction 

cases isempty true false 
case fg fg notice fact fg fact needed 
second case non edge finite tree containing edge 
compactness find isempty false 
prove compactness 
compactness find containing 
choose union isempty false case 
cases similar omitted 

