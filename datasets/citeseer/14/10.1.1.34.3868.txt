domain specific languages design implementation application video device drivers generation scott thibault renaud marlet charles consel irisa inria universit de rennes campus universitaire de beaulieu rennes cedex france thibault com marlet consel irisa fr www irisa fr compose domain specific languages dsl potential advantages terms software engineering ranging increased productivity application formal methods 
practice decades little study methodology implementation tools dsl approach 
dsl approach application realistic domain generation video display device drivers 
presentation focuses validation proposed framework domain specific languages design implementation 
framework leads flexible design structure provides automatic generation efficient implementations dsl programs 
additionally describe example complete dsl video display adaptors benefits dsl approach application 
demonstrates generally claimed benefits dsls increased productivity higher level abstraction easier verification 
dsl fully implemented approach available index terms gal video cards device drivers domain specific language partial evaluation contrast general purpose language gpl domain specific language dsl language expressive uniquely specific features programs problem domain 
small declarative imperative may textual graphic 
dsls partly supported france telecom contract cnet darpa contract 
www irisa fr compose gal called application domain languages little micro languages related scripting languages 
dsls various domains graphics financial products telephone switching systems protocols operating systems robot languages 
languages sql unix shell languages may considered dsls 
software architectures dsls primarily aimed achieving faster development safer applications 
constructs dsl key concepts domain developer skilled programmer write concise higher level programs time 
programming dsl contributes safety error prone gpl 
additionally high level constructs translate practice reuse validated components 
language small specific possible easier apply automated proof techniques developed general purpose languages limited success due generality 
example termination properties may considered language turing complete 
similarly easier build test generation tools 
dsl may seen way parameterize generic application designate member program family 
program family set programs share characteristics worthwhile study 
fact designing dsl involves commonality analysis study program family determining assumptions true members family variations members 
process performed domain experts software engineers 
actual uses dsls record benefits productivity reliability flexibility implementing dsls difficult costly 
kinds approaches language implementation significant disadvantages 
approaches compilers application generators translation dsl gpl easy write extend extensions require skills compiler technology expected domain developers 
hand approaches interpreters easier write extend efficient 
implementation issue impacts maintainability complexity dsl compiler defeats software engineering goals dsl 
depending objectives style implementation chosen application generator interpreter 
proposed framework development application generators reconciles alternatives offering flexibility interpreters performance compilers 
framework relies partial evaluation program transformation technique suited automatically transform interpreters compilers 
partial evaluation exploits known information program input able evaluate parts program advance 
program known portion input partial evaluator produces specialized program 
new semantically equivalent program computations depending known values performed 
interpreter dsl takes arguments dsl program input data dsl program dsl program partial evaluation automatically yields specialized interpreter compiled version dsl program 
framework structured parts come family analysis 
part consists definition machine operations viewed generic components capture important operations domain 
second part definition dsl terms machine operations providing high level interface machine 
partial evaluation framework twofold corresponding part maps dsl program machine program removing interpretation layer machine program efficient implementation 
development framework supported industry partners realistic applications 
describes realistic application framework automatic generation video card drivers 
domain naturally forms program family dsls suited 
design definition complete dsl video display adaptors 
concerning performance show partial evaluation yield efficient drivers 
concerning safety insure generated drivers proven terminate define analyses greatly improve reliability 
dsl fully implemented approach available url www irisa fr compose gal 
contributions summarized follows ffl validate framework application generator design realistic example video card device drivers 
ffl define dsl generating drivers 
restricted language allows program verifications 
ffl provide flexible implementation language generates efficient video drivers 
ffl illustrate benefits dsls software architecture 
rest organized follows 
section describes framework application generator design detail 
section presents domain video card drivers 
section describes level design machine graphics adaptor language 
section discusses results applying approach domain video drivers 
section summarizes results experiment identifies language framework 
framework designing implementing dsls previous approach application generator design 
approach consider implementation program family single generic program 
parameterization generic program corresponds variations program family represented micro language dsl 
words generic program interprets dsl programs know actions pertaining application family perform 
possible actions define machine adapted domain application family interpretation layer mapping constructs actions provides interface dsl programs machine 
performance overhead due genericity interpretation layer adaptation machine calls optimization partial evaluation 
approach basis general framework designing implementing dsls 
framework sketched described subsections 
details concerning impact reuse code expertise advantages application generators designs 
dsl design machine design language level analyzability constraints family domain analysis machine program dsl program implementation dsl program output output dsl program input input partial evaluation partial evaluation interpretation layer machine implementation terminology objects commonalities variations objects operations interpreter 
dsl design implementation framework 
analysis phase framework family analysis phase 
phase studies features members family variations members 
conducted methodology fast commonality analysis 
family analysis may rely domain analysis discovers commonalities domain 
analysis phase sets outputs lead design dsl machine 
machine design analysis phase identifies key objects domain program family basic operations objects 
operations define machine offers model computation underlies programs family 
operations included possible construct program family operations 
machines natural progression established reuse practices 
starting idea highly parameterized subroutines reuse library consider generic components operations provide level abstraction 
level abstraction provides insulation definition operation implementation 
context domain specific solution reasonable domain define collection related operations cooperate solve relevant problems domain 
enforcing explicit state opposed threading arguments machine instructions obtain machine model implemented efficiently 
advantages approach 
advantages opportunity implementations single machine 
machine implemented different languages 
benefit approach provides formal model computation reasoned established techniques machines 
able reason operations way enables verification certain properties dsl programs derive properties time complexities 
machine model provides right level decomposition increase reuse machine 
language design analysis phase outputs terminology commonalities variations family members 
information addition constraints level language analyzability design dsl 
idea dsl implemented terms machine 
key difference dsl machine dsl program describes application machine program describes application operates 
link dsl machine dsl viewed glue language composing machine operations interface machine 
interface provides superior abstraction dsl program designer second restricts applications expressed forming program family 
dsl generally designed express programs terms domain specific concepts 
usability analyzability semantics restricted possible depending requirements program family 
structuring implementation dsl implemented interpreter compiler target machine gpl 
straightforward approach implementing dsl build interpreter 
interpreter directly interprets language construct produce results compiler produces program executed produces results 
compiler approach introduces indirection difficult construct 
interpreter facilitates prototyping 
reasons propose approach interpreters 
framework implementation dsl expressed interpreter calls machine operations 
machine typically highly parameterized library 
just implementations machine staged framework provides possibility dsl languages machine 
machine express wide range applications domain dsl restricted subset useful multiple dsls different users 
example dsl manage database subset dsl able express queries 
interpreters easier construct efficient 
similarly genericity parameterized library introduces execution time overhead 
subsection approach obtaining efficient implementations partial evaluation 
efficiency partial evaluation identified sources inefficiency framework far dsl interpretation layer parameterization library implementing machine 
particular interpretation cited orders magnitude slower compiled code 
exist technique automatically remove kinds overhead partial evaluation 
matter fact partial evaluation proved effective mapping software architectures efficient implementations 
partial evaluation 
partial evaluation fully automatic program transformation specializes program particular context reducing execution time cases size :10.1.1.46.1067
specialization context defined assigning values subset program inputs 
specifically consider program argument data producing result may written split known vary subset input describes context unknown may form new program waits available calls original program produce result words known computations relying performed available 
form new program equivalent computations depending eliminated 
program called specialization respect known input known inputs representing context called static unknown inputs called dynamic 
partial evaluator program pe computes pe case study described article partial evaluator named tempo specializer 
tempo fully automatic partial evaluator programs 
tempo specialize programs compile time source source transformation run time 
users tempo specify inputs program entry point global variables static known dynamic unknown 
example partial evaluation 
shows example specializing simple version printf 
top part original code bottom part result specializing function input fmt equal 
fact example represents mini printf char fmt int val int fmt fmt putchar fmt switch fmt case val break case putchar break default abort error fmt mini printf fmt int val putchar putchar putchar val 
specialization fmt simple interpreter level framework 
fmt parameter program specifies data val parameter displayed 
putchar abort functions machine instructions print simple values 
mini printf function represents interpretation layer decides invoke machine instructions implement behavior specified fmt argument 
partial evaluation interpreters 
interpreter dsl takes arguments dsl program input data dsl program known dsl program partial evaluation applied automatically produce implementation specialized respect dsl program compiled dsl program 
resulting functionality equivalent compiler cost writing interpreter 
partial evaluation stand application generic program dsl program considered application generator 
ensuring efficiency 
mapping performed interpretation layer depends input program input program known input partial evaluator able eliminate entire interpretation layer 
shown interpretation layer specialized respect input program invocations machine instructions remain result machine program 
order ensure interpreter correctly structured eliminate interpretation layer rely program analysis performed partial evaluation binding time analysis 
actual partial evaluation process split phases binding time analysis actual specialization transformation 
binding time analysis dependencies propagated determine subexpression program depends known values evaluated 
result sub expression binding time static mean depends known inputs dynamic 
second phase performs specialization evaluating static expressions outputting specialized program 
code top depicts bind time annotated function 
underlined expressions dynamic binding times rest static binding times 
expected dynamic expressions mini printf calls machine instructions 
interpretation evaluated specialization time remains calls shown bottom 
rules define requirements structure guarantee elimination interpretation layer 

machine state interpretation layer may appear subprogram arguments 

machine implementation may contain interpreter state 
application tempo insure successful application partial evaluation separation machine interpreter having state represented global variables 
interpreter state specified static machine state specified dynamic 
visualization binding times produced tempo analyses lets user assess correct separation interpreter machine successful partial evaluation 
second step partial evaluation shown implementation machine specialized respect machine program 
reason second step machine operations highly parameterized reusable components 
may desirable eliminate genericity introduced parameterization 
parameters depend input program machine program contain instructions constant values arguments 
second step partial evaluation exploit values remove genericity instructions implementations 
specialization optimize inefficiencies introduced boundaries operations 
reason partial evaluation done twice obtain machine program analysis reason 
machine program needed single application partial evaluation interpreter yield results 
important difference genericity removed interpretation layer machine layer 
interpreter structure framework respected interpretation layer guaranteed removed 
guarantee machine layer removed 
video driver domain section introduces domain experiment video adaptor device drivers 
video adaptor video card hardware component computer system stores produces images display 
video cards consist frame buffer graphics controller 
frame buffer bank high speed memory store display data including currently visible image 
graphics controller consists main functionalities producing video signal display providing access frame buffer create display image 
graphics controllers provide similar sets functionalities changing display resolution 
adaptors provide similar functionalities programming interface different vendor vendor successive models adaptor 
true devices resolved device drivers 
device drivers generally consist library functions implement standard api fixed devices 
driver purpose translate standard api operations operations required specific device providing uniform interface operating system applications 
video device drivers provide main services operating system applications 
put graphics display different video modes 
video mode graphics mode defined horizontal vertical resolution number colors pixel screen refresh rates 
second service provided driver provide access hardware drawing operations 
example video cards provide line drawing hardware draws lines display faster rate possible software 
application approach applied approach described section family device drivers video adaptors 
considered existing set device drivers window server created project 
server generic window server written supporting different cards device driver architecture 
server contains drivers cards different vendors 
additionally driver supports different models 
structure indicates similarities models vendor implement generic program reasonable multiple vendors 
may due efficiency due lack methodology handle larger scales variation 
remainder section details application approach construction application generator video drivers different vendors window server 
discuss definition machine domain identified studying existing device drivers 
describe dsl generating video drivers related design issues 
machine machine video driver domain designed primarily studying implementation existing drivers 
machine iteratively refined development dsl 
identified patterns appeared existing drivers guide definition machine operations 
operation pattern 
patterns corresponds simple atomic operations machine 
forms pattern appears repeated fragments code differ data fragments perform treatment small number variations performed 
case fragments identified placed library defined macro 
fragments directly correspond machine operations 
example second case device drivers dominated occurrences code fragments read write data video card 
communication hardware devices handled small number different ways scheme chosen varies vendor vendor 
occurrences different schemes differing certain data address 
fragments captured single machine operation defined follows write port port number integer index integer indexed boolean pair boolean pci boolean instruction parameterized flags specify scheme indexed paired pci data scheme perform port number index 
combination operations pattern 
second type pattern recognized identified expressions combinations operations 
pattern characterized expressions combinations operations commonalities members family 
example device drivers sequences shifts logical expressions different driver 
commonalities expressions driver identify sufficient set operations construct instance 
selection operations depends existing samples understanding domain speculation domain 
code fragment shows example pattern existing drivers 
outb inb cc xf outb index misc index misc inb portion driver maps value appropriate registers order select clock 
driver may number reads writes shifts logic operations operations 
implement driver sequential composition small number machine operations 
control pattern 
pattern consists code fragments share common control structure contain code fragments matching combination operations pattern previously discussed 
example consider function device driver save restore set clock value video card 
function form video cards programmable clocks set different frequencies control video refresh rate 
bool int switch save clock value 
case clk reg save series os logic operations 
break restore saved clock value 
case clk reg restore second series os logic operations 
break set clock value 
default third series os logic operations 
series os logic operations example follow combination operations pattern constructed sequences machine operations 
pattern introduce higher order machine operations 
machine operations take sequences machine operations parameters 
parameters correspond contained fragments follow combination operations pattern 
example captured machine operation change clock save clk instructions restore clk instructions set clk instructions 
patterns existing examples able define machine express behavior particular device driver 
typically easy recognize important realize necessary certain details order see different patterns 
experiment examples written different people different styles programming took different approaches problem 
situation necessary determine functionality implemented common structure happened case 
gal language section graphics adaptor language gal video device driver specification 
order understand language comes important know essential variations video adaptors 
remainder section describes variations exist cards corresponding con structs gal capture 
complete example gal specification described appendix ports registers fields params video adaptor controlled setting certain parameters stored hardware registers card 
registers addresses 
single parameter may stored multiple registers certain bits registers may 
layout parameters register space major variation cards 
access registers provided various communication schemes 
mentioned previous section small number different schemes communicate hardware device program 
choice communication scheme second major variation cards 
define concepts describe notions communication register layout 
ports 
concept port define point communication 
example declaration port indexed defines port named uses indexed communication scheme address 
standard port video cards 
registers 
second concept provided register declaration defines access registers card defined ports 
example declaration register defines register accessed port index 
fields 
concept specified field declaration 
field declaration defines logical value stored bits registers mapping logical values actual stored values 
example declaration field control offset scaled defines field stored bits control register entire offset register 
additionally mapping clause scaled specifies value stored register th actual value 
mapping needed cards store value function field actual value 
standard field purpose horizontal resolution settings 
vertical resolution settings 
width virtual screen 
display start address 
clock selection 
standard param purpose frame buffer memory size 
address linear space 
size linear space 
number fixed clocks 
table 
predefined fields params 
parameters 
related field declaration parameter declaration definition constant value explicit specification read card configuration 
example case param majority gal specification consists definition fields standard values control video adaptors parameters determine certain features card size frame buffer 
table lists predefined field parameter names defined gal specifications 
clocks third major variation different adaptors clocks 
adaptors clock controls frequency data sent display 
frequency needs changed different resolutions approaches doing 
fixed number frequencies choose programmable chip generate frequencies changing parameters 
cards fixed number clocks vary number clocks frequencies provided cards programmable clock vary clock programmed range frequencies 
card fixed clocks specified defining parameter field 
constant defines number clocks available field defines field selects clock 
cards programmable clocks special construct defined specify program clock 
example clock defines clock named programmable equation right 
equation defines frequency generated programmable values defined fields 
desired clock frequency device driver uses specified equation find values approximate frequency closely possible 
identification fourth major variation observed video cards card identified 
information required systems dynamically configure card available time 
card identification uses small number predicates test card follows decision tree decide card supported driver 
define appropriate construct specifying type decision tree gal 
example identification construct 
identification writable segment true step chip id step chip id identification example identifies models cards graphics controller 
construct defines series steps numbered left 
step expression left arrow evaluated result compared list decisions right 
decision matched right identification fails indicates driver support card 
possible decisions identify card proceed step 
step example reads value chip id register result identifies proceeds step tests 
stepwise syntax reflects way diagnostic procedures commonly described manuals 
modes final major variation cards adaptors require flags set certain operating conditions 
referred modes operation gal device driver supports multiple cards vendor 
defined mode construct 
mode construct specify predicate sequence assignments fields enable disable corresponding mode operation video card 
example mode enable sequence control mode declaration defines mode indicates stored bit control order video mode horizontal resolution greater pixels 
implementation predicate tested changing video mode true sequence control executed 
addition user defined modes built modes 
built modes fixed predicates allow specification enabling disabling sequences 
example built mode true graphics modes user defined enabling sequence executed time mode changed 
run time variations addition variations exist cards variations single driver depend conditions known run time driver 
example video adaptors operate differently depending hardware bus utilized pci 
additionally wants build single device driver number models vendor variation models chosen run time 
gal cases construct describe type variation 
example statement define clocks different models cards 
cases trio trio field field control example specifies card identified run time trio trio card fixed clocks selected bits field 
cards sixteen clocks selected bits control field 
design gal section forces influenced design gal 
subsections describe main inputs design process definition variations family knowledge domain 
case domain knowledge came existing documentation domain engineers 
important issues level abstraction level restriction readability maintainability level abstraction level restriction particular importance dsls issues readability maintainability apply dsls defining variations main inputs design dsl description variations exist target set applications 
defined variations imply requirements dsl order distinguish instances program family 
case variations came study documentation existing video cards 
addition studying different cards inspection existing device drivers provided detailed source variations implementation level 
example small number ways communicate varied cards construct gal specifications allow selection correct communication scheme 
information extracted parameters machine operations 
domain knowledge main input dsl design process knowledge domain terms objects concepts terminology domain 
knowledge may come domain expert existing natural language specifications experiment 
important input leads user level dsl 
appropriate terminology provides dsl familiar people domain 
identified objects affected variations program family provide starting points declarative constructs 
experiment looked english specifications video cards identify concepts terminology domain 
clocks ports registers examples concepts domain identified 
identifying considered attributes objects related variations program family 
declarative statements defined specify values attributes varied 
objects identified experiment directly translated declarative constructs dsl 
additionally relationship objects translated relationship dsl 
example registers defined port definitions 
may suggest object oriented analysis dsl design 
level abstraction important goals guiding dsl provide high level abstraction 
particular wish intentionally focus raising level abstraction machine level 
fact may desirable include information dsl implementation may analyses documentation 
example abstraction machine developed video device drivers includes operations doing bitwise shifts logical operations 
types expressions appear gal intentionally introduced idea fields parameters eliminate low level procedural nature expressions 
eliminates common source errors 
preliminary design language language machine revised iterative way 
revision process satisfy correspondence constraint language machine feasible provide mapping language operations machine interpreter 
revision process level abstraction considered 
possible move functionality language machine making mapping essentially conscious decisions draw line interpreter machine 
primary consideration separation functionality specification 
machine specify applications family implemented 
interpreter hand specify design decisions required map design specification dsl program implementation machine operators 
level restriction major concern restricting language 
important consider types analyses performed specifications dsl order insure language restricted analyses feasible 
example gal language intentionally introduced loops insures device drivers proven terminate 
additionally perform analyses detect common errors specification providing explicit information difficult impossible extract general purpose languages 
example checking bits register belong field 
information retrieved general driver implemented language gpl principles addition design goals specific dsls principles general purpose language design apply dsl design 
general purpose languages help dsl design providing standard set constructs may restricted dsl recognized common construct 
hand cases construct introduced gal interesting example construct possibly applications dsls general predefined abstraction may conditionally definitions useful behavior totally described program abstractions explicitly invoked 
main purposes introducing dsl application generator embed knowledge implement certain operations domain application generator 
result declarative constructs dsls translated executable code application generator generally true general purpose languages 
declarations really imply operations need choices implied operations run time 
leads type dynamic selection multiple definitions provided cases statement 
main motivation utilizing dsl raise level abstraction common dsls declarative objects imply operations require dynamic selection 
suspect construct useful dsls general fact necessary dsls experimented 
suggests new constructs principles interesting unique dsls warrant study 
results section results applying framework domain video device drivers 
results terms advantages gained approach family drivers 
aspects approach led advantages 
aspect dsls application generators general second specific framework application generator design 
domain specific language gal language demonstrates advantages application generator dsl video device driver domain 
benefits include increased level abstraction possibility automated program analyses reuse productivity 
profile trio trio maximum resolution maximum virtual screen maximum ram ram size clock range mhz resolution limited clock max 
refresh hz 

extract generated card profile 
significant examples benefit higher level abstraction 
discussed section ports registers fields low level bitwise operations 
eliminates common errors readable easier write 
second example abstraction implementation 
window server considered framework device driver provides additional functions 
framework device driver needs implemented certain way order compatible server requires considerable knowledge framework 
application generator knowledge framework compatibility issues coded application generator hidden designer 
gal demonstrates automatic analyses performed dsl possible feasible general purpose language 
example analyses performed gal specifications include detecting unused definitions checking exhaustive identification video cards identifying overlap field definitions checking minimum requirements predefined fields generating card profile summary card characteristics analyses feasible existing device drivers implemented gal analyses feasible easy implement 
example analyses gal implemented single day 
particularly interesting analysis generates card profile 
generating card profile analysis gal specification produces summary video modes supported generated device driver 
shows extract profile generated specification listed appendix profile generated subset cards specification profile 
shows profile trio trio 
summary compared vendor specifications find mistakes field definitions provides automatic documentation specification 
application generator provides reuse capturing design knowledge 
domain video device drivers large benefits reuse large growing number video cards potentially generated single application generator 
amount productivity gained depends ease building application generator consequently approach design 
discuss productivity measurements section respect framework 
framework addition advantages obtained dsl approach advantages demonstrated gal due framework generator design 
experiment shows framework achieves automatic predictable generation efficient video drivers highlevel reuse 
gal demonstrates benefits level approach analyses multiple implementations practical value 
reuse productivity machine window device drivers consists small procedures totaling lines 
implementing machine roughly difficulty level implementing single driver directly code similar 
existing device driver implementations machine code reused drivers 
table summarizes number lines code gal system comparison writing drivers interpreter gal consists lines code automatically generated parser concerns building environment look routines declarations 
system consists lines code 
compare size existing hand coded drivers averaged lines 
effort required build interpreter building device driver estimate application generator requires little times effort individual driver assuming code size proportional effort 
version window server existing drivers consisted lines code 
gal specifications written factor smaller corresponding existing driver estimate drivers generated lines gal specifications plus lines generator totaling lines 
estimated productivity gain factor 
average lines total lines driver drivers gal generator gal driver estimated gal generator plus driver driver table 
lines code summary 
practice higher gain gal specifications easier write corresponding driver 
addition having interpreter gal provides prototyping environment 
efficiency consider measures efficiency object code size execution speed 
designing interpreter easier designing compiler significant losses speed size compared compilation 
terms speed interpreters typically times slower compiled programs terms size gal interpreter times larger typical driver object code size 
benefit partial evaluation regain loss efficiency 
tempo partial evaluator program specializer translate gal specifications machine programs produce efficient implementation machine programs 
order size comparison compared object file sizes generated drivers hand coded drivers 
average generated driver larger hand coded 
main difference lead increase code size hand coded drivers loops access block contiguous registers 
gal recognize registers contiguous 
second difference hand coded drivers careful saving restoring registers 
speed device driver functions insignificant called configuration 
picked device driver functions drawing lines rectangles hardware benchmark performance 
interpreter level framework guaranteed eliminated see section concerned machine layer 
comparison prepared versions window server trio video card pentium pro 
table shows timing results servers 
xaa server window server provided included hand coded de server lines percent xaa am pe server rectangles percent xaa am pe table 
performance results 
vice driver 
am server device driver directly uses machine 
pe server machine partial evaluation 
table shows performance servers lines filled rectangles size measured standard benchmark utility 
table includes percentage xaa baseline 
table indicates loss performance machine 
loss performance contributed error checking interpretation function call data copying overhead 
data copying due need communicate machine operations 
write operation includes error checking insure previous operations fail resulting data written card 
particularly important card damaged 
operations require interpretation parameters determine type perform addresses 
directly machine incurs performance loss results pe server show program transformations performed partial evaluation able recapture performance loss 
majority error checking eliminated tempo operations preceding write operations fail error conditions need checked 
parameters interpreted select type perform address computation known eliminated tempo 
tempo performs inlining copy elimination eliminates function call data copying overhead 
analyses framework application generator design contributes ways program analyses 
generation process predictable analyzed separation machine interpreter allows analysis machine level 
small size ensure measurements dominated hardware operations independent driver 
example gal machine includes operations allocate deallocate temporary storage operations temporary storage 
long operations temporary storage set allocate deallocate operations insure uninitialized pointer dereferences 
analyses partial evaluation capable producing specification programs possibly generated partial evaluation process 
obtain formal description possible machine programs generated check operations generated correct order 
gal system prove uninitialized pointer dereferences occur 
description generation process may analyzed performance properties example 
separation machine dsl provides intermediate level analyses performed allow analysis run time 
fact separation corresponds standard technique program specification factors verification process parts 
example analysis run time may wish check device access video driver safe access disk device 
done run time depends devices run time 
case accept video drivers machine form analyze machine run time 
partial evaluation performed run time efficiency 
kind analysis feasible machine code java bytecodes due general purpose nature 
proof carrying code burden proof put programmer proof sent code verified verification easier proof easier done run time 
multiple implementations video device driver family demonstrates useful application having multiple implementations interpreters machines 
domain desirable machines architectures interpreters different operating systems 
example shows situation implementations interpreters microsoft windows linux implementations machine dec alpha intel computers 
situation equivalent application generators interpreter machine pairs gal specification generate different device drivers 
implemented intel path 
prototyping benefited having second implementation machine gal program interpreter interpreter windows machine program intel machine alpha machine device driver 
multiple implementations 
simulates machine operations 
simulation records values written card real machine 
important feature video adaptors damaged writing inappropriate values card 
domain specific languages hold promise delivering high payoffs terms software reuse automatic program analysis software engineering 
gal example complete dsl realistic program family video device drivers 
demonstrated benefits dsls showing gal raises level abstraction device driver specifications identifying analyses performed gal specifications domain specific 
contribution validate framework application generator design applying program family provide implementation gal 
implementation partial evaluation provides complete interpreter prototyping device drivers automatically generates efficient device drivers 
efficiency demonstrated results comparing hand coded drivers automatically generated device drivers 
generated drivers roughly third larger hand code drivers perform equivalently terms speed 
additionally give measures expected reuse benefits gal specifications roughly factor smaller driver hand coded techniques applied active networks domain 
developed plan dsl active networks 
techniques run time specialization successfully specialized plan programs run time achieve effect just time compiler jit 
experimental results show programs produced run time specializer incur overhead system performance comparison hand written code 
furthermore comparison java mobile code approach specialized program twice fast equivalent java program compiled optimizing line byte code compiler 
framework significantly reduces development time application generators done direction 
specifically approach benefit generator specific reuse method allow interpreters machines constructed reused composable parts 
additionally nature dsls extended frequently adapt new program requirements ease extension needs considered language components 
implementation static analyses indicates methods quickly constructing static analyses investigated composable analyses 
important dsls static analyses major motivation approach 
application approach program family existing family members 
validate approach important study application program family pre existing 
case machine dsl developed results domain analysis commonality analysis fast 
arnold van deursen res 
algebraic specification language describing financial products 
ieee workshop formal methods application software engineering pages april 
bentley 
programming pearls little languages 
comm 
acm pages august 
berg moher 
formal methods program verification specification 
prentice hall englewood cliffs nj 
bergstra klint 
coordination architecture 
coordination models proceedings international conference italy number lncs pages 

laboratory application languages 
bendix editors nordic workshop programming environment research aalborg 
technical report aalborg university may 
grady booch 
software components ada 
benjamin cummings 
bosch editors 
workshop compiler techniques application domain languages extensible language models link oping 
technical report lund university april 
satish chandra james larus 
experience language writing coherence protocols 
proceedings st usenix conference domainspecific languages santa barbara california october 
cleaveland 
building application generators 
ieee software july 
consel hornof lawall marlet muller thibault volanschi 
tempo specializing systems applications 
acm computing surveys symposium partial evaluation 
appear 
consel hornof noel volanschi 
uniform approach compile time run time specialization 
danvy pages 
consel noel 
general approach run time specialization application conference record rd acm symposium principles programming languages pages st petersburg beach fl usa january 
danvy gluck thiemann editors 
partial evaluation international seminar dagstuhl castle number lncs february 
conal elliott 
modeling interactive multimedia animation embedded language 
proceedings st usenix conference domainspecific languages santa barbara california october 
gupta jagadeesan koutsofios weiss 
generating audits fast way 
proceedings third ieee symposium requirements engineering pages january 
jones 
partial evaluation 
acm computing surveys september 
jones 
writing interpreter specialisation 
danvy pages 
jones gomard sestoft 
partial evaluation automatic program generation 
international series computer science 
prentice hall englewood cliffs nj june 
samuel kamin david 
special purpose language picture drawing 
proceedings st usenix conference domain specific languages santa barbara california october 
kieburtz mckinney bell hook lewis oliva sheard smith walton 
software engineering experiment software component generation 
proceedings th ieee international conference software engineering icse pages 
david ladd christopher 
application languages software production 
usenix symposium high level languages new mexico october 
marlet thibault consel 
mapping software architectures efficient implementations partial evaluation 
conference automated software engineering pages lake tahoe nevada november 
ieee computer society 
mccain 
reusable software component construction product oriented paradigm 
proceedings th aiaa acm nasa ieee computers aerospace conference long beach california october 
necula 
proof carrying code 
conference record th symposium principles programming languages pages paris france january 
acm press 
james neighbors 
software construction components 
phd thesis university california irvine 
plotkin 
structural approach operational semantics 
university aarhus aarhus denmark 
prieto 
domain analysis 
software engineering notes april 
pu black cowan walpole consel 
operating system specialization 

romer lee voelker wolman wong baer bershad levy 
structure performance interpreters 
proceedings th international conference architectural support programming languages operating systems pages october 
scott thibault charles consel 
framework application generator design 
proceedings symposium software reusability boston ma usa may 
scott thibault charles consel gilles muller 
safe efficient active network programming 
th ieee symposium reliable distributed systems west lafayette indiana october 
scott thibault jerome gilles muller 
adapting distributed applications extensible networks 
th ieee conference distributed computing systems austin texas may 
van deursen klint 
little languages little maintenance 

st acm sigplan workshop domain specific languages paris france january 
computer science technical report university illinois urbana champaign 
bruce weide william ogden 
recasting algorithms reuse 
ieee software september 
project 
www org 
complete gal example appendix gives complete listing gal specification models video adaptors 
appendix explain constructs included main text 
various registers video cards typically accessed addressing scheme sequential procedure followed access registers 
serial construct specify kind procedure see listing 
construct consists list sequences actions performed ports access registers 
multiple ports may accessed procedure example 
sequence consists port operation write read write read sequence values writes registers names reads read writes 
actions sequence performed port left right sequence 
mode read read write write right sequence indicates sequence applies reading registers writing registers 
serial construct example defines registers pll pll 
order write values registers construct executed follows 
write misc write value pll seq write value pll seq write seq 
specification includes example derived field discussed 
field value derived standard fields 
example derived field 
value set graphics mode set value horizontal resolution 
declaration indicates clause 
card fixed programmable clocks trio cards 
indicates clocks fixed programmable 
example indicates clock fixed clock available na clock programmable clock 
parameters related clocks specify minimum maximum values generated clock values valid 
operating mode access lock unlock registers card 
gal listing list cards models supported driver 
trio trio define ports 
port indexed port seq indexed port misc cc define registers 
register misc register seq register offset register register register memory register state register lock register lock register register misc register control register control register register register control serial registers see appendix 
serial misc seq pll seq pll seq define predefined fields horizontal resolution fields 
field std field std field std field std vertical resolution fields 
field std field std field std field std virtual screen fields 
field control offset scaled cases trio trio field control memory std field control memory std field control std field memory std define derived fields see appendix 
field offset scaled special flags set color graphics modes 
enable sequence misc define standard parameters 
param false param true cases param state mapped param state mapped define clocks 
cases trio trio param field param param field pll offset range field pll offset range field pll mapped clock fixed fixed na param field control identification procedure 
identification step xa xb xc xd xe step trio trio xb register locks chips 
enable access sequence lock disable access sequence lock 
