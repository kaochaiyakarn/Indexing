pure versus impure lisp nicholas pippenger nicholas cs ubc ca department computer science university british columbia vancouver british columbia canada aspect purity versus impurity address involves absence versus presence mutation primitives lisp set car 
set cdr 
scheme change state pairs creating new pairs 
known cyclic list structures created impure programs pure ones 
sense impure lisp powerful pure lisp 
inputs outputs programs restricted sequences atomic symbols difference computability disappears 
shall show temporal sequence input output operations maintained computations online difference complexity remains pure program impure program steps log steps sufficient cases omega gamma log steps necessary 
research partially supported nserc operating 

programming language lisp see mccarthy mccarthy inspired calculus see church basic features frank imitations aspects calculus essential differences rules order evaluation 
way lisp significant programming language allow computation partial recursive functions purely applicative functional programs side effects 
feature lisp goes applicative realm inclusion primitives usually called mutation 
primitive semantics rooted von neumann architecture machines lisp implemented calculus 
main primitives mutation lisp mutate components existing pair contrast cons creates new pair 
shall refer lisp mutation primitives pure impure lisp respectively 
usage fairly common admitted terms features programming languages features happen fit conveniently writer conceptual framework 
goal assess extent mutation primitives add essential language extent simulated eliminated favor purely applicative primitives language 
case question formulated ways immediate goal describe formulation mind explain chosen preference 
trivial observation 
pairs created mutated components previously existing objects arrows box arrow diagrams point backward time diagrams acyclic 
follows allow outputs programs data structures represented diagrams add essential possible creation structures diagrams contain cycles 
answer completely satisfying assumes want programs produce particular representation answer representation answer power pure lisp 
redirect attention representations answers answers led observation inputs outputs programs words finite alphabet alternatively natural numbers pure impure lisp compute partial recursive functions equivalent power 
answer completely satisfying describes computations performed ignores issues efficiency computations 
redirect attention computability theory complexity theory obtain crisp formulation problem 
consider computational problems input word finite alphabet say sequence boolean values output answer boolean value 
impure lisp program solving problem transformed pure lisp program input output behavior way number primitives executed pure program exceeds number performed impure program constant factor 
unfortunately unable answer question 
putting additional restrictions computations able delineate precisely additional computational power conferred impure primitives 
shall say computation symbolic input output consist sequences atomic symbols 
symbols incorporated components pairs distinguished pairs predicate atom operation performed place predicate eq tests equality atomic symbols 
crucial property atomic symbols unlimited supply distinct symbols single symbol carry unbounded number bits information 
fact equality predicate defined symbols inefficient convert information carry form 
atomic symbols natural part lisp world view insisting treated artificial allowing primitives explode dialects lisp allow treated composites 
shall say computation line input output comprise unbounded sequence symbols th output produced computation st input received 
notion refers computation convention necessary reconcile customary view lisp programs functions finitely arguments single value 
shall regard line computations performed non terminating programs arguments receive inputs primitive read operation produce outputs primitive write operation 
new primitives side effects course borne mind purity refers absence operations absence side effects 
line computation part classical lisp world view natural component interactive systems 
notions state main result 
theorem symbolic line computation performed impure lisp program way primitive operations needed produce outputs pure lisp program perform omega gamma log primitive operations inputs sequences infinitely values produce outputs 
omega gamma delta represents function bounded positive constant multiple 
result best possible constant factors shown second result 
theorem symbolic line computation performed impure lisp program way primitive operations needed produce outputs performed pure lisp program performs gamma log delta primitive operations inputs sequences values produce outputs 
objection efficiency mutation known obvious warrant proof offer argument 
known stack discipline easily implemented pure lisp obvious implementation queue relies mutation add items tail queue 
fischer meyer rosenberg shown ingenious construction queue dequeue items added removed implemented pure lisp primitive lisp operations performed queue dequeue operation 
face highly non obvious implementation claim proof ingenious non obvious implementation full interpreter impure lisp pure lisp primitive pure lisp operations performed primitive impure lisp operation 
rediscovering special case fischer meyer rosenberg result hood melville conclude interesting exhibit problem lower bound pure lisp worse implementation 

discussion question address implicit lisp literature explicit formulation due ben galil mention cyclic acyclic distinction go ask complexity simulation 
input values certain restricted operations applied established comparison programming languages introduced paterson hewitt 
comparison complexity computability due pippenger 
special case atomic symbols sense considered tarjan 
restriction line computation established literature automata theory see 
say words models embody powers pure impure lisp 
models pure impure lisp machines 
machine furnished built program takes form flowchart recursion implemented explicit manipulation pushdown stack 
specifically consider programs manipulate values may atomic symbols pairs fixed number registers registers contain mutable values pure case 
primitive operations predicates atom eq appear decision flowcharts operations read write cons car cdr take arguments deliver values registers impure case mutation operations 
flowchart models allows ignore questions variable binding scope primitives pure model allow common scoping conventions simulated efficiently 
assuming particular program including attendant subprograms involves just fixed number variable names current bindings kept fixed number registers 
consideration mechanisms eval allow symbols input variable names bound values 
flowchart models allow ignore questions control structures mentioned recursion simulated manipulation pushdown stack control structures explicit current continuations similarly simulated 
allowed constants nil incorporated programs uses quote 
justification follows 
program involve fixed number constants compared eq atomic symbols 
constants needed may assume input sequence begins presenting agreed order echoed back outputs 
program test fact pairwise distinct proceed original computation substitute agreed dummy computation echoing back inputs outputs 
overlook presence atomic symbols impure model similar storage modification machines introduced turn model kolmogorov precursor 

upper bound reformulate theorem terms machines follows 
theorem line symbolic impure lisp machine simulated pure lisp machine way outputs produced steps produced log steps 
theorem established construction simulation detail 
obtained modification arguments ben galil just easy describe construction scratch 
key idea represent state store impure machine balanced tree 
construction new pairs cons accomplished allocating new paths tree allocator issues new paths order increasing length tree kept balanced 
fetches store implicit car cdr operations updates implicit operations performed paths tree root nodes containing relevant information case rebuilding modified version path backtracking root 
observe constant implicit notation independent machine path copying technique just described applied tarjan implementation persistent data structures old versions data structure copied updated independently 
benefits pure programming style sense data structures automatically persistent 

lower bound section shall computation separates power pure impure lisp machines 
proof producing outputs accomplished operations impure lisp easy 
proof pure lisp requires omega gamma log operations shall just sketch heart result 
superficial level proof information theoretic counting argument analogous example show omega gamma log comparisons needed sort items 
obvious argument distinguish creation mutation 
key argument bring situation certain information measured counting argument retrieved impure operations rate omega gamma bits operation pure operations rate bits operation 
consider set records comprises atomic symbol pointers link records linear chains 
chain call chain link records order gamma gamma 
delta delta delta gamma gamma nil second chain call chain link records order gamma gamma 
delta delta delta gamma gamma nil permutation sg 
shall describe computational problem describing impure lisp machine solves 
problem consists prolog comprising steps followed unbounded sequence phases comprising steps 
prolog takes place follows 
checking received distinct input symbols boolean values impure machine reads tally notation gamma follows false constructs records linked chain 
chain links atomic symbols left unspecified 
reads tally notation fills chain links 
atomic symbols left unspecified 
prolog finishes reading additional inputs bring number steps 
done just number steps prolog independent permutation remainder computation divided phases steps 
steps phase reads atomic symbols stores records order chain 
steps phase writes atomic symbols records order chain 
specified symbols writes prolog half phase shall stipulate symbol read step 
output depend symbols reads second half phase 
clear perform computation primitive operations read write operation 
shall restrict attention point input sequences atomic symbols read written phases distinct 
allow ascribe symbol produced write operation phase defined read operation earlier phase 
observe value just 
possible permutations described prolog 
remains show pure lisp machine requires omega gamma log primitive operations phase choices say gamma choices performs just operations prolog just operations phase obtain theorem considering phases produce outputs operations require omega gamma log operations gamma choices consider interval steps 
say set input sequences coherent pure lisp machine processing th input th output test operations atom eq operations outcome 
operation restricted interval operations set coherent inputs corresponds straight line program fixed sequence primitive operations car cdr cons read write performed 
say input sequence outputs equal inputs lemma coherent set inputs pure lisp machine suppose inputs exists map fa bg fa bg input sequence produces output fa bg 
sketch proof fa bg start write operation produces trace back computation read operation received corresponding input input sequence defined value fa bg show value input sequences trace back way 
write operation produces takes output value register 
trace back operation put value register 
operation read operation done 
cons car cdr operation 
case trace back operation put relevant argument register 
continue reach appropriate read operation 
process tracing back terminate read operation disallowed quote introduce constants 
pure lisp machine pairs involved process constructed interval starting output interval pointers point backward time input interval 
follows operations involved process take place interval executes straight line program 
consequently input reached output input sequence shown 
worth observing lemma breaks impure lisp machines reasons value produced car cdr operation trace back cons pointers necessarily point backward time conclude relevant operations take place interval 
suppose phase corresponding interval performs test operations gamma choices outcomes operations partition set gamma input sequences coherent classes 
phase writes symbols read phase classes lemma outputs produced specified maps 
behavior impure lisp machine calls gamma different maps gamma different permutations gamma logarithms omega gamma log 
phases needs omega gamma log comparisons easy permutations easy means fewer comparisons needed gamma easy permutations phases phases ther gamma permutations easy phase 
half permutations easy phase 
permutation easy phase 
see juncture roles played special restrictions 
symbolic inputs outputs allow step phase involve omega gamma bits information distinct symbols phase allowing impure machine process bits operations 
lower bound break required input sequence finite infinite set symbols upper bound break charged logarithmically pointer manipulation operations reflecting implementation finite set symbols 
line assumption allows basic arguments repeated disjoint phases assumption pure machine read inputs phases writing outputs phases operations 

shown mutation reduce complexity computations computations required performed line inputs outputs may sequences atomic values sequences symbols drawn finite alphabet 
shown reduction logarithmic factor exceed logarithmic factor 
naturally interest lift special assumptions 
conjecture reduction complexity occur line computations computations inputs outputs words finite alphabet 
result far reach currently available methods computational complexity theory 

ben galil pointers versus addresses acm 
church calculi lambda conversion princeton university press princeton nj 
fischer meyer rosenberg real time simulation tape units acm 
line turing machine computations ieee trans 
electron 
computers 
hood melville real time queue operations pure lisp info 
proc 
lett 
kolmogorov definition algorithm ams translations 
mccarthy recursive functions symbolic expressions computation machine comm 
acm 
mccarthy list programmer manual mit press cambridge 
ma 
paterson hewitt comparative project mac conf 
concurrent systems parallel computation 
pippenger comparative auxiliary acm symp 
theory computing 
tarjan planar point location persistent search trees comm 
acm 
storage modification machines siam comput 
tarjan class algorithms require nonlinear time maintain disjoint sets comput 
sys 
sci 

