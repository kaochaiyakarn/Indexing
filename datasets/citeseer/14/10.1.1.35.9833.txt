perfect supercompilation jens peter morten heine department computer science university copenhagen diku dk copenhagen denmark mail diku dk 
extend positive supercompilation handle negative positive information 
done instrumenting underlying unfold rules small rewrite system handles constraints terms ensuring perfect information propagation 
illustrate transforming naively specialised string matcher optimal 
algorithm guaranteed terminate means generalisation steps 
turchin supercompiler program transformer functional programs performs optimisations partial evaluation deforestation 
positive supercompilation variant turchin supercompiler introduced attempt study explain essentials turchin supercompiler achieves effects relation transformers 
particular language programs transformed positive supercompilation typical order functional language usually studied deforestation different language usually adopted connection turchin supercompiler 
sake simplicity positive supercompiler designed maintain positive information transformer reaches conditional information assumed hold taken account transforming performing substitution fx 
contrast negative information hold discarded transforming substitution represent information 
turchin supercompiler negative information maintained constraint transforming consequently turchin supercompiler perform optimisations positive supercompilation 
algorithm call perfect supercompilation term essentially adopted similar turchin supercompiler 
perfect supercompiler arises extending positive supercompiler take negative information account 
retain typical order language language programs transformed adopt style presentation positive supercompilation 
main contribution extension develop techniques manipulate constraints general form 
running implementations turchin supercompiler techniques extent techniques literature turchin supercompiler far know 
exception gluck handles constraints simpler form instance algorithm normalising constraints counterpart technique 
main contribution generalise technique ensuring positive supercompilation terminates perfect supercompiler prove perfect supercompilation terminates programs far aware version turchin supercompiler maintaining negative information general guaranteed terminate 
remainder organised follows 
sect 
classical application positive supercompilation transformers general generation efficient specialised string pattern matcher general matcher known pattern 
known positive supercompilation generates specialised matchers containing redundant tests 
show redundant tests eliminated uses perfect supercompilation 
sect 
overview perfect supercompilation sect 
overview proof perfect supercompilation terminates 
sect 
conclude compare related 
knuth morris pratt example consider programs written order functional language pattern matching conditionals 
simplicity patternmatching functions allowed match non nested patterns parameter conditionals test equality values means operator 
convention function names written slanted variables written italics constructors written small caps 
standard shorthand notation empty list list constructed tail respectively usual notation hn 
consider general matcher program takes pattern string input returns true iff pattern occurs substring string 
match ss op os true pp ss op os pp ss op os pp op os false pp ss op os pp ss op os op os op ss op ss op ss termination guaranteed guarantee perfect transformation underlying unfolding scheme perfect sense information propagated 
example compares variables variables method manipulate general equalities inequalities 
consider naively specialised matcher match aab matches fixed pattern string calling match match aab match evaluation proceeds comparing component second third 
point comparison fails process restarted tail strategy optimal 
suppose matching occurrences pattern occurrences string pattern fails match string 
process restarted string tail known comparisons succeed 
performing tests outcome known skip occurrences original string proceed directly compare pattern fourth element original string 
done kmp specialised matcher match aab aab aab false aab ss ab ss aab ss ab false ab ss ss aab ss false ss true ss aab ss finding third symbol string program checks third symbol string continues immediately comparing symbol string pattern calling avoiding repeated comparisons 
get program application positive supercompilation naively specialised matcher 
result application depicted graphically process tree fig 
explained nodes emphasised 
root process tree labelled initial term transformed naively specialised matcher 
children node ff process tree represent possible unfoldings term ff edges labelled assumptions free variables 
arc process tree seen step transformation 
time tree viewed new program arcs labels represent tests input leaves represent final results recursive calls 
informally program extracted process tree creating new function definition node ff labelled outgoing edges new function parameters set variables ff right hand side match ss 
false ss oo ss ss xy ss ss ss ss ss ss ss ss 
false ss ss ss ss ss oo ss ss xy ss ss ss ss ss ss ss xy ss ss ss 
false ss ss ss ss ss oo ss xy ss ss ss ss ss 
true ss ss oo ss ss ss ss ss ss ss ss ss xy ss ss ss fig 

driving naively specialised matcher 
children node ff represent possible unfoldings term ff edges labelled assumptions 
created children ff 
fact program corresponding tree fig 
aab false aab ss ab ss aab ss ab false ab ss ss ab ss false ss true ss aab ss aab ss ab ss ab ss aab ss ss ss ab ss term aab program efficient match original program 
fact desired kmp specialised matcher redundant test ab redundant argument aab 
reason redundant test positive supercompilation ignores negative information proceeding false branch conditional original program ss ss ss information holds forgotten 
test repeated subsequent conditional ss ss ss contrast perfect supercompilation information maintained constraint decide conditional possible outcome 
tree continue node resulting program skip superfluous test recursive call back branching node exactly kmp specialised matcher 
overview perfect supercompilation section give informal account supercompilation algorithm 
proofs examples depth treatment algorithm see :10.1.1.35.9833
despite intended informality need definitions 
range variables set range fixed arity constructor function pattern matching function names finite sets respectively 
range patterns form xn range terms 
var denote variables range substitutions written fx xn application substitutions defined usual written prefix 
write denote function defined program consideration 
perfect supercompilation program carried phases 
model subject program constructed form constrained process tree 
second new program extracted constrained process tree 
constrained process tree similar tree fig 
node labelled term set constraints 
distinguish constrained unconstrained process trees refer part label node ff simply saying node ff contains 
root process tree labelled initial term transformed empty constraint system 
process tree developed repeated unfoldings terms leaves 
rules govern unfolding terms constructed extending small step semantics language rules speculatively execute tests depend variables 
possible outcome test child added information test conducted appended current constraint system 
extended constraint system passed child resulted speculative execution 
constraint systems subset ones defined restricted kinds conjunctive normal forms formulae form terms consist variables constructors constraint systems prune branches process tree speculative execution test results constraint system satisfied produce new child 
instance consider conditional blindly unfolding term result node children ss ss ss ssg ss ss ss inherited constraint system conditional left child produced resulting constraint system satisfiable 
precisely constraint system satisfiable possible assign values variables system constraints satisfied 
constraint system satisfiable iff exists substitution equation syntactically identical likewise disequation syntactically different decide satisfiability constraint system apply set rewrite rules bring normal form 
core rewrite rules modified version ones shown fig 

additional control rules ensure non deterministic 

ffl 
ffl ffl 
ffl ffl 
ffl 
bn am 
bn am 
bn 
delta delta delta bn bn 
delta delta delta bn 
var 
var ffl 
ag var ffl 
ag var fig 

rewrite system normalisation constraint systems 
represents unsatisfiable element represents trivially satisfiable element ffl stands arbitrary part formula 
exhaustive application rewrite rules constraint system terminates results constraint system normal form 
constraint system normal form 
false 
true form type information variables constraint system constraint system normal form satisfiable exactly different 
known variable assume finite set values necessary verify exists value assigned satisfies constraint system 
instance consider constraint system variables boolean type 
system normal form appears satisfiable possible assign values false true variables system satisfiable 
constraint system normal form necessary systematically try possible combinations value assignments variables known types 
done instantiating variables possibly call rewrite steps take normal form finitely valued variables left 
different satisfiable :10.1.1.35.9833
show constraint systems guide construction process tree 
term process tree associated constraint system denoted ht ri 
complete set unfold rules fig 

rules correspond normal evaluation respect semantics language rules perform speculative execution term information associated constraint system 
rule instantiates free variable pattern ym taken function definition fresh variables 
achieved appending equation ym current constraint system 
new constraint system satisfiable function application unfolded 
manner rules handle conditional expressions general equations disequations appended constraint system 
rule separates resulting constraint system positive negative information normalising positive information form regarded substitution separated normalised denote separation 
positive information propagated context applying substitution term unfolding branch stopped leaf branch value ancestor node covers explained possible executions arise leaf 
case constitutes fold operation eventually result recursive call derived program 
say node covers node terms nodes equal renaming variables constraint system leaf restrictive ancestor 
intuitively speaking conditions met real computation performed leaf performed ancestor safely produce recursive call derived program 
algorithm gives safe approximation question restrictive :10.1.1.35.9833:10.1.1.35.9833
look process tree fig 
see parts tree created deterministic unfolding consist single path 
sign means path represents local computations carried program particular state regardless uninstantiated variables 
precomputed intermediate transitions done partial evaluation omit intermediate steps simply remember result 
creation process tree manner just described terminate infinite process trees produced 
keep process trees finite ensure infinite branches produced 
turns free variables intended semantics language evaluation weak head normal form comparison conditionals terms compared fully evaluated comparison carried 
simplicity unfolding rules call name unfortunately give rise duplication computation 
free variables positive information re injected context re injection neatly irrelevant information variables longer 
ht ri 
ht xn hf tn ri 
hfx xn ri xm xm xn hg tm tm tn ri 
hfx xn ri xn satisfiable hg tn ri 
hfx xn xn ht ri 
ht hg tn ri 
hg tn satisfiable hif ri 
ht satisfiable hif ri 
ht ht ri ht hif ri 
hif ht ri ht hif ri 
hif ht ri ht ht ri 
ht ht ri ht ht ri ht hc am gamma tm tn ri hc am gamma tm tn ht ri ht ht ri ht ht ri fig 

unfold rules perfect information propagation 
infinite branch term embeds ancestor known kruskal tree theorem 
homeomorphic embedding relation smallest relation terms symbol ng ng term leaf embeds term ancestor danger producing infinite branch 
situation split means generalisation step 
definition generalisation 

term instance term denoted exists substitution 
generalisation terms term 
specific generalisation msg terms generalisation generalisation 
exists exactly msg modulo renaming 
ut generalisation step process tree calculates msg terms nodes ff ff msg divide nodes subterms unfolded independently ht ri ht xn un ri uu hu ri hun ri hs ri msg xn ung 
nodes split depends similar nodes precise 
terms merely notational convenience unrolled derived program 
sketch full supercompilation algorithm 
ensure termination time provide reasonable specialisation partition nodes process tree categories lines 
nodes containing terms 
global nodes 
local nodes 
global nodes represent speculative execution final results derived program 
local nodes nodes global contain terms 
example fig 
set local nodes indicated dotted frames nodes containing terms need generalisation particular example 
partitioning nodes control unfolding 
definition relevant ancestor 
process tree set relevant ancestors ff node ff defined ff ff contains term ancestors global ff global local ancestors ff local local ancestors ff ancestors local common ancestor global 
ut example consider process tree fig 
local node ss ss near bottom local ancestors ancestors including node ss 
definition drive 
process tree ff node 
ff denotes label node ff 

denotes new tree identical subtree rooted ff replaced 
ffl denotes root node tree 

fht ht rn ig fht ri ff ht rig drive ff ff ht ht rn ut definition finished 
leaf ff process tree finished conditions satisfied 
ff hc constructor 
ff hx variable 
ancestor ff ff ff ff global nodes ff ht ri ff ht renaming restrictive tree said finished leaves finished 
ut definitions sketch supercompilation algorithm input term consist single node labelled ht finished ff ht ri unfinished leaf ff ht ff drive ff ff ht ff restrictive ht ig rig ig output transformed program extracted process tree examination global nodes collecting set free variables labels edges 
overview termination proof language independent framework proving termination program transformers sufficient conditions established program transformers terminate 
section give rough sketch framework prove termination algorithm 
program transformer map trees trees single step transformation carried application transformer 
termination amounts certain form convergence sequences trees obtained repeatedly applying transformer 
transformer fit framework sufficient ensure 
transformer converges sense transformation step difference consecutive trees lessens 
precisely sequence trees produced transformation depth point consecutive trees identical depth 
transformer maintains invariant finite trees produced 
induction depth trees produced proved fact algorithm 
adds new leaves tree trivially consecutive trees identical increasing depth 
generalises node replaces subtree node containing term node containing empty constraint system 
generalisation occurs terms terms contain non empty constraint systems respectively node generalised twice 
ensured proces tree 
path consists terms finite term subsets children proper size nodes path strictly decreases 

nodes allowed embed ancestors finished nodes leaves 
related algorithm supercompiler order functional language maintains positive negative information 
algorithm guaranteed terminate programs strong pass socalled kmp test 
turchin briefly describes latest version supercompiler utilises contraction restriction patterns driving graphs underlying representation programs 
resolution clashes assignments contractions restrictions achieve propagation negative information extent provides power equivalent exact relationship unclear 
field partial evaluation consel danvy described negative information incorporated naively specialised matcher achieving effects similar described 
achieved non trivial rewrite subject program partial evaluation applied rendering full automation difficult 
case generalised partial computation takano transformation technique exceeds power turchin supercompiler perfect supercompilation 
extra power stems unspecified theorem prover needs fed properties primitive functions language axioms data structures employed program consideration theorem prover replaced congruence closure algorithm allows automatic generation kmp matcher naively specialised algorithm properties list structures provided 
comparison supercompilation generalised partial computation formulated takano concept generalisation terminate small class programs 
abandons simple functional languages treated considers logic programming constraint logic programming accounts exist equivalent transformation power 
frameworks search constraint solving facilities logic language provides necessary machinery avoid redundant computations 
field great efforts produce optimal specialisation time ensure termination see 

robert gluck neil jones laura michael leuschel discussions comments 
peter sestoft insightful comments :10.1.1.35.9833

acm 
proceeding acm sigplan partial evaluation semantics program manipulation volume acm sigplan notices new york september 
acm press 

hubert comon pierre lescanne 
equational problems 
journal symbolic computation march april 

charles consel olivier danvy 
partial evaluation pattern matching strings 
information processing letters 

danvy gluck thiemann editors 
partial evaluation volume lecture notes computer science 
springer verlag 

futamura 
generalized partial computation 
bjrner ershov jones editors partial evaluation mixed computation pages amsterdam 
north holland 

gluck 
occam razor metacomputation notion perfect process tree 
cousot falaschi fil editors workshop static analysis volume lecture notes computer science pages 
springer verlag 

gluck 
roadmap metacomputation supercompilation 
danvy pages 

hickey smith 
partial evaluation clp languages 
pepm pages 

jones gomard sestoft 
partial evaluation automatic program generation 
prentice hall 

gallagher 
partial evaluation functional logic programs rewriting languages 
technical report cstr department computer science university bristol march 

gallagher 
extending power automatic constraint partial evaluators 
acm computing surveys es september 
article 

michael leuschel danny de schreye 
constrained partial deduction preservation characteristic trees 
new generation computing 

michael leuschel bern martens danny de schreye 
controlling generalization partial deduction normal logic programs 
acm transactions programming languages systems january 

greg nelson derek oppen 
fast decision procedures congruence closure 
journal acm april 


perfect supercompilation 
technical report department computer science university copenhagen 

smith 
partial evaluation pattern matching constraint logic programming 
pepm pages 


convergence program transformers metric space trees 
jeuring editor mathematics program construction volume lecture notes computer science pages 
springer verlag 

gluck 
supercompilation 
diku summer school partial evaluation lecture notes computer science 
springer verlag appear 

takano 
generalized partial computation lazy functional language 
pepm pages 

takano 
generalized partial computation solve constraints 
rusinowitch remy editors conditional term rewriting systems 
proceedings volume lecture notes computer science pages 
springer verlag 

turchin 
concept supercompiler 
acm transactions programming languages systems 

turchin 
metacomputation transition plus supercompilation 
danvy pages 

wadler 
deforestation transforming programs eliminate intermediate trees 
theoretical computer science 
