universitat passau fakultat fur mathematik und informatik chaotic fixed point iterations jens knoop gerald luttgen bernhard steffen fakultat fur mathematik und informatik universitat passau passau germany oliver institut fur informatik und praktische mathematik christian universitat kiel germany mip new fixed point theorem applicable countable system recursive equations wellfounded domain 
essential feature computer science applications guarantees termination corresponding fixed point computation algorithms 
natural restriction marks new area application monotonicity required 
demonstrate power versatility fixed point theorem condition covers known synchronous versions fixed point theorems means applications data flow analysis program optimization 
keywords fixed point chaotic iteration vector iteration data flow analysis program optimization workset algorithm partial dead code elimination 
contents theory main theorem vector iterations applications data flow analysis workset algorithms program optimization partial dead code elimination practically relevant problems computer science formalized follows 
family functions df ff ing wellfounded partial order hd vi find solution system recursive equations common fixed point functions typical algorithm solving task start initial value denotes element successively apply functions arbitrary order producing called chaotic iteration main theorem guarantees existence common fixed point functions increasing respect guarantees success procedure functions locally monotonic applied sufficiently 
local monotonicity generalization usual monotonicity property second requirement essentially fairness property 
remainder structured follows 
section new fixed point theorem 
particular show vector iterations special case chaotic iterations 
section demonstrate power versatility theorem application data flow analysis program optimization 
data flow analysis key proving correctness common iterative workset algorithms compute extreme fixed point solution data flow analysis problem 
program optimization central proving optimality algorithm partial dead code elimination 
section contains directions 
related origin fixed point theorems computer science dates back fundamental tarski tar 
tarski theorem considers monotonic function guarantees existence fixed point respect complete partial order 
setup turned restrictive lot practically relevant applications led number generalizations 
see lns survey history fixed point theory 
numerical analysis interested computing fixed point vector gamma monotonic vector function gamma cf 
rob 
tarski iteration may choose th component 
intuitively step set denotes indices components updated 
call iteration synchronous vector iteration 
show vector iterations special chaotic iterations 
vector approach generalized asynchronous iterations cou ud wei may components choice earlier vectors iteration 
worth noting vector iteration approach concerned fixed point single function expressed terms common fixed point vector functions gamma tarski setup requires monotonicity contrast treat common fixed points family functions df ff ing satisfies weaker notion monotonicity called local monotonicity monotonicity restrictive practice 
basic notions partial order hd vi set reflexive antisymmetric transitive binary relation theta sequence elements called ascending chain chain df stationary fd ing finite 
partial order relation called wellfounded chain stationary 
function increasing monotonic 
df family functions defined composition df sn ffi delta delta delta ffi theory section new fixed point theorem gives sufficient conditions family functions df common fixed point function wellfounded partial order hd vi element 
skeleton algorithm computes conditions hold 
main theorem notions central dealing fixed point iterations family functions 
definition strategy chaotic iteration sequence fairness hd vi partial order df family increasing functions strategy function fl strategy fl element induce chaotic iteration fl elements inductively defined fl 
strategy fl called fair iff implies fixed point theorems usually require considered functions monotonic 
practice functions monotonic satisfy weaker notion 
definition local monotonicity hd vi partial order df family functions called locally monotonic implies choose ni od nondeterministic skeleton algorithm monotonic function usual sense locally monotonic 
note local monotonicity general carry proper subsets theorem states main result 
theorem chaotic fixed point iterations hd vi wellfounded partial order element df locally monotonic family increasing functions fl fair strategy 
fl 
fixed point consequence uniqueness fixed point fl 
independent choice fl 
proof functions fairness strategy directly imply fl 
fixed point 
left showing fl 
lower bound fixed point arbitrary fixed point consequence show induction induction step fl follows induction hypothesis local monotonicity fixed point property fl 
definition theorem induces iterative strategy computing fixed point defines fl step run algorithm 
fixed point strictly greater chooses fl arbitrary idea illustrated nondeterministic skeleton algorithm 
vector iterations hc vc wellfounded partial order ordered pointwise extension vc monotonic function 
iterating tarski theorem may pass dissection components gamma perform selective updates 
note set fixed points function set upper indices select component vector length common fixed points function family ff gamma coincide 
vector iteration iteration form gamma df performs selective update components specified set common fixed points function family df ff gamma gg equal set fixed points note monotonic monotonic 
demonstrate vector approach modelled conveniently setting 
generalize notion strategy set strategy range subset gamma 
result shows monotonic vector function chaotic iteration sequence chain 
lemma vector iterations hc wellfounded partial order element ordered pointwise extension gamma monotonic function df ff gamma gg functions defined fl set strategy gamma 
chaotic iteration fl 
chain 
proof fl arbitrary set strategy gamma induced chaotic iteration 
show proof induction definition property holds 
suffices show case element trivial 
updated earlier step 
precisely fl greatest index fl 
induction hypothesis gamma choice obtain fl follows transitivity monotonicity fl fl required 
corollary special case theorem vector iterations follows lemma 
particular jf corollary reduces wellfounded case tarski theorem 
may assume fd 
dg 
corollary chaotic vector iterations hc vc wellfounded partial order element ordered pointwise extension gamma monotonic function df ff gamma gg fl fair set strategy 
fl 
fixed point applications section consider applications fixed point theorem data flow analysis program optimization 
data flow analysis corollary key proving correctness iterative workset algorithms common practice 
precisely prove compute extreme fixed point solution data flow analysis problem 
program optimization show theorem central proving optimality algorithm partial dead code elimination 
data flow analysis workset algorithms data flow analysis dfa concerned static analysis programs order support generation efficient object code optimizing compilers cf 
hec mj 
imperative languages provides information program states may occur program point execution 
usually information computed means iterative workset algorithm elegantly modelled vector iteration approach 
dfa program optimization cf 
section common represent programs directed flow graphs node set edge set nodes represent statements edges nondeterministic branching structure program consideration unique start node node assumed possess predecessors successors respectively 
pred df denotes set immediate predecessors succ df denotes set immediate successors node node assumed lie path node reachable reachable node theoretically wellfounded dfas interpretation cf 
cc mar 
point approach replace full semantics program simpler version tailored deal specific problem 
usually semantics specified means local semantic functional 
gives meaning program statement terms monotonic continuous transformation function wellfounded partial order hc vi element elements express dfa information interest 
program local semantics goal dfa annotate program points dfa information properly reflect run time behaviour respect problem consideration 
formally annotation defined solution equation system specifies consistency preconditions statements expressed terms respect start information annotation known solution minimal fixed point mfp strategy sense kam ullman ku 
minimal maximal 
pre forall pre od workset workset choose workset workset new pre pre pred new pre pre new workset workset succ fi ni od workset algorithm equation system pre pre pred practice mfp solution denote pre computed means iterative workset algorithm see 
correctness approach consequence corollary going show 
flow graph consideration 
local semantics semantic functions monotonic 
denote number nodes df jn gamma bijective mapping set gamma natural numbers set nodes define df equipped pointwise extension easily verifies wellfounded partial order 
value gamma represents configuration flow graph value assigned node 
node flow graph define function gamma df gamma pred intuitively describes effect computation local semantics node configuration 
easily verifies monotonic consequence lemma increasing 
locally monotonic lemma states task modelled correctly 
lemma fixed point equation system fixed point workset algorithm follows general pattern nondeterministic skeleton algorithm 
profits set workset indices satisfies invariant workset dg 
shown premises theorem satisfied 
obtain correctness theorem 
theorem correctness run workset algorithm terminates computes mfp solution pre program optimization partial dead code elimination section demonstrate application chaotic fixed point iteration theorem program optimization proving optimality partial dead code elimination algorithm krs :10.1.1.133.1703
intuitively assignment program dead left hand side variable dead immediately execution program continuation reaching node program left hand side variable preceded redefinition 
correspondingly assignment partially dead dead program paths reaching node program 
conceptually elimination partially dead occurrences assignment pattern ff short partially dead ff occurrences decomposed steps 
moving far possible direction control flow second removing ff occurrences left hand side variable dead execution assignment occurs 
order preserve program semantics sinking elimination steps admissible 
corresponding definitions full detail krs recall restrict presentation framework krs parts essential application theorem :10.1.1.133.1703
relevance theorem partial dead code elimination stems fact assignment sinking elimination steps general second order effects usually enable assignment sinking elimination steps assignment patterns 
example eliminating partially dead occurrences assignment pattern premise occurrences assignment patterns eliminated 
krs taken care repeatedly applying admissible assignment sinking elimination steps assignment patterns program consideration program stabilizes fixed point reached :10.1.1.133.1703
correctness iterative approach consequence theorem going show remainder section 
program write se flow graph results applying admissible assignment sinking elimination transformation 
df se denotes universe programs resulting partial dead code elimination 
denote set admissible assignment sinking dead code elimination functions respectively introduce abbreviation df consists functions defined df se additionally introduce set maximal assignment eliminations 
function called maximal functions function ffi denote set maximal sinking elimination functions max max respectively denote union max max functions important precisely functions involved partial dead code elimination algorithm krs :10.1.1.133.1703
function program introduce conventions notations se alternatively 
ff assignment pattern ff ff denotes set maximal admissible assignment eliminations respect ff 
ff ff denotes set ff occurrences eliminated order compare quality different programs introduce relation better programs definition optimality 
better signs ff ap ff ff ap denotes set assignment patterns occurring ff ff denote number occurrences assignment pattern ff respectively 

optimal better program easy check relation wellfounded 
unfortunately partial order pre order reflexive transitive antisymmetric 
may programs optimal sense definition 
order apply theorem consider partial order se result dominance lemma immediately follows definitions ff ff note relation reflexive 
fact precise notion 
partial dead code elimination preserves branching structure argument program 
starting path easily identify corresponding paths lemma dominance ff ff corresponding functions sinking elimination functions se se se particular lemma proved straightforward induction length derivation sequence 
point proving induction step program resulting transformation argument respect detailed equivalence class sinking elimination step assignment occurrence moved loop eliminated better 
follow immediately constraints satisfied admissible assignment eliminations 
lemma se worth noting lemma yields se carries se definitions se directly yield functions increasing 
lemma 
relation se wellfounded 

functions increasing se 
going show locally monotonic 
lemma se se 
ff occ ff occurrence occ ff occ dead dead 
ff occ ff occurrence moved join node occ ff occurrence moved predecessor occ dead iff occ dead obviously eliminating certain assignment occurrences assignment occurrences dead 
observation directly implies part lemma 
second part lemma consequence admissibility simple program transformation supposed krs typical code motion transformations cf :10.1.1.133.1703
krs krs insert edge leading node successor node predecessor new synthetic node 
node called join node predecessor 
se se se se commuting diagram lemma se ff fi ap different assignment patterns 

transformations diagram commutes 

transformations diagram commutes 

ff fi transformations ff fi diagram commutes 

ff fi transformations ff fi diagram commutes 
proof part lemma proved investigating cases ff ff fi case maximality guarantees ff ff applying lemma obtain ff occurrences ff nff dead transformation eliminates ff occurrences ff nff choosing transformation arbitrary function leaving invariant get se desired se case lemma yields ff fi subsets sets dead ff fi occurrences respectively 
transformations eliminate ff occurrences ff fi occurrences fi choosing transformations respectively obtain desired se se similarly proof part lemma proof second part cases considered ff ff fi case dominance lemma yields existence admissible assignment sinking directly transforms choosing arbitrary function leaving invariant succeed case 
order prove case consider program results ff occurrences moved program results maximal fi sinking se result eliminating reinserted ff occurrences 
obviously transformation fi directly transforms admissibility implies identical fi occurrences 
interchanging roles ff fi applying construction get existence transformation ff transforms completes proof case 
remaining parts lemma proved straightforward proof lines part additionally applying lemma 
lemma lemma allow establish main lemma key proving local monotonicity lemma main lemma se se ffi ffi proof ff fi ap different assignment patterns 
main lemma proved investigating cases 


ff fi 
ff fi 
ff ff 
ff ff due dominance lemma assume loss generality maximal cases immediate consequences corresponding parts lemma 
left cases proved fashion 
proof case 
situation case program results labelled version ff occurrences eliminated due labelling reinserted ff occurrences distinguished remaining ones 
assume unlabelled ff occurrences subject assignment ff occurrences labelled considered block sinking ff occurrences ff occurrence sink labelled unlabelled ff occurrence choose uniquely determined maximal ff sinking ff elimination respectively denote program resulting subsequent application eliminating labelled ff occurrences obtain program course corresponding functions directly transform order complete proof case sufficient show maximal ff elimination transforms 
point ind hyp 
premise ind hyp 
se se se se se se se se se commuting diagram due reinsertion ff occurrences eliminated precisely ff join free paths paths node predecessor unlabelled ff occurrences precisely sinking potential corresponding occurrences paths containing join nodes sinking potential different ff occurrence occ blocked predecessor join node brother ff occurrence ff occurrence successfully sunk ff occurrences ff worth noting ff occurrence dead live 
eliminated subsequent application holds ff occurrence blocked predecessor dead lemma 
combining results obtain desired maximal ff elimination transforms theorem states desired monotonicity result 
theorem local monotonicity locally monotonic se se ffi ffi proof konig lemma finitely branching tree paths finite length finite 
length path bounded 
derivation tree root respect se property 
prove claim induction length longest path starting cases trivial 
apply inductive hypothesis applies respectively longest path starting smaller longest path starting likewise completes proof 
show set common fixed points coincide 
central proving result dominance lemma 
check fixed points maximal set brothers node succ theorem fixed point characterization 
fixed point functions fixed point functions 
fixed point functions maximal proof holds trivially prove 
implication simple consequence second implication proved showing contrapositive 
loss generality assume ff nf ff se ff uniquely determined function ff corresponding dominance lemma yields desired program resulting application different collecting results se wellfounded lemma complete partial order element functions increasing lemma locally monotonic respect se theorem 
theorem applicable 
function families common fixed points theorem fixed points maximal se theorem 
combining results applying lemma obtain desired central theorem krs theorem existence optimal programs optimal element respect computed sequence function applications contains elements sufficiently :10.1.1.133.1703
worth noting optimality partial faint code elimination algorithm introduced krs proved exactly fashion :10.1.1.133.1703
new fixed point theorem gives sufficient condition existence common fixed point family functions wellfounded partial order 
point theorem usual monotonicity condition weakened wellfounded partial orders 
allows capture new interesting class practically relevant applications 
representatives class discussed applications data flow analysis program optimization 
currently investigating generalization approach cover asynchronous iterations wei examine suitability applications distant areas computer science knuth bendix procedure term rewriting partitioning algorithms establishing bisimulation finite state systems 
cc cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
conf 
record th acm symp 
principles programming languages pages los angeles ca 
cou cousot 
asynchronous iterative methods solving fixed point system monotone equations complete lattice 
technical report laboratoire informatique grenoble france september 
dhamdhere rosen zadeck 
analyze large programs efficiently 
proc 
acm sigplan conf 
programming language design implementation volume acm sigplan notices pages san francisco ca june 
hec hecht 
flow analysis computer programs 
elsevier north holland 
krs knoop steffen 
lazy code motion 
proc 
acm sigplan conf 
programming language design implementation volume acm sigplan notices pages san francisco ca june 
krs knoop steffen 
optimal code motion theory practice 
acm transactions programming languages systems 
krs knoop steffen :10.1.1.133.1703
partial dead code elimination 
proc 
acm sigplan conf 
programming language design implementation volume acm sigplan notices pages orlando fl june 
ku kam ullman 
monotone data flow analysis frameworks 
acta informatica 
lns 
lassez nguyen 
fixed point theorems semantics folk tale 
information processing letters 
mar 
frameworks interpretation 
acta informatica 
mj muchnick jones editors 
program flow analysis theory applications 
prentice hall englewood cliffs nj 
rob robert 
convergence locale erations non lin 
technical report laboratoire informatique grenoble france december 
rosen wegman zadeck 
global value numbers redundant computations 
conf 
record th acm symp 
principles programming languages pages san diego ca 
tar tarski 
lattice theoretical fixpoint theorem applications 
pacific journal mathematics 
ud michel dubois 
sufficient conditions convergence asynchronous iterations 
parallel computing 
wei wei 
parallel asynchronous iterations fixed points 
parallel computing 

