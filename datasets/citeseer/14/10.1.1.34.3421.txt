appear proceedings usenix annual technical conference june 
techniques design java operating systems back patrick leigh stoller wilson hsieh jay lepreau department computer science university utah language systems java virtual machines spin type safety provide memory safety single address space 
software provide safety support efficient ipc 
memory safety sufficient protect different applications 
systems need support process model enables control management computational resources 
particular language extensible systems support resource control mechanisms analogous standard operating systems 
need support separation processes limit resources support safe efficient ipc 
demonstrate challenge addressed java systems 
lay design choices implementing process model java 
second compare solutions explored projects alta kernel 
alta closely models fluke operating system similar traditional monolithic kernel kernel resembles microkernel system 
compare systems support resource control explore tradeoffs various designs 
language extensible systems form java virtual machines implement execution environments applets browsers servlets servers mobile agents 
environments share property run multiple applications time 
example user may load applets different web sites browser server may run servlets different sources agent server may run agents internet 
circumstances research supported part defense advanced research projects agency monitored department army contract number dabt air force research laboratory rome research site usaf agreement numbers 
contact information stoller wilson cs utah edu 
department computer science central campus drive room university utah slc ut 
www cs utah edu flux java applications trusted server user runs 
untrusted applications language extensible system able isolate applications may buggy malicious 
execution environment java byte code attempts provide isolation term java operating system 
conventional operating systems provide abstraction process encapsulates execution application 
process model defines process may 
features necessary process model safe extensible systems protection 
process able destroy data process manipulate data process uncontrolled manner 
resource management 
resources allocated process separable allocated processes 
unprivileged untrusted process able starve processes denying resources 
communication 
application may consist multiple cooperating processes processes able communicate 
supported communication channels safe efficient 
requirements processes form primary tradeoffs building operating systems illustrated 
right hand side processes protected easily completely separate machines 
addition managing computational resources simpler resources completely separate 
unfortunately communication expensive processes different machines 
left hand side communication cheaper processes share memory directly 
result protection accurate resource accounting difficult 
operating systems research spanned entire range systems primary focus systems middle 
research distributed systems networking focused right side 
research single address space operating systems ease protection resource management machine shared memory processes java opal separate address spaces machine shared memory unix svr separate machines distributed os machine shared memory separate address spaces unix multiple jvms communication costs address space trading sharing isolation processes 
right running different processes separate machines isolates cleanly communication expensive 
left theory space operating system allows efficient communication processes isolation difficult 
opal older language operating systems focused left side 
language extensible systems spin focused attention back left side diagram :10.1.1.117.6702
systems single address space systems type safety hardware memory mapping protection 
discuss resource management provided language systems particular java tradeoff memory control sharing expressed systems 
view java example language extensible system reasons 
java bytecode verification removes need trusted compiler 
second java popularity possible process model widely 
java general lessons learned developing process model apply language extensible systems 
systems servlet engines mobile agent servers need support multiple java applications simultaneously 
safety systems separate java virtual machines contain application 
possible run multiple java applications applets separate java virtual machines jvms reasons run single virtual machine 
aside overhead involved starting multiple jvms cost communication applications applets greater applications run separate virtual machines suggested 
additionally small systems palmpilot os hardware support multiple processes 
environments jvm perform operating system tasks 
final reason single jvm better performance achievable reduction context switching ipc costs 
unfortunately standard java systems readily support multiprogramming support process abstraction 
research issues explore design problems arise implementing process model java virtual machine 
hard problems implementing process model java revolve memory management 
hard problems designing process model unique java 
java system protection provided type safety language 
memory management harder java conventional operating systems address space shared 
conventional operating system protection provided memory management unit 
process memory inherently separated systems engineered provide fast efficient communication 
compare java systems process models support alta projects university utah kernel project cornell 
alta structured fluke microkernel provides hierarchical process model focuses providing safe efficient sharing processes potentially different type spaces 
structured traditional monolithic kernel focuses stringent comprehensive resource controls 
kernel structured system automatic stub generation intertask communication 
surprising language operating systems adopt ideas previous operating systems research design issues implementation tactics remain 
systems support strong process models limit resource consumption processes permit processes share data directly necessary 
section overviews java terminology 
section describes technical challenges providing resource management java section compares design implementation alta kernel 
section describes related research traditional operating systems language operating systems java particular 
section summarizes 
background java high level object oriented language specification virtual machine executes bytecodes 
java gives applications control dynamic linking process special objects called class loaders 
class loaders support user defined type safe loading new data types object types code running java system 
jvm architecture neutral platform objectoriented multi threaded applications 
jvm provides number guarantees backed run time verification automatic memory management memory safety applications executes 
specifically bytecodes constitute application satisfy certain semantic constraints jvm provided automatic garbage collector reclaim storage 
traditional jvm structured trusted core usually implemented augmented java libraries 
core libraries implement standard java class libraries 
calls core code native methods 
protecting system buggy malicious code protecting clients requires control just protection afforded type safety 
particular jvm able provide security control data information files resource management control computational resources cpu time memory 
jvm analogous traditional operating system 
extensive investigation devoted security issues java resource management thoroughly investigated 
example client abuse memory intentionally accidentally compromise functionality jvm 
design implementation robust java operating systems tightly control resource usage open area research addressing 
resource management section discusses primary design choices managing resources java operating system 
divide problem resource management related subproblems resource accounting ability track resource usage 
accounting exact approximate fine grained coarse grained 
resource reclamation ability reclaim process resources terminates 
complex allocation management policies flexible sharing policies reclamation difficult 
reclamation immediate delayed 
resource allocation ability allocate resources processes way allow processes violate imposed resource limits 
allocation mechanisms fair incur excessive overhead 
discuss previous issues respect computational resources memory cpu usage network bandwidth 
currently deal managing persistent storage little specific management storage language systems 
java encourages direct sharing memory primary difficulty supporting process model java isolating processes memory 
memory issues memory accounting memory reclamation memory allocation java process model divided discussions memory accounting impact inter process sharing model allocation deallocation policies 
sharing model sharing model defines processes share data 
java operating system choices possible copying direct sharing indirect sharing 
sharing model standard java processes direct sharing objects contain pointers thread accesses object fields offsets object pointer 
java processes choice sharing model affects memory accounting process termination resource reclamation implemented 
copying 
copying feasible alternative address spaces shared example processes different machines 
copying traditional approach communication rpc systems research aimed reducing cost copying machine rpc 
mach example copy write data avoid extra copies 
data copying means communication processes memory accounting process termination straightforward 
processes share objects process objects reclaimed immediately ambiguity process owns object 
course immediacy reclamation depends garbage collector involvement memory accounting reclaiming objects java require full garbage collection cycle 
java copying communication mechanism unappealing violates spirit java sharing model slow 
support jvm process safely share trusted object untrusted peer leveraging support fine grained sharing java process model major advantage language system 
hand system supports copying data processes process termination process memory accounting simpler 
direct sharing 
java designed support direct sharing objects design option allow direct sharing processes 
interprocess sharing objects sharing 
direct sharing single address space systems somewhat analogous shared memory shared libraries separate address space systems unit sharing finer grained 
system supports direct sharing processes process termination resource reclamation complicated 
process exports directly shared object object reclaimed exporting process terminated 
type safety guarantees java virtual machine violated object remain valid 
reclaim object require object located 
presence code search impossible extensive compiler support 
order support resource reclamation process killed direct sharing needs restricted system guarantee outstanding object located 
indirect sharing 
alternative direct sharing indirect sharing objects shared level indirection 
communicating shared object direct pointer object provided 
process creates proxy object encapsulates shared object 
passes pointer proxy object 
proxies system protected objects 
order maintain indirect sharing prevent direct sharing system ensure way client extract direct object pointer proxy 
second class handles objects commonly called capabilities analogues traditional operating systems include file descriptors process identifiers 
compared direct sharing indirect sharing efficient extra level indirection followed interprocess call occurs 
advantage indirection resource reclamation straightforward 
shared object revoked level indirection enables system track object 
process killed shared objects reclaimed immediately 
copying immediate revocation subject cost full garbage collection cycle java 
allocation deallocation page protection hardware software mechanisms necessary account memory java operating system 
allocation group allocations checked allocating process heap limit 
stack frame allocations checked executing thread stack limits 
memory necessarily reclaimed java automatic garbage collector 
obvious garbage collector memory accounting 
simplest mechanism keeping track memory allocator debit process allocates memory garbage collector credit process memory reclaimed 
presence object sharing direct indirect memory accounting schemes possible 
example system conceivably divide cost object parties keep object alive 
model drawback process spontaneously charged memory 
example suppose process acquires pointer large object initially charged small fraction object memory 
sharers release process may asynchronously run memory forced bear full cost entire object 
potential scheme allow processes pass memory credits processes 
example server require clients pass memory credits request pay resources server allocates 
scheme analogous economic models proposed resource allocation 
similar system permit process transfer right allocate allowance 
similar effect possible simple allocator pays model having client allocate object pass server filled 
important issue managing memory relationship allocation accounting schemes 
particular system charges object allocates memory larger chunks subject fragmentation attack 
process small budget accidentally maliciously cause allocation large number blocks 
solution provide process region physical virtual addresses allocate memory 
solution guarantees accurate accounting internal fragmentation may introduce external fragmentation 
cpu usage mechanisms necessary controlling cpu usage accounting preemption 
system able account accurately cpu time consumed thread 
system able prevent threads exceeding assigned cpu limits preempting terminating 
desirable additional features cpu management multiple scheduling policies user policies support real time policies 
cpu accounting accuracy cpu accounting strongly influenced way processes obtain services 
services implemented libraries calls monolithic kernel accounting simply amounts counting cpu time thread accrues 
cpu accounting difficult shared system services process bill cpu usage easily determined 
examples services include garbage collection interrupt processing network packets 
services system needs means deciding process charged 
garbage collection 
simplest accounting policy garbage collection treat global system service 
unfortunately policy undesirable opens system denial service attacks 
example process trigger garbage collections frequently slow processes 
addition treating garbage collection universal service allows priority inversion occur 
low priority thread allocates deallocates large chunks memory may cause high priority thread wait garbage collection 
see approaches taken solve problem 
garbage collector charge cpu usage process objects traversing 
solution require fine grained measurement cpu usage overhead prohibitive 
second alternative provide process heap garbage collected separately gc time charged owning process 
independent collection different heaps requires special treatment inter heap direct sharing allowed 
addition distributed garbage collection algorithms necessary collect data structures shared heaps 
packet handling 
interrupt handling system service behavior differs garbage collection user external interrupt known interrupt serviced 
goal system minimize time needed identify receiver time accounted 
example druschel banga showed packets processed operating system 
demonstrated system performance drop dramatically packet processing done interrupt level normal process resource limits apply 
concluded systems perform lazy receiver processing lrp combination early packet demultiplexing early packet discard processing packets receiver priority 
lrp improves traffic separation stability overload 
preemption termination preempting thread holds system lock lead priority inversion 
result generally better thread exit critical section preempted 
similarly destroying thread holds system lock lead consistency problems lock released deadlock lock released 
preemption termination safe system protect critical sections operations 
making distinction non preemptible non code regular code java system effectively distinction user mode kernel mode 
traditional hardware system entry exit kernel explicit marked trap instruction 
separation kernel user code clear java making call kernel different method invocation 
addition providing support non preemptible non critical sections java operating system needs preemption model kernel 
design choices similar traditional systems 
kernel single threaded preemption occur outside kernel 
alternatively system designed allow multiple user threads enter kernel 
case preemption immediate protecting kernel data structures incurs additional overhead 
network bandwidth bandwidth important certain applications java active networks little controlling network bandwidth specific java 
range approaches byte counting packet scheduling available 
kernel experimented special version dll count bytes outgoing network streams 
implementations alta easily provide access packet scheduling facilities provided infrastructure run 
comparison section describe detail prototype systems alta prototype third java operating system kernel built cornell 
systems represent different sets design tradeoffs kernel disallows direct sharing processes uses bytecode rewriting support indirect sharing 
consists java code portable jvms 
result resource controls kernel provides approximate 
kernel ipc involve rendezvous thread migrates processes delay termination 
partitions java heap isolate resource consumption 
addition restricted direct sharing permitted system heap 
garbage collection techniques put interesting support combination 
cpu inheritance scheduling framework hierarchical scheduling cpu time 
alta uses hierarchical resource management processes responsible gives capability managing subprocesses resources 
direct sharing sibling processes permitted parent responsible memory 
hierarchy match cpu inheritance scheduling 
kernel kernel implements microkernel architecture java programs written java :10.1.1.124.9017
supports multiple protection domains called tasks 
names managed kernel resolvers map names java classes 
task creates subtask specify classes subtask allowed access 
class loaders give tasks name spaces 
system model communication kernel capabilities 
java objects shared indirectly passing pointer capability object local rmi call 
capability trusted object containing direct pointer shared object 
level indirection capabilities shared object capabilities revoked 
capability passed tasks share class 
making class shared explicit action forces class loaders share class 
arguments inter task invocations capabilities copied depth complete tree objects reachable argument direct copied recursively 
default standard java object serialization involves marshaling unmarshaling linear byte buffer 
decrease cost copying fast copy mechanism provided 
specialized code class creates direct copy object fields 
specialized fast copy code stubs needed cross domain calls generated dynamically 
kernel supports thread migration tasks cross task communication threads 
single thread method call logically changes protection domains 
full context switch required 
prevent malicious callers damaging callee data structures task allowed thread thread executing code process 
choice system structure requires caller trust callees malicious erroneous callee return 
resource management kernel designers explicit decision build jvm 
kernel written entirely java 
result decision kernel designers limited precision resource control mechanisms 
lack precision occurs jvm runs kernel know processes 
result account resources consumes behalf process 
memory management 
order account memory kernel rewrites bytecode constructors charge credit memory usage 
scheme take fragmentation account 
addition memory occupied just intime compiled code hard account 
cpu management 
nt version kernel uses kernel device driver monitor cpu time consumed thread 
mechanism reactive threads prevented consuming resources exceeded limits 
addition difficult add custom scheduling policies tasks 
implementation status version kernel support resource controls freely available cornell 
advantage implementation approach high degree portability kernel run jvms 
uses class reloading dependencies specific interpretation gray areas java language specification 
kernel distributed additional pieces software 
jos uses kernel provide support servers 
second server web server safely runs client provided java code 
summary kernel adopts capability model disallows direct sharing tasks 
result capabilities directly memory completely reclaimed task termination 
addition kernel exploits high level nature java bytecode representation support automatic creation communication channels 
design loosely follows traditional monolithic kernel 
oriented complete resource isolation processes secondary goal allowing direct sharing 
traditional operating system process associated separate heap sharing occurs special shared heap 
run jdk applications modification 
run assume loaded null class loader 
system model process consists name space heap set threads 
relies class loaders provide different processes separate name spaces 
process associated class loader logically considered part kernel 
provide different processes copies classes contain static members loads classes multiple times 
jvms allows safe reloading essential classes object throwable 
reduce process memory footprint classes contain shared data may shared processes akin different processes map shared library address spaces traditional os 
shared classes occupy single name space sharing privileged operation 
threads access kernel services calling kernel code directly 
kernel returns kernel objects act capabilities things open files sockets 
order support stopping killing threads provides primitive defers delivery asynchronous exceptions defined cancellation point kernel reached 
primitive solve problems thread termination enables kernel programmer safely cancel user processes compromising integrity kernel 
process associated heap 
shared classes shared data reside distinct heap called shared heap 
supports comprehensive memory accounting takes internal allocations jvm account 
controls able support independent collection individual heaps able charge garbage collection time appropriate processes 
separate heaps additional benefit allowing avoid priority inversions necessary higher priority threads processes performing collection 
resource management memory management 
separate heaps simplifies memory accounting heap subject memory budget simplifies cpu accounting heap collected separately 
order preserve benefits allowing efficient process communication provides limited direct sharing heaps 
processes want share object criteria met 
processes share type object 
second object allocated shared heap 
creation shared object privileged operation 
object process heap refer shared object shared object refer object process heap 
explicitly disallows direct sharing objects separate processes heaps uses write barriers enforce restriction 
acquiring shared object possible invoking system ensures resources allocated system heap behalf process subject specific limit 
instance process may open certain number files kernel part file descriptor allocated system space 
careful hand objects public members objects uses internal synchronization 
shared objects restricted execution model 
construction allocate objects system heap 
objects constructed threads methods subject normal segment limits thread attempts shared object write foreign heap heap segmentation violation error triggered 
allow separate garbage collection individual heaps implements form distributed gc 
heap keeps list entry items objects external exist 
entry item consists pointer local object count 
count denotes number foreign heaps links object 
garbage collector heap treats entry items roots 
heap keeps list exit items non local objects heap refers 
exit item contains pointer entry item object refers 
garbage collection cycle unreferenced exit items collected counts corresponding entry items decremented 
entry item re claimed count reaches zero 
write barriers automatically create update exit entry items maintain heap invariants described previously 
write barrier detects legal lookup create corresponding exit item remote object 
turn corresponding entry item foreign heap updated 
write barrier prevent passing illegal cross heap 
created write illegal segmentation violation error thrown 
write barrier similar write checks 
may odd protection mechanism software fault isolation type safe system motivation resource management memory safety 
improve jvm memory reserve non overlapping contiguous memory regions heap 
memory accounting done block basis 
small objects stored page sized blocks larger objects stored dedicated blocks 
heaps receive new memory blocks garbage collector heap frees block 
cpu management 
traditional java thread belongs thread group 
thread groups form hierarchy thread group parent group 
initial thread group root group hierarchy 
adapts thread group classes threads belonging process contained subtree 
process threads traverse tree past root subtree 
combines thread group hierarchy cpu inheritance scheduling 
cpu inheritance scheduling directed yield primitive scheduler thread cpu time specific thread yielding effectively schedules thread 
receiver thread may turn function scheduler thread scheduler hierarchies built 
non root thread associated scheduler thread notified thread runnable 
scheduler may timer revoke donation preempts scheduled thread 
cpu inheritance scheduling allows things 
provide process scheduler may implement policy schedule threads process 
second thread groups processes may hierarchically schedule threads belonging 
thread group associated scheduler java class 
different policies implemented different subclasses 
root scheduling hierarchy uses fixed priority policy guarantee system heap garbage collector highest priority 
level stride scheduler divides cpu time processes 
provide compatibility traditional java scheduling root thread group process default associated fixed priority scheduler child stride scheduler 
implementation status prototyped kernel composed modified jvm kaffe beta 
supplemented classes binary format javasoft jdk package privileged classes replace part core java packages 
ran stand kernel oskit suite components building operating systems 
additionally ran user mode libraries simulate certain oskit components interrupt handling raw device access 
implemented separate heaps write barriers 
initial prototype support separate garbage collection class garbage collection 
prototype supported cpu inheritance scheduling way described supported schedulers implemented native methods implemented different policies rate monotonic scheduling lottery 
currently working successor system called improved base jvm supports separate garbage collection provide full resource reclamation 
summary design oriented complete resource isolation processes secondary goal allowing direct sharing 
giving process separate heap memory cpu management resource issues simpler 
sharing occurs shared system heap distributed garbage collection techniques safely maintain sharing information 
alta alta extended java virtual machine provides hierarchical process model system api modeled provided fluke microkernel 
fluke supports nested process model process manage resources child processes way operating system manages resources processes 
memory management cpu accounting explicitly supported alta system api 
higher level services network access file systems managed servers applications communicate ipc 
capabilities provide safe cross process communication 
process root thread group threads private copies static member data 
process memory accounting alta comprehensive 
access control purposes alta expands fluke model providing processes ability control classes sub process 
alta extends java class model allows process rename classes subprocess sees 
result process interpose subprocess interfaces 
alta virtual machine change interfaces semantics defined jvm specification 
existing java applications javac java compiler run unmodified processes alta system model communication alta done ipc system mimics fluke ipc system 
inter process communication half duplex reversible client server connection threads may reside different processes 
additionally alta ipc provides immediate notification client server peer connection terminated disconnects 
alta permits sibling processes share objects directly 
objects shared passing ipc 
sharing permitted objects processes consistent views class name space 
enforcing requirement efficiently requires classes involved final subclassed 
somewhat restrictive primitive types byte array bytes java lang string core alta classes meet requirements 
resource management strongest feature alta process model ability nest processes process manage child processes way system manages processes 
resource management alta strictly hierarchical 
process create child process limit memory allowance process 
memory management 
alta supports memory accounting simple allocator pays scheme 
garbage collector credits owning process object eventually reclaimed 
process terminated existing objects promoted parent memory 
responsibility parent process sure cross process created full memory reclamation necessary child process termination 
important note alta enables process prevent child processes passing java object ipc 
memory reclamation simple process passes children 
nested process model process terminated child processes necessarily terminated 
passed process children unused 
support clean thread process termination alta uses standard operating system implementation tricks prevent problem threads terminated executing critical system code just 
example avoid stack overflows executing system code entry layer verify sufficient space available current thread stack 
check analogous standard technique pre allocating adequate size stack kernel execution traditional operating systems 
additionally alta structured avoid explicit memory allocations kernel mode 
system call allocate objects entering kernel proper 
allocation effectively happens user mode 
notion system code entry layer explicit system calls example thread need enter kernel 
cpu management 
alta provides garbage collection system service 
leaves alta open denial service attacks generate large amounts garbage cause garbage collector run 
memory limits processes limits cpu usage process gc problems mitigated 
implementation status alta implementation jdk equivalent jvm libraries kaffe version version respectively 
bulk system implemented entirely java 
internals vm enhanced support nested processes 
number core library classes modified alta primitives class substitution effective 
addition javac alta supports simple applications nest multiple children control class name spaces basic shell simple applications 
terms code sharing process alta analogous statically linked binary traditional systems process jit version method 
kaffe jit modified provide sharable code just compilers generate position independent code shared libraries 
version kaffe alta support garbage collection classes 
alta implement cpu inheritance scheduling 
alta share common code base cpu inheritance scheduling implemented easy migrate alta addition alta runs regular process traditional operating system run top bare hardware oskit 
summary alta implements fluke nested process model api java operating system 
demonstrates nested process model provide java processes flexible control resources 
hierarchical nature model direct sharing siblings supported resource reclamation problems 
performance evaluation ran microbenchmarks prototype systems alta port kernel kaffe measure baseline performance 
benchmarks demonstrate undue performance penalties paid normal java code systems supporting processes 
addition roughly compare cost ipc java process creation systems 
alta kernel basic kaffe tests performed mhz intel pentium ii mb sdram 
system ran freebsd version idle 
tests performed machine linked oskit running freebsd 
table shows average time simple null instance method invocation average cost allocating java lang object average overhead creating starting thread object average cost creating throwable object 
benchmarks written avoid invocation gc intentional unintentional timing 
alta benchmarks run root task system 
kernel benchmarks run children kernel cornell 
std main 
systems significantly disrupts basic features virtual machine 
previously published results kernel microsoft java virtual machine significantly faster kaffe 
alta null thread test significantly expensive basic kaffe test alta threads maintain additional thread state ipc process state blocking 
table measures critical costs adding process model java 
column lists overhead creating new process measured time parent creates new process time new process begins main function 
kaffe row lists time required kaffe fork exec new kaffe process freebsd 
kernel supports limited notion process kernel processes require active thread kernel test simply creates passive task seeds simple initial object 
subsequent columns table show time required cross task communication 
alta ipc significantly slower rendezvous threads uses ports kernel ipc simply cross process method invocation 
ipc implemented shared rendezvous object directly wait notify 
ipc cost reflects unoptimized thread package different thread package jvms 
performance results indicate systems need substantial optimization order realize performance potential language operating systems 
performance benefits fine grained sharing software dominated inefficiencies basic jvm implementation 
difference previously published kernel results demonstrates performance java systems spurred advances just time compilation orthogonal research issues exploring 
analyze implementation costs decision build jvm examined system terms useful lines code non blank lines source 
point original version kaffe contains lines kaffe beta comprised just lines lines java 
increase due move jdk jdk alta comprised lines java adds approximately lines kaffe significant fraction code consists features versions kaffe ported back kaffe 
adds approximately lines code virtual machine lines java code basic libraries 
additional code consisted changes garbage collector support separate heaps 
comparison kernel consists approximately lines java 
building kernel layer top jvm probably easier implementation path building new jvm 
primary difficulty building kernel probably lay building dynamic stub generator 
related lines research related 
development single address space operating systems protection provided language hardware direct antecedent java 
second great deal research today directed building operating system services java 
prior research great deal research done single address space operating systems 
virtual machine method invocation object creation null thread test exception creation kaffe beta alta kaffe kernel table despite fact distinct java virtual machines different versions kaffe virtual machine base performance versions different 
kernel run kaffe deficiencies object serialization kaffe beta 
virtual machine process creation null ipc integer request byte string request alta ms ms kernel ms kaffe ms table process tests 
note numbers column reported ms columns reported alta ipc separate threads kernel ipc uses cross process thread migration 
integer request byte string request operations include time marshal request 
kernel uses object serialization transmit string alta hand coded string marshal code 
opal communication accomplished passing bit capabilities processes process attach memory segment address space address memory segment directly 
opal type safe language resource allocation reclamation coarse grained counting segments 
research projects explored operating systems issues context programming languages 
example argus clouds explored transactions distributed programming languages 
important systems studied issues distribution include eden emerald amber 
systems explored concepts underlying object migration investigate resource management 
language operating systems existed years 
designed protect malicious users number support strong security features 
provide strong resource controls 
pilot cedar earliest language systems 
development xerox parc predates flurry research systems 
oberon java features garbage collection object orientation strong typechecking dynamic binding 
java oberon non preemptive single threaded system 
background tasks garbage collector implemented calls procedures interruption occur top level procedure calls 
related project juice provides execution environment downloaded oberon code just jvm provides execution environment java 
juice virtual machine executes binaries portable format compiles native code loading executes native code directly 
advantage juice portable format faster decode easier compile java bytecode format 
spin operating system kernel lets applications load extensions written modula extend specialize kernel 
java type safety modula ensures memory safety 
spin supports dynamic interposition names extensions different name spaces 
inferno os building distributed services virtual machine called dis programming language called limbo 
inferno small system ported architectures designed run resource limited environments set top boxes 
order minimize garbage collection pauses inferno uses counting reclaim memory avoiding number accounting issues related garbage collection operating system 
vino software language extensible system addresses resource control issues wrapping kernel extensions transactions 
extension exceeds resource limits safely aborted holds kernel locks resources recovered 
java research alta kernel number research systems explored exploring problem supporting processes java 
balfanz gong describe multi processing jvm developed explore security architecture ramifications protecting applications opposed just protecting system applications 
identify areas jdk assume single application model propose extensions jdk allow multiple applications provide security 
focus multi processing jvm explore applicability jdk security model multi processing rely existing limited jdk infrastructure resource control 
ibm released jvm os family systems targeted server applications enterprise java beans 
system puts transaction separate worker jvm initialize execute shared heap 
shared heap holds classes objects expected survive transaction 
worker jvms leave resources reused multiple transactions 
transaction leave resources worker jvm process terminated os free resources 
ibm motivation providing quasi process model java faster startup times attributable savings class loading processing increases transaction throughput 
consider case malicious uncooperative applications control data individual applications store shared heap 
addition shared heap garbage collected 
approach resource control dedicate entire machine execution client code 
instance java playground cage applet management system define special java applet execution models require applets run dedicated specially protected hosts 
execution model imposes extremely rigid limits mobile code quarantining applets isolated hosts 
result richer access completely disallowed 
abovementioned systems guarantee integrity jvm provide inter applet guarantees offered underlying stock jdk 
systems similar uses dedicated servers protect critical virtual machine resources bytecode verifier protect applications 
luna system kernel developers 
luna extends java language runtime explicit remote pointers 
remote pointers dynamically revoked processes safely share fine grained data compromising type safety 
sun original standalone os written entirely java 
described firstclass os java applications appears provide single jvm little separation applications 
replaced new implementation termed business runs java applications 
consumers built chorus microkernel os order achieve real time properties needed embedded systems 
systems require separate jvm java application run supervisor mode 
jvm integrated scout operating system provides control cpu time network bandwidth 
uses scout path abstraction 
provide memory limits 
open group conversant system project modifies jvm provide processes 
provides process separate address range single mach task separate heap separate garbage collection thread 
conversant support sharing processes systems kernel 
threads native mach threads support posix real time semantics 
conversant provides real time services 
real time system perc extends java support real time performance guarantees 
perc system analyzes java bytecodes determine memory requirements worstcase execution time feeds information realtime scheduler 
order support multiple applications java operating system control computational resources 
major technical challenges addressed building system managing memory cpu usage shared code 
challenges dealt adapting techniques conventional systems language systems 
challenges dealt adapting language technology garbage collection fit operating system framework 
described prototype java operating systems built utah alta 
prototypes cornell kernel illustrate tradeoffs terms system structure resource management implementation strategies 
shown design issues conventional operating systems structural design java operating systems 
java operating systems built monolithic designs built microkernel designs alta kernel 
shown garbage collection techniques support resource management java processes 
acknowledgments kristin wright stephen james efforts helping results 
eric eide great help editing improving presentation material massimiliano poletto comments drafts 
chris hawblitzel clarifications kernel works 
flux group making oskit 
accetta baron bolosky golub rashid tevanian young 
mach new kernel foundation unix development 
proc 
summer usenix conf pages june 

adl tabatabai lucco wahbe 
efficient language independent mobile programs 
proc 
acm sigplan conf 
programming language design implementation pldi pages may 
black lazowska noe 
eden system technical review 
ieee transactions software engineering se jan 
java apache project 
java apache org apr 
back hsieh 
drawing red line java 
proc 
seventh workshop hot topics operating systems pages rio rico az mar 
ieee computer society 
balfanz gong 
experience secure multiprocessing java 
proc 
eighteenth international conf 
distributed computing systems may 

java meet service guarantees secure partitioning cpu memory 
technical report open group research institute june 
bershad anderson lazowska levy 
lightweight remote procedure call 
acm transactions computer systems feb 
bershad savage pardyak sirer fiuczynski becker chambers eggers 
extensibility safety performance spin operating system 
proc 
th acm symposium operating systems principles pages copper mountain dec 
birrell nelson 
implementing remote procedure calls 
acm transactions computer systems feb 
black jul levy carter 
distribution types emerald 
ieee trans 
software engineering se 
chase lazowska levy 
amber system parallel programming network multiprocessors 
proceedings th symposium operating systems principles pages december 
chase levy feeley lazowska 
sharing protection single address space operating system 
acm transactions computer systems 
clements morrison 
implementation java tm core class libraries 
ftp uk misc tar gz www cs utah edu projects flux java 
czajkowski 
chang hawblitzel hu von eicken 
resource management extensible internet servers 
proceedings th acm sigops european workshop sintra portugal sept 
dasgupta design implementation clouds distributed operating system 
computing systems winter 
cage 
www com overview html 
clark durand howard oliver samuel st john 
building java virtual machine server applications jvm os 
ibm systems journal 
reprint order 

dorward pike presotto ritchie trickey 
inferno 
proceedings nd ieee computer society international conference san jose ca february 
druschel banga 
lazy receiver processing lrp network subsystem architecture server systems 
proc 
second symposium operating systems design implementation pages seattle wa oct 
ford back benson lepreau lin shivers 
flux oskit substrate os language research 
proc 
th acm symposium operating systems principles pages st malo france oct 
ford hibler lepreau back 
microkernels meet recursive virtual machines 
proc 
second symposium operating systems design implementation pages 
usenix association oct 
ford 
cpu inheritance scheduling 
proc 
second symposium operating systems design implementation pages seattle wa oct 
usenix association 
franz 
java infrastructure highperformance mobile code world wide web 
tomek editors proceedings webnet pages october 
gong mueller 
going sandbox overview new security architecture java development kit 
proc 
usenix symposium internet technologies systems pages monterey ca dec 
usenix 
gosling joy steele 
java language specification 
java series 
addison wesley 
hartman platform liquid software 
technical report univ arizona cs dept dec 
hawblitzel 
chang czajkowski hu von eicken 
implementing multiple protection domains java 
proc 
usenix annual technical conf pages new orleans la june 
hawblitzel von eicken 
tasks revocation java hey 
got operating system language 
describes luna nov 
zimmerman 
special feature look java mobile agents 
ieee internet computing july august 
liang bracha 
dynamic class loading java virtual machine 
proc 
oopsla vancouver bc oct 
appear 
lindholm yellin 
java virtual machine specification 
java series 
addison wesley jan 
liskov 
distributed programming argus 
communications acm march 
malkhi reiter rubin 
secure execution java applets remote playground 
proc 
ieee symposium security privacy pages oakland ca may 
mosberger peterson 
making paths explicit scout operating system 
proc 
second symposium operating systems design implementation pages seattle wa oct 
usenix association 
nilsen 
java real time 
real time systems journal 
shapiro 
survey distributed garbage collection techniques 
proceedings international workshop memory management scotland sept 
redell dalal lauer lynch mcjones murray purcell 
pilot operating system personal computer 
communications acm 
rozier armand herrmann kaiser leonard 
chorus distributed operating system 
computing systems dec 
seltzer endo small smith 
dealing disaster surviving misbehaved kernel extensions 
proc 
second symposium operating systems design implementation pages seattle wa oct 
usenix association 
sirer grimm gregory bershad 
design implementation distributed virtual machine networked computers 
proceedings th symposium operating systems principles pages kiawah island resort sc dec 
sun microsystems standalone java environment feb 
www javasoft com products white html 
swinehart zellweger beach hagmann 
structural view cedar programming environment 
acm transactions programming languages systems oct 
lepreau 
nested java processes os structure mobile code 
proc 
eighth acm sigops european workshop pages sintra portugal sept 
von eicken 
chang czajkowski hawblitzel hu 
kernel 
source code available www cs cornell edu jk doc default html 
waldspurger hogg huberman kephart stornetta 
spawn distributed economy 
ieee transactions software engineering feb 
wallach balfanz dean felten 
extensible security architectures java 
proc 
th acm symposium operating systems principles pages oct 
wetherall guttag tennenhouse 
ants toolkit building dynamically deploying network protocols 
proceedings ieee san francisco ca april 
wilkinson 
kaffe virtual machine compile interpret java bytecodes 
www com kaffe html 
wilson 
uniprocessor garbage collection techniques 
proceedings international workshop memory management st malo france sept 
wirth gutknecht 
project oberon 
acm press new york ny 

