dependently typed functional programs proofs conor mcbride doctor philosophy university edinburgh research dependent type theories past concentrated presentation theorems theorem proving 
thesis concerned mainly exploitation computational aspects type theory programming context properties programs may readily specified established 
particular develops technology programming dependent inductive families datatypes proving programs correct 
demonstrates considerable advantage gained indexing data structures pertinent characteristic information soundness ensured typechecking human effort 
type theory traditionally presents safe terminating computation inductive datatypes means elimination rules serve induction principles associated reduction behaviour recursion operators dyb 
programming language arena appear somewhat cumbersome give rise unappealing code complicated inevitable interaction case analysis dependent types equational reasoning indices appear explicitly terms 
thierry coquand proposal coq equip type theory directly kind pattern matching notation functional programmers past decades bur mcb offers remedy difficulties 
status pattern matching relative traditional elimination rules doubt 
pattern matching implies uniqueness identity proofs martin hofmann showed conventional definition equality hof 
thesis shows adoption uniqueness axiomatic sufficient pattern matching admissible 
datatype elimination rule allows abstraction inductively defined family 
order support pattern matching application rules specific instances dependent families 
underlying analysis extends datatypes rules similar second order character suggesting may roles play specification verification derivation programs 
technique developed shifts specificity instantiation type indices equational constraints indices freely chosen allowing elimination rule applied 
elimination means leaves equational hypotheses resulting subgoals solved progress 
order unification algorithm constructor forms simple types mcb extended cover dependent datatypes yielding completely automated solution class problems syntactically defined 
justification operation techniques requires machine construct exploit standardised collection auxiliary lemmas datatype 
greatly facilitated technical developments interest right ffl convenient definition equality relaxed formulation rule allowing elements different types compared equivalent usual equality plus axiom uniqueness ffl type theory oleg incorporates incomplete objects accounting holes entirely typing judgments requiring notion explicit substitution manage scopes 
substantial prototype implemented extending proof assistant lego lp 
number programs developed way example 
chiefly increased expressivity dependent datatypes shown capture standard order unification algorithm class structurally recursive programs removing need termination argument 
furthermore elimination rules specifying components program simplifies significantly correctness proof 
writing thesis long hard struggle done great deal friendship support 
official supervisor rod burstall constant enthusiasm mine times 
rod achieved managed happy 
pleasure part lego group lfcs 
slightly official supervisors successively james mckinna goguen martin hofmann deserve gratitude 
hope done justice 
word go randy pollack implementation lego code built mine 
friends family constant source love encouragement 

express appreciate lived years 
phil carsten melanie cat shall profoundly grateful 
friendship treasure 
declaration declare thesis submitted previous degree 
table contents chapter overview 
thesis context 
implementation 
chapter oleg type theory holes oleg core 
oleg development calculus 
positions replacement 
state information order 
life hole 
displaying oleg state 
basic component manipulations 
moving holes 
refinement unification 
discharge permutations 
systems explicit substitution 
sequences telescopes families triangles 
chapter elimination rules refinement proof propositional equality definition deferred 
anatomy elimination rule 
examples elimination rules 
legitimate targets 
constraints 
simplification coalescence 
fix 
abstracting patterns goal 
constraints inductive proofs 
elimination tactic 
preparing application 
targets 
constructing scheme 
proving goal 
tidying 
example nneq 
constructing nneq 
proving 
proving 
proving rules 
chapter inductive datatypes construction inductive datatypes 
simple inductive datatypes nn 
parameterised datatypes list 
datatypes higher order recursive arguments ord dependent inductive families fins 
inductively defined relations 
record types 
compendium inductive datatypes 
sigma types reinventing 
tactic 
constructing case fix 
case analysis datatypes relations 
guarded fixpoint principle 
chapter equality object level unification nearly inductive definitions equality 
martin lof identity type 
uniqueness identity proofs 
john major equality 
equality sequences 
relationship 
order unification constructor forms 
transition rules order unification 
algorithm constructor form unification problems 
conflict injectivity 
cycle 
brief look constructor form problems 
chapter pattern matching dependent types pattern matching alf 
interactive pattern matching oleg 
computational aspects elimination 
conservativity pattern matching oleg 
constructing programs 
recognising programs 
recursion spotting 
exact problems 
splitting problems 
empty problems 
extensions 
functions varying arity 
exotic recursion 
chapter programs proofs concrete categories functors monads 
records categories 
records functors 
records concrete monads 
substitution untyped calculus 
lift thin thick 
substitution monad splits renaming functor 
correct order unification algorithm 
optimistic optimisation 
optimistic unification 
dependent types rescue 
correctness mgu 
substitution tells occurs check 
positions 
check 
comment 
chapter 
appendix implementation bibliography index chapter philosophers merely interpreted world various ways 
point change 
marx engels computer programs expected sense 
fact seldom expected say computer programmers expected sense 
understandable programming primarily form giving orders 
grounds optimism 
programmers really want genuinely stupid orders obeyed understand sense able shorter orders need 
benefit comes sense programmer mind manifesting explicitly program 
named variables looping constructs functional abstraction method encapsulation evolution programming languages greatly facilitated programmer actively seeks sense 
particular type systems allow sense compulsory industrial programming languages 
purpose typing indicate number bits left array subscript shifted strongly typed languages java genuinely reduce machine faces human 
objective promoting sense programs pursued research documented thesis 
main purpose show advantage dependent type system lends cause principled programming 
briefly principal contributions ffl oleg type theory holes metavariables standing missing parts constructions explained entirely judgments calculus state theorem prover may represented valid judgment ffl identification added conventional type theories underlying lego coq facilitate pattern matching dependent types implemented alf ffl systematic view elimination rules leading derived elimination rules characterise specify programs compact powerful way overview thesis records development technology support functional programming dependent datatypes pattern matching structural recursion intensional type theory 
technology suggests novel tools techniques reasoning programs 
give overview identifying innovations 
open account theorem proving type theory oleg luo ecc luo includes account holes terms 
lot theorem proving thesis 
done hand 
done machines manufacturing exploiting standard equipment working datatypes equational problems 
feel obliged give precise treatment theorems theorem proving 
novelty holes handled variables accounted binding entirely judgments system 
system workable core calculus terms embedded development calculus hole bindings core term scope hole may refer hole 
effect separation prevent troublesome interaction computation holes 
consequently terms called partial constructions development calculus enjoy property may safely replaced type remarkably behaviour dependent type system 
result theorem proving oleg consists exactly editing oleg judgments ways guaranteed preserve derivability 
oleg restrictive systems explicit substitution restrictions hinder slightest 
inductive datatypes shall concerned lego coq coq alf mag 
elements introduced constructor symbols recursive arguments satisfy strict positivity condition 
recursive computation inductive proof provided old fashioned elimination rule style 
necessitated innovation principled tactical support rules documented chapter 
technology restricted elimination rules arising datatypes 
contribution thesis methodology program verification lies derived elimination rules capture leverage exerted piece information arbitrary goal 
abstraction predicate induction name oleg tribute randy pollack proof assistant lego 
new treatment partial proofs required minor rearrangement 
known metavariables existential variables question marks names principle return type datatype fold operator point way 
piece information ask deduce ask deduce want 
tactics chapter developed support datatype elimination rules allow exploit wide class rules similarly type 
give numerous examples capturing behaviour programs way believe demonstrate efficacy policy 
understand elimination rules may give proper attention inductive datatypes 
particular may chapter technology derive conventional eliminator pair alternative usefully treatment case analysis recursion structurally smaller terms 
gives effectively presentation case fix constructs primitive notions coq 
equivalence established eduardo gim minor adaptations required construction 
chapter unremarkable 
case analysis restricted instance inductive family henceforth subfamily inevitably involves equational reasoning 
example may define family lists indexed length analysing instance constrained contain nonempty lists rule nil constructor list generates satisfy constraint 
generally constructor represent object level constraint return type unifies subfamily analysis 
constraints similar unification problems arise unfolding transformations logic programs ts gs 
msc involved systematic solution simply typed problems constructor form implemented form tactic mcb 
chapter extends treatment dependent types 
necessity requires compare sequences terms elements may propositionally equal computationally distinct types area proved troublesome intensional type theory 
new slightly relaxed definition equality scales sequences significant attendant 
turns equivalent traditional inductive definition augmented axiom identity proofs unique 
equipped may easily prove datatype confusion property constructors injective disjoint form single elimination rule 
give systematic proof datatype contains cycles 
lemmas justify transitions unification tactic 
coq thierry coquand characterises class pattern matching programs dependent types ensure patterns cover possibilities deterministically recursion structural 
class programs available unrestricted recursion alf system mag 
chapter contains principal metatheoretic result thesis confirming class programs constructed traditional datatype elimination rules uniqueness identity proofs 
meta level unification coquand presentation performed object level tactic developed chapter 
way illustration thesis closes sub examples verified dependently typed programs 
concern syntax ffl substitution untyped terms shown properties monad ffl structurally recursive order unification algorithm shown compute general unifiers understood type theory community may really sense terms relative context explains free variables 
examples express sense directly data structures gain reflected correctness proofs 
example new literature program synthesis verification 
substitution treated bp ar polymorphic recursion include simply show dependent types easily offer functionality recourse index data type level 
existing treatments unification turn externally imposed termination ordering 
novelty indexing terms number variables may occur gain access computation index capture program structural recursion 
witness benefit program captures precisely sense algorithm implements 
developments adopt methodology characterising behaviour subprograms means elimination rules 
establishing program correctness sufficiently easy presenting proofs cut corners monotonous extreme 
length linearity thesis 
hope nearly trouble read write 
thesis context press give account certainly spring tree rock penelope 
odyssey homer little known belfast pattern matcher 
spent life surrounded pattern matching implemented pattern matching year am doing phd pattern matching rod burstall 
fortunately mother computer scientist 
martin lof type theory established convenient arena computational regularly fed logical lions relatively emphasis placed type theory basis constructive logic programming 
comparatively boring programs written comparatively interesting theorems proven 
expressiveness type theory promises benefit 
things changed 
induction natural numbers explicitly different guises pascal fermat seventeenth century implicitly lot longer 
frege dedekind independently gave inductive definitions explanation impredicative set theory 
structural induction widely mathematical logic cf mp time burstall introduced notion inductive datatypes programming elements built constructor functions taken apart case analysis bur 
inductive datatypes escaped programming languages mcb bms arrived type theory cpm 
expressive indexing power dependent type theory giving natural home inductive families types dyb 
example hinted polymorphic datatype list constructors nil list list cons list usefully indexed way vectors lists length vcons sn typing strong tell vector empty potentially disastrous destructive operations head tail safely defused 
significant ways dependent datatypes troublesome question datatypes shall shall compute 
datatypes families proposed thierry coquand christine paulin mohring peter dybjer integrated type theory number variations 
zhaohui luo utt luo closest traditional presentation equipping families safe strictly positive schemata elimination constants doubling induction principles recursion operators 
conservative treatment appropriate forms behaviour established goguen gog 
unfortunately recursion operators somewhat unwieldy instruments programming added natural numbers lego pol tell 
thierry coquand presentation pattern matching dependent types coq implemented alf system lena magnusson mag shown conventional type theory hofmann streicher implies uniqueness identity proofs hos 
pattern matching full language inductive families contingent unification needed check constructor manufacture element family instance 
unification escapes simple order syntaxes developed instinct survival survive 
father lisp pattern matching programming language escaped inductive datatype 
subsequent systems alf family agda hal cautious datatypes allow order generous facilities working 
particular question unification avoided forbidding datatype constructors restrict return types portion family empty vectors nonempty vectors 
families declared similar manner datatypes functional programming languages data family con indices distinct variables indicating constructor con domain types range entire family pattern matching instantiated subfamily just instantiates types constructors generating arbitrarily complex unification problem 
sensible restriction sound motivation 
serious forbidding example formulation identity type reflexivity constructor restricts return type subfamily indices equal 
decompose elements datatypes indices instantiated agda datatype indices go 
power lost way computing types data 
example type vectors datatype agda computed length index sn theta vect kind computed type data way measured indices elements finite contain finitely constructor symbols se decompose indices recursively go founded ordering 
place setting inductive families indices stock exchange go 
practical limitations system require exploration 
certainly removal unification pattern matching process considerably straightforward implement grasp 
implemented outside protective environment interactive proof assistant lennart augustsson dependently typed programming language cayenne aug 
cayenne allows general recursion typechecker requires boredom threshold prevent embarrassing nontermination 
course programs sense typecheck interesting examples appear ac 
hand examples implementations order unification happens expressed stand restricted system 
ana bove treatment bove shows standard haskell implementation algorithm imported systematically type theory 
general recursion original replaced powered recursion induct phrase defined accessibility predicate expressed alf successors 
implementation chapter thesis dependently typed exploits power constraining constructors represent substitutions association lists way captures idea assignment gets rid variable 
variables finite sets indexed size fin terms trees number variables tree association lists alist represent substitutions variables terms anil alist fin sm tree alist alist sm having said am quite sure gravity powered unification implemented agda restricted type system 
association lists application substitutions delayed incremental 
happy apply substitutions straight away functional representation suffices 
alist type stands useful data structure context extension reasonably hope represent datatype 
coq system coq inductive families types strictly positive schemata 
moved away traditional step elimination operator suggestion thierry coquand divide elimination case analysis operator constructor guarded fix point operator 
eduardo conservativity argument gim strong normalisation proof case lists gim proved strong normalisation general case gim 
bruno barras formalised system bar including decidability typechecking 
case fix separation sensible practical technology thesis working effectively luo utt luo start traditional step rule mechanised derivation case fix datatype 
follows applies coq lego 
noticeable gap programming case fix coq programming pattern matching alf cayenne 
gap addressed cristina cornes cor 
identifies decidable class second order unification problems captures pattern matching programs viewed collections functional equations 
solving problems mechanically extended coq substantial facilities translating programs terms case fix 
takes form macro cases allows pattern matching style decomposition multiple terms unconstrained inductive families vect vectors arbitrary length combines fix yield recursive function definition style ml 
full gamut dependent families defined adopted agda solution problem computing 
task implementing pattern matching constrained instances inductive families subfamilies vect sn nonempty vectors leaves 
leaves arrive 
attempted duplicate machinery translation equational programs 
concentrated problem case analysis subfamilies gap dependent pattern matching alf 
mentioned known time dependent pattern matching conservative implies uniqueness identity proofs hold hofmann groupoid model type theory hos hof type refl refl refl refl points real connection pattern matching power equality type theory 
case analysis inductive subfamilies known inversion necessarily involves equational reasoning constructor check return type unifies subfamily analysing 
unification problems resemble arise unfold fold program transformation bd ts gs 
treated meta level alf coq mag 
cristina cornes progress area tactics inverting inductively defined relations simply typed data coq ct 
msc project import technology lego 
explicit separation hand splitting family constructors subfamily constraints object level equations hand simplification constraints 
implemented complete order unification algorithm object level equations constructor forms simple types mcb 
uniqueness identity proofs contributes directly extension firstorder unification algorithm dependent types yielding explicit object level solutions class unification problems alf handles implicitly 
gap programming datatypes lego coq pattern matching alf bridged 
building bridge involved engineering problems development feel fascinating technology 
particular tactic built deploying elimination rules inductive datatypes potential far purpose 
begun explore rules style specifying proving properties programs thesis contains examples 
implementation implemented prototype version technology described thesis extension lego 
contributed benefiting full analysis set 
emphasise stage prototype better 
fact alf rejects cyclic equations unification problems hard disprove years 
technology implemented support example programs proofs thesis 
built oleg assistance checked lego core oleg subset lego type theory randy pollack typechecker runs unchanged 
hand crank techniques subsequently shown developments described thesis honest account real machine proofs 
chapter oleg type theory holes just started reading chapter nearly finished writing 
started long time ago intended unremarkable summary familiar type theory largely need notational conventions thesis 
despite best intentions chapter contain original describes type theory oleg gives account incomplete constructions quite different existing 
say outset set invent thing 
years writing programs construct lego proofs standard datatype equipment constructor injectivity forth tactics deploy 
began msc direct synthesis proof terms syntax painful 
time went tools building looked theorem prover 
eventually penny dropped synthetic programming proof clever people better busy people stupid machines need analytic framework sound treatment refinement 
previously ad hoc assortment syntactic oleg type theory machines people 
oleg manifest code long chapter 
put help spare parts randy pollack lego code 
lego treatment metavariables remarkable allows remarkable fact 
scope quite managed properly reliability lego lies final typecheck completed term 
consider business repair problem looking convenient way represent holes mechanical manipulation 
hit idea binding holes context required little alteration term syntax operations refinement turn unknown premises subgoals just matter turning treatment holes strongly dale miller explicit binding existential variables mixed quantifier prefix unification problems mil mil 
time explicit substitution issue 
wanted maintain scope holes technology alf family mag re engineer lego syntax re duction mechanism typechecker 
turned adaptations minimal 
profound reason explicit substitution relies ingenuity oleg relies 
repairing troublesome interactions holes computation propagating bits stack term structure oleg simply forbids 
keep suspense longer 
oleg consists computational core luo ecc luo local definition sp sigma types wrapped development calculus way extended ml kst wraps core standard ml mth 
reason separation precisely aforementioned respect holes computation 
extended ml treatment holes profits fact simple type systems safe replace term placeholder type 
way core terms dependent type theory hope replacement property counterexample see section hold terms partial constructions oleg development layer 
single metatheorem oleg successful reconstruction refinement proof know 
oleg core definition universes identifiers bindings terms universes prop type natural number identifiers allow countably identifiers 
define families bindings terms indexed finite set variables ae permitted appear free 
motivation ensure identifiers meaningful 
set variables sets bindings extending terms defined inductively follows fxg motive prepare ground application dependently typed functional programming syntax chapter 
natural deduction best style presenting indexed inductive families 
binding means attaching identifier properties type value behavioural attributes may interested 
structural linguist saussure point identifiers words intrinsic significance 
variables hand signs 
binding creates sign linking signified 
syntactically binding binding operator followed identifier followed sequence properties introduced special piece punctuation type value 
binding operator determines computational role variable 
encourage think bindings important syntactic entities right combinator attaches binding scope convention extends rightwards far possible 
oleg core binding operators comprise usual written pi universal quantification functional abstraction 
pronounced representing local definition 
describe bindings bound variable occurs scope 
usual application indicated juxtaposition associates leftwards 
shall denote variable occurs free term shall freely abbreviate identical consecutive bindings distinct variables may abbreviated commas example ff convertible terms identified representing consequent notion syntactic identity 
denote result substituting free occurrences formally prefer live de bruijn indexed world deb informally luxury names associated luxury ignoring issue variable capture 
having introduced syntax abuse suits 
machines suppress inferrable information machines demand 
sure machines catching implicit syntax pol 
propose give mechanistic account arguments shall omit parentheses shall drop ad hoc notations shall introduce purpose purely presentational 
definition contexts judgments set ctxt contexts defined inductively hi ctxt gamma ctxt gamma gamma gamma ctxt gamma ctxt gamma gamma gamma ctxt note may treat context set variables gamma set terms gamma 
gamma ctxt gamma set gamma judgments 
gamma may assert holds writing gamma gamma contains context validity typing judgments valid gamma gamma gamma presentations context assignment types identifiers 
value assignments permitted 
indulge slight abuse notation write bindings context effectively annotating entries binding operators additional properties 
seen data structure example implementation lego context stack bindings 
recover formal contexts defined simply forgetting extra annotations 
shall need check variable particular property may 
example write gamma gamma context property type regardless annotations 
explore term variable encounter meaning stack bindings passed 
variable name binding 
names arise social phenomenon just story naming things gives power 
define computation respect context 
feel 
quite reverse syntax sense relative context explains signs 
goguen typed operational semantics type theory gog necessarily naturally involves context significantly reducing cost metatheory 
contextual information requires active typing passive computation accident ecc inevitable restriction 
goguen typed operational semantics higher order subtyping cg exploits potential full 
mantra gamma go 
feel strongly provoked exploit potential reveals increasing activity context computation 
real programming language implementations keep values stacks 
may employ usual technique supplying number contraction schemes indicate actual computation steps notion compatible closure allows computation occur term 
definition contraction schemes oleg contraction schemes shown table 
useful know colour variable fi gamma fi ffi gamma gamma ffi gamma table contraction schemes gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma delta gamma gamma delta gamma gamma delta gamma table compatible closure gamma gamma gamma gamma gamma gamma prop type gamma type type gamma gamma gamma table empty hi valid declare gamma type gamma bx valid define gamma gamma valid prop gamma valid gamma prop type type gamma valid gamma type type var gamma gamma valid gamma gamma imp gamma prop gamma prop gamma type gamma type gamma type abs gamma gamma app gamma gamma gamma gamma gamma gamma gamma gamma table oleg core inference rules metatheorem church rosser gamma implies existence common reduct gamma gamma metatheorem strengthening gamma gamma gamma gamma implies gamma gamma metatheorem subject reduction gamma gamma implies gamma metatheorem strong normalisation gamma ensures strongly normalising 
metatheorem cut gamma gamma implies gamma gamma table metatheoretic properties subterms susceptible fi ffi contraction schemes respectively fi ffi redexes 
note property ffi redex implicitly context dependent 
term normal form contains redexes 
helpful think fi ffi waste disposal 
fan fritz lang classic silent film metropolis imagine computation sounds fi reduction sounds shuffling ffi reduction sounds filing cabinets pops sudden 
definition compatible closure delta contraction scheme compatible closure delta henceforth shall elide context casual discussion 
write union labelled compatible closures finite transitive closure 
term strongly normalising admits finite sequences reductions 
smallest equivalence relation closed called conversion denoted 
observe binding allows avoid meta level substitution describing computation 
explanations identifiers activated putting context propagating terms 
traditional fi contraction noisier reduction sequence fi ffi delta delta delta luo combine notions conversion universe inclusion type cumulativity preorder respect definition cumulativity cumulativity relation defined inductively table 
luo luo shows antisymmetric partial order respect 
fact typed term gamma principal type sense gamma gamma consequently habit omit index type uncontroversial phenomenon known typical ambiguity hp 
practice cumulativity constraints required ensure consistency development stored finite directed graph checked offending cycles 
system inference rules validity contexts typing judgments oleg core calculus table 
formulation slightly unusual involves meta level substitution types job done computational behaviour local definition performed rule 
usual metatheoretic properties see table hold expect 
contribute insight unavailable luo treatment ecc luo 
poll shown extend dependent type systems local definitions sp 
church rosser property follows parallel reduction argument tait martin lof takahashi tak 
subject reduction strengthening cut follow induction typing derivations differing minor details proofs ecc 
omitted weakening list special case monotonicity property shall prove section 
strong normalisation oleg core direct consequence strong normalisation ecc 
style poll type preserving translation maps oleg terms ecc terms adding apparently pointless fi redexes step oleg reduction sequence simulated step ecc reduction translation 
consequently infinite reduction sequence typed oleg term infinite reduction sequence typed ecc term know thing exists 
interesting aspect oleg development superstructure 
give attention 
oleg development calculus put hole hole don belong 
bernard holes stand parts constructions invented 
hole tell things candidates may fill ffl type ffl context gamma variables may employ may ascribe properties hole way convenient abbreviation 
point safe fill hole gamma solutions locally checkable working holes practicable 
mentioned treatment holes simple type systems greatly helped fact terms leak types 
consequently subterm may safely replaced type affecting type containing term local hole solutions just special case 
holes may safely represented unlabelled symbols typing places dependency 
may help think translation ecc tying old tin cans terms ecc reduction noisy oleg reduction 
application dependently typed function argument term result type replacement property fails 
consider example context defining equality symbol natural numbers nn nn prop refl nn sym nn may reasonable infer sym 
refl may instantiate retain typing instantiate sym arguments appear required type refl 
represent information sym 
refl signify natural way choose give single sign 
invent new binding operator 
pronounced hole introduce variables standing holes proof instantiated common candidate appropriate type 
may add context nn infer sym refl think suitable candidate may solve hole changing binding say nn typing stand 
danger gone away 
quite reasonably infer sym nn nn refl nn nn nn binding nn syntactically identical regard bound variables distinct scope 
free solve avoid situation 
point wrong holes leaking types disaster strikes permit bindings 
oleg development calculus ensures bindings safe places may solved independently 
arises corollary general replacement property just simply typed case 
introducing explicit binding operator holes oleg follows dale miller lead mil mil representing state system judgment context mixed prefix explains variously quantified variables involved 
oleg development calculus represents store theorem prover directly judgment level 
theorem provers tend contain kinds information ffl assumptions ffl proved theorems ffl claims ffl partial proofs claims components represented form binding respectively definition 
state context bindings 
terms development calculus called partial constructions 
definition states components partial constructions states state hi state delta state delta state components gamma partial constructions fxg observe partial proofs guesses attached holes symbol indicating computational force bound values attached 
may view state delta core context forgetting properties variable 
particular means guesses invisible core 
states delta development calculus equipped delta judgment forms delta corresponding core 
delta may assert holds writing delta fl delta valid delta delta delta delta delta form typing judgment contains important piece information development calculus extend type system language terms 
holes bound right 
serves emphasise analytic view types come terms explain terms types search terms inside types 
table shows new inference rules 
note core judgments delta validate delta viewed core context guesses delta checked 
accounts extra delta fl valid premises appearing rules 
analogous metatheoretic properties table continue hold extended system 
parallel reduction treatment church rosser derivation inductions subject reduction strengthening cut easily adapted 
strong normalisation development calculus reduces strong normalisation core translation argument adds assumption imagine type root context turning bindings bindings hole guess imagines translated guesses bound values 
core terms embedded partial constructions 
forgetful interpretation states core contexts allows variables appear partial constructions term rule 
effect core development separation restrict holes may bound 
partial construction containing bindings said pure expressible core term 
pure terms may course refer variables bound context 
particular bindings occur inside applications bound values 
ensure interaction computation 
bindings allowed appear guesses partial constructions attached holes potential solutions 
bindings guesses merely typechecked annotations computational behaviour effect subsequent typing 
fact contraction scheme partial construction level contraction removing spent value bindings 
delta fl computations occur embedded terms closure rules 
course ffi reduction terms exploit components context 
state validity empty hi fl valid declare delta fl valid delta type delta cx fl valid define delta fl valid delta delta fl valid construct delta fl delta fl valid typing partial constructions term delta fl valid delta delta fl abs delta fl delta fl delta fl delta fl hole delta fl delta fl guess delta fl delta fl delta fl delta fl delta table development calculus inference rules delta delta delta fl delta delta delta delta fl delta delta delta delta fl delta delta delta delta fl delta delta delta delta fl delta delta fl delta delta fl delta delta delta delta fl delta delta delta fl delta delta fl delta delta delta crucial role played side conditions hole guess rules 
insist term binding may exploit bound variable type may 
allow bindings types 
furthermore restrictions simply reflect natural ways holes arise refinement style proof claims motivated need construct inhabitant type know 
inability leak types partial constructions share terms simply typed systems 
expect replacement property follow easily exactly manner replacing typing subderivation replaced term 
positions replacement positions pos formed partial constructions deleting construction 
position pos delta induces context extension collects components deletion point lies 
delta denotes partial construction obtained inserting deletion point 
positions defined inductively follows definition positions gamma ffi pos pos fxg pos pos fxg pos ffi delta ffi delta delta delta delta delta delta delta delta delta crucially derivation delta fl follows subderivation delta fl may compose positions writing position obtained replacing ffi clearly metatheorem replacement delta fl follows delta fl delta fl delta fl proof proof induction derivation delta fl case analysis position 
cases position ffi typing derivations yielding exactly typing need strength induction position nontrivial 
ffl term ffi position ffl abs delta fl delta fl delta fl suppose delta fl inductively delta fl delta fl ffl hole go component way abs 
ffl guess position goes component argument applies 
position goes guess delta fl delta fl delta fl suppose delta fl inductively delta fl delta fl note typing side condition affected change guess 
claim simplicity theorem utility misunderstand pragmatics theory 
utility simplicity 
state information order shall need little apparatus ready reconstruct theorem proving oleg 
particular shall need notion progress oleg states 
idea state delta improves delta contains information delta simulate behaviour variable delta 
definition state information order valid states delta delta say delta delta ffl delta delta delta ffl delta delta ffi delta clearly preorder 
notice inserting new components delta moves order 
replacing type binding guess binding appropriately typed value 
furthermore guesses may added holes removed modified long intended type respected replacement property helps check modifications 
hand variable computational behaviour may take away 
delta delta viewed variable sets delta ae delta delta ae delta ordering preserves observable behaviour state expect find holds metatheorem monotonicity delta delta delta delta fl implies delta fl proof generalise little delta delta delta delta fl implies delta delta fl delta gamma implies delta gamma provided delta captures variables delta gamma allows easy induction derivations 
definition shall acquire exactly components need replace subderivations look types delta perform ffi reductions delta simply validate delta interesting cases ffl var rule variable typed lies delta definition tells derive type delta result follows inductive hypothesis replaces prefix premise var rule recovers type unchanged suffix 
ffl validity rules context validated delta replace entire derivation delta valid 
context strictly contains delta premise context contains delta inductive hypothesis applies 
ffl rule inductive hypothesis supplies modified premise 
computational side condition definition enables replace ffi reduction variables delta equivalent conversion valid delta life hole basic replacement operations act basis working holes 
claim birth delta fl delta type delta fl try marriage delta fl delta fl delta fl regret divorce delta fl delta fl solve death delta fl delta fl pure clear rules admissible 
may read justifying replacement position construction premise construction 
monotonicity justifies corresponding steps insert modify new components state 
effectively claim allows insert new hole position 
holes naturally born way claim holds order develop proof hole typing rule holds matter course 
try regret steps allow attach discard guesses repeatedly hopefully judgment improves go round cycle 
guess contains components core term death journey transition hole solved local definition 
rules allow extend notion information order positions 
gives means relate operations focused particular position amount information available position 
definition position information order valid states delta pos delta position information order delta fl inductively rules refl delta fl trans delta fl delta fl delta fl claim delta type delta fl try delta fl delta fl regret delta fl solve delta fl pure admissibility basic replacement operations ensures delta fl ffl delta fl valid delta fl valid delta delta ffl delta fl delta fl may reconstruct familiar tools refinement proof operations manipulate oleg states preserving validity 
assurance double sure stage state validity judgment 
direct correspondence judgments type theory states machine admissible rules tactics quite solid basis build proof assistant 
displaying oleg state prototype implementation oleg written programs people 
thesis full oleg proofs shall need way see doing 
think display oleg state 
propose list components state vertically local bindings literally metaphorically global ones 
binding give binding operator identifier table showing property indicators associated terms types values 
serve cause brevity relax vertical alignment combining bindings identifier treatment 
term viewed subterm context binders allow format contexts way main state write subterm directly underneath 
example state shown right 
initial assumptions introduce type nn natural numbers constructors primitive recursion operator 
shown partial development addition function 
observe completed successor case introduced binding zero case unknown bound 
partial proof bound indicating contains bindings duplicated 
note binding enables inspect terms plus stuck beneath application rec 
nn type nn nn nn rec phi type oe phi oe phi phi nn phi plus plus nn nn plus plus nn nn nn plus oe nn nn nn nn rec nn nn plus plus nn nn nn general state displayed tree forking nodes bindings 
binding edge points underneath scope point sideways terms attached property indicators 
sequence components state form spine tree vertically aligned left hand side starting root underneath edges component reached 
example spine consists bindings nn rec plus 
subtrees reached going sideways spine representing example type rec incomplete development plus terms partial constructions leaves 
seen find partial construction may replace type 
want see tree large state fully expanded 
imagine mouse draw clouds round uninteresting parts proofs introducing cloud symbol state display 
double click cloud restore expanded tree 
expand detail interested keeping connected subtrees uninteresting proof obscured clouds 
instance simply interested unsolved goals example reduced picture 
plus plus nn nn interface obscuring irrelevant details focus subtree displaying full path back root 
allow subtrees containing clouds obscured bigger clouds structure lack interest expand larger cloud return part development bits marked dull remain hidden 
visualise state visualise tactics direct manipulations displayed image 
symbol tangible presence binding 
operations affect symbol addressed mouse binding 
shall soon find dragging bindings place forth 
advantage making bindings explicit afford visual metaphors 
basic component manipulations shall tactics qualified state transitions 
validity final state follow initial state side conditions 
table shows basic tactics manipulating components outer level oleg state 
tactics justified monotonicity cut abandon standard metatheoretic properties 
side conditions may represent replacement tactic instantiating acquire tactics position development 
consequently may apply claim abandon try regret solve cut guesses 
free create destroy preserve type partial construction 
delta delta delta delta delta fl delta fl course want operate little sophistication edit partial constructions directly try regret 
established machinery making holes appear disappear place 
just cinema machinery fast create illusion movement 
assume justify claim delta delta delta delta delta delta delta delta delta delta delta delta delta type delta type try regret solve delta delta delta delta delta delta delta delta delta delta delta delta delta fl pure cut abandon postpone delta delta delta delta delta delta delta delta delta delta delta delta delta table basic component manipulations attack intro intro 
retreat raise raise 
table moving holes types moving holes traditionally may introduce term functional type filling hole binding body new hole context new hole contains argument function 
may animate manoeuvre pretending binding moved argument shortened type 
familiar manoeuvre undoes effect generalising hole functionally assumptions proven 
binding moves outwards binding assumption type gets longer 
miller calls raising mil 
may shuffle holes bindings appearing types 
moves collected table 
notice tactics replace constructions form body arbitrary introductions affect expression 
fortunately hole form ready attack tactic 
raising tactics restriction 
allow move holes assumptions definitions functional go outermost guess 
retreat tactic may extract development 
partial construction pure raising retreating remaining bindings 
refinement unification intros tactic progress filling hole term 
section builds tactics fill holes applications 
simple motivating example say developing double function natural numbers terms plus 
double nn nn may introduce argument attack intros 
double nn nn point decide solve adding numbers 
decided numbers inserting holes numbers 
claim double nn nn nn solve plus cut 
filled old hole plus applied new holes refined plus 
double nn nn plus complete development refine double nn plus tactic nave refine solves hole function applied unknowns represented new holes 
combination claim try solve 
note explained length argument sequence chosen 
leave user 
decidable simply try successively longer sequences afforded type works run arguments 
nave refine example effectively solved nave refine plus nave refine nave refine simple types expect sufficiently powerful real dependently typed setting 
consider admittedly somewhat artificial problem 
find careful examination shows derivation 
simply nave refine mey proves nn nn nex nn nn mey start building application binding 
solve types xen mey convertible complete refinement 
need unify types 
note unification need just sided matching need infer values holes goal just unknown arguments 
nn nex xen nex mey thesis place discussion unification proof search literature pym 
purposes similar power order unification normalised terms prove adequate 
oleg explicit bindings holes assumptions support various operations permute suggest miller technology unification mixed prefix mil imported easily 
imagine buying pre existing unification tool drive tactic shown 
unify delta delta delta delta delta fl delta idea unify solves holes new ffi reductions added give point desired temporarily stored binding filled value note unify creating new holes unusual order algorithms 
require unification process terminate helps 
may build phase tactic incorporates unification refinement process 
unify refine 
delta delta 
unify position nave refine necessary specify arguments advance 
provided willing wait unification attempts may simply start keep trying successively unification succeeds run 
exactly behaviour lego notorious refine tactic 
alternative search behaviour precise drag drop technique 
imagine mouse action picking hypothesis suffix functional part type dropping hole 
arguments hypothesis point selected ones holes unify refine 
familiar children toy consists various holes different shapes top 
toy comes number blocks object exercise post block correct hole 
order child refinement tactic takes form blue plastic hammer 
initial phase connection shape block shape hole phase characterised violent 
learned lego undergone similar experience 
lego tries quite hard keep going applying weak head normalisation step attempt reveal fresh binding 

delta delta delta delta delta delta delta delta 
delta delta delta delta delta delta delta delta table discharges discharge permutations complete reconstruction basic theorem proving oleg technology shuffling components 
fairly clear may permute components state way preserves dependencies 
dependency arise may reorder components account introducing appropriate functional behaviour 
particular allows discharge assumption making follows functional 
lego implements transformation discharge tactic 
may reconstruct piecewise manipulations table 
may read discharges pulling binding binding just cinematic illusion 
course proven creating earlier binding expressing terms 
monotonicity may permutations components components 
may permutations deletions argument types functional holes long break dependencies 
see table 
bracket moves raising similar permutations deletions arguments introduced 
swap independent delete unused table permuting deleting arguments systems explicit substitution time compare oleg treatment holes systems 
key issue cope holes leaking scope explanation 
lego ignores issue reaps consequent harvest instantiations typechecked may involve scope values detected completed proof verified 
oleg deals problem forbidding hole may escape scope scope may widened raising keeping dependency information explicit intact 
real comparison lies systems treat problem explicit substitution alf mag 
holes appear calculi underlying systems explicit binding 
context type hole recorded external 
design context coincides collection bound variables hole initial appearance computation may destroy coincidence explicit substitution required fix 
illustrates simple example 
suppose defined type context entry 
consider term 
told abstracted object 
hand may instantiate fi reduce get may fi reduce get instantiate commute show diagram 
xg 
fi fi 
xg trouble performing fi reduction introduces discrepancy term longer contains binding occurrence corresponding subsequent instantiation touch 
fact substitution implicit fi reduction passed stopping consider fact appear instantiated solution delay explicitly application substitution 
instantiated substitution may proceed 
repair leak scope attaching explicit substitution hole 
xg 
fi fi 
xg extra really kind binding maintains consistency remains function problem remains think function value remains applied 
oleg approach problem total situations cause trouble forbidden 
particular may bind holes inside application relationship fi reduction 
course state shown right 
guess computational force 
reduce widen scope raising retreating undoing leaving explicitly functional hole 
restriction 
assure give trouble course thesis 
point oleg offers genuine compromise ingenuity explicit substitution pain representing holes say skolem functions entire context holes need kept functional far computationally 
sequences telescopes families triangles chapter digress moment introduce important notational convenience serve abbreviate clarify follows 
frequently encounter sequences terms arguments functions indices type families 
wish avoid traditional number reasons ffl wide ffl introduces subscript frequently irrelevant ffl binding syntax involves significant dots throwing dots cause confusion sequence favour de bruijn telescope notation deb 
sequence indicates finite empty sequence terms primitive monoidal urge composition operator empty sequence 
de bruijn explains give sequence type 
simply typed setting just write things little complicated dependently typed world values earlier terms sequence affect types terms 
afford lose dependency information incorporate kind placeholder type sequence notation 
definition telescope set variables containing fx gamma telescope abbreviates abbreviates 
define sequence types relative sequence identifiers bound turn stand placeholders earlier values types 
example telescope type prop represents triple respectively type predicate proof elements satisfy may exploit telescopes sorts circumstances 
example telescope judgment gamma abbreviates conjunction judgments gamma gamma 
gamma gamma gamma binding abbreviates sequence bindings giving type abbreviates corresponding bindings similarly binding operators 
may speak sequence bound variables having telescope speak single bound variable having type 
shall omit telescope variables necessary avoid ambiguity 
essential clarity shall attach placeholder variables types situ naming making example type type term telescope comes notation shrinking power inspired kind telescope nelson put blind eye 
appropriate metaphor abbreviating dependent type sequence structures opera hats concentric cylinders telescope lip constrains cylinders 
optical behaviour telescopes helpful 
broadly speaking longer optical telescope smaller field view greater magnification 
similarly extend type telescope new type acts new constraint collection inhabiting sequences visible telescope smaller informative 
sense type telescopes instantiate placeholder acquire specific telescope shorter 
definition telescope application telescope application telescope observe notion application telescopes may iterated term sequence way function application shortening telescope instantiating prefix 
telescope just de bruijn talks sequences fitting telescopes prefer avoid mixed metaphor 
note semicolon sequential composition leaves comma free usual role indicating multiple inhabitation type telescope 
means inhabits means concatenation inhabits introduce notation making multiple copies telescope 
definition iterated sequence telescope sequence terms telescope sequential composition copies sequence terms telescope containing free subscript sequential composition empty sequence telescope fg may say plus type nn intend curried form function 
observe similarly abbreviates 
telescope notation expressing types indices may define notion indexed family 
definition indexed family telescope type indexed family inhabitant example nn define finn finite datatype elements may say fin nn indexed type family 
may describe function decides equality natural numbers indexed family 
type family henceforth type family may define telescope definition free telescope type family telescope indexed type family free telescope example fin just nn fin visible telescope 
member family course 
note element telescope 
consider arbitrary telescopes 
simply phi type psi capture potential type dependency telescope may depend value type 
may represent type 
telescope types telescope type families type type type 
ft gamma type special telescope call type sequence inhabits triangle length triangle sequence represents telescope 
hard convert telescope triangle simply turn abstractions implicit telescope notation bindings capture earlier 
resulting triangle 
ft gamma correspondingly triangle telescope represents 
fx gamma ambiguity triangles telescopes represent 
easily spot side colon appear 
shall happily write type triangle represented telescope mean triangle type position 
elements type families apart unindexed type families types 
observe length triangle representing telescope triangle representing fs tg telescope application represented triangle coding function applications 
notational forms give syntactic power manipulate dependent type families inhabitants cleanly hardly effort simple types 
dependent type families feature strongly thesis sure glad convenience 
chapter elimination rules refinement proof rules tell establish new information 
elimination rules tell exploit know 
chapter identifies particularly useful class elimination rule develops tactic deploy refinement proof 
encounter things described elimination rules taught natural deduction undergraduate mathematician 
particular learned elimination rules propositional connectives 
phi 
phi phi recall thinking elim rules uncontroversial whilst somewhat confused convoluted behaviour elim 
caught supervisor building proof bottom blackboard upwards began see point 
elim tells exploit disjunctive hypothesis gain leverage phi trying prove 
elim rules somewhat comparison project conjunct arrange want conjuncts 
reformulate elim rules single rule style elim 
phi phi rule called uncurrying explicit see prove conjuncts technique original pair rules tacitly require reasoner apply 
key point 
elimination rules supply proof technique analyses hypothesis question give leverage objective may 
projective rules manage applicable motivated lucky trying prove projections 
mantra motivates means 
pretty boring connective choice prove get away projective elimination rules 
disjunctive hypothesis yields definite forward synthesis blocked analytically reasoning cases 
elim helps prove phi splitting task subtasks decomposing hypothesis 
way designed elimination rule analytical progress 
decompose objective goal specific cases favourite example principle mathematical induction phi phi 
phi sn nn phi rule explains prove arbitrary goal phi indexed natural number show proofs phi way numbers 
subgoals instantiate index specific natural numbers 
instantiation may provide concrete data need perform computation simplification large inductive proofs 
henceforth shall intend elimination rule kind rule arbitrary goal possibly abstracted indices 
characterisation broad including rules eliminated 
may odd useful characterise progress arbitrary goal exploiting information 
examples bear mind impredicative encodings true proposition absurd proposition respectively phi prop phi phi phi prop phi 
exploits information cause proving arbitrary phi consequently exerts leverage leaving phi subgoal 
derivable context contradiction indicates need establish phi want 
order exploit elimination rules abstracted indices need corresponding abstractions goal trying prove 
course obvious goal looks nn phi chapter largely devoted explaining abstractions obvious circumstances 
propositional equality definition deferred tools shall shortly require propositional notion equality 
conventional formulations awkward type dependency enters picture 
trouble instances type family indices convertible just propositionally equal type 
familiar definitions permit equations type forbid stating equality elements drawn instances family 
huet encounter similar problem formalisation category theory sh need state equality arrows domains computationally equal 
solution relax formulation rule equations arrows whilst supplying reflexive constructor 
care approach may extended commonplace propositional equality propose 
presenting definition stage motivation context shall defer treatment idea properties language describe 
familiar equality shall presume familiar symbol 
shall write 
experienced readers dislike suspense find definition chapter 
read look required behaviour go 
anatomy elimination rule establish notation elimination rules give names components 
presenting elimination rules raw types conventional natural deduction style relatively uninformative past cost 
section shall motivate hope clearer presentation arising blackboard conversation rod burstall 
important come systematic understanding rules shall need teach machines 
order sense elimination rule need know ffl eliminates target ffl family arbitrary goals proves scheme example mathematical induction right eliminates natural number proves goals form phi phi family propositions predicate nn 
phi nn prop phi phi phi sn nn phi mark target box 
tell phi scheme stands head rule return type 
want apply rule target marker tells select natural number eliminate stand place having done need goal appropriate scheme phi 
important type scheme prominently 
index types obvious 
may need precise type universe goal inhabit prop rule suitable propositional goals rule programming 
schemes types form call rule indices indexed telescope rule aperture 
shall see elimination rules thing different apertures 
shall see change aperture rule 
conventional proofs mathematical induction scheme called induction predicate 
shall need schemes predicates rules inductive 
phi applied arguments called patterns 
universally quantified variables appearing patterns pattern variables 
target selection instantiate pattern variables goal know build scheme 
mathematical induction pattern variable involved target requirement clearly fulfilled 
solid line rule cases proves phi applied case patterns sn 
subgoal specific assumptions appear dotted line horizontal cousin natural deduction vertical ellipsis 
involve phi case data 
described inductive hypotheses recursive calls 
visual aspect presentation intended convey idea cases elimination rule ghosts corresponding rules 
prawitz inversion principle captures relationship elimination rules natural deduction pra attributes idea gentzen gen expresses property follows eliminating symbol may formula terminal symbol dealing sense afforded symbol 
essence elimination rules show mimic structure hypotheses act 
mathematical induction shows phi imitate nn 
freely suppress implicit assumptions nn successor subgoal order strengthen resemblance 
mantra decomposition exposition construction 
describe elimination rules detail place discussion context exhibiting number variations theme 
examples elimination rules parameterised data structures lists parameterised elimination rules 
particular say elimination rule parameters hypotheses scheme cases types depend 
may interesting listed top rule 
type phi list type phi nil phi phi cons list phi note supply case datum explicitly despite appearance cons case pattern order emphasise imitation constructor 
class elimination rule construct thesis case analysis inversion principle 
notion rules corresponding inversion principle asserts rules exhaustive 
case rule inductive hypotheses 
consider way example nn suffix variant 
mm mn msn traditional clark completion cla presentation represents choice derivations disjunction existentially quantified equations 
mn sn disjunct rule schematic variables existentially quantified equations demanding proves inverted hypothesis premises hold 
construction somewhat mechanical explicitly constrains argument hypothesis constraint redundant case 
mcb gave standardised elimination rule presentation inversion essentially currying clark completion 
example generic class hypothesis mn inverted fact think induction inversion augmented recursive information 
phi prop phi sn phi mn phi parametric rule 
instantiated equations subgoals may simplified automatically 
approach somewhat clumsy easy apply scheme phi may proposition abstraction necessary 
shall shortly develop abstraction technology required exploit streamlined version indexed scheme removing need equational constraints parameters inversion principle differs clark rule aperture 
course suggesting systematic way change aperture elimination rule 
fact essence tactic chapter develops 
inv phi nn prop phi mm mn phi sn mn phi process simplifies constraints arising inversion critical fact constructors injective disjoint confusion property 
natural numbers plausibly choose derive peano postulates ffl nn sm sn ffl nn sn formulation injectivity essentially projective fashion awkward elim rules directly useful trying prove 
non unary constructors cons example problem gets worse separate head tail injectivity theorems single result yields tuple equations eliminate 
consequently injectivity inversion rule equation successors 
really just tuple version curried form predecessor equations hypotheses rule case 
turning constructors disjoint result think implies false false absurd proposition true discover elimination rule fortunate number cases 
shall show prove rules chapter 
phi prop phi sm sn phi phi prop sn phi think elimination rules solely belonging datatypes relations 
provide neat tools reasoning functions 
extension function relation total deterministic computational mode imposed 
equational presentation function corresponds set rules recursive calls inductive premises 
sense reason behaviour function corresponding elimination rule 
consider nneq function decides equality natural numbers 
shall see define recursive pattern matching equations shown 
nneq true nneq sm false nneq sn false nneq sm sn nneq mm corresponding elimination rule allows john mccarthy calls recursion induction mcc effectively packaging recursive structure nneq single induction principle 
phi nn prop phi true phi sn false phi sm false phi phi sm sn phi nneq proofs functions operate choosing right combination inductions case analyses arguments computation unfold 
recursion induction functions away apparent choice wrapping right combination derived rule targets applications function directly 
proof recursion induction principle follows construction function describes step step 
order proper recursion induction principle rule eliminating function application choose scheme phi abstracts application goal 
subgoal replaces application appropriate value 
abstractions usually unnecessary eliminating datatypes relations 
exactly abstraction behaviour required vary rule rule problem problem see infer reliably structure rule target 
user free indicate arguments abstracted case put box type scheme index abstraction attempted 
boxed indicates occurrences nneq functions typically searching testing character recursion induction close implementation really useful 
example regardless test works know nneq returns true equal false unequal arguments 
represent requirements extensional rules propositional equality equations may computational conditional rewriting lucky encounter applications nneq look left hand sides 
nneq true nneq false lucky 
imagine trying prove property program nneq computation blocked box reduce boolean value inside box numerals 
rewrite rule applies know equal 
remove blockage split problem cases nneq call returns true false respectively 
exactly behaviour inversion principle corresponding rewrite rules 
inverting nneq call yields cases arguments result true arguments differ false returned 
phi nn prop phi true phi false phi nneq boxing indicates nneq abstracted scheme 
consequently replaced subgoal true false 
cases reduces true case coalesced ffl ffl inversion requires effort extracting information characterisation theorems lego library nn nneq true achieve effect inversion need combine lemma projection boolean case analysis rewriting mechanism 
mantra invert blocking computation 
point simple 
rules construct information 
elimination rules exploit information 
serious weakness confuse purposes 
view equational specification wrong tool exploit properties program proof 
construction elimination rules especially invert blocked computations better tools purpose 
course thesis see point reinforced example example 
legitimate targets order refine goal elimination rule things ffl select target kind rule eliminates ffl construct suitable scheme goal shall discuss section issue requires comment impacts elimination rules place 
point order able select target know kind target rule eliminates 
define means legitimate target rule tell machine rule want tell may 
just seen different kinds elimination rule eliminating different kinds target 
elimination rule datatype eliminates arbitrary element type abstracted rule appearing concluding pattern nn phi inverting inductively defined relation eliminates hypothetical inhabitants relation pattern phi involves relation indices target proof mn mn phi elimination rule function specifically eliminates applications function arbitrary elements result type target appears patterns 
phi nneq diverse variations include double induction provide targets nested analysis 
way expect machine cope diversity looking type trying second guess intention 
place burden specifying elimination rule targets belongs manufacturer rule 
northern irish tradition legitimate target say consequently boxes targets notational courtesy annotations machine see 
way represent annotations store boxed term type binding special identifier ffl nn nn phi ffl mn mn phi ffl nneq phi nneq manufacturer instructions machine ask legitimate targets order annotations appear type 
indicate eliminate process known business machine match target annotation inferring universally quantified variables 
opens interesting possibility type elimination rule computed targets 
compute elimination scheme know intend eliminate 
see example technique injectivity conflict rules datatype combined single rule computes inversion appropriate equation eliminated targetting instantiated sides constructor expressions 
part really easy way prove peano style properties dependent datatypes 
constraints color long black 
henry ford undergraduates count fortunate exercises inductive proof traditionally involve goals form nn 
formulation base step cases involves copying bit appropriate values substituted 
complete question manufacture proof template tendency write suppose show beaten collect credit 
reasoning modestly complex notions nn favoured goals bearing close elimination rule inv inv mn phi inv scheme abstracts arbitrary pairs natural numbers deal arbitrary pairs 
cope particular restrictions relations datatypes forth 
apply generic rule inv restricted instance consider boxed hypothesis need construct scheme constrained problem hand abstracted entire aperture rule 
constraint need expressed means propositional equality purposes worthy predicate 
phi nn long 
plugging scheme inv mn fill details selected target instantiated surely prove presume refl type generally suppose elimination rule proving scheme phi patterns shown right 
notation represents sequence patterns pattern variables abstracted generally means patterns substituted 
phi rule subgoals phi may apply rule specific goal presume targetting produced matching oe giving rule pattern variables terms goal hypotheses 
consider goal looks psi oe may choose scheme phi explicit equational constraints oe psi oe oe 
telescopic equation general sequences length telescopic equation abbreviates telescope equations fs observe able express constraints presence type dependency 
example building constraints aperture nn vect need need notion equality scales telescopes exactly provide 
instantiate rule filling pattern variables oe phi scheme constructed oe oe psi oe solve equations recover target goal 
fortunately reflexive 
point way henry ford customers ask colour model receive satisfaction happened choose black scheme abstracted entire aperture patterns applies subject equational constraints recover specificity 
notice formulation scheme requires abstraction 
psi oe remains untouched 
targetting identifies oe need occur goal exercise little pointless 
established basic technique constructing schemes goal specific elimination rule 
broadly effective generates redundant information 
example constraints unnecessary goal really general rule point saying color long color 
try avoid equations abstraction 
subsections describe techniques basic scheme clumsy accordance observations ffl fresh variable constrained equal index coalesce remove constraint ffl avoid abstracting scheme redundant information ffl index constrained equal complex pattern example apply elimination rule characterising function may simplify scheme replacing copies pattern index simplification coalescence simpler example unnecessary constraints wanted prove nn generic constrained scheme nn nn scheme want students write better scheme machine computes 
scheme constrains bound index equal fresh bound variable type may coalesce 
example nn hope 
coalesce variables choice name keep polite preserve name goal 
note bound variable constrained equal index effectively forces indices may coalescence lose 
fix goal premises really want scheme 
remain fixed scope elimination 
unfortunately quite subtle questions 
imagine example building map function polymorphic lists map type list list order recursion certainly fix element type parametric elimination rule list 
may fix please 
hand constructing functions require nested recursion may free fix arguments 
consider example ackermann function ack nn nn nn ack sn ack sm ack ack sm sn ack ack sm apply outer recursion argument fix second argument see recursive calls decrease vary 
abstracting forced fix sounds promising policy hurt flexibility little 
abstraction definitely redundant 
recall earlier example proving inv shown right 
inv phi nn prop phi mm mn phi sn mn phi things stand basic scheme abstracts premises phi coalescence removes renames phi plugging rule find proof xn extra inequality redundant 
abstracted eliminating way useful scheme indexed proof inequality 
typically targetting filled eliminated application elimination rule looks rule phi oe oe phi oe premises occurring inferred arguments oe ones eliminated 
may appear patterns eliminated premises may appear instantiated patterns oe 
elimination tells may omit scheme provided type dependency permits 
may omit premise grounds redundancy provided ffl occurs arguments elimination rule inferred targetting ffl occur instantiated patterns oe ffl remainder goal depend inductive relations usually formulated exactly proof irrelevant way 
example eliminated hypothesis satisfies conditions 
omit leaving phi scheme want 
abstracting patterns goal rules indices marked abstraction oblige carry simplification scheme order intended rewriting effect 
recall section rule rewrite application nneq goal phi nn prop phi true phi false phi nneq psi nneq targetting infers 
coalesced scheme phi nneq psi nneq boxed tells away occurrences nneq goal 
done throw constraint away 
phi psi abstracting arbitrary terms dependent type theory sensitive business free replace subterm variable type typing term may depend particular intensional properties subterm replaced 
worth try unsuccessful may leave constraint continue 
rewriting technique powerful 
trouble caused type theory real 
part problem avoided appropriate facilities reconstructing broken typings propositional equalities proposed hofmann hof 
constraints inductive proofs see constrained schemes affect inductive proofs 
acquire constraints inductive hypotheses subgoals 
consider applying weak induction principle see right proof phi nn prop phi mm phi phi sn mn phi strict sxy targetting gives oe sx infer scheme coalescing phi sx corresponding subgoals shown right 
constraints appear hypotheses subgoals friendly restrict deal 
constraint inductive hypothesis unfriendly restricts choice closer examination constraints reveals subtle crucial distinction 
base nn sx step nn hyp nn sx nn sx sn variables appearing constraints come sources ffl pattern variables case elimination rule premises subgoals appear left hand side constraints ffl variables universally quantified scheme premises subgoals parameters inductive hypothesis appear right hand side constraints friendly constraints tell useful information variables occur subgoal premises come scheme patterns 
chapter see simplify solving variables appearing side friendly constraints constitute unification problems 
inductively defined relation strong induction principle distinction explained section 
example imagine perform simplification instantiating leave subgoals shown 
base nn sx step nn hyp nn sx sx sn unfriendly constraints tell variables occur subgoal premises allow infer narrow choices copies scheme variables parameterise inductive hypotheses 
unfriendly constraints determine variables appearing right hand side matching problems 
look back simplified friendly constraints find solve matching problem sx done unification solution available 
inferring obtain subgoals shown right 
base nn sx step nn hyp sn interesting happened see subgoals natural deduction style base sx step sn looks plausible recursive specification 
fact done apply standard unfold fold technique logic programs ts gs transform goal viewed specification terms subgoals give recursively 
unification problems arise unfolding matching problems inductive hypotheses involved folding 
elimination tactic section shall tactic eliminate refines goal elimination rule user required finger targets tactic constructs appropriate scheme solves goal generating subgoal case 
eliminate operates stages ffl preparing application elimination rule arguments initially unknown ffl targets inferring pattern variables ffl constructing constrained scheme ffl proving goal ffl tidying implemented prototype tactic functionality described key component extension lego 
course known know functionality 
section blueprint revised version 
shall stage little tactic 
induction just seen previous section useful running example 
tactic reproduce exactly effect manufactured hand 
rule shall goal shall prove shown oleg notation right 
boxed premise rule inequality eliminates boxed inequality goal shall target 
elim phi nn prop oe nn phi mm oe nn oe mn phi phi sn nn phi nn sx preparing application preparation step carried goal solved lemma 
just administrative manoeuvre getting right place real follows 
tactic eliminate prepare elim goal elim goal app elim conc conc goal hypotheses introduced lemma hypotheses inserted unknowns 
application lemma manufactured stored binding 
ultimately application solve conc 
fill prepared application example shown right 
nn sx phi oe oe nn app elim phi phi conc conc targets having installed application rule proof goal step infer arguments targetting 
may presume rule sequence targets marked manufacturer 
user finger sequence matching expressions eliminated 
may unify tactic matching may slight overkill 
happens goal app elim conc conc target eliminated goal app elim conc conc targetting tries match terms types 
successful rule arguments inferred 
inferred 
kinds bound separate clumps just easier write way 
rule target repeat step 
example successfully match matching types infers sx app elim phi phi sx elimination rule particularly complicated structure may computed earlier arguments inferred targetting 
instantiated type app may reduce revealing premises inferred 
tactic create holes add application 
computation may reveal targets 
incorporating possibility real behaviour targetting step follows tactic eliminate target goal app elim conc conc target eliminated goal app elim conc conc observe inferred turned bindings appeared result computation 
application extended accordingly 
constructing scheme targetting phase left state shown tactic may proceed construct elimination scheme 
scheme variable phi uncovered patterns inferred 
task compute phi 
put analysis section practice 
recall basic scheme manufactured abstracting premises constraining indices equal instantiated patterns 
goal phi app elim phi conc conc correspondingly tactic begins building basic scheme copying non parametric premises goal constraining indices 
premise considered parametric exactly occurs type phi 
tactic may fail point goal addressed big universe rule eliminates 
phi remainder phase prunes basic scheme clumsy possible 
course real implementation try save approaching desired scheme directly suspect pruning basic scheme gives clearer exposition 
passes ffl decreasing remove scheme redundant targetted inspected patterns depended rest goal ffl increasing try simplify constraint simplifications check order coalescence index constrained equal fresh variable type replace remove scheme strictly rename keeping name goal presentation complex abstraction rewriting marked abstraction type phi try replacing occurrences scheme result typed discard leave scheme 
simplification complete pruned scheme accessible changing phi phi 
type app reduce 
example basic scheme complex needs 
reflecting proof irrelevant nature inductive relations redundant 
furthermore may remove coalescence 
phi nn nn sx em sx redundant premises retain earlier redundant premises 
simplifying earlier constraints may unify types constraints 
pruned scheme exactly came example hand 
type app reduces accordingly 
phi nn nn sx app elim phi nn em sx sx summarise behaviour phase tactic step tactic eliminate scheme phi app elim phi phi app elim remain pruning corresponding selection remain pruning equating pruned sequence indices pruned sequence patterns 
recall trying prove construction proving goal tactic eliminate goal app elim conc conc app refl phase proves conc app instantiating premises abstracted scheme originals making constraints reflexive return type desired 
effect example shown right 
app elim phi nn sx sx conc app refl sx tidying tactic eliminate tidy goal phi sub app elim phi sub conc app refl conc sub goal elim sub sub proves generalised depends 
firstly phase cuts bindings inferred arguments phi app conc 
task shuffle subgoals rule arguments inferred targetting outside proof goal 
done discharging generalised types depend opposed raising generalise regardless 
typically re fixed parameters 
outside retreat tactic moves outside binding goal 
point smart implementations try reduce proof goal 
goal solved binding 
example subgoals depend premises generalisation necessary 
final subgoals proof term follows sub nn sx sub nn hyp nn sx nn sx sn nn sx elim sx sub sub sx refl sx nn sx example nneq built hammer bang 
propose synthesise nneq function described earlier chapter prove useful theorems 
eliminate tactic programming proof 
nneq recursive function nn starting point development nn elimination rule doubles traditional induction principle primitive recursion operator 
phi nn type phi phi phi sn nn phi sequence follows ffl build implementation nneq corresponding obvious functional program 
nneq true nneq sm false nneq sn false nneq sm sn nneq mm ffl prove nneq recursion induction principle phi nn prop phi true phi sn false phi sm false phi phi sm sn phi nneq ffl prove convenient elimination rule nneq inversion principle suggested earlier chapter 
phi nn prop phi true phi false phi nneq ffl show nneq satisfies equational specification rules 
nneq true nneq false constructing nneq implement nneq nested recursion argument second 
program nneq nneq nn nneq nn nneq satisfying nneq true nneq sm false nneq sn false nneq sm sn nneq mm development goal shown box target 
note binding replaces return type nneq informative alias 
see return type nneq looks bit left hand side pattern matching definition 
find target 
eliminate 
base case step case 
note way return types picked patterns corresponding case analysis 
base case ready eliminate second argument 
nneq nn nneq nneq nn rec nn nneq nn nneq sm nneq nneq nneq nneq fill right hand sides introducing premises refining true nneq false nneq nneq nneq nneq nn rec nneq nneq sn nneq nneq nneq nneq step case kept neat introducing associated recursive call eliminating 
note type recursive call tells argument patterns 
nneq nn rec nn nneq nneq nn nneq sm nneq solve nneq false 
nneq ss introduce premises refine recursive call rec nneq nneq sm nneq ss nn rec nneq sm nneq sm sn nneq nneq sm nneq nneq ss built function eliminate 
proving standard technique proving recursion induction principle function 
fix arbitrary scheme phi indexed function arguments result type 
assume phi preserved rule recursive equation 
prove phi holds arguments corresponding result proof exactly recursive structure function 
discharging fixed assumptions give general rule 
theorem phi nn type oe phi true oe nn phi sn false oe nn phi sm false oe ss nn hyp phi phi sm sn nn phi nneq proof nneq example fix phi assume preserved equations 
left proving phi nneq computed nneq eliminate exactly places 
phi nn type oe phi true oe nn phi sn false oe nn phi sm false oe ss nn hyp phi phi sm sn nn phi nneq show base case step case 
elimination instantiated arguments nneq appropriately reduces subgoal making vulnerable assumptions constructed exactly purpose 
base cases follow directly 
phi nneq phi true similarly step case reduces relevant assumption oe ss suitably instantiated 
rec computed recursive call construction function 
rec fills premise oe ss complete proof 
rec nn phi nneq ss nn rec phi sm nneq sm phi sm sn nneq sm sn phi sm sn nneq discharging subgoals proves general rule want 
mark targetting nneq default abstracting 
proof method gives recursion induction principle functions build oleg mimics exactly construction 
effect packages sequence eliminations function stroke proofs properties 
proving proof example deriving inversion principle recursion induction principle 
illustrates technique shall similar circumstances rest thesis 
proof recursion induction principles relatively simple 
directly describe computational behaviour function question surprised find computational mechanism underlying calculus hard 
recall subgoal inductive proof reduces exactly proven corresponding premise 
contrarily inversion principles cut computational grain characterising extensional properties functions mechanism operate 
key proving fix schemes bindings outside induction vary inside induction 
means inductive hypotheses inversion principles inversion computation simplify inductive steps 
theorem phi nn type oe nn phi mm true oe nn phi false nn phi nneq proof fix context eliminate abstracting nneq 
scheme generated eliminate abstracted scheme rule trying prove 
observe original nneq replaced nn phi nn type oe nn phi mm true oe nn phi false phi recursion induction gives directly base cases step case 
base case representative 
diagonal case recursion induction filled answer false 
introducing premises refining oe left proving sn 
difficult shall see chapter 
nn phi nn type oe nn phi mm true oe nn phi false phi sn false step case entertaining 
know oe oe know inductive hypothesis elimination rule telling called scheme psi reduce confusion 
ss nn hyp psi nn type nn psi mm true nn psi false psi phi nn type oe nn phi mm true oe nn phi false ss phi sm sn ss introducing may eliminate hyp abstracting indices 
targetting necessary patterns fully instantiated 
generated scheme abstracts psi phi sm sn left subgoals equality decided sst nn phi sm sm true ssf nn phi sm sn false follow respectively oe oe difficulty completing proof 
mark targetting nneq default abstracting 
proving rules theorem nn nneq mm true proof eliminating introduces constraint target phi nn true subgoals easy 
nn true true nn false true theorem nn nneq false proof eliminating subgoals easier 
nn true false nn false false chapter inductive datatypes chapter gives formal definition class inductive datatypes families shall oleg 
shall broadly follow luo choice definitions admit show elimination computation rules generated luo 
goguen checked usual metatheoretic properties strong normalisation continue hold ecc extended notion datatype gog 
basically shall datatypes families arising strictly positive schemata proposed coquand paulin mohring dybjer cpm dyb 
datatypes coq lego alf 
induction recursion provided means traditional elimination rules exactly step case analysis attaching inductive hypothesis recursive subterm exposed 
type equipped elimination constant type codes elimination rule computation added associating appropriate contraction schemes reductions constants 
elimination rules inductively defined relations formulated martin lof 
exactly presentation described luo book luo implemented lego pol claire jones 
coq basically datatypes separates inversion recursion aspects elimination providing case construct fix construct 
fix carefully checked ensure recursive calls terms guarded constructors strictly smaller term decomposed 
case fix presentation reasons ffl particular argument wish function recursion reason suppose argument case analysis 
want look argument cases arising decompose recursive argument 
conventional eliminator ties notions inappropriately 
ffl conventional eliminator facilitates recursion exactly constructor stripped away 
fix operator allows recursion subterm exposed case 
serves useful purpose merely admit inefficient definitions fibonacci function 
working interactively need predict precisely advance inductive structure require 
eduardo showed conservativity confluence case fix gim 
showed strong normalisation calculus constructions extended lists style gim reason suppose extend types 
intuitively reductions sound giant metal cog ratchet 
deeply fi ffi administration real may buried hear great machines going know hands clock go forward bell ring midnight 
chapter show argument oleg 
summary skip detail equip datatype alternative elimination rules sense previous chapter 
course eliminate tactic provides means construction 
point omitted classes datatype lego coq 
systems permit mutually defined types example odd numbers zero constructor successor constructors odd odd 
omit awkward principle discussing general terms notational nightmare examples thesis require 
technology developed solitary inductive definitions extends mutual case difficulty implemented system handle mutual definitions 
case mutual definition represented single inductive family datatypes indexed finite type elements label branches define family parity type parity true containing numbers parity false odd numbers 
coq allows embedded datatypes existing datatype new datatype example defining finitely branching trees single node constructor takes list subtrees 
facility neat adds extra power 
paulin mohring observes embedded datatypes turned mutual extra branches duplicating behaviour auxiliary types may define finitely branching tree mutually list finitely branching trees 
construction inductive datatypes deep subscripts establish simply typed theme examine variations parameterised parameters types polymorphic types types higher order constructors dependent inductive families degenerate types relations records 
components inductive datatype definition follows ffl type new constant names type type family nn list vect 
ffl constructors rules means forming canonical elements datatype nn 
ffl elimination rule induction principle provides mechanism decomposing elements datatype cause constructing proof induction recursively computed value 
rule marked target eliminate 
ffl reductions animate mechanism defining computational behaviour elimination rule canonical element 
simple inductive datatypes nn componentwise ffl type constant inhabits universe ind type nn example ind ffl constructors function symbols con con con ind called non recursive arguments may refer ind may involve universe large ind inhabits order avoid paradoxical embedding larger universe inside smaller may usually rely harper pollack universal policeman hp unlabelled type regardless 
say con recursive arguments 
think elements ind tree structures nodes different kinds constructors con node having edges label telescope need recursive arguments come non recursive ones presentation simpler pretend nonrecursive arguments types involving ind may certainly permuted front 
may think constructors rules ind ind ind con ind derivation trees composed rules correspond exactly tree notion inductive data structures mentioned 
nn constructors nn nn sn nn observe ind inhabited need constructor recursive arguments 
ffl examine constant type gives elimination rule ind accordance general analysis elimination rules earlier 
pattern eliminates free pattern ind matches element ind scheme indexed ind phi ind type rule goal targetting element eliminated 
ind phi outline rule shown 
phi ind type ind phi order build proof phi arbitrary need method constructor showing phi follows phi recursive arguments succinctly con preserves phi 
may think phi property hold argument ind rules rule subgoals analogous ind manufacture rule subgoals rules ind writing phi ind phi phi phi con note recursive arguments disappeared entirely 
types recursion hypotheses depend may infer case hypotheses suppress written rule accordingly 
functional programmers may familiar fold operators cut version phi constant recursive arguments recursion hypotheses 
pieces need complete rule phi ind type phi phi phi con phi phi rc phi con ind phi phi ind type phi phi con 
phi phi con ind phi natural numbers get phi nn type phi 
nn phi phi sn nn phi phi nn type phi phi phi sn nn phi ffl skeptical disposition accept validity see plug proofs rule subgoals build inhabitant phi particular ind constructors 
process represented type theory reductions associated ind means computational meaning allowing evaluate recursive functions ind add reduction effect constructor phi oe con oe phi oe natural numbers get rules phi oe oe oe phi oe oe sn oe phi oe oe type constructors simple inductive datatype elimination rule reductions computed straightforward way 
parameterised datatypes list hard represent datatypes lists natural numbers mechanism type nn preferable define lists polymorphically instantiate definition type element encounter define new list type element type 
able define lists way parameterised choice element type allowing write functions operate arbitrarily typed lists 
type list simple inductive datatype lists elements 
entities called families inductive datatypes element family inductive datatype 
kind parameterisation simple parameters instantiated fixed entire inductive definition constructors elimination rule lot 
parameter telescope need merely bind parametrically defined constants rewrite rules correspondingly replacing applied 
ffl type ind type ffl constructors con find pg ind rule ind ind con ind ffl elimination rule phi ind type phi phi phi con phi phi rc phi con ind phi type phi ind type find pg phi phi con 
find pg rc phi rc phi con ind phi ffl reductions phi oe con oe phi oe family datatypes list list type nil list list cons list phi list type phi nil phi phi cons list phi phi oe oe nil oe phi oe oe cons oe phi oe oe note suppress parameter writing cons inferred type conversely leaving visible list nil general shall avoid mentioning parameters convenient 
datatypes higher order recursive arguments ord far datatype constructors seen fixed number recursive arguments tree metaphor fixed number edges smaller subtrees 
choose see family edges indexed finite set proceed wonder types acceptable indexing recursive arguments 
small type telescope index recursive argument long involve type defined giving increased power higher order recursive arguments addressing infinite families subterms 
higher order recursive arguments functions returning elements inductive datatype 
elimination rule higher order recursion hypotheses functions returning proofs phi 
example may construct type ordinal numbers supplements zero successor constructors supremum possibly infinite family smaller ordinals zero ord ord suc ord nn ord sup ord restriction known strict positivity sup constructor takes family ordinals indexed nn admitting transfinite structure 
corresponding subgoal elimination rule gives access family recursion hypotheses phi ord type phi zero phi phi suc nn phi phi sup ord phi compute type 
sup branch expects family proofs phi image functional argument may manufacture family abstracting recursive call phi oe oe oe sup sup oe sup nn phi oe oe oe sup way allow constructors arbitrary inductive datatype families recursive arguments elimination rule acquiring families recursion hypotheses ffl type ind type ffl constructors con ind ind rule ind ind con ind ffl elimination rule phi ind type phi phi phi con ind phi type course nn ord countably inhabitants 
phi ind type ind phi phi con 
ind rc phi rc phi con ind phi ffl reductions phi oe con oe phi oe dependent inductive families fins extend notion inductive datatypes include inductively defined indexed families types dyb 
example consider finite sets 
hard define simple type elements 
types commonplace 
choice meta level define type separately 
useful define fin nn type enabling reason object level arbitary finite sets 
course fin better empty fin sn inventing new element embedding old elements fin fin mutually defined family datatypes constructors fz fin sn fin fs fin sn convention choose think sets growing push fashion 
new element introduced fz zero old elements embedded successor function 
debruijn influenced see newest closest lowest number 
note may leave implicit argument fs 
fin family elimination rules family schemes phi nn fin type form rule subgoals demanding phi holds fin inhabited select scheme corresponding relevant branch mutual definition 
phi nn fin type phi sn fz phi phi sn fs nn fin phi computational behaviour phi oe fz oe fs sn fz oe fz phi oe fz oe fs sn fs oe fs phi oe fz oe fs fin inductively defined family types instances family inductive datatypes taken isolation collectively form mutual inductive definition 
contrast family inductive datatypes list member list nn inductive datatype right 
light example generalise dependent inductive families fam type constructors take recursive arguments return values instance type family defined fam terms rule style get fam fam con fam con scheme indexed entirety types defined phi fam type recall free telescope notation abbreviates phi fam type 
rule subgoals demand phi holds fam inhabited succinctly phi holds fam inhabited 
get phi fam type phi phi phi con con fam phi observe unifying term type gives information infer inhabitant fam 
reduction rule constructor phi oe con con oe con phi oe inductively defined relations inductively defined relations bear strong resemblance dependent inductive families datatypes 
presentation differently motivated inductive relations families propositions role reasoning computation sit outside domain programs data characterising aspects 
propositions types terms inhabit constitute proofs 
inductive relation inhabitants built constructor functions just datatype may think constructors inference rules elimination rules inspect proofs explicitly terms constructors 
technically difference inductive relations datatypes manifested ways ffl type formers inductive relation range impredicative universe prop correspondingly schemes elimination rules families propositions ffl inductive relations proof irrelevant apertures elimination rules indices relation proofs rule cases identify constructors correspond shall need relation interfere computation 
represent constraints elimination process datatypes relations allow eliminate type prop 
way fit presentation inductive relations 
treated specially gets chapter 
moment consider inductive relations reasoning 
dependent datatypes relational analogues 
example fin family corresponds relation nn prop rules new sn old 

sn names rules really constructor symbols side emphasises proof irrelevant nature relations 
leaves free write propositions prefixed proofs rules 
compare 
fin clearly empty 
sn new proves new thing just smaller whilst old lifts proofs smaller exactly fz creates new element finite set fs embeds old ones 
elimination rule oleg provides known strong induction principle elim elim phi nn prop phi sn 
phi phi sn nn phi note scheme indexed numbers proof second 
correspondingly targetted occur goal patterns constructor symbols new old appear subgoals 
consequently step case hypothesis longer implicitly inductive hypothesis write explicitly mean 
matter fact choose omit rule obtaining weak induction principle 
equivalent appropriate notion conjunction strong version useful practice generally preferable discard unnecessary hypotheses reconstruct necessary ones 
clear inductively defined relations equipped computational behaviour computation belongs realm datatypes inductive relations computation desired easily redefined dependent family 
hand sense computation explains induction possible equip relations reduction rules meaningful desirable 
get elim phi oe new oe old sn new oe new elim phi oe new oe old sn old oe old elim phi oe new oe old guide general treatment ffl proposition rel prop ffl inference rules constructors rel rel rule rel rule ffl elimination rule strong induction principle phi prop rel rel phi phi phi rule rel phi ffl reductions phi oe rule rule oe rule phi oe record types represent dependent record types degenerate case inductive datatypes 
simple datatype rec constructor rec recursive arguments just tupling wrapper non recursive arguments fields call 
typical type constructor follows ffl type rec type ffl constructor singular field rec field rec official field names field significant allow adopt conventional named tuple notation syntactic sugar write indicate sugared notation field rec presumes sequence names field determines defined record types intended 
underneath layer sugar names fields irrelevant 
having established syntax elimination computation rules ffl elimination rule phi rec type phi field rec phi ffl reduction phi oe field oe record types come ready equipped projections 
elimination rules require function fields introducing arguments effectively extends local context bindings fields 
similar behaviour pattern matching named tuples sml open structures pascal construct 
underneath entitled place welltyped expression choose involving fields 
interactive analytical setting eliminating preferable projection focused goal 
single elimination exposes fields projection gives time 
honest account especially may type dependency fields 
understanding records fields spite structure weaves bit understanding london terms discrete tube station 
plenty people including navigate london basis 
define projections conventional notation delta field type dependency requires order earlier projections appear types ones 
presuming defined delta field delta field delta field delta field rec field field rec field field refer spot think ugly thing wish distance dot binding 
dot marks scope may contain typed expression identifiers explained 
spot allows name field 
apply generous makeup hide 
rec may write field syntactic sugar abbreviates bunch bindings open record chosen local names 
dot introduces scope bindings may naturally 
abbreviate case chosen names ones field happens field name recover effect projection 
hx 
superficial resemblance opening notation explicit environments sato sakurai burstall ssb 
treatment propagates environments term structure manner explicit substitutions giving action distance effect binding 
implemented class local definition records experimental extension lisp mcb 
compendium inductive datatypes section defines formally number familiar datatypes thesis everyday functional programming 
purpose partly consolidate material previous section confine contiguous portion thesis lot boring definitions 
finite types see table standard equipment empty unit bool 
constructor pronounced void 
disjoint sums specifically table 
dependent family examples thesis vectors vect table 
note suppression inferrable arguments 
sigma types reinventing luo supplies dependent pairs sigma types basic features ecc equipped second projections 
facility datatypes preferable pairing parameterised record type 
pairs acquire apparatus shall shortly build datatypes 
type type type true false table standard finite types type type type type inl inr table type nn type vcons sn table vectors intro sigma raise sigma hy xi table tactics sigma types goals ffl record type sigma type ffl fields penalty risk paying slightly clumsy syntax power sugar problem away 
lots 
sigmax sigma sigma fake binding operator thetat sigma usual special case hs ti ti unlabelled pairs empty telescope gives unit type sigma sigmax sigmax nonempty telescope gives sigma type omega fg ff empty sequence gives void ti hs hs ti ii nonempty sequence gives pair conflict sigma binding operator turns telescopes types tuples represented pairs nested right 
dot notation record types sugar 
choice field names gives familiar delta delta projections special case 
equip oleg tactics dragging bindings fake sigma bindings 
see table 
replacements 
applied recursively intro intro sigma turn goal full sigmas partial proof full correspondingly raise sigma combines raise allow multiple subgoals retreat partial single outstanding proof obligation 
tactic intro sigma caters sigma types goals allowing solve piecewise 
sigma types hypotheses 
usually try curry away possible find sigma types inductive hypotheses example original goal compute pair 
awkward exploit hypotheses tactics lego refine specifically geared functional information 
propose tactic search inside sigma tactic tactic tries solve goal depthfirst search strategy 
nodes search tree bindings proofs try 
initially root node set root goal node starting root behaves follows ffl try unify node goal successful ffl reduce weak head normal form ffl generate subnodes type directed methods table try turn blunder refl subnodes tried blunder subnodes recover exactly lego refine tactic blunder 
just blunder sigma 
taken opportunity blunder refl 
recall eliminate generates constrained scheme equations generated appear matching problem inductive hypotheses may arise 
blunder refl intended easier exploit hypotheses matching problem obvious solution 
equational premise required tries unify sides order supply refl proof 
fails blunder introduces premise normal 
unusual making possible unification turned unfortunate choice 
construction guarded fixpoint operator section uses style hypothesis exploitation exactly right tactic 
old fashioned kind gun barrel opens horn 
fires wide spread 
phrase tactics describe technique throwing got problem hope 
blunder refl delta node 
goal delta sub refl refl 
goal unify delta delta delta fl delta blunder delta node 
goal delta sub 
goal blunder sigma delta node sigmax 
goal delta sub sub sub 
goal table search methods constructing case fix section shows derive alternative datatype corresponding case fix operators coq 
case analysis datatypes relations elimination rule datatype relation may construct version embodies notion may reason arbitrary inhabitant type considering possibilities outermost head constructor recursive information 
nn get 
phi nn type phi nn phi sn nn phi construction builds theorem proof technique call attempt prove blatantly false claim fail turning remaining subgoals premises just lecturer leaving bits forgotten exercises students 
trick postpone remaining bindings outside level turning bindings discharge 
construction case analysis suppose inductive family fam indices dependent datatypes relations universe family types inhabits need consider indices fixing parameters families list vect construction 
family elimination rule phi subgoals fam phi inhabits prefix fam corresponding prefix universe family types eliminates inductive definitions subgoals oe applications phi 
boldly fix phi attempt prove patently untrue mind eliminate 
delta phi fam phi note holes may appear neatly ordered matter 
subgoals oe correspond constructors datatype 
oe phi phi fam phi oe divide hypotheses case data inductive hypotheses rec phi oe rec phi phi phi inductive definitions permitted depend inductive hypotheses 
may remove delete unused 
having modified subgoals way postpone 
state shown 
delta phi oe phi phi fam phi may discharge assumptions recovering case analysis principle expect 
phi oe phi phi phi oe phi fam phi hard see reductions hold phi oe con oe guarded fixpoint principle giving construction elimination rule performs job coq fix construct look example motivates need manner done 
famous old fibonacci function counting drawing attractive rectangles making euclid algorithm go slowly possible fib fib fib ssn plus fib fib sn see goes wrong just blunder trying mimic definition 
initial state return type decorated binding see happening 
fib nn nn nn type fib nn fib eliminate binding tracks arguments 
certainly fill fib watch happens eliminate split successor case fib fib fib nn fib fib fib fib case fine double successor disaster struck 
fib sn safely happened fib 
appeared right wrong place hope accessing 
fib fib fib fib fib ss nn hyp fib fib fib sn fib sn fib sn fib ssn course classic definition fibonacci function famous run time 
traditional remedy write linear recursion computing pair successive values 
bd burstall darlington transform definition efficient form fib fib fib ssn plus sn design auxiliary function computes exactly information required complete double successor case step recursion 
main function reduced case analysis 
gim effectively generalises technique encoding recursion guarded arguments technique 
exercise compute 
definition guarded ffl con datatype constructor non recursive arguments recursive arguments guarded con con ffl guarded guarded guarded idea introduce intermediate data structure stores input recursive values need compute output 
may code elimination rule phi nn type aux phi phi nn phi applied rule case analysis allows split subgoal cases separate patterns wish treat pattern prove phi information supplied aux phi course prove rule shall able show nn aux phi proof go recursion generate auxiliary information sn corresponding information just fibonacci function may carry information need keep computing new value exactly way main function 
aux phi 
different depths recursion necessitate different amounts auxiliary information 
fibonacci may choose aux ib aux ib aux ib ssn fib theta fib sn users may choose develop auxiliary data structure develop function follows case analysis 
generally may give single auxiliary structure suitable occasions 
defines inductively parametric phi phi phi phi phi sn carefully higher order recursive argument type guarded datatype auxiliary mimics constructors recursion pattern 
recursive argument decorated phi proof element original type auxiliary stores phi proper subterms 
proofs nn phi sn phi go case analysis time splitting nn patterns surfacing recursions exposed subterms 
treatment differs pragmatically compute auxiliary structure defining inductively 
phi phi sn phi theta phi case analysis feeds constructor expressions unfolds wallets people credit cards revealing proofs phi exposed subterms 
tactic extract required hypothesis provided identified type 
try prove nn phi induction base case trivial 
step case nn phi phi sn reduces nn phi 
phi theta phi clearly establish second component pair 
leaves requirement nn phi phi technique may postpone discharge subgoal auxiliary generation lemma nn phi phi nn phi elimination rule 
phi nn type phi phi nn phi shall give general construction simple types discuss extensions 
construction guarded fixpoint consider inductive family datatypes constructors shown right 
non recursive recursive arguments 
standard elimination rule 
ind type con ind fix components supplied user holes components supplied machine 
binding indaux helps track development indaux 
phi ind type indaux ind type indaux ind indaux body ind aux indaux phi ind indaux ind phi may immediately prove ind body eliminate auxiliary generator subgoal constructor 
illustrate point reduces subscript terror 
indaux con indaux con indaux indaux indaux con con indaux con indaux con build indaux con introduce arguments return iterated sigma pair types collecting recursive argument phi lovely binding reminds really indaux con introduce arguments return corresponding iterated tuple pairs passing accumulated proof adding layer computed body 
indaux con sigmaf phi thetat con omega ig ff indaux con cutting indaux proofs subgoals discharging fixed hypotheses left indaux phi ind type ind type phi ind type body ind aux indaux phi ind indaux phi ind type body ind aux indaux phi ind phi phi ind type indaux phi phi ind phi conversions hold indaux phi con sigmaf phi theta indaux phi phi con phi phi ig phi phi dependent families fam exactly construction replacing ind fam fam appropriate phi fam type fam type con sigmaf phi thetat con body fam aux phi con omega fh body ig ff con fam body higher order recursive arguments pairs indaux ho ind indaux sigma phi theta ho ind indaux body ee built useful elimination rules move consider technology need solve constraints arise dependent subfamilies 
chapter equality object level unification chapter examines different notions propositional equality type theory forms equational reasoning support 
particular shall give formal treatment predicate exploiting merely convenient packaging martin lof identity type uniqueness identity proofs axiom proposed altenkirch streicher str 
reason reformulating equality way improve treatment equality sequences terms presence type dependency 
definition equality task build tactic simplify solves order constructor form equations appearing premises goals 
achieve need construct machinery inductive datatype ffl proof constructors injective disjoint ffl cyclic equations sn nearly inductive definitions equality martin identity type prop refl phi oe refl refl oe refl phi type phi refl phi known business historical reasons 
may easily prove equality substitutive usual sense 
proof fixes phi proof single case applies eliminate 
generated scheme equation proof proof irrelevant 
phi type phi phi prove convenient sugar applications ffl substitution phi phi phi phi phi ffl coercion type computational behaviour follows refl phi uniqueness identity proofs altenkirch streicher suggest equipped additional elimination rule shown computational behaviour 
phi oe refl refl oe refl phi type phi refl phi rule known business largely comes 
element type aperture space equations scheme range dimensional thetaa 
scheme ranges diagonal 
course diagonal inhabited 
imagine rules named jazz johnson kai winding 
propose pour cold water explanation 
hofmann streicher shown derivable hos 
hand streicher adds unnecessary taken axiomatic may replace say reduce remaining arbitrary proof refl 
effectively divide process phases proof irrelevant phase reduces family inhabited subfamily reflexive equations proof relevant phase need concerned restricted case 
john major equality time reveal definition john major equality relation 
john major classless society widened people aspirations equality gap rich poor 
equal oneself politics envy 
way forms equations members type treated equals substituted type 
just thing equal 
prop refl phi oe refl refl oe refl phi type phi refl phi observe elimination rule expect inductively defined 
usual rule eliminates equations quite useless substitute values type scheme abstracted arbitrary type 
phi type type phi refl type phi contrast eliminates subfamily types type diagonal course inhabitants lie subfamily 
equality sequences reason adopting working dependent types seen clearly attempt extend notion equality cover just john major leader conservative party prime minister united kingdom case slipped mind 
terms type sequences terms telescope 
suppose telescope may general state equality sequences theta may different 
course writing henceforth abbreviated telescopic equation may correspondingly abbreviate sequence reflexivity proofs refl refl refl fact may prove substitutivity uniqueness telescopic equations 
construction telescopic substitution natural number may derive substitution principle telescopic equations length reduction behaviour follows phi type phi phi phi oe refl refl oe refl construction recursion effectively iterating 
zero case proved polymorphic identity function 
clearly reduction behaviour correct 
phi type phi phi assuming constructed construct phi type phi phi fixing phi proof phi goal shown 
goal phi proof type may eliminate 
generated scheme includes phi note depends proof relevance necessary construction just construction 
elimination leaves subgoal shown 
note just exactly telescope subgoal phi telescope may eliminate remaining scheme just phi leaves subgoal phi proof fixed context 
reduction associated inductive hypothesis may deduce phi oe refl refl refl phi oe refl oe observe proof structure yields substitutivity direction 
roles reversed may fix right hand sides required 
phi type phi phi construction telescopic uniqueness natural number may derive substitution principle telescopic equations length reduction behaviour follows phi type phi refl phi phi oe refl refl oe refl construction proceeds recursion polymorphic identity base case 
step case slightly subtle 
suppose constructed construct time fix proofs equations 
goal phi little choice eliminate 
introduces equational constraints scheme 
phi constraints disposable definitely occurs goal general may expect occur implicitly types consequently subgoal get shown 
may discard eliminate subgoal refl phi ready appeal scheme phi refl 
subgoal phi refl turns remaining refl fixed proof phi refl completes obligations 
far reduction behaviour concerned omit detail 
construction successively applies elimination rules equations reduce single subgoals equations instantiated reflexivity 
consequently inherits behaviour 
impossible build notion telescopic equality substitution considerably cumbersome 
method forces equation typecheck explicit appeal substitution operator prefixed equations 
need operators order formulate telescopic equation length establish substitutivity 
furthermore order step construction sufficient simply substitute equation eliminate substituting terms instantiating proof reflexivity allowing substitutions repairing remainder equations reduce 
adopting achieve telescopic extension acquiring proof relevant dirt 
relationship having argued practicality working dependent types feel obliged point equivalent provided mean equipped 
give mutual construction 
easy direction construction easy just tell answers construction just telescopic equation telescopes length 
type type prop refl refl type type phi type oe phi phi type phi type oe phi refl phi furthermore reduction behaviour exactly direction interesting 
construction assume construct type type prop refl type type phi type oe phi refl phi little abbreviation cell sigmaa type cell packages typed term 
idea just cells type type ha ai hb bi refl type refl ha ai elimination rule type phi ha ai ha bi type oe phi refl ha ai ha ai ha bi phi deduce way 
need proof equal cells equal second projections 
equivalence equality second projections dependent pairs folklore knowledge shall 
difficult state equality second projections convertible types substitutivity equality type coercion 
lemma need shown 
claim globally main goal 
observe aa bb cell aa bb aa bb refl exploit discovery 
introducing hypotheses goal solve 
ab refl goal phi type contains wise may eliminate ab 
ab refl goal ha ai ha bi phi goal goal reflexive equation 
may eliminate 
subgoal ha ai ha ai phi subgoal acquire follows oe 
immediate phi refl eq ha ai remains prove 
firstly eliminate equation cells 
pairs unpacked binding sugar names projection 
clear eliminating aa reducing projections cutting sugared bindings 
aa cell aa aa may remove reflexive open type remaining subgoal exactly type refl refl type far reduction behaviour concerned observe refl ha ai refl refl eliminates succession equation cell second equation constructor form 
consequently applied computed equality proof ab turns refl 
equations reflexive steps reduce required 
order unification constructor forms typical application elimination rule scheme variable phi type engender scheme phi psi correspondingly cases form phi yield subgoals proof form psi equational constraints constitute unification problem solution goal follows vacuously general unifier may instantiate suppose example wish write vector tail function type prevents application null vector nn vect sn vect note fixed element type avoid clutter 
eliminating creates constrained scheme nn vect nn vect sn sn vect corresponding subgoals shown 
subgoal features impossible premise zero equals successor whilst vcons case equations conveniently constrain type tail return type function 
nn vect sn sn vect vcons nn vect nn vect sn sm sn vect solve unification problems left goal 
vcons nn vect vect introduce arguments return tail 
task hinge solving unification problems generated course elimination 
mcb tactic solving problems provided terms comprised constructor forms simple datatypes 
shall largely follow treatment extending procedure dependent datatypes 
transition rules order unification tactic operates successively eliminating goal hypothetical equations constructor forms phi definition constructor form constructor form variable set ffl ffl con constructor form goal suppose type constructor forms may distinguish possibilities decision table cheese identity cycle coalescence substitution apply conflict cheese symmetry injectivity kinds constructor equation elimination rule 
shown table rules proven constitute transition rules unification algorithm complete class problem definition constructor form unification problem constructor form unification problem goal form phi sequences constructor forms inhabiting telescope leading equation sides type exactly rules apply symmetry necessary 
check rules preserves structure 
lemma transition rules preserve problem structure constructor form unification problem phi eliminating appropriate transition rule solves goal leaves subgoal constructor form unification problem 
proof check rule rule cheese constructors different cheese 
identity phi type phi phi coalescence phi type phi phi cycle phi type cheese phi substitution phi type phi cheese cheese phi conflict phi type cheese phi injectivity phi type phi cheese cheese phi table elimination rules constructor form equations ffl identity phi phi variable set unchanged constructor forms 
ffl coalescence substitution permutation goal performed elimination tactic start phi elimination phi vanished variable set replaced constructor form contain remaining problem ffl cycle conflict subgoals 
ffl injectivity cheese cheese phi cheese cheese type constructor cheese elimination phi certainly problem consists constructor forms furthermore inhabit telescope cheese 
checked transition rule preserves structure constructor form unification problems step put unification algorithm 
algorithm constructor form unification problems algorithm straightforward consists repeatedly applying transition rule appropriate leading equation goal proved outright equations remain 
lemma clear step leaves subgoal step 
show unification terminates computes general unifiers definition unifier general unifier constructor form unification problem oe substitution terms oe oe oe addition oe general unifier mgu unifier factorised ae delta oe ae substitution lemma unification terminates constructor form unification problems sequence transition rule applications determined stage leading equation finite 
proof shall traditional proof may establish founded ordering unification problems lexicographical ordering quantities ffl number variables ffl number constructor symbols appearing problem ffl number equations problem may check case case transition rule terminates directly reduces measure 
ffl cycle conflict terminate directly ffl coalescence substitution decrement number variables ffl injectivity preserves number variables reduces number constructor symbols ffl identity preserves number variables number constructor symbols reduces number equations lemma unification correct initial goal constructor form unification problem phi unifier case algorithm proves goal subset substitution oe constructor forms oe mgu algorithm yields subgoal phi oe proof check step problem ffl goal proven unifier ffl goal form phi oe general unifier ae remainder induces general unifier ae delta oe invariant holds initially accumulator oe identity substitution 
holds goal unifier 
holds empty remainder mgu identity substitution accumulator mgu case case ffl cycle conflict prove goal cases ffl identity injectivity change accumulator unifiers remainder ffl coalescence substitution remainder accumulator oe delta oe suppose ae mgu remainder transition 
show ae delta mgu remainder invariant forcing ae delta delta oe mgu clearly ae delta unifies suppose unifies delta delta hypothesis delta unifies factorised ae delta ae 
delta ae delta ae delta 
ae delta general required 
feel comment proofs unusual quite reverse 
deliberately conventional measure proof termination way comparison structurally recursive algorithm shall exhibit example programming dependent datatypes 
algorithm exploits transition rules remains construct proofs 
identity trivial 
coalescence substitution just applications conflict injectivity cycle require 
give constructions want draw attention computational aspect proofs built unification algorithm shall need technology build programs proofs 
algorithm generates sofar phi oe start phi shall need computational behaviour arbitrary start oe refl oe sofar refl recall elimination tactic supplies refl proofs constraints 
elimination rule associated reductions applied constructor headed target reduces subgoal proofs start passed subgoal constraint arguments allow subgoal proof reduce simplified version sofar ultimately value user supplied case 
may check property stepwise 
identity implemented abstraction appropriate fi behaviour coalescence substitution exploit established reduction conflict cycle prove pay attention case injectivity 
conflict injectivity consider inductive family datatypes fam type constructors con fam seen compute case analysis principle phi fam type phi con fam phi prove conflict injectivity theorems class datatype 
conventional way prove injectivity constructors simple datatypes define suite predecessor functions argument constructor fact equality respects function application 
presentation ct mcb 
general dependent types possible supply dummy values predecessor functions applied constructors originally intended 
contention case predecessor functions idea pattern matching expose predecessors locally constructor case apply techniques appropriate constructor arbitrary elements type 
fortunately computational power dependent type theory comes rescue 
proving peano style conflict injectivity theorems may manufacture single peano eliminates constructor headed equation computing appropriate rule case analysis 
construction peano establishing structure development wish compute peano theorem appropriate pair elements prove equal pair elements fam fam type fam fam note perfectly reasonable prove theorem instance family fam exactly situation theorem eliminating leading equation unification problem terms type 
looking statement problem may eliminate giving subgoals varieties 
diagonal kind asked compute conflict theorems constructors con con ij type simply introduce premises supply useful elimination rule phi type phi equation constructors head true 
interestingly diagonal compute injectivity theorems constructors ii type fortunately case analysis exposed predecessors need pair 
introducing supply rule phi type phi phi crucially reduction behaviour really means con con ij show rule assigned kind equation really holds equation 
recall goal fam fam quite choice things eliminate far useful equation applying left fam eliminating equation restricted attention exclusively diagonal trouble considering untrue equations deducing untrue consequences 
may eliminate yielding subgoals con con reducing case analyses fed constructor symbols obtain phi type hyp phi phi simply introduce hypotheses prove phi hyp refl 
checking reduction behaviour find con con refl con con phi type hyp phi hyp refl ensures identity transition decomposes refl proofs required programs 
note critical targetting making rule applicable 
obvious fam elimination rule unifying candidate equation 
equated terms constructor heads instantiated rule reduce revealing scheme variable subgoals normally expect 
unification algorithm requires prove peano theorems elements particular instance fam construction possible prove stronger theorem operates sequences fam fam eliminate equation reduced problem 
possible theorem eliminate constructor headed equation telescopic problem just front 
improve efficiency unification see conflict telescopic equation solve goal hacking earlier stages problem 
measures necessary constructor form increase efficacy wider class problems polluted non constructor terms 
difficult inductive families involving indices constructor form 
problems technology developed thesis shall discuss briefly section 
cycle showing cycles occur inductive datatypes quite subtle business 
proving nn sn 
requires quite lot technology 

eliminating 
nn hyp sn 
sn ssn applying unification cycle elimination subgoals simplify constructor headed equations theorem 
eliminates case conflict injectivity leaves immediate step easy nn hyp sn 
sn fact follow structure number natural numbers deceptively symmetrical 
watch happens throw spare successor constructor making type nn try prove nn stn 
induction yields cases perish conflict 
case follows nn hyp stn 
sn injectivity yields tricky nn hyp stn 
tsn oh dear 
wrong inductive hypothesis 
extra appeared inside rotating cycle successor usually looks theorems easy nn 
order prove result style strengthen nn stn theta tsn 
including just st cycle rotations successor cases show happens nn hyp stn theta tsn 
sn theta sn 
right conjunct follows conflict 
left reduces injectivity repaired nn hyp stn theta tsn 
tsn 
rotated follows projecting appropriately rotated conjunct inductive hypothesis 
technique generalised arbitrary cycles arbitrary datatypes 
drawback rotation need new theorem cycle pattern 
leaves little choice generate fly 
slightly technique arising conversation andrew adams mentioned mcb 
constructs cycle pattern type ind quotient function quot ind nn quot quot quot applying quot sides cycle get quot quot seen 
guarded recursion principles constructed datatype functions relatively easy manufacture implemented technique escaped burden substantial fly construction cycle cycle 
remember cycle constructor form compute structural recursion way compute proof want 
unfortunately way test decomposed far non canonical symbol programs access decidable conversion relation type theory describes 
adopt tactics element datatype construct property proper subterm way constructor head property reduces product explicitly enforcing exposed subterms 
idea works auxiliary data structure earlier constructed guarded recursion 
fact predicate need just instance structure 
may define property nn non strict counterpart follows nn 
nn nn theta conversion behaviour sn theta loss generality assume fresh variables argument positions cycle path 
inhabited exactly proper subterm whilst adds requirement indicate subterm unfolds computationally reveal proof equal guarded subterm observe example sx theta theta suppose prove nn hypothetical proof proof expand product containing contradiction goal surely follow 
step proof eliminate equation leaving highly plausible cycle nn hoping get cheap proof theorem built sadly proves phi phi constant stage pass accumulated information adding just new layer 
scheme varies recursion 
move unsurprising induction cycle cycle nn xh sx sx base case trivial type reduces 
unfortunately step genuinely difficult fixes argument way things stand reduce inductive hypothesis 
intelligent strengthening necessary 
reduce non strict expansion cycle nn xh sx prove proper subterm sx certainly subterm 
see sx subterm proper subterm right hand side 
corresponding generalisation 
introduce hypotheses create hole general version goal solve original cycle nn xh gen nn sx gen xh move 
fixed argument predicates free second vary induction corresponds computational behaviour 
gen sx gen nn yh sx sy sx sy applying little computation base case gen sx theta easily proven little help 
reducing step case get gen nn yh sx theta sx sy theta sx implication right conjuncts exactly inductive hypothesis 
left conjuncts expanding gives proof sx sy prove 
exposes proof ready 
having established property natural numbers suspicion exploited hidden way symmetry datatype just wary generalising triangles property held equilateral case 
step constructor recursive argument issue phenomena behave disjunctively blurred 
case fits perfectly 
construction cycle consider type ind type constructors con ind note really write number recursive arguments may vary constructor constructor 
proof readable start subscripting superscripts 
may define inequality property ind 
add proper subterm relation ind indaux non strict subterm relation ind theta computational behaviour definitions hope con sigma phi psi may prove cycle theorem ind eliminate equation leaving ind eliminate case con con expands yielding product case con come strengthening step 
trying show fold 
trick prove separately abstracting away right hand separate lemmas case lem ind con proof lemma inductive 
apply lemmas acquire constructor cases lem con con con con little computation order lem con sigma phi theta psi sigma con con sigma phi con psi firstly con follows applied proof projected 
secondly establish con con prove con con 
apply 
constructors different goal proved show 
look 
contains proofs may select proof injected equations proof establishing contradiction completing construction 
briefly extension dependent families 
fam type appropriate notion inequality fam 
construct fam fam theta take sequences fam elements fam problem arises strengthening step free away right hand sequence ensuring induction entire family 
equational reasoning suppose trying prove inequality 
sequences inhabit fam 
trying unify may apply strong version peano theorem directly telescopic equation solving goal case different constructors exposing equations predecessors constructors 
effect construction scales difficulty elements simple types sequences fam 
construction generalises easily datatypes higher order constructors represent infinitely branching structures 
higher order arguments appear hypotheses may simply fixed may appropriate witnesses higher order arguments goal positions 
easy exploit proof automatically undecidable infinitely branching structure contains cycle 
suppose hypothetical ordinal function nn ord yields input 
hypothesis sup acquire proof sup expands uncover proof nn 
machine reliable way guessing right number expose contradiction 
course know branches cycle takes apply hand 
brief look constructor form problems restricts dependent families indices constructor form 
complex indices lead complex unification problems general case inevitably undecidable 
ways problems arise mutually exclusive ffl non constructor form indices may appear type constructor 
example define sized binary trees stree nn type follows empty stree stree stree node stree plus ffl non constructor form indices may appear type argument case analysis performed 
example wish write type nn plus tractability problems hand depends types form expressions ffl problems involving comparison types functions simply 
hand theorems conflict level types disprove nn 
hand prevents solving simple higher order problems nn nn nn sx extensional behaviour completely determined intensionally distinct terms exhibit behaviour 
ffl equations datatypes involving defined functions plus troublesome especially equipped functions derived elimination rules constructor analysis return values 
examine example 
induction leave subgoals containing unsolved equational problems case type nn plus plus case analysis get know plus works 
approach address troublesome plus directly constructing plus recursion induction principle shown right 
note plus symbol completely absent cases 
phi nn type phi phi phi sx sz nn phi plus targetting plus goal yields subgoals type nn type nn sz sm remaining indices constructor form 
draw discussion 
firstly dependently typed programming non constructor form indices difficult principled machine treatment long way 
secondly hand treatments problems derived elimination rules describing behaviour non constructor functions considerable benefit 
chapter pattern matching dependent types position build tools programming dependent datatypes 
chapter shall discuss interactive development programs 
believe important consider translation functional programs conventional equational style real oleg terms elimination rules primitive datatype 
interested programs 
people write programs raw type theory hard write especially record explicitly attendant elimination dependent datatypes 
get machines 
am enthusiastic advocate analytic style programming afforded proof editors 
key point search programs carried structured space partial objects constrained sense machine performs bookkeeping checks type errors locally incrementally 
synthesising programs conventional way involves unconstrained search arbitrary sequences potential completed objects compiler accepts rejects 
incremental programming afforded interactive environments common ml community entirely useless incremental bottom requires details outline supports kind lonely gives programming bad name 
module system offers compensation coarse granularity 
trouble raw type theory hard write hard read 
program generated machine help thing represent way comprehensible humans 
sequences tactic applications especially informative case run counter demands user interface 
hope agree high level representation synthesised proofs programs exposes analysis merely paid 
operates constructed 
pattern matching notation decades theory practice bur mcb 
brought old ways am slow change prefer equational presentations programs pointer dereferencing young people days 
side effect concise readable notation write programs backs quite small envelopes 
programs look 
simplify matters time consider solitary functions 
contain free variables really universally quantified 
may appear may appear course impossible guess arbitrary hard imagine classes problem routine 
assume supplied programmer omit informally unremarkable 
mean program 
suggest mean determine type intensional behaviour defined symbol program determine closed input unique output merely describe extension function give equations cover cases true 
programs reflect deterministic terminating computation mechanism open terms canonical inputs canonical outputs 
equations computational just propositional force 
programs decode internally combinations abstractions applications case analysis terminating recursion 
requirement reflected considerable extent task translating programs terms effective computational behaviour primitive oleg datatypes 
common notion pattern matching functional programming simple types requires patterns constructor form nonlinear exhaustive disjoint 
sufficient guarantee intensional behaviour required 
classic counterexample due far know berry majority function majority verdict verdict verdict verdict majority innocent innocent innocent innocent majority guilty innocent majority innocent guilty majority guilty innocent majority guilty guilty guilty guilty imagine low budget henry film twelve angry men entitled mildly men task find majority verdict know think way gain information ask individually ask casting vote 
represent know pattern initially know pattern ask question say state knowledge divides possibilities innocent guilty choice adopt different strategies questioning ultimately giving set possibilities draw 
berry collection patterns represent set possibilities arising conditional questioning strategy 
appears undeclared pattern declare order determine answer 
shorter intensionally realisable function extensional behaviour majority verdict verdict verdict verdict majority innocent innocent innocent majority innocent guilty majority guilty innocent majority guilty guilty guilty extensional presentations functions useless merely 
highly desirable times give extensional properties specifications functions 
question transformed intensional programs preserving extensional requirements 
fact intensionally realisable patterns arise questioning strategies strongly favour analytic view programming generating patterns case splitting guarantees computational meaningfulness gives guidance way think problems place 
generating coverings patterns splitting central thierry coquand characterisation pattern matching dependent types coq implemented alf mag 
worth time review place chapter wider context meta level footsteps followed object level treatment 
advantage cases third prone moments 
teaching students ml frequently asking empty list 
cons mantra 
pattern matching alf coquand proposes admit functions defined pattern matching style directly type theory constants reduction rules equations provided satisfy certain safety conditions stringent necessary allowing considerable freedom expression 

demands nesting occur guarded recursion recursive guarded ij covering form covering sense defined definition covering captures notion successive case splitting 
shall need definition split elementary covering iterate yield covering 
definition elementary covering form elementary covering argument position ffl ij constructor headed ffl argument sequence constructor headed exactly instantiation note particular sequences different constructors heading jth argument covered different patterns possible constructors covered just asked jth argument reveal constructor head 
definition covering ffl free pattern covering ffl elementary covering ij ij coverings ij form covering term coverings build interactively depends elementary coverings recognise unification comes 
suppose family types fam wish form elementary covering telescope fam case splitting fam constructors con fam possible cases unify flexible variables apply appropriate unification algorithm constructor unification chapter getting responses ffl general unifier oe variables terms ffl indication unifier ffl failure due ambiguity getting stuck unification conclusive constructor case elementary covering pattern mgu oe oe con oe oe build coverings starting free pattern repeatedly applying case splitting allowed unification 
note unification meta level notion sound respect computational equality 
apart clever stupid 
constructor unification quite generous essentially implementation alf provides 
programming proceeds type directed way building covering argument telescope function filling right hand sides refinement allowing recursive calls provided appropriate termination check satisfied 
hard see reductions far thesis fall class definable function provided appropriate straightforward extension mutually defined functions mutually defined datatypes elimination rules datatypes constructed yield elementary coverings step guarded recursion 
fact need unification algorithm original alf implementation left moral obligation coquand criterion hard enforce 
handle conflict injectivity cycles coalescence substitution datatype reductions add identity wish support 
way 
fix constructor form unification informs case splitting process may follow treatment object level 
interactive pattern matching oleg section contains main metatheoretic result thesis proves functions manufactured interactively alf manufactured interactively oleg 
furthermore simulation intensional level functions manufacture oleg elimination rules computational behaviour defined directly alf 
progress theorem examine computation elimination rules detail 
computational aspects elimination suppose function terms follows infer computational behaviour 
common situation 
elimination rule construct eliminating arguments exactly structure take 
reduction behaviour reductions pattern matching function coquand style may able infer corresponding behaviour example seen construct way reduce fed constructor headed numbers 
hard check inherits appropriate behaviour phi oe oe oe phi oe oe sn oe similarly want implement pattern matching version plus means need sure defining equations intensionally recoverable 
particular need show recursive calls implementation replaced recursive calls plus convertible 
achieve process unfold fold transformation functional programs respects computational equality oleg 
consider unfolding 
suppose pattern matching program pattern variables definition infer lengthened equation possibilities ffl long ffl shorter case may split oe substitution terms unifies oe oe oe oe oet oe case split prefix oe unifying substitution oe oe oe oe oe oe oe oet note may general pad application unification may functional type instantiated 
folding straightforward 
know free pattern oe explained substitutions oe come unfolding folding pair techniques derive new intensional equations old ones 
propose construct pattern matching programs confirm intensional status 
example program plus may written pattern matching notation guess 
plus plus sx plus quite clearly falls coquand class definable functions 
seen plus defined somewhat oleg plus nn nn nn nn nn plus nn nn nn plus check pattern matching equations hold intensionally oleg definition 
unfolding respect reduction plus nn plus sx nn folding respect oleg definition plus nn plus sx nn plus lengthening plus plus sx plus checked implementation pattern matching program 
fact lengthening unfolding folding check computation laws thesis shall particular ensure intensional validity pattern matching programs shall shortly construct 
particular interest computational effect case analysis followed unification 
suppose face goal fam constructor form 
fam constructors con fam eliminating yields general phi fam 
con 
phi refl refl apply unification algorithm unifier case need computational explanation general unifier oe case new subgoal looks oe furthermore having oe may unfold definition respect discovering oe oe oe refl oe conversion holds computational properties proof term generated unification algorithm established previous chapter 
shows case analysis constructor form unification really correspond intensionally coquand case splitting step 
position prove crucial metatheorem 
conservativity pattern matching oleg theorem conservativity pattern matching oleg suppose 
admissible program characterisation previous section ffl covering built interactively case splitting constructor form unification ffl recursive calls structurally smaller rth argument oleg term satisfying proof main problem theorem proving 
prove goal check implement satisfies computational laws intended pattern matching equations 
key aspects construction justifying recursive calls 
help regard give highly distinctive types 
stand just type function returns arguments dull 
introduce informative type follows type call return call happened 
defined terms function returns elements unknown indexed type family course going turn style decorative bindings previous chapters remains obscure transfer values means pair unknowns call return turn identity function 
things stand type call identifies precisely arguments wish recursive call tactic shall able find hypothesis need just looking type 
step eliminate rth argument appropriate guarded recursion principle 
suppose fam fam dependent family datatypes 
guarded recursion principle need 
eliminating obtain scheme phi fam fact scheme constraints optimised usual way fam simple type 
consider general case 
immediate subgoal guarded fam recs phi intensionally speaking unfolding definition respect tells phi guarded refl guarded phi guarded refl subgoal constraints require exactly typed arguments reduce unification free recs phi goal addition auxiliary premise ready unfold revealing available recursive calls split cases may argument shown position immaterial 
note computational behaviour terms generated unification gives free phi guarded may consider parameters fixed 
replay interactive case splitting process justified covering splitting argument means eliminating case analysis rule datatype applying unification tactic subgoals 
unification tactic implements unification algorithm justifies elementary covering induced split know achieve exactly effect 
left subgoals corresponding covering recs phi ir know case analysis unification right intensional effect phi guarded ir time fill right hand side 
introduce premises refine return recs phi ir return expression want supply may contain recursive just refine 
replace applications calls fresh holes type 
nesting may write order nesting permitted able choose order 
shall write 
recs phi ir ij return call ij find elements recs course 
jr assumption structurally smaller ir type fam ij type phi expands product containing phi ij jr ij jr project call typed find matching substitution solves constraints 
may form refl ij jr instantiate ij point fact recs solve ij solves reflexive equations searches sigma types 
uniquely type recursive call arguments way search come back wrong value 
check type directed folding really finds recursive call 
point phi guarded ir phi guarded ij jr projecting applying shown gives phi guarded ij jr refl ij jr compare definition folds matching substitution know return call remains solve cut call return suggested earlier 
find exactly trivially unfolding folding calls returns disappear turn 
required constructing programs man bought full size replica michelangelo david 
put back garden invited friends round see 
just big block white marble said 
reply haven unwrapped 
theorem guarded recursion case analysis unification technology previous chapters replay justification pattern matching function known lie coquand class admissible definitions 
advantage knowing equations advance derivation covering merely check build term right type computational behaviour 
shall shortly see slight advantage essentially technique construct pattern equations go 
propose supply collection tactics programming 
performing theorem proving actions oleg state tactics create manipulate associated pattern matching programs way justifiable coquand criteria holes filled intensionally correct 
way running example propose construct vlast function extracts element nonempty vector 
fix suppress element type vlast nn vect sn shall tell pattern matching program point unwrap 
goal goal nn vect sn tactic indicates goal regarded programming problem 
tactic program goal 
fam 
type call return phi fam recs phi phi refl goal call 
proof tactic program turns goal premises programming problem 
goal solved appeal function arity recursive rth argument 
informative type family introduced call return eliminated relevant guarded recursion theorem 
leaves filling body function associated pattern matching equation labelled pattern variables listed parentheses describes aspects behaviour accounts 
left hand side equation indicating describes effect arguments matching free pattern arguments 
right hand side placeholder indicating decided returns arguments matching split goal yield subgoals specific constructor cases shall split equation corresponding equations instantiated patterns 
equations constitute pattern matching program building shall maintain invariant patterns constitute covering accordance coquand definition 
trivially case 
way program recursive allow omission tactic call 
correspondingly need apply guarded recursion theorem 
type rest unaffected 
vlast structurally recursive arguments immaterial choose 
shall pick vector 
see effect tactic vlast nn vect sn type call nn vect sn vlast return nn vect sn vlast phi nn vect nn vect sn sn vlast nn vect sn recs phi vlast vlast nn vect sn phi sn refl sn refl goal nn vect sn call vlast vlast 
nn vect sn know start process build coverings 
tactic split recs phi ir 
recs phi oe ir oe 
oe 

fam con fam oe general unifier terms con fam proof tactic split performs case split subgoal yielding bunch subgoals equation split correspondingly equations eliminate subgoal case analysis principle fam apply unification 
tactic succeeds provided unification case shows unifier finds mgu oe resulting collection justifies new covering justifies unfoldings show reduces case oe invariant patterns equations associated subgoals form covering maintained 
example shall certainly need split vector way nonempty vector vcons case survives nn vect recs rec nn vect sm sm vlast phi vlast vcons vlast vcons 
nn vect note wallet recursions unfolded step showing recursive call fact known nonempty 
effect informative tell patterns corresponding equation 
split finish job 
simply typed programming split see element 
need splitting tell need 
cz vect recs rec nn vect sm sm vlast phi vlast vcons cs nn vect sn recs rec nn vect sm sn sm vlast phi sn vlast sn vcons cz vlast vcons 
vect cs vlast sn vcons 
nn vect sn observe case way matching problem solved allow access recursive call whilst way clear 
having split far necessary fill right hand sides 
tactic return recs phi ir 
recs phi ir return return proof return may form replacing recursive calls calls holes type calls structurally smaller argument able solve holes appeal appropriate projections recs 
structural condition ensures new equation acceptable argument theorem shows holds intensionally 
example cases 
singleton value just head 
return gives cz vect recs rec nn vect sm sm vlast phi return cz vlast vcons return vect case nonempty tail recursive call return vlast cs nn vect sn recs rec nn vect sm sn sm vlast phi sn vlast return call quick search reveals appropriate recursion recs refl sn refl justifying equation cs vlast sn vcons return call vlast nn vect sn tell program finished gone 
may solve call return previous case 
leaves real term intensional behaviour corresponds associated equational program satisfies coquand conditions construction 
example vlast vcons vlast sn vcons vlast subtle way write vlast crucial extra indexing information 
erasing indices hope recovering function ordinary lists yields cons cons theta clearly right function function 
course split built usual vlast vcons vlast sn vcons vcons vlast vcons wish embark discussion relative merits programs merely point computation indices type behaves differently computation type directly interestingly 
combined effect tactics allow similar style interactive program development available alf build programs way 

having built programs store 
oleg representation program term involving guarded recursion case analysis unification recorded 
just write pattern matching equations 
construction programs section relied knowing just equations exploited justification equations satisfy coquand conditions recovered process building justifications interactively 
section consider just equations 
recognising programs question asked section pattern matching programs recover justification 
sadly shall see answer 
worth analysing point problem undecidable view building system store information allow recovery 
aim describe class recognisable programs 
progress direction done 
feel discussion problem worthwhile techniques described sufficient recognise examples thesis save trouble describing construction 
existing tactical presentation program construction assistance 
built structural editor acceptable programs 
imagine editor humans mechanical recogniser task take set pattern matching equations build program 
echoes view taken constructions may equip datatypes tools developed theorem proving structural editing oleg terms 
know relatively little writing compilers promising move build structural editor target language 
tactics previous section divide recognition phases ffl identify argument position recursion program guarded apply program ffl show patterns form covering applying split ffl fill right hand sides return third easy 
may simply check argument position turn satisfies condition applying program 
return codes exactly operation need 
second phase checking covering undecidability 
recursion spotting goal goal pattern matching program arity easy check recursive calls easy find equation set argument positions satisfy condition 
may say non recursive equations guarded argument positions 
coquand criterion requires intersection nonempty 
may apply program tactic indicated positions 
possible procedure yield choice positions 
may preference 
example structurally recursive programs fins necessarily guarded natural number indices 
really matter choose prefer recursion datatypes indices produces justification intuitive 
may apply program leaves subgoal associated equation 
relate program equations trying construct associated equations current state construction 
call covering equations patterns guaranteed form covering 
particular certain program equation covered exactly covering equations covering patterns may instantiated give program pattern 
covering equation may collect program equations covers just order matching problem 
possibilities ffl equation covered exactly meaning covered equation covers patterns renaming variables return applicable ffl covered equation covered exactly splitting necessary ffl equations covered means program incomplete cover undecidable type inhabitation problem look case turn 
exact problems reached stage covering equation 
exactly covers program equation may apply tactic return know guarded recursive calls available complete branch justification 
splitting problems covering equation 
covers program equations oe oe matching substitution terms time split covering equation introduce constructor symbol patterns patterns may nonlinear replacing pattern variable constructor form may add constructor symbol pattern 
may exploit property measure far away program equations covered exactly 
order matching exist program equation contain constructor symbols covering equation may simply count excess 
suppose covers equation split cases say covers 
know constructor excess equation strictly patterns contain constructor symbols 
may keep splitting problems exact empty sure process terminate 
split 
order see expand program equations terms know oe oe tuple just collection accessible recursive call values oe constructor headed candidate splitting 
split successful constructor symbols appear yielding simpler subproblems 
ideally constructor form splits yield solvable unification problems may split candidates carry 
candidate choose 
suggest prefer candidates higher type dependency hierarchy may induce splits arguments unification 
example building covering splitting vector automatically split length cases merely splitting length leave vector 
awkward non constructor expressions involved finite number candidates stage may keep trying split works 
conceivable impure world splitting early may yield unsolvable problems 
sake argument may consider recogniser nondeterministic justification 
far satisfactory safe 
empty problems subgoal recs program equations give clue go right hand side case splitting 
means programmer forgotten case ij empty morally need explain happen case arise 
types empty arbitrarily subtle reasons type inhabitation problem undecidable 
restrict sight constructor forms able code halting problem datatype inhabitation question see table 
empty types simple type step constructor base constructors require inductive argument prove empty 
may eventually disappear case splitting way telling required 
totally clever totally stupid 
reject problems hand 
unfortunately 
elimination rule type reductions corresponds empty program recognise recursion operators provided datatypes bona fide programs shall able solve empty problems 
having rejected trying zero infinity steps case splitting intuitively plausible option 
try case split argument turn proves goal success 
problem hard fail recognise program 
allow ignore cases arguments types fin 
idea type obviously empty constructor headed expression inhabits 
effectively programmer deal non obviously empty types explicitly calling subprograms eliminate 
construct program interactively takes steps splitting dispose type may represent step obviously empty subprogram gets called case pattern existed 
effectively records splitting process dismiss type 
find repeating able register commonly emptiness proofs way tried splitting empty problem encountered 
conceivable search path checking covering may lead obvious empty problems may lead non obvious empty problem 
may save crude nondeterminism 
better remains seen 
extensions feel brief mention number obvious extensions class programs willing consider particularly controversial 
functions varying arity simply typed languages seeing functions varying arity 
certainly curried functions commonplace serious happening fij equivalence explain 
little motivation allowing functions defined arity varying pattern equations 
contrast dependently typed functions relaxation syntax genuine benefit 
tend arise write function compute types involved 
example sum nn type sum nn sum sn nn sum sum nn sum sum sum sum ssn sum sn plus argument sum number subsequent arguments function computes sum 
point arities uniform abstraction am doing pattern matching newly exposed arguments 
course case introduce subprograms 
ffl basic datatypes start state halt state delta delta delta states blank symbol delta delta delta symbols left move right move ffl describing machine transition state transitions list transition tape symbol theta list symbol configuration state type lists built adding elements right hand constructor snoc 
overload nil 
ffl list membership element type list find member cons member seek member cons ffl updating tape update tape move tape type symbol list symbol update hnil ri left hnil blank cons ri symbol symbol list symbol update ri left hl cons ri symbol symbol update hl nili right blank nili symbol symbol list symbol update hl cons ri right ri ffl step step transitions configuration configuration type tr member hq di trs update hl ri tape tr step trs hq hl rii hq ffl halting problem halts transitions configuration tape type trs transitions tape tape trs tape halts trs tape step step trs halts halts trs tape go step halts halts trs tape table coding halting problem suspect functions uncommon practice worth trouble 
things say ffl dependently typed programming infancy know techniques turn common practice 
ffl kind technique somewhat strong normalisation proofs compute meta level function type objectlevel function type compute appropriate metal level function inhabit 
ffl sort behaviour supported industrial programming language remarkably common printf command takes formatting string followed arguments appropriate fields printed hope 
course check see sense 
compilers blink twice printf effect seldom benign 
dependent types functions 
may accommodate behaviour adjusting definition covering allow lengthening pattern sequences fresh pattern variables provided result type functional 
extended patterns may split 
lengthening course replaced call subprogram order recover uniform arity original 
treatment recursion 
recursive calls recognised provided arity pattern guarded recursion principle applied 
longer sequences arguments cut leaving recursive call right length applied 
exotic recursion sufficient facilitate functions recursive argument position convenient allow complex structures built single function forcing programmer break 
traditional example ackermann function ack nn nn nn ack sn ack sm ack ack sm sn ack ack sm recursion function lexicographic sense argument decreases structurally stays second argument decreases 
split pair coquand accepted primitive recursive functionals follows ack sm nn nn nn nn ack sm ack ack ack sm ack sn ack ack ack nn nn nn ack ack sm ack happened 
start main ack function functional 
enables sm case delegated auxiliary function ack sm receives argument function ack available structural recursion free apply function making guarded calls 
die hard programmers prefer write lexicographic version 
fact tools construct interactively suppose reached stage ack nn type call nn ack nn return nn nn ack ack recs nn sn ack nn recs nn ack theta nn ack sm ack recs argument gives access guarded recursion argument 
may add guarded recursion second argument eliminating fixing recs ack nn recs nn ack theta nn recs ack sm ack sm case splitting gives need pass ack explicitly recursion define locally successor case ack 
programmer uses pattern matching define fold operators 
ack nn recs nn ack theta recs ack sm ack ss nn recs nn ack theta nn recs ack sm theta ack sm ack sm sn ack case may project appropriate component recs 
looking ack ss detail nested right hand side translates call return ack ss nn recs nn ack theta nn recs ack sm theta ack sm rec ack sm rec ack call rec return call rec rec solved recs rec solved recs 
definition complete 
build quite complex structures multiple eliminations guarded recursion lexicographic recursion number argument positions 
example may define function lists trees recursion replaces head tree subtrees steps may list longer decomposition head tree guarantees termination 
question extend class recognisable pattern matching programs exotic territory important interesting 
attention paid simply typed case example ms system 
cristina cornes equipped coq substantial package translating equational programs relatively interesting recursive structure constructor guarded fixpoint expressions cor 
investigation scope thesis 
shall write equational programs chapter shorter clearer expanded versions recursion subfunction 
shall careful point justification imagining deriving function interactively 
chapter programs proofs developed substantial technology constructing dependently typed functional programs reasoning 
put technology 
course chapter offer examples believe illustrate advantages afforded working informative types 
shall see new versions old programs easier prove correct 
shall see applications elimination rule technology aid program discovery verification 
hopefully shall see sense 
shall focus manipulation syntax programming domain shows great effect expressive power dependent pattern matching 
particular shall construct prove correct order unification algorithm novel merit structurally recursive 
concrete categories functors monads examples follow shall examine methods working syntax dependently typed functional programming 
behaviour functions shall develop fits neatly categorical treatment worthwhile building tools packaging functions properties categorically 
shall need particularly heavy category theory just far am concerned 
substantial formalisation category theory see sh 
fact may restrict attention concrete categories objects interpreted family types arrows interpreted functions types family 
records categories shall say category 
idea objects types arrows functions data interpreted 
imagine modelling programming language categorically oleg datatypes representing types functions language translations model types functions oleg types functions 
datatypes give objects arrows concrete category translations interpretations 
fix types objects arrows 
type ae type define record type concrete contain things supply meaningful category ae ffi ae 
ae 
ae delta type delta ae ae ae ffi think safe overload delta 
confusion interpretations objects arrows arise examples 
saunders maclane mac defines concrete category category equipped faithful functor set 
interpretations preserve identity composition embed objects arrows set 
condition 
begs question appropriate equality objects arrows 
type theory marriage fidelity comes way see things 
oleg intensional equality discriminating useful 
propose consider arrows interpretations extensionally equal interpretations trivially faithful 
consequently little sense consider category separately functor interprets functor properties know category traditional absorption associativity laws respect extensional notion equality 
correspondingly ae abbreviation usual absorption properties ffi ffi ffi ffi ffi ffi follow reflexivity 
discharging parameters notion category 
shall typically write concrete ae mean category notion arrow leaving object type implicit 
type family fam type may define ae fam fam fam type may easily define operation delta families fam concrete ae fam objects interpreted fam arrows identity composition 
usual notion functions types family represented defined class category 
particular type identity function type type category oleg types 
special case may pretend type indexed type family manufacture object category endofunctions 
encounter categories arrows represented directly oleg functions 
example concrete ae nn arrows live nn nn mind interpreted plus identity composition plus property interpretation respects composition just associativity 
records functors functor takes objects arrows category objects arrows preserving identity composition 
certainly write requirements parameterised record 
fix source target categories open type ae type concrete ae type ae type concrete ae ffi delta delta ffi delta delta relative define record type functor fields fo fa ae 
fo ae fo fa fa fa fo fa ffi fa ffi fa note left human inferrable universal quantifiers sake readability 
extra condition preservation extensional equality arrows necessary 
possible extensionally equal source arrows distinguished computationally mapped different arrows target category expressly forbid 
course writing functor types shall suppress details just leave functor way example polymorphic type family associated functor 
nice manufactured automatically 
shall outline functor 
functor type type fo fa type functor just lifts functions exception propagating images 
table notation case expressions column heading indicates analysed underneath patterns right corresponding return values notation easily interpreted pattern matching 
remaining fields may easily proven inverting fa case analysis typed argument implicit extensional equations 
ml sense irritating aspect intensional type theory may implementations extensionally speaking function 
suppose candidate fa arrow part fa functor type extensional behaviour 
really annoying redo proofs properties functor fa replaced fa fortunately may argument 
point functor properties concern extensional behaviour fa may construct function takes source functor fa proof fa fa extension returning functor fa arrows properties 
shall give details amount unremarkable rewriting 
records concrete monads formalisation monads shall give concrete version kleisli triple presentation due manes man showed equivalent convention definition mac endofunctor natural transformations definition kleisli triple kleisli triple hj category ffl function objects objects ffl object indexed family morphisms tx interpreting elements image ffl family functions hj indexed pair objects ty tx ty satisfying equations ffl jhj id ffl fhj ffi ffl fhj ffi hj fhj ffi ghj kleisli category arising structure objects arrows ty 
gives object identity composition pi pi fhj ffi consequently ffi delta gives functor kleisli category gives functor kleisli category image composition functor objects 
hj pronounced bind 
presentation monads idea functor split ffi delta ji delta 
concrete categories functor may describe means concrete monad splits functor 
keep target source categories opened fix functor open names fields 
concrete monad splitting captures class diagonal arrows interpreted fo arrows kleisli category equipped notion composition pi behaves interpretation composition kleisli category 
think functor viewing packaging data representing error condition 
arrows source category reliable functions acting actual data arrows target category error aware functions may handle errors create 
functor takes reliable functions error propagating functions give actual output actual input transmit error conditions 
diagonal arrow unreliable function accepts actual data may result error 
monad splitting characterises class unreliable functions ffl reliable function unreliable image just packages output jif jif ffl unreliable function class error aware image propagates input errors may new output errors ghj ghj ffl combination thing source arrows formally fix carrier type diagonal arrows type collect relevant details record type monad fields ji delta ae 
fo ae fo pi 

delta fhj ji pi fhj split fa jif jig ji ffi jif pi jig fhj ghj pi hj fhj ffi ghj may look lot stuff remember diagonal arrows represented functionally really concrete association lists 
operations ji delta pi viewed syntactic 
ensure right semantics 
course just functions interpretation application easy 
functor trivial functional representations arrows source target 
corresponding monad take diagonal arrow type interpretation application 
ji delta just composes back argument whilst defined case analysis fhj fhj composition defined accordance requirement interpretation pi fhj properties ffl hold reflexivity 
ffl split hold case analysis reflexivity 
ffl holds rewriting premise 
ffl holds case analysis reflexivity case rewriting premise case 
function constructs concrete kleisli category concrete monad 
kleisli monad 
concrete concrete constructed operations ji ffi pi fo fhj observe theta theta ji definition ji hj definition delta fa split hh fo ii theta theta ffi pi definition ffi pi hj definition delta fhj ffi ghj fhj ghj definition delta substitution untyped calculus section shall develop technology give monadic man mog presentation substitution terms binding particular untyped calculus de bruijn indices deb 
bellegarde hook bh suggest datatype altenkirch reus ar describe heterogeneous bird paterson bp describe nested 
type lam type var lam app lam lam lam lam datatype terms arbitrary type variables 
defined sml recursion necessarily polymorphic unavailable 
haskell allows functions datatypes long types supplied explicitly 
languages terms may appear types policy advisable terms engage criminal activities nontermination 
fact scheme definitions restricts variable type inhabit smaller universe terms 
want kind indexed family indices types 
presentation works kind type level corresponding idea number variables abstraction introduces 
lam type closed terms 
type level nn rules computation indices available 
fortunately substitution structural terms 
need group areas act 
system terms trustworthy types 
nn god invented fin sets variables 
nn lam type fin var lam lam app lam lam sn lam lam lam type terms free variables 
shall see operations syntax structural availability recursion index 
placing types categorical setting fin concrete ae fin lam concrete ae lam objects categories elements nn interpreted fin lam respectively 
arrows function spaces interpreted application 
effectively abbreviate ae fin fin ae lam lam section shall looking build functor rename functor fin lam arrow variable space fin gives operation terms lam variables renaming indicated 
object part functor just identity nn 
may view functions type fin lam simultaneous substitutions variables terms variables seek monadic implementation monad rename note rename endofunctor notion monad think splitting monadic way 
consequent kleisli category interpret substitutions functions terms set variables terms 
terms need basic tools working variables de bruijn style 
lift thin thick de bruijn insight see variable just binding 
variable indices count outwards bindings local 
example time go binder new variable old ones get incremented 
may represent distinction constructors fin family 
suppose renaming arrow ae order apply renaming term explain expanded variable space lam affect free variables embedded fs leaving newly bound fz variable 
sm ae sn fz fz fs fs recognisable program 
discharging arbitrary obtain functional lift takes appropriate suppress boring arguments apply 
lift nn fin fin fin sm fin sn lift fz fz lift fs fs lift gives arrow part functor lift functor fin fin lift fo fa lift recursion induction principle lift may regard generated automatically equational definition 
lift recursive function informative call inversion principle nn ae phi fin sm fin sn type phi fz fz phi fs fs fin sm phi lift functor properties left elliptic follow easily inversion 
shall show leave imagination 
nn ae ae fin sr lift ffi lift lift inverting boxed lift application acquire subgoals nn ae ae fin sr lift ffi fz lift fz nn ae ae fin lift ffi fs lift fs reduce respectively fz fz fs fs see reflexive 
lift define important class renamings 
add new variable set necessarily top 
old variables thinning liquid metaphor 
sn choices new variable thin renaming shuffles old variables new changing order 
idea morally thin particular thin new variable fz thinning just fs embedding 
lifted thinning 
thin nn fin sn 
ae sn thin nn fin sn fin fin sn thin fz fs thin fs lift thin thinning provides alternative view 
variable new embedded old thin fin may imagine partial inverse thin distinction extensional behaviour thick nn fin sn fin sn fin thick thin thick fin thick refinement decidable equality finite sets tells elements differ way 
get help writing thick try prove pair equational laws common abstracted recursion induction thin defined obvious way 
seek thick nn fin sn fin thick nn fin sn fin thick thin thick fin abstraction outside equations allows transformed simultaneously 
induction yields subgoals thick nn fin sn fin thick iz nn fin thick fz fs thick fz fz fin thick nn fin sn fin fin sn hyp fin thick thick fin fin sn thick fs lift thick fs fs fin sn know thick fz gain information fs case inverting lift 
allowing inside sigma binding appropriate algebraic manipulation obtain thick nn fin sn fin fin sn hyp fin thick thick fin sz thick fs fz sn fz fin thick fs fs fs thick fs fs fin sn stripping away excess notation certainly base cases function thick fz fz fin thick fz fs thick fs fz sn fz useful information step case 
satisfy fin thick thick fin fin thick fs fs fs thick fs fs fin sn effectively branch propagates result corresponding recursive call stays stays recursive value passed appropriate monadic lifting hj 
program thick fz fz fin thick fz fs thick fs fz sn fz thick fs fs hj thick construction satisfies base case equations reduces step case fin thick thick fin fin hj thick fs hj thick fin sn holds rewriting hypotheses 
desired extensional rules satisfied 
corresponding non computational inversion rule real prize nn fin sn phi fin sn fin type phi fin phi thin fin sn phi thick tells possible outcomes thick circumstances arise 
fixing new variable case thick returns old variable thinned case thick identifies 
useful rule effectively performs constructor case analysis output function 
see just helpful 
guess prove rule 
right thick recursion induction principle making sure keep phi scheme inductive hypotheses elimination rules 
start matthew nn fin sn phi fin sn fin type oe phi fin oe fin phi thin fin sn phi thick indicated boxing recursion induction scheme abstracted 
acquire base subgoals corresponding base cases function follow directly oe diagonal oe fz 
step subgoal concentrate remaining interest 
ss nn fin sn fin hyp phi fin sn fin type oe phi fin oe fin sn phi thin phi phi fin ssn fin sn type oe phi fs fin sn oe fin sn phi thin fs fin sn phi fs hj position oe oe know applies 
computation blocked point hj applied result recursive call constructor form 
case analysis result recursive call exactly effect inductive hypothesis 
eliminating indicated scheme obtain ssn oe phi fs fin sn phi fs hj fin oe fin sn phi thin fs fin phi fs thin hj lifted fs reduces propagating cases correctly 
follow indicated hypotheses 
elimination rule holds 
fact way inductive step proven shows rule useful wider setting 
applying rule unblocks computations waiting case analysis result call thick common 
example may define function delta 
delta nn fin sn lam sn 
thick fin var delta 
delta pronounced knockout generates substitution function variables terms removes replacing term remaining variables 
source variable thin mapped removing variable set reordering 
proving properties delta 
delta see reduce case analysis thick 
point elimination exactly effect required unblock computation 
interested comes thick conventional elimination goes clumsy way proceed 
tools variables turn attention terms 
substitution monad splits renaming functor decided object part functor rename just identity nn 
fairly clear renaming substitution just composing var back jif var var identity substitution 
remaining programming consists arrow part rename operation effect terms 
fairly clear shall fhj var monad law fhj app app fhj fhj 
clear push binder 
need 
fhj lam lam omega fi fi lifting takes source bound variable target bound variable behaviour free variables respects defined lift lift renamings 
lift substitutions 
bound free case analysis source variable easy 
know bound variable case analysis tells old variable applied 
yields term old variables renamed free variables target set 
know variable renaming just fs need lifted terms 
need fz var fz fs hj trying define applying recursively result structural 
solution define renaming fa operation advance know lift renamings fa var var fa app app fa fa fa lam lam fa lift define fa fs hj leaving free define terms 
altenkirch reus point involves writing similar functions terms function 
course function saves lines code expense founded induction ordering exhibit prove satisfactory 
suggest turning blind eye proof obligations function preferable expressing vague hope carpet sweeping actual day magic 
happens necessary magic 
fa implemented single structurally recursive function provided sufficiently parametric 
suppose type family function fin map function terms provided know ffl convert output terms lam ffl represent variables ffl lift functions fin sets sets know things fin renaming build operations fact easier time proving monadic behaviour substitution take opportunity generalise lifting inserting new variables fz inserting thick thin just easy implement 
thick variables lift requirement thin 
goal nn type vt nn fin nn lam nn fin sn sn map nn fin lam lam subject parameters may build lifting thinning parameter liftt nn fin sm fin sn fin fin sm sn liftt thick fin vt new source variable corresponding target variable 
lifted function uses thick distinguish new old embeds vt result 
map function may written map var map app app map map map lam lam map liftt fz fz parameters discharged may take fa map fin var thin fa thin map lam var note notion lifting renaming liftt fin var thin fz fz extensionally lift function defined earlier 
follows easily inverting thick contained liftt 
inherits functor properties 
task plug relevant functor monad 
am afraid say little forward planning point pay dividends 
motivate best 
functor monad require extensional equality arrows respected conditions apply fa 
implemented map worth proving property map parameters abstracted 
goal nn fin hyp fin lam map map hope learn technique recommend recursion induction map 
map chosen second 
subgoals time nn fin hyp fin fin rewrite hyp 
nn fin hyp fin lam fin hyp fin map app map map app plug hyp turn map thing happens map 
fact inductive proofs implicitly lam shall encounter thesis app case proof rewrite inductive hypotheses 
shall omit 
course real interest lam case nn fin hyp fin lam sm lam sn fin sm sn hyp fin sm liftt fz fz map lam map liftt fz fz lam equation respects function application may strip map liftt fz fz ripe inductive hypothesis leaving hyp fin sm liftt fz fz liftt fz fz expanding liftt find really hyp fin sm thick fz fin vt fz fz thick fz fin vt fz fz computation blocked thick applications know invert 
arguments may invert simultaneously 
course instance case analysis effect thickening fz know thick implemented want effect inversion inversion 
left cases case vt fz vt fz case fin fz fz reflexive second rewriting hyp 
proven may discharge parameters 
prove renaming functorial supplied fo fa 
remains prove properties 
just special case 
property gives goal nn lam fa recursion induction comes 
trouble twofold ffl scheme map recursion induction abstracted different source target objects unified 
elimination tactic supply constraint resolve little clumsy 
ffl scheme abstracted arbitrary renaming concerned particular 
tactic give constraint function intensionally equal extensional equality proof go 
come understanding correct manipulation constraints kind inductive proof 
structural induction 
var app cases easy 
lam trust doing proof write 
nn lam sm fa sm lam fa liftt fz fz lam may introduce hypotheses strip lams 
leaves inductive hypothesis looks bit try transitivity rewriting backwards 
fa liftt fz fz fa sm get bonus proving advance 
goal asks show renamings thing term apply show agree variable fin sm liftt fz fz sm liftt fz fz functor properties lift including preservation identity exactly goal 
nn ae ae lam fa ffi fa fa recursion induction friend 
eliminating boxed application find easy var app cases 
lam case similar previous proof nn ae ae lam sr lam ss hyp nn ss ae fa ffi liftt fa lam fa liftt ffi lam fa liftt strip lams apply transitivity inductive hypothesis right leaving fin sr liftt ffi liftt liftt surprise 
property lifting functor preserves composition 
renaming functor 
turn showing substitution monadic 
supplied ji delta composition var 
representation functional interpret arrows application 
may supply directly kleisli pi demanded pi fhj mx reduces reflexivity true construction 
follows var respects equality whilst instance 
reflexive 
split require real 
split says split nn ae lam fa prove exactly plan 
recursion induction leaves easy var app cases 
lam case reduces strategy split fin sm liftt fz fz jif var liftt thin fz fz composing var lifting commute 
expansion blocked thick fz 
inverting thick leaves trivial subgoals 
starts way nn lam pi hj fhj ghj usual story lam case reduced fin sr liftt pi liftt liftt says lifting substitutions respect composition know result renamings 
boil goal little expanding outer inverting blocked 
give cases newly bound variable just reflexive equation indicating correctly propagated lifting free variables awkward 
fin fz fhj liftt hj fz special case lemma need prove crucial fact relationship thinning substitution nn fin sm fin sn lam fhj liftt hj substituting thinning effect applying lifted substitution 
point inventing new proof plan old 
var app easy 
modulo need switch thin lifted thin thin reduce lam case equation involving blocked simplify inversion leaving free variable case fin fs fz fz sn just renaming thin really fin fa lift thin fa fs fa fs sn fa thin may rewrite sides property renaming preserves composition backwards fin fa lift thin ffi fs fa fs sn ffi thin lift shuffle fs thin 
sides equation intensionally 
proven substitution monadic 
correct order unification algorithm main example dependently typed functional programming thesis 
propose study unification trees holes 
algorithm variation theme goes back alan robinson rob 
program implementing algorithm new benefits dependent type system way just available simply typed world remarkable higherorder polymorphic extensions available sorts programming language 
shall critical fact types depend data real data elimination rules 
just lam represent variables fin trees binding may fix number variables parameter type 
ffl formation rule nn tree type ffl constructors fin var tree leaf tree tree fork tree ffl elimination rule nn phi tree type phi var phi leaf phi phi phi fork tree phi may construct renaming functor substitution monad tree path lam required cope binding 
section ae tree tree fin tree rename functor fin tree monad rename kleisli framework may equip substitutions preorder induced prior composition pi task unifying tree find arrow fhj fhj exists particular find maximal respect ordering 
unification optimisation problem worth spending little time thinking problems general proceeding particular example 
optimistic optimisation unification just example problem involving optimisation respect conjunction constraints 
draw attention particular class constraint problems vulnerable nave technique optimism 
guessing optimum best thing think 
encounter constraint turn continue think best allows reducing current guess necessary 
worked way constraints hoped final guess bitter experience genuinely optimal 
hope holds true constraint property solution smaller remains solution 
call constraints closed short 
property constraints gives underlying rationale transformation recursive optimisation algorithms accumulating solution technique way automated synthesis parts unification algorithm asg 
give record type characterising properties arrows ordered composition 
fixing category source object may represent closed constraint arrows inhabitants record type closed fields ae type ae closure ae ae ffi note extra condition constraint distinguish extensionally equal arrows 
price allowing functional representations arrows intensional type theory 
may define means maximal respect constraint 
fixing opening record fixing target arrow ae may collect relevant conditions record maximal fields holds factors ae sigmah ae ffi solution solution smaller witness 
may easily prove maximality respects extensional equality arrows 
define operator closed constraints 
closed closed closure closure theta proofs properties unremarkable 
optimistic strategy constraint extends accumulated guess ffi holds 
may regard effectively constraining witnesses existence solutions bounded constraint closed provided construct operator bound ae closed closed bound closure ae ffi properties easily proven 
ready prove optimist lemma optimist clp clq closed ae gmax maximal ae fmax maximal bound maximal ffi key step correctness proof optimistic strategy 
tells conjunction may optimised extending optimum just satisfy proof difficult reasons 
unpack definitions elimination rules argument records introduce hypotheses pcl ae ae pk sigmah ae ffi ae ffi ae ffi sigmah ae ffi max maximal ffi may attack goal rules records implications pfg ffi ffi ae pk qk ae ffi ffi ffi known hold ffi follows pcl certainly solution composite problem 
remains show optimality expressing hypothetical solution ffi ffi proof successively exploits optimality solution subproblem 
firstly acquire ae ffi know ffi gives ae ffi supply witness ffi ffi ffi ffi ffi required 
note proof 
effect optimise respect collection constraints downward closed long address non closed constraint freedom shall need 
optimist lemma allows solve complex closed constraint recursively decomposing equivalent conjuction simpler closed constraints address turn accumulating solution 
accordingly shall need book equivalence closed constraints equiv closed closed type equiv ae theta proof equivalent constraints arrow maximising maximises easy 
lots algorithms follow optimistic strategy finding largest element nonempty list numbers principal type inference ml 
see works unification 
optimistic unification unifier substitution subject constraint fhj fhj may consider computation general unifiers optimisation problem kleisli category induced substitution monad 
fortunately constraint downward closed 
may construct unifies closed unifies fhj fhj properties easily proven 
extensional equality arrows means exactly effect terms 
downwards closure follows fact interpretation arrows kleisli category substitution respects composition 
easy provide justification structural decomposition rigid rigid problems equiv unifies fork fork unifies unifies may represent arrows dependent pair sigman nn guess type unification algorithm mgu tree adoption optimist strategy means defining mgu terms subfunction bmgu computing unifiers general relative accumulated bound 
bmgu tree identity substitution biggest substitution composition ordering take mgu bmgu hm note function arrow kleisli category monad know propagate unification failures correctly 
suggests functional definition bmgu rigid rigid cases bmgu leaf leaf bmgu leaf fork bmgu fork leaf bmgu fork fork bmgu pi bmgu 
far structural terms 
trouble comes encounter variable 
unify variable tree relative nontrivial bounding guess 
traditional approach unload accumulator may easily prove lemma unload equiv bound unifies unifies ghj ghj unfortunately applying substitution blows terms corresponding recursive program structural 
think need impose external termination ordering accessibility argument exploits fact substitutions blow terms get rid variables 
fact case 
dependent types rescue incidentally just noticed augustsson carlsson ac contains section title expect traditional 
certainly need exploit property accumulated substitution gets rid variables blows terms 
development unification literature externally program means ad hoc termination ordering 
invariably requires auxiliary function count distinct variables term auxiliary lemma relates value function substitution subject occur check 
say vital component sense unification algorithm absent implementations understandably data structures manifest sense available 
point explaining terms built finite context variables equipped exactly natural recursive behaviour need 
count number variables term posterior phenomenon structural linguists prior requirement terms considered meaningful 
number variables arrived belongs type terms 
look type bmgu bmgu tree proceed structural recursion trees structural recursion stress strongly indexing types terms allows 
parametric polymorphism compute types 
structural forms computation available dependently typed setting just simply typed languages 
recursive structure suggest lexicographic unifying trees sm variables entitled recursive calls trees variables large 
course number variables merely decreasing structural way time avoid appeals founded recursion 
seen define substitution gets rid single variable delta 
delta function 
delta 
delta nn fin sn tree sn 
thick fin var delta 
delta easily shown extensional behaviour thinking relationally rules care termination 

thin var follow directly established extensional behaviour thick 
corresponding inversion rule follows nn fin sm tree phi fin sm tree type phi phi thin var phi 
accumulator composition delta 
delta may apply step time reach variable 
fact merely structural way unification quite efficient 
course constrain accumulator take form easiest way means abandoning functional representation substitution favour concrete association list treatment 
define datatype ffl formation rule nn alist type ffl constructors anil alist fin sm tree alist alist sm datatype combination conventional association list relation 
definable alf coq oleg agda cayenne nonlinear base constructor type 
may equip ffl composition behaves append association lists transitivity anil fzg ffl interpretation delta 
delta anil pi 
correspondingly may manufacture concrete category alist concrete alist anil ffi tree jhj trivially functor alist arrows interpretations arrows source target 
arrows alist propose search unifiers show general computed yields general 
correspondingly take sigman nn alist define bmgu tree mgu tree mgu bmgu anil need outline structurally recursive bmgu deferring treatment base cases bmgu leaf leaf bmgu leaf fork bmgu fork leaf bmgu fork fork bmgu hj bmgu bmgu sm var var anil ji extend hj bmgu 
hj var 
hj var bmgu sm var leaf sm anil leaf sm ji extend hj bmgu 
hj var 
hj leaf sm bmgu sm var fork anil fork ji extend hj bmgu 
hj var 
hj fork 
symmetric cases extend hn gi hn gi failure propagating image 
correctness mgu spirit refinement reduce correctness unification algorithm correctness 
defined motivate definition seeing get stuck 
specification mgu form inversion principle nn tree phi type phi alist maximal unifies phi hn fi phi mgu fhj fhj prove inversion principle bmgu nn tree phi type alist jhj jhj phi hn fi alist alist maximal bound unifies phi hn fi hn phi bmgu proof simply expands mgu terms call bmgu inverted 
leaves subgoals instantiated anil 
recall anil just 
properties alist reduce subgoals 
interesting proving 
course proofs non computational rules recursion induction proof recursion induction bmgu keeping phi universally quantified 
subgoals involving variables follow program case analysis accumulated substitution 
may classify subgoals follows ffl rigid rigid diagonal known conflict trying unify leaf fork bmgu returns apply case 
leaves proving nn alist bad jhj leaf jhj fork fortunately reducing pushes substitution constructors leaving hypothesis bad leaf fork jhj jhj goal proven unification tactic chapter 
ffl rigid rigid diagonal known injectivity correctness leaf leaf easy 
fork fork computation reduces goal phi bmgu hj bmgu worked expect inductive hypotheses invert recursive calls 
shall 
leaves subgoals 
unification failed ultimate value inversion give proof may show original forks unifier 
substitutions proofs gmax maximal bound unifies hmax maximal bound unifies unification returned zf applying case leaves trying prove 
goal maximal bound unifies fork fork unload followed structural decomposition alist goal maximal unifies jhj jhj unifies jhj jhj pi applying optimist acquire subgoals goal maximal unifies jhj jhj goal maximal bound unifies jhj jhj unload backwards lets move bound giving goal follows immediately gmax 
may shuffle bound inside apply composition laws get goal maximal unifies jhj jhj pulling composition bound reduce goal hmax 
ffl flexible cases way 
bmgu hn gi variable 
reduces bmgu 

inverting recursive call inductive hypothesis find things jhj 
hj jhj 
hj prove jhj jhj just pi 
just question pushing composition 
maximal bound unifies 

prove maximal bound unifies proof easy bound shuffling composition hacking 
ffl flex flex base case computation bmgu var var anil reduced may safely presume answer identity coalescence situation equals 
choose case proof leaving obligation goal maximal bound unifies var var may easily remove trivial bound yielding goal maximal unifies var var implemented go proof 
export goal specification 
ffl flex rigid base cases subgoals trying unify var variable 
may collect rule expressing side condition nn fin sm tree sm fin sm var phi sm sm type alist jhj phi hn gi alist alist maximal bound unifies var phi hn fi hn phi anil regard inversion rule specification little general 
example hypotheses rule arbitrary accumulators know accumulator anil 
accumulator anil longer need vary scheme 
tidy little 
nn fin sm tree sm fin sm var phi sm type var phi alist maximal unifies var phi hn gi phi tidy version proves version tidy hypotheses special cases ones modulo equational reasoning 
take specification 
proven correctness unification contingent correct implementation 
may noticed unwrap proof merely showed general unifiers computed base cases correctly propagated 
create substitutions shall real proving maximality 
order achieve come understanding variable occurrence 
seen know unification algorithm terminating accord 
substitution tells occurs check conventional presentations unification occurs check boolean decision role ensuring termination external program 
situation somewhat different happen occurrence var rigid unified 
just substitute manifest program elimination computing image syntax fewer variable find 
general unifier var prove lemma shall need times 
knockout nn fin sm tree maximal unifies var 
real 
introducing maximal record holds 
hj var 
hj factors nn sm hyp fhj var fhj sigmag ae pi 
holds notice left hand side just 
rewrite rules observe right hand side composition substitutions 
little monadic obtain holds ji hj 
pi hj says substitutions behaviour arbitrary tree prove behave variables 
holds fin ji 
pi reducing obtain holds fin var 
thin follows established extensional behaviour delta 
delta 
unifier show unifier factors 
introducing assumptions pair nn sm hyp fhj var fhj fac pi 
try prove fac hoping shed light goal comes checking substitutions agree variables fac fin sm ghj 
predictably step invert blocked computation fac ghj fac fin thin subgoal gives big clue 
prove fin thin prove fac little monadic massage shows extensionally composition pi making replacement fac pi hj unwinding composition reduces goal hyp 
progress nontrivial substitutions generated general unifiers lemma 
position write fin sm sm thick fin hsm hm var recall establish correctness prove max nn fin sm maximal unifies var var defined thick verified leaving cases nn fin sm maximal unifies var var anil nn fin sm fin maximal unifies var var thin var anil recall anil identity substitution clearly unifies equal variables equally clearly unifier factors 
interpreting association list tidying get nn fin sm fin maximal unifies var var 
var follows knockout 
role thick plays attempt compute image variable set removed 
succeeds manufacture corresponding knockout 
fails identity substitution 
analogous role played occurs check seen attempt compute appropriate tree knockout fail exactly case offending occurrence 
correspondingly occurs check longer boolean decision provides witness explains safe substitute 
sense appeared program 
type occur check check fin sm tree sm tree inversion rule nn fin sm phi tree sm tree type phi occurs phi tree tree sm phi check occurs useful means characterising occurs words check partial inverse 
implement check pushing thick trees variable causing 
really occurs check formalise notion occurrence 
positions idea pattern matching explain decomposition inverting construction exposed early age simply refuses wear 
seen nneq terms duplication thick terms thin 
searching occurrence kind decomposition help asking corresponding construction 
identify operation occurrence operation puts position 
order shall need represent positions tree 
datatype allied datatype positions hole contexts elements operation puts hole 
huet gives beautiful construction zipper types code hole contexts paths hole back root term recording contents side branches way 
may equivalently slightly conveniently purposes reverse direction code paths root hole 
define parameterised datatype pos positions ffl formation rule nn pos nn ffl constructors pos pos tree left pos tree pos right pos constructors may interpreted directions finding position root respectively go left go right 
consequently function puts term position delta delta goes pos tree tree allow break convention write goes postfix definition goes left goes fork goes right goes fork goes particular may describe term containing var var goes order reason positions useful apparatus 
may consider goes interpret pos arrows category object interpreted tree identity 
define composition spirit piece shall write infix operator called pos pos left left right right definition goes ensures correct interpretation 
easy recursion induction proves correct interpretation goes goes goes way datatypes list nn single constant base constructor nil linear step constructors cons isomorphic position types 
goes operations append plus 
may account regular behaviour 
returning tree syntax shall need push substitutions positions 
overloading slightly pos pos fhj fhj left left fhj fhj fhj right right fhj fhj recursion induction operation gives proof coherence fhj goes fhj fhj goes order prove occurs check failure causes unification failure shall need show position may find term inside nn tree pos hyp goes seen similar theorem 
proof goes induction case analysis 
lot impossible cases removed unification obviously left right positions var leaf 
real done fork 
cases shall just give proof fork left nn tree pos hyp goes pos hyp fork left fork goes trick rotate cycle 
reducing goes hyp fork fork fork goes unification identifies tells fork goes careful turn cycle apply relevant inductive hypothesis 
categorical tools allow rewrite equation left goes inductive hypothesis tells left manifest nonsense need constructor appear head left hand side reveal conflict 
say case analysis accompanied unification tactic completes proof 
position fill component unification algorithm 
check suggested earlier check function pushes thick tree 
check var hj thick check leaf sn leaf check fork check check fork tree tree tree tree know talk positions give function better inversion principle nn fin sm phi tree sm tree type phi phi var goes tree tree sm phi check proof omit recursion induction inversion blocked computations 
define check hm tree sm show function satisfies specification nn fin sm tree sm fin sm var phi sm type oe occ var phi sm oe nn alist fmax maximal unifies var phi hn fi phi prove expanding inverting check leaving cases 
tree phi sm type oe nn alist fmax maximal unifies var phi hn fi phi hm introducing hypotheses refining oe unpacking association list left proving maximal unifies var 
follows knockout lemma 
case inversion pos sm fin sm var goes var phi sm type oe occ var var goes phi sm phi sm time introducing hypotheses refining oe expanding leaves nn sm bad fhj var fhj var goes coherence may push goes telling fhj goes tells reducing var var may easily prove goal 
comment verification unification long line developments 
zohar manna richard waldinger pioneering hand synthesis mw lawrence paulson machine verification lcf pau diverse proof systems coen rou bove faced inherent problem explaining program simply sense maker intended 
critical correctness unification algorithm terms context variables 
relativised data structures occur naturally dependent type systems 
unification structurally recursive just structure data right types came 
pleased vocal 
delicate aspects unification handled treatment entirely independent ffl termination algorithm ffl propagation unifier computed part problem rest problem ffl failure unification due failure occur check termination issue years separated partial correctness increasing technique standard literature wellfounded recursion ad hoc ordering 
manna waldinger mw sensible leave choice ordering extracted conditions satisfy deferred choice ordering oe un satisfy ordering conditions accumulated proof 
choice ordering motivated formally steps derivation 
necessary ordering combines lexicographically size variable set structure problem different treatments manifest slightly different ways 
paulson pau points works harder motivating desire lcf package founded induction order emulate manna waldinger development closely 
implementations generally recursive programs type theory necessarily involve computation proof termination 
different strategies exist minimise impact intrusion proof program 
joseph rou manages confine logical component outermost wellfounded recursion number variables inner recursion terms purely structural 
ana bove moves systematic way bove 
alf program recursion proof accessibility relation constructed directly haskell program wishes import arguments program indices relation 
single induction relation splits cases corresponding left hand sides original program exposed sub proofs give exactly recursive calls 
course prove elements accessible founded lexicographic induction packaging complicated induction single relation supported program effectively acquired facto recursion induction principle useful proving properties 
course program similar lexicographic recursion internalised data structures 
avoid appeal founded recursion number variables unloading accumulated substitutions incrementally unreasonable built incrementally incidentally enables delay critical 
interesting consider trouble normalised representation substitution applied 
normalising substitutions case computationally quite expensive 
manna waldinger hard synthesise accumulation unifier list subproblems 
idempotence unifier plays pivotal role 
paulson proof apparently simpler occasional ugly steps 
coen coen describes problem awkward aspect partial correctness 
optimistic treatment accumulators problem easier deal introducing accumulator extra parameter effectively strengthens inductive hypotheses subproblems exactly necessary manner 
armando smaill green automated synthesis manages profit excessive prompting asg 
bove exploits accumulating parameter benefit 
shown natural technique employ order respect seek optimum induced notion composition 
showing unifier occur check fails treatment morally manna waldinger packaged slightly categorically 
slightly concrete 
datatype positions attendant operations thin means inversion occur check instantiates investigated term patterns capturing relevant information presenting propositionally 
position datatype comes play proof program case choose 
may day want unification algorithm augments failure response diagnostic information phd student desperate cash easier time finding type errors undergraduate ml program 
point concrete representation positions 
type check just easily check fin sn tree sn tree pos sn returning witness case failure 
treatment positions hardly wasted 
furthermore huet points hue reason construction position apparatus automated arbitrary datatypes 
comment packaging aspects development unification thesis 
firstly monadic treatment failure propagation substitution necessary equipment useful orderly way 
secondly inversion recursion induction principles capture behaviour components lent regularity components correctness proof believe substantial credence methodology capturing leverage way 
recall example inversion occur check exposed information pertinent possibilities performed consequent rewriting allowing progress computation 
effect triggered asking single high level question program component happened occur check low level question data values tree 
able stare unification going blind 
chapter contributions thesis 
firstly somewhat tangentially introduced oleg type theory holes advantages ffl separation partial constructions core computational terms way partial constructions holes live behave replacement property ffl internalisation account holes judgments theory allowing state theorem prover represented exactly valid context course relative systems explain holes aid explicit substitution disadvantage forbidding certain interactions holes computation 
troubled 
admittedly involved kind higher order problem banned interactions help 
hand resemblance miller mixed prefix mil treatment strong suggest brand higher order unification feasible 
handles interaction holes computation raising holes functionality required ensure computation happens entirely scope 
deeper exploration needed say oleg suitable basis sophisticated theorem proving 
effective basis tactics mechanised constructions main thesis depends 
build object level support pattern matching dependent types conventional type theory extended uniqueness identity proofs 
closes problem opened thierry coquand status pattern matching coq cs implemented alf mag demonstrates uniqueness identity proofs sufficient support pattern matching unification underpinning case analysis order constructor forms unification suggested coquand implemented alf 
necessity shown hofmann streicher hos hof 
course demonstration new john major formulation propositional equality 
allows elements different types aspire equality ensures treated equally come type 
john major equality equivalent martin lof equality considerably convenient practice 
facilitates expression unification problems sequences terms involving type dependency requiring dependency equations 
consequently able extend object level order unification algorithm simply typed constructor forms msc mcb dependently typed case 
necessary confusion cycle theorems family types constructed automatically uniform way 
objectlevel unification required support pattern matching shows need uniqueness identity proofs idle coincidence 
famous dictum marx engels merely show dependently typed pattern matching meaning conventional type theory point show 
hope successively argued principle representing relativised data relativised types 
believe developments substitution unification chapter lend tangible credence argument 
unification example particular demonstrates importance allowing datatypes depend terms 
may require general recursion abandoned sake typechecking programs structurally recursive gives structures types indexed terms allow computation indices types indexed types 
mantra recursion structural am wrong structure 
dependent types sense general recursion sense lucky 
examples right structure hard represent internally program external termination argument prudent course expressiveness dependent type system offers improved prospect principled structural alternatives 
functional programming community ignores dependent types 
turning programs proofs suspect idea elimination rules capture behaviour program components abstractly implementations important 
specifications tell programs write tell need know function 
behaviour clearly elimination character 
kind second order rule supported oleg eliminate tactic exploits information compact powerful way relativised goal motivates 
quite happy specify write programs derived rules modular fashion derive corresponding elimination rules lennart augustsson disagrees number 
opinion trying cake eat convinced advantages cake 
reason programs modular fashion 
trying far long prove properties programs primitive rules data dream writing programs way 
henrik persson identified style reasoning considerable assistance formalisation polynomial ring 
order equational specifications half job inappropriate reasoning usage programs 
characterising behaviour need complemented effective treatment elimination 
believe technology methodology developed thesis contributes writing programs sense effective exploitation sense reasoning 
world far better turn things upside 
bruce great deal done 
firstly far technology supporting dependently typed programming concerned important task identify recognisable dependently typed programming language 
things stand equational programs write correspond deducible computational behaviour complex proof terms want able check reloaded program need reload justification 
pointed chapter problem lies ensuring stored programs give satisfactory account empty cases 
believe reasonable way go machine capable detecting argument types shown empty step case analysis 
step required empty type split nontrivial constructor cases program record 
effect program contain hints allow reconstruction emptiness proof 
consider insisting types filled markers indicating badness regions empty 
implications expressiveness type system enforcement discipline entail early say 
propagation badness surely involves propagation emptiness 
question gives clearest treatment explicit approach certainly worthy attention 
development improved technology programming dependent types imperative write programs 
despite clear argument principle precise data structures lead tighter programs types rhetoric changes practice competition 
example close home springs mind development polymorphically typed strongly terminating functional programming language parser type inference algorithm interpreter 
encoded natural semantics coq ter ter simply typed presentation terms types inductively defined relations describing valid formation typing 
reasonable hope properties built directly data structures dependent types 
altenkirch reus ar augustsson carlsson ac moving positively direction 
having developed firstorder unification ml style type inference algorithm dm obvious step especially finding principal types optimisation problem addressable optimistic strategy 
existing developments simple types available comparison nn dm 
tandem continuing development programming technology development strong specification methodology includes elimination rules task genuine importance 
focus development program derivation verification 
early stage reached thesis seen small example elimination rules transform specification program development thick thin 
area interest touched thesis prominent thinking derived elimination rules programming 
starting point phil wadler suggestion equip datatypes different views wad supporting different notions pattern matching underlying type put sound footing 
motivation development straightforward 
matter course write derived constructors functions build elements datatypes patterns reflecting macroscopic structure problem hand 
write plus add numbers snoc add element list forth 
surely helpful equip programmers means analyse data macroscopic level 
great deal attention paid developing goes righthand side pattern equations principled way left hand side long neglected 
time left came 
lose chains 
world gain 
appendix implementation points prototype implementation ffl oleg implemented primarily technology machine construction standard theorems equip datatypes support writing tactics relatively high level 
separation partial constructions terms rigidly enforced 
uses lego unification algorithm scoping conditions solving holes enforced 
complete terms generated independently checked lego reliable typechecker trusted 
restrictions positioning behaviour holes implementation complete 
developments implemented obeyed 
gives anecdotal support suggestion way natural restrictions 
ffl implementation eliminate tactic abstraction facility described chapter 
entirely adequate programming thesis abstractions necessary working datatype elimination rules 
tactic support derived elimination rules functions way 
examples rules implemented machine checked elimination rules functions applied hand 
ffl invention john major equality came time stopped prototype 
consequently traditional equality plus uniqueness 
telescopic equations represented somewhat awkward way equation telescope coercing previous ones order typed 
significantly complicated elimination tactic unification technology 
bibliography ar thorsten altenkirch bernhard reus 
monadic presentations generalized inductive types 
computer science logic 
asg alessandro armando alan smaill ian green 
automatic synthesis recursive programs proof planning paradigm 
automated software engineering 
october 
aug lennart augustsson 
compiling pattern matching 
conference programming computer architecture 
aug lennart augustsson 
cayenne language dependent types 
proceedings international conference functional programming icfp 
acm press september 
ac lennart augustsson magnus carlsson 
exercise dependent types typed interpreter 

bar henk barendregt 
lambda calculi types 
gabbay abramsky maibaum editors handbook logic computer science volume 
oup 

bar bruno barras 
auto validation un systeme de avec 
phd thesis universite paris vii 
november 
bh bellegarde james hook 
substitution formal methods case study monads transformations 
science computer programming 

bp richard bird ross paterson 
de bruijn notation nested datatype 
journal functional programming 
vol 
pp 

bove ana bove 
programming martin lof type theory 
unification non trivial example 
licentiate thesis 
chalmers university technology goteborg 
preparation 
bro jason brown 
presentations unification logical framework 

phil thesis 
college oxford 
bd rod burstall john darlington 
transformation system developing recursive programs 
jacm vol 
january pp 
bur rod burstall 
proving properties programs structural induction 
computer journal 
pp 

bms rod burstall dave macqueen don sannella 
hope experimental applicative language 
proceedings lisp conference 
stanford california 
bur rod burstall 
inductively defined functions functional programming languages 
journal computer system sciences 
vol 
nos 
april june pp 
cla clark 
negation failure 
logic databases editors gallaire minker pp 
plenum press 

coen martin coen 
interactive program derivation 
phd thesis 
university cambridge 

cg adriana goguen 
typed operational semantics higher order subtyping 
appear information computation 
coq projet coq 
coq proof assistant manual version 
rapport de recherche inria 

cpm thierry coquand christine paulin mohring 
inductively defined types 
martin lof mints editors proceedings 
springer verlag lncs 

coq thierry coquand 
pattern matching dependent types 
proceedings types proofs programs june 
cs thierry coquand jan smith 
status pattern matching type theory 
el pp 
june 
ct cristina cornes 
inverting inductive predicates coq 
types proofs programs international workshop types 
springer verlag lncs 
june 
cor cristina cornes 
conception un langage de niveau de representation de 
doctoral thesis universite paris vii 

cf curry feys 
combinatory logic 
amsterdam north holland 

dm luis damas robin milner 
principal type schemes functional programs 
proceedings th acm symposium principles programming languages pp 

deb de bruijn lambda calculus notation nameless dummies 
mathematicae pp 
deb de bruijn 
telescopic mappings typed lambda calculus 
information computation pp 

dm dubois morain 
certification type inference tool ml damas milner coq 
journal automated reasoning vol 
pp 
november 
dyb peter dybjer 
inductive sets families martin lof type theory 
logical frameworks edited huet plotkin 
cup 
gen gerhard 
untersuchungen uber das logische 
mathematische zeitschrift pp 

translation pp collected papers gerhard gentzen edited szabo north holland 
gim 
codifying guarded definitions recursive schemes 
proceedings types pp 
gim 
un calcul de constructions son application la verification de systemes 
doctoral thesis 
ens lyon 

gim 
structural recursive definitions type theory 
proceedings icalp 
springer verlag lncs 
july 
gog goguen 
typed operational semantics type theory 
phd thesis 
university edinburgh 
cst 
gs gardner shepherdson 
unfold fold transformations logic programs 
pp computational logic essays honor alan robinson edited jean louis lassez gordon plotkin mit press 
hal thomas 
alfa user guide 
www cs chalmers se alfa hp robert harper robert pollack 
type checking universe polymorphism typical ambiguity calculus constructions 
theoretical computer science 

von henke luther strecker 
interactive automated proof construction type theory 
bibel schmitt chapter interactive theorem proving 
hos martin hofmann thomas streicher 
groupoid model refutes uniqueness identity proofs 
proceedings ninth annual ieee symposium logic computer science 
pp 
paris france 
july 
ieee computer society press 
hof martin hofmann 
extensional concepts intensional type theory 
phd thesis 
university edinburgh 
cst 
hue gerard huet 
unification algorithm typed calculus 
theoretical computer science pp 

hue gerard huet 
zipper 
journal functional programming vol 
pp 

unification case study transposition formal properties 
supplementary proceedings th international conference theorem proving higher order logics poster session tphols 
gunter felty editors 
pp 

kst stefan donald sannella andrzej tarlecki 
definition extended ml 
lfcs technical report university edinburgh 

lp zhaohui luo robert pollack 
lego proof development system user manual 
lfcs technical report university edinburgh 

luo zhaohui luo 
computation reasoning type theory computer science 

oxford university press 
mac saunders maclane 
categories working mathematician 
springer verlag gtm 

mag lena magnusson 
implementation alf proof editor martin lof monomorphic type theory explicit 
phd thesis chalmers university technology goteborg 

man manes 
algebraic theories 
springer verlag gtm 

mw zohar manna richard waldinger 
deductive synthesis unification algorithm 
science computer programming 
northholland 

ms 
termination proofs recursively defined functions 
theoretical computer science pp 

martin lof 
intuitionistic theory types 
manuscript 
martin lof 
intuitionistic theory iterated inductive definitions 
proceedings second scandinavian logic symposium 
north holland 

martin lof 
theory types predicative part 
rose shepherdson editors logic colloquium 
northholland 

martin lof 
intuitionistic type theory 
bibliopolis 
mcb fred mcbride 
computer aided manipulation symbols 
phd thesis queen university belfast 
mcb conor mcbride chris mcbride 
polysemy lisp pattern matching class local definitions 
experimental implementation 

mcb conor mcbride 
inverting inductively defined relations lego 
types proofs programs international types 
springer verlag lncs 
pp 
mp mccarthy painter 
correctness compiler arithmetic expressions 
mathematical aspects computer science pp 
ams 
mcc john mccarthy 
basis mathematical theory computation 
computer programming anf formal systems hirschberg editors 
north holland publishing 

mil dale miller 
logic programming language lambda abstraction function variables simple unification 
journal logic computation pp 

mil dale miller 
unification mixed prefix 
journal symbolic computation pp 

mth robin milner mads tofte robert harper 
definition standard ml 
mit press 
mog moggi 
notions computation monads 
information computation 

mun cesar munoz 
dependent types explicit substitutions development 
types proofs programs international types 
springer verlag lncs 
pp 
nn wolfgang tobias nipkow 
type inference verified algorithm isabelle hol 
types proofs programs international types 
springer verlag lncs 
pp 
bengt nordstrom 
terminating general recursion 
bit vol 
pp 

christine paulin mohring 
inductive definitions system coq rules properties 
proceedings tlca 
christine paulin mohring 
definitions tn theorie des types ordre 
habilitation thesis 
universite claude bernard lyon 

pau verifying unification algorithm lcf 
science computer programming 
north holland 

pau lawrence paulson 
constructing recursion operators type theory 
journal symbolic computation pp 

pau lawrence paulson 
logic computation interactive proof cambridge lcf 
cambridge tracts theoretical computer science vol 

cup 

henrik persson 
development polynomial ring agda 
type theory integrated logic programs doctoral thesis 
chalmers university technology goteborg 

poll erik poll 
programming logic type theory 
doctoral thesis 
technische universiteit eindhoven 
pol robert pollack 
implicit syntax 
preliminary proceedings st workshop logical frameworks 
pol robert pollack 
incremental changes lego 
lfcs report 
university edinburgh 
pra dag prawitz 
natural deduction proof theoretical study 
almquist wiksell stockholm 

pym david pym 
proofs search computation general logic 
phd thesis 
university edinburgh 

pym david pym 
unification algorithm pi calculus 
international journal foundations computer science vol 
pp 

rob alan robinson 
machine oriented logic resolution principle 
acm 

rou joseph 
de algorithme unification dans le calcul des constructions types 
technical report inria lorraine 
november 
sh gerard huet 
constructive category theory 
proceedings joint types workshop categories type theory goteborg sweden 

ssb sato sakurai rod burstall 
explicit environments extended 

ferdinand de saussure 
cours de linguistique 

sp paula erik poll 
pure type systems definitions 
lfcs 
springer verlag lncs pp 

sli konrad slind 
function definition higher order logic 
theorem proving higher order logics 
th international conference tphols 
springer verlag lncs 
august 
str thomas streicher 
investigations intensional type theory 
thesis ludwig universitat 

tak takahashi 
parallel reductions calculus revised version 
information computation 
pp 

ts hisao tamaki sato 
transformation system logic programs preserves equivalence 
icot tr 

ter 
encoding natural semantics coq 
fourth international conference algebraic methodology software technology amast 
springer verlag lncs 
july ter 
vers un environnement de de en 
phd thesis ecole nationale des 
october 
tur david turner 
elementary strong functional programming 
proceedings international symposium functional programming languages education 
springer verlag lncs 

wad philip wadler 
views way pattern matching cohabit data abstraction 
th acm symposium principles programming languages munich january 
index property indicators type value guess binding operators universal quantification functional abstraction local definition hole component hole guess contexts hi empty context gamma context extension information order judgments gamma core judgment delta fl development judgment computation syntactic identity delta contraction delta step reduction step reduction conversion cumulativity positions ffi trivial position position composition context position put position information order substitution telescopes sequence telescope fam free telescope deltag iteration application type triangle telescope sugar datatypes empty type unit type boolean type sum type records field record tuple field projection open official names open local names sigma types sigmax fake sigma binding theta non dependent product hs ti pair sigma tuple type si tuple equalities see equality see equality concrete categories ae categorical arrow ffi arrow composition arrow equality identity arrow delta object arrow interpretation concrete monads monad arrow hj monad bind pi monad composition ji monad embed delta arrow interpretation delta 
delta knockout alist operations alist composition alist interpretation abandon abstraction rewriting ackermann function alist alist category aperture assume attack fi reduction bindings blue plastic hammer bmgu boolean type see bound call case analysis category see concrete category cell check church rosser claim clark completion closed closed constraint coalescence coalescence compatible closure core development components concrete concrete category family types concrete monad conflict constraints friendly unfriendly constructor form unification problem constructors contexts contraction schemes core development conversion covering elementary empty equations exact cumulativity cut cut property cycle ffi reduction discharge downward closed constraint eliminate elimination rule aperture case data case patterns cases datatype indices inductive hypotheses patterns recursive calls scheme target empty type see equality john major martin lof propositional construction construction equiv faithful functor fam family indexed type fibonacci function fields fin fixpoint guarded folding ford henry free pattern functor functor goes guarded guarded fixpoint guess halting problem hole binding life identity ind indaux indexed family induction principle strong weak inductive datatypes dependent families parameterised records simple higher order constructors inductively defined relations injectivity intro intro inversion reductions iterated sequence iterated telescope rule judgments core development justify rule kleisli category triple kleisli knockout lam lengthening elim clark completion clark style inversion inv weak induction principle reduction lexicographic recursion lift lift list major john majority mantra blocking computations contexts decomposition recursion means maximal mgu mgu monad monad general unifier nave refine nn nneq rules obviously empty optimism optimist ord partial constructions patterns peano postulates plus pos position information order positions postpone program property propositional equality pure raise raise records opening projection regret rename renaming replacement fails general partial constructions retreat return return scheme sequence iterated sigma types solve split spot state information order states strengthening strong induction principle strong normalisation strongly normalising subject reduction substitution sum type see syntactic identity syntax core development tactic abandon assume attack claim cut deletion discharges eliminate intro intro justify nave refine permutation postpone program raise raise regret retreat return solve split try unify unify refine target telescope application free iterated telescopic equation substitution uniqueness terms thick thin tree triangle try type family type type inference rules core development unfolding unification problem unifier unifies unify unify refine unit type see universes unload vect vlast vlast weak induction principle 
