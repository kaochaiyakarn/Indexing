planning interplanetary space theory practice ari jonsson paul morris nicola muscettola rajan nasa ames research center ms mo ett field ca jonsson mus ptolemy arc nasa gov ben smith jet propulsion laboratory pasadena ca smith aig jpl nasa gov may th nasa activated time ai planner scheduler running flight processor spacecraft 
part remote agent experiment rax demonstration planning execution model state inference failure recovery 
describes rax planner scheduler rax ps terms underlying planning framework terms fielded planner 
rax ps plans networks constraints built incrementally consulting model dynamics spacecraft 
rax ps planning procedure formally defined proved complete 
rax ps generates plans temporally flexible allowing execution system adjust actual plan execution conditions breaking plan 
practical aspect developing mission critical application required paying attention important engineering issues design methods programmable search control knowledge acquisition planner validation 
result system capable building concurrent plans tasks performance requirements operational mission critical software 
week may th remote agent autonomous closed loop software control spacecraft mission 
done part unique technology validation experiment remote agent took control nasa new millennium deep space spacecraft muscettola bernard 
experiment successfully demonstrated applicability closed loop planning execution model state inference failure recovery 
components autonomous control system board remote agent experiment copyright american association artificial intelligence www aaai org 
rights reserved 
authors alphabetical order 
planning experts search engine heuristics domain model plan database goals initial state plan planning engine knowledge base planner scheduler architecture planner scheduler rax ps drove high level commanding spacecraft 
involved generating plans safely executed board spacecraft achieve specified high level goals 
plans account board activities having di erent durations requiring resources giving rise subgoal activities satisfying complex flight safety rules activity interactions 
describe remote agent experiment planner scheduler theoretical practical perspectives 
architecture planning system shown 
domain model describes dynamics system planner applied case deep space spacecraft 
plan request consisting initial state set goals initializes plan database 
search engine modifies plan database generate complete valid plan sent execution agent 
heuristics planning experts part core framework integral part planning system flew board deep space 
heuristics provide guidance search engine planning experts provide uniform interface external systems attitude control systems inputs planner take account 
theory rax ps system defined framework planning scheduling ways di ers significantly classical strips planning 
instance actions occur concurrently different durations 
goals include time maintenance conditions 
section describe ps framework theoretical perspective 
start describing parallel activities defined framework domain rules specified candidate plans 
go describe semantics candidate plans point view plan execution derive realistic definition valid plan 
planning process framework prove complete 
tokens timelines state variables reason concurrency temporal extent action instances states described terms temporal intervals linked constraints 
approach called constraint interval planning smith frank jonsson various planners including tate ixtet ghallab 
approach builds constraint interval planning significant di erences 
timelines model reason concurrent activities elimination distinction actions fluents greater expressiveness domain constraints humans find natural view world terms interacting objects attributes 
planning concerned attributes states change time 
attributes called state variables 
history states state variable period time called timeline 
shows engine attitude state variables portions associated timelines spacecraft application attitude spacecraft orientation space 
periods idleness engine thrusting direction period achieve correct thrust vector spacecraft attitude maintained points direction turn actions change attitude spacecraft 
classical planning fikes nilsson mcallester earlier interval planning dichotomy fluents actions 
specify states specify transitions 
terms interval planning resulted intervals describing actions fluent values implicit 
distinction clear useful 
example idle idle thrust engine turn point turn timelines time attitude plans parallel timelines 
spacecraft domain thrusting direction regarded state implies pointing action pointing precondition 
execution persistence fluent values temporal intervals may actively enforced maintaining verifying value 
reasons distinction fluents actions planning approach construct describe fluents actions 
point view execution state variable represents single thread execution concurrent system 
time thread executing single procedure procedure np parameters np specified type 
state variable typed mapping set state variables set possible procedures 
state variable specifies procedures possibly executed 
timeline consists sequence intervals involves single procedure 
may think interval procedure structural unit called token placed timeline 
token resides definite timeline final plan appropriate timeline token may undetermined planning 
refer token timeline floating token 
token describes procedure invocation state variables occur parameter values procedure time values defining interval 
allow specification multiple values express range possible start times variables specify parameter start time values token 
result token tuple variable denoting state variable name procedure satisfying elements variables denote parameters procedure restricted types numeric variables indicating start times respectively satisfying 
token variables including parameter variables domain values assigned 
variables may participate constraints specify value combinations valid 
example consider token representing camera picture parameter indicates brightness level target object parameter spec choice camera filter 
duration picture token depends brightness level filter choice constraint links start times parameters 
general notion token certain specialized purposes 
general form called constraint token associated single procedure corresponds sequence invocations invocation drawn specified set procedures 
actual invocation sequence determined execution 
constraint tokens allowed overlap long overlap permits valid procedure invocation 
generalization timelines represent resource usage 
constraint token represents resource demand 
combinations overlapping demands exceed available resource 
intersected region overlapping demand determines procedure assigns resource checks availability exceeded 
approach model keep track power usage remote agent experiment 
unfortunately limited space prevents covering generalization detail article 
domain constraints complex system procedures invoked arbitrarily 
procedure call procedure completed need executed parallel procedure di erent thread 
example procedure turn occur procedure maintained attitude precede procedure maintains attitude similarly thrusting procedure executed procedure maintains correct spacecraft attitude 
specify constraints ground token configuration constraint call compatibility 
determines necessary correlation procedure invocations legal plan procedures precede follow temporal procedure invocation may supported di erent configurations compatibility disjunction constraints 
define terms pairwise constraints tokens organized disjunctive normal form compatibilities specify procedure invocations permitted disjunction empty procedure invocation valid configuration 
conjunction subgoals form 
token constraint values variables tokens involved 
general may take form appropriately specifies relation tokens 
practice structured limit expressiveness planning constraint propagation computationally cient 
rax ps framework limited conjunctions equality codesignation constraints parameter variables di erent tokens 
simple temporal constraints start variables 
specified terms metric versions allen temporal algebra relations allen meets met relation gives rise bound distance temporal variables 
bound expressed function start variables subgoal constraints guarantee state variable executing procedure instantaneously switching procedure invocations 
means contains predecessor requirement state variable met similarly specify successor 
concept subgoals generalizes notion preconditions ects classical planning 
example add ects enforced meets subgoals deleted preconditions correspond met subgoals 
preconditions ected action represented contained subgoals 
principle di erent compatibility may apply ground procedure invocation 
practice large number invocations share constraints 
example process executing attitude turn irrespective turn starts ends 
determining set applicable compatibilities done ciently planning process 
rax ps reason flexible tokens variables assigned single values accomplished indexing compatibilities hierarchically 
mechanism illustrated 
basic idea associate compatibilities sets described cartesian product token variable domain subsets 
allows planner map tokens relevant compatibilities pairwise comparing domains 
procedure invocations fall specified sets permitted 
example set constraints associated minor attitude turns set associated large scale attitude changes require 
procedure invocations small adjustments excluded 
round boxes marked represent compatibility associations 
compatibility applied token falls set see comes consider straight boxes marked represent tokens 
easy see determine restricted compatibility appli illustration hierarchical indexing mechanism rax ps compatibilities 
cable 
token general determine single compatibility 
cartesian products coarsegrained specify valid procedure invocations 
example sets possible origin destination attitudes relate sets possible start times 
additional constraint local constraint associated set specified terms procedural constraints jonsson ective way specify enforce arbitrary constraints 
partially instantiated token intersects single compatibility box instance corresponding local constraint lp automatically posted database compatibility associated box available planner start satisfying appropriate sets subgoals 
plan database having laid representation planning domain turn attention planner represents reasons 
rax ps data structure called plan database 
basic level plan database represents current candidate plan essentially set timelines containing interrelated tokens current set decisions need 
formal terms candidate plan consists horizon pair temporal values satisfying timeline 
state variable tokens ordering constraints 
ok enforcing constraint limit token variable domains set timeline set constraints 
cn relating sets variables tokens includes temporal equality local procedural constraints constraints candidate plan give rise constraint network consisting variables tokens constraints link token variables di erent ways 
network determines set legal instantiations tokens 
result candidate plan inconsistent underlying constraint network part valid plan 
important aspect underlying constraint network may infer restrictions possible values token variables 
done constraint propagation mackworth freuder method eliminating values proven appear solution constraint network 
side ect removing values constraint propagation may prove solution exists eliminating values variable 
doing implies candidate plan invalid addition candidate plan plan database may contain set decisions need 
decision corresponds flaw candidate plan aspect candidate may prevent complete valid plan 
framework types flaws uninstantiated variables floating tokens open disjunctions compatibilities unsatisfied compatibility subgoals 
flaw plan database gives rise choices flaw resolved 
resolving flaw reasoning step maps database database 
categorized types flaws list possible choices resolving flaw ect plan database 
variable restriction flaws resolved selecting non empty subset variable domain restrict variable domain 
ects restriction results token matching unique compatibility specification new open disjunction flaw added 
chosen domain singleton flaw removed 

floating token flaws resolved selecting adjacent tokens timeline inserting floating token 
ects floating token flaw removed 
ordering constraints implied insertion added 

open disjunction flaws resolved selecting converse necessarily true failing find empty domain guarantee existence solution 
item disjunction require true 
ects open disjunction flaw removed 
set unsatisfied subgoal flaws added 
implied constraints added constraint set 

unsatisfied subgoal flaws resolved finding existing token satisfy subgoal adding new token satisfy subgoal 
ects unsatisfied subgoal flaw removed 
resulting constraints added 
implied ordering constraints added new token generated 
important note necessary resolve flaws order plan 
example valid plan permit certain flexibility token start times turn means variable domains singletons 
cases require token satisfy applicable compatibility specification subgoals disjunctions satisfied 
case say token fully supported 
plans system behaviors notions introduced turn attention semantics candidate plan task developing formal definition valid plan traditionally valid plans defined terms candidate plan domain model 
approach realistic validity plan real world inherently tied mechanism executes 
address start discussing basics plan execution go derive realistic definition constitutes valid plan 
point executing agent called executive exec plan concurrent program interpreted executed dynamic system 
recall plan contains variables specify circumstances procedures instantiated 
variables correspond system values current time exec sense actual system values compare values specified plan determine procedure executed 
exec fails match sensed values values plan exec triggers fault protection response put system safe state start recovery actions 
question exec succeeds matching values selecting procedure invocation depends part reasoning exec perform purpose 
turn depends reasoning exec capable time invocation activated 
exec reasoning capabilities permitted time deliberation execution process simple possible 
purpose plan simplest possible interpret procedure calls fully specified invocation variables completely determined 
course brittle plan provides possible match sensed values 
simplest plans correspond exactly single possible evolutions system 
refer potential behaviors system 
formally definition candidate plan potential behavior system token timeline fully supported timelines fully cover scheduling horizon timeline token variables bound single value 
consider candidate plan 
general may number gaps timeline tokens tokens may fully supported variables may uninstantiated 
order instantiate single behavior flaw resolved successfully 
execution agent su cient time reasoning capabilities specified plan viable plan 
fact lack commitment allow execution agent choose flaw resolutions best fit actual conditions execution 
remote agent system took advantage letting exec map high level tasks low level procedures execution 
freed planner generating low level procedure calls allowed executive choose low level procedures best fit actual execution 
general executability depends execution agent question 
depends primarily aspects flexible candidate plan cover possible system variations restricted candidate plan executive identify executable 
important issue consider making determination expensive solving planning problem 
represent abilities particular executive agent plan identification function identifies executable candidate plans mapping possible candidate plan values 
intent candidate recognized executable candidate recognized executable executability determined 
permit great deal variation di erent executives respond di erent candidate plans require plan identification function behaves consistently respect aspects mentioned 
example function reject practice plan finite horizon 
requirement modified slightly start token timeline 
particular predecessor subgoals ignored applies successor subgoals candidate basis restrictive accept restriction candidate 
leads formalization constitutes plan identification function definition plan identification function execution agent function maps set candidate plans extended truth value set candidate plan candidate plan extends candidate token supported 
condition strictly necessary executives capable solving planning problems interest clarity limit execution agents solving constraint satisfaction problems 
notion plan identification functions provide realistic formal definition constitutes plan definition executive represented plan identification function candidate plan plan planning process turn attention plan generation process 
input planning process initial candidate plan includes initialization token timeline set floating tokens set constraints tokens question 
elements give rise initial plan database 
goal planning process extend initial candidate complete valid plan 
point view traditional planning initial plan database specifies initial state goals 
fact approach permits expressive specification goals 
example request spacecraft take specified sequences pictures parallel providing certain level thrust 
planning process define framework instantiated di erent methods controlling search selecting flaws propagating constraints planning process recursive function non deterministically selects resolution flaw current plan database 
outline process shown 
planning process clearly sound resulting plan satisfies plan identification function 
planning process complete sense plan plan 
furthermore initial candidate plan extended valid plan satisfying planning process find valid plan satisfying extended stronger completeness criterion plan hold general 
reason lenient identification function may return planning process addressed remaining flaws 
plan return return fail flaw flaw database choose resolution res flaw apply res return plan planning process 
plan database consists candidate plan set flaws highlights importance identifying properties soundness completeness new planning frameworks 
theorem suppose domain model plan identification function initial plan 
valid plan extends planning process generate valid plan extends extended proof basic idea proof define oracle specifies resolve flaw planning process may encounter order get suitable plan straightforward target plan set possible flaws defined tokens appear target plan flaws need considered 
flaw oracle specifies resolved variable domain restriction assign variable domain token insertion insert free token satisfies ordering tokens timeline compatibility choice choose disjunction satisfied subgoal satisfaction choice token satisfies subgoal appears candidate plan add new token 
show oracle result suitable plan need show flaws needed arrive final plan eventually appear step provides candidate extended final plan function return intermediate candidate plans 
steps straightforward 
show induction criterion maintained process 
clearly true step planning process preserves chosen flaw resolution compatible criterion follows fact plan identification function returns candidate plan return candidate plans extend includes final plan 
prove step necessary flaws arise note su cient show tokens generated planning process 
automatically give rise variable domain flaws compatibility satisfaction flaws 
see token generated recall initial candidate plan initialization token timeline 
note compatibility specifies possible successors predecessors corresponding token 
consequence token timeline gives rise compatibility flaw produces succeeding token timeline 
straightforward induction proves allows planning process generate tokens practice rax ps extends theoretical framework system 
system operate stringent performance resource requirements 
example deep space flight processor mhz radiation hardened rad powerpc processor mb memory available lisp image full remote agent 
performance order magnitude worse current desktop computing technology 
peak cpu available rax rest real time flight software 
sections describe engineering aspects rax ps system 
describe planning engine workhorse development founded 
describe mechanism search control fine tune planner 
give information development process methods interaction external software planning experts 
rax ps planning engine follows previously discussed theory producing planner requires choosing specific plan identification function specific way implement nondeterminism flaw resolution strategy 
rax ps designed planner steps 
defined basic planning engine general search procedure theoretically complete 
designed method program search engine restrict amount search needed find solution 
section talk planning engine 
thing need clarify constitutes desirable plan flight experiment 
rax plans flexible temporal dimension 
precisely temporally flexible plan variables bound single value temporal variables token start times 
easy see assumptions un instantiated constraint sub network plan simple temporal network dechter meiri pearl 
means planner arc consistency determine model size state variables procedure types plan size tokens variables constraints performance search nodes search ciency table plan size performance rax ps plan contains behavior executive adjust flexible plan actual execution conditions fast incremental propagation muscettola morris 
translated plan identification function defined follows applied candidate plan checks arc consistency 
candidate inconsistent returns candidate arc consistent returns values candidate fully supported non temporal variables grounded case 
keep balance guaranteeing completeness keeping implementation simple possible non determinism implemented chronological backtracking 
planner returned plan 
planning engine provided default flaw selection strategy choice points backtrack search 
guaranteed underconstrained temporal variable flaw selected flaw selection resolutions randomly 
search control basic planning engine generate plans needed flight experiment 
rax ps included additional search control mechanisms allowed localized backtracking 
reflected performance figures table search ciency measured ratio minimum number search nodes needed total number explored 
achieving kind performance easy required significant engineering ort 
outline principal aspects ort rest section 
flaw agenda management rax ps programmable search controller default flaw selection strategy described 
ideally optimal search controller oracle described proof completeness 
having advance knowledge plan oracle select correct solution choice backtracking 
practice possible control strategy flaw resolution decisions basis partial plan developed far 
search controller rax ps allows programming approximate oracle list search control rules 
list provides subgoal master match camera ready slave match camera turning method priority method add sort asap method connect method defer priority search control rules unsatisfied subgoal prioritization flaws database sorting strategies non deterministic choices flaw selection 
gives example search control rule 
rule applies unsatisfied subgoal flaw camera ready token requires camera turning token 
note ds model camera reach ready state immediately procedure turning executed 
case matching token types subgoal su cient uniquely identify 
priority value associated flaw minimum plan database planner attempt resolve flaw trying resolution methods order 
case planner try add new token try insert earliest possible timeline gap standard sort method asap 
resolution method try defer subgoal 
happens plan database automatically force start token occur outside horizon case method succeed ready token token timeline 
search control engineering rule language search controller designed extremely flexible 
permits new sorting methods standard methods prove ine ective 
possible prune solution methods connect satisfy subgoal resolution alternatives try scheduling token early possible fail 
unfortunately meant completeness longer guaranteed 
hand allowed finely tuned planner 
designing search control exercise trading scripting planner behavior exploring benefits shallow backtracking necessary 
issues needed addressed 
interaction model heuristics ideally desirable keep domain model search control methods completely separate 
constraints describe physics domain describe possible search control help narrowing desirable possible 
declarative domain models usually specified domain experts spacecraft systems engineers problem solving experts mission operators 
struc sep thrust accumulated accumulated accumulated thrust thrust thrust sep thrust max thrust time sep thrust plan fragment implementing thrust accumulation plan horizon tural domain information problem solving methods significantly complicate inspection verification di erent modules planning system 
experience ideal separation di cult achieve 
model specifications logically correct turned ine cient required discovery simple properties extensive search token sequence tokens procedure 
standard method rax ps define auxiliary token variables search control enforce specific value turn prune undesired alternatives constraint propagation 
including control information model caused significant level fragility domain modeling especially initial stages project weak grasp control search 
global control information rax ps search control requires rules rely solely local information 
example variable restriction rule rely information token variable belongs 
global information needed control decisions 
example ds planner needs schedule correct amount accumulated thrust planning horizon 
requires keeping track sum duration thrust token candidate plan 
new thrust tokens generated sum exceeds limit 
solution adopted appropriately program domain model constraint propagation mechanisms compute global information 
particular included extra thrust accumulation timeline tokens effectively act global timer 
tokens timeline captured possible start time ranges thrust token variable subgoals 
local constraints performed summation predecessor successor subgoals propagated sum thrust accumulation subgoal tokens 
high level control languages control rules described thought assembly language search control ds experience confirmed programming low level language painful error prone 
assembly language provides strong foundation build higher level control languages founded better capture control knowledge mission operators 
declarative semantics subsystem state variables value types constraints comments micas executable health models health mode activity micas imaging camera 
rax demonstrates fault injection recovery device part day scenario 
navigation goal executable internal schedule orbit determination od picture activity 
propulsion thrust goal executable internal thrust schedule generated nav module planner generates plans precisely activate ips specific intervals constraints domain model complex set timelines subsystem controlled planner 
attitude executable health enables planner schedule constant pointing attitudes spacecraft maintains panels sun 
targets constant pointing attitudes imaging targets earth communication thrust direction ips thrusting 
power mgmt 
goal internal allows planner ensure adequate power available scheduling numerous activities simultaneously 
executive goal executable allows modeling low level sequences bypassing planner models giving mission ops ability run sequencing mode ra 
planner executable schedule executive request plan horizon 
mission goal allows mission manager planner coordinate activities series scheduling horizons updatable mission ops entire mission 
timelines rax domain model domain model opens possibility automatically understanding dependencies point effective search control 
synthesized strategies compiled low level control rules 
currently progress explore viability methods alleviate burden control search programming 
scenario driven development testing scenario driven iterative refinement process develop domain model 
domain models fixed scenario 
scenario involve certain amount thrust activity communication windows picture activity 
scenario changed fragility model immediately apparent planner converging resource bounds 
testing critical component deployment 
scenarios drove planner testing 
developed scenarios cover possible modifications baseline exercise fault conditions 
scenarios run automatically test harness 
automated verification tools reported cases planner failed converge planner generated incorrect plan 
testing process described fully smith 
interaction plan experts quite legacy specialized software external planner provides specialized knowledge development plan fragments 
call software planning experts 
rax ps framework provides practical solution direct integration knowledge planning process 
experts wrapped appropriate adaptors products coming directly declarative model 
illustrative describe detail interaction rax ps optical navigation system 
revolutionary technologies validated ds 
nominal mission rax active periodically commanded pictures beacon triangulate position spacecraft estimate spacecraft course 
rax active simply provide source planning goals beacon imaged 
rax ps plan detailed activities needed 
communication goals worked follows 
invoked planner extend plan know time wanted perform imaging activities 
point search control rule explicitly invoke result set floating tokens relative temporal constraints deposited plan database 
principle planner reject 
constraints posted design search control rules ensured normal circumstances planner schedule goals linearly time higher priority goals scheduled start rejecting goals ran time allotted temporal window 
developing principled interaction planning systems legacy control software topic active research important practical acceptability planning technology 
planner flight remote agent experiment conducted week may th 
experiment achieved technology validation objectives 
surprises 
notable occurred early morning may th rax team realized remote agent ceased command spacecraft healthy 
hours problem diagnosed analyzing telemetry data spacecraft inspecting source code 
problem turned low probability deadlock condition due missing critical section exec code 
hours rax team developed potential software patch developed completely new experimental scenario complete achievement remote agent validation objectives validated scenario running flight analog hardware 
new scenario activated morning may st 
spite problem communication software external remote agent experiment completed pdt achieving validation objectives 
rax ps performed 
importantly planner experiment simply resumed interruption tight time constraints 
developing testing approving new sequence complex activities spacecraft usually requires days 
planner new mission scenario developed hour 
worth noting overnight testing validation involved running full hours new scenario flight processor real time 
potentially catastrophic software fault turned unexpected showcase planning technology reduce costs robotic space missions 
details actual flight run seen bernard nayak 
overview remote agent experiment planning scheduling system theoretical practical points view 
theoretical side described underlying planning framework ways di erent traditional planning approaches 
advantages framework provides ability plan concurrent activities di erent durations expressiveness needed plan complex interacting goals including maintenance goals 
practical side discussed problems solved implementation testing planner flight software solutions problems 
research development autonomous planning systems capable solving real problems continues scientists field 
just step development step taken autonomous planning interplanetary space 
acknowledgments authors acknowledge support complete remote agent team nasa ames jpl 
particularly steve chien scott davies greg david yan contributed rax ps flight experience 
jeremy frank david smith anonymous reviewers comments 
allen 
general theory action time 
artificial intelligence 
bernard gamble kanefsky kurien man millar muscettola nayak rajan smith taylor tung 

spacecraft autonomy flight experience ds remote agent experiment 
proceedings aiaa conference albuquerque new mexico 
bernard fry jr kanefsky kurien millar muscettola nayak pell rajan smith williams 
design remote agent experiment spacecraft autonomy 
proceedings ieee aerospace conference 
dechter meiri pearl 
temporal constraint networks 
artificial intelligence 
fikes nilsson 
strips new approach application theorem proving problem solving 
artificial intelligence 
ghallab 
representation control ixtet temporal planner 
proceedings second international conference artificial intelligence planning systems 
jonsson morris muscettola rajan 
generation remote agent planner 
proceedings fifth international symposium artificial intelligence robotics automation space 
mackworth freuder 
complexity polynomial network consistency algorithms constraint satisfaction problems 
artificial intelligence 
mcallester 
systematic nonlinear planning 
proceedings ninth national conference artificial intelligence 
muscettola nayak pell william 
remote agent boldly go ai system gone 
artificial intelligence 
muscettola 
hsts integrated planning scheduling 
zweben fox eds intelligent scheduling 
morgan kaufman 

nayak bernard jr kanefsky kurien millar muscettola rajan smith taylor wen tung 
validating ds remote agent experiment 
proceedings fifth international symposium artificial intelligence robotics automation space netherlands 

personal communication marc chief mission manager ds 
smith millar wen tung nayak jr clark 
validation verification remote agent spacecraft autonomy 
proceedings ieee aerospace conference smith frank jonsson 
bridging gap planning scheduling 
knowledge engineering review 
tate 
representing plans set constraints ova model 
proceedings third international conference artificial intelligence planning systems 
muscettola morris 
fast transformation temporal plans cient execution 
proceedings th national conference artificial intelligence aaai th conference innovative applications artificial intelligence iaai 
menlo park aaai press 
