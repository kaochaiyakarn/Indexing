high performance erlang system erik johansson computing science department uppsala university sweden csd uu se mikael pettersson computing science department uppsala university sweden csd uu se sagonas computing science department uppsala university sweden csd uu se erlang concurrent functional programming language designed ease development large scale distributed soft real time control applications 
far quite successful application domain despite fact currently available implementations emulators virtual machines 
improve performance aspects erlang implementations presenting hipe open source native code compiler erlang 
hipe complete implementation erlang offers flexible integration emulated native code efficiently supports features crucial erlang application domain concurrency 
performance evaluations show hipe currently fastest erlang implementations 

concurrent functional programming language erlang designed ericsson address needs largescale distributed soft real time control applications 
applications routinely arise products developed telecommunications industry 
erlang caters needs run time system provides features associated operating system programming language 
features include scheduling lightweight concurrent processes automatic memory management networking protection deadlocks programmer errors support continuous operation performing software upgrades 
decade existence erlang generally considered success story declarative programming languages see 
users experience erlang allows telecommunication systems programmed effort fewer errors conventional programming language technology :10.1.1.126.9642
worthwhile note systems typically consist lines source code size partly due complexity telecommunication protocols rely heavily concurrency capabilities erlang 
industry ericsson showing growing interest erlang limited choice compilers partly due erlang exclusive house development 
implementor compilers publicly admits performance major problem considering adding imperative features language solve performance problems 
performance current implementations erlang inferior implementations functional programming languages see 
competitive market telecommunications need high performance implementation pressing 
example consider axd new generation atm switching system ericsson 
major part axd software written erlang consists lines erlang code constituting time critical modules system 
speeding time critical part welcome axd engineering team ericsson speedup directly corresponds atm switch capable servicing requests see 
currently complete implementations erlang emulators virtual machines 
gives portability emulation incurs performance penalty erlang programs users wish cases need avoid 
ways avoid performance problems caused emulation compile sufficiently low level fast language proposed portable assembly language retargetable code generator ml risc gcc back compile directly native code 
implementation choices known pros cons roughly expect decrease portability increase performance implementation effort higher choice number see 
issue deserves attention byte code emulators usually result smaller object code size native code compilers 
object code size concern nowadays potential problem source code application consists lines 
paying attention code size result poor cache behaviour leading significant performance degradation 
ideally system provide seamless integration emulated native code execution allow user choose execution mode individually application component various space time trade offs involved 
information trade offs system provides user 
presents approach efficient execution erlang 
developed system hipe combines performance characteristics native code compiler benefits emulated implementation 
hipe currently uses jam emulator basis allows selective compilation modules individual functions native code executed directly underlying hardware 
fully describing architecture hipe changes jam run time system needed support native code execution discuss various technical issues emulated native code integration entails context erlang dealt 
specifically ffl pay special attention supporting hot code loading see section error handling hipe ffl describe method performing tail call optimization mixed mode execution separate stack mode method probably folklore best knowledge reported literature ffl compare analyse performance existing erlang implementations standard small benchmarks large programs actual industrial erlang applications show hipe performance superior 
self contained reviewing characteristics erlang section 
sections form main part describe basic characteristics hipe architecture integration native emulated execution run time system 
section contains performance comparison hipe implementations erlang industrial academic functional languages 
section contains additional measurements benchmark programs performance evaluation give insight hipe performance 
concluding remarks 

brief erlang dynamically typed strict concurrent functional programming language 
possible create closures erlang typical erlang programs order 
erlang basic data types atoms numbers integers arbitrary precision floats process identifiers compound data types lists tuples 
destructive assignment variables occurrence variable binding instance 
function selection happens pattern matching 
erlang design inherits ideas concurrent constraint logic programming languages flat guards function clauses 
processes erlang extremely light weight number typical applications quite big memory requirements vary dynamically 
erlang concurrency primitives spawn 
send receive allow process spawn new processes communicate processes asynchronous message passing 
data value sent message processes may located machine 
process mailbox essentially message queue message sent process arrive 
message selection mailbox occurs pattern matching 
shared memory processes distribution invisible erlang 
support robust systems process register receive message terminates 
erlang applications typically consist number modules erlang module defines number functions 
explicitly exported functions may called modules 
calling functions different modules called remote calls done supplying name module called function 
execution functions tail call optimization performed 
functional languages erlang memory management automatic garbage collection 
real time concerns language call bounded time garbage collection techniques see 
practice garbage collection times usually small processes short lived small size 
perform system upgrading allowing continuous operation erlang system needs cater ability change code module system running called hot code loading 
processes execute old code continue run expected eventually switch new version module issuing remote call invoke version module 
erlang provides mechanisms allowing process timeout waiting messages catch throw style exception mechanism error handling 
erlang language purposely designed small comes libraries containing large set built functions known 
open telecom platform otp middleware erlang extended standard solutions common requirements telecommunication applications servers state machines process monitors load balancing standard interfaces corba standard communication protocols ftp 

jam basis hipe hipe bytecode emulated jam implementation erlang adds ability compile execute erlang native machine code 
hipe new component currently lines erlang code lines assembly code added unchanged jam system jam emulator garbage collector extended aware native code 
tight integration describe relevant aspects basic jam system section continues hipe specifics 
hipe publicly available open source 
current release ericsson open source erlang 
see www csd uu se projects hipe 
jam system jam erlang implementation uses jam virtual stack machine primitive operations closely correspond erlang language 
example erlang dynamically typed language jam uses self describing data representation tagged values emulator instructions operate tagged values raw machine values 
jam compiler jam compiler non optimising compiler performs straightforward translation jam virtual stack machine 
object files contain bytecodes relocation entries describe symbolic resolved loader 
jam loader jam loader translates jam bytecodes external format internal format expected jam emulator 
erlang atoms symbolic constants atoms prolog symbols lisp 
internal representation atom position atom table known runtime 
task loader replace symbolic atoms current internal representation 
remote non local function call represented triple module name function name function arity 
names translated internal atoms 
special cases identified calls erlang module calls functions runtime system 
jam instruction call site patched reflect result 
module loaded global symbol table updated information module exported functions code addresses functions start 
jam emulator jam emulator single function executes jam instructions represented bytecodes 
jam implementation indirectly threaded 
emulator invoked runnable erlang process executes code process blocks 
process blocks attempts read message message queue empty time slice expired 
time slices represented budgets explicitly decremented checked specific points emulator 
erlang process described process control block pcb stack heap set pointer registers sp word stack fp start current function activation record ap actual parameter pc current bytecode instruction cc debug information current function stack discipline simple 
call parameters pushed left right order followed word continuation record containing caller fp ap pc cc 
fp set point start record sp word record ap parameter derived fp callee arity see 
note ap value caller sp call 
return sp reset ap cc pc ap fp restored frame return value pushed stack 
delta delta delta ap parameter delta delta delta parameter fp caller fp caller ap caller pc caller cc sp delta delta delta stack grows jam stack entry function jam tail calls complicated fact continuation frame pushed parameters 
continuation frame adjacent parameter area relocated tail call caller callee different number parameters 
tail call jam emulator copies frame temporary variables copies outgoing parameters bottom stack parameter area necessary moves copy back stack 
exception handling implemented dynamic tracking 
entry protected code block word catch frame pushed stack containing pointer previous catch frame address instruction protected block 
address frame saved pcb 
raise exception stack unwound call frame time activation record containing current catch frame 
unwinding process simultaneously restores sp fp ap cc registers 
processes memory management erlang node instance erlang runtime system executing machine 
unix single unix process 
node erlang processes created dynamically execute coroutines 
procedure acts scheduler continuously selecting runnable process passing emulator execution 
erlang process pcb stack private heap data structures creates 
erlang process starts small stack heap areas grown needed 
compared typical implementation posix threads unix allocate order megabyte virtual memory thread stack erlang performance improved shrinking frame minimum ap redundant cc computed pc needed 
continuation pushed parameters remain place tail calls section 
processes extremely lightweight 
erlang node expected handle hundreds thousands erlang processes relative ease 
garbage collector standard generational copy type 
interesting design feature process heap strictly private process allowed process heap 
advantage arrangement simplifies memory management 
processes occur garbage collection strictly local activity process terminates memory reclaimed immediately 
believed reduce total memory management costs majority erlang processes expected short lived small amounts live data 
disadvantage message passing implemented data copying reduces sharing increases pressure memory caches 
messages expected small 

hipe system overview hipe compiler called ordinary erlang function running erlang system 
smallest unit compilation function name existing erlang function compiler translates function jam bytecodes sparc machine code linking phase updates system state calls invoke native code see section 
respect hipe resembles user invoked jit compiler 
alternatively hipe compiler compile erlang module result compilation saved file symbolic sparc code 
file loaded explicitly hipe system 
erlang applications delivered bytecode format sources available 
example erlang open source erlang libraries jam bytecode files 
hipe designed able take loaded functions jam bytecode format erlang source code input 
means hipe perform high level optimizations compilation scheme offers freedom users users possibility identify hipe profiling tools functions call paths benefit compilation native code selectively compile 
way hipe combines performance native code system code compactness bytecode system 
integration tight code compiled hipe uses runtime system built functions jam emulator 
hipe compiler compiler intermediate representations internal representation jam bytecode high level intermediate language icode general register transfer language rtl machine specific assembly language currently sparc see 
icode rtl sparc represented control flow graphs basic blocks 
planning measure memory subsystem performance implementing shared heap runtime system comparing current runtime system 
jam emulator memory icode rtl sparc native code erlang run time system hipe compiler byte code jam data jam code symbolic intermediate representations hipe 
jam bytecodes translated symbolic form straightforward process 
internal atom numbers converted real atoms branches local functions translated call instructions symbolic function names 
icode register oriented virtual machine erlang 
arguments temporaries located infinite number registers values proper erlang terms 
call stack implicit calls preserve registers 
bookkeeping operations heap overflow checks context switching time slice decrements implicit 
translation jam bytecode icode uses simulated stack map jam stack slots icode registers 
simplify dependency analysis compilation passes renaming post pass ensures independent live ranges different registers 
icode optimised standard compiler optimizations copy constant propagation constant folding 
done pass extended basic blocks 
dead code removal performed remove assignments dead temporaries 
unreachable code removed translation rtl reachable basic blocks inserted rtl control flow graph 
operations erlang values expanded data tagging explicit 
optimisations performed icode applied rtl code 
heap overflow tests call stack management saving restoring registers calls explicit standard optimisations applied 
order limit number heap overflow tests propagated backwards far possible adjacent tests merged 
rtl code translated sparc code registers assigned graph colouring register allocator similar briggs 
symbolic atoms functions replaced values running system memory allocated code code linked system 
hipe linker described erlang requires ability upgrade code runtime affecting processes currently executing old version code 
jam system maintains global table loaded modules 
module descriptor contains name list exported functions locations current previous code segments 
exported functions refer current code segment 
remote function call module function parameters jam emulator performs lookup module function name 
function emulator starts executing bytecodes 
error handler invoked 
native code function call direct machine level call absolute address 
caller code linked linker initialises call directly invoke callee 
callee loaded linker direct call stub performs appropriate error handling 
callee exists emulated bytecode linker directs call stub turn invoke jam emulator 
order handle hot code loading dynamic compilation runtime linker maintains information call sites native code 
information dynamic code patching follows ffl module updated new version emulated code remote function calls native code module located 
call sites patched call new emulated code new native emulated code stubs 
ffl emulated function compiled native code native code call site refers function patched call new native code 
instruction bytecode replaced new instruction cause native code version invoked 
native emulated stub invoke native code deallocated 
ffl module unloaded memory freed native code call sites referring module patched invoke error handling stub 
native code call sites non existent module removed linker data structures prevent attempts update 
standard erlang system hipe support demand modules 
invoked error handler undefined function calls attempt load jam bytecodes module file system 
successful call continues normal 
side effect loading jam module hipe linker patch native code call sites described 
native code calling conventions hipe runtime system erlang process execute emulated jam code native sparc code 
facilitate data sharing hipe uses data representation jam 
jam calling convention inappropriate native code jam passes parameters stack uses large call frames containing redundant information 
native code passes return address parameters registers remaining parameters native stack shrinks fixed portion stack frames single word preserving previous return address 
currently hipe sparc register windows registers saved restored needed function calls 
hipe uses stacks process emulated code native code 
earlier version hipe stack scheme quickly abandoned quite complex difficult implement correctly 
current dual stack approach disadvantages advantages gamma described section jam emulator implements exception handling creating linked list catch frames stack 
native code uses strategy means stack may contain pointers 
runtime system relocates stack increase size stack traversed catch frame links updated 
separating stacks stack scanning code garbage collector kept simple 
single stack approach scanning code know switch mode order correctly deal different stack frame layouts 
certainly doable require effort implement correctly 
foreign function interface erlang programs call functions standard procedures runtime system written modules 
bif machine code stub directly callable native code 
stub takes care saving native code state registers invoking function stack 
stub checks exceptions return returns caller invokes current erlang exception handler 
erlang runtime system designed permit arbitrary recursive calls erlang functions 
erlang code emulated native difference 
detailed explanation scope limitation stems mainly erlang process scheduler function way runtime system periodically polls channels 
overly difficult modify runtime system eliminate limitation 
mode switching hipe mode switch occurs transfer control native code emulated code viceversa 
design decision mere presence multiple execution modes impose runtime overheads long mode switches occur 
design requirement calls great care implementing performance correctness 
switches occur 
hipe compiles individual functions native code mode switch occur flow control function functions different modes 
mode switches occur call return sites 
erlang exception mechanism introduces mode switches viz 
exception thrown code executing mode catch handler different mode 
refer cases call return throw events respectively 
switches occur 
system discover particular instance call return throw event perform mode switch 
call events older lisp systems dynamic test calls determine mode callee compiled emulated perform appropriate action 
common choice fixed mode calls usually native code 
emulated functions represented small native code stubs invoke emulator called 
advantage approach dynamic type test needed caller callee native code 
disadvantage calls emulated mode functions penalised conversions native code calling conventions 
hipe uses pseudo static approach calls mode caller 
described section native code caller refers emulated mode callee linker redirects call instruction invoke native code stub turn causes switch emulated mode 
emulated function compiled native code start original bytecodes overwritten special emulator instruction causes switch native mode 
asymmetry cases due fact hipe linker knowledge call sites native code 
return events recursive function call causes mode switch return sequence augmented perform inverse mode switch 
calls implemented dynamic tests fixed mode convention mode stubs 
dynamic tests return address tagged indicate mode switch required callee returns 
typically lowest highest bit 
lowest bit available return addresses aligned boundary 
highest bit imposes limit usable address space 
fixed mode convention calls mode returns 
mode native code call emulated mode function push stub native mode return address causes control flow back emulator 
hipe uses mode convention returns 
call causes mode switch new continuation stack frame created mode callee 
return address continuation points code causes switch back caller mode 
returns native emulated code return address points machine code runtime system 
returns emulated native code return address points special emulator instruction 
choice hipe causes overhead mode switches minimised amount changes existing jam emulator 
throw events hipe deals exception throws way deals function returns mode convention augmented mode switching stack frames 
call causes mode switch new exception catch frame created mode callee 
handler address catch frame points code switches back caller mode re throws exception 
call causes mode switch frames pushed catch frame return frame 
code return address return frame knows remove catch frame beneath switching mode 
maintaining tail recursion mode calling convention mode switch stack frames efficient easy implement 
programming languages 
functional programming languages erlang relies tail recursive function calls expressing iteration 
consider sequence tail calls emulated function native code function tail tail tail tail delta delta delta correct implementation erlang expected execute sequence bounded stack space regardless length 
unfortunately call new mode switch stack frame pushed return perform inverse mode switch 
stack space usage grow linearly length sequence tail calls optimisation lost 
hipe solves problem follows 
return address mode switch stack frame known value address return mode switch routine native mode address return mode switch instruction emulated mode 
simple runtime test able distinguish mode switch stack frames normal stack frames 
consider call sequence tail calls pushes mode switch frames native code stack catch frame return frame 
tail calls system normally push new mode switch frames emulated code stack 
hipe implements mode switch call event follows 
current return frame mode switch frame remove mode switch return frame caller stack remove mode switch catch frame caller stack invoke callee 
push mode switch catch frame callee stack 
push mode switch return frame callee stack 
invoke callee preventing adjacent mode switch frames created test restores proper tail recursive behaviour 
test expensive executed mode switch call 
implementation refutes statement section claimed mode switch stack frames loses tail recursion optimisation 
similar methods maintaining proper tail recursion context mixed mode execution prolog implementations bim prolog sicstus prolog methods probably folklore best knowledge print 
mode switching suspend resume events addition call return throw events described hipe may need perform mode switches process suspended resumed 
scheduler erlang runtime system knowledge current mode process 
assumes implicitly process executed jam emulator 
process created resumed scheduler simply passes process pcb jam emulator execution 
process suspended executing native code hipe sets resume address pcb point special emulator instruction 
scheduler resumes process jam emulator executes instruction transfers control suspended native code 
modifications jam emulator described sections modified jam emulator support mixing native emulated code 
summary modifications ffl jam loader registers location function bytecodes hipe linker 
ffl native code stack added pcb native code variables stack pointer resume address 
ffl garbage collector extended scan native code stack repair catch frame links stack relocated 
ffl small number instructions added jam emulator support mode switching emulated native code 
previous version hipe dynamic tests jam emulator 
call check target native code version return throw resume check return address zero interpreted signal switch mode 
design required changes different locations emulator complicated mode switch stack frame management imposed runtime overheads emulated code generally ugly difficult maintain 
contrast current design requires small localised extension emulator imposes runtime overheads mode switches 
performance instrumentation features support performance analysis benchmarking help users identify parts code benefit compilation native code added kinds performance instrumentation features hipe runtime system software event counters hardware performance counters 
software event counters keep track various interesting operations performed 
include number times erlang function called number times built library function called times jam instruction executed times control passed emulated native code 
hardware performance counters event counters inside ultrasparc processor measure number clock cycles spent code regions provide hardware specific information example amount time lost due stalls cache misses 
reason stall determined data cache instruction cache external cache branch misprediction 
details instrumentation facilities reader referred 

performance evaluation conducted performance comparison mhz single processor sun ultrasparc mb primary memory running solaris 
slow today standards machine ensure lightly loaded benchmark runs enabled user level access ultrasparc performance instrumentation facilities 
needed performance results section 
hipe functions called programs compiled native code 
erlang systems comparison hipe version erlang systems comparison jam beam etos 
jam beam systems measurements ericsson erlang hipe 
version etos 
describe beam modern processors hardware performance counters functionality level os support varies 
versions etos hipe significantly older 
etos hipe jam fully described earlier 
beam beam register machine influenced warren machine wam prolog implementations 
compared jam translation erlang code beam machine instructions advanced 
example treatment pattern matching better beam system full pattern match compiler implemented 
beam uses direct threaded emulator gcc class labels extension instructions machine code addresses part emulator implement instruction 
etos etos described system gambit scheme compiler 
translates erlang functions scheme functions compiled translation erlang scheme fairly direct 
advantages similarities languages optimizations gambit effective compiling erlang code 
optimizations inlining function calls currently single module unboxing floating point temporaries 
etos performs optimizations erlang scheme translation example simplification pattern matching 
process suspension etos done call cc implemented lazy copying strategy see 
process suspended stack frozen frame currently stack deallocated 
control returns suspended process stack frames copied top stack 
stack overflows garbage collector moves reachable frames stack heap 
general suspending resuming process require stack copied 
contrast jam beam hipe runtime systems handle processes explicitly saving restoring state process involves storing loading small number registers 
etos compiler progress full erlang implementation 
able run relatively small benchmarks etos 
time benchmark programs start performance comparison set standard small sequential benchmarks fib recursive fibonacci function 
calculates fib times 
huff huffman encoder 
compresses short string times 
length tail recursive list length function finding length element list times 
nrev naive reverse element list times 
qsort ordinary quicksort 
sorts short list times 
smith smith waterman dna sequence matching algorithm 
matches sequence length 
done times 
benchmark hipe etos jam beam fib huff length nrev qsort smith tak decode table times secs small sequential benchmarks 
tak takeuchi function uses recursion integer arithmetic intensely 
calculates tak times 
medium sized lines decode part telecommunications protocol 
decodes incoming binary message times 
table contains results comparison 
benchmarks hipe etos fastest systems small programs times faster jam times faster beam implementation see 
excluding length nrev hipe etos show complementary behaviour performance difference systems small programs significant 
decode probably difficult etos optimize operations pattern matching binary objects immutable sequences binary data hipe times faster etos 
hipe faster jam beam extent benchmarks 
fib huff length nrev qsort smith tak decode speedup jam hipe etos jam beam speedup compared jam small benchmarks 
compare erlang implementations concurrent programs 
mentioned erlang programs rely heavily concurrency primitives language 
programs call special attention erlang implementations 
benchmark programs ring creates ring processes sends messages 
benchmark executed times 
benchmark hipe etos jam beam ring stable life table times secs small concurrent benchmarks 
stable solves stable marriage problem men women times 
life executes generations conway game life board square implemented process 
table contains results comparison 
hipe fastest system times faster jam faster beam ring just times faster etos ring stable times life benchmark see 
fact etos significantly faster jam slower beam processes enter picture 
suspect etos implementation concurrency call cc efficient 
ring life stable speedup compared jam hipe etos jam beam performance speedup concurrent benchmarks 
time real programs unclear performance experiences gathered study small medium sized benchmarks applicable real life applications erlang 
compared performance hipe quite large erlang programs 
programs endeavour jam compiler application large 
portion compiler consists modules totalling lines erlang code 
benchmark compile modules jam compiler compiled systems 
eddie parser handles complex get requests 
excluding otp libraries consists modules total lines erlang code 
benchmark executed times 
axd time critical software part axd switch mentioned 
counting standard libraries consists lines erlang code 
actual benchmark program hipe jam beam jam compiler eddie axd table execution times seconds large programs 
atm switch sets tears number connections times functions benchmark amount code 
remaining code provides atm services handles errors occur practice benchmark run 
parts compiled native code 
table shows results comparison 
hipe fastest system 
move benchmarks real world applications erlang programs tend spend execution time built ins standard library 
example axd program extensively uses built ins access shared database top erlang term storage see data section 
implementation built ins currently shared systems percentage execution spent builtins bottleneck hipe speedup 
hipe faster beam largest benchmark considerably faster jam implementation see 
jam comp eddie axd speedup jam hipe jam beam performance speedup large programs 
code size benchmarking called functions programs compiled native code 
perfect sense small programs best approach cases 
mentioned users hipe selectively compile parts applications native code emulator remaining parts 
hipe space overhead prohibitive compilation applications native code valid option 
table provides evidence effect 
jam beam hipe presents size bytes loaded code benchmarks section 
cases axd functions loaded modules etos included currently handle large programs 
program jam beam hipe fib huff length nrev qsort smith tak decode ring life stable eddie axd table code size bytes programs 
benchmark axd fraction functions 
beam erlang system provide means obtaining size individual functions modules report corresponding number beam 
small programs code size increase hipe compared jam times 
compared beam hipe requires times code space excluding huff 
large programs space overhead low see axd 
comparison sizes stripped files produced etos compiler quite big partly due aggressive inlining performed etos 
clear extent etos benefits inlining 
note code size reported etos differ slightly code size programs loaded 
table denotes erlang vs functional languages compared performance hipe functional language implementations bigloo cml sml nj clean small benchmarks versions qsort fib huff ring benchmarks described previously 
small sequential benchmarks clean consistently fastest system 
systems showed considerable variance performance clear winner 
compared clean cml times slower bigloo times slower hipe times slower 
hipe bigloo comparable performance qsort hipe twice fast 
concurrent ring benchmark hipe times slower cml jam emulator times slower cml 
see details comparison 

detailed measurements shed light hipe performance characteristics compared erlang systems ericsson additional measurements benchmarks different sizes length eddie axd 
measurements obtained enabling performance instrumentation features systems see section installation explains slight mismatches performance numbers reported previous section 
thorough analysis comparison systems 
length small sequential benchmark consisting nested loops traverses list iterates number times 
benchmark hipe times faster jam times faster beam see table 
byte code emulation overhead evident benchmark hipe executes sparc instructions jam beam execute instructions respectively 
jam beam problems run time respectively pipeline stalls branch mispredictions see table 
table shows systems problems load stalls value needed completely loaded register systems suffers instruction cache misses 
eddie mildly concurrent messages sent benchmark parses requests 
parser consists modules added benchmarking purposes calls built functions erlang otp standard libraries heavily 
benchmark consists different erlang functions called total times 
benchmark hipe times faster jam times faster beam 
improved beam compiler emulation overhead beam executes sparc instructions hipe lot jam 
systems percentage pipeline stalls jam hipe beam 
axd time critical part ericsson axd atm switch 
responsible setting tearing connections switch 
code version axd earlier version product today 
benchmark concurrent eddie processes messages sent 
uses built functions heavily execution time jam spent built ins 
absolute terms time hipe relative terms corresponds hipe execution time built ins start bottleneck 
large benchmark total size called functions native code bytes see table 
jam beam hipe length eddie axd table speedups beam hipe compared jam calculated total execution times clock cycles 
mc mi cpi jam length beam hipe jam eddie beam hipe jam axd beam hipe table measurements benchmarks 
mc column rounded average execution times cycles 
mi column average number millions executed instructions 
cpi column number cycles instruction lower better 
benchmark hipe times faster jam times faster beam 
improved beam compiler completely emulation overhead 
indicated fact beam hipe execute sparc instructions benchmark see table 
execution times millions clock cycles mc millions executed instructions mi system benchmark shown table 
high speedup length hipe compared jam reasons 
compilation native code various optimizations hipe executes number sparc instructions jam executes 

utilizing pipeline better hipe executes times instructions cycle jam 
fewer instructions executed better pipeline utilization hipe gets speedup times jam shown table 
eddie length hipe beam execute considerably instructions jam hipe lower cpi jam beam 
benchmark uses builtin functions concurrency 
different types calls probably reason speedup hipe great length 
eddie systems spend time stalling mainly loads 
hipe significantly higher instruction cache stalls system jam beam suffer branch misprediction stalls see table 
large size generated native code axd absolute number instruction cache stalls twice hipe jam 
taken number stalls mispredictions stalls instruction cache misses jam hipe 
systems spend total execution time stalling ic total jam length beam hipe jam eddie beam hipe jam axd beam hipe table percentage execution time spent common types pipeline stalls 
column shows percentage load stalls shows percentage branch misprediction stalls ic shows percentage instruction cache stalls total column shows total percentage stalls 
numbers number executed machine cycles 
benchmark 
indicates hipe runs problems instruction cache hipe suffer jam beam suffer types stalls 
reason hipe achieve speedup smaller benchmarks time spent code currently outside hipe control built functions garbage collection 
ignoring time spent built functions garbage collector operating system hipe times faster jam benchmark 

plans described architecture implementation hipe native code compiler erlang 
hipe offers flexible user controlled integration interpreted native code complete implementation erlang supports features crucial telecommunication applications concurrency error handling hot code loading 
performance evaluation shows hipe fastest current erlang implementations 
hipe publicly available open source march 
current release erlang 
ericsson releases open source erlang exclusively beam implementation plan port hipe beam run time system 
hipe runs platform ultrasparc 
improve usefulness hipe system currently developing code generator processor family 
developing new front hipe compilation necessarily rely outcome previous compilation jam beam 
new front core erlang intermediate representation erlang developed 
core erlang fairly high level functional language expect easier include optimizations example efficient pattern match compilation level 
benchmark results indicate real world applications spend large fraction time built standard pro see www csd uu se projects hipe 

investigate issue extend scope hipe accordingly 
may require improving compiler tuning runtime system 
hipe greatly benefited prior involvement christer jonsson various design discussions thomas lindgren sven nystrom richard carlsson 
anonymous reviewers comments helped improve presentation 
research supported part advanced software technology competence center 

armstrong 
development erlang 
proceedings acm sigplan international conference functional programming pages june 
armstrong virding williams 
concurrent programming erlang 
prentice hall second edition 
baker riccardi 
implementing ada exceptions 
ieee software sept 
bell 
threaded code 
communications acm june 
blau rooth 
axd new generation atm switching system 
ericsson review 
briggs cooper torczon 
improvements graph coloring register allocation 
acm trans 
prog 
lang 
syst may 
dybvig 
implementation models scheme 
phd thesis department computer science university north carolina chapel hill 
technical report tr 
available www cs indiana edu scheme repository 
feeley 
compiling erlang scheme 
palamidessi glaser meinke editors principles declarative programming number lncs pages 
springer verlag sept 
gordon 
breed hybrid compilers interpreters 
technical report ecs lfcs department computer science university edinburgh 

representing type information dynamically typed languages 
technical report tr university arizona department computer science oct 
hartel benchmarking implementations functional languages float intensive program 
journal functional programming july 
hausman 
turbo erlang approaching speed tick editors implementations logic programming systems pages 
kluwer academic publishers 
hieb dybvig bruggeman 
representing control presence class continuations 
proceedings acm sigplan conference programming language design implementation pages june 
johansson 
nystrom lindgren jonsson 
evaluation hipe erlang native code compiler 
technical report uppsala university 
johansson pettersson sagonas lindgren 
development hipe system design experience report 
technical report uppsala university 
preparation 
jones lins 
garbage collection algorithms automatic memory management 
john wiley sons 
klint 
interpretation techniques 
software practice experience sept 
lal 
customizable reusable code generators 
unpublished technical report available www cs bell labs com george 
peyton jones ramsey 
portable assembly language supports garbage collection 
nadathur editor principles practice declarative programming proceedings international conference ppdp number lncs pages 
springer verlag sept 
peyton jones 
implementation functional programming languages 
computer science 
prentice hall 
stallman 
porting gcc 
technical report free software foundation 
sun microsystems 
ultrasparc tm user manual 
technical report sun microelectronics palo alto ca 

open telecom platform 
ericsson review 
see www erlang se 
virding 
garbage collector concurrent real time language erlang 
baker editor proceedings international workshop memory management number lncs pages 
springer verlag sept 
wadler 
angry half dozen 
sigplan notices feb 
warren 
prolog instruction set 
technical report sri international menlo park oct 
