cabins framework knowledge acquisition iterative revision schedule improvement reactive repair kazuo miyashita matsushita electric industrial cho osaka japan ped mei jp katia sycara robotics institute carnegie mellon university pittsburgh pa katia cs cmu edu september submitted artificial intelligence journal practical scheduling problems generally require allocation resources presence large diverse typically conflicting set constraints optimization criteria 
ill structuredness solution space desired objectives scheduling problems difficult formalize 
describes case learning method acquiring context dependent user optimization preferences tradeoffs incrementally improve schedule quality predictive scheduling reactive schedule management response unexpected execution events 
approach implemented cabins system uses acquired user preferences dynamically modify search control guide schedule improvement 
iterative repair cases exploited repair action selection evaluation intermediate repair results recovery revision failures 
method allows system dynamically switch repair heuristic actions operates respect particular local view problem offers selective repair advantages 
application repair action tunes search procedure characteristics local repair problem 
achieved dynamic modification search control bias 
priori characterization amount modification may required repair actions 
initial experimental results show approach able capture effectively utilize user scheduling preferences scheduling model produce schedules high quality unduly sacrificing efficiency predictive schedule generation reactive response unpredictable execution events variety criteria recognized important real operating environments 
scheduling task described assigning limited number resources activities time consistent manner avoid violation constraints associated problem resource capacity constraints activity precedence constraints release dates 
goal scheduling system produce schedules respect problem constraints optimize set objectives minimize tardiness jobs minimize process inventory wip maximize resource utilization minimize cycle time produced schedule respect user preferences 
scheduling difficult automate reasons 
computational complexity scheduling problem hardest subset np complete problems fre 

tight constraint interactions due tight interactions scheduling constraints non linear nature scheduling objectives general way predict effect local optimization decision global optimality simplest objective 

ill structured objectives preferences practical scheduling problems desirable multiple optimization objectives minimize weighted tardiness minimize process inventory maximize resource utilization satisfied 
optimization objectives interact conflict 
optimize objective jeopardize optimality objectives 
relationships global objectives extremely difficult model 
definition evaluation high quality schedule fraught difficulties need balance conflicting objectives tradeoffs 
tradeoffs typically reflect presence context dependent user preferences domain constraints captured scheduling model 
value incorporating user preferences constraints operational scheduling environments increasingly recognized mbs techniques currently lacking 

dynamic environment operational environments scheduling systems factories dynamic 
unpredictable events machine breakdown operator absence happen schedule execution 
schedule predictive created assuming world static predictable brittle 
clear effective scheduling system reactive perform schedule revision response unforeseen events schedule execution 
scheduling problem addressed general types methods constructive scheduling revision scheduling 
constructive approaches fox sad schedule constructed incremental construction merging partial schedules 
revision approaches bc lal complete suboptimal initial schedule incrementally repaired techniques heuristic simulated annealing 
ost predictive schedules generated scratch incremental revision repair pre computed schedule response unanticipated events schedule execution 
approach analyzes implications specific schedule features matches behavioral characteristics appropriate reactive actions selected static pre determined control model 
approaches assume existence explicit optimization function 
assumption general limiting practice optimization criteria reflect context dependent user preferences expressed terms single global objective function 
describe revision approach implemented cabins system provides unified framework acquisition user optimization preferences tradeoffs improvement schedule quality preferences reactive schedule management response unforeseen events 
systems utilize iterative repair find feasible solution executability schedule guaranteed repair iteration cabins produces executable schedule repair guaranteed monotonic increase quality time allowed repair exhibiting anytime executable behavior db 
desirable quality especially reactive contexts certain limited amount time system react 
approach uses integration case reasoning cbr kss fine granularity constraint directed scheduling mechanisms sf 
integrating cbr constraint scheduling stems variety motivations 
scheduling ill structured domain assume exhibits domain regularities captured albeit approximately case 
cabins case represents application revision action activity schedule expressing dependencies features schedule repair context suitable repair action see section detailed description case representation 
cbr allows capture re dependency knowledge dynamically adapt search procedure differentially bias scheduling decisions similar situations 
hand tightly coupled nature scheduling decisions revision part schedule may cause constraint violations parts 
constraint propagation techniques necessary determine ripple effects spread conflicts parts schedule case repair actions applied specific schedule revisions 
evaluation criteria judging acceptability outcome repair action multiple conflicting context dependent reflect user judgment tradeoffs 
difficult describe evaluation criteria associated tradeoffs simple manner 
case base incorporates distribution examples collectively implicitly capture user schedule evaluation preferences tradeoffs diverse problem solving circumstances enable cabins induce tradeoffs case base 
user preferences reflected case base ways preferences selecting repair action depending features repair context evaluation preferences repair outcome resulted selection application specific repair action 
revision approach attractive solving practical scheduling problems 
known efficient search algorithms schedule optimization limited set simple objectives span abz amount computation required finding solution generally unpredictable fre 
construction cheap suboptimal schedule incrementally repaired meet optimiza tion objectives preferable practice interrupt repair process interim result execution time allowed repair 
example dispatch heuristics low computational cost due myopic nature tailored particular optimization objectives 
general address issues balancing tradeoffs respect variety optimization objectives 
consequence result suboptimal schedules 
efficiency widely practitioners 
pointed researchers combining repair methodology simple gradient search ks neural networks joh advocated dispatch driven scheduler creation initial schedule promising real world scheduling environments 
experimental results reported section indicate cabins produce substantial schedule improvements starting schedules generated methods number dispatch heuristic constraint scheduler 
approach evaluated extensive controlled experimentation job shop scheduling problems 
experimental results reported section show approach potentially effective capturing user preferences optimization tradeoffs difficult model improves schedule quality irrespective method initial schedule generation produces high quality schedules lower computational cost compared simulated annealing known iterative repair method suitable reactive scheduling method maintains high schedule quality minimizes disruptions face execution time failures 
rest organized follows section gives background job shop scheduling presents constraint techniques cabins 
section introduces case schedule optimization 
section presents case representation indexing retrieval application schedule retrieved revision presents extensive example 
section presents experimental results validate approach 
section discusses related section 
job shop scheduling job shop scheduling deals allocation limited set resources number activities associated set jobs orders 
dominant constraints job shop scheduling temporal activity precedence resource capacity constraints 
activity precedence constraints job release date due date restrict set acceptable start times activity 
capacity constraints restrict number activities resource particular point time create conflicts activities competing resource overlapping time intervals 
goal scheduling system produce schedules respect temporal relations resource capacity constraints optimize set objectives 
model allow substitutable resources activity job able deal parallel machine job shop scheduling complicated version job shop scheduling problem mp 
cabins revision approach phases create initial schedule utilizing method dispatching rules improve possibly suboptimal schedule generated step incorporate user preferences tradeoffs 
rest section job shop scheduling problem framework constraint satisfaction search strategy propagate effects repair actions cabins 
constraints job shop scheduling problem requires scheduling set jobs fj 
set physical resources res fr 
rm job consists set operations activities fa 
scheduled process routing specifies partial ordering activities 
job release date rd signifies earliest time job started job due date dd job finished 
activity fixed duration du variable start time st domain possible start times activity initially constrained release due dates job activity belongs 
order successfully executed activity requires different resources milling machine jig ij may pool physical resources choose omega ij fr ij 
ij ijk res ij possible milling machines 
formally problem defined follows variables vector variables associated activity includes 
activity start time st 
resource requirement ij activity alternatives 
constraints non unary constraints problem types 
precedence constraints defined process routings translate linear inequalities type st du st 
capacity constraints restrict resource activity time translate disjunctive constraints form qr ip jq st du st st du st constraints simply express different resources activities overlap time assumed discrete activity start times times take integer values 
resource requirement ij selected set resource alternatives omega ij res 
constraints include non release dates initially non due dates activities job need performed 
objectives preferences practice scheduling objectives numerous complex conflicting mathematics problem extremely difficult simplest objectives fre 
define objectives constraints generalized dealing resources capacity larger 
common literature fre develop performance evaluation cabins 
objectives mathematical simplifications state dependent objectives difficult model precisely 
example optimization criterion weighted tardiness ip induced cabins user gave consistent evaluation schedules easily represented ways explored traditional schedule approaches 
waiting time time elapses completion preceding activity gamma rd start processing total waiting time sum waiting time activities belong clearly completion time time processing finishes 
equality rd du lateness simply difference completion time due date gamma dd tardiness delay completion due date dd note takes non zero value 
max 
amount time spends system 
gamma rd du span max latest completion time entire orders 
max maxc process inventory wip summation total waiting time 
ip weighted tardiness weighted average tardiness 
weight considered penalty cost tardy 
quality schedule function extent achieves user preferences 
illustrate necessity having user preferences scheduling system simple example 
assume simplest factory single machine jobs 
job consists single activity processed factory machine 
assume jobs released factory floor time 
schedule due date due date release date tardiness job wip job job job schedule wip job time horizon job job example conflicting objectives shows schedule results problem 
suppose schedule generated 
schedule job finishes due date job tardy 
wip job indicated wip job zero 
suppose wishes revise schedule reduce tardiness job simple schedule possible repair switch positions job job schedule resulting switch schedule 
schedule job tardy wip schedule wip job larger schedule 
extremely simple example difficult decide schedule higher quality consideration preferences user 
simply adding wip plus weighted tardiness minimizing sum may realistic relative importance objectives sum reflects tradeoffs user willing 
tradeoffs may depend factors importance client job past shipping records load factory warehouse 
combination factors produces enormous number contexts user preferences considered making user preferences difficult capture represent priori problem model 
reason authors think acquiring preferences adaptively important 
constraint search procedure constraint search procedure cabins applying selected repair action see section sf sad 
search interleaved application consistency enforcing mechanisms variable value ordering heuristics attempt avoid dead states 
search state associated partial solution 
search state defines new constraint satisfaction problem variables variables instantiated constraints initial problem constraints constraints reflecting current assignments 
schedule built opportunistically selecting activity scheduled assigning reservation resource start time 
time new activity scheduled new constraints added initial scheduling constraints reflect new activity reservation 
new constraints propagated consistency checking 
inconsistency constraint violation detected propagation system backtracks 
scheduler selects new activity schedule reservation activity 
process terminates activities scheduled successfully 
specifically search proceeds steps 
operations scheduled go step 
apply consistency enforcing procedure 
dead detected backtrack select alternative reservation left go back step 
select operation scheduled variable ordering heuristic 
select promising reservation operation value ordering heuristic 
create new search state adding new reservation assignment current partial schedule go back step details step follows consistency enforcement consistency enforcing procedure hybrid procedure differentiates precedence constraints capacity constraints 
guarantees dead states occur result capacity constraint violations 
essentially consistency respect precedence constraints enforced updating search state pair earliest latest possible start times unscheduled operation 
consistency enforcement respect capacity constraints tends significantly expensive due disjunctive nature constraints 
capacity constraints forward checking type consistency checking generally carried system 
resource allocated operation time interval forward checking procedure checks set remaining possible start times operations requiring resource removes start times conflict new assignment 
variable ordering scheduling np hard important focus search ways avoid dead states 
accomplished utilizing variable activity value reservation ordering heuristics 
variable ordering determines activity going scheduled value ordering determines reservation assigned selected activity 
variable ordering heuristic utilized system called activity resource reliance arr sf selects critical activity activity highest probability involved capacity constraint violation particular time intervals 
details approach see sf 
value ordering activity scheduled selected value ordering heuristic determines reservation assign activity 
value ordering heuristics relevant constraining value ordering heuristic selects reservation prevent activities scheduled 
uses unbiased utility function see activity preference particular start time activity available start times 
release date unbiased utility value biased utility value allowable latest start date utility functions greedy value ordering gv heuristic selects reservation local preferences expressed static piecewise linear biased utility function associated activity see 
biases value ordering prefer activity start times high utility values 
scheduling problems substitutable resources static utilities express differential resource preferences selection activity reservation 
experiments sf small job shop problems activities indicate arr variable ordering value ordering produces suboptimal schedules minimal backtracking arr variable ordering gv value ordering statically predetermined utility functions henceforth referred constraint scheduling cbs shown produce high quality schedules compared smu heuristic ky 
cabins schedule revision proceeds iteratively activity time 
set activities get involved constraint violations result repairing activity conflict set repair 
repair process activities conflict set modifies bias utility experiments run randomly generated scheduling problems 
functions associated 
bias reflects effects learning context dependent user preferences evaluations repair outcomes stored case base 
search procedure modified utility functions arr variable ordering gv value ordering schedule conflict set activities got unscheduled repair 
words time activity repaired cbs reschedule subset activities members conflict set schedule utility functions adaptively modified information case base 
section describes repair process detail 
case schedule optimization order optimize schedules user satisfaction need know contextdependent user preferences represent scheduling system exploited reasoning process 
rule approaches having potential capture context dependent tradeoffs rules require considerable knowledge acquisition effort pre 
approach uses case reasoning cbr potential dealing noisy data rk aka acquiring user knowledge complex domains cha mbs expending effort knowledge acquisition compared knowledge acquisition rule systems sm 
characteristics scheduling domain described previous section interest capturing context dependent user preferences cbr natural method knowledge acquisition 
applying cbr schedule improvement numerical optimization problem challenging 
general cbr ill structured symbolic problems planning ham kh vel legal reasoning ash ra argumentation conceptual design medical diagnosis primary concern plausibility correctness resulting artifact plan argument design computational efficiency process artifact quality 
challenges faced decide constitutes case domain schedule optimization case indices 
intuitive answer consider schedule case 
solution attractive right information transferred scheduling scenario little adaptation new problem solved relative ease 
high degree nonlinearity scheduling constraints objectives small difference input problem specification problems case base general result large variations results terms amount modification needed quality resulting schedule 
second difficulty respect having schedule case came form indices choose 
indexing case terms goals achieved problems avoided ham guideline served cbr systems 
domain goals achieved optimization criteria explicitly stated reflect context dependent user preferences tradeoffs 
optimization objectives explicit nonlinearities problem retrieving schedule achieved objectives desired ones current problem give little help adapting retrieved schedule current problem specifications 
unpredictable ripple effects constraint propagation tight constraint interactions problems avoided obvious discovered causal model scheduling assumed 
impossible judge priori effects scheduling decision optimization objectives scheduling decision applied schedule outcome evaluated terms resulting effects scheduling objectives 
having single scheduling decision case provide advantages terms focus traceability problem solving process 
focus traceability mean capture user evaluation results single scheduling decision case result unacceptable apply scheduling decision scheduling entity available scheduling decisions exhausted acceptable result obtained 
clear better single activity operation scheduling job scheduling entity scheduling decision applied 
result scheduling decision needed evaluated regard optimization preferences schedule clear constructive methods incrementally augment partial schedule scheduling decision point unsuitable purposes 
contextual information provided having complete schedule useful applying cbr 
revision scheduling chosen underlying scheduling methodology 
cabins case describes application schedule revision decision single activity job 
operationalization schedule revision decision done means schedule repair action 
identified classes schedule repair actions strategy tactic described detail section 
constraint propagation propagate effects schedule repair action rest schedule 
application repair results new schedule 
search space cabins space complete schedules incorporate acceptable user optimization tradeoffs 
predictive case features suitable case indexing ones capture tradeoffs 
schedule optimization hypothesis regularities domain captured albeit approximate manner features 
cabins indices divided categories 
category consists global features 
results schedule revision associated single activity pertain schedule global features express characteristics schedule relevant operate contextual information selection particular repair action 
local features comprise second category 
possible predict general bounds repair necessitated application repair action due constraint ripple effects reasoning effects repair action schedule priori amount unlimited lookahead analysis general intractable confine range lookahead analysis limited repair time horizon see section 
associated time horizon local features allow cabins estimate effects repair action 
schedule resulting application repair action evaluated terms user defined tradeoffs 
user predict effects modification actions schedule correctness quality modification result worsening schedule quality introducing constraint violations 
user perform consistent evaluation results schedule revisions 
evaluation recorded case part case repair history 
repair history constitutes third category case features 
case base incorporates distribution examples collectively capture repair performance tradeoffs diverse scheduling circumstances 
cabins searches space complete schedules 
control search provided cbr ways search control provided case selection repair action applied second case evaluation outcome schedule resulted application selected repair action 
global local features indices retrieve case suggests repair action applied 
features associated repair history retrieve cases suggest evaluations repair outcome 
detailed description case representation indexing see section 
cabins overview cabins general types repairs repair strategies repair tactics 
repair strategy associated particular high level description classes schedule defects 
repair strategy variety repair tactics associated 
repair tactics appropriate particular specializations defect classes 
identified general types repair strategies local patching model modification 
local patching selection repair actions result changing sequence activities allocated different resources rearranging resource assignments 
local patching general costly disruptive factory operations 
example repair goal reduce job tardiness specific local patching strategies include reduce slack activities tardy job reduce idle time resources needed activities tardy job 
model modification reformulates problem changing model parameters number jobs scheduled global constraints changing release due dates increasing resource capacity increasing number shifts 
model modification strategies facilitate solution problem amount global constraint relaxations 
practice model modification strategies costly implement buy new equipment pay extra shifts factory subcontract jobs outside contractors 
default cabins strategy local patching computationally challenging task system improve schedule relaxing imposed constraints due date constraints 
local patching unsuccessful fulfilling repair goal repair episode considered failure 
experiments run stringent assumptions 
depicts architecture cabins 
cabins composed modules initial schedule builder interactive schedule repair case acquisition module automated schedule repair case re module 
cabins operate modes exhibit different levels autonomy ffl knowledge acquisition interactive mode acquire user preferences generate case base 
ffl decision support interactive model previously acquired case base incorporates user preferences suggests revision actions evaluation outcomes user accept suggestion override new suggestion 
ffl automatic mode previously acquired user preferences reused guide scheduling decisions interaction user 
experiments reported section cabins operated autonomously 
repair process autonomous operating mode basic steps 
job initial suboptimal schedule randomly identifies repaired 
random job selection necessary cabins explicit optimization criteria select jobs repaired informed fashion 

job current repair consideration called focal job activity current repair consideration called focal activity 
repair performed activity time 
activities focal job repaired forward fashion starting earliest activity job upstream slack 
mechanism focuses attention activities slack moved avoiding unnecessary computations limiting amount ripple effects schedule disruption caused moving repair human expert repair cabins retrieve similar case apply repair tactic evaluate result case acquisition incomplete domain knowledge scheduling problem scheduler suboptimal schedule optimal schedule training data test data evaluation criteria case base contextual domain knowledge repair tactic feature values cabins architecture activities tightly scheduled move cause constraint violations 
repair strategy tactic selected current problem cbr applied 
application repair tactic described section consists parts identifying activities resources time intervals involved repair current conflict set change utility functions associated activities conflict set constraint directed scheduler utilities assigned step resource reservations activities identified step 

repair executed cbr predict evaluate repair outcome context current case base 

repair deemed success find activity repair repair outcome failure cbr invoked select repair tactic repair current focal activity 
case representation repair process exploit knowledge relating continuing validity various scheduling decisions flexibility current time capacity constraints trade offs implied particular repair repair successful unsuccessful user judgment 
shows information content case 
appendix shows example case instance cabins case base 
case describes application particular repair action activity 
ill structuredness domain case features heuristic approximations reflect regularities revision scheduling 
example regularities useful represent repair flexibility notion freedom current schedule moving activity new position 
global case features reflect potential repair flexibility schedule 
high resource utilization example indicates tight schedule current implementation upstream slack heuristically determined twice tardiness focal job 
case global feature weighted tardiness value salience resource utilization average value salience resource utilization deviation value salience repair history tactic outcome type value local feature value salience predictive shift gain value salience predictive alt shift gain value salience predictive swap gain value salience predictive alt swap gain value salience waiting time value salience value salience salience case representation act act waiting time repair time horizon repair time horizon focal activity act repair flexibility 
high standard deviation resource utilization indicates presence highly contended resources turn indicates low repair flexibility 
local features reflect flexibility schedule revision limited temporal bounds 
particular temporal bound cabins uses time interval called repair time horizon 
repair time horizon focal activity time interval activity preceding focal activity focal job focal activity see 
local features identified spirit utilized ost 
example predictive predicts gain achieved moving current focal activity earlier time horizon 
particular predicts reduction focal activity waiting time moved left repair time horizon 
repair history records sequence applications successive repair actions repair effects repair outcome 
repair effects describe impact application repair action schedule optimization objectives weighted tardiness wip 
typically effects reflect tradeoffs different objectives 
repair outcome evaluation assigned set effects repair action takes values set acceptable unacceptable 
judgment training phase gets recorded case base 
outcome acceptable tradeoffs involved set effects current application repair action judged acceptable 
case acquisition outcome judged unacceptable application repair tactic considered failure explanation expresses tradeoffs respect balancing favorable unfavorable outcomes optimization objectives provided 
cbr repair repair outcome deemed unacceptable tactic selected success cases repair activity indices global local case features failed tactic indication failed outcome 
cbr invocation retrieves similar past failures tactic successfully repaired tactic eventually successful fixing past failure 
assumption similar outcome tactic implies similarity causal structure past current case 
eventually successful tactic similar failure potentially successful current problem 
case acquisition cabins session starts empty case base 
set training problems user interacts cabins repair schedules hand 
user selects repair tactic deemed appropriate uses cabins tactic application procedure see section apply chosen tactic current schedule 
effects repair calculated 
effect describes result repair respect repair objectives 
effects pertain schedule job 
possible effects pertaining schedule weighted tardiness average resource utilization deviation resource utilization total schedule wip 
effects pertain job changes tardiness job changes process inventory changes resource assignment 
example tradeoff utilizing preferred machine reduce job tardiness reflected effects 
due tight constraint interactions effects ubiquitous job shop scheduling schedule optimization extremely hard 
application repair tactic produces feasible result user decide resulting schedule acceptable calculated effects 
example effects shown appendix outcome judged unacceptable schedule resulting application revision heuristic improvement respect user criteria 
happen harmful effects outweighed user judgment effected improvement 
example reduction job tardiness enforces increased utilization low quality machine total cost repair may low may user worries quality resulting products low 
repair judged unacceptable 
user judgment balancing favorable unfavorable effects related particular optimization objective constitute explanations repair outcome 
user supplies explanation terms rating importance effect denoted salience 
repair iteration applied repair tactic effects repair user judgment explanation repair outcome recorded case current problem features 
effects acceptable user repair outcome recorded acceptable user tries repair activity 
user tradeoffs incorporated repair effects outcome current repair tactic unacceptable effects calculated cabins salience assigned user recorded repair history case 
subsequently user tries utilize repair tactic repair activity 
process continues acceptable outcome reached failure declared 
failure declared available tactics repair activity user finds repair outcome unacceptable 
sequence application successive repair actions effects user judgment explanation case failed application recorded repair history case 
remarks order respect case acquisition 
new case acquired new activity repair 
activity repeatedly repaired due unacceptable repair tactic application results new case acquired repair history case augmented successive repair tactic application effects outcome 
way number cases accumulated case base 
section describe cases experiments acquired 
section report current experimental results investigate tradeoffs incurred cabins operates different size case bases 
case retrieval cabins constructed case base training data perform schedule repair interaction user 
retrieved cases purposes selection repair tactic applied evaluation resulting schedule application selected repair tactic case failure retrieval tactic fixed previous similar failure 
situations cabins utilizes different set indices case retrieval 
order retrieve cases select repair tactic global local features current case current focal activity 
process applying repair tactic described section 
repair applied result feasible schedule repair evaluation performed cbr 
effect features type value salience new indices cbr invoked returns outcome set acceptable unacceptable 
outcome current revision decided unacceptable cabins performs cbr invocation indices conjunction current outcome unacceptable failed heuristic case global local features find possibly applicable revision heuristic 
invoking cbr indices retrieves cases failed past similar manner current revision 
cbr space failures domain independent method failure recovery sim allows problem solver access past solutions failure 
result acceptable cabins proceeds repair activity 
case retrieval situations described cabins uses nearest neighbor method nn das case retrieval 
space nearest neighbor calculation done set features corresponding retrieval situations 
example case retrieval select repair tactic nn space defined values global local features 
nn calculation finds neighbors constant current problem training data pre determined similarity measures simplest form single nearest neighbor chosen classification result 
selected nn nn reasons 
domains scheduling clear predictive features due lack causal structure matches nearest match potentially contribute accurate classification 
large number near neighbor cases category suggesting swap tactic applied higher confidence classification result near neighbors different categories suggesting left shift suggesting swap 
example deciding repair tactic applied current problem suppose current implementation cabins set 
nearest neighbors 
left shift cases similarity current problem swap cases similarity 
nn left shift selected repair tactic nearest retrieved case similarity uses left shift successful revision tactic 
method occurrence multiple cases suggesting different classification result relatively high similarity potentially ignored 
sum similarity nearest neighbors selection criterion frequency appearance class nearest neighbors order avoid situation dissimilar cases may undue influence classification result previous example swap selected repair tactic cabins total similarity vs left shift 
similarity case current problem computed cabins follows distance salience theta gamma dev similarity exp salience salience th feature th case case base value th feature th case value th feature current problem dev standard deviation th feature value cases case base distance dissimilarity th case current problem 
similarity similarity th case current problem 
utilize normalized euclidean distance measure dissimilarity case problem 
prevents certain features dominating distance calculation merely large numerical values 
repair cabins repair schedule performed applying repair tactics selected repair iteration cbr 
repair tactics currently available cabins method successfully applied domains clear causal structure english word pronunciation text classification sw 
left slide try move focal activity resource left timeline possible repair time horizon preserving sequence activities 
left shift try move focal activity resource left timeline possible repair time horizon minimizing disruptions 
left shift alt try move focal activity substitutable resource left timeline possible repair time horizon minimizing disruptions 
swap swap focal activity activity left resource repair time horizon causes disruptions 
swap alt swap focal activity activity left repair time horizon causes disruptions changing resource assignment focal activity substitutable resource 
give give repair current focal activity 
expanded set tactics currently performing additional experiments 
process applying repair tactic steps 
determine predictive start time focal activity repaired 
predictive start time activity temporary start time calculated repair tactic desirable start time focal activity 
ripple effects repair conflict set consists activities may need re scheduled due constraint violations arising moving focal activity predictive start time 
note predictive start time may exactly start time result execution repair step 
ffl left shift left shift alt predictive start time start time minimizes capacity allocation result moving focal activity substitutable resource focal activity repair time horizon 
ffl swap swap alt predictive start time start time causes amount precedence constraint violations substitutable resource focal activity repair time horizon 

project effects moving focal activity predictive start time designated resource 
done performing constraint propagation identify capacity constraint violations 

adjust reservations activities conflict set simple right shifting left shifting conflicts resolved 

change bias start time utility function see fig 
activities conflict set favor start times calculated step 
tactic applied involves substitutable resource change resource utility function substitutable resource utility higher resource focal activity currently scheduled 
changing utility functions biases selection start times value ordering heuristic section favor higher utility values reflecting preferences encoded case base 

focal activity members conflict set re schedule opportunistic constraint directed scheduler arr variable ordering gv value ordering utility functions defined step 
restore start time utility function affected activities reflect bias repair iteration 
process results conflict free revised schedule 
effects revision calculated cbr invoked effects relevant indices evaluate repair outcome 
note activity moved different situations 
moved current focal activity 
second moved conflict set focal activity 
gives detailed example graphically shows local repair action left shift applied 
simplified example jobs activities 
suppose current focal activity left shift chosen repair tactic 
step revision find appropriate start time activity left shift dictates activity starting soon possible repair time horizon 
utility function associated reflect preference starting late possible indicated utility function repair adjusted accordingly 
new utility function indicated utility function adjustment 
step find conflict set consists affected activities moving left 
members conflict set shown 
utility function activity conflict set adjusted reflect changes 
show example adjustment utility activity utility functions adjusted focal activity activities conflict set unscheduled constraint scheduler called re schedule 
resulting repaired schedule shown bottom 
example briefly illustrate repair process simple example schedule repaired shown gantt chart row shows assignments activities resource timeline white box corresponds assignment activity 
number inside white box identifies job activity belongs 
example activity resource activity job identified text write indicate ith resource identify jth job identify kth activity job example jobs 
job activities linear precedence constraint 


resources substitutable resource bottleneck 
suppose current focal job current focal activity indices retrieve similar cases case base calculated follows 
global features weighted tardiness particular case weighted tardiness schedule 
job job job resource constraint propagation precedence constraint propagation focal activity conflict set machine machine machine left shift machine machine machine left shift time horizon function repair adjustment function utility utility repair adjustment example repair tactic application left shift resource utilization average feature calculated ratio utilization resources availability resources 
value feature 
resource utilization deviation deviation resource utilizations different resources equal 

local features waiting time feature defined time completion preceding activity start focal activity 
case equal gamma 
predictive shift gain computed cabins follows predictive start time gamma current start time waiting time theta predictive start time defined section current start time waiting time parameters associated focal activity 
heuristically estimate repair time horizon hyperbolic tangent function 
example value predictive shift gain 
predictive alt shift gain calculation feature similar predictive shift gain case required resource activity bottleneck resource substitutable resources value predictive alt shift gain 
predictive swap gain calculate predictive swap gain cabins uses formulas predictive shift gain predictive start time calculated differently 
see section example predictive swap gain 
predictive alt swap gain value feature requires bottleneck resource substitutable resources 
original schedule results case retrieval performed global local indices 
turns case retrieval case shown appendix similar selected swap repair tactic focal activity apply swap cabins calculates activity swapped 
cabins selects activity swapped result amount precedence constraint violations 
see activities swappable repair horizon 
activities glance may appear better swapped doing finished early possible 
best choice swapped cause lot downstream ripple effects contrary primary intention keeping repair effects localized possible 
calculation estimated possible effects cabins decides swap job weight weighted tardiness theta gamma 
effect applying swap tactic unscheduled re scheduled start time start time activity prior swap 
due larger duration activity ripple effect precedence constraint violation activity successor activity resource 
general activities affected rescheduled described section 
constraint propagation discovers constraint conflict shifts activity right resource schedule results repair resulting repaired schedule shown 
effects repairing calculated 
cabins estimates local effects focal job calculates global effects schedule 
machine utilization change estimated decrease weighted tardiness time units estimated decrease wip units increase weighted tardiness units increase wip units 
global weighted tardiness decrease gamma global wip increase 
cbr invoked effects applied repair tactic indices determine repair outcome acceptable 
success cases failure cases retrieved nearest neighbors considered effects reflect tradeoffs user preferences example little weight wip outcome considered acceptable 
hand failure case retrieved outcome considered unacceptable reflecting user preferences minimization weighted tardiness expense increasing wip 
example cbr invocation effects indices retrieves closest matching case case shown appendix effects match effects associated swap repair tactic 
outcome deemed acceptable 
decreases precisely determined activity repaired evaluation approach conducted set experiments test hypotheses 
approach potentially effective capturing user preferences optimization tradeoffs difficult model 

approach improves schedule quality irrespective method initial schedule generation 

approach produces high quality schedules lower computational cost compared simulated annealing known iterative repair method 

approach suitable reactive scheduling method maintains high schedule quality minimizes disruptions face execution time failures 
hypotheses difficult test due subjective nature user preferences obvious correlate scheduling results captured preferences define quality schedule evaluation subjective 
address issues devise method test hypotheses consistent manner 
necessary know optimization criterion implicit case base experimental results evaluated 
experiments reported different explicit criteria weighted tardiness wip weighted tardiness reflect user optimization criteria built rule reasoner rbr goes trial error repair process optimize schedule 
rbr constructed select repair action application selected repair tactic evaluated unacceptable go repair actions giving repair 
applications repair action gathered repair history case particular activity repair 
repair repair effects calculated basis rbr predefined evaluation objective evaluate repair outcome consistently 
rbr different rules time generate different case bases different explicit optimization objective 
naturally objective known rbr known cabins implicitly indirectly reflected extensional way case base 
designing objective rbr reflected corresponding case base got experimental baseline evaluate schedules generated cabins 
evaluated approach benchmark suite job shop scheduling problems parameters number bottlenecks range due dates activity durations varied cover broad range parallel machine job shop scheduling problem instances 
particular benchmark problems structure problem orders activities 
order linear process routing specifying sequence order visit bottleneck resources fixed number activities increase resource contention problem tighter 
parameters cover different scheduling conditions range parameter rg controlled distribution order due dates release dates bottleneck parameter bk controlled number bottleneck resources 
ensure unintentionally hardwired knowledge problem solution strategies problem generator function embodied problem structure described generate parallel job shop scheduling instances problem parameters varied controlled ways 
particular groups problems randomly generated considering different values range parameter static moderate dynamic values bottleneck configuration bottleneck problems 
slack adjusted function range bottleneck parameters keep demand bottleneck resources close major part problem 
durations activities order randomly generated 
generating problem instances neighborhood problem controlled variation problem parameters accepted method operations research knowledge scheduling communities evaluating performance scheduling methods sad sc 
problem instances randomly generated shared features problem structure problem machines machines bottlenecks substitutable machines exist non bottleneck machines cbr exploit captured regularities structure problems transfer problem solving 
interesting note transfer carries number orders varied see table 
benchmark problems variations problems originally reported sad benchmark number researchers mus ls 
problem sets different respects allow substitutable resources non bottleneck resources solving parallel machine simple job shop scheduling problem due dates orders problems tighter percent original problems 
cross validation method evaluate capabilities cabins 
problem set class divided half 
training sample consisting problems activities repaired rbr gather cases 
explained section case acquisition section case acquired activity current focal activity irrespective number tactics available number tactics activity repair 
course activity consequently job may repaired repair cycle repaired focal activity activity conflict set focal activity moved 
allowing activity focal activity problem give maximum cases training sample different experimental optimization objective 
practice activities focal activities repaired upstream slack see section training sample cabins trained approximately cases 
cases case repair validation problems problems 
repeated process interchanging training test sets 
reported results validation problem sets 
possible theoretically predict bounds repair global optimum experiments cabins allowed run repair cycles 
preference acquisition test hypothesis cabins acquire user preferences constructed rbr case bases reflect user preference repairs minimize weighted tardiness second reflect complex criterion minimizing combination weighted tardiness wip 
cases constituted source knowledge cabins 
words objective cabins explicitly 
case bases source suitable repairs source advice regarding repair evaluation 
graphs fig 
show comparison performance cabins weighted tardiness case base labeled graphs cabins wt performance cabins weighted tardiness wip case base labeled graphs cabins wt wip 
results observe cabins wt generated higher quality schedules respect minimizing weighted tardiness cabins wt wip problem classes 
conversely cabins wt wip generated higher quality schedules respect wip weighted tardiness plus wip cabins wt problem classes 
nutshell cabins wt tries optimize schedule terms weighted tardiness neglects wip cabins wt wip takes account tradeoffs weighted tardiness wip schedule repair 
results indicate cabins acquire different subjective user preferences tradeoffs diverse objectives scheduling cases 
approach traditional heuristic scheduling approaches fre mp necessary devise particular heuristic suit optimization criterion 
case base changed different optimization objectives 
addition traditional search scheduling approaches branch bound dynamic programming tabu search simulated annealing approach doesn require explicitly represented objective function 
cabins potential inducing complicated form user objectives allowing handling exceptional situations cases 
true user objectives elicited intensely interviewing domain experts represented form rules done constructing rbr modules gather cases experiments 
rule knowledge acquisition extremely laborious pre scheduling problem ill structured domain expert sufficient knowledge making schedule efficiently 
cbr methodology cabins induce efficient control model cases obtained applications insufficient rules 
set experiments objective wip wt rbr repair set test problems 
table shows repair cabins efficient repair rbr improves quality schedules repair rbr 
potential explanation cabins wt wip cabins wt weighted tardiness plus wip problem set cabins wt wip cabins wt weighted tardiness problem set cabins wt wip cabins wt wip problem set scheduling results different case bases table repair rbr cabins wt 
wip wt wip cpu sec 
repair rbr repair cabins results described section cabins effectively utilize failure information stored cases refer ms details experimental results 
predictive reactive scheduling evaluated cabins scheduling methods standard criteria ost evaluating schedule revision quality 
criteria appropriate planning 
criteria attendance scheduling objectives quality revision respect desired optimization criteria 
amount disruption changes original schedule 
efficiency revision quick revision process 
particular revision process responsive schedule execution sense allowing execution proceed rapidly possible 
subscribe view schedule generation schedule repair viewed iterative repair process ease readability described experiments separate subsections 
schedule quality efficiency important predictive schedule generation reactive schedule management 
responsiveness schedule revision process crucial handling schedule execution failures opportunities patch schedule quickly allow execution proceed 
minimizing schedule disruption important reactive management schedule 
schedule starts executing important preserve continuity domain activity substantial cost having attend discontinuities introduced reactive schedule revision set costs resource assignments changed 
criteria balanced traded 
results show predictive schedule generation methodology improves quality schedules generated variety scheduling methods generates schedules higher quality variety optimization objectives lower processing cost compared simulated annealing known iterative optimization method jams lal 
recovering execution time failures approach attends schedule quality terms optimization objectives disruption responsive allows continuation execution delays response execution failures 
predictive schedule repair predictive schedule repair primary objective experiments optimize schedule quality low computational cost 
investigate experimental hypotheses compared cabins simulated annealing 
simulated annealing sa known iterative improvement approach combinatorial optimization problems reported able yield solutions better quality cost larger computational efforts number combinatorial optimization domains computeraided design integrated circuit image processing neural network theory jams lal 
sa applied job shop scheduling domain makespan objective reported lal potential finding shorter makespans state art tailored heuristic shifting bottleneck procedure abz 
details sa implementation follows 
generate initial schedule 
select activity randomly 
available repair actions tried select repair action remaining un tried repair tactics apply chosen repair tactic activity repair evaluate resulting repaired schedule respect explicit objective wip wt resulting schedule better schedule repair terms objective revision procedure goes repair randomly chosen activity revision procedure goes repair activity probability exp gamma delta temp delta defined difference schedule evaluations repair repair 
temperature temp updated decreased fixed percentage time fixed number currently repair actions applied revision procedure terminated pre set maximum computational effort reached 
ran experiments times reported best results separate runs sa incorporates probabilistic factor results necessarily different experimental runs 
order test generality approach repeated set experiments times time initial seed schedule generated set regarded dispatch heuristics constraint scheduler cbs 
dispatch rules selected generate initial schedule widely practical job shop scheduling problems earliest due date edd rule weighted shortest processing time wspt rule wspt order time urgency factor rule 
heuristics reported particularly reducing tardiness different scheduling conditions mp 
constrained scheduler cbs uses arr variable ordering heuristic gv value ordering heuristic pre determined biased start time utility functions see section 
experiments user objective function assumed minimizing weighted linear combination process inventory wip plus weighted tardiness 
multi objective function difficult optimize heuristically 
wip weighted tardiness compatible 
situations wip reduced weighted tardiness increases 
table presents average results problems benchmark 
results variety observations 
cabins improved initial schedule scheduling methods objectives 
noted dispatch heuristics extensively operations research experimentation results bak mrv 
initial schedules generated dispatch heuristics considered local minima sense table repair cabins sa different methods initial schedule generation wt 
wip wt wip cpu sec 
schedule edd repair cabins repair sa schedule wspt repair cabins repair sa schedule repair cabins repair sa schedule cbs repair cabins repair sa easily improved 
example initial schedules tight purpose machine idleness 
conjecture difficult improve initial schedule higher quality 
example difficult improve generated schedule edd generated 
experimental results support conjecture edd generated schedule improved percent generated schedule improved percent 
second observe better quality initial schedule better quality repaired result 
third cabins generated schedules comparable quality average times efficient simulated annealing 
contextual information captured cabins case base system failure information repair history effectively guide search prune unpromising paths making cabins efficient random search simulated annealing 
investigate cabins behavior vis vis initial schedule generation method training test sets resources wt wip wt wip cpu sec 
initial schedule repair cabins repair sa table repair cabins randomly generated initial schedules problems 
initial schedule problem randomly generated scratch 
took account precedence constraints resource constraints disregarding due date constraints generation executable schedule guaranteed 
expected qualities initial schedules low compared ones generated dispatch heuristics cbs 
table see cabins performs randomly generated initial schedules 
behavior cabins regard method initial schedule generation confirms intuitions operations research community mp higher quality initial solution better repaired solution 
consistent behavior repair methods example behavior simulated annealing experiments min conflict heuristic behavior constraint satisfaction problems :10.1.1.31.8372
interesting experimental results got far ffl evaluation revision control model learning conducted set experiments ascertain effectiveness case learning control model selecting repair actions 
results learning obtained random case selection application repair tactics activity repair 
results showed repair improve schedule quality approximately example problems 
ffl evaluation scalability test scalability approach generated additional set problems jobs uses resources 
usually real operating environments factory configuration number table repair cabins resources orders problems wt wip wt wip cpu sec 
schedule edd repair cabins schedule wspt repair cabins schedule repair cabins schedule cbs repair cabins type machines remain relatively reasonably long periods 
number orders fluctuate due varied customer demands economic factors 
assumptions experimentation focused varying number jobs number resources 
job problems generated problem generator function varying parameters set job problems controlled ways 
knowledge acquisition method job problems rbr acquire training case base problems jobs resources 
cross validation approach 
pattern results set problems 
results shown table 
ffl evaluation knowledge transferability order test generalization issues case learning transferability acquired knowledge collected cases solving resources jobs benchmark problems rbr 
case base collected step solve resources jobs problems 
results shown table 
see results got resource jobs case base better reported table cabins performs bigger problems original resource jobs case base 
see pattern cabins behavior improving schedule quality independent initial schedule generation holds 
wt 
wip wt wip cpu sec 
schedule edd repair cabins schedule wspt repair cabins schedule repair cabins schedule cbs repair cabins table repair problems case base collected problems knowledge acquisition practical point view results quite encouraging 
show cabins potential application operational factory environments knowledge transferability alleviate knowledge acquisition burden affecting system performance quality scheduling results 
repair response unpredictable execution events reactive schedule repair involves recognition conflicts introduced schedule result unexpected uncontrollable change execution environment propagation conflicts selection application repair action 
discuss experimental hypotheses evaluation criteria results reactive repair steps taken cabins 
step reactive repair recognition conflicts introduced schedule result unexpected events execution environment 
general types conflicts recognized temporal conflicts conflicts reflecting inconsistencies scheduled actual start times activities resource conflicts conflicts reflecting inconsistencies resource capacity currently available capacity required processing activities second step effects introduced conflicts propagated downstream forward time point time unexpected event happened right shifting 
involves undoing reservations inconsistent result unexpected event propagating effects determine consequences ripple effects unexpected event rest schedule 
result step feasible schedule typically worse quality predictive schedule occurrence deleterious unexpected event 
third step cabins repair suboptimal schedule resulted second step 
mechanisms cabins uses reactive repair exactly predictive optimization course attempt repair activities executed unexpected event happened 
unexpected event loss capacity machine breakdown activity processed resource time breakdown re scheduled 
illustrate repair process example 
shows predictive schedule problems experimentation predictive schedule optimization see section 
particular bottleneck problems static start time jobs 
schedule weighted tardiness units 
computing predictive schedule machine breakdown created middle schedule 
broken machine busiest machine 
breakdown timed occur total execution time increase deleterious effects rest schedule 
estimated duration breakdown times average duration activities problem 
assumed available processing time breakdown 
effects breakdown propagated downstream forward time 
particular activities scheduled broken machine scheduled reservations overlapped time interval schedule result machine breakdown schedule result machine breakdown schedule result reactive repair breakdown unscheduled re scheduled sequence time breakdown called right shifting ost 
right shifting activities typically results constraint conflicts related activities fixed constraint propagation mechanisms cabins feasible worse schedule results 
shows schedule resulting machine breakdown propagated effects 
weighted tardiness schedule fold worsening quality 
delaying schedule execution till fixed equivalent right shifting clearly option practice 
utmost importance schedule repaired enable execution continuity 
cabins applied repair schedule 
big delays arise consequence capacity loss assume optimization weighted tardiness repair objective 
shows schedule resulting repair cabins 
weighted tardiness decreased fold 
general responses repair strategies planning scheduling system occurrence unexpected events execution 
attempt repair 
strategy results advantage opportunities activities finishing earlier scheduled time additional resources available incurring execution delays entailed deleterious events partial total loss resource capacity activities finishing scheduled times 
strategy obviously suboptimal 
second repair strategy throw away rest plan schedule re plan re schedule point occurrence unexpected event 
speculated literature ost strategy may efficiently produce high quality schedules may increase schedule disruption measure disruption previous 
third repair strategy incremental revision existing schedule 
argued literature incremental repair process achieves efficient generation high quality schedules allows continuation execution minimizing schedule disruption desirable 
date experimental evidence provided favor incremental schedule repair opposed re scheduling exhibiting incremental repair approach performs repair objective simultaneously 
demonstrate cabins reactive capability respect execution time failures ones typically happen scheduling system guard 
set experiments performed cabins repair predictive schedule response unexpected capacity loss 
cbs re scheduling 
experimental results demonstrate incremental repair methodology cabins superior re scheduling performing reactive schedule repairs response execution failures desirable evaluation criteria 
measured disruption respect criteria 
difference start times repaired schedule original predictive schedule occurrence unexpected capacity loss 
difference resource assignment activities repaired versus original schedule 
difference sequencing activities resource repaired versus original schedule changes repaired original schedule qualify measures schedule disruption cause changes attendant costs resource set activities process routing expected job finish times 
example manufacturing environment changes start times may cause changes plans product warehousing material preparation product shipment plans change resource assignments may change product routings factory floor resulting need change programs material handling equipment automated guided vehicles changes activity sequencing machine may cause changes machine set ups worker assignments 
changes cause serious difficulties smooth continuation schedule execution factory floor 
obviously degree severity changes depends nature manufacturing process factory floor layout 
unified measure disruption schedule hard formulate 
compare performance reactive repair cbs re scheduling different machine breakdown scenarios sets problems 
experiment machine breakdown duration times average activity duration simulated bottleneck resource problems second experiment similar machine breakdown simulated set bottleneck problems 
cabins cbs gv reactive repair re schedule start time disruption routing disruption sequencing disruption repaired wei 
tar 
cpu time second table reactive repair vs re scheduling table shows average results experiments 
results show terms disruption quality cabins outperformed re scheduling cbs 
cabins efficiency worse cbs 
problems problem example cabins spends times time cbs 
examination result misleading 
reason rapid monotonic repair behavior cabins 
shown example cabins achieved better result quality cbs time point cbs finished re scheduling 
see seconds cabins achieved weighted tardiness units compared units achieved re scheduling time period secs 
contrast re scheduling method provide incremental schedule feasibility cabins incremental reactive repair results feasible executable schedule repair iteration repair process stopped secs schedule produced cabins executed higher quality produced cbs re scheduling time period 
behavior consistency exhibited experiments 
system responsiveness reactive contexts great concern 
see results robust different breakdown scenarios repeated experiments different variations duration machine breakdown 
experiment breakdown duration times average activity duration 
shows results 
graph shows reactive repair efficient saturates improvement possible 
characteristic cabins repair process suitable reactive repair allows continuation cpu time msec weighted tardiness reactive repair re scheduling repair responsiveness cabins problem execution minimal delay schedule quality loss repaired rapidly 
cases 
graphs compare performance cabins different sized case bases 
results obtained cabins wt wip type case bases 
case approximately cases generated rbr 
done allowing repair cycles training set problems activities 
get case bases different sizes appropriate number cases situation randomly selected deleted approximately size case base 
method generating new case base random deletion cases bigger case base similar ablation study performed bar 
initial schedule generation method cbs 
viewpoint knowledge acquisition interesting question knowledge acquisition terminated sufficient knowledge acquired enable high quality performance knowledge system 
case knowledge acquisition question cases knowledge capture reuse guaranteeing satisfactory performance 
unfortunately difficult answer question general due ill structuredness scheduling problem approximate nature cbr causal model available 
believe exists appropriate size case base give relatively satisfactory results terms schedule quality excessive overhead case acquisition case retrieval case base 
experimental results support hypothesis follows 
larger number cases better schedule quality 
marginal payoff increase case base size decreases 
explained partially fact number cases say cases capture characteristics problem space additional new cases may give redundant information 
size case base relatively small time new cases acquired may get information different part problem space results higher quality improvement 

terms efficiency system observe graphs cpu time msec repaired weighted tardiness machine breakdown average durations machine breakdown average durations machine breakdown average durations machine breakdown average durations repair ratio problem set weighted tardiness wip cabins wt wip cases cabins wt wip cases cabins wt wip cases cabins wt wip cases number cases case base cpu time sec effect case base sizes quality efficiency case base cases optimal choice 
terms cpu time quality improvement case base cases obviously outperforms case base cases 
terms schedule quality improvement case bases cases provide payoff proportional case base size increase 
discussion experimental results show cbr repair method potential capture different user optimization preferences performs terms producing schedules high quality compared constructive scheduling methods 
compared simulated annealing repair method cbr repair produces schedules comparable quality substantial computational savings 
addition cbr repair exhibits desirable anytime characteristics outperforms re scheduling constructive constraint method terms minimizing disruption maintaining high schedule quality 
section attempt answer question approach powerful 
believe power approach stems reasons 
pointed revision approaches making available complete assignment complete schedule domain provide information guide search compared constructive methods partial assignment available :10.1.1.31.8372
cbr revision method captures relevant information global case features exploits contextual information case retrieval 
second job shop schedule optimization belongs category hard np complete problems case features able capture important domain regularities repair flexibility 
complemented keeping information failed applications revisions repair case history keeping failed cases case memory 
failures exploited cbr prune unpromising paths search space similar situations 
third experimental results discussion section support hypothesis cases cabins acquired reported experiments cover solution space fairly evenly distributed fashion allowing cbr repair take advantage coverage 
conjecture quality solutions evenly distributed search space backtrack search example potentially solutions bunched particular parts search space lan dispatch heuristics myopic take advantage promising search paths 
believe regularities structure experimental problems captured cases training phase information transferable solve test problems 
information transfer problem size results table indicate 
table shows cases acquired training set job problems effective solving test problems jobs 
question arises extent information captured cases set problems transfer job shop optimization problems different problem structure 
question albeit great theoretical practical importance difficult answer theoretical way 
contrast np complete problems graph coloring satisfiability traveling salesman insightful analysis performed structure properties characterize easy hard problem instances similar characterization job shop schedule optimization problems currently open research problem bak 
due tight constraint inter dependencies job shop optimization known constitutes problem structure features problem difficult easy solve problem substantially similar different 
reason simple optimization objectives minimize machine problems proven wspt heuristic finds optimal solution currently impossible theoretically prove schedule optimality particular technique 
proposed problem solution extensive experimentation researchers understood facto difficult abz bak 
importantly approaches characterize problem structure job shop optimization explicit optimization criteria help analysis cabins explicit objective function aims capturing implicitly context dependent user preferences 
related shares motivations goals mbs motivations interactive user manipulation schedules 
system monitors user manipulation schedule requesting reasons revision 
information augment refine system knowledge 
approach promising experimentally tested 
approach rooted concepts mechanisms long line research constraint directed scheduling fox sol sad 
schedules generated incrementally constructing merging partial schedules 
extensively investigated various properties aspects scheduling methodology proposed sophisticated procedures techniques constraint directed scheduling 
research tradition come view scheduling opportunistic repair process operated static design assumptions deterministic application variable value ordering heuristics sad statically determined control level model application repair actions ost 
approach advances state art learning dynamically adapt focusing mechanism search procedure adapting repair model current problem solving circumstances user preferences tradeoffs 
approach generates schedules repair scheduling space complete schedules 
respect similar bc 
simulated annealing perform iterative repair 
knowledge form constraint types evaluation criteria added basic simulated annealing framework shown improve convergence speed 
studied tradeoff minimizing perturbations vs speed convergence conflict free schedule vs schedule quality measured terms number violated resource constraints 
min conflict heuristic repair heuristic chooses repair minimizes number conflicts result step lookahead investigated performance analyzed 
heuristic shown powerful solving queens problem shown inadequate types job shop scheduling constraint satisfaction problems mus initial assignment random 
min conflicts relies initial assignment :10.1.1.31.8372
cbr repair cabins hand shown experimentally improve schedule quality irrespective initial schedule generation method percent improvement quality final repaired schedule varies 
bc schedule modifications procedurally encoded 
small snapshots scheduling process called chronologies focus search information gained incrementally scheduling process locate classify resolve bottlenecks 
plausible explanation learning pebl applied learn search control rules increase search efficiency scheduling tasks nasa space shuttle payload ground processing 
pebl enables system generalize target concept chronic resource contention distribution examples 
cost function minimize number remaining conflicts schedule 
systems cabins doesn explicit objectives optimize applies case learning techniques acquire user optimization preferences records user repair decisions optimizes schedules acquired objectives 
repair scheduling methods considered related repair methods previously case planning systems vel kh ham 
previous case systems incremental solution revision motivated primarily concerns computational efficiency preserving plan correctness improving plan quality assumed existence strong domain model get information plan correctness 
example chef ham assumes existence model simulator evaluate derived plan detect plan failure uses studied domain rules selecting repairs 
research kh vel hypothesis plan built planner causally correct cbr find satisfying plan efficiently 
cabins knowledge acquisition system related previous case knowledge acquisition systems protos bar 
approaches usually require causal explanations expert teacher acquire domain knowledge 
cbr schedule repair embodied cabins user program assumed possess causal domain knowledge 
user give solid explanation selection repair action predict effects selected action plan caused tight interactions 
user expertise lies ability perform consistent evaluation results problem solving impart program cases problem solving experiences histories evaluation tradeoffs 
advocate framework knowledge acquisition iterative repair schedule optimization 
approach utilizes cbr mechanisms recording user preferences repair tactics explanations constraint scheduling application selected repair tactics 
approach predicated existence set schedule repair tactics operates respect particular local view problem offers selective advantages improving schedule quality capturing re user scheduling preferences judgments 
capability acquiring user optimization preferences important domains strong domain models usually explicitly expressed objectives unavailable 
available new optimization heuristics need developed evaluated implemented complicating design maintenance system 
cabins provides framework alleviating problems 
experimental results show potential approach capture effectively utilize user scheduling preferences scheduling model 
results indicate different scheduling objectives implicitly reflected case base differentially bias schedule repair procedure 
experimental results show defined objectives reflected case base cabins produces schedules higher quality compared repair scheduling methods simulated annealing 
addition cabins robust sense improved quality schedule regardless method generating seed schedule 
effort expended capture large number cases amortized repeated case base get high quality schedules efficiently 
importantly cabins acquire cases user interaction process solution improvement imposing undue overhead user 
believe cabins potential accommodating acquisition user preferences change time 
investigate issue issues automating hierarchical abstraction repair process dealing complex objectives larger problems 
acknowledgments research partially supported defense advance research projects agency contract 
performed author visiting scientist robotics institute carnegie mellon university support matsushita electric industrial zeng help experimentation insightful discussions 
appendix case instance name exp order activity slots slot feature value salience slot feature value salience slot feature value salience slot feature value salience slot feature value salience slot feature value salience slot feature value salience slot feature value salience solutions solution swap effects effect salience domain gain effect salience domain gain effect salience domain gain effect salience domain gain effect salience domain job gain result acceptable appendix case evaluation name exp order activity slots slot feature value salience slot feature value salience slot feature value salience slot feature value salience slot feature value salience slot feature value salience slot feature value salience slot feature value salience solutions solution effects effect salience domain gain effect salience domain gain effect salience domain gain effect salience domain gain result unacceptable solution swap effects effect salience domain gain effect salience domain gain effect salience domain gain effect salience domain gain effect salience domain job gain effect salience domain job gain result acceptable abz adams balas 
shifting bottleneck procedure job shop scheduling 
management science 
aka david aha dennis kibler marc albert 
instancebased learning algorithms 
machine learning 
ash ashley 
modeling legal argument reasoning cases 
phd thesis university massachusetts amherst 
bak baker 
sequencing scheduling 
wiley 
course textbook 
bar ray bareiss 
exemplar knowledge acquisition unified approach concept representation classification learning 
academic press new york ny 
bc cooper 
bottleneck identification process chronologies 
proceedings th international joint conference artificial intelligence ijcai pages sydney australia 
cha 
acquiring implicit knowledge complex domain 
expert systems applications 
cheeseman kanefsky taylor 
really hard problems 
proceedings twelfth international joint conference artificial intelligence ijcai sydney australia 
robert masand stephen smith david waltz 
mips memory knowledge engineering 
communications acm 
das dasarathy editor 
nearest neighbor nn norms nn pattern classification techniques 
ieee computer society press los alamos ca 
db dean boddy 
analysis time dependent planning 
proceedings seventh national conference artificial intelligence pages saint paul minnesota 
aaai 
fox mark fox 
constraint directed search case study shop scheduling 
phd thesis department computer science carnegie mellon university 
fre simon french 
sequencing scheduling mathematics job shop 
ellis horwood london 
ham kristian hammond 
case planning viewing planning memory task 
academic press new york ny 
jams johnson aragon mcgeoch schevon 
optimization simulated annealing experimental evaluation part graph 
operations research 
jams johnson aragon mcgeoch schevon 
optimization simulated annealing experimental evaluation part ii graph coloring number partitioning 
operations research 
joh mark johnston 
spike ai nasa hubble space telescope 
proceedings sixth conference artificial intelligence applications pages santa barbara ca 
ieee cs 
kh kambhampati james hendler 
theory plan modification reuse 
artificial intelligence 
smith fox 
issues design ai schedulers workshop report 
ai magazine 

reasoning evidence causal explanations 
proceedings case reasoning workshop pages clearwater fla 
ks john sridharan 
electronic new tool shop scheduling 
manufacturing review 
kss kolodner simpson sycara 
process casebased reasoning problem solving 
proceedings ninth international joint conference intelligence pages los angeles ca 
ijcai 
ky keng david yun 
planning scheduling methodology constrained resource problem 
proceedings eleventh international joint conference intelligence pages detroit mi 
ijcai 
lal peter van laarhoven emile aarts jan karel lenstra 
job shop scheduling simulated annealing 
operations research 
lan langley 
systematic non systematic search strategies 
proceedings aaai san jose ca 
aaai 
lewis brown 
case reasoning solution problem redundant engineering large scale manufacturing 
international journal expert systems 
ls liu sycara 
distributed constraint satisfaction constraint partition coordinated reaction 
proceedings th international workshop distributed artificial intelligence hidden valley pa 
mbs mckay 
scheduler knowledge uncertainty missing link 
proceedings ifip working conference knowledge production management systems galway ireland 
minton johnston philips laird 
solving large scale constraint satisfaction scheduling problems heuristic repair method 
proceedings eighth national conference artificial intelligence pages boston ma 
aaai 
minton johnston philips laird :10.1.1.31.8372
minimizing conflicts heuristic repair method constraint satisfaction scheduling problems 
artificial intelligence 
mp thomas morton david 
heuristic scheduling systems application production systems product management 
john wiley sons new york 
ron stuart russell 
long take 
proceedings aaai pages san jose ca 
aaai 
mrv morton 
accurate myopic tardiness scheduling 
technical report graduate school industrial administration carnegie mellon university 
ms kazuo miyashita katia sycara 
learning control knowledge cases schedule optimization problems 
proceedings tenth ieee conference intelligence application pages san antonio tx 
ieee 
mus muscettola 
scheduling iterative partition bottleneck conflicts 
proceedings ninth conference ai applications pages orlando fla march 
ieee 
ost ow smith 
reactive plan revision 
proceedings seventh national conference artificial intelligence pages st paul minnesota 
aaai 
pre 
developing managing expert systems proven techniques business industry 
addison wesley reading ma 
ra rissland ashley 
credit assignment problem competing factors case reasoning 
proceedings case reasoning workshop pages clearwater fla 
rk david ruby dennis kibler 
learning episodes optimization 
machine learning proceedings ninth international workshop ml pages 
sad norman sadeh 
look ahead techniques micro opportunistic job shop scheduling 
phd thesis school computer science carnegie mellon university 
sc smith cheng slack heuristics constraint satisfaction scheduling 
proceedings eleventh national conference artificial intelligence washington 
aaai 
sf norman sadeh mark fox 
variable value ordering heuristics activity job shop scheduling 
proceedings fourth international conference expert systems production operations management pages hilton head island sc 
sycara narasimhan 
case synthesis tool engineering design 
international journal expert systems 
sim simpson 
computer model case reasoning problem solving investigation domain dispute mediation 
phd thesis school information computer science georgia institute technology atlanta ga 
sm simoudis miller 
application cbr help desk applications 
proceedings case reasoning workshop pages 
sol smith ow muscettola 
integrating multiple scheduling perspectives generate detailed production plans 
proceedings sme conference ai manufacturing long beach ca september 
sw craig stanfill david waltz 
memory reasoning 
communications acm 
sycara 
patching old plans 
proceedings tenth annual conference cognitive science society montreal canada 
sycara 
argumentation planning agents plans 
proceedings eleventh international joint conference artificial intelligence ijcai detroit mich 
vel manuela veloso 
learning analogical reasoning general problem solving 
phd thesis school computer science carnegie mellon university 
zweben davis brian 
learning improve constraint scheduling 
artificial intelligence 
zweben davis 
rescheduling iterative repair 
proceedings aaai workshop production planning scheduling control san jose ca 
aaai 
zweben davis 
iterative repair scheduling rescheduling 
ieee transactions system man cybernetics 
zweben 
anytime rescheduling 
proceedings darpa workshop innovative approaches planning scheduling control pages san diego ca 
darpa 

