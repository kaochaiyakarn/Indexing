writing hygienic macros scheme syntax case kent dybvig dyb cs indiana edu indiana university computer science department technical report june revised july copyright fl kent dybvig preface report dedicated friend colleague bob hieb killed eleven year old daughter tragic car accident near home april 
bob worked macro system described years important concepts algorithms developed bob adopted dissertation project 
report intended justify macro system help potential users learn write macros 
companion report syntactic abstraction scheme written bob death attempt justify macro system place context 
companion report contains detail algorithms implementation macro system 
complete implementation macro system available run scheme system provision implementation dependent hooks 
obtained anonymous ftp cs indiana edu directory pub scheme syntax case 
ftp access contact get implementation 
implementation earlier implementation bob system described appendix revised report algorithmic language scheme 
implementation robust significantly efficient 
carl bruggeman detailed thoughtful comments drafts report scheme examples contained report formatted 
david george springer dan friedman helpful comments 
document describes hygienic macro system scheme similar documented appendix revised report algorithmic language scheme important differences 
importantly practical distinction system high level low level macros 
macros take advantage primitive operators penalty terms loss automatic hygiene referential transparency ease macros 
particular pattern matching facilities previously available high level macros context 
need completely rewrite macro originally written high level style simply requires access primitive feature 
furthermore need explicitly manipulate syntactic environments kind 
macro system consists set defining forms set forms apart putting syntax set primitives manipulating comparing identifiers 
system representation expressions objects different commonly scheme representations 
macro transformers take syntax objects input return expanded syntax objects output 
embedded syntax object sufficient information determine bindings identifiers contained syntax object internal representation syntactic form 
implementation dependent information may contained syntax object example position expression original source code may included debugging purposes 
section document attempts clearly define terminology syntactic forms primitive operators supplied macro system section 
section demonstrates series examples easy write macros ranging simple complex system section 
intended serve complete implementors guide theory operation help macro writers understand expansion process section 
order fully understand examples document necessary understanding scheme helpful necessary studied extend syntax high level system documented revised report 
document intended instruct potential macro system users system attempt justification comparison systems 
formal treatment macro system implementation background information macro systems 
syntactic forms primitives new macros defined extend set syntactic forms available program subprogram 
extended syntactic forms referred macro calls take form keyword keyword identifier names macro 
syntax determined macro vary significantly macro macro 
mechanisms establishing new keyword bindings writing macros described remainder section 
extensive examples demonstrating features described section section 
macros defined facilities automatically hygienic 
macro transformer inserts binding identifier variable keyword new binding capture identifiers name introduced 
macros defined facilities referentially transparent 
macro transformer inserts free identifier refers binding visible transformer specified regardless local bindings may surround macro 
order maintain properties bound identifiers introduced macros renamed effect avoid potential conflicts 
desired behavior desirable insert identifiers output macro behave original expression 
desirable inserted identifiers bound captured existing bindings inserted bindings bind capture existing 
mechanism doing controlled hygiene preserving manner described section 
new syntactic forms defined associating identifier keyword transformation procedure transformer top level syntactic definitions take form define syntax keyword transformer expression transformer expression expression evaluates transformer 
expander encounters expression form keyword expression passed associated transformer processing 
scope syntactic definitions limited lexical binding forms syntax keyword transformer expression body letrec syntax keyword transformer expression body forms keyword denotes new syntax body case letrec syntax binding scope includes transformer expression 
lexical macro keyword bindings ordinary lexical variable bindings pattern variable bindings introduced shadow lexical binding shadows top level binding identifier 
define syntax forms appearing definitions front lambda body similar body treated letrec syntax bindings 
macro transformers procedures argument 
argument macro transformer syntax object contains contextual information expression addition structure 
contextual information enables macro system determine identifier contained expression binding identifier refers 
information required maintain hygiene referential transparency 
information allows macro transformers compare identifiers intended free identifiers bound identifiers data 
syntax objects may contain syntactic information direct interest macro writer 
example syntax objects contain source annotations allow evaluator correlate final object code source code produced 
output transformer may macro call contain macro calls case expansion performed macro calls remain 
transformers decompose input syntax case rebuild output syntax 
syntax case expression takes form syntax case input expression literal clause clause takes forms pattern output expression pattern output expression syntax case evaluates input expression attempts match resulting value pattern clause 
value usually syntax object may scheme list structure 
value matches pattern output expression evaluated value returned value syntax case expression 
value match pattern value compared clause 
error signaled value match patterns 
patterns consist list structures identifiers constants 
identifier pattern literal pattern variable special identifier represents ellipsis 
identifier literal appears list literals literal syntax case expression pattern variable 
literals serve auxiliary keywords case cond expressions 
list structure pattern specifies basic structure required input pattern variables specify arbitrary substructure literals constants specify atomic pieces match exactly 
ellipses specify repeated occurrences subpatterns follow 
input form matches pattern ffl pattern variable ffl literal identifier identifier binding ffl pattern list list forms match respectively ffl improper pattern list list improper list forms match respectively nth cdr matches ffl form ellipsis ellipsis identifier proper list elements match respectively remaining element matches ffl pattern datum equal sense equal 
procedure 
optional serves additional constraint acceptance clause 
value input expression matches pattern clause corresponding evaluated 
evaluates true value clause accepted clause rejected input failed match pattern 
logically part matching process specify additional matching constraints basic structure expression 
pattern variables contained clause pattern bound corresponding pieces input value clause output expression 
pattern variable bindings created syntax case shadow shadowed lexical macro keyword bindings pattern variables referenced syntax expressions 
scheme syntax expressions form syntax template syntax form returns scheme object way quote important differences values pattern variables appearing template inserted template contextual syntactic information contained template retained 
list structure template remains ordinary list structure output items including identifiers inserted interpretation 
contextual information associated values inserted pattern variables items template retained output 
template followed ellipsis expands zero occurrences 
contain pattern variable subpattern followed ellipsis input 
expander determine times repeated output 
generalizes natural way nested ellipses 
exception rule special template expands macro defining macros introduce ellipses defined macros 
pattern variable occurs syntax template replaced matched syntax case expression established pattern variable binding 
pattern variables occur subpatterns followed ellipses may occur followed ellipses syntax template case replaced output matched input 
error transformer return raw symbol names returned transformer identifiers introduced syntax expressions 
words transformer returns symbol behavior undefined 
system provides predicates recognizing comparing identifiers identifier free identifier bound identifier 
predicate identifier 
returns true argument identifier 
term identifier shorthand syntax object representing identifier 
predicates free identifier 
bound identifier 
determine identifiers equal intended free bound identifiers output macro 
necessary determine binding introduced identifier bind predicate bound identifier 

identifiers bound identifier 
name original program introduced macro application 
predicate bound identifier 
detecting duplicate variable names binding construct preprocessing binding construct requires detecting instances bound variables 
necessary determine identifiers inserted free refer binding predicate free identifier 

literal identifiers appearing syntax case patterns cond matched free identifier 
identifiers may free identifier 
bound identifier converse true 
general identifiers introduced different macro expansion steps refer binding inserted free free identifier 
bound identifier 
rare occasions necessary compare identifiers inserted symbolic quoted data output macro 
predicate directly comparing identifiers symbolic data provided simple define terms syntax object gamma datum extracts raw datum syntax object define symbolic identifier 
lambda eq 
syntax object gamma datum syntax object gamma datum necessary generate single unique name insertion output macro necessary systems inserted bindings effect renamed necessary 
convenient able create list temporary names 
procedure generate temporaries purpose 
procedure takes list input returns list new identifiers element input list 
actual elements input list ignored 
typically list passed generate temporaries list input macro number determines number temporaries required 
see letrec example section 
occasionally useful define macros introduce visible bindings identifiers supplied explicitly macro call 
example wish define loop macro binds implicit variable exit escape procedure loop body 
done procedure implicit identifier 
procedure implicit identifier template identifier symbol arguments creates identifier named symbol behaves introduced time place template identifier 
template identifier macro keyword extracted input symbol symbolic name identifier constructed 
section presents examples implicit identifier 
syntax errors reported automatically syntax case clauses selected 
error messages produced misleading example syntax case applied portion input informative desired 
procedure syntax error signal error explicitly 
procedure accepts arguments argument syntax object stripped syntactic information readability remaining arguments strings describing error 
string arguments supplied default message invalid syntax printed stripped argument 
examples section contains sequence annotated example macro definitions simple macros graduating complex macros 
syntactic forms procedures described preceding section demonstrated 
examples define standard revised report derived syntactic forms assumption reader familiar syntax semantics 
code syntactic keywords appear boldface lambda lexical variables toplevel variables pattern variables appear italics comments constants appear roman okay 
example simple macro subexpression variant standard syntactic form 
define syntax lambda syntax case syntax define syntax expression establishes binding keyword specified transformer 
syntax object provided input transformer handed syntax case ultimately done syntax objects way syntax case 
syntax case expression contains clause 
input pattern specifies addition macro keyword form requires exactly subexpressions pattern variables bound corresponding pieces input 
output expression simply returns new expression defined terms pattern variable 
things worth noting simple example 
output generated macros generated directly indirectly syntax forms 
syntax form serves purposes expands pattern variables corresponding input retains information regarding lexical variable bindings contextual information output form 
example contextual information helps determine output refers toplevel binding binding 
hand local binding visible macro defined contextual information ensure referred local binding top level binding binding 
second pattern variable appearing input pattern shadows lexical variable bound enclosing lambda expression 
referenced output expression outside syntax form error 
possible locate binding identifier tracing outwards find nearest enclosing binding form binds identifier form exists identifier refers top level binding 
local binding forms include lambda letrec syntax letrec syntax internal define define syntax syntax case macro expands forms 
third pattern variable underscore example examples macro keyword appear input expression 
convention pattern variable may including name macro 
convention helps remind macro writer reads code keyword position fails contain expected keyword need matched 
convention help avoid confusion defining local macros syntax 
see discussion surrounding local examples appear section 
examples defining forms scheme implementations demonstrate ellipses specifying multiple define syntax lambda syntax case syntax define syntax lambda syntax case syntax cases expansions clearly show intended evaluates test expression evaluates true returns result evaluating remaining sequence 
sense test reversed form demonstrates output macro may defined terms 
require subexpression test expression zero additional forms form expands macro keywords form expands macro keyword variable 
system local bindings identifiers context expression alter semantics construct 
definitions problem expressions print win desired list write win newline lambda write win newline macros just easily defined local macros syntax letrec syntax 
example syntax lambda syntax case syntax write hi newline mom case matter syntax letrec syntax macro keyword appear transformer expression 
choice important recursively defined macro generalized zero letrec syntax lambda syntax case syntax syntax syntax pair 
pair 
pair 
second clause defines base case recursion subexpression third clause defines recursive case subexpressions 
clause specifies happens subexpressions 
expansion expect intermediate final forms macro recursive defined define syntax letrec syntax syntax 
syntax output third clause refer top level definition 
course try scheme system probably appear defined top level exactly thing 
try syntax different name say see happens 
macros defined far introduced new bindings 
definition define syntax lambda syntax case syntax syntax syntax expression return value subexpression evaluates true value evaluate true 
subexpression test value subexpression placing test part expression return value evaluate true value 
order avoid evaluating expression twice temporary variable introduced 
system maintains hygiene automatically binding visible code introduced macro code contained input macro 
correctly evaluates okay automatic hygiene evaluate second subexpression captured introduced binding 
okay useful think bound variable automatically renamed avoid conflicts fact implementations 
final output expander look lambda lambda okay generated names 
debugging purposes actual output include original names recorded separate table provided compiler system debugger 
see section information examples expansion process 
identifiers bound introduced bindings need new identifiers inserted macro may identifiers extracted input macro 
example unnamed provided system defined simply follows define syntax lambda syntax case syntax lambda series definitions subscript 
example demonstrates patterns contain ellipsis subpattern preceding ellipsis structured pattern containing pattern variables 
shows pieces pattern split output appear input separate output 
definition includes named define syntax lambda syntax case syntax lambda name syntax letrec name lambda name clause identical version second clause defines named form terms letrec 
order clauses important 
named match clause match identifier 
clauses reversed unnamed expressions match named clause pattern variable name matches 
avoid problem introduce unwanted matches define syntax lambda syntax case name identifier 
syntax name syntax letrec name lambda name syntax lambda uses identifier 
predicate ensure name identifier 
syntax wrapped name necessary pattern variables referenced arbitrary syntax forms may just output expression 
definitions produce correct output handed correct input automatically check syntax case basic structural errors input 
ensure bound identifiers identifiers 
version uses local help function called perform check define syntax letrec ids 
lambda ls null 
ls identifier 
car ls ids 
cdr ls lambda syntax case ids 
syntax syntax lambda name ids 
syntax name syntax letrec name lambda name successfully reject input expressions identifiers expected resulting error message reported say input rejected 
refine macro moving test output expression calling syntax error directly define syntax lambda define ids 
lambda ls null 
ls identifier 
car ls ids 
cdr ls syntax case ids 
syntax syntax lambda syntax error non identifier name identifier 
syntax name ids 
syntax syntax letrec name lambda name syntax error non identifier check sure name identifier left clause failure test may due general syntax error suppose handed form containing duplicate bound identifiers version checks condition define syntax lambda define unique ids 
lambda ls ids 
ls ls null 
ls identifier 
car ls ids 
cdr ls unique 
ls ls null 
ls 
car ls ls cdr ls null 
ls bound identifier 
car ls 
cdr ls unique 
cdr ls syntax case unique ids 
syntax syntax lambda syntax error non identifier duplicate identifier name identifier 
syntax name unique ids 
syntax syntax letrec name lambda name syntax error non identifier duplicate identifier bound identifier 
allows reject forms result conflict 
definition employ free identifier 
correct program rejected syntax lambda syntax case syntax macro call apparently expands program correct introduced identifier renamed avoid conflicts 
occurrences left free refer top level binding free identifier 
distinguish 
intended case bound variables predicate bound identifier 

sequence definitions ends version allows value expressions implicit expressions define syntax lambda syntax case syntax lambda particularly useful construct order evaluation lambda arguments value expressions unspecified example serve illustrate nested ellipses 
useful create pattern variable bindings hold intermediate output body macro 
purpose define local binding operator pattern variables similar ordinary variables 
syntax form defined expands syntax case expression single clause define syntax syntax lambda syntax case syntax syntax case list definition uses syntax third clause build piece output separately define syntax lambda syntax case syntax syntax syntax rest syntax syntax rest definition shows realistic syntax define syntax lambda orig syntax case orig var init step syntax step map lambda syntax case syntax syntax error orig syntax var syntax step syntax case syntax syntax var init step syntax var init step definition optional steps optional return value expressions 
syntax form bind pattern variables output help functions definition letrec define syntax letrec lambda syntax case syntax generate temporaries syntax syntax set 
cond syntactic form complex built forms come macro cond works terribly difficult 
show series definitions cond different properties 
simplest definition series define syntax cond lambda syntax case 
syntax syntax syntax cond 
syntax 
syntax cond syntax syntax cond notice appearance 
literals list 
informs syntax case identifiers appear pattern literals pattern variables 
order clauses definition important rearrangement done 
general specific patterns appear general patterns match input pattern appear pattern patterns check 
appear patterns 
output second clause simply syntax syntax choose complicated form avoid specifying return result evaluates false 
implementation dependent value determined expression 
output third clause written terms choose consistency preceding clause 
syntax cond version cond shows free identifier 
place syntax case literals list 
provides example define syntax cond lambda syntax case identifier 
syntax free identifier 
syntax syntax syntax syntax syntax cond identifier 
syntax free identifier 
syntax syntax syntax identifier 
syntax free identifier 
syntax syntax syntax cond syntax syntax cond wrong output versions cond recursive nature possible get slightly strange error message clause malformed 
example syntax error reported input cond error invalid syntax cond example cond complex previous recurs internally handle original input expression 
contains explicit error clause calls syntax error directly 
uses syntax defined earlier 
define syntax cond lambda orig orig syntax case 
syntax syntax syntax rest syntax cond syntax rest 
syntax 
syntax rest syntax cond syntax rest syntax syntax rest syntax cond syntax rest syntax error orig versions cond shown far cases types clauses subsequent clauses subsequent clauses 
necessary obvious base case recursion cond invalid syntax 
examples various clauses determining tail generated expression constructing output tail empty contains subexpression generated expressions contain part clauses 
set definitions uses local help function cond tail construct tail define syntax cond cond tail lambda clauses syntax case clauses syntax syntax cond lambda syntax case 
syntax syntax tail cond tail syntax syntax tail 
syntax tail cond tail syntax syntax tail syntax tail cond tail syntax syntax tail version constructs tail looking current clause uses simplified patterns matched current clause 
simplified pattern generate error explicitly clear error caused malformed cond expression 
define syntax cond lambda orig syntax case orig syntax tail syntax case syntax syntax syntax cond syntax case syntax 
null 
syntax tail syntax syntax tail 
syntax tail syntax tail syntax error orig explicit error clause omitted cond cause error system report error error invalid syntax just versions cond syntax error cond reported error cond 
version combines techniques preceding version earlier version recurs internally get right define syntax cond lambda orig orig syntax case syntax tail syntax case syntax syntax syntax syntax cond syntax syntax case syntax 
null 
syntax tail syntax syntax tail 
syntax tail syntax tail syntax error orig final definition cond expands pair mutually recursive local macros perform expansion 
works reports errors terms original cond expression straightforward previous definitions 
furthermore efficient previous versions requires new macro transformers constructed evaluated time cond expression occurs program 
demonstrate local macro definitions may inserted output macro perform additional complex processing input 
define syntax cond lambda syntax case xc xc syntax dots syntax syntax letrec syntax cond lambda syntax case 
dots syntax dots 
dots syntax cond dots dots dots syntax cond dots dots dots syntax cond dots syntax error syntax cond xc xc cond lambda syntax case syntax dots syntax cond dots cond xc xc escape introduce ellipses generated macros 
macro definitions shown section provide simpler demonstration feature 
local macro may written terms existing syntactic form procedure name syntax somewhat tricky usually idea 
shows restrict expressions expression require alternative part syntax lambda syntax case syntax expression evaluates 
body syntax error result 
definition looks simple ways attempt write macro easily gone wrong 
letrec syntax syntax 
case identifier inserted local macro output refer local top level expansion loop indefinitely 
definition specified syntax lambda syntax case syntax expansion loop indefinitely 
reason identifier appearing start pattern treated pattern variable definition keyword 
bound corresponding identifier input expression denotes local binding 
placing list literals attempt patch version syntax lambda syntax case syntax cause syntax case compare literal pattern scoped outside syntax expression input expression scoped inside syntax 
refer binding free identifier 
result syntax error 
conventional place macro keyword helps macro writer avoid situations wrong identifier matched inserted accident 
local macro defined terms existing binding macro keyword local macro defined recursively 
done internal recursion similar cond examples 
done observing problem second example advantage 
local definition general form allows zero test consequent pairs possibly followed alternative syntax lambda syntax case syntax syntax syntax list pattern variable pick identifier input carries local binding recursion step 
refer output top level refer local 
works best solution name local macro different top level macro letrec syntax support recursion 
macro appendix revised report scheme provides syntax rules form restricted variant syntax case 
defined terms syntax case define syntax syntax rules lambda syntax case pattern template syntax lambda syntax case pattern syntax template syntax rules differs syntax case ways 
syntax rules evaluate transformer procedure expands lambda expression 
second syntax rules support 
third output part syntax rules clause syntax template arbitrary expression expands syntax form 
macros written syntax rules written simple input pattern output template clauses 
definition example define syntax syntax rules completely correct ignore position pattern specified revised report reasons stated earlier convention position patterns matched macro calls 
definition inserting set dummy pattern variables define syntax syntax rules lambda syntax case keyword pattern template syntax dummy generate temporaries syntax keyword syntax lambda syntax case dummy pattern syntax template versions scheme provide version extend syntax system described document 
defined terms syntax case willing syntax place quote mark pieces clauses expanded template expander 
version shows extend syntax forms second allows forms output template 
define syntax extend syntax lambda define expand clause lambda syntax case pattern template syntax pattern syntax template pattern template syntax pattern syntax template syntax case syntax map expand clause syntax syntax define syntax lambda syntax case define syntax extend syntax lambda define expand template lambda syntax case pattern expression template syntax template expand template syntax template syntax syntax pattern expression template template syntax syntax template define expand clause lambda syntax case pattern template syntax template expand template syntax template syntax pattern template pattern template syntax template expand template syntax template syntax pattern template syntax case syntax map expand clause syntax syntax define syntax lambda syntax case version extend syntax letrec defined follows extend syntax letrec generate temporaries syntax set 
macro definitions earlier shorter syntax rules shorter extend syntax 
really matter taste 
examples involve insertion implicit identifiers output macro 
defines loop macro implicitly binds variable exit continuation body loop define syntax loop lambda syntax case syntax exit id implicit identifier syntax exit syntax call current continuation lambda exit id definition expression loop loops indefinitely loop zero 
exit set 
gamma terminates third iteration 
exit lambda loop exit terminates returns loop exit lambda exit terminate 
order create binding captures exit loop create implicit identifier macro keyword template 
implicit identifier behaves introduced time place template identifier case keyword macro call 
implicit identifier part original macro call input synthesized implicit identifier 
binding introduced exit just macro binding define syntax loop lambda syntax case syntax exit id implicit identifier syntax exit syntax call current continuation lambda define syntax exit id lambda syntax case syntax examples behave definition loop fact generated code nearly identical 
common implicit identifiers definition structure facilities 
definition define structure adaptation appeared scheme programming language 
system represents structures vectors length number fields element name structure remaining elements contain fields values 
structure definition expands containing sequence procedure definitions constructor structure type predicate access assignment procedures field 
names procedures constructed implicit identifiers name structure field names 
done local help procedure construct name 
procedure takes template identifier list identifiers strings forming implicit identifier name 
define syntax define structure lambda define construct name lambda template identifier args implicit identifier template identifier string gamma symbol apply string append map lambda string 
symbol gamma string syntax object gamma datum args syntax case name id syntax define structure name id name id id init syntax constructor construct name syntax name syntax name predicate construct name syntax name syntax name access map lambda construct name syntax name syntax id id assign map lambda construct name set syntax name syntax id id structure length length syntax id id index ids syntax id id null 
ids cons cdr ids syntax define constructor lambda id id init vector name id id define predicate lambda vector 
vector length structure length eq 
vector ref name define access lambda vector ref index define assign lambda update vector set 
index update notice choice template identifier call construct name 
constructor predicate identifiers structure name access assignment procedure identifiers corresponding field name 
logical choices difference define structure macro calls built incrementally 
generated procedure definitions easily macro definitions 
example define accessors macros necessary replace define access lambda vector ref index define syntax access lambda syntax case syntax vector ref index version define structure form may appear define define syntax form may appear including sequence definitions front lambda similar body 
definition defines complicated necessary attempts minimize amount consing 
new concepts introduced example example macro traverses entire input expression just top level structure 
simpler version defined replacing calls gen cons gen append gen vector syntax calls cons append list vector 
define syntax letrec gen cons lambda syntax case quote quote syntax case quote list quote syntax quote list syntax list quote syntax cons quote syntax case quote list quote syntax list list syntax list syntax cons gen append lambda syntax case quote list cons quote syntax case quote quote syntax quote syntax append quote quote list gen cons syntax gen append syntax list syntax case quote list quote syntax syntax append gen vector lambda syntax case quote list quote syntax quote list syntax vector syntax list vector gen lambda lev syntax case unquote unquote splicing unquote lev syntax gen cons syntax quote unquote gen syntax gamma lev unquote splicing lev gen append syntax gen syntax lev gen cons gen cons syntax quote unquote splicing gen syntax gamma lev gen syntax lev gen cons syntax quote gen syntax lev gen cons gen syntax lev gen syntax lev gen vector gen syntax lev syntax quote lambda syntax case gen syntax inserted transformer defined earlier inserted cons list primitive names resolve top level bindings bindings names lexically apparent scope expression cons cons cons final example section shows macro generating macro include ellipses generated macro escape sequence define syntax lambda syntax case name syntax define syntax name lambda syntax case syntax sequence allow sequence interchangeably 
ellipses generated macro may preferable bind local pattern variable variable place definition define syntax syntax dots syntax lambda syntax case name syntax define syntax name lambda syntax case dots syntax dots theory operation implementation macro system surprisingly straightforward 
section briefly describe implementation works 
strategies may possible 
implementing basic macro expansion algorithm procedure called expander called compilation expression entered keyboard loaded source file 
expander traverses input expression expanding macros encounters handling core forms lambda quote 
expander maintains lexical compile time environment contains information lexically visible identifiers macro keywords lexical variable names pattern variable names 
expander enters scope lexical binding construct lambda syntax case letrec syntax compile time environment augmented information new bindings 
leaving scope information dropped 
macro keywords lexical compile time environment holds associated transformers 
pattern variable names holds nesting depths number levels nested ellipses pattern variable followed 
lexical variable names records existence 
identifier bindings may shadow enclosing identifier bindings encountered binding type relevant expansion 
top level compile time environment maintained hold bindings top level macro keywords associated transformers 
identifier binding top level compile time environment relevant point lexical binding identifier 
phrase compile time environment refers combined lexical top level environments identifiers looked compile time environment looked lexical environment binding exists top level environment 
scope lexical binding identifier expander replaces occurrences new identifier 
new identifier contains original name identifier unique generated name set marks described original name retained case identifier ultimately symbolic data case eventually appears quote expression 
newly generated name look identifier meaning compile time environment 
lexical compile time environment maps generated names binding information 
efficiency substitution done incrementally creating syntax object encapsulating outermost form environment mapping old identifiers corresponding new identifiers 
form traversed expander macro transformers syntax case encapsulation pushed pending substitutions performed 
case lexical lambda bound variables generated names formal parameter names generated lambda expression 
pattern variables syntax case patterns lambda binding generated names established output expressions names bound run time corresponding pieces input 
pattern variable followed ellipsis generated name bound list corresponding forms levels ellipses list lists corresponding forms 
syntax letrec syntax forms generated name bound run time solely handle binding compile time environment 
identifier encountered expander expander action differs depending context visible compile time binding identifier 
identifier occurs keyword position form macro call macro keyword compile time environment associated transformer invoked described 
identifier encountered expander apparent variable bound lexical variable lambda bound variable converted corresponding generated name 
bound assumed top level binding expanded original name 
apparent variable type identifier macro keyword pattern variable invalid signaled expander 
identifier appears syntax form bound pattern variable compile time environment generated name nesting level expander generate code inserts corresponding output 
identifier appearing syntax form inserted output unchanged 
identifier appears quote form stripped original name 
macro call handled follows 
new mark created 
mark distinguishable marks unimportant marks represented 
currently represent marks integers 
mark attached identifier input macro resulting expression passed transformer 
identifiers output transformer similarly marked identifiers mark attached stripped mark 
way mark sticks identifiers introduced transformer stick identifiers transformer copies input output 
substitution old identifiers new identifiers described marking done incrementally efficiency marks applied recorded substitutions performed syntax object 
marks inhibit substitution macro introduced lexical identifiers captured bindings context call bound output macro capture input call 
marks occurrence identifier scope lexical binding construct marks bound identifier occurrence left identifiers equivalent 
example consider expansion subexpression version define syntax lambda syntax case syntax expression evaluate top level value variable expansion unfolds observe substitution marking prevent binding source expression interfering macro macro binding interfering source expression simplicity assume handled directly expander little tedium expand corresponding lambda application 
assume identifier substitutions marks applied immediately incrementally 
purposes discussion identifiers shown ordered triples form name current name gi original input fgi hif fgi hor fgi hif fgi ht fgi step binding original binding top level environment bound variable outer expression replaced generated name occurrence identifier scope expression replaced new identifier contains generated original names hor fgi hif fgi ht fgi existence binding recorded lexical compile time environment 
transformer invoked identifiers input marked mark hor fm gi hif fm gi ht fm gi transformer produces fgi ht fgi hif fm gi hif fgi ht fgi ht fgi ht fm gi output transformer identifiers marked marked mark removed identical marks cancel 
fm gi ht fm gi hif fgi hif fm gi ht fm gi ht fm gi ht fgi current name relevant identifier binding determined compile time environment mark attached identifier resolves top level definition 
bound identifier replaced generated name occurrences identifier current name marks replaced new identifier scope expression hif fgi hif fm gi ht fm gi ht fm gi ht fgi existence binding recorded lexical compile time environment holds record binding 
recorded lexically bound variable compile time environment occurrence hif fgi expands 
output expression far consists hif fm gi ht fm gi ht fm gi ht fgi line unexpanded 
current name identifier hif fm gi line recognized expression ht fm gi ht fm gi ht fgi variable expression remain expanded 
current name second recorded lexical variable compile time environment simply expand 
current name third binding lexical compile time environment expands top level final output expander responsibility pushing substitutions markings actual implementation syntax case expressions 
syntax case matches input pattern syntax objects far necessary perform match substitutions markings transferred subexpressions form 
match successful resulting values bound pattern variables corresponding generated names output expressions 
syntax expressions scope pattern variables rebuilt necessary insert values 
substitutions marks attached pieces output syntax retained subsequently inserted output macro identifiers pieces refer bindings visible appeared 
expander strips information quote forms equivalent syntax object gamma datum quoted symbols ordinary symbolic data 
identifiers bound identifier 
current name implies original name marks 
identifiers free identifier 
current name 
reflection compile time environment lookup identifier replacement rules current name relevant determining identifier binding current name marks agree identifier replaced scope lexical binding construct 
identifiers bound identifier 
may eqv information including source annotations may identifier structure 
rarely useful eqv 
identifiers 
implementation implicit identifier straightforward place constraints implementation necessary 
specifically identifier substitutions required binding forms visible occurrence identifier recorded identifier including substitutions affect identifier due difference current name marks 
implicit identifier formed copying substitutions marks template identifier new identifier 
original name new identifier second argument implicit identifier current name determined substitutions marks recorded template identifier 
william clinger jonathan rees 
macros 
conference record eighteenth annual acm symposium principles programming languages pages january 
william clinger jonathan rees revised report algorithmic language scheme 
lisp pointers 
kent dybvig 
scheme programming language 
prentice hall 
robert hieb kent dybvig carl bruggeman 
syntactic abstraction scheme 
technical report indiana computer science department june 
eugene kohlbecker 
syntactic extensions programming language lisp 
phd thesis indiana university bloomington august 
eugene kohlbecker daniel friedman matthias felleisen bruce duba 
hygienic macro expansion 
proceedings acm conference lisp functional programming pages 

