new algorithm partial redundancy elimination ssa form fred chow sun chan robert kennedy shin ming liu raymond lo peng tu sgi com silicon graphics computer systems shoreline blvd mountain view ca new algorithm ssapre performing partial redundancy elimination entirely ssa form 
achieves optimal code motion similar lazy code motion krs ds formulated independently involve iterative data flow analysis bit vectors solution 
exhibits characteristics common sparse approaches inherits advantages shared ssa optimization techniques 
ssapre maintains output ssa form input 
describing algorithm state theorems proofs giving claims ssapre 
give additional description practical implementation ssapre analyze compare performance bit vector implementation pre 
conclude discussion implications 
static single assignment form ssa popular program representation optimizing compilers provides accurate def relationships program variables concise form cfr wol ccl 
efficient global optimization algorithms developed ssa 
optimizations dead store elimination cfr constant propagation wz value numbering cs induction variable analysis gsw llc live range computation global code motion cli 
uses ssa restricted solving problems program variables concept def readily apply expressions 
noticeably missing ssa optimizations partial redundancy elimination 
partial redundancy elimination pre powerful optimization algorithm developed morel renvoise 
targeting partially redundant computations program automatically removes global common subexpressions moves invariant computations loops 
important component global optimizers cho bc cs 
krs krs knoop formulated alternative placement strategy called lazy code motion improves morel renvoise results avoiding unnecessary code movements removing bidirectional nature original pre data flow equations 
result lazy code motion optimal number computations reduced safe code motion lifetimes temporaries introduced minimized 
ds drechsler gave simpler version lazy code motion algorithm inserts computations edges nodes 
optimizations ssa share common characteristic require traditional iterative data flow analysis solutions 
take advantage sparse representation ssa 
sparse form information associated object represented places changes object occurs program 
replicate information entire program sparse representation conserves memory space 
information propagated sparse representation smaller number steps speeding algorithms 
get full benefit sparseness typically give operating elements program parallel traditional bit vector data flow analysis 
operating element separately allows optimization decisions customized object 
advantage ssa perform global optimization 
traditional optimization techniques implement separate versions optimization global version uses bit vectors basic block simpler faster local version performs optimization basic block 
ssa optimization algorithms need distinguish global local optimizations 
algorithm handle global local versions optimization simultaneously 
amount effort required implement optimization correspondingly reduced 
hinted dhamdhere developing pre algorithm ssa difficult expression redundant result different computations different places expression 
operands different ssa versions operands illustrated fig 

situation def chain ssa little help recognizing partially redundant 
help effecting movement computations 
lacking ssa pre algorithm optimizers ssa switch bit vector algorithms performing pre 
apply subsequent ssa opti gamma gamma psi oe pre gamma gamma psi oe oe pre pre ssa form necessary convert results pre back ssa form incremental updates arbitrary modifications program expensive css 
developed algorithm performs pre directly ssa representation program ssapre 
algorithm sparse require collecting traditional local data flow attributes program require form iterative data flow analysis arrive solution 
algorithm works constructing ssa form hypothetical temporary store result computation program 
resulting ssa form def corresponds computation result may need saved corresponds redundant computation may replaced load ssa form apply analyses corresponding pre 
analyses allow identify additional defs accompanying computations need inserted achieve optimal code motion 
final output generated updated ssa graph temporaries introduced program save reuse values computations 
algorithm works modeling ssa forms hypothetical temporaries real temporaries introduced maintained ssa properties fig 

rest organized follows 
section surveys related aimed improving efficiency data flow analysis pre 
section briefly introduces ssa form gives overview ssapre approach 
section describes ssapre algorithm detail stating related lemmas proofs 
section discusses theoretical foundations ssapre algorithm verifies correctness optimality 
section discusses practical issues related efficient implementation ssapre 
section compares contrasts steps ssapre bit vector pre analyzes complexity ssapre algorithm 
section provides measurements compare time spent performing pre bit vector implementation implementation ssapre 
section concludes discussing implications points promising areas similar techniques applied ssapre model 
related years seen development different techniques aimed improving solution data flow problems related ssa pre 
ccf generalizing ssa form choi derived sparse evaluation graphs reduced forms original flow graph monotone data flow problems related variables 
technique construct separate sparse graph variable data flow problem solving data flow problem variable sparse graph 
practically applied pre requires solution different data flow problems 
dhamdhere observed solving monotone data flow problem suffices examine places problem answer different trivial default answer 
possible transfer functions node raise lower identity propagate unchanged 
proposed analysis 
nodes identity transfer function reached node answer answer 
performing propagation method arrive solution variable pass control flow graph 
analysis sparse performs propagation respect control flow graph program 
approach place iterative solution monotone data flow problem formulated 
speed data flow analyses pre 
joh johnson proposed dependence flow graphs dfg sparse approach speed data flow analysis 
dfg variable viewed ssa graph additional merge operators imposed identify single entry single exit sese regions variable 
identifying sese regions identity transfer function technique short circuit propagation 
johnson showed apply techniques data flow systems drechsler variation knoop lazy code motion 
researchers rice university done aimed improving effectiveness pre bc cs 
involves application ssa transformation techniques prepare program optimization pre 
techniques enhance results pre 
implementation pre drechsler variation knoop lazy code motion unrelated ssa 
prior related pre modeled problem systems data flow equations 
regardless efficiently systems data flow equations solved substantial amount time needs spent scanning contents basic block program initialize local data flow attributes serve input data flow equations 
experience shown takes time solution data flow equations fundamentally new approach pre require dense initialization data flow information highly desirable 
ssapre satisfies property exploits sparseness 
overview approach input ssapre ssa representation program 
ssa definition variable unique version different versions variable regarded different program variables 
variable version refer single reaching definition 
virtue versioning def information built representation 
definitions variable am reach confluence point control flow graph program oe function assignment statement oe am inserted merge definition new variable version semantics single reaching definitions maintained 
new variable version result oe factors set def edges confluence nodes reducing number def edges required represent program 
ssa def chain variable provided making version point single definition 
important property ssa form definition dominate uses control flow graph program uses oe operands regarded occurring predecessor nodes corresponding edges 
assume expressions represented trees leaves constants ssa renamed variables 
ssapre applied program expressions independently regardless subexpression relationships 
section describe strategy exploits nesting relationship expression trees obtain greater optimization efficiency ssapre 
indirect loads candidates ssapre memory aliases indirect variables ssa form order ssapre handle 
form ccl allows ssapre uniformly handle indirect loads expressions program 
ssapre consists separate steps phi insertion rename willbeavail finalize 
ssapre works conducting round ssa construction lexically identical expressions program variables ssa form 
term ssa meaningfully applied expressions define refer hypothetical temporary store result expression 
rest phi refer oe ssa form hypothetical temporary contrast oe variable original program 
phi insertion rename initial ssa construction steps expressions 
round ssa construction approach similar described cfr working expressions program simultaneously 
alternatively implementation may choose lexically identical expression sequence 
describe sparse implementation section 
assuming working expression hypothetical temporary rename step occurrences corresponding version compute value 
stage points defs uses identified 
phi inserted unnecessary 
steps ssapre fix 
phi operands determined undefined 
rename available computation valued phi operands play key role steps ssapre insertions performed 
call ssa graph rename dense ssa graph contains phi minimal ssa form defined cfr 
expressions lexically identical apply exactly operator exactly operands ssa versions variables ignored matching expressions 
example lexically identical expressions 
ssa graph similar described gsw formed def edges nodes assigned ssa version 
sparse computation global data flow attributes performed dense ssa graph separate phases involved 
phase performs backward propagation determine phi results fully anticipated respect second phase willbeavail performs forward propagation determine phi computation available assuming pre insertions performed appropriate incoming edges phi 
results willbeavail ready finalize effects pre 
finalize step inserts computation incoming edges phi ensure computation available merge point 
occurrence program determines def links uses defs form precise ssa graph 
extraneous phi see cfr removed minimal ssa form 
step update program effect code motion determined ssapre 
step introduces real temporary eliminate redundant computations walks precise ssa graph generates saves computation giving unique ssa version 
redundant computations replaced phi translated oe native program representation 
ssapre algorithm section describe complete ssapre algorithm 
krs ds assume critical edges control flow graph removed inserting empty basic blocks edges 
allows model insertions edge placements insert ends predecessor blocks 
assume prior computation dominator tree dt dominance frontiers df respect control flow graph program 
data computed program put ssa form cfr 
base discussion expression hypothetical temporary example program shown fig 
illustrate various steps 
algorithms describe state prove various lemmas establishing theorems ssapre section 
phi insertion step phi expression needed different values expression reach common point program 
different situations cause phi expressions placed expression appears insert phi iterated dominance frontiers df occurrence may correspond def fig 
phi inserted block due block 
second situation causes insertion phi oe variable contained expression indicates alteration expression reaches merge point 
need insert phi merge point reaches occurrence expression phi contribute optimization pre 
fig 
phi block caused oe block 
need insert oe oe exit example program ssa form phi block merge point occurrence block 
types phi insertions performed pass program second type phi insertion performed demand driven way 
set df phis keep track phi inserted due df occurrences expression set var phis keep track phi inserted due occurrence oe th variable expression come occurrence expression update df phis 
variable occurrence check defined oe 
update var phis phi block contains oe may contribute optimization current occurrence may apply earlier points program necessary recursively check updates var phis operand oe occurrences program processed places insert phi union df phis var phis 
full algorithm phi insertion step fig 

demand driven technique take advantage ssa representation input program 
algorithms ssa oe placement linear time complexity place phi sg 
adapt algorithm cfr easier understand implement 
lemma sufficiency phi insertion basic block expression phi inserted expression partially anticipated entry exactly evaluation expression counting evaluation reach entry proof suppose different evaluations phi oe phi oe phi exit hypothetical temporary program phi insertion expression reach entry case dominate suppose loss generality dominate exists block dominates reached lies df may 
computation expression phi insertion step placed phi contradicting proposition reaches hand assignment operand expression values reaching oe correctness input ssa form 
phi insertion processed placed phi contradicting proposition reaches rename step rename step assigns ssa versions ssa form 
version numbering produce differs eventual ssa form temporary important properties 
occurrences identical versions identical values 
second control flow path includes different versions cross assignment operand expression phi apply ssa renaming algorithm cfr conduct preorder traversal dominator tree modification 
addition renaming stack variable program maintain renaming stack expression entries expression stacks popped back blocks define 
maintaining variable expression stacks allows decide efficiently occurrences expression version 
procedure phi insertion expression df phis empty set variable var phis fg occurrence program df phis df phis df variable occurrence defined oe index set var phis phi expression variable df phis df phis var phis insert phi df phis phi insertion procedure set var phis phi phi var phis var phis var phis operand phi defined oe set var phis phi set var phis algorithm phi insertion kinds occurrences expressions program expressions original program call real occurrences phi inserted phi insertion step phi operands regarded occurring exits predecessor nodes corresponding edges 
rename algorithm performs steps encountering occurrence expression phi assign new version 
check current version variable version top variable rename stack version corresponding variable occurrence top rename stack 
variable versions match assign version top stack 
variable versions match cases real occurrence assign new version phi operand assign special version phi operand denote value unavailable point 
push stack proceed 
fig 
shows dense ssa graph forms example renamed 
expression renaming technique takes advantage ssa representation program variables 
remaining steps ssapre algorithm rely fact phi placed partially anticipated dead phi ssa graph 
dead phi efficiently identified applying standard ssa dead store elimination algorithm cfr ssa graph formed renaming 
assume live phi represented ssa form lemma correctness version renaming occurrences assigned version rename expres 

phi 


oe phi 

oe phi 

exit 
dense ssa graph def arcs shown ds cba ds cba ds cba dense ssa graph sion value occurrences 
proof lemma follows directly fact rename step assigns version occurrences expression ssa versions expression operands match 
appeal single assignment property correctness ssa renaming algorithm variables cfr complete proof 
lemma versions capture redundancy occurrences assigned versions rename exactly holds ffl control flow path reach passing real non oe assignment operand expression meaning redundancy occurrences ffl path possibly empty case ssa graph def arcs implying redundancy exposed algorithm 
proof suppose control flow path pass assignment operand expression 
proof proceed induction number phi expression traversed encounters phi establishing basis induction 
hits phi phi defines apply induction hypothesis part corresponding operand phi 
step criterion required pre insert computation computation safe anticipated point insertion krs 
dense ssa graph constructed rename node represents real occurrence expression phi 
shown ssapre insertions necessary phi safety needs computed 
ssa graph safety sparsely computed backward propagation def edges 
phi safe control flow path phi expression evaluated program exit altered redefinition variables 
loops exit happen due cases path exit phi result version path exit phi result version operand phi safe 
case represents initialization backward propagation safety phi initially marked safe 
propagation case 
real occurrence expression blocks case propagation algorithm marks phi operand flag real path phi operand crosses real occurrence version expression 
convenient perform initialization case safe computation real flags dominator tree preorder pass ssa graph 
rename conducts pass include calculations rename step minimal overhead 
initially safe flags true real flags false 
rename assigns new version real occurrence expression encounters program exit examines occurrence top stack pushing current occurrence 
top stack phi occurrence rename clears phi safe flag version defines path current occurrence exit 
rename assigns version phi operand sets operand real flag real occurrence version appears top rename stack 
fig 
gives propagation algorithm 
lemma correctness safe phi marked safe expression fully anticipated phi 
proof note phi marked safe rename safe 
ssa renaming algorithm property definition dominates uses 
suppose phi appears top stack rename creates new version encounters program exit 
case program exit encountered phi obviously safe path dominator tree phi exit containing phi 
similarly rename assigns new version real occurrence expression operand different version current occurrence version phi 
exists path dominator tree phi current occurrence assignment minimality input program implies path phi current occurrence continuing program exit encounter assignment encountering evaluation expression 
expression fully anticipated phi 
observation phi safe flag gets cleared step safe path ssa def graph procedure expr phi program safe operand opnd reset opnd procedure reset real defined phi return phi defines safe return safe false operand opnd reset opnd reset algorithm unused version phi arc path crosses real expression value 
path appears recursion stack reset procedure time safe flag cleared 
need show phi safe marked 
fact straightforward property depth search propagation performed reset 
willbeavail step willbeavail step task predicting expression available phi result insertions pre 
finalize step insertions performed incoming edges corresponding phi operands expression available insertion phi avail predicate true 
willbeavail step consists forward propagation passes performed sequentially conduct simple reachability search ssa graph expression 
pass computes avail predicate phi initializing true phi 
begins boundary set phi expression available safe set insertions 
phi satisfy safe predicate valued operand 
avail predicate set false false value propagated nodes safe reachable def arcs ssa graph excluding arcs real true 
phi operands defined phi avail set way 
propagation step avail false phi safe placement computations expression available 
phi avail true designate range safe program areas insertion expression plus areas safe expression fully available original program 
second pass works region computed pass determine phi expression available insertions implicitly determines latest final insertion entry points region valued phi operands thought ssapre earliest insertion points 
may earliest insertion points krs ds bit vector schemes allow earliest insertion non merge blocks 
points 
second pass analogous computation predicate ds 
works propagating predicate initializes true avail true 
begins real occurrences expression program propagates false value forward points insertions postponed moved downward introducing unnecessary new redundancy 
second pass avail phi avail avail fig 
shows values safe ds avail cba avail program example phi convenience define predicate indicate phi operands perform insertions say insert holds phi operand hold ffl phi satisfies avail ffl operand real false operand operand defined phi satisfy avail 
fig 
gives willbeavail propagation algorithms 
krs term placement refer set points program particular expression value computed 
lemma correctness avail phi satisfies avail safe placement insertions expression available immediately phi 
proof phi satisfying avail 
satisfies safe result immediate safe insert computations expression operands 
safe satisfies avail note expression available unoptimized program path phi valued operand def arcs ssa graph 
phi satisfy avail 
algorithm reset avail flag recursion stack reset avail gives path bearing witness fact safe set insertions expression available lemma correctness avail phi satisfies willbeavail exists computationally optimal placement phi result available immediately phi 
proof set phi satisfying willbeavail exactly set avail phi reachable arcs ssa graph real operands avail phi 
path def ssa graph phi operand expr phi false 
prove induction length available computationally optimal placement 
safe fact avail means operands fully available unoptimized program 
trivially available computationally optimal placement making result available 
case safe contains arcs real operand operand procedure compute avail expr phi program safe avail operand reset avail compute avail procedure reset avail avail false expr phi operand opnd defined real opnd set phi operand safe avail reset avail reset avail procedure compute expr phi program avail expr phi program operand opnd opnd real opnd reset compute procedure reset false expr phi operand opnd defined reset reset procedure willbeavail compute avail compute willbeavail algorithm willbeavail fully available optimized program insertion redundant operand contradicting computational optimality 
safe operand redundant real occurrence unoptimized program computationally optimal placement eliminate redundancy 
way accomplish perform insertions expression fully available safe contains arc apply induction hypothesis phi defining operand corresponding final arc conclude operand available computationally optimal placement 
consequence computationally optimal placement available argument basis step previous paragraph 
lemma shows avail predicate computed willbeavail faithfully corresponds availability program insertions performed phi operands satisfying insert 
lemma correctness avail set insertions chosen ssapre set real occurrences expression available immediately phi phi satisfies avail 
proof establish direction simple induction proof showing path leading particular phi optimized program expression unavailable phi satisfy avail 
proposition expr phi path length ssa def graph passing phi avail arcs satisfy real insert avail 
follows directly fact insertion performed operand marked avail 
fact valued operand implies insertion required available 
see notice gamma implies operand corresponding final arc defined phi avail real occurrence expression path defining phi operand perform insertion operand satisfy avail 
establish direction suppose expr phi satisfy avail 
satisfy avail satisfies 
case available optimized program insertions performed ssapre safe 
case processed reset meaning reachable def arcs phi satisfying avail 
insertion required result available avail algorithm performs insertion 
finalize step finalize step plays role transforming ssa graph hypothetical temporary valid ssa form reflects insertions phi operand 
finalize step performs tasks ffl decides real occurrence expression computed spot reloaded temporary 
computed decides result saved temporary 
sets flags reload save represent pieces information 
ffl phi avail true insertions performed incoming edges correspond phi operands expression available 
ffl expression phi avail predicate true may oe phi avail part ssa form links avail phi fixed refer real inserted occurrences 
ffl extraneous phi removed 
finalize creates table avail def available definitions expression perform tasks 
indices table ssa versions hypothetical temporary avail def point defining occurrence hx real occurrence phi avail true 
finalize performs preorder traversal dominator tree program control flow graph 
course traversal visit defining occurrence value saved version temporary ty visits occurrences ty redundant computation replaced reload ty hx phi operand ty oe operand 
processing order finalize modeled standard ssa rename step cfr finalize require renaming stack ssa versions assigned 
course traversal finalize process occurrences follows 
phi avail false needs done 
example phi block running example 
see fig 
visiting hx time 
set avail def phi 

real occurrence avail def visiting hx time 
avail def set occurrence dominate current occurrence current occurrence definition hx 
example case block example 
cases update avail def current occurrence 
current occurrence hx set save flag occurrence pointed avail def reload flag current occurrence 

operand phi successor block avail phi false needs done 
operand satisfies insert operand phi block example insert computation exit current block 
avail holds operand satisfy insert set save flag occurrence pointed avail def update phi operand refer avail def operand phi block example 
full algorithm perform tasks fig 

removal extraneous phi ssa minimization necessary task far pre concerned 
extraneous phi take storage program representation may affect efficiency optimizations applied pre 
removing extraneous phi requires changing uses refer replacing versions 
ssa minimization implemented variant oe insertion step ssa construction cfr sg 
initially mark phi extraneous 
applying oe insertion algorithm find mark phi extraneous iterated dominance frontier set real assignments program real occurrences save bit set plus inserted computations 
pass extraneous phi determine replacing version 
extraneous phi defines version hx operand hy defined extraneous phi replacing version phi propagate replacing version uses replacing version phi known replacing version phi known replacing version replacing version phi propagate recursively uses phi 
straightforward recall phi operands considered occurring corresponding predecessor blocks 
procedure finalize visit block occurrence block save false reload false version phi avail avail def avail def avail def dominate avail def avail def real save avail def true reload true succ block block expr phi avail th operand satisfies insert insert exit block set th operand inserted occurrence version th operand avail def real save avail def true set th operand avail def children dt block finalize visit finalize visit procedure finalize version program avail def finalize visit root dt finalize algorithm finalize see method replaces extraneous phi non extraneous occurrences 
fig 
shows example program finalize step 
lemma correctness save reload point reload temporary contains value expression 
proof lemma follows directly finalize algorithm fact rename assigns versions traversing ssa graph dominator tree preorder 
particular finalize ensures directly reload dominated available definition 
live ranges different versions overlap reloaded occurrence refer available definition 
lemma optimality reload optimized program compute expression point fully available 


phi 


oe phi 

oe phi 

exit 
precise ssa graph def arcs shown ds cba ds cba ds cba program finalize proof straightforward check optimized program reloads expression value occurrence defined phi satisfying avail reloads expression value occurrence dominated real occurrence version 
need note avail accurately reflects availability optimized program lemma definition insert insert phi operands insertion required achieve availability 
step hypothetical temporary put valid ssa form remaining task update ssa program representation reflect results pre 
involves introducing real temporary purpose eliminating redundant computations 
task straightforward due fact valid ssa form 
ssa form subgraph ssa form defs including phi omitted 
step walks ssa graph real occurrence save true generates save result computation new version reload true replaces computation inserted occurrence saves value inserted computation new version phi generates corresponding oe fig 
shows example program step 
oe oe oe oe exit program theoretical results section derive main results ssapre lemmas 
theorem ssapre chooses safe placement computations path entry exit exactly values computed optimized program original program 
proof insertions take place points satisfying safe theorem follows directly lemma 
theorem ssapre generates reload correct expression value temporary real occurrence point expression value available point optimized program 
proof theorem follows fact reloads generated reloaded occurrence dominated avail phi version case appeal lemma availability expression reload point real occurrence version marked save finalize 
theorem ssapre generates save temporary real occurrence insertion point hold ffl expression value unavailable optimized program just point ffl expression value partially anticipated just point saved value 
proof theorem follows directly lemma fact finalize algorithm sets save flag real occurrence occurrence dominates version real occurrence phi operand 
case result immediate case need appeal fact expression partially anticipated phi remaining rename step 
theorem ssapre chooses computationally optimal placement safe placement result fewer computations path entry exit control flow graph 
proof need show redundancy remaining optimized program eliminated safe placement computations 
suppose control flow path optimized program leading computation expression computation expression assignment operand expression theorem expression value available just dominated real occurrence version lemma defined avail phi lemma 
version assignment expression operand definition version lie real occurrence avail phi phi avail 
phi satisfy operands reached safe 
safe set insertions available eliminating computation theorem ssapre chooses lifetime optimal placement specifically point just insertion ssapre denotes computationally optimal placement expression fully available proof theorem direct consequence lemma theorem 
theorem ssapre produces minimal ssa form generated temporary 
proof minimality result follows directly correctness dominance frontier oe insertion algorithm 
phi remaining finalize justified iterated dominance frontier real inserted occurrence saved temporary 
practical implementation ssapre sparse algorithm implementation reduce maximum storage needed optimize expressions program finishing expression moving 
scheme different lexically identical expressions need worked ssapre maintained worklist 
expressions program represented tree form exploit nesting relationship expression trees reduce overhead optimization large expressions 
efficient algorithm performing rename step ssapre 
section give brief description implementation techniques 
worklist driven pre worklist driven pre add initial pass scans entire program creates worklist expressions program need worked ssapre 
element worklist represent occurrences program set occurrence nodes 
occurrence node provides information pinpoint location occurrence program 
collect occurrences pass needs look entire program 
steps ssapre operate expression occurrence nodes 
intermediate storage needed expression reclaimed working 
collect occurrences enters order expressions worklist 
order expressions contain operator 
example expression gamma order expression entered worklist gamma initially entered worklist 
ssapre worked redundant occurrence replaced temporary pre changes gamma gamma step enter new order expression gamma new member worklist 
redundant occurrences gamma redundancies gamma replaced gamma processed 
expression gamma yield gamma worked redundant implying gamma redundancy skipped ssapre 
approach deals cleanly interaction optimizations nested expressions gains efficiency ignoring higher order expressions exhibit redundancy 
strategy hard implement bit vector pre typically works expressions program simultaneously order take advantage parallelism inherent bit vector operations 
manipulating sparse representation expression steps algorithm need visit occurrence nodes order corresponding preorder traversal dominator tree control flow graph 
purpose maintain occurrence nodes expression order preorder traversal dominator tree 
mentioned section kinds occurrences 
collect occurrences creates real occurrence nodes 
phi insertion step inserts new occurrence nodes represent phi phi operands 
pre need fourth kind occurrence nodes indicate reach program exits rename step 
exit occurrence nodes represented just shared expressions 
fig 
flow chart ssapre implementation 
delayed renaming rename algorithm described section maintains version stacks variables program addition version stacks expressions 
apart additional storage updating variable stacks requires keeping track values variables change may incur significant overhead 
algorithm line sparseness sparse algorithm time spent optimizing expression affected number times variables redefined 
worklist driven implementation ssapre longer pass entire program rename step imply passing entire program expression program 
solution higher order expressions redundancies approach secondary effect converting expression tree essentially triplet form 
input program collect occurrences initial worklist expr 
phi insertion rename dense ssa graph willbeavail finalize precise ssa graph update add new exprs worklist 
output program ssapre implementation flow chart problems efficient algorithm renaming called delayed renaming 
recall purpose variable stacks rename step enable determine value available expression longer current checking versions variables current versions 
real occurrence expression rely variable stacks current versions variables represented expression 
need variable stacks renaming phi operands 
implement delayed renaming rename step replaced separate passes 
pass rename rename variable stack 
phi operand optimistically assumes version version top expression stack 
perform occurrence nodes expression 
rename computes initial version ssa graph optimistic entirely correct 
correct renaming phi operands delayed second pass rename relies seeing real occurrence expression determine current versions variables 
seeing real occurrence implies earlier phi expression partially anticipated 
versions phi operands fixed phi 
rename works worklist built rename contains real occurrences defined phi 
versions variables merge block phi determines versions variables predecessor block presence absence oe variables merge block 
different versions assumed phi operand rename pass rename invalidates phi operand def current condition rule top occurrence identical stack version real real corresponding variables real phi operand versions phi real defs variables phi phi operand dominate phi table assigning versions delayed renaming resetting 
phi operand renamed rename correct 
phi operand defined phi added worklist process continue ssa graph 
example rename initially set second operand phi block fig 
rename resets 
table gives rules deciding occurrences assigned version absence variable stacks 
rules applied rename rules applied rename 
additional advantage delayed renaming allows determine phi live performing separate dead store elimination phase 
delayed renaming operands phi expression partially anticipated fixed 
remaining phi correspond dead phi marked deletion 
analysis formulation optimal code motion algorithm ssapre self contained gain additional insight comparing ssapre implementation lazy code motion 
regard phi insertion rename steps construct ssa graph hypothetical temporary corresponding initialization data flow information steps faster ssapre take full advantage ssa form input program 
safety corresponds attribute lazy code motion correlation part involves forward propagation data flow information direct 
shown algorithm yields results lazy code motion quite plausible forward propagation parts ssapre implementation lazy code motion proven essentially equivalent 
analysis propagates respect control flow graph ssapre propagates respect sparse ssa graph propagation ssapre take fewer steps 
ssa graph hypothetical temporary allows ssapre easily maintain generated temporary ssa form 
complexities various steps ssapre easily established 
assuming implementation described section rename willbeavail finalize steps linear respect sum number nodes edges ssa graph 
phi insertion step omega gamma insertion domination frontiers explained section linear time ssa oe placement algorithms lower 
second kind phi insertion due variable oe linear demand driven algorithm 
program size ssapre total time number edges nodes control flow graph respectively 
pleasing ssapre replaces solution data flow equations initialization local data flow attributes bit vector pre 
measurements implemented ssapre global optimizer silicon graphics compilers 
optimizer uses variant ssa called internal program representation ccl 
optimizer bit vector morel renvoise algorithm cho perform pre uses known ssa algorithms optimizations 
release compiler re implemented pre phase ssapre incorporating techniques described section 
section compare performance differences specint specfp benchmark suites 
terms optimization results measured running time benchmarks differences implementations pre noticeable 
interested comparing optimization efficiencies sparse approach bit vector approach 
implementations pre start ssa representation program 
bit vector pre starts determining local attributes setting bit vectors data flow analyses 
bit vectors represented arrays bit words operations efficient 
bit vector pre update ssa representation program encodes effects pre bit vector form ready emit output program 
timing bit vector pre includes local attributes phase solution time pre data flow equations 
correspondingly omit step ssapre timing include pass ssapre steps 
table gives timing results measured mhz silicon graphics power challenge 
benchmarks compiled optimization level invoke procedure inlining 
measurements table show widely different results various benchmarks 
specint benchmarks ssapre ranges faster perl slower go 
specfp benchmarks ssapre usually slower times case mgrid 
examining sizes characteristics benchmark procedures detail characterize measurement results situations ssapre implementation superior bitvector implementation 
see efficiency sparse implementation stands mainly large procedures 
small procedures sparse graph simpler control flow graph harder beat performance bit vectors process expressions time 
advantage sparse implementations increases procedure size 
large procedures expressions appear procedure sparse representations smaller compared control flow graph 
despite strong bias bit vector pre faster set measurements think ssapre promising 
time complexity collecting local attributes omega gamma 
number techniques contribute speeding bit vector data flow analysis little promise overcoming cubic complexity local attribute collection bit vector approach 
data flow specint benchmarks go ksim gcc compress li ijpeg perl vortex bit vector pre ssapre ratio specfp benchmarks tomcatv swim su cor hydro mgrid applu turb apsi fpppp wave bit vector pre ssapre ratio table time msec 
spent partial redundancy elimination compiling specint specfp analysis sped time spent collecting local attributes come dominate bit vector pre spends time local attributes collection phase optimizing benchmarks 
cubic complexity optimization efficiency issue large procedures 
trend inlining compilation large procedures commonplace efficiency advantages sparse implementation obvious 
done tuning implementation ssapre 
characterization common sizes forms ssa graphs hypothetical temporary expect improve implementation parts algorithm speed ssapre processing 
investigation ssapre wide compile time performance differences relative bit vector pre may offer insights lead efficient implementation 
ssapre algorithm performs pre full advantage ssa form input program operation 
incorporates advantages shared ssa optimization techniques separate phase collect local attributes data flow analysis involving bit vectors sparse representation sparse computation global attributes unified handling optimization global local forms 
actual implementation working expression time lower maximum storage requirement needed optimize expressions program exploit nesting relationship expression trees speed optimization large expressions 
ssapre enables pre seamlessly integrated global optimizer uses ssa internal representation 
ssa form updated optimization progresses optimizations re invoked needed incurring cost repeatedly rebuilding ssa 
engineering point view ssapre permits cohesive software implementation making ssa sparseness theme optimizer 
previous uses ssa directed problems related variables 
ssapre represents ssa solve data flow problems related expressions operations program 
shows data flow problems expressions modeled ssa form introducing hypothetical temporaries store values expressions 
approach opens new ways solve data flow problems formulating solution terms ssa graph hypothetical temporary 
candidates new approach code hoisting elimination load store redundancies cho krs 
intend pursue near 
ssapre approach incorporate techniques developed context classical pre integration strength reduction pre optimization phase cho krs 
currently working prototype ssapre includes strength reduction linear function test replacement 
processing expressions time allows possibilities ssapre customizing handling different types expressions 
example suppress pre expressions branch conditions branch instructions evaluate conditions extra cost 
move selected loop invariant operations loops points safe raise exceptions 
ssapre works bottom respect expression tree expression tree optimization opportunity original form 
possibility represents different approach addressing code shape issue pre discussed bc 
intend report interesting results publications 
authors ash ron price ross support compilers 
peter dahl mark contributed described 
lastly conference referees comments helped improve 
alpern wegman zadeck 
detecting equality values programs 
conference record fifteenth acm symposium principles programming languages pages january 
bc briggs cooper 
effective partial redundancy elimination 
proceedings acm sigplan conference programming language design implementation pages june 
ccf choi cytron ferrante 
automatic construction sparse data flow evaluation graphs 
conference record eighteenth acm symposium principles programming languages pages january 
ccl chow chan liu lo 
effective representation aliases indirect memory operations ssa form 
proceedings sixth international conference compiler construction pages april 
cfr cytron ferrante rosen wegman zadeck 
efficiently computing static single assignment form control dependence graph 
acm trans 
programming languages systems october 
chow killian weber 
engineering risc compiler 
proceedings ieee compcon pages march 
cho chow 
portable machine independent global optimizer design measurements 
technical report phd thesis computer systems laboratory stanford university december 
cho chow 
minimizing register usage penalty procedure calls 
proceedings acm sigplan conference programming language design implementation pages june 
cli click 
global code motion global value numbering 
proceedings acm sigplan conference programming language design implementation pages june 
cs cooper simpson 
scc value numbering 
technical report tr dept computer science rice university october 
cs cooper simpson 
value driven code motion 
technical report tr dept computer science rice university october 
css choi sarkar schonberg 
incremental computation static single assignment form 
proceedings sixth international conference compiler construction pages april 
dhamdhere 
new algorithm composite hoisting strength reduction optimization corrigendum 
journal computer mathematics 
dhamdhere rosen zadeck 
analyze large programs efficiently 
proceedings acm sigplan conference programming language design implementation pages june 
ds drechsler 
variation knoop steffen lazy code motion 
sigplan notices may 
gsw wolfe 
induction variables detecting classifying sequences demand driven ssa form 
acm trans 
programming languages systems january 
wolfe 
chain approach live variables 
technical report cse oregon graduate institute april 
joh johnson 
efficient program analysis dependence flow graphs 
technical report phd thesis dept computer science cornell university august 
johnson pearson pingali 
program structure tree computing control regions linear time 
proceedings acm sigplan conference programming language design implementation pages june 
krs knoop steffen 
lazy code motion 
proceedings acm sigplan conference programming language design implementation pages june 
krs knoop steffen 
lazy strength reduction 
journal programming languages march 
krs knoop steffen 
optimal code motion theory practice 
acm trans 
programming languages systems october 
krs knoop steffen 
partial dead code elimination 
proceedings acm sigplan conference programming language design implementation pages june 
llc liu lo chow 
loop induction variable canonicalization parallelizing compilers 
proceedings fourth international conference parallel architectures compilation techniques pages october 
morel renvoise 
global optimization partial redundancies 
comm 
acm february 
rosen wegman zadeck 
global value numbers redundant computations 
conference record fifteenth acm symposium principles programming languages pages january 
sg sreedhar gao 
linear time algorithm placing oe nodes 
conference record eighteenth acm symposium principles programming languages pages january 
schwarz landwehr 
optimizer ada design experiences results 
proceedings acm sigplan conference programming language design implementation pages june 
wol wolfe 
high performance compilers parallel computing 
addison wesley 
wz wegman zadeck 
constant propagation conditional branches 
acm trans 
programming languages systems april 
