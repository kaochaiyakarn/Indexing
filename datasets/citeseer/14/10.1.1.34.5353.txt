multi stage programming theory applications walid taha computer science engineering kuwait university 
dissertation submitted faculty oregon graduate institute science technology partial ful llment requirements degree doctor philosophy computer science engineering november copyright walid taha rights reserved ii dissertation multi stage programming theory applications walid taha examined approved examination committee tim sheard associate professor thesis research adviser james hook associate professor john launchbury associate professor david maier professor neil jones professor university copenhagen eugenio moggi professor university genova iii dedication mohamed hanan hamid 
iv verse new pride far variation quick change 
time glance aside new methods compounds strange 
write keep invention noted weed word tell name showing birth proceed 
know sweet love write love argument best dressing old words new spending spent sun daily new old love telling told 
shakespeare creativity energy enthusiasm prof tim sheard advisor tremendous source support half years graduate studies 
guidance support reason am completing dissertation today 
arabic proverb says companions chosen route 
easy school want go half way world 
despite say excellent stay ogi 
memorable times am indebted davide veronica byron cook scott daniels anita phil ashish brian hansen paul mary jon inouye je lewis john julie mathews emir matt sa ell indian ma large bennett vance karen ward lisa walton wei wei wonderful friends 
emails intermittent visits tamer abdel sarah miller kelly provided lots portland clouds tried protect 
library job responding continual requests inter library loans especially came closer graduation wanted tie 
special goes mary support continual interest native culture language 
am grateful williams patience helping prepare bibliography dissertation 
systems support sta cse accommodating demands years ogi 
especially marion helping quickly recover endless especially time deleted chapter dissertation 
iwould administrative sta ogi general particular 
kelly atkinson fisher continually done keep happy ogi away ogi business trips arranged care 
vi credits personal contribution fortune nding people wanted thesis committee 
thesis committee played active role development 
neil jones careful reading thesis proposal bringing needed fresh insights various formulations metaml semantics 
neil pointed amazing works quine 
eugenio moggi careful reading dissertation suggestions improving technical presentation 
am especially grateful eugenio critical doubtful possibility relating reduction big step semantics 
long started working thesis david maier class automata helped regain courage explore theoretical aspects programming languages 
writing dissertation david preempted attempts english language 
james hook classes semantics ered challenge evidenced dissertation eventually decided take 
numerous illuminating discussions james hook software engineering theoretical computer science signi cant uence 
john launchbury classes category theory formal software development emphasis having students proofs reason developed topics 
substantial energy barrier involved understanding topics john magician comes helping people understand 
am especially indebted james hook john launchbury questions posed years dissertation hope satisfactory answers dissertation 
iwould lois delcambre dick kieburtz addition serving thesis proposal committee 
conducting research dissertation preparation received substantial technical help number people 
idea manually staged pro grams metaml original implementation primarily due sheard 
cross stage persistence gensym renaming free variable sheard original metaml imple mentation 
multi stage programming explicit annotations sheard conception 
just gave things names went study formally 
rowan davies gave concrete ex ample limitations original type system metaml 
el benaissa guided doing strip lemma con uence proofs early version reduction semantics 
earlier version rst type system metaml joint 
great pleasure working eugenio moggi 
eugenio proposed simpli cations original type system played key role developing category interpreting metaml vii extensions 
developed interpretation metaml model jointly 
eugenio proposed study language combined logical modalities previously explored davies pfenning lead framework importance closedness explained clearly 
fruitful discussions turbak observational equivalence proofs plotkin call name call value lambda calculus 
hongwei xi pointed takahashi parallel reduction 
useful discussions hongwei details standardization proofs 
discussions eugenio moggi greatly sharpened presentation results soundness metaml reduction semantics 
research metaml bene ted valuable inputs don batory koen claessen olivier danvy rowan davies robert gluck sam kamin peter lee erik meijer ming nielson dino oliva frank pfenning amr sabry mark shields yannis smaragdakis carolyn talcott phil wadler members 
people kind read parts dissertation gave feedback improved presentation sharpened thought iwould lennart augustsson byron cook leo fegaras mark jones alex abdel hamid taha eelco visser 
mistakes results dissertation responsibility 
parts dissertation build works author collaborators previously published :10.1.1.39.7201:10.1.1.17.4285
funding financial support grateful oregon graduate institute technology paci software research institute generously supporting doctoral studies covering expenses related attending numerous workshops conferences summer schools 
provided national science foundation nsf type safe program generators award iri 
tuition provided air force material command phase ii phase iii contracts respectively 
iwould university copenhagen lucent technologies uni versity genova supporting di erent occasions 
university copenhagen diku provided funding region analysis school week research visit copenhagen 
lucent technologies bell laboratories supported enjoyable summer internship provided funding attendance region analysis school 
university genova disi provided funding month research visit genova 
viii table contents program generation meta programming 
meta programming optimization 
partial evaluation multi level languages 
multi stage programming explicit annotations 
thesis contributions 
organization reading plans 
practice multi stage programming metaml staging metaml conceptual framework 
metaml programming language 
pragmatics variables levels 
staging list membership function 
staging power function 
back forth useful functions code types 
staging inner product stage example 
staging simple term rewriting implementation term rewriting 
single stage implementation 
attempt staging 
second attempt 
ii theory multi stage programming dowe implement metaml 
basic semantic concerns known concerns 
simple approach implementing functional language 
extending simple implementation staging annotations 
new concerns 
covers plausible solution hidden free variables problem 
concerns 
ix big step semantics type systems closedness big step semantics cbv cbn 
big step semantics cbv 
basic type system metaml 
type safety 
big step semantics cbn 
limitation basic type system re integration 
bn language 
adding closedness 
re ning types 
staging power function revisited 
re ned method intuitively appealing 
reduction semantics reduction semantics cbn cbv 
extending reduction semantics intensional analysis con icts raw metaml terms level annotated metaml terms expression families 
escapes con ict annotated metaml terms 
substitution con icts level annotated terms 
reduction semantics cbn con uence soundness cbn reductions cbn big steps iii appraisal recommendations discussion related works 
part practice multi stage programming 
part ii theory multi stage programming 
history quotation review 
summary results appraisal results open problems promising research directions calculus level annotations language bibliography biographical note multi stage programming theory applications walid taha supervising professor tim sheard metaml statically typed functional programming language special support pro gram generation 
addition providing standard features contemporary programming languages standard ml metaml provides staging annotations 
staging notations allow construction combination execution object programs 
thesis metaml staging annotations provide useful theoretically sound basis building program generators 
dissertation reports study metaml staging constructs implementation formal semantics 
results include extended example metaml allows produce cient programs explanation implementing constructs traditional ways challenging formulations metaml semantics type system metaml proposal extending metaml type construct closedness 
dissertation number previous publications author including metaml type systems big step semantics 
presentation new 
proposed solution implementation problem reduction semantics metaml staging constructs new 
xi chapter thought corrupts language language corrupt thought 
politics english language george program generation powerful pervasive technique development software 
improve code reuse product reliability maintainability performance resource utilization developer productivity 
despite success program generation little special support writing generators high level programming languages java standard ml sml haskell 
host fundamental problems inherent program generation addressed ectively programming language designed speci cally support writing program generators 
metaml novel example meta programming language 
dissertation shows metaml concise expressive meta programming language solid formal foundation 
chapter begins explaining need special language constructs support program generation meta programming role metaml context 
outline scope dissertation basic classi cation meta programming distinguishes call multi stage programming kinds meta programming 
relate multi stage programming partial evaluation multi level languages state thesis preview organization dissertation 
dissertation refer primarily 
readers encouraged include discretion 
program generation meta programming meta programs programs manipulate programs 
object programs programs ma programs 
program generators meta programs produce object programs nal result 
metaml general purpose programming language designed object programs manipulated concise type safe manner 
notion type safety metaml strong meta program guaranteed free run time errors object programs 
furthermore metaml meta programming constructs concise expressive facilitates powerful method developing meta programs call multi stage programming 
metaml provides user constructs building combining executing object programs statically typed language run time environment 
bene ts metaml illustrated contrasting meta programming metaml meta programming mainstream general purpose language 
particular metaml constitutes clear improvement popular general purpose language qualitative dimensions meta programming language design 
support syntactic correctness conciseness specifying object programs 
support type correctness object programs 
cient combination object programs 
semantic correctness object programs 
support staging correctness 
addition metaml enjoys desirable re ective properties 
rest section elaborate design dimensions metaml lies design space 
syntactic correctness conciseness general purpose language fragments object program typically encoded strings datatypes 
string encoding represent code fragment simply 
constructing combining fragments represented strings done concisely deconstructing quite verbose 
seriously automatically veri able guarantee programs constructed syntactically correct 
example static type string clearly imply string represents syntactically correct program 
datatype encoding address syntactic correctness problem 
loss generality consider sml typical general purpose language 
datatype represent object programs de ned sml follows datatype exp variable string apply exp exp tuple exp list function string exp datatype declaration implements set representations object programs de ned bnf rule exp exp exp jx exp drawn set identi ers 
datatype set identi ers implemented set sml strings 
datatype encoding essentially called syntax parse trees 
encoding fragment sml datatype apply variable tuple variable variable 
datatype encoding immediate bene correct typing meta program ensures correct syntax object programs 
sml supports pattern matching datatypes deconstructing programs easier string representation 
constructing programs verbose 
contrast metaml provides construct called brackets allows specify code fragment read 
encoding combines simplicity conciseness string encoding strength datatype encoding bracketed expression accepted parser metaml long contained brackets correct syntax 
words metaml correct syntax meta program ensures correct syntax object programs 
type correctness syntax errors avoided datatype representation protection constructing ill formed programs contain type errors case fragment 
particular datatype encoding object programs represented type exp provide information type object program represented 
string encoding su ers problem 
metaml takes advantage simple type theoretic device parametric type constructor 
common example parametric type constructor sml list allows lists elements di erent types int list char list respectively :10.1.1.22.1290
metaml parametric type code type note type constructor lists metaml code type constructor declared datatype sml 
expand point section 
read code int xi ai 
show dissertation metaml correct typing meta program ensures correct typing object programs 
cient combination operational control constructing representation object program possible identify instances part program constructed performed immediately 
example consider meta program hfn fn xi 
meta program evaluates quoted string 
note contains object level application depend unknown information 
modify meta program slightly application done object program constructed object program executed 
modi cation accomplished metaml construct called escape allows incorporate code fragment context bigger code fragment 
improved meta program hfn fn hxi improved meta program evaluated useful done 
evaluation term proceeds follows hfn hxi hxi ii 
application performed 
hfn ii 
spliced context 
hfn 
spliced context 
presence recursion meta language escapes allow perform substantial computations constructing nal result yielding cient object programs 
escaping done string datatype encodings easily long object program meta program case escaping gets involved 
semantic correctness string datatype encodings ensuring name clashes inadvertent variable captures responsibility meta programmer 
example consider writing simple program transformation takes object level arithmetic expression returns object level function adds arithmetic expression arguments 
example object program get object program fn 
similarly get fn 
implement program transformation function apply variable tuple variable 
implementation probably awed 
particular get fn 
result expected assumed just dummy variable appear argument tot 
case say inadvertently captured 
see dissertation inadvertent capture especially subtle problem presence recursion 
intended function de ned metaml hfn ei 
de nition concise simpler semantics captured result splicing run time system ensures occurrences expected static scoping semantics 
inadvertent capture avoided metaml language completely statically scoped respect object level variables 
way naming issues arise code generation automatically managed metaml run time system 
staging correctness string datatype encodings care taken ensure meta program tries variable belonging object programs 
example generate program uses local variable wewould ensure generator attempt variable bound run time generated program 
addressing problems de ne notion level 
level term number surrounding brackets number surrounding escapes 
example xi correct staging point view variable bound level attempt level 
intuitively means trying available 
staging correctness subtle problem traditional setting object language meta language 
particular accidental reason prevents staging correctness problem manifesting level language construct executing code 
consider string datatype encodings study encoding metaml xi 
encodings yield untypable expressions 
fn fragment typed generally speaking variable meta language considered unknown identi er 

function 
fragment typed precisely reason 
real problem term incorrect staging hidden coincidental fact encodings untypable 
encodings show typed terms correctly staged 
staging correctness manifest encodings describing multi level terms xii 
encodings term typed 
fn perfectly valid string 

bracket function escape var perfectly valid exp extend exp datatype brackets escapes datatype exp variable string apply exp exp tuple exp list function string exp bracket exp escape exp staging correctness problem evident time object program constructed evident object program executed 
executing program get stuck trying construct encoding untypable xi 
staging correctness problem especially subtle allow execution code executing code involves changing level terms run time 
example get level dropped 
sheard postulated ensuring staging correctness responsibilities metaml type system 
dissertation presents type systems metaml typed metaml programs correctly staged 
re ection re ection de ned presence construct language allows execution object programs ability language represent meta programs object programs 
de nitions properties formalized interpreted positive qualities 
unfortunate name di erent properties important right 
metaml enjoys instances re ective properties qualitatively rst kind re ection suggests meta language expressive object language 
kind re ection realized metaml incorporating run construct execute object programs 
rei cation de ned mapping value representation value available metaml 
metaml program returns iii valid multi level program 
tively second kind re ection suggests object language expressive meta language 
kind re ection realized metaml allowing object program meta program 
summarize section metaml designed solve host fundamental problems en countered writing program generators freeing generator developers having continually re invent solutions problems 
meta programming optimization meta programming overcome limitations existing programming language 
limitations performance expressivity problems 
focus dissertation semantic basis improving performance 
broad distinction ways improving performance meta programming translation staging 
touch translation focus staging aspect meta programming 
section explain di erence translation staging 
meta programming translation re mapping machines machines realized software hardware vary speed resource usage 
possible reduce cost executing program re mapping machine 
hardware machines faster space cient software ones re mappings commonly involve producing machine byte code 
call technique translation distinguish staging discussed subsection 
translation integral part practical compilation programming languages typically performed back compiler 
translation involves inspecting constructing code 
metaml implementations support experimental constructs inspecting code focus dissertation 
study various forms run construct allow meta programmer exploit full power underlying machine 
distinction run generalized code inspection subtle profound implications semantics see section type system see section multi stage programming language 
meta programming staging goal staging improve program priori information 
name suggests staging program transformation involves reorganizing program execution stages 
concept stage arises naturally wide variety situations 
compilation program execution involves distinct stages compile time run time 
generated program execu tion involves generation time compile time run time 
example consider yacc parser generator rst reads grammar generates code second generated program compiled third user runs compiled program 
compilation high level program generation reduce cost program execution 
staging provides tool improve performance high level programs 
cost models staged computation cost models absolute generally dictated surrounding environment algorithm program system deployed 
staging allows take advantage features inputs program cost model improve performance 
particular staging may optimization model may 
important classes cost models staging bene cial cost total cost stages inputs 
model applies example implementations programming languages 
cost simple compilation followed exe cution usually lower cost interpretation 
example program executed usually contains loops typically incur large overhead interpreted implementation 
cost weighted average cost stages 
weights re ect relative frequency result stage reused 
model useful applications symbolic computation 
solving problem symbolically graphing solution points cheaper numerically solving problem times 
cost model symbolic approach worthwhile times expensive direct numerical 
symbolic computation form staged computation free variables values available stage 
cost cost stage 
cost model just practical approximation previous model relative frequency executing stage larger previous stages 
illustrate consider embedded system function may implemented large look table 
cost constructing table relevant 
cost computing function run time relevant 
observation applies optimizing compilers may spend unusual amount time generate high performance computational library 
cost optimization relevant users libraries model commonly referenced literature described ample time arrival di erent inputs signi cant di erence frequency various inputs program change performance program matters arrival input 
wish emphasize non trivial performance gains achieved staging need translation 
metaml provides software developer programming language staging aspect computation expressed concise manner level syntax types 
way programmer need learn low level language continues enjoy performance improvements previously associated program generation 
furthermore translation employed implementation metaml translation exploited meta programmer run construct 
partial evaluation multi level languages today sophisticated automated staging systems partial evaluation systems 
partial evaluation optimizes program partial information program inputs 
jones introduced line partial evaluation show partial evaluation performed ciently 
line partial evaluator staged system 
binding time analysis bta annotates input program indicate subexpression computed partial evaluation time static run time dynamic 
intuitively subexpressions depend static inputs computed partial evaluation time 
second annotated pro gram specialized static inputs produce new specialized program 
metaml provides common language illustrating workings line partial evaluation 
example construct representation program metaml 
consider simple metaml session 
type hfn fn yi mention century long stages needed evolve theory libraries 
metaml implementation prints val hfn fn yi hint int inti 
program fed partial evaluator rst go bta 
implementation level bta viewed source source transformation 
typically speci cation inputs static inputs dynamic 
simplicity assume interested programs take curried arguments rst static second dynamic 
metaml implementation provide function today principle add constant bta metaml type bta val bta fn 

ci 
cii 
perform bta apply constant source program val ap bta val ap hfn hfn lift hint hint yielding annotated program 
lift function secondary annotation takes ground value returns code fragment containing value 
reader view lift simply fn hxi 
step specialization 
involves running program input term val run ap val hfn yi hint inti yielding turn specialized program 
partial evaluation general line partial evaluation particular subject substantial body research 
understanding applications limitations staged computation grown literature 
word multi stage rst introduce jones 
illustration taken view output bta simply stage annotated program 
view rst bta expressed staging constructs study dissertation 
particular analysis requires intensional analysis addressed tangentially dissertation 
suggested works nielson nielson gomard jones level languages introduced 
level languages proposed intermediate representation line partial evaluation systems 
gluck generalized stage line partial evaluation multi level line partial evaluation introduced multi level languages 
ideas starting point dissertation 
example metaml essentially multi level language addition run 
view metaml precisely sense term multi stage multi stage language multi level language run 
multi stage programming explicit annotations software engineering point view novelty metaml admits appealing method developing meta programs 
multi stage program developed metaml follows 
single stage program developed implemented tested 

type single stage program annotated code type constructor re ect order inputs arrive 

organization data structures program studied ensure staged manner 
analysis may indicate need factoring parts program data structures 
step subtle critical step ective multi stage programming 
fortunately thoroughly investigated context partial evaluation known binding time engineering 

staging annotations introduced specify explicitly evaluation order various computations program 
staged program may tested ensure achieves desired performance 
method described called multi stage programming explicit annotations summarized slogan staged program conventional program staging annotations 
conciseness meta programs written metaml allows view meta programs simple variations conventional non meta programs 
variations minor orthogonal localized compared writing meta programs general purpose programming language task problems described section 
furthermore staging accurately re ected manifest interfaces types metaml programs 
program generation purpose staging widen scope applicability slogan restating program generator conventional program staging annotations 
thesis contributions thesis metaml designed language useful developing meta programs program generators 
break thesis main hypotheses 
metaml useful medium meta programming 

metaml placed standard formal foundation staging annotations viewed language constructs amenable formal techniques programming languages 

metaml particular multi level languages general improved design implementation learned building metaml formal tions 
dissertation presents contributions support hypotheses applications metaml metaml develop program generators 
im portant bene approach simplicity transparency 
furthermore metaml powerful pedagogical tool explaining workings partial evaluation systems 
time identi ed limitations approach identi ed ways addressed 
chapter detailed example proto typical experience 
basis multi stage programming formal semantics atype system metaml common framework uni es previous proposals formal foundations high level program generation run time code generation 
formalized semantics di erent styles big step style chapter reduction style chapter developed type system chapter metaml proved sound 
improving design implementation metaml process formalizing semantics uncovered variety subtleties aws early implemen tations metaml proposed remedies 
examples ndings chapter 
furthermore identi ed extensions language showed incorporated type safe manner 
particular proposal extending metaml type constructor closedness chapter 
organization reading plans dissertation organized parts 
part introduces metaml provides examples multi stage programming explicit annotations 
part ii presents formal semantics type system propose metaml 
part iii covers related works discussion results concludes dissertation 
detailed overview parts 
part chapter provides basic background needed developing multi stage programs metaml including intuitive semantics metaml staging annotations illustrated small examples 
design principles shaped metaml 
stress novelty signi cance principles called cross stage persistence cross stage safety 
simple stage examples multi stage programming explicit annotations 
exam ples illustrates positive role types development method 
stage example multi stage programming explicit annotations 
chapter presents extended example multi stage programming explicit annotations 
example shows developing staged programs challenging borrowing known techniques area partial evaluation yield worthwhile results 
consider simple term rewriting system rst attempt staging 
searching staged type system suggests direct attempt yield optimal result 
nd case 
second attempt technique exploited users line partial evaluation systems show approach yields satisfactory results 
part ii chapter summarizes problems addressed wish implement stage programming language metaml gives examples study formal semantics improved understanding metaml implementations 
problems examples provide motivation theoretical pursuit rest part ii 
reviewing implementation problems known metaml rst developed including basic scoping typing problems 
describe semantics simple implementation subset metaml call simple implementation prototypical implementations multi stage languages developed practice 
implementation allows point new set problems including new scoping subtleties typing issues need better understanding metaml programs considered equivalent 
chapter illustrative state art potentially veri able implementation multi stage programming languages 
chapter presents basic type system subset metaml proof soundness type system respect big step semantics 
argue extending type system big step semantics proposed extension metaml call bn chapter presents big step semantics 
big step semantics provides functional semantics 
partial function resembles interpreter language 
evaluation lambda explicit semantics realistic model multi stage compu tation 
capture free substitution semantics essence static scoping 
furthermore semantics illustrates metaml violates basic assumptions programming language semantics dealing closed terms 
atype safety result 
show basic type system guarantees run time safety augmented big step semantics 
closedness types 
explaining expressivity problem basic type system show problem remedied introducing special type closed values 
extension paves way new expressive form run construct 
chapter represents state art untyped semantics type systems multi stage programming languages 
letter stands metaml 
letters stand box respectively names logical modalities davies pfenning :10.1.1.16.4975
noted bn longer type closed code type closedness 
chapter presents reduction semantics subset metaml call chapter presents reduction semantics 
reduction semantics set directed rewrite rules 
intuitively rewrite rules capture notions reduction metaml 
subject reduction 
show reduction preserves typing type system 
con uence 
result indicator behavedness notions reduction 
states result possibly di erent sequences reduction reduced common term 
soundness 
result parts 
achieved big step semantics achieved reductions 
second applying reductions subterm program change termination behavior big step semantics 
essence result establishes equivalent formulations language 
chapter presents new results untyped semantics multi stage programming languages 
part iii chapter summarizes related positions contributions context programming languages partial evaluation program generation research 
chapter presents summary key developments multi level specialization languages 
brief review history quasi quotations revisiting quine original lisp back quote comma mechanism 
chapter ndings outline directions works conclude dis 
appendix presents remarks intermediate language develop fully dissertation intend study detail 
call reduction semantics avoid asserting priori equivalent big step semantics 
letter sequence rst attempt calculus called 
included appendix may applications implementation multi stage languages suitable purpose equational reasoning 
reading plans reader interested primarily practice writing program generators relevance metaml multi stage programming program generation may nd chapters useful 
reader interested understanding di culties implementing multi stage languages metaml extensions existing programming languages may nd chapter skipping section useful chapter serve complete 
reader interested primarily formal semantics multi level languages may nd chapter useful chapter section serve complete 
chapter primarily readers interested acquainted related ture multi stage languages 
chapter primarily readers interested summary ndings tation overview open problems 
part practice multi stage programming chapter metaml staging world stage men women merely players exits entrances man time plays parts 
jacques act scene shakespeare chapter introduces staging metaml 
metaml staging constructs explain staging fairly level useful improving performance 
explain key design choices metaml illustrate metaml utility staging known functions 
metaml conceptual framework formalism staging allow explain concept staging clearly 
essence staging altering program order evaluation order change cost execution 
metaml formalism staging provides staging annotations explain alterations 
delaying computation 
escape combining delayed computations 
run run executing delayed computation 
lift lift constructing delayed computation ground value 
just description metaml annotations explain reduce cost program staging 
staging reducing cost metaml call value cbv language cost executing program cbv call name cbn semantics reduced staging 
consider computation fn fn 
ignore fact part computation performed optimizing compiler program executed 
optimizing compilers constitute additional level complexity concerned moment 
consider cost model count number arithmetic operations performed 
choice simplicity 
cost model realistic situations arithmetic operations program stand place costly operations 
evaluating program cbv semantics proceeds follows cost step indicated op 
fn fn 
arith ops 

arith ops 

arith ops total cost ops 
evaluating computation cbn semantics proceeds essentially way 
total cost 
staging reduces cost cbv cbv setting stage computation follows fn lift 
evaluating staged computation cbv semantics proceeds follows 
fn lift 
arith op 
fn ii 
arith ops 
fn 
arith ops 
fn fn 
arith ops 
fn fn 
arith ops 

arith ops 

arith ops staged version costs op 
staging reduces cost cbn cbn setting stage computation follows fn fn lift evaluating staged computation cbn semantics proceeds follows 
fn fn lift 
arith ops 
fn fn 
arith ops 
fn fn 
arith ops 
fn fn 
arith ops 
fn fn 
arith ops 

arith ops 

arith ops cost op staging 
sense staging gives programmer control evaluation order manner exploited enhance performance 
having explained concept staging ready introduce metaml programming language 
metaml programming language metaml functional programming language special constructs staging programs 
addition features sml metaml provides special support multi stage programming staging annotations believe basis general purpose multi stage programming 
static type checking polymorphic type inference system 
metaml multi stage pro gram type checked begins executing ensuring safety computations stages 
feature metaml specially useful systems stages executed original programmer longer 
static scoping meta level object level variables 
metaml implements delayed computations syntax trees representing metaml pro grams 
metaml staging constructs implemented follows 
code fragment 
escape combines code fragments 
run run executes code fragment 
lift lift constructs code fragment ground value code fragment repre sents ground value 
section explain intuitive semantics constructs 
brackets brackets inserted expression delay execution 
metaml implements de layed expressions building representation source code 
source code representation way implementing delayed expressions simplest 
short interactive session illustrates behavior brackets metaml val result val result int val code val code 
percentage signs simply indicates free variable 
reader treat percentage signs white space signi cance explained section 
addition delaying computation brackets re ected type 
type declaration read code int 
code type constructor primary devise type system uses distinguishing delayed values values prevents user accidentally attempting unsafe operations 
escape escape allows combination smaller delayed values construct larger ones 
combination achieved splicing argument escape context surrounding brackets val code code code val code hint inti 
declaration binds code new delayed computation representing tuple arithmetic expressions 
escape combines delayed computations ciently sense combination subcomponents new computation performed new computation constructed executed 
subtle distinction crucial staging 
see examples come particular behavior escape big di erence run time performance delayed computation 
run run allows execution code fragment 
having run language important code constructed metaml constructs going outside language 
added expressivity run important practical theoretical points view 
practical point view having run statically typed language allows develop multi stage systems part program sure system free run time errors 
theoretical point view allows formalize problem safety multi stage systems address formal rigor 
run metaml illustrated simple example val code val code val result run code val result int 
lift lift allows inject values ground type type code 
metaml base types types containing arrows function types 
examples ground types int string bool int list val code lift val code 
brackets lift construct code lift delay argument 
lift rst evaluates argument constructs representation value val code lift val code 
lift implemented producing source level representation operand lift de ned functions arbitrary function general way computing source level representation function functions delayed brackets val result fn val result fn int int val code hresult val code result val result run code val result int 
rst declaration result bound function takes int returns int 
second declaration constructs piece code uses result delayed context 
notion level determining escaped expression performed requires notion level 
level term number surrounding brackets minus number surrounding escapes 
escapes metaml evaluated level 
metaml multi level language 
feature important allows multiple distinct stages execution 
example write expressions ii val hh ii type re ects number times enclosed integer expression delayed 
escapes object programs 
multi level expressions escapes val code hh code ii val code hh code ii 
escape performed expression evaluated brackets surrounding escape 
run doubly delayed value code follows type directed partial evaluation suggests practical ways deriving source level representations functions run time executables available run time su ciently instrumented 
sheard investigated type directed partial evaluation context metaml 
treatment subject scope 
val code run code val code hint inti 
run eliminates bracket lowering level escape escape performed 
pragmatics variables levels reasonable write program variable bound level 
hand completely justi able write terms 
formal treatment programming languages consider sqrt free variable bound level 
case sqrt bound level level 
hand wish allow terms xi dictates evaluated level bound level 
rst term example cross stage persistence desirable second term example violating cross stage safety undesirable 
cross stage persistence say variable cross stage persistent bound level higher level 
permitting usage variables means allowing programmer take full advantage primitives bindings available current stage reusing stages 
percentage sign printed display mechanism indicate avariable new constant 
example program val inh ai computes code ai 
percentage sign indicates cross stage persistent variables bound code local environment 
variable bound rst stage constant 
name printed provide hint user new constant originated 
evaluated stage return independently binding variable new context 
arbitrary values including functions injected piece code hygienic binding mechanism 
despite sense evaluation reduction preserve level 
properties established part formal treatment metaml part ii dissertation 
cross stage safety say variable violates cross stage safety bound level level 
violation occurs expression fn hfn annotations expression dictate computing rst stage value available second stage 
supporting cross stage persistence means type system metaml ensure typed programs won going wrong includes violation cross stage safety condition standard notions going wrong statically typed languages 
experience having type system screen programs signi cant aid developing stage program 
ready see metaml stage simple functions 
staging list membership function metaml programmer stage programs inserting proper annotations right places program 
programmer uses annotations modify default strict evaluation order program 
consider staging function takes list value searches list value 
writing single stage function member list bool fun member null false hd true member tl 
observed possible annotations staged version program signi cantly constrained type 
observation suggests strategy hand staging program sml type variables written unrestricted polymorphic variables type variables written polymorphic restricted equality types types elements tested equality 
function types prototypical example type elements tested equality 
equality type variables instantiated functions types example 
rst determine target type desired annotated program 
start studying type single stage function 
suppose list parameter available rst stage element sought isavailable 
natural target type staged function ai 
list 
type re ects fact rst argument result function late 
words second argument isavailable current time 
having chosen suitable target type annotating single stage program 
start expression working inwards sub expressions considered 
step try nd annotations correct type expression function type closer target type 
function realizes target type staged member function member ai 
list fun member null lift hd true member tl annotations explicitly dictated type 
annotated term lift hd type hd ensures hd performed rst stage 
selections head element list delayed generated code run stage brackets branches outermost expression ensure return value member code 
rst needs annotations return value precisely 
moving inwards second branch condition forces type parameter ai planned 
just rst branch outer statement inner statement return bool 
rst branch returns true annotations 
recursive call member escaped 
inserting escape implies recursion signi cantly recursive programs annotated fundamentally di erent ways types provide help regard 
expand point chapter 
performed rst stage exactly desired behavior 
result member recursively constructed piece code type type bool 
member hxi yields hfn true true true staging power function falsei :10.1.1.22.1290
computing powers real number classic example partial evaluation literature 
consider de nition exponentiation xx de nition compute expressions interestingly compute generate cient formula expressions asx exponent known 
underlined term expanded xx sequence expansions example symbolic computation computing free variables 
example staged computation doing useful stage distinct nal stage computation 
computation programmed metaml 
write single stage inputs known function fun exp int real real sqr exp div add staging annotations exp 
fun exp sqr exp div need stage function sqr real real 
exp pattern multiplying variable binding evident generated code 
exp generate code forx follows val exp hfn exp hxi val exp hfn val val val val val 
metaml performs optimization bindings term form replaced einf ing code returned system fact simpler val exp hfn val vald val 
re integrate specialized function run time system run val exp run exp real real 
new function need ciently having run language essential allowing programmer automatically generated function hand written function 
recursion performed rst stage 
eliminating function calls involved recursion yield performance improvement short lists 
longer lists size generated expression burden memory management system 
back forth useful functions code types staging programs interesting pair functions useful fun back hfn ai bi 
bi fun forth xi 
bi ai bi 
takes function constructs code fragment representing new function 
body new function result unfolding function argument new function 
function forth takes code fragment code fragment constructs code fragment representing application rst second 
computational patterns come course multi stage programmers 
similar construction stage member function ai 
list member hxi :10.1.1.22.1290:10.1.1.22.1290
experience annotating function ai bi requires annotations annotating 
bi easier think 
furthermore functional programmers convenient think code transformers functions code code representations functions code functions 
reasons lead avoid writing programs type need see generated code 
observations apply programs stages 
consider function back ai hh bii hh cii 
cii fun back hfn hfn ii 
function allows write program takes arguments produces turns stage function 
experience functions considerably fewer annotations easier reason 
expand point section 
staging inner product stage example function computing inner product vectors studied works execution usefully separated distinct stages 
rst stage knowing size vectors ers opportunity specialize inner product function size removing looping overhead body function 

second stage knowing rst vector ers opportunity specialization values vector 
inner product vector taken times vectors specialized removing overhead looking elements rst vector time 
knowing size rst vector exactly case computing multiplication matrices 
row rst matrix dot product row taken column second matrix 

third stage knowing second vector computation brought completion 
versions inner product function 
iprod staging anno tations second iprod levels annotations third iprod levels annotations constructed back function 
metaml quote relational operators greater possible confusion brackets 
iprod int vector vector int fun nth nth iprod iprod int fun iprod hfn hfn ifn lift nth lift nth lift lift iprod ii ii ii int fun lift nth lift nth lift lift ii ii fun iprod back 
predicted section version written back annotation 
importantly annotating version written back cumbersome 
obser vation somewhat subjective may bene metaml multi stage programming 
emphasize type inference mechanism interactive environment especially useful exploring di erent approaches annotation staging 
bene metaml providing way visualize multi stage computation essence running stage stage inspecting intermediate results 
testing iprod inputs immediately see results val iprod hfn hfn lift nth nth lift nth nth lift nth nth ii 
run returns function 
function applied vector builds piece code 
building process includes looking element rst vector splicing actual value lift operator 
lift especially useful wish inspect generated code val run inti hfn nth nth nth 
actual values rst array appear code access function nth appears applied second vector 
code take full advantage information known second stage 
example may wish eliminate multiplications 
multiplications optimized knowing value second operand 
write smarter function add vector index rst vector piece code representing second vector constructs piece code adds result multiplication code valued fourth argument 
add int 
int fun add nth lift ei lift nth lift ei 
specialized function build improved version function int fun nth wh ii nth fun back 
look result rst stage computation val hfn hfn add nth hd add nth hd add nth hd ii 
code linear size vector 
lined calls add exponential 
controlling code explosion side bene sharing provided cross stage persistent constants 
observe result second stage computation val run inti hfn nth nth 
multiplications contribute answer remain 
vector sparse sort optimization dramatic ects 
note stage function terms body function involve levels terms 
implicit increase number stages prototypical ex ample multi stage programs develop naturally composition stage programs lower number stages programs 
chapter staging simple term rewriting implementation world longer stage act act scene king henry iv shakespeare chapter extended example applying method multi stage programming explicit annotations 
starting single stage term rewriting function annotate derive stage function 
point limitations direct attempt stage function show re implementing function continuation passing style cps improves generated code substantially 
rewriting program cps example known partial evaluation literature binding time improvement 
term rewriting dershowitz de nes term rewriting system set directed rules 
rule left hand side right hand side 
rule may applied sub left hand side substitution rule applied wheres result applying substitution right hand side 
call modi edt say rewrites step tot choice rule apply non deterministically 
example rules monoid 


andz rules match term 
variable occurs left hand side rule occurrences match identical terms 
rules allow derivations 

sub rewritten underlined 
generally rules change life term rewriting system 
time basic form matching function simultaneous traversal term left hand side rule matched 
invariance rules normal lifetime rewriting system ers opportunity staging specialize matching rules rst stage eliminate overhead traversing left hand side rules 
see remove signi cant amount administrative computations involved constructing applying substitution expect staging signi cantly reduce cost rewriting term 
single stage implementation section implementation part simple term rewriting system 
implementation terms patterns terms patterns represented metaml type datatype term var string int int op term string term 
constructors type var int op corresponding variables integers ap plications binary operators 
represent terms ast eas val op op var var op var var val op op op var var var var 
represent rewrite rules ordered pairs terms 
example rules monoid represented val op var int var val op int var var val op var op var var op op var var var 
represent substitutions lists pairs strings terms 
example substitution represented val op var var var var 
matching succeed fail instance simple datatype return value matching datatype option 
option type constructor provides mechanism write functions succeed return value arbitrary type fail return avalue simply return value 
implementation matching focus function tries match candidate term left hand side rule 
assume separate helper functions take care applying function sub terms candidate term 
single stage implementation matching function follows fun match pat case just sigma case pat var case nd sigma int case just sigma just just sigma int op case op 
match match match function takes pattern pat substitution candidate term tries compute substitution instantiate pattern term 
match inspects 
means failure occurred previous match simply propagate failure returning 
case analysis pattern pat performed 
pattern variable substitution extended appropriately checking consistency new binding 
check consistency looking name environment sigma 
binding name simply extend environment 
binding name wish add need perform extension 
binding name di erent wish add fail 
pattern integer term integer value 
case original substitution returned 
pattern operator check term operator operation right left hand sides pattern term recursively matched possibly extending substitution 
cases match returns indicate failed 
match function type term string term list option term string term list option occurrences option type explained follows match returns substitution option fail match pattern term 
failure occurs places match returns 
second result call match gets fed back call match incoming outgoing substitutions exactly type 
threading substitution happens case op pattern 
match match 
matching right operand fail case match fail 
match passed invalid substitution outer case statement immediately returns correctly propagating failure matching 
helper functions match need helper functions fun nd nd bs just nd bs 
function takes variable name substitution returns term corresponding name 
option type dealing failure 
applying substitution performed function fun subst sigma pat case pat var case nd sigma just int int op op subst sigma subst sigma 
function takes substitution pattern applies substitution pattern 
function works recursively traversing pattern replacing variables corre sponding binding substitution 
applying rewrite rule performed function fun rewrite lhs rhs case match lhs just just sigma subst sigma rhs 
function takes rule term uses match try compute unifying substitution 
matching successful applies substitution subst 
returns term unchanged 
expect staging success staging qualitatively need quantitative bench marking 
appraisal achieved inspecting intermediate result staged computation comparing achieved hand programming specialized version desired program contextual information available 
example hand crafted version rewrite specialized ruler xis follows fun rewriter term case term op case int term term 
term term function takes term checks binary operation operation addition second argument integer returns rst argument 
checks fails returns term unchanged 
function pay interpretive overhead traversing pattern ect substitution operation computed advance 
rest chapter study far metaml take turning single stage program generator produces highly specialized code 
attempt staging defer time delays dangerous ends act scene king henry vi shakespeare section analyze type match function develop target type stage matching function match 
stage matching function 
inspect generated code contrast goal set section 
designing multi stage type decided consider candidate term available second stage 
choice means rst approximation target type staged function term string term list option string term list option knowledge algorithm know substitution returned match function contain sub terms term matched 
resulting substitution going partially static datatype 
particular get back list pairs rst element pair string second element known 
second approximation desired type term string term list option list option going back algorithm recall thread substitution recursive calls match function case matching binary operations 
threading means staged implementation match result term match type string list option 
change type term forces change type substitution passed staged match function term list option list option problem type looks promising 
unfortunately subtlety matching algorithm forces re ect delays staged type 
say unfortunately having delays type usually suggests able stage function ectively 
problem algorithm option part return value depends testing equality terms substitutions 
particular testing consistency new binding existing substitution performed equating terms 
test carried statement just sigma 
condition statement delayed result statement considered delayed 
reason know branch pursue information condition available 
return type staged match function 
left target type term string term list string term list type indicates pattern inspected rst stage result specialized function run second stage 
subsection see take advantage information multi stage program 
stage implementation similar process described staging list membership function section arrive stage version match fun match pat just sigma case pat var nd sigma int just sigma just just sigma int lift op op match match ht note erase annotations source match get source match 
need stage helper function rewrite fun rewrite lhs rhs match just sigma subst sigma 
ready inspect code generated function quality 
stage implementation rewrite function generate code specialized forr follows rewrite fn val hfn case case op case case just subst rhs termi 
int just just case nd just just just traversal pattern performed 
compared target code wrote hand nested case statements call subst test consistency substitution performed 
closer inspection generated code shows ought possible reduce nested case statements meaning preserving transformations 
outer case statements pushed inner ones able simplify values leaves inner statements 
particular point return ought tobe able simply return point return just ought able return result applying substitution subst rhs 
second attempt unusual rst attempt staging yield best results 
staging automated case bta common users ine partial evaluators restructure programs help bta yield better results 
just place binding time annotations manually exempt requirement 
metaml allows touch see experiment explicit annotations code produced helps better understand problem staging particular algorithm 
believe strength metaml mental model provides reasoning multi stage computation 
implementation matching continuation passing style possible approach improving generated code rewrite match continuation passing style cps 
technique quite useful partial evaluation systems 
intuitively continuation function speci es computation continue 
function written cps takes continuation argument applies results normally just return 
cps function calls cps function passes new continuation second function 
furthermore sequencing function calls involved function cps explicitly pass extend continuation necessary 
subtle change form algorithm gives extra degree freedom provides new opportunity better design multi stage type turn better multi stage program 
cps matching function takes continuation type string term list option 

infor mally read continuation consumer substitutions 
cps matching function de ned follows fun pat case just sigma case pat var case nd sigma int case just sigma just just sigma int op case 
op fn msig msig threading substitution case op patterns replaced call takes second call part continuation 
impor continuation explicitly placed branches expression opposed just expression 
minor variation signi cant ect achieved staging matching function 
function written cps provide initial continuation 
intuitively initial continuation nal step computation 
initial continuation simply identity function specifying computation nal result 
case function need interesting continuation application nal substitution right hand side rewrite rule 
pass continuation write new version rewrite follows fun lhs rhs fn lhs fn just rhs just 
continuation pass rst inspects nal result matching 
failure result returned unchanged 
substitution applied right hand side rewrite rule 
usual call passed empty substitution term 
re designing multi stage type type cps matching function string term list option 
string term list option term 
function polymorphic type constrains value returned con note read return type function type argument continuation rst occurrence type string term list option 
contrast rst attempt designing multi stage type matching function forces return delayed option type 
recall section di atype staged function caused statement tested equality oftwo terms 
test forced expression delayed 
dependencies changed 
unavailability condition statement longer matters 
explicit handle continuation freeze branches statement 
pursue possible ways computation continue 
pursuing continuations mean eliminating super uous just constructs 
example initial continuation passed case analysis result 
initial continuation eliminates constructs option type 
furthermore time extend continuation matching binary operators 
fn msig msig 
long match continues consume option constructors sigma new continuation consumer 
observation suggests delayed computations generated branches statement may free option constructors 
time eliminating constructors coincide eliminating complex nested case statements output rst attempt staging match function 
summary reason achieve type list option ai list option ai stage continuation passing style implementation adding staging annotations arrive stage function fun pat case just sigma case pat var case nd sigma int just sigma just hif just sigma int lift op op lift fn msig 
type substitutions change skeleton list rst projection binding variable names available rst stage 
rewrite substitution function take advantage information fun sigma pat case pat var case nd sigma just int hint lift op hop sigma lift sigma need annotate cps rewriting function fun lhs rhs hfn lhs fn hti rhs just hti stage continuation passing style implementation output cps rewrite function ruler follows val fn case op case int aj termi 
generated code compact free reducible nested case statements calls subst tests consistency substitution 
furthermore virtually identical idealized code rewriter section contains super uous redices really depend parameter variable code generated concise val hfn case op case termi 
op op op role metaml multi stage programming reader familiar type systems programming languages sml may appear designing type staged version sections black art 
described chapter designing multi stage type essentially binding time analysis bta performs automatically 
metaml provides pedagogical help removing magic bta 
provides formal semantic basis multi stage programs 
foundation needed example prove metaml staging sensitive type system type system ensures typed programs safe 

provides system executing multi stage programs 
example having type inference system interactive section provided implementation gives programmer automatic tool point problems described subsection 
programmer learning multi stage programming trial error 
interactive type system tell try unsafe 
experience feedback provided type system helped greatly developing right insights intuitions structure algorithms interested staging 
programmer gained necessary expertise uent staging programs type inference system automatically check programmer annotations ensure sound 
specialization term rewriting systems bondorf rst systematically study application partial evaluation term rewriting systems 
reader interested specialization term rewriting systems recommend consulting bondorf thesis 
part ii theory multi stage programming chapter implement metaml 
basic semantic concerns test bath sit moved nger bit frigid 
samson ogden nash previous chapters metaml staging multi stage programming explicit annotations cross stage persistence cross stage safety 
chapter explain basic challenges implementing typing multi stage programming language metaml 
break problems sets ones known early implementations metaml developed new ones recognized implementations 
chapter illustrative state art potentially veri able implementation multi stage programming languages 
known concerns explaining need renaming bound variables quoted expressions renaming necessary implementing static scoping 
explain retaining static scoping desirable point view design goals metaml 
syntax type system toy functional language explain type system changed accommodate extending toy language staging annotations 
scoping function name generating function gensym avoid accidental name capture multi level languages 
function associated back quote comma lisp introduced :10.1.1.49.7238
back quote comma mechanism early ancestor brackets escape see section various works studied explained need run time renaming bound variables 
follows brief explanation need renaming performed run time 
illustrate point introduce simple function called chapter 
need renaming multi level language object level bound variables re named 
consider function chapter hfn ei 
function takes expression returns new expression representing function takes argument adds follows val hfn result hfn fn yi 
rename bound variables constructing piece code run problem 
called local variable get result hfn fn xi 
term represents function di erent rst simply ignores rst argument returns result adding second argument 
consider dynamic capture names unsatisfactory wish maintain relatively simple relation multi level programs unannotated counterparts 
particular erase annotations get funt standard semantics cbv language confuse occurrences name declaration 
check fact implementation sml int 
renaming performed compile time consider examples function rename variables program executing 
renaming execution bound variables object terms repeatedly renamed run time 
illustrate point function call rst single stage version called second stage version called 
single stage function de ned follows nz ifn fn function takes integer arguments 
rst argument simply returns second argument 
recursive call subtracting rst argument adding rst argument second 
note local variable local name second argument fact inconsequential result signi cant analyze staged version nz ifn fn hx ni 
note renaming variable run time inconsequential variable 
renaming run time application evaluates fn fn fn occurrences name arithmetic expression refer argument innermost binding 
accidental capture innermost binder take place 
follow execution program closely nd occurrence associated di erent binding manner fn fn fn 
reader verify result evaluating code fragment closely related unannotated semantics function 
section show renaming performed implementation 
typing functional languages metaml functional programming languages inspired lambda calculus 
order developing semantics type system metaml focus minimal subset metaml studied extension lambda calculus 
follows introduce syntax type system lambda calculus extended include integers explain type judgement extended order able express notion staging 
language terms type system basic lambda calculus extended include integer constants syntax set expressions 
expressions integers set lambda abstractions free occurrences expression 
lambda abstraction introduces occur free called body lambda term 
type systems allow restrict set programs interested see 
example language interested programs apply integers expressions 
common restriction application allow terms function type applied 
types syntax intj 
productions stand integers function types respectively 
simple language includes type terms int int int int int 
int usually written simply int int int int int int 
build type system usually need notion type environment type assignment 
environments simply associate variable names types represented follows jx atype system language speci ed judgment 
intuitively type judgement associate term int mere syntax integers type term 
partial functions take argument type may return result type diverge 
terms contain free variables technically elements represent implement nite mappings names types 
implementation correct need additional assumption having variable occur environment 
free variables addressed considering closed terms 
particular typing judgements generally de ned induction structure expression wish assign atype 
case lambda abstraction judgement go lambda 
body lambda abstraction bound variable introduced lambda free 
give concrete example try see happens wish establish closed expression type int int empty environment 
type judgement involves environment simply associates free variables term single type 
type system precisely derivability typing judgment de ned induction structure follows var int int lam rule integers int says type int environments 
rule variables var says type environments wherex bound type rule lambda abstractions lam says abstraction arrow type environments long body abstraction shown type environment extended binding type rule application app says application type environments operator shown type argument language terms type system rst step extending language staging constructs adding brackets escape run syntax ej rune second step extending type system 
extending type system involves extending type terms include type term code bj 
jhi need extend type environments keep track level avariable bound 
represent environments need representation naturals jn slight abuse notation write drop lift rest treatment introduce unexpected complications 
app productions stand number respectively 
type environments typing jx able address issue cross stage safety system introduce level index typing judgment 
type judgment extended form andn 
judgement read type environment 
important note part judgement part type 
bj 
jhi jx note extended type assignments keep track level avariable bound 
level index judgement combined level annotations variables reject terms variable violates cross stage safety 
type judgment de ned induction structure follows nx var hei hi brk int int lam ne ne hi esc hi rune run rule integers int allows assign type int environment rule variables var allows assign type environment wherex associated type level equal ton 
rule lambda abstractions lam works essentially way lambda language 
noteworthy di erence associates extend environment 
lambda rule rule level bindings introduced environments essential ensuring cross stage safety 
warning proved rules sound 
soundness rules discussed section 
app rule application app essentially di erence type subexpressions expression 
rule brackets bra introduces code type time increments level subexpression ton 
change level index judgement ensures level index type system counting number surround brackets subexpression consistently 
rule escapes esc eliminates code type time decrements level subexpression ton 
change level index judgement ensures level index type system counting number surrounding escapes subexpression consistently 
note type system allow escapes occur level 
rule run run eliminates code type constraints level environment 
simple approach implementing functional language values elegant implementation toy functional language developed datatype containing functions see example 
element datatype represents value term toy functional language 
datatype containing functions declared sml follows datatype value vi int integer values vf value 
value function values 
datatype allows pass values corresponding interpretation functions 
identity fn 
function composition fn fn fn gx 
square fn 
factorial fn integer multiplication factorial functions 
values represented datatype value val id vf fn val compose vf fn vf vf fn vf vf fn val square vf fn vi vi val bang ifn fact vf fn vi vi fact 
example illustrates encoding allows take features meta language case sml embed value domain toy object language 
factorial example advantage features meta language recursion conditionals arithmetic operations introduce factorial object language 
expressions just implemented values datatype value datatype implement expressions language declared sml follows datatype exp ei int integers ea exp exp applications el string exp lambda abstractions ev string variables 
closed terms xand fn fn fn gx encoded datatype exp follows val id el ev val compose el el el ea ev ea ev ev 
closed terms syntax typed object language express functions square bang see expressed open terms su ciently rich environment 
environments job interpreter take terms compose produce values id compose respectively 
write concise interpreter ev having type exp env 
value aware proof statement 
negative results expressivity generally substantial challenge 
reader take statement folklore 
env 
environment associates value free variable expression evaluated 
simplicity take env simply string value represent environments function takes variable name returns value 
need support simple implementation environments de ne empty environment environment extension function exception val env fn raise env empty environment function raises exception indicate variable bound 
raising exception ways semantics role type system ensure typed program go wrong evaluated interpreted 
environment extension function takes environment variable name value returns new function type string value new environment 
function returns applied returns env applied 
interpretation de ne cbv interpreter language mere lines fun ev env case ei vi ea case ev env ev env vf el vf fn ev ext env ev env 
interpreter easy 
equational reasoning level meta language sml see interpretation id compose env produce values id compose respectively 
values contain function types printable see output 
see output interpreter result integer 
example expect object term fn evaluate 
encoding term simply ea id ei 
applying interpreter ev term empty environment env produces expected result ev env ea el ev ei val vi value 
introducing constants implementation technique described appealing partly allows rich set constants language simply extending environment modifying interpreter 
constants include addition function xed point operator allowing implement recursion 
easily extend object language modifying syntax set values interpreter 
lot expressivity added object language simply extending initial environment terms language evaluated 
example de ne meta level constants val plus vf fn vi vf fn vi vi val minus vf fn vi vf fn vi vi val times vf fn vi vf fn vi vi 
constants express terms evaluate square 
terms contain free variables bound extended environment 
example construct environ ment binding variable called function value times val env ext env times 
encode term fn open term val square el ea ea ev ev ev 
ev evaluate square ev env ea square ei val vi value 
produces encoding integer value expected 
introducing conditionals constant introduce conditional statement language constant 
general conditional statements replaced function val fn fn tf fn tf convention syntactic sugar free variable 
convention di erent sml convention term syntactic sugar 
sml convention require introducing tuples pairs toy language 
function takes integer function integers booleans second function integers booleans 
integer simply passed rst function result returned 
integer passed second function result returned 
general replace expression expression conditional statement ze fn fn function represented datatype value val vf fn vi vf fn vf tf vf fn vf tf vi vi 
introducing recursion constant recursion introduced lan guage xed point function essence function need val fun fn 
declaration fun replaced declaration containing fewer recursive expression fn function implemented datatype value val recur fun recur vf vf fn vf recur 
case recur vf vf fp fp equipped way expressing conditionals recursion express wide variety interesting programs toy functional language 
meta language sml toy language cbn cbv conditional statement slightly simpler 
particular need pass rst function 
cbv language obsolete argument needed maintain correct termination behavior 
metaml implementation sml cbv chose de nitions chapter 
cbn setting de nition xed point operator slightly simpler 
name usually xed point combinator function instance 
expressing executing function function section expressed language 
demonstrate rst show construct environment contains necessary ingredients expressing function show non construct replaced constant environment 
meta level concepts introduced directly object language including initial environment val env ext ext ext ext ext env plus minus times recur 
extended environment express evaluate terms function dis cussed 
interesting part task encoding term representation terms 
complete interpreter encoding performed parser 
clarifying mechanics interpreter 
original declaration nz ifn fn avoid need tuples language minimize parameters recursive function declaration recursion really depends fn function turn recursion lambda abstractions applications conditional val fn fn fn fn 
similarly function turn statement function lambda abstractions applications val fn fn fn fn fn fn 
encode sml program datatype representing syntax toy language val ea ev el val ea ea ei ei val answer ev env val answer vi value 
nal result represents integer value 
extending simple implementation staging annotations rst implementations metaml interpreter similar 
hypothesis introduce staging constructs language adding complexity interpreter 
section discuss involved extending simple implementation metaml staging annotations 
show anumber subtle problems arise easily addressed 
signi cance di culties comes fact extending existing implementation programming language include staging annotations prototypical multi stage languages developed practice see example :10.1.1.22.1290:10.1.1.122.522
existence problems underlines potential dangers widespread practice importance studying formal semantics multi stage languages 
values expressions extend interpreter deal multi stage language section enrich expression datatype exp new variants represent constructs brackets escape run cross stage persistent constants 
enrich value datatype value variant represent code fragments 
de nitions exp value recursive expressions values values expressions datatype exp integers ea exp exp applications el string exp lambda abstractions ev string variables eb exp brackets es exp escape er exp run ec value cross stage constants value integer values vf value value function values vc exp expressions object code 
infrastructure necessary de ning interpretation function 
environments bound variable renaming address renaming problem described section extended interpreter explicitly rename bound variables object programs 
way performing renaming environment carry new names assign object level bound variables run time 
technique interpreter jones 
perform renaming stateful function computes new name variable val ctr ref fun val ctr ctr integer ctr 
distinguish instances environment carry real values simply implement renaming generalize interpreter weakening 
way weakening changing type exp string value 
change types drastic datatypes exp val mutually recursive essentially expressivity 
exp val simply interpreter concise 
normal bindings name value replaced bindings expression ec reasons apparent section useful change default behavior empty environment 
particular empty environment simply return variable expression variable fun env ev extend interpretation function deal brackets run cross stage constants follows fun ev env case ei vi ea case ev env ev env vf el vf fn ev ext env ec ev case env ec eb vc eb env er case ev env vc ev env ec 
rst cases essentially 
di erence variable case requires variable associated constant environment 
variable associated constant run time error occurs 
postpone explaining case brackets momentarily interpretation uses rebuild ing function eb 
note case escapes escapes treated evaluation function rebuilding function 
case run interpreted rst interpreting argument get code fragment re interpreting code fragment empty environment 
cross stage persistent constants interpreted simply value carry 
case brackets call rebuilding function eb 
primary role rebuilding evaluate escapes level 
evaluating escapes performed traversing inside bracketed expression level escape encountered point escaped expression evaluated result evaluation spliced current context 
rebuilding function eb de ned mutual recursion ev eb env case ei ei ea ea eb env eb env el val el eb ext env ev ev env eb eb eb env es case ev env vc es eb env er er eb env ec ec 
parameter level expression rebuilt 
rebuilding integer expressions leaves unchanged 
rebuilding expressions escape level involves rebuilding subexpressions appropriate correction level parameter 
example rebuilding subexpression bracket expression requires adding level 
rebuilding subex escape level higher requires subtracting level 
level parameter changed 
way type environment re building variables works simple way environment carrying new name simply replaces old 
environment carrying real value equipped surround ec exactly form need avalue replace variable expression 
rebuilding lambda term involves producing new name bound variable extending environment new name old name replaced new encountered 
introducing constants extended initial environments essentially manner 
change modify way extend environment slightly val env ext ext ext ext ext env ec plus ec minus ec times ec ec recur 
evaluating encoding produces exactly result 
expressing executing staged function express staged function toy language nz ifn fn hx 
modify de nition slightly amenable encoding exp val fn fn fn fn fn fn hx zi ni 
de nition contains applications abstraction variables integers express syntax language 
contains free variables know include initial environment 
encoding function essentially val ea ev el val ea ea ei eb ei val answer ev env val vc ea el ea el ea ei ei value 
corresponding result expected fn fn fn 
new concerns hypotheses studying formal semantics metaml improve un language turn allow improve implementations metaml 
di cult explain accurately studying formal semantics language enhances standing language implemented 
cases studying formal semantics helps solve problems cases helps identify problems 
developing type systems rest dissertation examples study helped solve problem 
case scrutiny metaml implementation brought light previously unknown problems 
section describes new anomalies identi ed course study constitute ample justi cation pursuit rigorous semantics metaml 
scoping cross stage persistence hidden free variables cross stage persistence gets way bound variable renaming strategy inter 
particular ev performs renaming rebuilding function 
usage rebuilding limited kind substitution variable name 
cross stage persistent constants functions 
traverse functions rebuilding go inside cross stage persistent constants 
renaming strategy fails 
call hidden free variable problem 
formal semantics help 
identifying failure came direct result studying formal semantics metaml 
observed problem developing early version reduction semantics chapter 
mayhave run similar problem testing existing implementation examining implementation associated formal speci cation hard distinguish merely implementation mistake fundamental problem understanding language implemented 
reduction semantics allowed see clearly functions represent values functions performing renaming di cult 
shortly making observation synthesised concrete counter example caused metaml implementation exhibit anomalous behavior val puzzle hfn fn hxi fn hai run puzzle 
see rest dissertation term typed fairly simple speci cations metaml semantics evaluate toh 
implementations get di erent result 
see problem note escaped computation constructs code fragment containing cross stage persistent function contains dynamic variable body code fragment get back splice context contains cross stage persistent constant carrying avalue contains free object level variable 
conceptual error design ev eb assumed values carried cross stage persistent constants fully developed sense need processing 
function ev faithful model implementations ev illustrate puzzle problem 
application result running puzzle encoded evaluated follows val puzzle ea er eb el ea es ea el eb ev ev env puzzle val vc ev value 
el eb ev ei ei obscure result bound variable escaped scope binding abstraction 
anomaly occur statically scoped language occurrences variable remain syntactically inside scope binder 
formal semantics help 
ii section current proposal modifying implementation deal problem 
proposal primarily operational view implementation chapter corrected 
problem proposed solution identi ed development formal semantics metaml 
proposal just expect solve problem sheer complexity solution nal argument need study formal semantics metaml multi stage programming languages 
puzzle problem arise simply standard formal notion substitution done formulations metaml semantics rest part ii 
typing failure cross stage safety case scoping problem ran obscure bugs involving run construct 
documented simply implementation mistakes 
version formal soundness proof metaml type system rowan davies pointed soundness type system hold 
rowan expression hfn run expression typed type systems section behaved 
encoding executing expression implementation leads run time error 
root cause problem subsection run dynamically changes level term 
expression starts level 
expression executed level drops 
attempt evaluate looking associated value environment value available 
problem subsection result aw type system implementation metaml 
chapter solutions problem explain prefer solutions 
covers plausible solution hidden free variables problem go describe subtle reasons studying formal semantics metaml consider possible solution problem hidden free variables 
see solution quite complex solution may plausible formally verifying correctness remains non trivial task 
cross stage persistent constants carry values may rebuilding need go inside cross stage persistent constants 
mentioned earlier fallacy arises generally expects values fully developed terms requiring processing 
confusion results fact cross stage persistent constants carry sml values type value 
unfortunately things represented value datatype values sense formed interpretations terms 
counter example puzzle previous subsection evidence problem 
result evaluating puzzle ev represented value correspond accept metaml value 
hinted earlier problem evaluating puzzle renaming go inside cross stage persistent constants 
making renaming go inside cross stage persistent constants tricky obvious rename free variables inside function values value datatype 
solution propose called cover 
intuitively allows perform substitution datatype containing functions 
alternatively cover viewed delayed environment 
essential idea perform substitution non function terms normal manner cover functions making functions apply substitution results results available 
way free variable eliminated substitution renaming able escape scope binding occurrence 
de ne mutually recursive functions cover expressions values follows fun env case ei ei ea ea env env el el env ev env eb eb env es es env er er env ec ec env env case vi vi vf vf env vc vc env 
revised de nition interpreter follows fun ev env case ei vi ea case ev env ev env vf el vf fn ev ext env ec ev case env ec eb vc eb env er case ev env vc ev env ec env eb env case ei ei ea ea eb env eb env el val el eb ext env ev ev env eb eb eb env es case ev env vc es eb env er er eb env ec ec env 
changes evaluation rebuilding functions cases cross stage persistent constants cross stage persistent constants covered current environment returned 
cross stage persistent variables covered rebuilding address possibility added environment moved dynamic lambda incorrectly capture dynamic variable originated cross stage persistent constant 
evaluating term puzzle semantics produces expected result ev env puzzle val vc ec vi value 
point accumulation wrappers lead unnecessary performance degradation especially cross stage persistent constants contain code 
problem alleviated postponing application covers code fragment encountered 
idea similar spirit done calculi explicit substitutions 
optimization unexplored 
concerns concerns described section bugs instances implementation type system break 
qualitative concerns identi ed 
section 
need validating certain run time optimizations object code 
existence interesting intrinsic properties metaml code type enjoy 
revisit rst concern chapter 
optimization generated code interpretation considered su cient executing metaml pro grams known code generated programs contain super uous computations 
super uous computations costly execute gen erated programs code larger harder humans understand 
section explain need optimizations 
safe reduction uncommon executing multi stage program result construction applications eliminate 
consider example val hfn val hfn 
interpreter declaration evaluates fn 
metaml implementation attempts perform kind safe reduction piece code escaped 
generally reduction safe ect semantics properties termination safe case particularly easy recognize application lambda abstraction constant 
application reduced symbolically ecting termination 
furthermore restricting optimization cases argument small constant allows avoid possibility code explosion 
rebuilding time optimization easily incorporated interpretation modifying application case rebuilding function eb ea case eb env eb env 
el ei eb ext env ei el ev eb ext env ev ea optimization requires rule expected hold levels 
verifying claim trivial 
fact simple formal semantics metaml claim practically impossible verify 
return issue chapter 
respecting termination behavior su cient ect language termination 
richer languages safe reduction may need respect semantic properties 
safe rebuilding rebuilding expressions multi level language costly nec essary 
example somewhat unnatural allows exhibit behavior arise natural programs val hh ii hh aii 
interpreter declaration evaluates iii 
computing result involved turn rebuilding 
running involve rebuilding 
concern rebuilding redundant know rebuilding performed 
place larger expression cost redundancy substantial 
metaml implementation alleviates problem checking result rebuilding inside escape levels greater 
result rebuilding inside escape bracketed expression escape brackets eliminated result just expression 
optimization correct hei equal toe 
equality obvious supported refuted de nition semantics metaml 
furthermore semantics fairly simple proofs practical reliable 
need determine optimization sound motivation seeking equational theory metaml 
outline elementary equational theory chapter support optimization 
optimization incorporated rebuilding function changing escape case eb follows es case ev env vc 
case eb env eb es optimization described subsection eliminate redices user expect see generated code optimization principle hard understand particular program generated 
experience resulting smaller simpler programs easier understand optimizations worthwhile 
conjecture isomorphism great truths 
george bernard shaw conclude chapter describing simple controversial observation shortly began programming metaml purpose section observation emphasize programming metaml illuminated way deep insights nature multi stage programming 
say isomorphism types pair andg go back fourth types composition functions equal identity see example di cosmo 
precisely referring situation functions representation compositions provably equal tox equational theory simple example isomorphic types 
example pair andg identical fn 
working implementation metaml began wonder functions back forth section functions 

recall de nition functions fun back hfn ai bi 
bi fun forth xi 
bi ai bi 
reason function form isomorphism back applied non terminating function fails terminate returning code non terminating function 
time functions take code fragment diverge immediately useful functions 
particular code fragments metaml inductive structure programmer take apart code fragments look inside way running clear useful function takes code fragment fail terminate 
continued search counter example section may safely skipped reader interested details formal semantics metaml 
section requires familiarity formal notion equational theory 
important emphasize equational theoretic view view concerned domain theoretic interpretations types 
view interesting subject 
close inspection interpreter chapter reveal environment enriched constants allow apart piece code 
possibility artifact implementation language studied dissertation intended 
fragile nature distinction implemented formal intended possibly informal harder argument subsection 
di culty incentive seek alternative stronger formulations metaml semantics 
instances semantics rest part ii 
useful metaml function composition functions back forth identity 
date function 
conjectured back forth form isomorphism interesting subsets ai bi andh 
bi 
subsets exclude example non terminating functions ai bi 
choice restrictive functions generally uninteresting useful induction performed 
danvy observed level expansions binding time im provement 
functions back forth closely related level expansions 
application multi level expansions improving staged programs studied ex dissertation remains important open question 
relation functions level expansion motivation validate conjecture type isomorphisms 
chapter big step semantics type systems closedness art research ability look details see 
zero zero ect chapter presents formal semantics metaml big step style type system proven type safe respect big step semantics 
resulting language albeit useful expressivity limitation 
show shortcoming overcome explicating notion closed value level types 
grounds propose metaml extended new type closed values big step semantics sound type system proposal 
chapter represents state art untyped semantics type systems multi stage programming languages 
big step semantics cbv cbn formalizing big step semantics see example gunter allows specify semantics function goes directly expressions values 
reviewing big step semantics language 
recall chapter syntax language follows cbv big step semantics speci ed partial function 
set expressions int lam ee app note terms rules semantics apply get stuck semantics goes nite loop 
rule integers says evaluate 
rule lambda abstractions says evaluate 
rule applications says evaluated evaluating operator get lambda abstraction substituting result evaluating operand body lambda abstraction evaluating result substitution 
de nition substitution standard denoted bye capture free substitution ofe free occurrences 
semantics partial function associating unique value expression domain 
note need environment keeps track bindings variables value available variable immediately substitute value variable 
performed rule applications 
possible implement language directly mimicking big step semantics 
point direct implementation big step semantics somewhat ine cient application require traversal body lambda abstraction 
realistic implementation involve traversing terms run time perform substitution similar spirit simple interpreter discussed chapter 
closedness assumption semantics language fairly stan dard contains important assumption violated extend language multi level 
particular big step semantics rule evaluating vari ables 
key observation evaluating closed term big step semantics involve evaluating open sub terms 
claim established property derivation tree induced de nition semantics 
proof proceeds induction height derivation claim true base cases integers lambda abstractions typically semantics de ned closed terms 
impose restriction semantics 
capture free substitution means free variables captured bound variables 
true induction case applications 
case application need established evaluating closed expression returns closed expression 
big step semantics cbv recall chapter terms ej rune de ne big step semantics employ ner classi cation expressions 
example evaluation term interest escapes occur top level 
introduce expression families xjx je xjx je ij lemma basic properties expressions families proof 
parts lemma proven easy inductions 
illustrate proof rst part lemma 
prove proof proceeds induction derivation ofe de nition 
de nition know induction hypothesis 
de nition 
treatment rest cases proceeds manner 
second third parts similar 
third part induction derivation ut presentation sets expressions values slight abuse notation 
de nition level annotated terms essentially bnf de nes set terms simple induction 
technically set de ned induction height set membership judgment properties set established induction height derivation judgment 
expressed traditional notation follows hei run bnf notation shorthand de nitions 
shorthand especially convenient de ning sets workable stuck terms chapter 
syntax big step rules rune 
int ej rune run lam esc var lam brk esc rune 
rune fig 

coarse cbv big step semantics cbv big step semantics speci ed partial function proceed rst de ning coarse function type function arrive ne function app app run 

show restrict 
summarizes coarse cbv big step semantics see rst rules correspond rules rule run level says expression run rst evaluating get bracketed expression evaluating bracketed expression 
rule brackets level says evaluated rebuilding expression surround level rebuilding evaluating levels higher eliminates level escapes 
rebuilding performed traversing expres sions correctly keeping track level 
rebuilding simply traverses term level escape encountered point evaluation function invoked esc rule 
escaped expression yield bracketed expression expression returned 
regularity weuse 

way evaluation rebuilding described chapter treated partial function takes natural number extra argument 
extra argument distinguish evaluation extra argument rebuilding extra argument greater zero 
immediate bene having semantics provides formal way nding result implementation metaml return expression 
example easy compute result evaluating application result running puzzle see section hxi hai basic properties big step semantics establish properties operational semantics 
values subset terms denote results computations 
relative nature brackets escapes important family sets values indexed level term just set 
values de ned follows jx jx ij intuitively level values get result evaluating term level level values get rebuilding term 
set values important properties value level lambda abstraction bracketed value re ecting fact lambda abstractions terms representing code considered ac results computation 
second values contain applications re ecting fact computations levels deferred 
level escapes level values re ecting fact having escape term mean evaluating term completed 
evaluation complete example terms fx lemma establishes simple important property lemma strong value re ection untyped terms proof 
simple induction 
ut lemma parts saying element set code values element set expressions saying converse 
mentioned chapter properties interpreted positive qualities multi level language 
rst part tells object program value viewed meta program second part tells meta program viewed object program value 
having established re ection easy verify big step semantics returns value lemma basic properties big step semantics nv proof 
part simple induction derivation ofv prove part simple induction derivation ofe re ection lemma needed case run 
ut corollary level preservation proof 
noting andv ne result immediate previous lemma 
ut fine big step function rest dissertation con ne big step semantic function simply big step semantics 


refer closedness assumption violated semantics standard structure note unusual feature manipulates open terms 
particular rebuilding goes lambda rule lam escape level re invokes evaluation rebuilding 
closed term evaluates xi hx xi derivation evaluation involves sub evaluation open 
basic type system metaml chapter introduce level index typing judgment 
type judgment extended form andn 
judgement read type environment 
important note part judgement part type 
summarizes type system study section 
syntax types type environments operations type environments type rules var ej rune hei hi brk basic properties type system bj 
jhi jx int int lam ne ne hi esc fig 

type system hi rune run technical lemmas needed establish type safety 
lemmas establish basic properties type system needed establishing interesting properties lemma weakening dom fv proof 
induction structure derivation ut akey lemma needed proving type safety system lemma persistence typability proof 
direction implication simple induction height typing judgement assumption 
forward direction routine 
backward direction straightforward case escape notable 
particular prove implies ine ine ut app notation write environments 
environment determined disjoint union lemma says term remains typable reduce level variables environment term typable 
lemma promotion proof 
simple induction derivation ut introduce simple notation useful writing kind proofs dissertation 
notation proofs derivations convenient proofs laid dimensions re ect relating derivation tree 
symbols way implications list rules achieve implication 
rules applied rules type system arithmetic induction hypothesis 
proofs start left proceed right 
go depending normal orientation particular rule implication 
horizontal implications aligned precedents antecedents 
lemma substitution proof 
induction derivation judgement variables know weakening variables ii typing rule variables know natural know persistence typability wehave applications promotion done 
lambda abstraction andy 
barendregt convention fv 

ih 
lambda abstraction ii 

done 
applications brackets escapes run type safety 
hei hi hi hi rune ih ih 
ih hei hi ih hi ih ne hi rune statement proof type safety lemma quite straightforward emphasize importance de ning carefully meant safety particular language 
specify occurrence run time error rst augmenting big step semantics return error value err undesirable condition takes place 
type big step semantic function 


second introduce additional set rules propagate value returned sub computations 
rst set rules added big step semantics follows 
err hei rune 
err 
err hei 
err esc err add propagation rules simply return error result sub computation error 
subtle error cases identify variables 
particular easy forget add rule error emitting case hard see possible prove incorrect type safety theorems 
instructive note slight redundancy typed treatment ut lemma proof 
simple induction derivation ut interested typed terms strictly speaking need family classi cation expressions 
see chapter classi cation signi cant treatment untyped language 
re ection typed multi level language viewed existence correspondence programs program representations hvi hi 
property holds 
instance result lemma strong value re ection typed terms 
proof 
part induction derivation case analysis part induction derivation ut lemma basic property augmented semantics proof 
simple induction derivation ofe re ection lemma needed case run 
ut closedness assumption re ned pointed earlier important feature language reductions operate closed terms 
pointed assumption violated big step semantics rebuilding goes lambda 
crucial observation allows continue formal development metaml usual manner terms closed respect variables bound level 
observation dictates general form statement type preservation theorem theorem type preservation cbv proof 
induction derivation ofe case application uses substitution 
case analysis proceeds follows variables vacuous derive type judgment case 
variables ii trivial lambda abstraction interestingly induction needed 
particular de nition premise lambda abstraction ii straightforward induction 
ih 
application run follow involved similar pattern 
cases straight forward induction 
applications induction hypothesis twice gives result substitution lemma 
ne ne ih ih 
note judgment apply substitution lemma 
information apply induction hypothesis third time applications ii bracket escape escape ii 
hei hi hi hi hei ih 
ih ih ih 
hi ih hi hi run similar application persistence typability 
apply induction hypothesis reconstruct type judgment result hi rune ih hi applying persistence typability top result get applying induction hypothesis run ii hi rune rune 
rune ih rune hi rune theorem type safety cbv err proof 
follows directly type preservation ut big step semantics cbn di erence cbn semantics cbv semantics evaluation rule application level 
cbn rule ee app cbn summarizes full semantics 
type preservation proof need changed application case 
theorem type preservation cbn limitation basic type system re integration basic type system previous chapter problem renders unsuitable supporting multi stage programming explicit annotations type simple useful terms 
example chapter re integrated dynamically generated function follows ut syntax big step rules rune 
int ej rune run lam esc var lam brk esc rune 
rune fig 

coarse cbn big step semantics val exp run exp real real 
app cbn app run declaration typable faulty type system chapter type system 
fact type simple sequence declarations type system val run sequence typable standard interpretation corresponds lambda term typable 
overcoming problem achieve multi stage programming advertised chapters 
understanding problem signi cance requires understanding relation types method multi stage programming 
analysis types major artifacts produced main steps method multi stage programming 
clear type system allow general way conducting step method 
argue root problem lies lack ofan ective mechanism tracking free variables 
propose solution problem level types show new types basis re ned method supported provably sound type system 
types artifacts multi stage programming main steps multi stage programming 
write conventional program program ts td type static known parameters td type dynamic unknown parameters type result program 

add staging annotations program derive annotated program ts hti 
compose annotated program unfolding combinator back hai hbi ha bi 
construct read static inputs code generator ts htd ti ts 
apply code generator static inputs get specialized code htd ti 
run specialized code re introduce generated function rst class value current environment specialized program td steps method carried type system previous chapter 
step problematic 
problem abstracting run root expressivity problem described general type safe way going metaml value code metaml value 
level language constructs metaml provides construct run 
run construct allows execution code fragment type rule hi rune run example typed evaluates 
run limited expressivity 
particular function turned function lambda typable type system section 
function code fragments declared top level executed typed terms 
time adding function run hai safety type system previous section equivalent faulty run rule chapter 
counterexample type safety applies 
despite long search able nd reasonable type systems function unsafe run hai exist inclined believe single parametric type code allow natural way executing code 
observation interpreted saying generated code easily integrated rest run time system 
closer look goes wrong operationally code fragment contain free dynamic variables 
original code type metaml provide information free dynamic variables fragment way ensuring code fragment safely executed 
need ner typing mechanism provides means reasoning free variables 
observation holds minimal language multi stage programming language believe hold multi stage languages 
bn language 
adding closedness proposal add special type constructor mark closed terms metaml 
closed terms evaluate closed values values containing free variables 
viability proposal demonstrated adding closed type presenting provably sound type system 
extended language called bn adds closed type types bj 
jx tempting say searching rst class function function functional language rst class citizen operator function citizen 
looking way operator functional language function looking way operator functional language rst class citizen 
bn language re nes adding constructs marking un marking closed terms replacing run new construct called safe run providing explicit form cross stage persistence closed values safe rst production allows set constants strings 
productions standard ones calculus 
bracket escape seen 
close construct assert imposed type system terms closed set bound closed 
open allows forget closedness assertion 
safe run executes closed code fragment returns closed result 
allows closed expression higher level providing cross stage persistence closed values 
big step semantics bn big step semantics bn similar summarized 
rst evaluation rules evaluation language 
rule says evaluating bracketed expression done rebuilding expression 
rules new specify semantics closedness annotations 
evaluation rule close says rst evaluates expressions clause substitutes results place variables body close 
result substitution evaluated returned nal result 
rule open says simply evaluates argument get closed result returns result 
rules new specify semantics new operations exploit useful interaction closed code types 
de nition rebuilding essentially level annotations changed cases brackets escapes 
note semantics explicitly specify renaming bound object level variables rebuilding code 
capture free substitution performed application rule takes care necessary renaming 
example expression evaluates level hx hx zi hxi hx xi syntax safe shorthands big step rules level evaluation ei mg ei lam ee hei hvi vie xi vi ei 

iv safe rune 
big step rules rebuilding var hei hvi ei ei vi brk srn brk clos const lam hvi 
vi safe rune 
safe srn 


esc clo 
esc 

upv fig 

cbv big step semantics bn app app capture free substitution renames bound variable goes inside lambda inadvertent capture variable substitution 
worth noting rule rebuilding constants says remain unchanged 
evaluation rules escapes escapes intended occur inside brackets meaningless level 
language extended speci constants speci rules evaluating ensure rules violate properties safety example 
type system bn typing judgments bn form natural number called level term 
level term number brackets surrounding term number escapes surrounding term 
summarizes type system bn rule constant says type associated constant 
rules essentially note variable rule longer allows implicit cross stage persistence 
variables level bound 
see rules allows achieve restricted form cross stage persistence 
rules brackets escape exactly 
rules new specify typing closedness annotations 
rule close says typable bindings clause closed term body close typable level assuming variables clause available level 
essence ensures closed expression contain variables bound closed expressions 
rule open simply forgets closed type 
rule safe run allows eliminate code type occurs closed type 
rule allows lift closed value level providing limited form cross stage persistence cross stage persistence closed values 
covers performance worth noting build implementation lines chapter language cross stage persistence closed values need covers discussed section 
particular cross stage persistent constants implementation carry free variables 
see claim recall 
covers perform substitution functional values syntax safe types type environments operations type environments type rules var bj 
jx const nx 
lam 
app hei hi brk ei fxi ji mg ei hi safe rune srn hi esc clo fig 

bn type system 
functional values arise inside cross stage persistent constants 
closed cross stage persistent constants contain free variables 
example puzzle term chapter hfn fn hxi fn hai longer acceptable type system cross stage persistent variable rst lambda abstraction closed type time free variable second lambda abstraction lambda abstraction closed type 
covering involves adding extra function composition latent traversal code time cross stage persistent variable evaluated independently contains hidden free variables covering costly operation 
observations suggest covering avoided completely restrict cross stage persistence closed values 
basic properties type system technical lemmas bn needed establish type safety 
lemma weakening dom fv proof 

ut lemma substitution proof 
substitution 
ut type safety rst set rules added big step semantics follows 
err 
err 
err 
err safe rune 
err hvi 
err esc err propagation rules simply return error result sub computation error 
basic properties big step semantics values bn de ned follows jx safe jx ij lemma values upv ij safe proof 
just 
ut key property establish bn value produced evaluating expression closed type closed value 
lemma formalizes claim saying value closed empty environment lemma closedness proof 
immediate de nition values 
ut lemma strong value re ection typed terms 
proof 
just 
ut theorem type preservation cbv bn proof 
induction derivation ofe case application uses substitution 
case involves closedness re ection weakening addition applying induction hypothesis 
case safe run involves re ection ut theorem type safety cbv bn err proof 
follows directly type preservation ut cbn bn di erence cbn semantics cbv semantics bn evaluation rule application level 
cbn application rule ee app cbn type preservation proof need changed application case 
theorem type preservation cbv bn theorem type safety cbn bn re ning types err crucial insight chapter useful type systems function safe run hai 
exists 
safe run operational behavior unsafe run intended achieve running code 
di erence typing function 
nutshell safe run allows programmer exploit fact closed code safely executed 
re ning method propose re nement stage programming explicit assertions closedness assertions checked type system 
write conventional program exactly program ts td 
add staging closedness annotations program achieve closed annotated program ts hti 
di erence programmer closed type constructor demonstrate type system annotated program introduce free dynamic variables 
new requirement means constructing annotated program programmer allowed closed values 

compose annotated program unfolding combinator get closed code generator ts htd ti back closed inside closed value slightly di erent combinator closed back hai hbi ha bi 
turn closed code generator generator closed code ts htd ti new program exhibited applying combinator closed apply 

construct read static inputs closed values cs ts step similar multi stage programming explicit annotations 
requiring input closed speci original method 
sure combinators constructing value closed 

apply code generator static inputs get 
run result get closed specialized code htd ti closed specialized program td step exploits interaction closed code types type system 
step performed applying function safe run hai 

forget specialized program closed specialized program td step performed applying function open full development multi stage programming examples previous chapter expressed bn staging power function revisited recall power function staged section fun exp int real real sqr exp div exp 
staging function bn essentially staging metaml 
di erence surround metaml style staged function closedness annotations 
close mark term closed open forget closedness free variables wish de ning closed term 
program annotated follows val exp close val open int bool val sqr open sqr fun exp ifn exp sqr sqr 
sqr exp div exp sqr versions sqr functions closed manner example sqr de ned val sqr close fun sqr val sqr 
note fun exp part val exp declaration exactly text exp function staged metaml 
see section general explicitly close values wish constructing bigger closed value exception primitive operations 
programs produced way somewhat verbose believe problem alleviated careful separation closed non closed values environment 
study separation left 
operationally unnecessary re binding sqr sqr needed type checking see type system 
operationally di erent writing yx 
re ned method intuitively appealing metaml original type system section code type constructor tries combine features open closed code type constructors constructor supposed allow evaluate lambda open code run code closed 
combination leads typing problem discussed section 
contrast bn type system incorporates separate open code closed value type constructors providing correct semantics natural desirable functions 
open 
function allows forget closedness argument 
bn language function inverse type 

function corresponds cross stage persistence closed values 
fact embeds closed value code fragment including values functional type 
function exist :10.1.1.16.4975
time bn function inverse type re ecting fact general way going backwards 

safe run hi 
function allows execute closed piece code get closed value 
viewed essence interaction bracket closed types 
chapter reduction semantics am impossible 
saw moon jumped high high sky 
reached care 
heart joy 
chapter explaining de ning reduction semantics metaml ing 
strikingly simple reduction semantics metaml con uent sound respect big step semantics 
chapter presents new results untyped semantics multi stage programming languages 
reduction semantics cbn cbv formal semantics general provides means going arbitrary expressions values provision certain expressions may corresponding value 
important conceptual tool study programming language reduction semantics 
reduction semantics set rewrite rules formalize notions reduction language 
having semantics useful developing equational theory rst review semantics speci ed language section 
experience case studying semantics helped developing rst type system chapter 
reduction semantics helpful developing type system 
particular important property appropriate type system remain invariant reductions subject reduction 
reduction semantics simple help language designers eliminate inappropriate type systems 
recall set expressions set values language de ned follows ijx order productions expressions integers lambda abstractions applications 
values language integers lambda abstractions 
intuitively expressions commands computations values answers ac results simply expressions require evaluation 
note allow value expression computational content 
order build mech anism going expressions values need specify formal rule eliminating variables applications program 
reduction semantics see example barendregt elimination process speci ed introducing rewrite rules called notions reduction 
known rule helps eliminate applications variables time rule says application lambda abstraction expression simpli ed substitution expression body lambda abstraction 
cbn semantics rule 
similar rule cbv 
argument restricted cbv value forcing evaluated passed function 
metaml implementation cbv simply rest chapter emphasizing applicability cbn language rule build new relation 
subscript allows perform rewrite subexpressions 
see example section formally andc identical exactly hole lled respectively say rule reduction semantics left hand side condition disjunction rewrites toe rules rewrite system 
cbv values slightly di erent cbn values notably cbv values typically include variables 
note distinction arises reduction semantics big step semantics 
noted due time limitations formally veri ed con uence soundness cbn metaml cbv metaml 
expect properties hold 
relation 
holds terms exactly subterms rewritten rules reduction semantics 
coherence con uence important concepts central chapter coherence con uence con uence see example barendregt 
recall section term rewriting system non deterministic 
depending order apply rules get di erent results 
case semantics reduce 
say reduction semantics coherent path leads ground value leads ground value 
semantics lacks coherence satisfactory deterministic programming language 
intuitively knowing rewriting system con uent tells reductions applied order ecting set results reach applying reductions 
con uence term rewriting system way ensuring coherence 
conversely ifwe lose coherence lose con uence 
turn problem extend reduction semantics multi stage language 
extending reduction semantics rst attempt extending set expressions values incorporate basic staging constructs metaml yields set expressions values ej rune add rules rule hei 
ee 
re reasons naive approach unsatisfactory 
rest chapter explain problems approach explore space possible improvements semantics 
intensional analysis con icts raw metaml terms rst observation con ict rule supporting intensional analysis 
support intensional analysis means adding constructs metaml allow program inspect piece code possibly change execution structure content piece code 
con ict example high level insight resulted studying formal semantics metaml 
particular metaml developed meta programming language multi stage programming need concern code type represented long term goals metaml project time included support intensional analysis 
idea intensional analysis example allow write optimizers code 
turns intensional analysis direct contention allowing rule object code levels higher 
illustrate interaction rule intensional analysis assume minimal extension core metaml tests piece code see application 
extension achieved simple hypothetical construct semantics fn fn val true bool 
allowing object code means fn fn replaced yi 
reduction performed optimizing compiler justi able eliminates function call object program 
optimization devastating ect semantics metaml 
particular allow language behave follows fn fn val false bool 
reduction performed argument longer application simply lambda yi 
words allowing intensional analysis object program optimization implies get result false just get result true 
example illustrates problem coherence metaml semantics presence reduction higher levels code inspection 
issue rst drew attention care needed specifying equalities hold metaml subtle concerns direct relevance multi stage programming absence intensional analysis 
level annotated metaml terms expression families order control applicability various levels developed notion level annotated terms 
level annotated terms carry natural number leaves re ect level term 
terms keep track meta level information level subterm terms give ner control di erent reductions applicable 
level annotated terms induce nite family annotated term lives 
family level annotated expressions values de ned follows jx jx je jx jx je ij jx jx jx jv jx jx jv jx ij key di erence level annotated terms raw terms leaves variables integers 
level annotated terms variables integers explicitly carry natural number represents level 
constructs simply infer level term looking subterm 
brackets escapes obvious correction levels performed 
note go inside bracket escape index expression set changed accordance way level changes go inside bracket escape 
escapes con ict annotated metaml terms problematic interaction rule higher levels escape 
particular preserve syntactic categories level annotated terms 
consider term fn ii 
level term 
allow rule higher levels term reduced ii 
result contains nested escapes 
level term longer 
outer escape corresponds bracket inner escape 
originally corresponded bracket reduction get expression read manner original term 
substitution con icts level annotated terms possibility avoiding problem limit level terms rst approach appealing extension metaml code inspection operations problematic 
consider term fn hx fn fn 
possible reductions level term 
rst outermost application second application inside argument 
rst application get result hfn fn level annotations need adjusted substitution 
see section rst note reductions level left term 
second application rst get fn hx fn 
go back perform outermost application get hfn presence code inspection example illustrates incoherence problem 
absence code inspection lose con uence reductions despite fact sacri ced reductions higher levels 
intuitively example illustrates cross stage persistence arises naturally untyped metaml terms cross stage persistence hard limit level consistent con uent way 
example applying lift term fn function causes redices body function frozen 
reduction semantics cbn welcome notes bands travellers sands voice ne er heard spring time cuckoo bird breaking silence seas farthest 
solitary william syntax consists set raw expressions values de ned follows jx ij rune ijx essential subtlety de nition production set values inside brackets code value needed simply expression level 
cbn notions reduction simply 

eu 
ru just rules rules intended applied context 
calculus allows apply rule expression looks level application 
restricting body lambda term argument language avoids con ict escapes discussed earlier chapter level terms free top level escapes 
subject reduction summarizes language cbn study section 
note cbn enjoys de ned terms standard notion substitution 
fairly straightforward establish preserves typability notion typing type system section syntax reductions jx ij rune ijx 

eu 
ru fig 

cbn language theorem subject reduction cbn proof 
proof builds basic properties type system established chapter 
cases need considered ande 
know typing know 
typing know substitution know done 
ande get hi persistence typability get done 
ande get hi done 
con uence establishing con uence property presence rule involved largely substitution duplicate redices establishing redices ected tion non trivial 
barendregt presents number di erent ways proving con uence discusses relative merits 
takahashi produced concise highly rigorous technique proving con uence demonstrated application variety settings includ ing proving subtle properties reduction systems standardization 
basic idea takahashi promotes explicit notion parallel reduction 
idea ut goes back original classic unpublished works tait martin lof takahashi emphasizes verbose notion residuals see barendregt example completely avoided 
section proof con uence cbn follows closely development takahashi 
cbn reductions introduce notable complications proof simple concise rigorous takahashi 
de nition context context expression exactly hole 
jx expression resulting replacing lling hole 
lemma basic property contexts proof 
induction derivation ofc ut filling hole context involve variable capture sense cx binding occurrence ofx renamed 
de nition parallel reduction parallel reduction de ned follows 


xx ihe 

rune rune idempotence ignoring rules de nition easy see 
lemma parallel reduction properties 
proof 
rst proved induction context redex second third induction 
ut see 
church rosser theorem 
follows takahashi property 
statement takahashi property uses notion 
de nition star reduction star reduction function de ned fol lows xx 

ife 
ihe 


rune run rune 
simple induction see theorem takahashi property proof 
induction 
ut results follow sequence notation relation composition relations shorthand ab bc 
lemma parallel reduction diamond ee proof 
takahashi property ut theorem cbn con uent soundness cbn reductions cbn big steps section show cbn reductions preserve observational equivalence notion observation simply termination behavior level big step evaluation 
recall chapter cbn semantics speci ed partial function 
follows rune 
int run lam esc var lam brk rune 
rune app app run reduction semantics lambda calculus generally equal big step semantics 
example reduction semantics lambda calculus reductions lambda big step semantics generally 
reader referred textbooks semantics detailed discussions 
esc 
de nition level termination de nition observational equivalence de ne follows ne de nition says terms observationally equivalent exactly interchanged level term ecting level termination behavior term 
notation drop subscript 
rest chapter 
theorem cbn reduction sound big steps ne proof 
de nition prove goal prove ne noting know su cient stronger statement noting ac su cient prove stronger statement goal broken parts consider 
de nition termination says show big step evaluation included reduction lemma 
prove prove con uence theorem tell reduction paths joinable weaken goal follows show lemmas reduction starts value lead value level 
weaken words know reduces value question really evaluates 
formally fact original assumption longer necessary prove consider 
de nition termination says inclusion evaluation reduction weaken rst assumption statement say longer need assumption su cient show note identical goals 
state statement direct consequence lemma ut easy show follows directly result lemma cbn cbn proof 
straightforward induction height ut harder show converse 
consequence stronger result lemma cbn cbn proof 
arrive result adaptation plotkin proof similar result cbv cbn lambda calculi 
main steps development 
strengthen goal 
de ne left reduction function 
de nition lemma lemma 
big step evaluation simply evaluation exactly chain left reductions ends value 

goal restated 
technical reasons proofs simpler parallel reduction relation de ni tion similar introduced section 
goal restated ev 
left reduction function induces ne classi cation terms de nition 
particular terme exactly lemma membership sets de ned inductively structure term 
ands refer member sets respec tively 
left reduction total function exactly members lemma 
left reduction strictly unde ned non un de ned values stuck terms 
furthermore result parallel reduction value source value workable lemma 
refer property parallel reduction monotonicity 

classi cation break goal cases depending starting point workable vv wv 
obvious true 
current goal 

monotonicity parallel reduction clear intermediate terms reduction values 
furthermore values interleave exactly transition values chain 
chain visualized follows kv prove kv replaced lemma wv 
lemma know replace chain evaluation involved going workable rst value explicit 
left push back information workable chain rst workable chain 
achieved straightforward iteration induction number ofk chain result prove lemma result able move predicate 


way back tothe rst workable chain 
step visualized follows 
application chain applications completing proof 


rest section de nitions lemmas mentioned 
noted proving lemmas mentioned require generalizing level ton 
rest development generalized forms trivially instantiated statements mentioned 
basic classi cation terms de nition classes de ne judgements raw type free classes values stuck sets de ned follows xjx jv xjx jv ij jw jw jv ij jw jv ij xjs runs js jv ij runs js jv ij lemma basic properties classes ut proof 
properties easy prove straightforward induction 

verify claim case separately induction ande respectively 

prove exactly ors proof induction proof direct albeit tedious 
left reduction notion left reduction intended capture precisely reductions performed big step semantics small step manner 
note simplicity de nition depends fact partial function de ned de ned values 
expect noe de nition left reduction left reduction partial function de ned follows 




hv hei 
rune 
rune ut 
lemma says set characterizes exactly set terms advanced left reduction 
lemma left reduction classes proof 
need prove rst second follow 
rst straight forward induction second straightforward induction ut lemma left reduction cbn proof 
straightforward induction rst judgement ut lemma left reduction proof 
forward direction induction length derivation size ofe 
second ordering needed lambda calculus needed evaluation higher levels 
proof proceeds case analysis rst left reduction left reduction chain 
backward direction straightforward induction height derivation ut parallel reduction complexity order prove key lemmas section need reason induction complexity parallel reduction 
de nition parallel reduction associated complexity measure de nition parallel reduction complexity parallel reduction de ned follows 




rune rune number occurrences terme 
sense parallel reduction respect classes 
lemma cates properties 
lemma parallel reduction classes sn proof 
rst part lemma proved straightforward induction height reduction derivation 
establish second parts lemma fourth part follows immediately 
proof rst straightforward induction derivations ofe ande respectively ut shown parallel reduction complexity equivalent steps normal reduction steps 
result applies annotated de nition 
lemma substitution parallel reduction complexity zx proof 
induction height 
direct extension proof lemma page plotkin 
ut lemma transition 
proof 
induction size ofw 
direct combination extension proofs lemmas plotkin ut lemma permutation 
proof 
induction case analysis case derivation ofw 
direct extension lemmas previous ut lemma push back 

proof 
assumption corresponds chain reductions wk wk gives en 
applying permutation tow 
monotonicity parallel reduction know workable reduce workable 

chain 
repeating times 
applying permutation wk 
wk wk 
wk wk give ek en wk 
ek 
monotonicity parallel reduction know value workable 
value chain 


wk 
vk done 
workable applying transition gives wk 

means chain 


wk 
wk 
done 
ut concluding remarks equational theory case equational theory lan guage look similar reduction semantics 
point expect reductions hold equalities 
equational theory useful reason ing programs general proving equivalence programs particular 
formal development practical utility equational theory largely unexplored 
strati cation expressions necessary stratify set ex expression families 
particular notions reduction certainly sound explicitly forbid application big step semantic function terms manifestly right level 
particular consider term hii term sub big step semantic function level result unde ned 
optimize term escape reduction get back termi big step semantics de ned 
strati cation expressions crucial correctness notions reduction 
non left internal reductions standardization proofs described barendregt takahashi employ complementary notions reduc tion internal reduction de ned simply non head 
development plotkin require notions 
posses interesting prop erties setting preservation classes needed proofs 
turbak point complementary reductions preserve classes 
complementary notions may possible avoid plotkin notion com plexity rest proof remains essentially 
plan investigate point 
classes plotkin names set values explicitly 
notions stuck terms employed helped adapt plotkin technique metaml cases shorten development 
example combined plotkin lemmas lemma 
expect organization expressions values stuck terms may suitable applying plotkin technique programming languages 
standardization need standardization theorem explicit notion standard reduction 
development avoided lemma plotkin non trivial lexicographic ordering needed proving lemma 
classi cation employed danvy values stuck terms named 
time writing results name literature 
soundness cbv additional degree care needed treat ment cbv 
particular notion value induced big step semantics call value lambda language notion value reduction seman tics call value languages 
typically contains variables 
subtle di erence require distinguishing notions soundness proof 
part iii appraisal recommendations chapter discussion related works explained motivation study metaml multi stage languages 
part explained basics metaml develop multi stage programs 
part ii explained need formal study semantics metaml main technical results 
chapter expands points distracted essentials argument 
rst sections parallel organization dissertation 
section reviews motivation studying manual staging explains dissertation allows formalize concept stage informal notion 
part section reviews current state metaml presents explanation lambda abstraction staging 
section discuss practical problem cross stage portability having cross stage persistence creates 
part ii section discusses related works multi level specialization multi level languages positions context 
nal section reviews snapshots history quasi quotation formal logic lisp prolog 
manual staging 
partial evaluation performs staging automatically reasonable ask manual staging interest 
number reasons manual staging interesting desirable foundational seen dissertation subtlety semantics annotated programs warrants studying relative isolation added complexity partial evaluation issues 
pedagogical explaining concept staging programmers challenge 
example hard new users understand workings partial evaluation systems 
new users lack model partial evaluation systems 
furthermore new users uncertain output binding time analysis 
annotations 
expressed 
really mean 
answers questions crucial ective partial evaluation 
bta involved process requires special expertise annotations produces relatively simple easy understand 
observation programmers understand annotated output bta knowing 
having programming language explicit staging annotations help users partial evaluation understand issues involved staged computation hopefully reduce steep learning curve currently associated partial evaluator ectively 
pragmatic performance performance issue control evaluation order im portant 
bta optimizes evaluation order time arrival inputs just easier say wanted force bta discover 
automatic analyses necessarily incomplete approximate knowledge programmer 
explicit annotations programmer exploit full knowledge program domain 
language manual staging having explicit annotations er programmer designed back door dealing instances automatic analysis reaches limits 
pragmatic termination ects annotations alter termination behavior ways specialization annotated program fail terminate generated program termination behavior di ering original program 
termination questions subject active investigation partial evaluation programming explicit annotation gives user complete control responsibility termination behavior staged system 
example recursive program annotated staging annotations fundamentally di erent ways 
consider power function 
rst way annotating wehave discussed dissertation fun exp sqr exp div exp second way annotating follows fun exp hif sqr exp div exp intuitively done factored brackets branches statement bracket statement 
function perfectly typed anno tations just created non terminating function function terminating powers 
applied function simply repeated calls constructing bigger bigger code fragments 
partial evaluation problem known nite unfolding partial evaluation systems take precautions avoid 
metaml fact anomalous annotations problem programmer speci es explicitly annotations go 
particular partial evaluation automatic analysis bta alter termination behavior program multi stage programming programmer control responsibility correctness termination behavior annotated program 
notion stage gave intuitive explanation stage 
presenting semantics metaml provide formal de nition 
de ne trace stage derivation tree generated invocation derivation rune 
see run rule chapter 
note notion level de ned respect syntax notion stage de ned respect trace operational semantics 
quite intuitive distinction clear especially comparable de nition literature respect operational semantics 
levels subterms program stages involved execution program unrelated 
ii expressions levels 
de ne level program maximum level subexpressions level program 
evaluation expression just involves rebuilding involves derivations rune hand evaluation slightly modi ed level program ii involves stages 
illustrate distinction levels stages de ne number stages program number times derivation rune evaluation consider fn lift run 
arbitrary problem words possibly non terminating program 
number stages program statically decidable 
furthermore say general occurrence run ultimately responsible triggering computation addition 
recognizing mismatch useful step nding type system metaml employs static notion level approximate dynamic notion stage 
code added sml datatype simple interpreter metaml discussed chapter uses datatype implement code type constructor 
interesting question de ne similar datatype sml constructors datatype place metaml brackets escapes 
possible datatype interpreter available object language avoid need having implement full interpreter metaml altogether 
unfortunately number reasons metaml code type constructor added sml datatype 
explain reasons assume datatype exists declaration form datatype code int var lam app 
essentially single variant datatype contradict basic assumptions datatype constructors 
see recall sml datatype construct type constructor ai 
ai ai stands type term closed variables ai 
sml datatype get type upper bound may wish de ne number sequential stages multistage computation 
example de ned number stages data ow view computation 
de nition simplistic su cient illustrating point 
ai ai integers consider case integers 
integer variant ei type ei int int code return type polymorphic wish de ne datatype return type cover datatype 
problem clear consider type int code 
int typed int code values 
simple fact means express polymorphic identity function works apart code fragment putting back 
variables variable variant ev expected type ev tvar tcode run problem similar target type completely polymorphic 
furthermore need introduce explicit notion variables form type constructor 
obvious constructor introduced form datatype 
clear atype constructor introduced consistent manner 
lambda abstraction lambda abstraction variant el expected type el 
code run problem target type fully covered 
addition rst occurrence complex appears 
particular possible second argument open expression variable bound rst argument occur free 
type insu cient describing fragment fact conditioned fact free variable bound lambda abstraction type clear accomplished introducing additional substantial machinery meta language sml 
application application variant ea expected type ea 
code 
run problem target type covers domain 
problem free type variable type domain appear type domain 
may possible view existentially quanti ed type obvious complicate treatment datatype 
part practice multi stage programming sheard developed original design implementation metaml language combining host desirable language features including staging annotations static typing hindley milner polymorphism type inference 
primary goal design provide language suited writing program genera tors 
implementations metaml developed 
rst developed sheard 
interpreter implemented pure cbv functional language poly morphic type inference support recursive functions sml style datatypes staging constructs studied dissertation 
rst implementation largely implementation 
see section development second implementation sheard taha benaissa started continues today 
interpreter aims incorporating full sml extending staging constructs 
highlights metaml cross stage persistence 
ability variables past stage crucial writing staged programs manner programmers accustomed 
cross stage persistence provides solution hygienic macros typed language macros bind identi ers environment de nition captured environment 
multi stage aware type system 
type checker reports staging errors type errors 
interactive type system useful staging 
display code 
debugging important users able read code produced multi stage programs 
supporting metaml feature requires display mechanism pretty printer values type code 
display constants 
origin cross stage persistent constant hard identify 
named tags provide approximation constants came 
tags misleading quite useful 
connection bi 
having mediating functions back forth reduces number annotations needed stage programs 
lift 
lift annotation possible force computation early stage lift value program incorporated stage 
may cross stage persistence lift unnecessary lift helps producing code easier understand constants explicit 
safe rebuilding optimizations 
optimizations improve generated code readable 
lambda abstraction multi stage programming may appear staging requires delay force operations see example okasaki wadler implemented lambda abstraction application re spectively :10.1.1.54.6229
may true certain domains capabilities needed multi stage programming provided delay force 
delayed computation maintain intensional representation users inspect code produced generators printed compiled 
compiled implementation lambda abstractions lose high level intensional representation harder inspect print lambda abstractions run time 

fundamentally code generators need perform evaluation lambda 
eval uation lambda necessary staged application performs kind unfolding functions 
clear ect escape lambda imitated cbv calculus extending additional constructs 
explain second point show example result encoding operational semantics metaml sml nj 
encoding metaml cbv language ects essential program requires abstraction application staging brackets dynamic non level abstractions escapes 
lambda abstraction unit encode brackets application unit encode run 
escape considerably di cult encode 
particular expression inside escape executed surrounding delayed computation constructed 
implementing encoding di cult variables introduced inside delayed expression occur escaped expression terms way imitate behavior uses non pure sml features 
simulate evaluation lambda exceptions simulate creation uninitialized cells 
consider sequence metaml declarations fun hfn val pc fn xc xc xc val run pc 
corresponding imitation sml exception de ned val unde ned fn raise de ned fun val xh ref unde ned val xc fn xh val nc xc fn fn xh fn nc val pc fn xc fn xc xc val pc 
translation values ai encoded delayed computations type 

assigning lifted unde ned value unde ned 
ready write analog function function function rst creates uninitialized cell xh 
cell corresponds occurrences application metaml de nition intuitively fact xh uninitialized corresponds fact bound xed value application performed 
facility isvery important metaml allows unfold functions dummy variables expression fn xh delayed lookup xh 
delayed computation corresponds brackets surrounding expression 
simply perform application function delayed construction 
important note applying passed function know value bound 
body function returns delayed lambda abstraction rst assigns delayed version xh simply includes applied escaped version nc body abstraction 
transliteration illustrates advantage metaml trying encode multi stage programs lambda abstractions exceptions 
metaml version shorter concise looks version easier understand 
consider implementation metaml approach hidden syntactic sugar alleviate disadvantages listed 
lambda delay method advantage machine independent manipulation lambda terms 
unfortunately fails meet intensional representation criterion incurs overhead necessarily incurred metaml version 
particular assignment xh delayed repeated time function returned 
happens application escaping nc 
expenses incurred metaml version intuitively operations connect meta level variable corresponding object level xh 
metaml overheads incurred exactly evaluation run pc opposed time function resulting pc applied 
cross stage portability cross stage persistence novel feature metaml knowledge exist previous proposals run time code generation 
language feature highly desirable run time code generation systems generally little interest inspecting source level representation programs 
high level program generation cross stage persistence comes price parts generated code fragment may printable 
example consider simple sml nj session val int val fn 

result evaluating rst variable printed back result second 
sml nj compiled implementation result evaluating fn xis structure containing machine code 
structure printed back machine dependent considered implementation detail 
independently structure printed source level representation function generally maintained compilation 
lack high level representations values run time reason inlining cross stage persistent variables generally possible 
example metaml session fn hyi fn val yi 
ai 
xi source level representation fn simply lost point application performed 
loss poses practical problem rst stage multi stage computation performed computer second 
case need port local environment rst machine second 
arbitrary objects functions closures bound local environment embedding cause portability problems 
currently metaml assumes computing environment change stages generally computing integrated system 
current metaml implemen tations lack cross platform portability believe limitation recovered pickling techniques 
linguistic re ection related metaml research linguistic re ection de ned ability program generate new program fragments integrate execution 
metaml descendent turn greatly uenced 
languages support linguistic re ection 
stage languages allowed users provide compile time functions macros directed compiler perform compile time reductions 
emphasized computations representations program datatype de nitions 
generating functions datatype de nitions possible create speci instances generic functions equality functions pretty printers parsers 
facility provided abstraction mechanism available traditional languages 
metaml improves languages adding hygienic variables generalizing number stages emphasizing soundness type system 
sheard nelson investigate stage language purpose program generation 
base language statically typed dependent types generate wider class programs possible metaml restricted stages 
sheard shields peyton jones investigate dynamic type system multi staged programs type obligations staged computations put till run time 
part ii theory multi stage programming multi level specialization gluck rgensen introduced idea multi level bta cient ective alternative self application 
multi level language scheme presentation 
metaml fewer primitives language focus program generation issues bta 
intermediate results printable representation 
metaml cross stage persistence allows intermediate results stages contain constants representation available 
second gluck rgensen demonstrates done ciency comparable level bta 
implemented constraint solving techniques 
underlying language dynamically typed 
gluck rgensen study partial evaluation generalized context inputs arrive arbitrary number times just specialization time run time context ow chart language called graph 
language viewed dynam ically typed multi level programming language 
graph designed human programming language producing automatically program generators 
contributions dissertation emphasising programmers write useful multi stage programs directly appropriate programming language metaml automatic analyses useful strictly speaking necessary multi stage programming 
gluck study issues involved implementation language graph 
syntax graph explicitly captures information necessary specifying staging computation construct annotated number indicating stage executed variables annotated number indicating stage availability 
annotations language motivations studying level annotations metaml 
see appendix 
notable di erence explicit level annotations re ect intended usage time opposed availability time 
availability formalisms generally re ected level type system typing environment 
graph dynamically typed syntax formal semantics language sizable 
programming directly graph require user annotate construct variable stage annotations ensuring consistency annotations user responsibility 
explicit annotations necessarily serious drawback language intended primarily internal language program transformation systems 
believe simplifying language verifying correctness program transformation systems easier 
gluck identi ed language independence internal representation code important characteristic multi stage language 
gluck rgensen continue study graph focusing issue tion data multi level transformation systems self applicable partial evaluation 
advocates graph appropriate representation meta system hierarchies 
essence meta system hierarchy sequence meta programs meta program ma program sequence 
roughly speaking generalization precisely nding speci generalization process nding precise characterization expression terms position hierarchy 
identi es addresses fun problems arise considering hierarchies space consumption problem invariance problem 
space consumption problem arises due possibility encoding object programs multiple times hierarchy 
space consumption problem seen level annotated terms appendix similar spirit graph solution abolished quest distinguishing unencoded encoded terms chapter 
invariance problem arises pro gram transformation invariant encoding operation 
metaml invariance problem roughly comparable transformation works level term continue term promoted 
note problem arise terms unencoded encoded terms syntactically indistinguishable 
graph shows problems described avoided multi level data structures graph 
feature graph highly desirable success multi level transformations generalization data precise regardless involved multi level transformation 
avoiding level annotated terms simplify language remains interesting open question weather distinction unencoded en coded terms applied graph 
furthermore technical development notion generalizations similarities problems substitution arose context metaml reasonable expect reap bene ts level annotations avoided graph 
type systems open closed code typed languages manipulating code fragments typically type constructor open code type constructor closed code :10.1.1.17.4285
languages open code types useful study partial evaluation 
typically provide constructs building combining code fragments free variables allow executing fragments 
able construct open fragments enables user force computations lambda 
executing code fragments languages hard code contain bound identi ers 
contrast languages closed code types advocated models run time machine code generation 
typically provide constructs building executing code fragments allow forcing computations lambda 
follows review languages detail 
nielson nielson gomard jones nielson nielson pioneered investigation multi level languages level functional languages 
developed extensive theory denotational semantics level languages including framework interpretation 
framework allows level language arbitrary possibly partially ordered set 
nielson nielson proposed algebraic framework speci cation multi level type systems 
gomard jones proposed statically typed level language explain workings partial evaluator untyped calculus 
language basis 
allows treatment expressions containing free variables 
treatment object level variables implementation semantics inspired 
multi level languages logical modalities research emphasized pragmatic importance able combine cross stage persistence evaluation lambda symbolic computation able execute code 
section review basic features important statically typed multi level languages closely related 
davies pfenning statically typed multi stage language motivated constructive modal logic 
show curry howard isomorphism modal logic 
show type system equivalent binding time analysis nielson nielson 
language provides closed code type constructor closely related closed type bn language constructs box box correspond roughly close open respectively 
davies extends curry howard isomorphism relation linear temporal logic type system multi level language :10.1.1.16.4975
presents language allows staged expressions contain free variables 
language provides open code type constructor corresponds closely metaml code type 
constructs prev correspond closely metaml brackets escape respectively 
collaboration moggi benaissa sheard author presents aim idealized metaml extends metaml analog box type yielding expressive language simpler typing judgment metaml 
embed languages aim view bn cut version aim expect su ciently expressive purposes multi stage programming 
closed type constructor bn essentially strict version box type constructor aim 
author proposed laziness box type constructor aim type constructor dropped 
motivation proposal follows aim box construct delays argument 
programmer means code types aim closed code open code 
having di erent cause confusion point view multi stage programming manipulating values type hai read closed code open code ofa 
reading cumbersome unnecessarily harder programmer reason computations performed 
reasons bn pragmatic decision closed claim theorem proof identi ed shortcomings statement theorem proof 
correcting embedding metaml simple embedding subtle 
expect embedding hold 
delay argument types hai read simply closed code ofa 
words propose necessity modality asserting closedness delaying evaluation 
di erence aim superset languages studied metaml bn 
hand expect embedded open fragment aim closed fragment 
formal support claim establish strong relation closed code open code types aim necessity modalities modal temporal logic 
embedding aim turned embedding bn 
embedding needs modi ed take account fact closed bn strict delay evaluation argument 
hand embedding metaml aim adapted reasons 
bn full cross stage persistence 
having cross stage persistence simpli es categorical model 
time pragmatic point view cross stage persistence closed types expected su ce 
bn run 
able nd general categorical interpretation construct possible interpret run particular concrete model :10.1.1.39.7201
time pragmatic need run disappears presence safe run natural categorical interpretation 
knowledge rst successful attempt de ne sound type system combining brackets escape safe way executing code language 
combination rst context metaml expressive context aim eventually bn overview multi level languages summary distinguishing characteristics languages discussed 
stages mean level language means multi level 
static typing means rst level checked 
re ection refers presence run construct 
persistence refers presence cross state persistence 
portability refers code generated run time 
facility example nielson nielson gomard jones gluck rgensen gluck metaml aim bn stages xi static typing re ection run eval persistence xi portability closer look aim fig :10.1.1.16.4975

comparative feature set clarify relation metaml multi level languages take closer look syntax type system semantics aim 
adopt uni ed notation types bj 
order productions correspond base types functions open code fragments closed code fragments 
rst language features function closed code types 
typing judgments form jx syntax follows type system ine 

ine super cial di erences type system essentially bn open code type 
metaml aim feature function open code types 
typing judgments form jx natural number called level term 
syntax follows type system 

hei hi hi type system similar metaml cross stage persistence run construct 
words type system metaml achieved addition rules hi rune metaml uses relaxed type rule variables variables bound level lower level 
relaxation cross stage persistence 
furthermore metaml extends syntax rune 
aim extends metaml analog box type yielding expressive language simpler typing judgment metaml 
syntax aim extends metaml follows ej run generalizes run metaml allows additional body ofe satisfy certain typing requirements 
aim essentially union languages described addition run construct generalizing run construct metaml reformulation rules closed type ei fxi ji mg hi ei ei fxi ji mg ei operational semantics aim sub languages ei vi 


box xi ei 
box xi vi 
hei 
hvi 








box unbox 





unbox 
unbox 
hvi ei 
vi xi vi 
hv 
run xi ei 
ei 
vi box xi ei 
box xi vi ei 
vi 
run xi ei 
run xi vi categorical semantics multi level languages moggi advocates category theoretic approach level languages uses indexed categories develop models languages similar stressing formal analogies categorical account phase distinction module languages 
points stateful functions newname semantics formal reasoning hard 
big step semantics dissertation avoids gensym 
points level languages generally equational calculus 
reduction semantics eliminated problem metaml knowledge rst correct presentation multi stage language reduction semantics moggi presents careful categorical analysis interactions logical modalities studied davies pfenning computational monads :10.1.1.28.4059
builds previous study categorical semantics multi level languages greatly uenced design aim bn particular study categorical semantics earlier attempt devise reduction semantics awed :10.1.1.39.7201
level annotated terms su ers complications addressed 
highly instrumental achieving semantically sound integration logical modalities bn level annotations level annotations example russell address paradox pointed frege quine system new foundations logic cardelli type system phase distinction danvy study re ective tower gluck collaborators multi level programming languages 
dissertation experience level annotations useful part predicate classifying terms various levels annotating subterms levels instructive necessarily practical direct reasoning programs source level 
danvy similar experience study re ective tower 
reduction semantics equational theories multi level languages muller studied reduction semantics quote eval context lisp 
muller observed formulation constructs breaks con uence 
reason calculus distinguishes expressions representations expressions 
muller proposes closedness restriction notion reduction eval shows restores con uence 
muller studied reduction semantics calculus extended representations terms notion reduction representations 
muller observed calculus lacks con uence uses type system restore con uence 
muller studies language express object code apart intensional analysis 
wand studied equational theory lisp meta programming construct theory trivial sense rule semantic equality valid 
wand predicted meta programming systems interesting equational theory 
evidenced cbn metaml example system 
history quotation formal logic developed discipline programming languages research inherits techniques 
illuminating review foundational works formal russell viewed father type theory view notion level primordial todays notion types 
logic closely related development dissertation review done context lisp migrating programming languages arena 
quasi quotes 
quine corners quasi quotes formal notation developed logician willard van quine size semantics subtleties involved construction logical formulae 
quine introduced quasi quotes formal logic way distinguishing meaning denoted syntax syntax 
motivations lie primarily fact variables semantically distinct ways 
section excerpts quine original writings largely self explanatory 
greek letter convention quine description state art dealing object programs time greek letter convention 
essay new foundations mathematical logic page quine writes stating de nitions greek letters refer expressions 
letters refer formulas refer variables 
embedded signs belonging logical language refer expression formed embedding expressions referred greek letters 
refer formula formed putting formulas may respective blanks 
expression formula noun describing formula short description formula formed writing left parenthesis followed formula followed stroke followed formula followed right parenthesis greek letter place language discussion provides means discussing language 
rephrase range object language variable names 
range expressions 
note single quotes standard time talking object terms 
problem solution chapter essay vi logic rei cation universals page quine contrasts semantic di erences usage variables expression expression wherep particular name object language say propositional logic discussion 
quine explains 
contrasts basic ways 
variable sentences values construed schematically variable value sense 
second grammatically occupying place names sentences grammatically sentential occupying place sentences 
contrast dangerously obscured usage shows greek ters sentential positions 
usage nonsense special arti cial convention essay concerning embedding greek letters signs logical language 
con usage shorthand substantive result putting variable sentences respective blanks 
greek letters clearly occur noun positions referring variable statements noun turn 
writings example insisted tting misleading usage safety device form modi ed type quotation marks marks rightly suggest ordinary quotation substantive refers expression isolate portions text combined greek letters logical signs oddly construed 
literature quasi quotation marks omitted 
usage logicians take care preserve semantic distinctions exempli ed essay commonly german boldface latin letters greek 
today quine quasi quotes standard tool distinguishing object language terms meta language terms 
see example 
footnotes quotation point numbered respect dissertation meta level quine book object level 
dwelling concrete example problems arise want formal semantics multi level expressions appropriate dissertation 
meta level equation number 
object level page number 
meta level citation number 
lisp back quote comma ideas mathematics logic calculus form programming languages quine quasi quotes 
back quote comma appeared lisp timothy hart introduced macros language 
illustrate behavior back quote comma eval consider simple scheme session define lambda eval steele gabriel write back quote syntax particularly powerful nested 
occurred primarily macro de ning macros coded primarily wizards ability write interpret nested back quote expressions soon surrounded certain 
alan bawden mit acquired particular reputation back quote early days lisp machine 
advent back quote macro mechanisms leap expressive power problems macros fraught kinds scoping problems accidental name capture accompanied special variables 
problem lisp macros time hart mid macro call expands expressions composed symbols attached semantics 
back quote spirit quasi quote quite capture seman tics spirit quine construct quasi quote invented clarify binding issues back quote su ered variety semantic problems 
problems mayhave partly due fact back quote primarily construct conveniently constructing lists fact lists happen represent programs probably somewhat secondary 
worth noting ease programs manipulate lisp encourages meta programming 
noted encoding provide auto matic renaming support needed correct treatment bound variables meta programming systems 
scheme community continued development features 
nearly agreed macro facilities invaluable principle practice looked particular instance sort family secret 
right thing 

clinger rees clari ed problem renaming macros analogy reductions calculus 
particular explained need renaming run time static renaming 
calculus run time corresponds reductions ing corresponds renamings 
calculus kinds reductions interleaved reductions involve duplication re combination potential con ict code 
hygienic macros developed kohlbecker friedman felleisen duba provided means de ning macros needing worry accidental name capture 
bawden gives detailed historical review history quasi quotations lisp :10.1.1.22.1290
comparison metaml lisp metaml brackets escape run analogous lisp back quote comma eval constructs brackets similar back quote escape similar comma run similar eval empty environment 
analogy perfect 
lisp ensure variables atoms occurring back quoted expressions bound rules static scoping 
example plus bind plus scope term produced 
view addressing problem important feature metaml 
view metaml semantics concise formalization semantics lisp constructs static scoping 
view similar spirit smith semantically motivated lisp 
lisp dynamically typed metaml statically typed 
metaml annotations viewed providing simple statically typed macro expansion system 
important note annotations allow de nition new language constructs binding mechanisms expected macro expansion systems 
worth noting hart gensym explicitly avoid capture issues original report macros 
today trick closely associated back quote scheme lisp 
pointed chapter managing renaming manner especially di cult presence functional values 
alleviating need stateful construct meta programming language invaluable bene metaml 
point back quote comma macros lisp 
state airs leads concerns 
non trivial formal semantics restricted context program generation 
pages lisp code 
second way expand parse time lead representation overhead exponential multi level program 
metaml avoids problems direct treatment bracket escape language constructs 
meta programming prolog just similarity representation programs representation data meta programming lisp attractive meta programming prolog attractive 
prolog supports intensional analysis code allows programmer examine alter program clauses satisfy goals 
particularly straightforward clause seen just ordinary prolog structure 
prolog provides built predicates allow programmer construct structure representing clause database add clause represented structure database remove clause represented structure database 
application results experience metaml prolog currently unexplored 
surface common themes 
example prolog data run call predicate 
problems variables available right time show 
prolog implementations relax restriction imposed logic programs goals body clause non variable terms 
meta variable facility allows variable appear goal conjunctive goal body clause 
computation time called variable instantiated term 
treated usual 
variable instantiated comes called error reported 
interesting see problems arising meta programming prolog addressed way similar way wehave addressed basic meta programming questions functional language 
chapter single biggest problem communication illusion taken place 
george bernard shaw chapter review ndings extent support thesis 
outline pose open questions believe signi cance research community 
review dissertation reports results design implementation multi stage programming language metaml 
approach studying metaml formalize semantics type system properties expect enjoy 
doing identi ed variety subtleties related multi stage programming provided solutions number 
results include various forms formal semantics metaml addition sound type system 
study resulted proposal re ned type system re ned view process developing program generators metaml 
chapters metaml promising framework meta programming general staging particular 
staging allows distribute cost computation stage computation 
goal achieved case term rewriting example case concise examples member functions 
experience programming metaml helped recognize multi stage computation simple natural clear computational phenomenon simple requires annotations explain 
natural appears distinct translation important computa tional phenomenon described dissertation 
natural applies principle cbv cbn evaluation strategies 
clear easily described demonstrated mathematical rigor 
emphasize promise multi stage programming exhibits caution current incarnation multi stage programming limitations 
notably term rewriting example needed rewritten cps order allow better staging 
point question cps transformation avoided open 
see section chapter saw direct approach extending simple interpreter cbv lambda calculus multi level language metaml di cult 
hand di culty surprising simple interpreters extended incorporate powerful cally complex features side ects exceptions 
hand di culty surprising essential trick interpreters rei ers rei ers take object level concepts map directly meta level concepts 
example integers mapped integers lambda abstractions mapped lambda abstractions applications mapped applications conditionals conditionals recursion recursion 
multi level fea tures object programs brackets escapes run interpreted naturally rei er style style feature wish interpret counterpart meta language 
prerequisite satis ed multi level features 
chapter deterministic semantics suitable formally specifying semantics metaml 
showed formal type safety property established subset metaml called 
pointed expressivity limitation basic type system metaml proposal avoids problem 
argued proposal extended metaml better match stage programming method 
current practical experience proposed language limited 
chapter studied reduction semantics subset metaml called saw hard limit reduction level metaml hard semantic equality meta level leaking object level 
alternative interpretation observations natural allow semantic equality levels metaml 
essential reason level raw metaml terms local information determined just looking term 
level term determined context 
substitution general cross stage persistence particular forced allow leak higher levels 
leakage rule interpreted desirable phenomenon allow implementations metaml perform wider range semantics preserving optimizations programs 
accept interpretation accept allowing levels need careful introducing intensional analysis 
particular direct deterministic way intensional analysis code lead incoherent reduction semantics equational theories 
summary results summarize key results follows 
programming staging number programs metaml illustrated potential multi stage programming pointed weaknesses approach 
staging metaml promising intuitive process 
main weakness identi ed term rewriting example rewritten cps better staging achieved 

implementation identi ed variety anomalies implementation suggested corrections 
main example dissertation awed treatment hidden free variables proposed solution idea cover 

semantics order understand ensure safety generated programs studied formal semantics metaml styles 
formulations dissertation reduction big step semantics 
reduction semantics proofs con uence soundness cbn case novel independent technical results 

type system identi ed various ways multi stage programs developed examples demonstrated type systems weak strong metaml 

meta programming identi ed coherence turn con uence property violated trying semantic equality intensional structural analysis code metaml 
appraisal results thesis metaml designed language useful developing meta programs program generators 
broke thesis main hypotheses 
metaml useful medium meta programming 
chapter explained idea staging easy see reduce cost setting cbv cbn lambda calculus 
small example applications chapter substantial example chapter 

metaml placed standard formal foundation staging annotations viewed language constructs amenable formal techniques programming languages 
chap ters big step semantics core subset metaml type system 
chapter reduction semantics core subset proved con uent sound cbn case 

metaml particular multi level languages general improved design implementation learned building metaml formal foundations 
chapter identi ed subtle previously unknown problems riddle implementations multi stage languages 
identifying problems direct consequence studying formal semantics metaml 
chapter proposed adding explicit type constructor expressing closedness metaml argued utility supporting multi stage programming metaml 
chapter explained potentially negative ects adding deterministic intensional analysis direct manner metaml 
limitations works dissertation improved number ways 
formal relations established various formulations semantics 
reduction semantics shown respect big step semantics cbv case done cbn case 

implementation validated respect formulations semantics 
candidate big step semantics closest implementation 

proposed extension metaml incorporated implementation implementation develop substantial examples dissertation 
important understand practical implications extensions proposed especially programmer point view 

subject reduction type safety results extended hindley milner phic type system decidability type system light current extensions veri ed 

relationship multi stage programming partial evaluation concepts self application futamura projections addressed dissertation remains 
open problems promising research directions dissertation directed attention important questions relating multi stage computation general metaml particular 
list questions see signi cant 
closedness annotations implicit terms programming language 
particular term language bn verbose lost simplicity core metaml constructs staging 
bn asserting code fragment closed part responsibilities programmer 
remains open question exists statically typed language expressivity bn needs additional constructs realize staging 

avoid need rewriting programs cps staging 
term rewriting example chapter shows optimizations generated code useful 
may possible reduction produce optimal results having user rewrite program cps 
bondorf studied improving binding times resorting explicit cps conversion 
sabry wadler suggests moggi may relevant dealing problem 

metaml compiled traditional functional programming language compilation techniques 
compiling metaml requires staging semantics reveal new design options need pursued understood 
model theoretic interpretation functions provided starting point research past believe case metaml 
furthermore exposing safe run constant programmers eventually new demands controlling behavior new operation pose interesting questions developers compilers supporting construct 
safe run way user appeal higher power compiler developer avoid complex fragile implementation details user necessary specifying asking light weight compilation phase produces machine code quickly heavy weight phase takes longer produces cient code 
compiling memory speed 

modular way supporting heterogeneous meta programming language metaml 
focusing staging aspect meta programming dissertation anumber concrete solutions fundamental problems staging 
mentioned important application meta programming translation 
believe extended fairly natural way allow manipulation multiple di erent object languages time 
particular index code type name language associated syntax special typing rules 
implicit meta language jones see example describing partial evaluation 
believe framework may appropriate dealing run time code genera tion 
run time code generation concerned cient generation specialized machine code run time 
compiled implementation metaml provide version safe run generates machine code implicitly assumed making calls compiler generally considered fast run time code generation 
machine code considered typed language believe incorporated neous metaml setting 
ongoing research orts typed assembly languages possibility far fetched 

practical sound type systems expressing tag rei ers 
chapter ex subtleties implementing language metaml context interpreter described essentially rei er 
interpreters great utility staged total maps object programs meta programs 
meta language compiled implementation rei ers provide simple means implementing compilers languages similar sense syntactically sugared subsets meta language 
problem remains interpreters chapter map object programs meta programs datatype carrying meta programs 
tags datatype introduce level run time overhead necessary object program typed 
currently possible express tag rei er untyped metaml typable metaml type system 
problem nding appropriate type system allow express tag rei ers remains open 

practical theoretically sound approaches allowing specify opti metaml code 
pointed con ict allowing optimizations object code intensional analysis 
obvious problem associating domain speci optimization speci instances code datatype 
seman tics datatype de ned modulo optimizations optimizations applied compiler non deterministically furthermore practical statically veri able methods establishing con uence set rewrite rules may possible simplify semantics domain speci code type 
appendix calculus level annotations raw develops jaw quietly 
ogden nash appendix presents alternative approach reduction semantics metaml 
explored approach develop fully substantially larger calculus chapter 
appendix explains detail working subject reduction lemma guide helped arrive type system metaml 
language avoid problems discussed chapter introduce bubbles language levels higher means explicitly controlling elimination escapes 
furthermore build simple observation set expressions set values language de ned follows ijx mutual recursion de nition strictly necessary seen chapter de ne expressions rst values compactness de nition pay extend core language syntactic constructs 
resulting multi level calculus called syntax je ij rune ji jx je jx ij rune jx values level integers lambda terms code fragments 
note speci ed code fragments bubbles 
primary role bubbles ensure level escapes code value 
important note re ned notion level take bubbles account 
level term number surrounding brackets surrounding escapes bubbles 
intuitively keeping track re ned notion levels terms allow deduce exact state rebuilding term reached 
illustrate point concrete example section notation simply index clear context 
notions reduction 
calculating bubbles wehave structure terms direct reduction sensible manner need contextual information 
basic notions reduction language 


rt rule essentially restricted level extra precaution taken de nition substitution preserve level level higher body lambda term 
denotes special notion substitution treatment chapter barendregt convention free bound variables 
essence convention states set terms proof de nition bound variables chosen di erent free variables 
nx fv rune run promotion total function inductively follows hei rune rune non standard feature de nition substitution case variables levels higher 
case arises exactly cross stage persistent variable eliminated 
example notion level allows terms asx hxi 
non standard notion substitution sophisticated formedness conditions 
particular approach require cross stage persistence explicit language implicit complicate formal treatment simplify 
bubble reductions come main feature calculus set reduction rules mimic behavior rebuilding functions 
reduction rules start leaves delayed term propagating bubble upwards 



en 
tx 

rune 
rune intuitively bubble term assert free top level escapes 
key concept delayed term free top level escapes treated normal program previous level 
note bubble reductions generate bubble surrounding term level annotation case integers variables bubbles surrounding subterms 
term generate surrounding bubbles left term reaches level level applicable left term 
deriving type rule bubble run question synthesis type system language described systematic way approaching question 
starting type system brackets escapes explain arrive extra rules bubble run analysing reduction rules 
type system judgment type environment types environments de ned follows bj 
jhi jx unusual thing de nition bindings environments 
explain bubble reductions motivate particular generalization 
need simple operations environments increment decrement respectively indices bindings extra rules needed follows bubble hi rune run trying prove subject reduction language provides concrete motivation typing rules 
subject reduction lemma says reduction preserves typability 
words knowing left hand side reduction typable able show right hand side reduction typable 
follows explain provability property helped synthesising new type rules 
bubble 
bubble reduction variables operationally aimed capturing fact variable free escapes rule basis developing rules untyped language 
reduction rules bubble potential source di erent insights type rule bubble look 
crucial looking insights pick simplest rule suggest concrete constraint 
case bubble rule variables 
important feature rule involve bubbles left hand side 
true rule integers rule integers involve environment 
consider exactly information available know left hand side bubble rule variables typable 
words know holds 
know want general left hand side typable 
precisely wewant sure typable environment level type 
words want able prove wewant nd uniform way inferring result 
notion uniformity hard de ne take mean simple way 
concretely schema 
new rule schema consider question simplest transformations environments types ll missing parts succeed proving concrete problem type preservation bubble reduction variables 
rule variables follow derivation tree schema level variable rule get simpler equation 
var schema 
recalling know left hand side rule see ll schema 
propagate information back new rule schema get concrete bubble rule concrete bubble rule argued far rule holds subject reduction hold 
useful rule rule variables 
arrive useful rule candidate generalize occurrence arbitrary expression get bubble tentative subject reduction test validity general rule 
rule show bubble reductions preserve typing note run ignoring presence type rule 
progress promising road completely justifying rule requires ensuring preserves substitutivity eventually safety language 
promising bubble rule rules involve run bubble infer uniform schema run way done bubble 
subject reduction consolidate observations section formal subject reduction lemma 
summarizes language study section exception lengthy de nition non standard notion substitution 
lemma tells term typable level remains typable level 
furthermore increase level subset variables environment term typable 
lemma promotion lemma promotion lemma generalized substitution corollary substitution theorem subject reduction cbn con uence key observation new calculus promotion performed substitution con uence bubbles allow recover con uence 
example reconsider example section syntax reductions je ij rune ji jx je jx ij rune jx types type environments type rules var hei hi brk 

ete 
rte 


en 
tx 

rune 
rune bj 
jhi jx int int lam ne ne hi esc bubble fig 

reduction semantics type system app hi rune run fn hx fn fn 
saw perform outermost redex get hfn fn redices left 
bubble reductions allow rst derive hfn fn hfn fn hfn fn recovering desired redex perform get hfn furthermore reduction sequences reduced common term fn lemma formalizes claim recover level redices term term promoted substitution 
lemma property goal get carefully restricted form levels higher 
expect calculus con uent report formal proof property 
report formal proof con uence concise calculus section 
studying language allowed illustrate carefully restricting reductions yield promising calculus metaml 
large number rules uses non standard notion substitution 
features inconvenient pencil reasoning 
language smaller set reduction rules uses standard notion substitution 
intuitively moved burden recognizing piece code free top level escapes object language back meta language tracks freedom top level escapes bubbles tracks freedom top level escape testing membership bubbles introduced level annotations object level codi cation meta level concept gone full circle attempting exploit meta level concept levels identi ed fundamental meta level concept freedom top level escapes 
level annotations noted level annotations highly illuminating suggest appropriate inside member set values level 
generally true 
fact level annotations get way unifying set set important feature 
big step semantics level annotations bubbles determinism big step semantics alleviate need explicit level annotations bubble construct 
big step semantics toy language explicit level annotations terms 
de ning big step semantics language level annotations done essentially way verbose 
particular explicitly pass level annotation baggage 
de ning big step semantics require adding rule says rebuilding bubble expression idempotent 
expect big step semantics explicit bubbles superior performance bubbles idempotence rule rebuilding bubbles allow redundant rebuilding 
semantics largely unexplored 
bibliography barendregt lambda calculus syntax semantics revised ed 
north holland amsterdam 
barendregt lambda calculi types 
handbook logic computer science abramsky gabbay maibaum eds 
oxford university press oxford 
bawden quasiquotation lisp :10.1.1.22.1290
acm sigplan workshop partial evaluation semantics program manipulation san antonio jan pp 

invited talk 
benaissa lescanne degli calcu lus explicit substitutions preserves strong normalisation 
journal functional programming sept 
benaissa moggi taha sheard categorical analysis multi level languages extended :10.1.1.39.7201
tech 
rep cse department computer science oregon graduate institute dec 
available 
benaissa moggi taha sheard logical modalities multi stage programming 
federated logic conference floc satellite workshop intuitionistic modal logics applications july 
press 
bondorf self applicable partial evaluator term rewriting systems 
tapsoft 
proceedings theory practice software development barcelona spain mar lecture notes computer science springer verlag pp 

bondorf self applicable partial evaluation 
phd thesis university copenhagen 
bondorf improving binding times explicit cps conversion 
acm conference lisp functional programming 
san francisco california june pp 

cardelli 
type systems 
computer science engineering handbook 
crc press 
cardelli phase distinctions type theory 
unpublished manuscript 
available online www luca demon uk bibliography html 
viewed august 
cardelli typeful programming 
formal description programming concepts neuhold paul eds ifip state art reports 
springer verlag new york pp 

clinger rees macros 
conference record th acm symposium principles programming languages popl orlando jan acm press pp 

clocksin mellish programming prolog 
springer verlag 
consel danvy better support static data ow 
functional programming languages computer architecture cambridge aug vol 
lecture notes computer science springer verlag pp 

curry feys combinatory logic volume north holland amsterdam 
second printing 
danvy bridge re ection partial evaluation 
partial evaluation mixed computation bjorner ershov jones eds north holland pp 

danvy type directed partial evaluation 
acm symposium principles pro gramming languages florida jan acm press pp 

danvy intensions extensions re ective tower 
pro ceedings acm conference lisp functional programming acm press pp 

danvy palsberg essence eta expansion partial evaluation 
lisp symbolic computation 
danvy palsberg eta expansion trick 
tech 
rep rs university aarhus aarhus aug 
davies temporal logic approach binding time analysis :10.1.1.16.4975
proceedings th ieee symposium logic computer science new brunswick july ieee computer society press pp 

davies pfenning modal analysis staged computation 
rd acm symposium principles programming languages popl st petersburg beach jan pp 

dershowitz computing rewrite systems 
information control 
di cosmo isomorphisms types calculus information retrieval language design 
birkhauser 
engler hsieh kaashoek language high level cient machine independent code generation 
conference record popl rd acm sigplan sigact symposium principles programming languages st petersburg beach jan pp 

friedman wand rei cation re ection metaphysics 
confer ence record acm symposium lisp functional programming austin aug pp 

gluck hatcliff rgensen generalization hierarchies online pro gram specialization systems 
logic program synthesis transformation vol 
lecture notes computer science springer verlag pp 

gluck rgensen cient multi level generating extensions program spe 
programming languages implementations logics programs plilp swierstra hermenegildo eds vol 
lecture notes computer science springer verlag pp 

gluck rgensen fast binding time analysis multi level specialization 
perspectives system informatics bj rner broy eds vol 
lecture notes computer science springer verlag pp 

gluck rgensen automatic program generator multi level special ization 
lisp symbolic computation 
gomard jones partial evaluator untyped lambda calculus 
journal functional programming jan 
gunter semantics programming languages 
mit press 
hatcliff danvy thunks calculus 
journal functional program ming may 
hatcliff gluck reasoning hierarchies online specialization systems 
partial evaluation vol 
lecture notes computer science springer verlag pp 

hindley basic simple type theory vol 
cambridge tracts theoretical computer science 
cambridge university press cambridge 
hook sheard semantics compile time re ection 
tech 
rep cse oregon graduate institute 
available 
jones mix years 
proceedings acm sigplan symposium partial evaluation semantics program manipulation june acm press acm press pp 

jones writing interpreter specialisation 
partial evaluation vol 
lecture notes computer science springer verlag pp 

jones gomard sestoft partial evaluation automatic program generation 
prentice hall 
jones sestoft experiment partial evaluation generation compiler generator 
rewriting techniques applications vol 
lecture notes computer science springer verlag pp 

scherlis compilers staging transformations 
thirteenth acm symposium principles programming languages st petersburg florida acm press pp 

kieburtz mckinney bell hook lewis oliva sheard smith walton software engineering experiment software component generation 
th international conference software engineering mar pp 

kohlbecker friedman felleisen duba hygienic macro expansion 
acm conference lisp functional programming aug 
leone lee deferred compilation automation run time code genera tion 
tech 
rep cmu cs carnegie mellon university dec 
turbak calculus link time compilation extended 
unpublished manuscript 
way turbak wellesley edu june 
maier warren computing logic logic programming prolog 
benjamin cummings publishing 
milner theory type polymorphism programming 
journal computer system sciences 
milner tofte harper macqueen de nition standard ml revised 
mit press 
mitchell foundations programming languages 
mit press cambridge 
mogensen cient self interpretation lambda calculus 
functional programming july 
moggi notions computation monads 
information computation 
moggi categorical account oftwo level languages 
mathematics foundations programming semantics elsevier science 
moggi taha benaissa sheard idealized metaml simpler expressive includes proofs 
tech 
rep cse ogi oct 
available 
moggi taha benaissa sheard idealized metaml simpler expressive 
european symposium programming esop vol 
lecture notes computer science springer verlag pp 

extended version appears 
muller lisp representation independent dialect lisp reduction seman tics 
acm transactions programming languages systems oct 
muller staging calculus application veri cation translators 
conference record popl st acm sigplan sigact symposium principles programming languages portland jan pp 

nielson program transformations denotational setting 
acm transactions programming languages systems july 
nielson correctness code generation level meta language 
proceedings european symposium programming esop saarbrucken mar vol 
lecture notes computer science springer pp 

nielson level semantics interpretation 
theoretical computer science dec 
nielson nielson level semantics code generation 
theoretical computer science jan 
nielson nielson level functional languages 
cambridge tracts theoretical computer science 
cambridge university press cambridge 
nielson nielson multi level lambda calculi algebraic description 
partial evaluation international seminar dagstuhl castle germany selected papers vol 
lecture notes computer science springer verlag pp 

nielson nielson prescriptive framework designing multi level lambda calculi 
proceedings symposium partial evaluation semantics program manipulation amsterdam june acm press pp 

okasaki purely functional data structures 
phd thesis school computer science carnegie mellon university 
oregon graduate institute technical reports 
box portland usa 
available online ftp cse ogi edu pub tech reports readme html 
viewed august 
paulson ml working programmer second ed 
cambridge university press 
plotkin call name call value lambda calculus 
theoretical computer science 
quine mathematical logic revised ed 
harvard university press 
published norton 
quine set theory logic 
harvard university press cambridge 
quine logical point view second revised ed 
harper row 
elements functional programming 
international computer science series 
addison wesley wokingham 
rees clinger abelson adams iv brooks dybvig friedman halstead hanson haynes kohlbecker pitman sussman wand revised report algorithmic language scheme 
tech 
rep ai memo mit press nov 
reynolds de nitional interpreters higher order programming languages 
acm national conference acm pp 

reynolds de nitional interpreters higher order programming languages 
higher order symbolic computation 
reprinted proceedings th acm national conference 
sabry wadler re ection call value 
proceedings acm sigplan international conference functional programming philadelphia may pp 

sheard user guide compile time re ective programming language 
tech 
rep coins dept computer information science university mas 
sheard automatic generation structure operators 
acm transac tions programming languages systems oct 
sheard guide compile time re ective ml 
available www cse ogi edu sheard html 
viewed august oct 
sheard type parametric programming 
tech 
rep cse oregon graduate institute 
available 
sheard atype directed line partial evaluator polymorphic language 
proceedings symposium partial evaluation semantics program manip ulation amsterdam june pp 

sheard nelson type safe abstractions program generators 
tech 
rep cse oregon graduate institute 
available 
shields sheard jones dynamic typing staged type ference 
proceedings th acm sigplan sigact symposium principles programming languages jan pp 

smaragdakis batory transformation library data structures 
usenix conference domain speci languages oct pp 

smith re ection semantics procedural language 
phd thesis massachusetts institute technology jan 
smith re ection semantics lisp 
acm symposium principles programming languages jan pp 

smith kids semi automatic program development system 
ieee transactions software engineering special issue formal methods sept 
steele jr gabriel evolution lisp 
proceedings conference history programming languages new york apr wexelblat ed vol 
acm sigplan notices acm press pp 

stemple stanton sheard morrison kirby fegaras cooper connor atkinson type safe linguistic re ection generator technology 
tech 
rep fide esprit bra project fide 
sterling shapiro art prolog second ed 
mit press cambridge 
taha benaissa sheard multi stage programming type safety 
th international colloquium automata languages programming aalborg july vol 
lecture notes computer science pp 

taha hook anatomy component generation system 
international workshop principles software evolution kyoto apr 
taha sheard facets multi stage computation software architectures 
tech 
rep cse oregon graduate institute 
available 
taha sheard multi stage programming explicit annotations 
proceed ings acm sigplan symposium partial evaluation semantic program manipulations pepm amsterdam acm pp 

extended revised version appears 
taha sheard metaml multi stage programming explicit annotations 
theoretical computer science press 
takahashi parallel reductions calculus 
information computation apr 
veldhuizen templates partial evaluation 
acm sigplan workshop partial evaluation semantics program manipulation san antonio jan danvy ed university aarhus dept computer science pp 

wadler taha macqueen add laziness strict language odd 
proceedings acm workshop ml baltimore sept pp 

wand theory trivial 
lisp symbolic computation 
wand friedman mystery tower revealed non re ective description re ective tower 
meta level architectures re ection maes nardi eds 
elsevier science pp 

whitehead russell principia mathematica 
cambridge university press cambridge 
lee pfenning run time code generation modal ml 
proceedings acm sigplan conference programming language design implementation pldi montreal june pp 

winskel formal semantics programming languages 
computing series 
mit press feb 
wright felleisen syntactic approach soundness 
information computation nov 
biographical note walid taha born april th egypt 
spent school year attending corvallis high school corvallis oregon 
completed oxford university general certi cate education ordinary level examinations kuwait english school kuwait 
walid went study rst mechanical engineering electrical engi neering eventually computer engineering kuwait university 
college studies number times brown baden switzerland sion dr karl 
kuwait university prof sarwar programming languages course introduced walid functional programming 
gulf con ict week vacation turned year university alexandria schlumberger alexandria egypt linz austria brown baden switzerland 
eventually walid back university nished senior project compiling lisp pascal completed science computer science engineering 
graduation walid spent months institut bremen germany studying german scholarship german government 
returned kuwait contemplate 
got tired joined masters program electrical engineering semester worked software engineer ce vice president planning airs kuwait university 
year prof kuwait university sabbatical oregon graduate institute 
prof obviously having fun ogi insisted walid apply phd program 

ogi prof david maier math look interesting 
prof james hook walid spending years life working semantics 
walid advisor prof tim sheard starting intriguing creature called metaml 
doctoral studies oregon graduate institute beaverton oregon walid months lucent bell laboratories hill new jersey working dr phil wadler implementing wadler proposal lazy ml datatypes 
currently walid post doctoral fellow department computing sciences chalmers university sweden 

