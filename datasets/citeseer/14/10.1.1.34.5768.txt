foil midterm report quinlan cameron jones basser department computer science university sydney sydney australia quinlan cs su oz au cs su oz au foil learning system constructs horn clause programs examples 
summarises development foil early evaluates effectiveness non trivial sequence learning tasks taken prolog programming text 
tasks handled reasonably experiment highlights weaknesses current implementation 
areas research identified 

principal differences zeroth order order supervised learning systems form training data way learned theory expressed 
data zeroth order learning programs assistant cestnik kononenko bratko cart breiman friedman olshen stone cn clark niblett quinlan comprise preclassified cases described values fixed collection attributes 
systems develop theories form decision trees production rules relate case class attribute values 
contrast input order learners usually contains ground assertions number multi argument predicates relations learned theory consists logic program restricted horn clauses similar predicts vector arguments satisfy designated predicate 
early order learning systems mis shapiro marvin sammut banerji notion order proof 
partial theory modified insufficient prove known fact able mis prove known fiction 
dependence finding proofs meant systems relatively slow time consumed theorem proving mode able analyse small training sets 
systems foil quinlan golem muggleton feng abandoned proof algorithms efficient methods golem uses plotkin relative general generalisation form clauses foil uses divide cover strategy adapted zeroth order learning 
approaches proved efficient robust enabling larger training sets analysed learn complex programs 
systems cham focl pazzani brunk silverstein pazzani kibler ile rouveirol forte richards mooney contain elements proof empirical approaches 
examines foil summarising development years 
outlining key features describe experiment designed evaluate program writing ability problems human prolog students expected able master 
surprisingly foil difficulty problems 
discuss foil shortcomings tell research needed extend useful logic programming tool 

foil nutshell foil system learning function free horn clause definitions relation terms relations 
program slightly flexible learn relations sequence allows negated literals definitions standard prolog semantics employ certain constants definitions produces 
foil input consists information relations target relation defined horn clause program 
relation set tuples constants belong relation 
target relation tuples known belong relation alternatively closed world assumption may invoked state tuples specified belong target relation 
tuples known target relation referred phi tuples relation psi tuples 
learning task find set clauses target relation accounts phi tuples covering psi tuples 
basic approach foil aq covering algorithm michalski hong lavrac 
starts training set containing phi psi tuples constructs function free horn clause explain phi tuples removes covered phi tuples training set continues search clause 
clauses covering phi tuples reviewed eliminate redundant clauses reordered recursive clauses come non recursive base cases 
perfect definitions exactly match data possible particularly real world situations incorrect values missing tuples expected 
get problem foil uses encoding length heuristics limit complexity clauses programs 
final clauses may cover phi tuples covering psi tuples 
see quinlan details 
finding clause foil starts left hand side clause specialises adding literals right hand side stopping psi tuples covered clause encoding length heuristics indicate clause complex 
new variables introduced added literals size tuples training set increases tuple represents possible binding variables appear partially developed clause 
target relation arguments process finding clause definition summarised follows ffl initialise clause local training set phi tuples covered previous clause psi tuples 
ffl contains psi tuples complex find literal add right hand side clause 
form new training set tuple binding new variables introduced literal delta tuple obtained concatenating satisfies add label phi psi replace ffl prune clause removing unnecessary literals 
foil incorporates simple backup mechanism clause building process essentially greedy search literal added clause alternative literals usually investigated 
key question determine appropriate literals append developing clause 
foil uses criteria literal help exclude unwanted psi tuples training set introduce new variables may needed literals 
literals kind called determinate literals included primarily introduce new variables 
choosing literals consider partially developed clause lm gamma containing variables tuple training set looks hc constants fc represents ground instance variables clause 
consider happens literal lm form added right hand side 
literal contains new variables arity new training set increase denote number variables new clause 
tuple new training set form hd constants fd properties ffl hd tuple ffl hd relation tuple extension tuples ground instance represents satisfies literal 
tuple gives rise zero tuples phi psi label tuple copied ancestor tuple denote number phi tuples number effect adding literal lm assessed information perspective follows 
information conveyed knowledge tuple label phi gammalog jt similarly 
gained information adding literal lm clause tuples extensions total information gained phi tuples gain lm theta gamma foil explores space possible literals added clause step looking greatest positive gain 
form gain metric allows significant pruning literal space foil usually rule large subspaces having examine literals 
potential literal contains new variables possible compute maximum gain obtained replacing existing variables 
maximum gain literal considered literals resulting replacements need investigated 
form pruning involves literals target relation 
want foil produce non executable programs fail due infinite recursive looping recursive definitions screened carefully 
recursive literals lead problems barred consideration described 
determinate literals clauses reasonable definitions inevitably contain literals zero gain 
suppose instance objects value property literal defines value object literal represents mapping tuple give rise exactly tuple gain literal zero 
imagine literal value supplied possible values literal negative gain 
previously defined variable new variable important difference adding literals clause produce new training set exactly size second may exclude phi tuples may cause number tuples training set grow 
key insight underlying determinate literals idea inspired golem determinate terms muggleton feng value new variable forced determined values existing variables 
precisely suppose incomplete clause lm gamma associated training set 
literal lm determinate respect partial clause lm contains new variables exactly extension phi tuple extension psi tuple satisfies lm idea lm added clause phi tuple eliminated new training set larger foil notes determinate literals searching literals 
maximum possible gain literal excludes psi tuples phi tuples notation gain theta 
literal gain close maximum possible gain foil adds determinate literals clause tries 
may literals useful 
foil incorporates clause refining mechanisms remove unnecessary literals clause completed ultimate penalty approach 
phi tuples eliminated training set grow computational cost associated new variables corresponding increase space subsequent possible literals 
precisely enlargement space addition determinate literals intended achieve 
potential runaway situation determinate literals cycle give rise determinate literals ad infinitum 
circumvent problem foil borrows idea golem 
depth variable determined occurrence clause 
variables left hand side clause depth variable occurs literal depth greater greatest depth previously occurring variable literal 
placing upper limit depth variable introduced determinate literal rule indefinite runaway 
limit reduce class learnable programs 
stringent requirement determinate literal uniquely satisfied phi tuples means runaway situation foil default depth limit rarely reached 
literal forms moving areas covered extensions foil 
concerns kinds literals appear right hand side clause 
early versions foil considered literals forms ffl relation variables occurred clause ffl compare values existing variables 
forms added 
certain constants identified theory constants appear explicitly definition 
examples include constant representing null list list processing tasks integers tasks involve natural numbers 
theory constant foil consider literals forms variable appropriate type appears earlier clause 
minor addition equivalent declaring special relation constant fact extension implemented way 
second extension substantial 
relations encountered real world limited discrete information commonly include numeric fields 
imagine simple relations atomic weight provides numeric atomic weight element quote detailing buy sell prices commodity step able exploit numeric information foil includes literal types allow existing variable numeric values compared threshold foil variable type 
extension falls long way short prolog facilities allow continuous value computed clause permit bound numeric values conditions right hand side clause 
managing recursion recursive theories expressive powerful ability learn recursive programs principal advantages order systems golem foil 
increase expressiveness counterbalanced care taken avoid nonsensical recursion 
illustration consider task learning program multiplication non negative integers terms addition decrement 
relations mult meaning theta plus dec gamma 
suitable definition multiply mult mult dec plus mult clause captures identity theta gamma theta definition intuitively behaved sense terminate 
hand simpler definition mult mult clearly lead infinite recursive loop 
foil biased finding simpler definitions eschew favour 
short answer clause developed recursive literals satisfy certain criteria inclusion right hand side 
particular recursive literal right hand side judged head clause ordering literals 
earliest version foil method discovering ordering constants appearing tuples 
method guaranteed single clause lead recursive loop calling directly 
order discovery removed releases relied user specifying constants type appropriate order 
order discovery mechanisms reinstated versions method ordering recursive literals generalised guarantee applies sets clauses single relation just single clause 
meant give informal sketch idea complete discussion available cameron jones quinlan 
returning multiply example see clause general case mult dec plus mult lead infinite recursion literal dec guarantees mult mult intuitive ordering mult literals 
foil assumes relations provided task behave dec establishing ordering arguments attempts identify 
relation pair arguments type foil asks orderings constants type consistent hypothesis answers questions determined foil establishes single definitive ordering constants type number inequalities maximised 
fixed ordering constants type allows determine rankings pairs variables incomplete clause 
clause contains variables training set consists tuples constants hd ax jt belong type ai comes aj constant ordering type 
inequalities pairs variables extended ordering literals involving predicate variables 
broad terms denote variables ff ff ff ff fi fi ff ff fi fi fl fl 
ff fi fl denote argument positions ordering variables clause specify particular ordering literals involving suppose incomplete definition relation consists zero completed clauses partial clause 
recursive literal added right hand side developing clause values ff fi ffl literal left hand side clause ffl true recursive literals completed clauses 
may sound complex implementation simple efficient 
restriction recursive literals right hand side clauses prevents infinite recursive loops due definition calling directly exclude complex recursive definitions ackermann function ack dec ack dec ack dec ack dec dec ack ack case ordering literals foil ack ack definition dec gives second third clauses dec third clause gives recursive literals clauses heads clauses 
consequently definition guaranteed terminate invoked ground instances improved definitions programs foil depend greedy search occasionally follow unprofitable paths leading poor definitions definitions 
foil backup mechanism designed ameliorate condition restarting search saved backup points 
problem poor definitions difficult circumvent 
earliest version foil incorporated post processing definitions unnecessary literals excised finished clauses redundant clauses removed complete definitions 
numerous superfluous literals clause pruning consume noticeable amount time extension fast heuristic pruning method reverts slow sure algorithm event failure 
versions additional mechanisms producing better clauses 
happens possible literals added clause considered literal complete clause literal higher gain selected 
search way leading eventually clause inferior produced chosen 
foil remembers best complete clause obtained different choice literal point 
clause complete system checks see remembered clause final clause uses remembered clause 
extension requires hardly additional computation responsible improved definitions tasks 
observed cases non recursive literal chosen complete clause involves variables appear left hand side clause 
literal clearly appeared righthand side 
right hand side contains literals may effect making clause specific 
circumvent possibility clause starting single literal right hand side 
final polishing involves reordering clauses 
clauses making definition sifted remove redundancies non recursive base case clauses moved front appear recursive clauses 

experiment evaluations learning systems involve limited amount background information just required task hand carefully chosen training examples 
experiments demonstrate feasibility certain types learning address usefulness learning system practical applications usually large amount irrelevant information training examples come neutral unbiased source 
step pragmatic evaluation started ivan bratko known text prolog programming artificial intelligence bratko 
chapter book introduces programs manipulating lists includes set student exercises 
conducted trials see foil learn expository programs exercises order appear book omitting exercises quite different 
deals lists specific monkey bananas problem flatten uses structured lists 
brief summary problems attempted member element list conc appending gives list member member conc available element ditto conc del deleting occurrence gives member member del available insert inserting gives sublist sublist permutation permutation list odd number elements relations defined reverse reverse list palindrome list palindrome palindrome reverse shift rotating elements left gives translate results translating element element mapping subset subset set contains odd numbered elements contains numbered elements included additional relation components meaning list head tail corresponds prolog built hjt notation lists 
program relations encountered previously available background knowledge irrelevant relations confuse foil search 
attempted assemble training examples unbiased manner 
trials repeated universes defined ffl lists containing elements element set ffl similar lists containing elements 
trial foil phi tuples relevant universe relation 
example phi tuples conc include case lists contains elements 
relations book defined restricted subclasses lists sets case subset lists repetitions case permutation 
relations defined lists 
psi tuples relation learned generally complement phi tuples 
second universe relations enormous number tuples conc foil option selects random sample psi tuples keep 
relations affected conc psi tuples del insert translate sublist permutation reverse shift 
foil allowed seconds decstation problem 
book introduced negation stage negated literals barred definitions 
foil options default values including default memory limit tuples training set 
outcomes experiment summarised table 
result column means correct definition obtained program book 
notation restricted indicates definition correct universe examples defined give incorrect results lists arbitrary length 
common problem restricted definitions incorrect base case relies fortuitous properties limited domain 
instance definition reverse universe reverse conc sublist reverse components reverse conc conc second recursive clause correct 
odd looking base case exploits fact lists length sublist result conc ing length ensures length 
course clause correct short lists task tuples result time phi psi secs member conc member restricted del time limit insert member sublist permutation unsound mutual recursion unsound mutual recursion reverse restricted restricted palindrome palindrome restricted restricted shift translate time limit time limit subset restricted restricted restricted erroneous table results learning programs definition produced foil universe error lists restricted universe considered 
foil relies psi tuples show generalisations 
task training set included psi tuples happened reveal clause defective 
underlines heuristic nature learning incomplete information 
apart running time problem occurred task required definitions 
definitions del components 
definition correct lead recursive looping longer definition shorter 
highlights fine print foil guarantee recursive soundness individual definition lead problems definitions invoking 

discussion results experiment described mixed 
encouraging see foil find correct definitions small programs encouraging remember students expected able produce matter course 
particular fact definitions tend restricted highlights foil sensitivity irrelevant information 
example superfluous relations removed correct definition subset subset subset components components subset subset components subset seconds 
cause concern recursive definitions require near complete sets phi tuples 
consider simplest task member universe interesting observe effect deleting single phi tuple changing psi tuples corresponding item missing information misinformation tuple form hx element list ffl effect length 
ffl length recursive continuation affected 
foil finds correct definition adds extra clause cover apparent special case 
phi tuples deleted random resulting definition correct contained superfluous clauses 
tasks experiment property defined horn clause program negated literals 
negated literals allowed definition language foil weak capture ideas 
illustration order expression likes oe happy written prolog definition cut establishment ancillary concept 
similarly program recognise sentences language requires extra concept sequence seq elt prolog programmer see immediately define subsidiary predicate 
foil invent new relations kind apply negation individual literals 
consequently quite simple concepts foil find general definitions matter examples 

title suggests foil development 
current form experimental vehicle exploring ideas learning practical tool constructing substantial logic programs 
way id circa experimental program required lot practical tool obtained 
shortcomings system mentioned previous section 
generalising slightly identify features required robust system learning recursive logic programs ffl construction new predicates logic programmers frequent predicates appear problem statement 
required express program horn clause form frequently ancillary predicates program simpler efficient 
foil facilities inventing new predicates promising research muggleton buntine kietz morik suggests facilities may able grafted 
ffl strategy constructing programs human logic programmers taught get simplest base case develop general recursive case 
kind strategic approach missing foil just attempts bite phi tuples possible clause 
super greedy strategy lead problems kind illustrated reverse example 
simple base case reverse foil greedily tries extend include single element lists leading restricted definition section 
ffl selective relations moment learning task harder foil simply including irrelevant relations increasing number literals examined step 
hypothesise practical system learning logic programs employ characterisation remembered relation relation considered prior reason believe may 
ffl incomplete training sets near complete sets phi tuples available constructing recursive definitions relations context real world problems 
practical training sets small problems involving synthesis novel theory tuples selected form final definition mind 
foil currently learn non recursive definitions sparse training cases difficulty recursive theories conditions 
ffl extended treatment numeric fields order systems addressed issue continuous valued information 
foil numeric fields limited thresholding comparisons known values computing new values 
practical prolog programs involve computation learning systems intended generate programs come computational clauses 
inclusion theory constants tests numeric values foil express theory derivable zeroth order learning systems 
carried initial tests running foil zeroth order attribute value data single relation argument attribute 
foil explores strictly larger hypothesis space systems surprising foil slower 
interesting see increased search results accurate theories learned systems 
current version foil available anonymous ftp file name pub sh integer research supported australian research council research agreement digital equipment 

bratko 

prolog programming artificial intelligence 
wokingham uk addison wesley 

breiman friedman olshen stone 

classification regression trees 
belmont wadsworth international 

cameron jones quinlan 

avoiding pitfalls learning recursive theories draft 
available anonymous ftp file pub recurse tex 
cestnik kononenko bratko 

assistant knowledge elicitation tool sophisticated users 
bratko lavrac eds 
progress machine learning 
sigma press 

clark niblett 

induction noisy domains 
bratko lavrac eds 
progress machine learning 
sigma press 

kietz morik 

polynomial approach constructive induction structural knowledge 
machine learning appear 



efficient learning logic programs non determinate non discriminating literals 
proceedings eighth international workshop machine learning evanston illinois 

michalski hong lavrac 

multipurpose incremental learning system aq testing application medical domains 
proceedings fifth national conference artificial intelligence philadelphia 

muggleton buntine 

machine invention order predicates inverting resolution 
proceedings fifth international conference machine learning ann arbor 

muggleton feng 

efficient induction logic programs 
proceedings conference algorithmic learning theory tokyo 

pazzani brunk silverstein 

approach learning relational concepts 
proceedings eighth international workshop machine learning evanston illinois 

pazzani kibler 

utility knowledge inductive learning 
machine learning 

quinlan 

learning logical definitions relations 
machine learning 

quinlan 

determinate literals inductive logic programming 
proceedings twelfth international joint conference artificial intelligence sydney 

quinlan 

programs machine learning 
san mateo morgan kaufmann 

richards mooney 

order theory revision 
proceedings eighth international workshop machine learning evanston illinois 

rouveirol 

completeness induction procedures 
proceedings eighth international workshop machine learning evanston illinois 

sammut banerji 

learning concepts asking questions 
michalski carbonell mitchell eds 
machine learning artificial intelligence approach vol 
los altos morgan kaufmann 

shapiro 

algorithmic program debugging 
cambridge ma mit press 
