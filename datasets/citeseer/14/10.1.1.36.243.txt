klaim kernel language agents interaction mobility rocco de nicola ferrari rosario pugliese dipartimento di sistemi informatica universit di firenze mail dsi dsi dipartimento di informatica universit di pisa mail di unipi investigate issue designing kernel programming language mobile computing describe klaim language supports programming paradigm processes data moved computing environment 
language consists core linda multiple tuple spaces set operators building processes 
klaim naturally supports programming explicit localities 
localities class data manipulated data language provides coordination mechanisms control interaction protocols located processes 
formal operational semantics useful discussing design language provides guidelines implementations 
klaim equipped type system statically checks access rights violations mobile agents 
types describe intentions read write execute processes relation various localities 
type system determine operations processes want perform locality check comply declared intentions necessary rights perform intended operations specific localities 
series examples show mobile code programming paradigms naturally implemented kernel language 
prototype implementation klaim java 
keywords programming languages mobile code languages semantics programming languages language design coordination models 
networking changed computers isolated data processors powerful communication elaboration devices 
terms global computers global information structures identify architectures kind applications 
world wide web www best known example application geographically distributed collection processors networks 
global structures computers rapidly evolving programmability illustrative example www 
easily imagine applications programs running different sites needing continuous interactions applications take decisions information retrieved global environment 
new scenario called new programming languages paradigms support migratory mobile applications 
example java permits local executions self contained programs downloaded sites 
similarly facile supports mobility programs allowing processes transmitted communications 
obliq programming language static scoping discipline mobile processes maintain connections move site 
examples languages supporting forms mobility cml telescript 
theoretical perspective research addressed mobility starting definition calculus basis designing concurrent object oriented programming language pict 
semantic framework allow formalize understand global programming languages clearly required 
semantic framework may formal basis discuss controversial design implementation issues scoping discipline mobile processes provide support mechanical reasoning global programs 
key issue designing language network programming security privacy integrity data 
important prevent malicious agents accessing private information modifying private data 
tools needed enable sites receiving mobile agents execution set demands limitations ensure agents violate privacy jeopardize integrity information 
similarly mobile agents need tools ensure execution sites disrupt compromise security 
languages mobile agents rely policies compilation run time restrict privileges capabilities mobile agents java 
unnecessarily reduces expressive power capabilities agents 
guarantee certain desired security properties enforced language implementation 
presents kernel programming language klaim kernel language agents interaction mobility describing mobile agents interaction strategies 
introduce basic concepts linguistic primitives formal opera tional semantics 
followed discussion pragmatics language prototype implementation 
distinguishing features approach explicit localities accessing data computational resources presence simple type system control access rights 
choice klaim primitives heavily influenced process algebras linda :10.1.1.113.9679
language seen asynchronous higher order process calculus basic actions original linda primitives enriched explicit information location nodes processes tuples allocated 
explicit localities enable programmer distribute retrieve data processes sites net structure tuple space multiple located spaces 
localities considered order data dynamically created communicated network 
outcome powerful programming formalism example easily model encapsulation 
fact encapsulated module implemented tuple space private locality ensures controlled accesses data 
separation logical distribution processes physical mappings net leads sharing control programmers net coordinator 
actual coordination language designed handle issues related physical distribution processes 
coordinators complete control changes configuration network may due addition deletion software components sites transmission programs sites 
actual structuring terms processes coordinators provides clean abstraction device global programming languages instrumental studying migratory applications understanding extent configuration decisions carrying actual implementation 
illustrated analyzing effects choosing specific scoping disciplines accessing tuple spaces 
take security issues account extend klaim processes coordinators simple type system statically enforce security properties 
precisely type system permits check operations klaim processes intend perform sites net really comply access rights 
illustrate pragmatics language means number programming examples demonstrate established programming paradigms mobile applications naturally programmed klaim 
untyped version klaim implemented set java packages 
rest organized follows 
sections introduce syntax operational semantics klaim respectively 
section type system inferring process types methodology controlling access rights 
followed discussion language pragmatics section description prototype implementation section 
section research discussed 
comments relationships klaim languages alternative design choices scattered remarks 
preliminary presentations klaim language 
klaim syntax informal semantics klaim consists core linda multiple tuple spaces set operators borrowed milner ccs building processes 
distinguishing feature tuples operations located specific sites net 
start section summarizing main features linda interested reader referred details 
syntax klaim 
process algebraic operators briefly subsection contains syntax klaim processes 
overview linda linda coordination language relies asynchronous associative communication mechanism shared global environment called tuple space ts 
tuple space collection formally multiset tuples tuple sequence actual fields expressions values formal fields variables 
pattern matching select tuples ts 
tuples match number fields corresponding fields matching values variables 
variables match value type values match identical 
linda provides just primitives manipulating tuples 
non blocking operations eval permit tuples added ts 
operation adds tuple resulting evaluation ts 
operation eval differs added ts new concurrent process created evaluating tuple available matching evaluation completed 
possibly blocking operations read permit tuples accessed ts 
operation evaluates looks matching tuple ts 
removed ts 
corresponding values assigned variables operation terminates 
matching tuple operation suspended available 
operation read differs tuple selected pattern matching removed ts 
nondeterminism inherent definition linda primitives 
arises read operations suspended waiting tuple 
tuple available suspended operations nondeterministically selected proceed 
similarly read operation matching tuple arbitrarily chosen 
linda programming paradigm known generative communication :10.1.1.113.9679
tuple added ts generated life time independent producer process life time 
original proposal predicative non blocking forms inp part language :10.1.1.113.9679
yield true false depending ts contains tuple matching argument 
returning true retrieve remove matching tuple 
consider predicates functional duplicates non predicative counterparts difficult implement distributed environment 
may require expensive checks synchronizations entire tuple spaces 
linda asynchronous communication model allows programmers explicitly control interactions processes shared data set primitives data manipulation process synchronization 
advantage rendering explicit interactions program environment 
original linda primitives completely adequate programming distributed systems 
example data protection security key features mobile applications problematic linda communication model guarantee data privacy 
modular programming disciplines awkward follow practice way guarantee tuples coming different contexts mixed modules put 
multiple tuple spaces step solution problems 
perform step adding structure multiple tuple spaces allowing explicit manipulation localities locality names 
klaim processes shall exploit syntactic categories listed followed symbols indices refer elements 
ffl set sites physical localities 
site considered address node processes tuple spaces allocated 
ffl loc set logical localities 
locality may thought symbolic name site 
localities permit structuring programs distributed environments ignoring precise allocations 
distinguished locality self loc assumed 
programs self refer execution site 
ffl set locality variables 
ffl val set basic values 
ffl var set value variables 
ffl exp category value expressions 
built values value variables set operators specified 
ffl psi set parameterized process identifiers 
parameters different types process locality value sake simplicity fix ordering formal parameters process identifier 
ffl set process variables 
simplicity denote localities locality variables 
indicate sequences localities set localities 
similar notation kinds sequences 
standard notation indicate substitution value expression variable denote simultaneous substitution corresponding tuples sequences actual fields expressions processes localities locality variables formal fields denoted 
var var generic variable 
shall fields denote set fields linda operations generate tuples spawn new process eval read tuples read remove tuples located operation place tuple tuple space located 
primitives generalize linda original ones 
modified eval primitive processes arguments tuples permits mobile agents programmed 
clarified section action eval nil simulate expected behaviour action eval 
new sites created prefix newloc 
operation creates fresh site accessed locality variable operators building processes borrowed milner ccs 
commonly process algebras correspond basic notions 
nil stands process perform action stands process executes action behaves jp stands parallel composition stands nondeterministic composition klaim terms syntax table 
matter notation shall write nil 
variables occurring klaim process terms bound prefixes 
precisely prefixes read act binders variables formal fields prefix newloc binds locality variable process identifiers recursive process definitions 
assumed process identifier single defining equation def free value process locality variables contained xg occurrences process identifiers guarded process identifier occurs scope blocking read prefix 
process term free variables localities occurring processes considered constants 
section see names meaning nil null process fi fi fi action prefixing fi fi fi parallel composition fi fi fi choice fi fi fi process variable fi fi fi ah ei process invocation fi fi fi fi fi fi read fi fi fi eval fi fi fi newloc fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi table processes syntax defined mapped sites coordinators 
processes localities class data manipulated generated data occurring tuples 
processes higher order capabilities exchanged communications 
klaim nets coordination appears key concept modelling designing heterogeneous distributed open ended systems 
applies typically systems consisting large number software components programmed independently possibly different programming languages may change configuration execution 
coordination languages provide primitive defining configurations interaction protocols sets software agents 
systems designed developed structured way starting basic computational components adding suitable software modules called coordinators 
approach increases potential reuse software agents coordinators cost acceptable overheads 
section introduce klaim coordination language 
designed handle issues related physical distribution processes 
controls changes network configuration 
changes may due addition deletion software components sites transmission programs resources 
finite set sites klaim net set nodes 
klaim node triple ae site ae allocation environment partial function loc denote set environments oe empty environment environment maps locality site processes site potentially access site net site visibility locally controllable allocation environment site visible node ae belongs ae node fi fi fi net composition table nets syntax image ae 
introduce operation stratify environments 
ae ae ae ffl ae environment defined ae ffl ae ae ae defined ae ae ffl ae ae inner environment ae outer environment 
syntax klaim nets grammar table 
net assume existence function st returns sites composition defined st st consider net just set nodes 
say net formed ae node ae self image ae included st 
consider formed nets 
notations allocation environments report binding self 
formulation klaim located tuple spaces hierarchical structure located tuple spaces nested 
nesting located tuple spaces easily modelled 
suffices extend klaim coordination language combinator allocate complete net 
hierarchical net written ae ae allocation environment returns localities sequences sites 
idea site net allocated 
site environment ae control interactions nets 
allocated nets similar spirit multiple ambients cardelli gordon 
complete investigation allocated nets scope subject 
operational semantics syntactic levels klaim reflected semantic level 
operational semantics klaim sos style proceeds steps 
step defines symbolic semantics specifies parts process commitments control localities effects actions tuple spaces 
full description process behaviours second step packages processes data net 
gamma gamma gamma 
oe eval gamma gamma gamma 
oe gamma gamma 
oe read gamma gamma gamma 
oe newloc self gamma gamma gamma gamma gamma 
oe gamma 
ae gamma 
ae gamma 
ae gamma 
ae gamma 
ae gamma 
ae gamma 
ae gamma 
ae gamma 
ae gamma gamma gamma 
ae ffl ae eu ex gamma 
ae ah ei gamma 
ae def table structural rules symbolic semantics process semantics labelled transition system processes describes possible evolutions klaim processes providing actual allocation processes tuple spaces 
reason corresponding operational semantics called symbolic value locality expressions tuples evaluated 
describe effects evaluation processes placed tuples fields introduce auxiliary term indicates process packaged allocation localities specified ae mapping ae evaluation environment closure 
sake simplicity range closures 
structural rules symbolic semantics reported table 
transition gamma 
ae describes evolution process label transition aei provides description activities performed evolution 
instance describes output sending tuple tuple space specified 
similarly self thought request binding fresh site variable environment ae records local bindings taken account evaluate allocation environments transition labels similar boolean expressions operational framework 
ae ae ae ae ae ae ae ae ae ae table tuple evaluation function match match match match 
match 
match 
match match match match match table matching rules net semantics operational semantics klaim coordination language defined structural congruence reduction relation 
structural congruence incorporates basic semantics net parallel composition reduction describes basic computational paradigm interactions processes inside net 
nets defined structural congruence smallest congruence associative commutative 
avoid cumbersome notations denote localities locality variables sites assume allocation environments extended sites act identity function 
operational semantics nets exploits evaluation mechanism tuples pattern matching select tuples tuple space 
evaluation function tuples exploits allocation environment resolve locality names relies evaluation mechanism closed expressions expressions free variables 
inductively defined syntax tuples rules table denote value closed expression evaluation process say ae yields process closure 
rules defining pattern matching predicate reported table 
model tuples processes introduce auxiliary processes denote evaluated tuples referred klaim syntax extended process symbolic semantics expressed structural rule self gamma gamma gamma gamma gamma 
oe nil sites alike localities locality variables 
reduction rules nets rules table rules clearly distinguish local remote operations performed located processes provide formal model guide implementation 
evaluation operation modifies tuple space 
rule adds new tuple local tuple space process 
rule hand adds new tuple remote tuple space located rule evaluation tuple depends allocation environment ae ffl ae corresponds having static scoping discipline remote generation tuples 
tuple contains field process corresponding field evaluated tuple contains closure 
processes tuple transmitted local allocation environment 
dynamic scoping strategy adopted eval operation described rules 
case process spawned remote node transmitted local allocation environment execution influenced remote allocation environment ae communication operations read note modifies tuple space see rules read rules tuple space encompassed process left unchanged process evolution 
obviously distinguish local rules remote rules 
consider rule rules interpreted similarly 
says process perform action local tuple space synchronizing process represents matching tuple 
result synchronization tuple consumed corresponding process nil values replace corresponding free variables process performed operation 
rule describes asynchronous evolution subcomponents node 
rules may modify structure nodes net introduce new localities 
creation new node described rule 
environment new node obtained creating obvious update self locality 
underlying idea new node inherits knowledge localities creating node 
obviously design choices 
alternative formulation rule creation new node self gamma gamma gamma gamma gamma 
ae fresh ae ae self nil rationale choice adopted new node knowledge rest net 
gamma gamma gamma 
ae ae ffl ae ae ae ae gamma gamma gamma 
ae ae ffl ae ae ae ae ae gamma gamma gamma 
ae ae ffl ae ae ae gamma gamma gamma 
ae ae ffl ae ae ae ae ae gamma gamma 
ae ae ffl ae self gamma gamma gamma gamma gamma 
oe match ae ae jp ae ae jp gamma gamma 
ae ae ffl ae self gamma gamma gamma gamma gamma 
oe match ae ae ae ae gamma gamma gamma 
ae ae ffl ae self gamma gamma gamma gamma gamma 
oe match ae ae jp ae ae jp gamma gamma gamma 
ae ae ffl ae self gamma gamma gamma gamma gamma 
oe match ae ae ae ae ae ae ae jp ae jp self gamma gamma gamma gamma gamma 
ae ae ae self nil table reduction relation process interactions conclude description reduction relation say reduction behaves presence operator parallel composition nets 
composition defined st st st st say reduction behaves respect structural congruence 
despite different programming paradigms interesting similarities telescript klaim 
general magic telescript object oriented language designed network programming 
central concept telescript concept place corresponds sites 
place thought stationary process accept mobile agents 
agents travel place invoking go operation 
operation requires agent destination place ticket route trip 
main advantage klaim approach possible stationary processes programmed notion locality requiring precise physical distribution places 
words localities provide powerful abstraction mechanism sites 
analogies eval operations telescript go operation allow mobile agents programmed 
theoretical works non interleaving semantics process calculi adopted notion locality capture logical distribution processes 
basic idea approaches allow observation actions locations access paths take place 
approach localities tool observing distribution processes programming device structure control distribution processes data 
formal models closely related :10.1.1.53.1757
approaches deal mobility calculus channel locality names passed interactions 
significantly localities klaim simulate private name passing scope extrusion mechanisms calculus natural encoding asynchronous calculus klaim easily programmed 
scoping mobility role net allocate coordinate set processes 
formally describing issues related physical distribution net semantics essential study migratory applications understanding design decisions carrying implementation 
better understood analyzing effects choosing specific scoping disciplines mobile agents accessing tuple spaces 
operational semantics nets adopts static scoping discipline evaluation operations 
hand dynamic scope discipline adopted remote eval operations meaning localities process spawned remote site depends remote allocation environment 
process located site wishes insert tuple remote tuple space located local environment ae evaluating dynamic scoping discipline obtained replacing rule table gamma gamma 
ae ae ffl ae ae ae ae ae ae remote environment ae evaluating alternatively rule gamma gamma 
ae ae ffl ae ae ae ae ae self nil process placed eventually take care local evaluation tuple dynamic scoping simulated modification operational rules nets writing eval self execution eval spawns process self site resulting evaluation evaluated local environment process located wants spawn process remote site dynamic scoping discipline followed 
local environment ae giving meaning localities may referred static scoping discipline eval obtained spawning precisely rule table replaced gamma gamma gamma 
ae ae ffl ae ae ae ae ae case remote spawning process consists transmitting packaged allocation environment ae eval static scoping simulated primitives language particular passing processes closures fields tuples private localities store intermediate results 
mind write newloc 
eval eval eval executed site bound process packaged ae closure plain process activated site different case eval 
typing security security privacy integrity data key issue development mobile applications 
easily imagine malicious mobile agents attempting access private information 
server receiving mobile agent execution needs impose strong requirements ensure agent violate privacy jeopardize integrity information 
similarly mobile agents ensure execution server site damage compromise security 
section introduce type system klaim show statically enforce security properties 
precisely type system permits check operations klaim processes intend perform sites net really comply access rights 
typing analysis klaim programs structured phases reflecting level syntax klaim 
phase deduces process intentions read write withdraw execute 
relation various localities willing interact want migrate 
done inference system assigns types processes partially checks behave accordance declared intentions 
second phase typing analysis checks process necessary rights perform intended operations violate access rights granted net coordinator 
types fr ng indicate set process capabilities denotes capability execute read operation capability execute operation 
polarities non empty subsets fr ng 
pi ranged may indexed denote set polarities 
polarities differently processes nets 
polarity locality locality variable say process contains information operations process intends perform 
net hand polarities fix access rights 
type checking guarantee intentions match access rights granted coordinator allowed 
orderings polarities model hierarchies access rights 
obviously process able perform operation able perform read 
type checking ensure process capabilities execute operations require capabilities smaller greater ordering pi defined intuitions lead relation obtained reflexive transitive relation induced rules fig pi frg pi pi pi pi think associating polarity process locality completely characterize intentions processes rights localities 
clear take account process migrations different access rights different localities 
obvious choice assigning types process associate single polarity describes operations process intends perform ignoring specific localities refers 
way characterize different intentions relative different localities 
associating polarities localities referred process unsatisfactory 
hinders possibility keeping track capabilities remotely executed processes different sender processes 
example consider process right access remote tuple space database right send process remote execution server node willing necessary right 
take account remote executions migrations processes need structure types associate locality just polarity type required processes executed locality 
type finite map assigns pairs consisting polarities types localities locality variables 
component pair associated describes polarity second describes types processes executed 
klaim types ranged ffi elements universe defined domain equation delta loc gamma 
pi theta delta construction delta rests standard construction complete partial orders cpo 
hd cpo set partial functions finite domain loc cpo pi theta defined loc gamma 
pi theta set functions ordered relation stating defined partial function smaller 

ffl dom dom ffl dom pi thetad pi thetad obvious ordering pi theta difficult show hd algebraic cpo hh algebraic cpo 
delta initial solution recursive domain equation delta called subtype relation 
usual shall denote greatest lower bound oe shall denote element delta empty domain 
ffi delta ffi denote th component pair ffi defined ffi yields ffi yields oe 
ffi gamma gamma denotes greatest lower bound set fffi fffi gamma gamma ffi 
notation ffi ffi denotes type ffi ffi ffi oe ffi undefined ffi ffi ffi ffi 
notation ffi ffi ffi effect substitution ffi ffi ffi denotes ffi ffi undefined 
typed version klaim obtained associating type locality variables process variables bound 
sake simplicity call typed version language klaim 
syntax terms processes usual closed terms reported table 
recall stands generic locality locality variable 
avoid name overloading types assume set locality variables partitioned subsets arguments newloc formals tuples 
type associated process locality parameters process identifiers usual assumed process identifier single defining equation ffi ffi def ready introduce formal syntax typed nets role allocate coordinate processes assign access rights 
type sites similar processes associates pairs localities locality variables 
construction cpos may straightforwardly turned functor category cpo category cpos embeddings morphisms 
action functor cpos defined delta embedding gamma 
action functor embeddings obtained 
ffi standard techniques prove continuous covariant functor cpo preserves algebraicity 
theory ensures existence uniqueness cpo initial fixed point functor initial solution recursive domain equation delta 
nil fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi ah ei fi fi fi fi fi fi read fi fi fi eval fi fi fi newloc ffi fi fi fi fi fi fi fi fi fi fi fi fi ffi fi fi fi ffi fi fi fi table typed klaim syntax declared means functions upsilon 
site net describes access rights processes located sites net upsilon describes locality variables processes located may 
net triple defined section upsilon structure st gamma 
st gamma 
pi upsilon st gamma 
loc 
deriving processes types section presents inference system assigns types processes 
type system records operations processes willing perform specific localities checks process operations comply declared types variables 
type contexts gamma functions mapping process variables identifiers types 
oe denote empty context 
auxiliary function update defined structurally tuples syntax update type contexts behaves identity function fields ffi 
formally defined update gamma update update gamma gamma ffi ffi gamma type judgments processes take form gamma ffi gamma type context providing type process variables identifiers statement gamma ffi asserts capabilities ffi context gamma 
type process variable identifier determined type context gamma set inference rules 
definedness gamma gamma guaranteed fact processes closed terms 
gamma gamma gamma gamma simplest process null process capability 
gamma nil oe process puts tuple tuple space address specified behaves typing rule operation gamma ffi gamma ffi ffi ffi fog states type possibly extends capability binder typed context gamma typing rules read update context types process variables bind 
second half premises checks process misuse locality variables bound read 
locality variable type ffi checks remote operations ffi gamma gamma really respect ffi resulting type obtained extending type corresponding capability 
update gamma ffi ffi ffi gamma gamma 
ffi gamma read ffi ffi ffi frg update gamma ffi ffi ffi gamma gamma 
ffi gamma ffi ffi ffi fig fe ug locality variables bound read 
typing rule eval extends type records remote operations extended ffi spawned process gamma ffi gamma ffi gamma eval ffi ffi ffi feg ffi ffi ffi typing rule newloc extends type self type ffi declared checks operations willing perform ffi comply ffi gamma ffi ffi ffi gamma gamma gamma newloc 
ffi ffi ffi self ffi self fng ffi ffi typing rules parallel composition choice state intentions composed processes cases union formally greatest lower bound components 
binding context left unchanged 
gamma ffi gamma ffi gamma ffi ffi gamma ffi gamma ffi gamma ffi ffi typing rule process definition updates type context types process variables occur parameters candidate type ffi resulting context exploited infer type ffi secondly formal locality variable checks operations ffi match type declaration ffi inferred type assigned gamma ffi ffi ffi ffi ffi fe ug gamma ffi ffi ffi def defining equation process identifier typing rule process invocation determines type process identifier process arguments 
checks types inferred process arguments agree corresponding formal parameter 
requirement imposed arguments 
type locality variables controlled rules read newloc applied 
localities controlled typedness nets checked 
gamma ffi gamma ffi ffi ffi pg gamma ah ei ffif ug ffif ug ffif ug hffi ffi ffi ffi ffif ug hffi ffi ffi defined 
inferred type states ah ei intends perform operations ah xi intends perform statically unable establish occurrences fe ug ffi replaced typing nets section presents criteria establishing net typed 
types processes net required agree sites located 
specifically types processes determined type inference system checked fixed net coordinator account process located 
pair functions upsilon associate type site net 
type compared located processes expresses expected behaviour check net typed 
net type ffi site st obtained dom ae dom upsilon ffi ae ffi ae dom ae hfi ng ffi dom upsilon hfi ng dom upsilon notice site ffi defined definition net dom ae ae polarity 
item definition ffi uses allocation environment ae determine site associated polarity type 
items deal locality variables restriction statically put fresh node inherits rights creating 
soundness theorem proved typed klaim nets processes lead run time errors due misuse access rights 
net typed required types processes net agree access rights sites located 
specifically types processes derived type inference system checked fixed net coordinator account process located 
soundness theorem establishes typedness invariant operational semantics 
result essentially variant standard subject reduction takes account fact new sites dynamically created 
soundness theorem related technicalities needed appreciate primitives pragmatics klaim 
highlight utility klaim types consider system composed process server available local space tuple containing locality identical processes client client access tuple space read address send process execution server def self nil client def read 
eval nil type ffi process client type ffi gamma 
oei gamma 
ffi suppose client right send processes evaluation location denoted net coordinator allocate server site processes client sites give access rights ffi gamma 
oei gamma 
ffi ffi gamma 
oei similarities types klaim telescript permit authority 
limit access rights mobile agents advantage approach type system mechanical static verifications access rights possible 
type systems proposed calculi mobile processes addressing security issues 
mention type system proposed pierce sangiorgi refined kobayashi pierce turner 
type system developed calculus uses types channels record information telescript agent permit specify mobile agent maximum lifetime seconds maximum size bytes 
channels read write 
type system extended associating multiplicities types order describe times channel 
main difference approach lies treatment localities importantly role played type information level net coordinator check enforce access rights processes 
shares parts underlying rationale volpano smith authors consider sequential procedural language type system control specific non interference security property 
programming mobile code applications section illustrate klaim program mobile code applications 
programming examples assume natural numbers identifiers basic values 
distributed applications distinctive feature exploitation code mobility 
classification proposed single paradigms apart traditional client server paradigm cs largely build ffl remote evaluation re 
component distributed application invoke services components transmitting data needed perform service code describes perform service 
ffl mobile agent ma 
process program associated state execution node network migrate different node continues execution current state 
ffl code demand cod 
component distributed application running node dynamically download different component link code perform task 
suitable programming constructs needed support approaches 
programming languages java facile obliq telescript designed provide facilities process mobility distribution see detailed survey 
aim show means simple programming examples klaim programming constructs powerful implement programming paradigms 
cs re paradigms programmed exploiting flexibility klaim data structures tuples 
tuple fields may contain data values processes program codes 
show program re basically cs language higher order facilities klaim 
suppose want require server located location executes evaluates code values assigned variables instruction assume def server performs self self similar activity 
suppose want execute process remote location paradigm ma implemented means instruction eval dynamic scoping discipline resolving location names adopted sequence newloc eval 
closed term contain free variables think closure 
processes migrate states 
want download program code stored tuple field contains remote location cod paradigm simply programmed means instruction form read subsections discuss specific examples take advantage described facilities 
remote procedure call caller process caller sends request callee callee waits response 
request name procedure actual parameters contains caller private locality response delivered 
caller newloc procid callee 
behaviour process callee waits invocation executes related procedure sends back results locality passed service request 
callee 
pid self callee pid nil 
processes allocated net local environment caller assigns locality callee site callee located 
fs self callee caller fs callee crucial role example played newloc permits private data space created accessed variable dynamic consider remote programming 
programming discipline permits writing agents dynamically move network interact locally agents 
agent placed user server location decoupled user interact server net 
consider scenario 
user needs additional information piece data represented item item example title book price wants know 
part behaviour depends information 
activities independent 
look required information database distributed network 
assume node database reachable item contains tuple form item desired information tuple form item information node search additional information 
user process asks execution item starting point search chosen search key item agent gatherer dynamically travels nodes looking tuple contains information item 
agent takes parameters research key item fresh locality provides address user private tuple space result search placed 
gatherer spawned splits behaviour parallel components waits additional information proceeds 
activities need additional information decoupled search activity complex expensive 
newloc eval gatherer item item 
jp process gatherer match alternative tuples 
captures additional information item price 
placed locality gatherer terminates 
second tuple obtain address node search repeated 
gatherer item read item self nil read item self eval gatherer item nil assumption structure distributed database guarantees gatherer deadlocks associated information location search repeated certainly ensure search activity terminate successfully gatherer loop indefinitely 
happen second tuple location information finds match tuple spaces 
electronic marketplace means example borrowed illustrate klaim program mobile agents 
assume client process wants buy specific camera decide purchase camera activates migrating agent passes information 
model camera chosen 
loc locality directory electronic marketplace 
length measure identify geographical area interest 
expects return name address telephone number closest chosen area camera shop lowest price part behaviour def eval ahc loc self self retain name address telephone number camera shop buy cost agent behaves follows 
obtains site located return outcome query identify geographical area interest pricing information 
done putting tuple containing self new tuple space order force evaluation self local tuple space withdrawing tuple 

migrates site marketplace directory asks obtains list camera shops location close site item list contains name address telephone number camera shop 
function return locality information item 

visits camera shop turn obtains local price agent retains information shop lower price currently stored offered 

visiting camera shops list sends back site information shop offers lowest price terminates 
sake simplicity defining agents conditional construct programmed exploiting dynamic creation new sites choice operator data type list usual operators hd tl empty 
def newloc self 
eval yi nil def self list self empty list gamma nil list hd list def eval read cost self cost hd ui nil def empty nil tl hd tl def eval read cost self cost cost hd ui ui nil part behaviour camera shop def price self denote marketplace directory process 
net initially structured follows fs loc fs cs fg fg interested inferring type ffi ffi rec self gamma 
ng gamma 
ng loc gamma 
ffi ffi self gamma 
ig oei gamma 
oei gamma 
ffi ffi rec self gamma 
oei gamma 
oei gamma 
types state performs kind operation site located addressed self site dynamically creates 
process activated migrates site marketplace directory addressed loc performs local remote return outcome initial query migration site camera shop 
running site camera shop process activated performs local read read local price camera remote original site migrations sites camera shops 
klaim java section describe prototype implementation klaim 
ensure portability different platforms choose java implementation language 
course assume basic knowledge java 
implementation klaim java jdk called extends java packages new packages linda klaim 
linda package implements standard linda primitives 
main classes package tuples tuplespace 
class tuples provides methods build handle tuples 
class tuplespace provides mechanisms build access update tuple space 
particular linda operations read implemented methods class 
klaim package supports implementation klaim 
main classes package net node process 
class net implements klaim coordination language klaim net object class 
net object behaves server contains code register sites net 
current implementation localities implemented strings 
sites hand internet addresses 
object class node implements klaim node 
encapsulates tuple space set processes 
klaim primitives read eval implemented methods class 
parameters methods locality node 
klaim process object class process 
main method class method execute 
method invoked run process node method run class thread 
objects class implement node communications 
message object contains sender node receiver node operation code content field type object 
feature permits transmission processes 
receiver node may know class process belongs 
process sent corresponding class file 
node specific performs dynamic linkage class received nodes net 
main method class invoked node receives process net 
method inserts class files local hash table 
method uses hash table load class definitions remote processes starting execution 
note similar approach adopted implementation aglets library 
presents part java code implementing 
give reader flavour programming report source code agent example section 
public class extends classloader private hashtable classes new hashtable private hashtable new hashtable node public synchronized public void string classname byte get classname null null put classname public synchronized class string classname boolean throws class result byte result class classes get classname check local cache classes result null return result classname load class repository null try result super classname return result catch exception system err println throw new classname result length parse class file result null throw new result classes put classname result return result java public class extends process protected protected locality protected distance protected public locality distance public void execute newloc kloc new new new newloc newloc self newloc kloc newloc new kloc distance eval self print costs public static void main string args throws ioexception node node new new locality new marketplace distance new args length new args args length new args args length new args args length distance new integer args node new localhost process new distance node start node java java implement dialect linda called jada :10.1.1.1.5724
jada supports version linda multiple tuple spaces 
tuple spaces key notion jada autonomous entities distributed nodes net identified internet address nodes placed 
jada distinction logical physical addresses 
processes tuple spaces connecting nodes placed invoking methods 
jada support process mobility eval primitive implemented processes exchanged communications 
concluding remarks kernel programming language supports mobile applications 
operational semantics focuses coordination mobile agents provided 
type system permits statically detect violations security properties related capabilities access control developed 
programming examples illustrate mobile applications expressed klaim 
prototype implementation java described 
klaim type system provides step ambitious goal demonstrating typing information systematically guarantee typed processes enjoy security properties 
plan extend type system introducing user defined capabilities allowance capabilities maximum life time seconds maximum size bytes multi level security structuring localities levels security dynamic transmission access rights 
klaim equipped cryptographic primitives done spi calculus 
plan develop observational semantics foundation programming logics verification techniques 
starting point testing framework developed process calculus linda 
currently exploring possibility allowing nets communicate move processes tuples 
current implementation appears suited program feature lead providing klaim hierarchical nets 
klaim implemented java packages programmers adopt java object oriented programming discipline klaim 
compiler klaim extended pascal primitives development implementation typed version 
acknowledgments grateful luca cardelli betti stimulating discussions global programming type systems anonymous referees useful comments helped improve 
lorenzo bettini discussions implementation klaim 
partially supported esprit working groups confer hcm project express cnr la matematica ingegneria di di sistemi software 
abadi gordon calculus cryptographic protocols spi calculus 
proc 
fourth acm conference computer communications security 
amadio prasad 
localities failures 
fct tcs proceedings thiagarajan ed lncs pp 
springer 
arnold gosling 
java programming language 
addison wesley 
berry boudol 
chemical machine 
theoretical computer science 
bettini 
progetto di un di mobile italian 
di dipartimento di sistemi informatica universit di firenze 
forthcoming boudol castellani hennessy 
observing localities 
theoretical computer science 
cardelli 
language distributed scope 
computing systems mit press 
cardelli 
global computation 
manuscript 
available url www luca demon uk 
cardelli gordon 
mobile ambients 
appear fossacs 
available url www luca demon uk 
carriero gelernter 
linda context 
communications acm 
carriero gelernter 
distributed data structures linda 
proc 
acm symposium principles programming languages acm new york pp 

ciancarini rossi 
jada coordination communication java agents 
mobile object systems programmable internet vitek tschudin eds lncs pp 
springer 
corradini de nicola 
locality semantics process algebras 
acta informatica vol 
pp 

cugola ghezzi picco vigna 
analyzing mobile code languages 
vitek tschudin editors mobile object systems lncs springer 
appear de nicola ferrari pugliese 
locality linda programming explicit localities 
tapsoft proceedings bidoit dauchet eds lncs pp 
springer 
de nicola ferrari pugliese 
coordinating mobile agents blackboards access rights 
coordination proceedings garlan le metayer eds lncs pp 
springer 
de nicola ferrari pugliese 
types access control 
submitted publication 
available url di unipi papers 
de nicola pugliese 
process algebra linda 
coordination proceedings ciancarini hankin eds lncs pp 
springer 
fournet gonthier 
evy emy 
calculus mobile agents 
concur proceedings montanari sassone eds lncs pp 
springer 
gelernter :10.1.1.113.9679
generative communication linda 
acm transactions programming languages systems 
gelernter 
multiple tuple spaces linda 
parle proceedings goos hartmanis eds lncs pp 

gelernter carriero parallel programming linda 
proceedings conference parallel programming ieee pp 

mishra prasad 
facile symmetric integration concurrent functional programming 
international journal parallel programming 
hennessy lin 
symbolic bisimulations theoretical computer science 
hoare 
communicating sequential processes 
prentice hall international 
ibm aglets workbench home page 
url address www trl ibm jp aglets 

semantic models communicating processes value passing 
ph thesis university edinburgh 
kobayashi pierce turner 
linearity calculus 
proc 
popl 

shared memories buses lans linda implementations spectrum connectivity 
dep 
computer science yale univ research report yaleu dcs tr 
milner 
communication concurrency 
prentice hall international 
milner polyadic calculus tutorial technical report ecs lfcs milner parrow walker 
calculus mobile processes part ii 
information computation 
pierce turner 
concurrent objects process calculus 
theory practice parallel programming ito yonezawa eds lncs pp 

pierce sangiorgi 
typing subtyping mobile processes 
proc 
lics full version mathematical struct 
comp 
science plotkin 
structural approach operational semantics 
tech rep daimi fn aarhus university dep 
computer science 
plotkin 
lectures notes domain theory 
university edinburgh 
pugliese 
semantic theories asynchronous languages 
ph thesis viii univ di roma la sapienza dip 
scienze dell informazione 
reppy 
higher order concurrency 
ph thesis cornell university tr 
thomsen leth 
issues semantics facile distributed programming 
rex workshop semantics foundations applications de bakker 
de roever lncs pp 
springer 
volpano smith 
typed approach program security 
proc 
tapsoft lncs pp springer 
white 
mobile agents 
software agents bradshaw ed pp 


