rc march computer science mathematics ibm research report assessment call graph construction algorithms david grove ibm watson research center box yorktown heights ny craig chambers department computer science engineering university washington box seattle wa limited distribution notice report submitted publication outside ibm probably copyrighted accepted publication 
issued research report early dissemination contents 
view transfer copyright outside publisher distribution outside ibm prior publication limited peer communications specific requests 
outside publication requests filled reprints legally obtained copies article payment 
copies may requested ibm watson research center box yorktown heights ny usa 
reports available internet domino watson ibm com library nsf home 
large number call graph construction algorithms object oriented functional languages proposed embodying different tradeoffs analysis cost call graph precision 
unifying framework understanding call graph construction algorithms empirical comparison representative set algorithms 
general parameterized algorithm encompasses known novel call graph construction algorithms 
implemented general algorithm vortex compiler infrastructure mature multi language optimizing compiler 
vortex implementation provides level playing field meaningful cross algorithm performance comparisons 
costs benefits number call graph construction algorithms empirically assessed applying vortex implementation suite sizeable lines code cecil java programs 
applications interprocedural analysis enabled substantial speed ups highly optimized baseline 
furthermore significant fraction speed ups obtained scalable near linear time call graph construction algorithm 
frequent procedure calls message sends serve important structuring tools object oriented languages 
severely degrade application run time performance 
degradation due direct cost implementing call indirect cost missed opportunities compile time optimization code surrounding call 
number techniques developed convert message sends procedure calls statically bind message send inline statically bound calls removing direct indirect costs call 
programs techniques applied remaining non statically bound message sends non inlined procedure calls 
presence call sites force optimizing compiler overly pessimistic assumptions potentially profitable optimization opportunities missed leading significant reductions application performance 
interprocedural analysis method enabling optimizing compiler precisely model effects calls enabling pessimistic assumptions program behavior reduce performance impact non inlined call sites 
interprocedural analysis divided logically separate sub tasks 
program call graph compile time data structure represents run time calling relationships program procedures constructed 
case done explicit pre phase performing real interprocedural analysis analyses interleave call graph construction analysis may construct call graph implicitly 
second real analysis performed traversing call graph compute summaries effect callees call site summaries effect callers procedure entry 
summaries consulted compiling optimizing individual procedures 
strictly order procedural languages constructing program call graph straightforward call site target call directly evident source code 
object oriented languages languages function values target call precisely determined solely examination source code call site 
languages target procedures invoked call site partially determined assessment call graph construction algorithms david grove ibm watson research center box yorktown heights ny ibm com craig chambers department computer science engineering university washington box seattle wa chambers cs washington edu assessment call graph construction algorithms grove chambers data values reach call site 
object oriented languages method invoked dynamically dispatched message send depends class object receiving message languages function values procedure invoked application computed function value depends value function value 
general determining flow values needed build useful call graph requires interprocedural data controlflow analysis program 
interprocedural analysis turn requires call graph built prior analysis performed 
circular dependency interprocedural analysis call graph construction key technical difference interprocedural analysis object oriented functional languages interprocedural analysis strictly order procedural languages 
effectively resolving circularity primary challenge call graph construction problem object oriented languages 
main contributions general parameterized algorithm call graph construction developed 
general algorithm provides uniform vocabulary describing call graph construction algorithms illuminates fundamental similarities differences enables exploration algorithmic design space 
general algorithm quite expressive encompassing algorithms wide range cost precision characteristics 
general algorithm implemented vortex compiler infrastructure 
definition general algorithm naturally gives rise flexible implementation framework enables new algorithms easily implemented assessed 
implementing algorithms single framework incorporated mature optimizing compiler provides level playing field meaningful cross algorithm performance comparisons 
representative selection call graph construction algorithms experimentally assessed 
vortex implementation framework test algorithm suite sizeable lines code cecil java programs 
comparison previous experimental studies experiments cover wider range algorithms include applications order magnitude larger largest prior 
assessing algorithms larger programs important algorithms including previous claimed scalable practically applied larger benchmarks 
organized major parts presentation general parameterized call graph construction algorithm sections empirical assessment representative set instantiations general algorithm sections 
section begins reviewing role class analysis call graph construction 
sections core half formally define call graphs call graph construction problem general parameterized algorithm 
section describes implementation algorithm vortex compiler infrastructure focuses design choices key primitives implemented 
section begins second half describing experimental methodology 
sections describe empirically evaluate category call graph construction algorithms 
section concludes second half summarizing experimental results 
section discusses additional related section concludes 
role interprocedural class analysis object oriented languages potential target method calls precisely determined solely examination source code call sites 
problem target methods invoked result message send determined classes objects reach message send site run time act receivers message 
general flow objects call sites may interprocedural precisely determining receiver class sets needed build call graph requires interprocedural data control flow analysis program 
interprocedural analysis turn requires call graph built prior analysis performed 
possible approaches handling circular dependencies receiver class sets program call graph interprocedural analysis assessment call graph construction algorithms grove chambers making pessimistic sound assumption approach breaks circularity making conservative assumption quantities computing 
example compiler perform interprocedural analysis assume statically type correct receiver classes possible call site single pass program construct sound call graph 
similarly intraprocedural class analysis performed procedure making conservative assumptions interprocedural flow classes slightly improve receiver class sets constructing call graph 
process iteratively repeated improve precision final call graph current pessimistic solution new pessimistic assumption quantities new approximation compute better pessimistic solution 
simplicity approach attractive may result call graphs imprecise enable effective interprocedural analysis 
making optimistic unsound assumption iterating fix point just pessimistic approach initial guess quantities giving rise values quantities 
fundamental difference initial guess may unsound initial values computed rounds iteration may required reach fix point 
example call graph construction algorithms initial optimistic assumption receiver class sets empty main routine procedure call graph 
assumption main routine analyzed process may discovered fact procedures reachable class sets contain additional elements causing analysis required 
optimistic approach yield precise call graphs receiver class sets pessimistic approach complicated may computationally expensive 
presents empirically assesses call graph construction algorithms utilize approaches 
data demonstrate call graphs constructed algorithms pessimistic approach substantially precise constructed algorithms utilize second optimistic approach 
furthermore precision differences impact effectiveness client interprocedural analyses turn substantially impact bottom line application performance 
sections concentrate developing formalisms naturally support describing optimistic algorithms integrate call graph construction interprocedural class analysis formalisms describe pessimistic algorithms 
lattice theoretic model call graphs section precisely defines output domain general integrated call graph construction interprocedural class analysis algorithm 
section informally introduces key ideas 
section formalizes intuition section ideas drawn lattice theory 
section presents applications call graph formalism discuss algorithmic termination call graph soundness relationship call graph formalism definition general algorithm section 
informal model call graphs standard formulation call graph consists nodes representing procedures linked directed edges representing calls procedure 
formulation insufficient accurately capture output context sensitive interprocedural class analysis algorithm 
call graph node represent contour analysis time specialization procedure 
context insensitive call graphs exactly contour procedure context sensitive call graphs may arbitrary number contours representing different analysis time views single procedure 
shows context insensitive call graph example program 
depicts call graph constructed context sensitive algorithm separated integer float dataflow creating contours max procedure 
define main routine program union program entry points static data initializations 
assessment call graph construction algorithms grove chambers contour intuitively contains primary components procedure identifier identifies source level procedure contour specializing 
contour key encodes context sensitivity decisions interprocedural class analysis 
class sets represent result interprocedural class analysis 
contour contains class sets formal parameters local variables procedure result 
sets classes represent possible classes objects stored corresponding variable returned procedure program execution 
call graph edges record call site set possible callee contours 
lexical parent contour allow contours representing lexically nested procedures access class sets free variables appropriate contour enclosing procedure 
intuitively components contour identify 
third fourth components record portion final analysis results class sets call graph edges local contour 
fifth component important languages allow lexically nested functions encode lexical nesting relationship contours 
addition normal contours created represent procedures special contours created represent program constructs 
example root contour created represent global scope local variables program global variables body program main routine 
interprocedural class analysis needs record sets possible classes instance variable manner similar class sets local variables recorded procedure contours 
array classes supported introducing single instance variable array class model elements array 
instance variable contours intuitively consist main components instance variable identifier identifies source level instance variable contour specializing 
contour key just contour key component procedure contours field encodes context sensitivity decisions interprocedural class analysis algorithm 
class set represents potential classes values stored instance variable 
just procedure contours components instance variable contour viewed playing roles identifying contour recording local analysis results 
precisely analyze polymorphic data structures interprocedural class analysis algorithms introduce additional context sensitivity analysis classes instance variable contents 
array classes procedure main return procedure return max procedure return max procedure return max context insensitive vs context sensitive call graph main max main max max example program context insensitive context sensitive assessment call graph construction algorithms grove chambers modeled just class analysis polymorphic array classes benefit scheme 
example treating different instantiation sites class leading distinct analysis time classes distinct instance variable contours analysis simulate effect templates parameterized types relying explicit parameterization source program 
single source level class may represented analysis multiple class contours 
class contours consist components class identifier identifies source level class contour specializing 
contour key contour key components field encodes context sensitivity decisions interprocedural class analysis algorithm 
previously described class information example class sets recorded procedure instance variable contours generalized class contour information 
informally result combined call graph construction interprocedural class analysis algorithm defined section set procedure contours set instance variable contours 
contents sets define contour call graph call graph edges component procedure contours class contour sets interesting program constructs class set component procedure instance variable contours 
formal model call graphs subsection uses lattice theoretic ideas formally define contour model context sensitive call graphs 
lattice set elements associated partial ordering elements pair elements set contains unique upper bound element unique greatest lower bound element 
downward semilattice lattice greatest lower bounds required 
set possible call graphs particular input program call graph construction algorithm pair forms downward semilattice term domain shorthand downward semilattice 
traditional dataflow analysis kam opposite conventions interpretation represents better optimistic call graph top lattice element represents best possible optimistic call graph bottom element represents worst possible conservative call graph 
elements call graph domain sound safely approximate real program call graph section formally defines soundness related structure call graph domains 
supporting domain constructors definition call graph domain uses auxiliary domain constructors common patterns making easier observe fundamental structure call graph domain 
readers may want skip ahead section see constructors reading remainder section 
constructor pow maps input partial order lattice dps subset powerset defined partial order defined terms elements dps greatest lower bound pow subtly differs standard powerset domain constructor maps input set lattice domain full powerset input partial order solely subset relationship 
complex definition pow preserves relationships established input partial order 
intuitively serves remove elements redundant respect member family constructors standard tuple constructor takes input partial orders generates new partial order cross product dps dps dps dps bottoms powerset bottoms dps dps dps dps dps dps bottoms bottoms assessment call graph construction algorithms grove chambers defined terms pointwise input partial orders downward semilattices downward semilattice greatest lower bound tuples tuple pointwise greatest lower bounds elements 
constructor map function constructor takes input set partial order generates new partial order partial order defined terms partial order downward semilattice downward semilattice elements greatest lower bound constructor takes input downward semilattice generates downward semilattice lifting union tuple domains elements elements partial order union individual tuple partial orders partial order elements drawn tuple domain greatest lower bound greatest lower bound domain greatest lower bound 
call graph domain utilizes domain constructors specified previous section define call graph domain particular input program call graph construction algorithm pair 
definition parameterized inputs encode program features algorithm specific context sensitivity polices 
program features abstracted unordered sets class set source level class declarations set source level instance variable declarations procedure set source level procedure declarations variable set program variable names callsite set program call sites set source level loads instance variables set source level stores instance variables 
algorithm specific information encodes context sensitivity policies represented partial orders prockey classkey 
prockey parameter defines space possible contexts context sensitive analysis functions procedure contours 
parameter defines space possible contexts separately tracking contents instance variables instance variable contours 
classkey parameter defines space possible contexts context sensitive analysis classes class contours 
ordering relation partial orders derived domains indicates relative precision elements element precise conservative 
components call graph instance variable contours procedure contours 
instance variable contours enable analysis dataflow instance variable loads stores procedure contours represent rest program 
components contours serve functions component instance variable procedure contours serves identify contour encoding source level declaration contour specializing restricted context applies 
call graph restricted contain procid 
third component procid identifies chain lexically enclosing procedure contours analyze free variables 
procedure third component contour procid restricted tuples exactly length lexical nesting depth procedure 
second component instance variable procedure contours records results interprocedural class analysis 
instance variable contours simply class contour set represents set class contours glb glb glb glb glb glb dom glb dom tuple tuple tuple assessment call graph construction algorithms grove chambers stored instance variable contour 
procedure contours mapping procedure local variables formal parameters set class contours representing classes values may stored variable 
variable mapping contains entry special token return represents set class contours returned contour 
remaining components procedure contour encode inter contour flow data control caused procedure calls instance variable loads instance variable stores respectively 
third component maps call sites elements pow procid encodes traditional notion call graph edges 
definition somewhat complicated overloading class contours represent objects closure values 
cases component identifies source level class closure associated contour 
classes second component class contour contain element classkey domain 
closures second component contain tuple prockey encode lexical chain procedure contours analyze free variables contained closure 
encoded information procedure contours created closure initialize third component procid 
example cfa algorithm classic context insensitive call graph construction algorithm object oriented functional languages 
modeled single point lattice instantiate prockey classkey partial orders 
call graph procedure instance variable contour 
common context sensitivity strategy create analysis time specializations procedure call sites shivers cfa algorithm 
corresponds instantiating prockey partial order procedure set single point lattice classkey 
final example cfa algorithm generalized support context sensitive analysis instance variables tagging class procedure instantiated maintaining separate instance variable contours class contour 
context sensitivity strategy encoded procedure set instantiate prockey classkey partial orders elements elements partial order 
applications termination call graph construction algorithm monotonic computation divided sequence steps takes input call graph produces call graph definition call graph domain callgraph tuple pow tuple tuple pow tuple procid map variable map callsite pow procid map pow map pow procid tuple procedure prockey pow prockey pow tuple class union classkey prockey cg cg assessment call graph construction algorithms grove chambers call graph partial order defined equations 
call graph construction algorithm bounded step guaranteed take finite amount time 
call graph construction algorithm monotonic bounded step associated call graph lattice finite height algorithm guaranteed terminate finite time 
furthermore worst case running time algorithm bounded sets specifying program features finite input program finite size algorithm specific partial orders may finite infinite 
parameterizing partial orders finite call graph domain finite number elements finite height 
result follows immediately restriction call graphs contain procid restriction third component procid set tuples length exactly matching lexical nesting depth procedure absence mutually recursive equations 
context sensitive algorithms introduce mutually recursive definitions cause call graph domain infinitely tall 
cases care taken incorporate widening operation ensure termination 
example cartesian product ages scs algorithms described section elements domain part prockey domain elements 
presence closures represented analysis class contours lead infinitely tall call graph lattice closure recursively passed argument lexically enclosing procedure 
agesen terms problem recursive customization describes methods detecting applying widening operation ages 
soundness depicts structure interesting portions call graph domain 
call graph conservative call graph located diagram 
call graphs exactly represent particular execution program located region labeled optimistic 
call graph domain downward semi lattice define unique call graph ideal greatest lower bound call graphs corresponding particular program execution 
call graph sound safely approximate program execution ideal optimistic sound call graph call graph sound iff equal conservative ideal unfortunately general impossible compute ideal directly may infinite number possible program executions observation constructive test soundness note call graphs ordered respect ideal depicts subset elements call graph domain 
lattice height length longest chain elements cg ideal cg regions call graph domain ideal sound optimistic assessment call graph construction algorithms grove chambers algorithm definition final application call graph domain definition section general call graph construction algorithm 
general algorithm parameterized context sensitivity strategy functions codomains pow prockey pow pow classkey 
result applying general algorithm input program element call graph domain implied input program codomains algorithm strategy functions 
computation algorithm viewed series steps transition intermediate solution element algorithm program call graph domain element 
core data structures implementation algorithm simply representations procedure instance variable class contours defined section 
parameterized call graph construction algorithm section specifies general integrated call graph construction interprocedural class analysis algorithm small example language defined section 
general algorithm parameterized contour key selection functions enable encompass wide range specific algorithms role requirements functions explored section 
section specifies analysis performed algorithm set constraints section discusses methods constraint satisfaction 
simple object oriented language analysis defined simple statically typed object oriented language syntax 
includes declarations types global local mutable variables classes mutable instance variables multimethods assignments global local instance variables global local formal instance variable class instantiation operations closure instantiation application operations dynamically dispatched message sends 
inheritance subtyping hierarchies separated enable modeling languages terminals boldface braces enclose items may repeated zero times separated commas 
program decl stmt expr decl typedecl classdecl typedecl type typeid subtypes typeid classdecl class classid inherits classid subtypes typeid instvar typeid var varid typeid method msgid formal typeid stmt expr formal classid typeid stmt varid expr expr expr expr varid expr new classid lambda formal typeid stmt expr send msgid expr apply expr expr syntax simple object oriented language assessment call graph construction algorithms grove chambers cecil separate notions languages unified subtyping inheritance hierarchy modeled requiring type inheritance declarations parallel 
multimethods generalize singly dispatched methods object oriented languages allowing classes message arguments influence target method invoked 
multimethod list immutable formals 
formal specialized class meaning method applicable message sends actuals instances corresponding specializing class subclasses 
assume presence root class classes inherit specializing class allows formal apply arguments 
multimethods name number arguments related partial order multimethod specific overriding tuple specializing classes specific pointwise 
message sent set multimethods name number arguments collected subset applicable actuals message unique specific multimethod selected invoked error reported method 
singly dispatched languages simulated specializing specializing root class formals commonly called self receiver singly dispatched languages 
procedures modeled methods formals specialized 
language includes explicit closure instantiation application operations 
closure application modeled special case sending message done cecil including explicit application operation simplifies specification analysis 
realistic language features viewed special versions basic features 
example literals particular class modeled corresponding class instantiation operations far class analysis concerned 
languages features super sends exceptions non local returns lexically nested functions easily accommodated omitted simplify exposition 
actual implementation vortex compiler supports core language features cecil java exception reflective operations dynamic class method loading perform primitives multithreading synchronization 
assume number arguments method message bounded constant independent program size static number interesting program features classes methods call sites variables statements expressions measure program size 
algorithm parameters general algorithm parameterized contour key selection functions collaborate define polices interprocedural class analysis call graph construction 
algorithm additional parameters constraint initialization function class contour set initialization function enable specialize constraint generation satisfaction behavior 
giving different values strategy functions general algorithm instantiated wide range specific call graph construction algorithms 
signature general algorithm required signatures contour key selection functions shown 
functions defined constituent domains call graph domain codomains formed applying pow domain constructor call graph domain parameterizing partial orders 
contour key selection functions algorithm viewed implying call graph domains result algorithm instantiation drawn 
particular roles played contour key selection functions procedure contour key selection function pks defines algorithm procedure context sensitivity strategy 
arguments contour specializing calling procedure call site identifier sets class contours passed actual parameters callee procedure 
returns set procedure contour keys indicate contours callee procedure analyze call 
analyze pks cks eks cif sif program callgraph pk ivk ck assessment call graph construction algorithms grove chambers instance variable contour key selection function collaborates class contour key selection function define algorithm data structure context sensitivity strategy 
responsible determining set instance variable contours analyze particular instance variable load store 
arguments instance variable accessed class contour set load store base expression object access occurring 
returns set instance variable contour keys 
class contour key selection function cks determines class contours created represent objects created class instantiation sites 
arguments class instantiated procedure contour containing instantiation site 
returns set class contour keys 
environment contour key selection function eks determines contours lexically enclosing procedure analyze free variables contained closure 
arguments closure instantiated procedure contour instantiation analyzed 
returns set tuples procedure contour keys encode lexical nesting relationship 
class contour representing closure reaches application site information initialize lexical parent information third component procid contours created analyze application see acs function 
contour key selection functions may ignore input information computing results 
main restriction behavior contour selection functions monotonic inputs result sets non empty 
general algorithm additional parameters roles discussed detail subsequent sections 
constraint initialization function cif allows algorithm choose generating equality bounded inclusion inclusion constraint express relationship class contour sets see section 
parameter class contour set initialization function sif allows algorithm specify initial value class contour set see section 
notation auxiliary functions section defines notational conventions auxiliary functions algorithm specification 
analysis sets class contours associated expression variable including formal parameters instance variable program 
class contour set associated program construct pc contour denoted algorithm computation consists generating constraints express relationships class contour sets determining assignment class contours class contour sets satisfies constraints 
constraint generation portion analysis expressed judgements form function monotonic iff procedure key selection function pks instance variable key selection function class key selection function cks environment key selection function eks pks callsite procedure pow prockey pow cks class pow classkey eks closure pow prockey signatures contour key selection functions pc pc assessment call graph construction algorithms grove chambers read analysis program construct pc context contour gives rise constraint set judgements combined inference rules informally understood inductively defining analysis program construct terms analysis subcomponents 
example seq rule describes analysis sequence statements terms analysis individual statements analyze program construct individual statements analyzed resulting constraints combined 
generalized constraints generated algorithm form non negative integer 
value set algorithm constraint initialization strategy function cif encodes upper bound constraint satisfaction sub system may perform satisfy constraint 
section discusses detail value influences constraint satisfaction vortex implementation algorithm 
key idea constraint solver basic mechanisms satisfying constraint superset propagate class contours unify single set 
solver allowed attempt propagate classes required unify 
generalized constraint bounded inclusion constraint allow bounded amount propagation occur behalf 
generalized constraint equality constraint sets unified soon constraint created 
generalized constraint inclusion constraint cause unification sets 
generalized constraint may optionally include filter set denoted restricts flow class contours class contours class component element filters enforce restrictions dataflow arise static type declarations method specializers 
number auxiliary functions concisely specify analysis helper functions simply named tuple map accessors return sub components tuple map domains construct call graph domain 
id contents access components similarly id accesses procid component proc id accesses procedure component procid id lex id accesses third lexical chain component procid id var formal access pieces codomain second variable mapping component var returns class set associated formal local variable formal returns th formal parameter 
type pc returns static type pc returns th formal method class hierarchy analysis determine type set classes subtype denoted determine class set classes inherit denoted subclasses 
defines additional helper functions encapsulates details expanding free variables 
expands lexical parent contour chain find procedure contours analyze variable procedure contour determines target contours instance variable load store class contour set base expression 
uses algorithm specific strategy function 
mcs acs determine callee contours message send closure application information currently available call site algorithm specific strategy function pks 
helper functions invoked applicable encapsulate language dispatching application semantics 
message name closure values argument class contours invoked computes set callee procedures closures 
callee procedure tuple argument class contours applicable returns narrowed tuple class contours includes class contours legally passed callee arguments 
main difference mcs acs computation encoded set possible lexical parents callee contours 
mcs simply uses root contour example language assessment call graph construction algorithms grove chambers include nested methods 
contrast acs extract set lexical chains second component closure class contours 
algorithm specification defines general algorithm specifying statement expression language constraints generated analysis declarations included directly add constraints solution declarations processed prior analysis construct class hierarchy method partial order 
static type information analysis statements ensure variables unnecessarily diluted assignments sets classes corresponding right hand sides filtered sets classes conform static type left hand sides 
occurs rules explicit assignments implicit assignments actuals formals return expressions result send apply body rules 
assignments source program statically type correct explicit filtering assignments beneficial algorithm instantiations may precise language static type system 
prog rule entry analysis top level statements expression analyzed context root contour specializing global scope 
statement sequencing seq expected analysis sequence statements entails adding constraints generated analysis statement 
assignment statements handled rules 
rules right hand side analyzed yielding constraints constraint added set class contours representing right hand side sets class contours representing left hand side 
rule left hand side class contour sets computed auxiliary function expand encoded contour lexical parent chain 
rule left hand side contours computed instance variable contour selector 
rule adds additional constraints generated analyzing base expression instance variable access 
basic expressions handled rules 
variable instance variable respective auxiliary functions find set target contours add constraints appropriate class contour set auxiliary functions defines enclosing defines true proc id procedure defines enclosing base enclosing base base proc id proc id key id pk pk lex id lex id pk pk iv base instvar id iv key id iv base mcs msg args cc args invoked msg args root acs expr args cc args invoked expr args lc expr lc lc cls class cls closure classkey cls lc cc args callees lcs proc id key id pks applicable args lex id lcs callees assessment call graph construction algorithms grove chambers program seq new closure send apply body root root var type contents type var contents new new key key cks cls cls cls key key eks cls cls lambda proc send msg 
formal send msg 
var result mcs msg 
proc subclasses proc proc apply 
formal apply 
var result acs 
proc subclasses proc 
var result specification general algorithm assessment call graph construction algorithms grove chambers target contour set class contours corresponding referencing expression 
assignment rules adds constraints generated analyzing base expression instance variable access 
analyzing class instantiation new rule entails adding constraint set class contours implied computed class contour key selection function set class contours representing new expression 
closure rule similar new rule uses environment contour key selection function compute set tuples prockey encode lexical chain procedure contours analyze free variables 
constraints generated send rule logically fall groups argument expressions send analyzed constraints included constraints generated send 
callee procedure contour kinds constraints generated actuals assigned formals callee body analyzed result returned auxiliary function mcs message contour selector invoked analysis message send expression compute set callee contours information currently available call site 
available information changes additional callee contours constraints added 
constraint graph lazily extended new procedures procedure contours reachable call site 
call graph nodes edges created added evolving solution side effect calling mcs 
analysis closure applications quite similar message sends 
key differences closure rule include analysis function value apply contour selector acs invoked compute set callee contours 
body rule defines analysis bodies methods closures 
allow varying levels context sensitivity safely coexist single analysis additional constraints required express global safety condition rule states identifiers instance variable contours related implies representing source level instance variable key conservative key second contents conservative contents second 
second rule imposes similar constraint class set map component procedure contours 
constraints ensure different degrees context sensitivity coexist requiring store occurs class set level context sensitivity conservative class contour appears corresponding class set conservative views source program construct 
algorithms described subsequent sections trivially satisfy second rule cfa trivially satisfy 
constraint satisfaction computing final solution combined interprocedural class analysis call graph construction problem iterative process satisfying constraints generated analysis adding new constraints class contour sets grow new procedures procedure contours reachable call sites 
number algorithms known solving systems set constraints 
section discusses constraint satisfaction mechanisms vortex implementation framework 
new formal send msg 
var result id id contents contents id id assessment call graph construction algorithms grove chambers initial values assigned sets large impact time required compute solution quality precision solution 
algorithm class contour set initialization function sif determines initial value assigned class contour sets right hand side constraints generated new closure rules initial value computed class key contour selection function 
common strategy initialize class contour sets empty optimistic assumption yield optimistic precise final result 
interesting possibilities 
example class distributions available seed class contour sets possibly reducing time consumed constraint satisfaction negatively impacting precision 
possibility selectively give pessimistic initial values hopes greatly reducing constraint satisfaction time small losses precision 
example common large programs polymorphic container classes arrays lists sets contain tens hundreds classes class set information tends useful program optimization cardinality set small algorithm initialize class contour sets container classes instance variable contours bottom set classes declared program 
may result faster analysis time analysis code manipulating container classes quickly converge final somewhat pessimistic solution significant reductions bottom line performance impact interprocedural analysis 
non iterative pessimistic algorithms modeled initializing class contour sets bottom 
vortex implementation framework goals section provide high level outline vortex implementation discuss role implementation framework highlight design choices briefly describe implementation key primitives 
aspects vortex implementation interprocedural class analysis call graph construction described previous papers 
overview vortex implementation general call graph construction algorithm closely follows specification section 
divided main subsystems constraint satisfaction constraint generation 
core constraint satisfaction subsystem worklist algorithm step removes unit worklist performs local propagation ensure constraints directly related unit currently satisfied 
unit may single node dataflow graph entire procedure contour depending algorithm instance uses explicit implicit representation program dataflow graph section 
satisfying constraints directly related single node simply entails propagating class contours necessary node immediate successors dataflow graph 
satisfying constraints directly related entire procedure contour entails local analysis contour reconstruct satisfy contour local intra procedural constraints propagation necessary resulting class contour information contour outgoing inter contour inter procedural dataflow edges may result adding contours worklist 
constraint generation subsystem implemented directly specification extensions support cecil java language features 
method defined kind vortex ast node add appropriate local constraints recursively evaluate constituent ast nodes generate constraints 
implied mcs acs functions constraints generated lazily constraints generated contour procedure pair class contour sets associated procedure formal parameters non empty signifying contour procedure pair determined reachable analysis section describes efficient implementation lazy growth constraint graph 
syntax tree commonly representation program 
see aho 
assessment call graph construction algorithms grove chambers implementation framework implementation general call graph construction algorithm consists lines cecil code 
approximately lines common code implement core data structures call graphs dataflow graphs contours class sets constraint satisfaction generation subsystems interface exported vortex subsystems mix classes implement common procedure class instance variable contour selection functions 
instantiating framework straightforward algorithms described empirically evaluated subsequent sections implemented vortex lines glue code combine appropriate mix classes resolve ambiguities introduced multiple inheritance 
addition enabling easy experimentation implementation framework provides level playing field cross algorithm comparisons 
algorithms call graph resulting interprocedural summaries uniformly calculated exploited single optimizing compiler 
algorithms library core data structures analysis routines depending algorithms implicit explicit representation intraprocedural dataflow graph discussed usage portions library different 
flexibility free achieved inserting level indirection form message sends decision points 
believe overhead affects absolute cost call graph construction relative cost algorithms implemented framework asymptotic behavior algorithms 
design choices implicit vs explicit dataflow graphs important considerations implementation framework managing time space trade offs 
previous systems explicitly construct entire reachable interprocedural data control flow graphs 
approach may viable smaller programs simple algorithms careful design underlying data structures memory requirements quickly unreasonable context sensitive analysis larger programs 
feature vortex implementation ability allow algorithms choose explicit implicit representation program dataflow graph 
implicit representation sets class contours visible contour boundaries corresponding formal parameters local variables accessed lexically nested functions procedure return values instance variables represented persistently 
derived class sets intra interprocedural data control flow edges re computed demand 
greatly reduces space requirements analysis increases computation time dataflow relationships continually recalculated granularity reanalysis larger 
additional limitation implicit dataflow graph support efficient unification implementation equality bounded inclusion constraints discussed section 
reducing memory usage important vortex implementations algorithms generate inclusion constraints cfa cfa cpa scs utilize implicit representation 
iteration order key component constraint satisfaction sub system worklist abstraction drive iteration 
obvious implementations worklist include recursion obtain implicit stack explicit stack explicit queue 
algorithms implicit dataflow graph representation coarsegrained unit choice worklist implementation large impact analysis time 
stack implementation yields lifo ordering queue implementation yields fifo ordering 
intuitively lifo ordering advantage analysis callee contours done analysis caller contour ensuring date sets classes results returned callees available analysis caller 
hand fifo ordering advantage potentially batching multiple re analyses contour 
example contour initially enqueued reanalysis analysis callers determined argument class sets passed assessment call graph construction algorithms grove chambers contour grown causing new elements added class contour sets representing contour formal parameters 
contour enqueued analysis callers may result additional widening enqueued contour formals 
updates handled single reanalysis contour reaches front queue 
informal performance tuning revealed effects important result vortex implementation uses hybrid fifo ordering 
uses queue time contour encountered immediately analyzed recursion enqueued analysis 
program representation interprocedural class analysis operates summarized ast representation program 
summarized ast abstracts program collapsing non object dataflow ignoring intra procedural control flow 
dataflow portion procedure dataflow statically guaranteed consist values directly influence targets invoked call site values objects functions sent messages applied 
example arbitrary side effect free calculation native non object integers represented integer ast summary node 
second part summarization removes side effect free computations results influence control flow 
summarized ast representation control flow insensitive summarizing non object dataflow degrade analysis precision 
control flow insensitive representation theoretically result precise results control flow sensitive representation 
assess importance intra procedural control flow sensitivity class analysis analyzed cecil java programs summarized ast representation control flow sensitive control flow graph representation 
measurable difference bottom line application performance programs analyzed different representations flow insensitive ast analysis roughly twice fast 
approximate set union operations propagation class contour information data flow graph main costs interprocedural class analysis 
especially true algorithms implicit representation dataflow graph procedure contour unit analysis may result large amount unnecessary re analysis time class contour set formal free variable callee result changes 
reduce problem exploit observation subclasses common parent class elements class contour set subclasses parent class eventually added set 
set union element addition operation cardinality result set exceeds threshold value compaction phase examines set see classes set share common parent class 
preserve precise results compacting candidate common parent fewest number subclasses included union selected subclasses added set 
approximation reduces size set representation vortex supports compact cone representation class set corresponding class subclasses dean may reduce total number times set contents change eagerly performing subsequent class additions single step 
previous version vortex system experiments large cecil programs showed eager approximation reduced cfa analysis time factor resulting slowdowns resulting optimized executables 
small cecil programs addition causing larger performance degradations technique increased cfa analysis time overly conservative class sets led analysis unreachable portions standard library 
implementation key primitives lazy constraint generation mcs acs functions ensure class contour sets representing formal parameters contour non empty body procedure analyzed context contour generate constraints 
assessment call graph construction algorithms grove chambers straightforward implementation requirement explicitly check see formal class contour sets contour non empty time element addition causes formal class contour set transition empty non empty set non empty contour analyzed 
alternative efficient method vortex implementation explicit dataflow graph 
dataflow edges corresponding actual formal dataflow caller callee pair grouped barrier 
barrier maintains count edges class contours blocked waiting barrier broken edges blocked classes barrier released callee contour guards analyzed 
filters rules analysis restrict flow class contours certain edges dataflow graph interposing filter derived static type declarations language dispatching semantics 
explicit dataflow graph representation filters implemented optionally associating filter class set implemented bit set edge dataflow graph filter prevents class contours class components elements filter set propagated edge 
implicit dataflow graph filters implemented filter ast nodes 
filter ast node contains expression sub tree filter class set value filter ast node intersection filter class set class set produced value expression sub tree 
bounded inclusion constraints equality constraints define near linear time binding time heng alias analyses 
algorithms soon nodes dataflow graph determined connected collapsed single node signifying respectively source constructs represented nodes binding time potentially aliased 
algorithms fast scalable quite imprecise 
bounded inclusion constraints attempt combine efficiency equality constraints precision inclusion constraints allowing bounded amount propagation occur inclusion constraint replacing equality constraint 
vortex implementation algorithms equality bounded inclusion constraints explicit dataflow graph representation 
edge dataflow graph counter initialized match value associated generalized inclusion constraint time constraint satisfaction sub system attempts propagate class contour edge edge counter decremented 
counter reaches bounded inclusion constraint effectively equality constraint 
satisfaction effective equality constraints effective equality constraint equality constraint bounded inclusion constraint counter decremented 
constraint satisfaction sub system allowed incur propagation costs behalf effective equality constraints alternative satisfaction method 
nodes dataflow graph linked effective equality constraints unified single node fast union find data structures 
unifying nodes dataflow graph causes class contour sets associated node combined constraint satisfied additional logical sets represented actual set 
depicts effect unification portion program dataflow graph nodes represent sets class contours directed edges nodes indicate bounded inclusion constraints 
propagation occurred dashed edge nodes sufficient number times trigger unification edge may filter blocks class contour propagated edge 
regardless class passes filter edge counter decremented 
assessment call graph construction algorithms grove chambers resulting dataflow graph shown 
final graph class contours flowing edge new node propagated original node successors incurring cost crossing non existent edge 
class contours flowing edge new node propagated successor nodes initial graph class contours arriving edge reach node unification potentially reduced precision final results analysis 
lazy constraint generation unification constraints generated lazily procedures proven reachable constraint generation constraint satisfaction phases overlap 
may necessary add constraint source node collapsed dataflow graph unification 
done safely adding constraint unif node dataflow graph currently representing set unified nodes includes ensuring class contours currently unif class contour set propagated new edge 
implementation takes simpler approach forcibly unifies nodes downstream unif filter edges dataflow graph edges uniform values approaches equivalent 
algorithms implemented far uniform values filters edges graph forcible unification approach overly pessimistic 
experimental methodology section describes experimental methodology 
data sections selected subset grove ph thesis 
focuses answering primary questions costs constructing program call graph particular call graph construction algorithm 
extent differences call graph precision impact effectiveness client interprocedural analyses 
benchmark description experiments performed cecil cham java programs described table 
exception cecil programs applications substantial size 
previous experimental assessments call graph construction algorithms exclusively benchmark programs consisting tens hundreds lines source code previous studies included larger programs ranged size lines code 
program size important issue call graph unification unification initial graph final graph unif assessment call graph construction algorithms grove chambers construction algorithms worst case running times polynomial size program 
data sections demonstrate bounds just theoretical concern practice algorithms exhibit running times appear super linear program size practically applied programs lines code 
conversely algorithms quite successful analyzing programs lines code suggesting benchmarks need certain minimal size contain interesting polymorphic code useful tools assessing call graph construction algorithms 
experimental setup experiments conducted vortex compiler infrastructure 
basic methodology augment optimized base configuration interprocedural analyses performed call graph constructed algorithms 
profile guided class prediction demonstrated important optimization object oriented languages may desirable include optimizing compilers experiments base configurations purely static profile guided class prediction 
benchmark programs compiled configurations base configuration represents aggressive combination intraprocedural limited interprocedural optimizations include intraprocedural class analysis john cham hard wired class prediction common messages cecil cham splitting cham class hierarchy analysis fern dean inlining static class prediction dean closure optimizations identify stack allocate sink partially dead closure creations cecil suite traditional intraprocedural optimizations common subexpression elimination constant propagation folding dead assignment elimination redundant load dead store elimination 
table description benchmark programs program lines excluding standard libraries 
cecil versions richards deltablue include line subset standard library cecil programs include full line standard library 
java programs include line standard library 
description richards operating systems simulation deltablue incremental constraint solver instr sched global instruction scheduler typechecker cecil share approximately lines common support code type checking algorithms completely separate written different people 
typechecker old cecil type system new tc typechecker new cecil type system compiler old version vortex optimizing compiler circa cassowary constraint solver toba java bytecode translator java cup parser generator espresso java source bytecode translator java translators common non library code developed different people 
javac java source bytecode translator pizza pizza compiler assessment call graph construction algorithms grove chambers base configuration augments base profile guided class prediction 
programs non trivial inputs different input sets collect profile data gather dynamic statistics application execution time 
call graph construction algorithm base ip configuration augments base interprocedural analyses enable intraprocedural optimizations included base better class analysis side effect constructing call graph formal local global instance variable associated set classes instances may stored variable 
intraprocedural class analysis exploits sets upper bounds precise possible classes enabling better optimization dynamically dispatched messages 
mod analysis interprocedural analysis computes procedure set global variables instance variables potentially modified calling procedure 
intraprocedural analyses exploit information accurately estimate potential effect non inlined calls local dataflow information 
exception detection interprocedural analysis identifies procedures guaranteed raise exceptions execution 
information exploited streamline calling conventions simplify intraprocedural control flow downstream calls exception free routines 
escape analysis interprocedural escape analysis identifies class functions guaranteed outlive lexically enclosing environment enabling function objects environments 
analysis generalized enable stack allocation objects current vortex implementation optimizes closures environments escape analysis applies cecil benchmarks 
side effect constructing call graph compiler identifies procedures unreachable program execution 
compiler compile unreachable procedures resulting substantial reductions code size compile time 
base ip configuration augments base ip configuration profile guided class prediction 
dynamic profile data derived iteratively optimizing profiling base configuration configurations 
methodology may slightly benefits profile guided class prediction base ip configurations additional inlining enabled interprocedural analysis result longer inlined chains methods 
potentially precise profile information obtained iteratively profiling base ip configuration 
effect quite small profile data configuration program variable eliminated experiments 
experiments performed sun ultra model sparcstation mb physical memory gb virtual memory running solaris 
programs configurations vortex compiled input programs code compiled gcc version option 
metrics focus direct costs call graph construction bottom line impact call graph precision effectiveness interprocedural optimizations 
previous contained extensive experimental results included metrics call graph precision secondary effects impact call graph precision interprocedural analysis time relative contributions interprocedural analyses improvements application performance 
primary cost call graph construction algorithm compile time expended running algorithm 
primary metric assess direct cost particular algorithm cpu time consumed constructing information call chain profiles interactions inlining details profile guided receiver class prediction vortex 
combined system user mode cpu time reported 
assessment call graph construction algorithms grove chambers call graph 
additional concern amount memory consumed call graph construction working set call graph construction algorithm fit available physical memory due paging effects cpu time accurately reflect real wall clock time required call graph construction 
algorithm memory requirements approximated measuring growth compiler heap size call graph construction metric somewhat conservative account details garbage collection algorithm may overestimate algorithm peak memory requirements 
call graph precision affect quality information computed interprocedural analyses affecting bottom line application performance 
assess importance call graph precision focus changes application runtime cpu time 
note minor variations application runtime may significant instruction caching effects cause application runtime noticeably vary independent optimizations enabled interprocedural analysis 
example simply running strip utility executable observed yield changes application runtime 
lower upper bounds impact call graph precision section establishes lower upper bounds potential importance call graph precision impact interprocedural analyses programs benchmark suite 
providing estimate total potential benefits extremely precise call graph fraction benefits achievable simple call graph construction algorithms section provides context experimental assessment call graph construction algorithms sections 
algorithm descriptions lower bound algorithms true lower bound benefit call graph precision obtained performing interprocedural analysis call graph call site assumed invoke procedure program 
needlessly pessimistic precise call graph selector constructed superficial analysis program 
selector improves removing call edges call sites procedures incompatible message names numbers arguments vortex front ends name disambiguate static overloading message names selector take advantage static type information 
limited analysis program improve precision selector axes 
class hierarchy analysis cha improve selector exploiting information available static type declarations methods applicable classes subtypes receiver invoked specialized formal parameters body method message sent specialized formals enclosing method methods applicable specializing class subclasses invoked 
statically typed languages unified inheritance type exploiting specialized formal parameters just special case exploiting static type declarations languages cecil sources information separable 
number systems class hierarchy analysis resolve message sends build program call graphs fern dean 
second assuming methods declared program invocable call graph construction algorithm optimistically assume method reachable discovers reachable procedure instantiates class method applicable reachable 
optimistic computation method class liveness novel idea bacon sweeney rapid type analysis strip simply removes symbol table relocation bits executable name extends function names include encoding static types arguments return value 
example method foo int int float name foo rf 
assessment call graph construction algorithms grove chambers rta linear time call graph construction algorithm combines class hierarchy analysis optimistic reachability analysis build call graph 
diwan modula optimizer intraprocedural class analysis increase precision selector cha reachable rta improving analysis messages sent objects created method 
upper bound algorithms ideal basis interprocedural analysis provide upper bound potential benefits call graph precision interprocedural analysis definition ideal precise sound call graph 
unfortunately ideal generally uncomputable 
loose upper bound established profile data build exact representation calls occurred particular run program 
sound call graph conservatively approximate program behavior particular input benchmarks deterministic 
obtain upper bound performance benefits call graph precision optimizer instructed assume sound resulting optimized program rerun input 
note ip optimized program run input compute incorrect result 
theory precise ideal limitations vortex profiling infrastructure prevent gathering fully context sensitive profile derived class distributions actual profile derived call graph prof vortex builds precise precise optimal contextinsensitive call graph 
direction may loose upper bound single run fully exercise program 
believe second concern loose upper bound significant problem benchmark programs 
input data sets chose exercise portions program programs compiler applications behavior highly dependent details input 
partially support claim built second prof configuration compiler program optimistic call graph constructed combining profile data gathered different runs program 
optimization combined prof resulted slowdown relative single run prof experimental assessment establish lower upper bounds bottom line impact call graph precision interprocedural analysis performed call graph construction algorithms discussed selector prof displays normalized execution speeds base base ip selector base ip prof base base ip selector base ip prof configurations application 
convention stacking bars configurations differ presence absence profile guided class prediction top static bar shaded additional speedups enabled profile guided class prediction indicated white bar 
absence white bar indicates profile guided class prediction impact performance case measurable slower explicitly noted text 
emphasize base highly optimized unopt configuration shown vortex optimizations performed resulting files compiled gcc difference unopt base configurations indicates effectiveness vortex basic optimizations suite 
difference base ip prof configurations approximates maximum speedup achievable current vortex system arbitrarily precise call graph construction algorithm 
ip selector configurations illustrate benefit vortex profiling infrastructure described detail 
key issue profile derived class distributions gathered vortex tagged finite length segments dynamic call chain limited degree method inlining 
building context sensitive may require profile data tagged arbitrarily long finite segments dynamic call chain 
prof prof prof prof prof pro prof prof assessment call graph construction algorithms grove chambers obtained extremely simple cheap call graph construction algorithm 
ambitious call graph construction algorithms may profitable substantial performance gap ip selector ip prof configurations 
programs performance difference base ip selector base ip prof large base base ip prof indicating aggressive call graph algorithms selector required reap potential benefits interprocedural analysis 
cecil programs potential benefit quite large 
base ip prof dominates base prof larger benchmarks yields speedups ranging factor base 
potential improvements java benchmarks smaller entirely unexpected combination java hybrid object model static type system unopt efficient cecil optimizations included base configuration effective leaving remaining overhead interprocedural analysis attack 
cassowary base ip prof roughly faster base potential benefits smaller remainder java programs 
upper lower bounds impact call graph precision richards deltablue instr sched typechecker new tc compiler cecil speedup cassowary toba java cup espresso javac pizza java speedup profile guided class prediction unoptimized base base ip selector base ip profile assessment call graph construction algorithms grove chambers basic algorithm cfa cfa algorithm classic context insensitive data flow sensitive call graph construction algorithm 
produces precise call graph selector lower bound algorithms section performing iterative interprocedural data control flow analysis program call graph construction 
resulting precise call graph may enable substantial improvements provided selector cfa algorithm described context control flow analysis scheme programs shivers 
basic cfa strategy number call graph construction algorithms palsberg schwartzbach basic algorithm pals hall kennedy call graph construction algorithm fortran hall lakhotia algorithm building call graph languages higher order functions derived cfa 
algorithm description cfa uses single point lattice lattice value prockey classkey partial orders 
general algorithm instantiated cfa parameters procedure instance variable class cfa contour key selection functions return singleton set resulting selection single contour analysis time representation procedure instance variable class 
uniformly setting cfa generates simple inclusion constraints non specified class contour sets optimistically initialized empty set 
experimental assessment reports costs cfa algorithm plotting call graph construction time heap space growth function program size measured number call sites program 
note axis log scale 
largest cecil programs call graph construction substantial cost consuming roughly minutes cpu time typechecker new tc just hours compiler 
large analysis times due paging effects 
heap growth call graph construction substantial mb typechecker new tc mb compiler mb physical memory machine cpu utilization averaged call graph construction 
cfa algorithm exhibited better scalability java programs largest programs call graph construction consumed minutes cpu time 
largest java program significantly smaller largest cecil program call sites vs may explain apparent qualitative difference cfa call graph construction times 
reliably compare scalability cfa algorithm cecil java larger java programs call sites required 
comparably sized programs appears cfa call graph construction takes roughly factor longer cecil java 
suspect major cause difference heavy closures cecil programs results larger number analysis time classes cecil programs increases amount propagation 
example typechecker contains classes closures effective total classes pizza contains class closures 
reports bottom line performance impact cfa displaying execution speeds ip cfa configurations benchmark third pair bars 
enable easy comparison execution speeds obtained base ip selector ip prof configurations repeated 
smallest cecil programs cfa enables potentially available speedup embodied ip prof configuration 
larger cecil programs cfa enables roughly half potentially available speedup substantially performs base remaining pks caller callsite callee procedure cks class eks closure cif sif assessment call graph construction algorithms grove chambers large gap ip prof indicates context sensitivity enable additional performance gains 
critical difference small large cecil programs amount truly polymorphic code 
programs generic hash table set library classes richards deltablue small contain multiple clients polymorphic library routines different ways store objects different classes 
programs larger cfa inability accurately analyze polymorphic code important 
performance impact cfa java programs fairly bi modal programs enables speedups comparable ip prof ineffective 
context sensitive algorithms contrast cfa algorithm context sensitive algorithms create contour program procedures instance variables classes 
section defines assesses context sensitive algorithms cfa cpa scs 
algorithms generate simple inclusion constraints costs cfa call graph construction cecil java program size number call sites sec min min hr hrs hrs call graph construction time program size number call sites sec min min hr hrs hrs call graph construction time program size number call sites mb mb mb call graph construction space cfa program size number call sites mb mb mb call graph construction space assessment call graph construction algorithms grove chambers algorithm descriptions context sensitivity call chains commonly forms context sensitivity vector enclosing calling procedures call site select target contour callee procedure call strings approach sharir pnueli shar 
degenerates single point lattice context insensitive algorithm cfa prockey corresponds analyzing callee contour separately source level call site classkey corresponds treating distinct source level instantiation site class giving rise separate class contour 
algorithm may fixed value program shivers cfa family algorithms scheme cfa extension palsberg schwartzbach algorithm various adaptations cfa object oriented programs phil 
sophisticated adaptive algorithms try different levels different regions call graph flexibly manage trade analysis time precision 
number algorithms arbitrarily large finite values proposed ryder call graph construction algorithm fortran callahan extension ryder support recursion call emami alias analysis algorithm performance impact cfa richards deltablue instr sched typechecker new tc compiler cecil speedup cassowary toba java cup espresso javac pizza java speedup profile guided class prediction base base ip selector base ip cfa base ip profile assessment call graph construction algorithms grove chambers treat non recursive path call graph creating new context 
alt martin developed aggressive call graph construction algorithm pag system levels recursion alt 
steensgaard developed unbounded call chain algorithm handles nested lexical environments applying widening operation class sets formal parameters entries recursive cycles call graph 
object oriented programs shivers cfa family algorithms straightforwardly extended cfa family algorithms denotes degree context sensitivity prockey domain denotes degree context sensitivity classkey domain phil 
partial orders contour keys algorithms detailed contour key selection functions defined auxiliary function general algorithm instantiated parameters cfa family algorithms procedure context sensitivity strategy cfa family algorithms identical original cfa algorithms 
cks functions collaborate enable context sensitive analysis instance variables 
cks tags classes contour created 
separate class contour set representing contents instance variable maintained class classkey pair 
uses base expression instance variable load store determine instance variable contours analyze access 
note practice larger values additional benefit context sensitivity parameters commonly basis context sensitive analysis procedures abstraction actual parameter values passed procedure call sites 
example abstraction alias relationships actual parameters basis context sensitivity algorithms interprocedural alias analysis land 
similarly call graph construction algorithms object oriented languages information classes actual parameters critical input procedure contour key selection functions 
algorithms attempt improve brute force approach call chain context sensitivity sophisticated notions callers similar share callee contour callers different require distinct callee contours 
algorithms cartesian product algorithm cpa ages simple class set algorithm scs 
primary difference algorithms procedure contour key selection function 
cpa uses prockey partial order scs uses algorithm prockey classkey cfa procedure single point lattice single point lattice cfa procedure procedure pks caller cs ccs callee proc id caller key id caller cks class proc id key id eks closure contains non global free variables key id lc lc lex id cif sif assessment call graph construction algorithms grove chambers algorithms single point lattice classkey partial orders 
general algorithm instantiated parameters cpa scs uses algorithms generate inclusion constraints initialize class contour sets empty set 
cpa callee procedure procedure contour key selection function computes cartesian product actual parameter class contour sets procedure contour selected created element 
scs callee procedure procedure contour key selection function returns single contour key exactly tuple actual parameter class contour sets single contour callee procedure created selected call site 
obtain contour reuse cpa breaks analysis callee procedure number small pieces hope call sites procedure overlapping tuples class contour sets able reuse contours call site 
contrast scs reuse callee contour call sites identical tuples class contour sets passed actual parameters 
hand cpa may create large number contours analyze callee benefit precise formal class contour sets 
illustrate context sensitivity strategies cpa scs contains program resulting scs cpa call graphs 
node represents contour labeled procedure prockey components procid 
multiple contours created procedure grouped dashed oval 
notice scs call graph contour procedure invoked call site 
example illustrates way cpa may produce precise result scs 
cpa call graph contours representing double num invoke contours int int float float 
scs call graph double num invokes contour num num 
worst case cpa may require contours analyze call site number arguments call site 
assumption bounded constant worst case analysis time cpa polynomial size program ages 
worst case scs may require contours analyze program 
avoid requiring unreasonably large number contours practice agesen implements variant cpa term bounded cpa cpa uses single context insensitive contour analyze call site number terms cartesian product actual class sets exceeds threshold value 
similarly bounded agesen implementation cpa self uses complex eks function reduces number closure contours fusing closure contours subset enclosing procedure formal parameters 
optimization difficult express framework included vortex implementation cpa 
see section ages detail 
pks caller cs callee proc cpa cpa 

cks class eks closure contains non global free variables key id lc lc lex id cif sif pks caller cs callee proc cks class eks closure contains non global free variables key id lc lc lex id cif sif assessment call graph construction algorithms grove chambers cpa scs example procedure random return double procedure random return double double double cpa scs num num double num double double double num num num class num method num num method double num return class float inherits num method float float class int inherits num method int int 
assessment call graph construction algorithms grove chambers variant scs scs defined limit number contours created procedure falling back context insensitive summary procedure contour creation budget exceeded 
experimental results section data cpa scs algorithms 
unbounded cpa scale large cecil programs 
bounded scs considered majority benchmark programs unbounded scs required analysis time cpa despite worst case exponential time complexity 
presence lexically nested functions cpa scs vulnerable recursive customization class contour key selection function closure class encode lexically enclosing contour 
leads mutual recursion prockey classkey partial orders results infinitely tall call graph domain 
agesen defines recursive customization problem gives methods conservatively detecting occurs enabling widening operation applied procedure contour key selection function ages 
vortex implementations cpa scs weakest methods programmer annotation methods may induce recursive customization 
context sensitive call graph construction algorithms object oriented languages defined exploiting similar ideas 
eager splitting component phase plevyak iterative refinement algorithm equivalent unbounded cpa implementation plevyak algorithm scale large cecil programs 
pande algorithm interprocedural class analysis pand built landi alias analysis land uses extension landi conditional points information basis context sensitivity 
prior developing cpa agesen proposed hash algorithm improve analysis self programs ages 
hash algorithm context sensitivity decisions hashing description calling context call sites target method compute hash value share callee contour 
original hash algorithm computed simple hash function limited information returned single value restricting analysis single callee contour call site agesen extended hash algorithm allow hash function include current sets argument classes part input return multiple hash values single call site ages 
experimental assessment time space costs subset context sensitive call graph construction algorithms plotted functions program size comparison costs cfa algorithm included 
program algorithm combinations call graph construction complete hours cpu time 
particular context sensitive algorithms successfully analyze compiler cfa completed typechecker new tc higher values cfa failed complete largest java programs 
intelligent context sensitivity strategies cpa scs resulted lower analysis time costs brute force approach cfa 
shows bottom line benefits additional call graph precision enabled context sensitive interprocedural class analysis comparison speedups obtained ip cfa ip prof shown 
bars grouped sets base ip selector ip cfa configurations ip cfa configurations ip ip scs ip prof configurations 
missing bars indicate combinations complete 
despite improvements precision context sensitive analysis enabled reliably measurable improvement cfa smallest cecil programs java programs 
typechecker new tc cfa improve cfa reach performance ip prof configurations suggesting improvements may possible scalable precise context sensitive algorithm developed 
programs current context sensitive call graph construction algorithms attractive option 
significant speedups cfa enabled call graph construction costs prohibitively high 
assessment call graph construction algorithms grove chambers approximations cfa goal context sensitive algorithms discussed previous section build precise call graphs built cfa enabling effective interprocedural analysis larger bottom line application performance improvements 
algorithms section take opposite approach trying improve precision cfa attempt substantially reduce call graph construction time preserving possible bottom line performance benefits obtained cfa 
algorithm descriptions cfa algorithm generates inclusion constraints 
basic constraint satisfaction method inclusion constraints propagate class contour information sources sinks program dataflow graph fixpoint reached 
solution method results worse case time complexity measure program size 
follows fact edges dataflow graph class contours costs context sensitive call graph construction cecil java cfa cfa cfa cfa cfa scs program size number call sites sec min min hr hrs hrs call graph construction time program size number call sites sec min min hr hrs hrs call graph construction time program size number call sites mb mb mb call graph construction space program size number call sites mb mb mb call graph construction space assessment call graph construction algorithms grove chambers may need propagated edge 
heintze mcallester describe alternative solution method cfa constructing control flow graph requires time compute solution 
applies programs bounded size types hein 
contrast cfa approximation techniques defined section applicable program yield precise analyses cfa 
unification approximation replace inclusion constraints generated cfa bounded inclusion constraints constant non negative integer 
families algorithms defined section uniform value constraint graph number strategies possible 
described previously section distinct class contours propagated bounded inclusion constraint bound source sink nodes connected constraint unified guaranteeing performance impact context sensitive algorithms base base ip cfa base ip cfa base ip cfa base ip cfa base ip cfa base ip cfa base ip cfa base ip base ip scs base ip profile richards deltablue instr sched typechecker new tc compiler cecil speedup cassowary toba java cup espresso javac pizza java speedup assessment call graph construction algorithms grove chambers constraint satisfied avoiding propagation nodes 
unifying nodes may result reverse propagation class contours dataflow graph degrading precision final analysis result unification analysis partially data flow insensitive 
equality constraints unify nodes soon connected dataflow define near linear time algorithms binding time analysis heng alias analysis 
ashley explored reducing propagation costs utilizing bounded inclusion constraints control flow analysis scheme programs utilized support inlining 
addition approximating cfa applies technique develop approximate cfa analysis 
shapiro horwitz developed family alias analysis algorithms mix propagation unification yield precise results steensgaard algorithm substantially improving complexity purely propagation algorithm 
bounded inclusion constraints shapiro horwitz randomly assign node dataflow graph categories 
nodes category connected edge immediately unified nodes different categories unified 
initial assignment nodes categories large effect final results analysis propose second algorithm runs basic algorithm times time different random assignment nodes categories 
call merging call merging asymptotically reduces number edges dataflow graph introducing factoring node call sites callee procedures selector 
illustrates call merging shows connections required connect call sites selector callee procedures selector shows connections required call merging utilized 
simplify picture single edge shown connecting node actual dataflow graph single edge expand set edges connecting actual formal pair return result pair 
call merging reduces number edges program dataflow graph enables reduction worst case analysis time 
analysis time reduction may come cost lost precision 
merged dataflow graph callee procedure reachable selector call sites deemed reachable selector call sites leading potential dilution class contour sets subsequent additional imprecisions final program call graph 
call merging modeled pre pass transforms program source prior running call graph construction algorithm 
pre pass creates method selector new unique name contains direct calls selector methods 
result selector method union result normal callees 
call sites original program replaced direct calls appropriate selector method 
algorithms families algorithms approximate cfa techniques described 
families algorithms simplistic strategy generating bounded inclusion constraints uniform constant value control unification vs propagation decisions 
families distinguished presence absence call merging bounded call merging second bounded linear edge 
constant values instances bounded algorithm worst case time complexity instances bounded linear edge worst case time complexity na 
selector encodes message name number arguments example selector send union message arguments union 
note vortex front ends name encode static overloading message names selectors encode information source language static type system 
inverse ackermann function introduced fast union find data structures 
practice assessment call graph construction algorithms grove chambers unification performed 
bounded algorithm exactly cfa approximation performed worst case time complexity 
bounded linear edge algorithm worst case time complexity defouw called degenerate case bounded linear edge linear edge cfa 
bounded linear edge algorithm similar bacon sweeney rapid type analysis rta 
key difference algorithms rta builds single global set live classes bounded linear edge maintains set live classes disjoint region program dataflow graph 
due simpler unification scheme rta precise bounded linear edge slightly better worst case time complexity 
exception small programs theoretical differences algorithms result significant differences analysis time bottom line performance benefit 
versions families algorithms assessed include additional approximation creating unique class source level closure closures number arguments considered instances single class apply method union apply methods individual reachable closures appropriate number arguments 
vortex implements families algorithms closure approximation previous experiments shown approximation closures reduces analysis time roughly factor cases having measurable impact bottom line application performance 
experimental assessment experimental results pair graphs program 
graph plots lines bounded bounded linear edge varies denoted axis 
analysis cost reported graph pair shows call graph construction time cpu seconds 
second graph dataflow graph call merging call site call site call site call site callee callee callee call merging call site call site call site call site method callee call merging selector method method callee method callee assessment call graph construction algorithms grove chambers approximations cfa analysis time execution speedup base bounded linear edge base bounded base bounded linear edge base bounded cassowary base toba base java cup base espresso base javac base pizza base analysis time execution speedup richards base deltablue base instr sched base typechecker base new tc base compiler base cecil java assessment call graph construction algorithms grove chambers pair reports application execution speed normalized base 
second graph lines plotted base ip base ip configurations 
memory usage shown 
constant values memory concern bounded linear edge algorithm example compiler program required mb 
memory issue bounded algorithm 
constant values call graph construction compiler program consumed mb terminate memory usage quickly grew gb days thrashing configuration killed 
typechecker new tc programs bounded consumed just mb call graph construction 
surprisingly benchmarks additional precision near quadratic time bounded algorithm enable measurable performance improvements obtained near linear time bounded linear edge algorithm 
expect near linear time algorithm significantly faster requires memory preferred 
additional call graph precision enabled bounded inclusion constraints equality constraints vs translate significant improvements bottom line application performance 
programs interesting inverse knee analysis times curves intermediate values affect caused interactions propagation unification 
increases propagation allowed edge dataflow graph tending increase analysis time 
larger values result precise call graphs making dataflow graph smaller removing additional unreachable call graph nodes edges reducing analysis time 
second effect requires moderate degree propagation significant gets larger program size increases knee gradually shifts right programs increase size 
intermediate values data flow graph significantly smaller propagation incurred edges dataflow nodes eventually unified 
summary comparison call graph construction algorithms depicts relative precision call graph construction algorithms described implemented vortex compiler 
algorithm precise algorithm input programs precise exists input program precise transitive relationship depicted placing connecting line segment 
sound algorithms construct call graphs conservative approximations ideal optimal sound call graph greatest lower bound context sensitive call graph construction algorithms produce call graphs precise produced cfa depicted lattice 
convention various algorithm names stands arbitrarily large finite integer value infinite values parameter represented relationships instances parameterized family algorithms implied values parameters 
example cfa family algorithms form infinitely tall infinitely wide sub lattice 
increasing degree context sensitivity analysis data structures procedures improves call graph precision independent axes relationship pairs algorithms cfa cfa 
similarly bounded bounded linear edge families algorithms form parallel infinitely tall sub lattices positioned rta cfa 
implications call merging unification different relationship bounded bounded linear edge exist programs produces precise call graph 
interesting portions lattice depicting relationships cpa scs cfa cfa 
unfortunately lattice theoretic definition call graphs section determine relationship pairs algorithms incomparable prockey partial orders discussion informal somewhat speculative indicated dotted lines 
algorithms context insensitive strategy analyze data structures 
precision differences due handling polymorphic functions 
context sensitive analysis functions increase call graph small constant pro assessment call graph construction algorithms grove chambers relative precision computed call graphs ideal selector rta cfa scs cfa cfa cfa cfa cfa cfa cfa cfa cfa cfa cfa cfa 
cfa cfa 
cfa 
cpa scs cpa cfa prof optimistic sound prof prof prof prof 
bounded linear edge bounded bounded linear edge bounded bounded linear edge bounded bounded linear edge bounded bounded linear edge 
cfa reachable cha assessment call graph construction algorithms grove chambers precision increasing precision procedure formal class sets creating distinct contours distinguish call sites different argument class sets 
definition cpa scs create new contours argument class sets differ construct call graphs precise generated cfa cfa 
interestingly programs scs cpa generate call graphs precise produced cfa cfa 
programs shown 
depicts program scs cpa cfa compute precise call graphs cfa 
levels wrapper procedures result cfa determining num num method invoked call site wrap 
algorithms mistake 
repeats example section illustrate cpa precise scs 
applying scs cfa cfa program results call graph num num possible callee double 
cpa call graph contain inaccuracy 
cpa precise algorithms scs cfa equally precise 
summarize costs benefits different call graph construction algorithms basis interprocedural analysis subsequent optimization repeat subset experimental results 
selector prof algorithms section represent lower upper bounds performance impact achievable vortex interprocedural analysis 
bounded linear edge section cfa section scs section algorithms represent substantially different regions algorithmic design space ranging fairly fast imprecise algorithms slow fairly precise algorithms 
choice bounded linear edge algorithm performance algorithm largest cecil benchmarks 
optimal values vary program program example cassowary results virtually improvement base shows benefits matches cfa benchmarks typically reports normalized execution speeds obtained base ip base ip configurations call graph construction algorithms 
base base configurations shown comparison 
shows call graph construction costs plotted function program size 
programs context sensitive example programs call chain vs parameter context sensitivity class num method num num method double num return class float inherits num method float float class int inherits num method int int main test test test wrap test wrap wrap return wrap wrap return wrap wrap return main num random return double class hierarchy program program assessment call graph construction algorithms grove chambers analysis enable significant performance improvements cfa call graph construction costs significantly higher context sensitive algorithms 
bounded linear edge algorithm enabled portion speedup cfa fraction analysis time costs 
combines previous graphs plotting execution speedup base ip configuration function call graph construction time 
generate graph cfa algorithm arbitrarily chosen unit comparison 
benchmark program algorithm pair point plotted show cost benefit algorithm relative cost benefit cfa program 
points values shown 
example compiler bounded linear edge call graph construction took seconds enabled speedup base cfa call graph construction took seconds hours enabled speedup base 
point plotted bounded linear edge 
cecil plot quite telling 
programs completed context sensitive analysis scs usually increased call graph construction costs little benefit 
largest cecil programs points corresponding bounded execution speed summary richards deltablue instr sched typechecker new tc compiler cecil speedup cassowary toba java cup espresso javac pizza java speedup profile guided class prediction base base ip selector base ip bounded linear edge base ip cfa base ip scs base ip profile assessment call graph construction algorithms grove chambers linear edge clustered part way axis close axis programs near linear time algorithm achieved significant portion cfa benefits small fraction cfa cost 
java programs results dramatic trends observed 
algorithms bounded linear edge fastest scs slowest 
scs speedups fairly equivalent enabled cfa 
performance results bounded linear edge mixed java programs value sufficient enable virtually cfa speedups 
purposes interprocedural analysis vortex bounded linear edge algorithm clearly represents excellent trade analysis time call graph precision 
algorithm fast scalable produces call graphs sufficiently precise enable significant speedups highly optimized baseline configuration 
call graph construction costs summary cecil java cfa scs bounded linear edge program size number call sites sec min min hr hrs hrs call graph construction time program size number call sites sec min min hr hrs hrs call graph construction time program size number call sites mb mb mb call graph construction space program size number call sites mb mb mb call graph construction space small constant assessment call graph construction algorithms grove chambers related closely related analysis framework parameterized control flow analyses higher order functional languages pals 
framework frameworks parameterized allow express variety context sensitive analyses 
focus higher order functional core languages frameworks parameterized procedure contour selection function directly address context sensitive analysis data structures 
unable express algorithms expressed 
additionally frameworks utilize inclusion constraints mechanism choosing initial value assigned class set prevents expressing unification algorithms algorithms utilize equality bounded inclusion constraints pessimistic algorithms 
hand analysis framework nielson nielson includes rules analyzing explicit bound polymorphism instantiated express polymorphic splitting analysis currently directly expressible analysis framework 
analysis framework nielson nielson includes additional parameterization environments play similar role class contour selection function closure creation sites analysis 
analysis frameworks framework implemented optimizing compiler utilized basis extensive empirical evaluation number call graph construction algorithms 
polymorphic splitting control flow analysis relies syntactic clues provided expressions guide context sensitivity decisions expressions included core object oriented language defined section analysis section define analyze 
analysis framework extended support polymorphic splitting incorporating rules wright jagannathan 
agesen templates informal explanatory device description constraint graph instantiations interprocedural class analysis algorithms ages 
templates similar contours serve group summarize local constraints introduced procedure 
agesen formally define templates considers context sensitive analysis procedures instance variables class instantiations 
cost benefit trade offs call graph construction algorithms cecil java cfa call graph construction time ip cfa speedup base cfa call graph construction time ip cfa speedup base ble cfa scs assessment call graph construction algorithms grove chambers analysis framework completely encompass algorithms monotonically converge final solution 
class algorithms referred iterative algorithms viewed iterating phases monotonic non monotonic behavior 
previous informally defined algorithmic framework encompassed iterative non iterative call graph construction algorithms 
non iterative algorithms currently supported vortex implementation framework 
terminology previous analysis framework precise definition monotonic refinement component general call graph construction algorithm 
iterative algorithms add non monotonic improvement component allows discard pieces intermediate solution call graph re portions analysis compute precise final call graph 
iterative algorithms derived shivers proposal analysis 
currently iterative algorithm implemented plevyak iterative algorithm 
previous proposed possible approach designing aggressive iterative algorithm exact unions 
number papers proposing new call graph construction algorithms empirically assessed effectiveness algorithm implementing optimizing compiler resulting call graphs perform interprocedural analyses 
cases comparisons call graph construction algorithms simply compare baseline system performs interprocedural analysis 
empirical assessment interprocedural analysis somewhat different hlzle agesen comparison effectiveness interprocedural class analysis cartesian product algorithm profile guided class prediction optimization self programs 
little performance difference optimizing configurations profile guided class prediction interprocedural class analysis techniques 
results cecil language approximately equivalent self terms challenges presents optimizing compiler somewhat different 
small programs interprocedural class analysis dominated profile guided class prediction 
larger programs isolation profile guided class prediction enabled larger speedups interprocedural class analysis combination enabled larger speedups technique 
unifying framework understanding call graph construction algorithms empirical comparison representative set algorithms 
parameterized call graph construction algorithm provides uniform vocabulary describing call graph construction algorithms illuminates fundamental similarities differences enables exploration design space call graph construction algorithms 
general algorithm quite expressive encompassing spectrum algorithms ranges imprecise near linear time algorithms number context sensitive algorithms 
implementation general algorithm vortex compiler infrastructure empirically evaluated number call graph construction algorithms suite sizeable object oriented programs 
comparison previous experimental studies experiments cover wider range call graph construction algorithms include applications order magnitude larger largest prior 
applications interprocedural analysis enabled substantial speed ups highly optimized baseline 
furthermore significant fraction speed ups obtained scalable near linear time call graph construction algorithm 
assessed call graph construction algorithms context supporting effective interprocedural analysis optimizing compiler object oriented languages 
analysis framework directly applicable functional languages unclear degree empirical results relative costs benefits particular call graph construction algorithms applicable functional language 
important aspect study relevant call graph construction algorithms generally empirical assessment interprocedural analysis critical evaluate algorithms large programs doing may lead quite different assessment call graph construction algorithms grove chambers small programs considered 
call graphs utilized variety common programming environment tools 
experimental data call graph construction costs guide selection appropriate call graph construction algorithm inclusion tools 
acknowledgments research supported part nsf number ccr nsf young investigator award number ccr gifts sun microsystems ibm xerox parc object technology international edison design group pure software 
careful reading helpful comments susan eggers david notkin jeffrey dean greatly improved quality 
greg defouw designed implemented initial prototype unification call graph construction algorithms section 
ages ole agesen jens palsberg michael schwartzbach 
type inference self analysis objects dynamic multiple inheritance 
nierstrasz editor proceedings ecoop lncs pages kaiserslautern germany july 
springer verlag 
ages ole agesen 
constraint type inference parametric polymorphism 
international static analysis symposium september 
ages ole agesen 
cartesian product algorithm simple precise type inference parametric polymorphism 
proceedings ecoop aarhus denmark august 
springer verlag 
ages ole agesen 
concrete type inference delivering object oriented applications 
phd thesis stanford january 
tr 
aho alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley reading ma 
aiken 
set constraints results applications directions 
second workshop principles practice constraint programming pages orcas island washington may 
alt martin alt florian martin 
generation efficient interprocedural analyzers pag 
proceedings second international symposium static analysis pages 
springer verlag september 
michael ashley 
practical flexible flow analysis higher order languages 
conference record rd acm sigplan sigact symposium principles programming languages pages january 
michael ashley 
effectiveness flow analysis inlining 
proceedings acm sigplan international conference functional programming pages amsterdam netherlands june 
david bacon peter sweeney 
fast static analysis virtual function calls 
oopsla conference proceedings san jose ca october 
sandeep kumar agrawal 
precise call graph construction oo programs presence virtual functions 
international conference parallel processing pages august 
call david callahan alan carle mary hall ken kennedy 
constructing procedure call multigraph 
ieee transactions software engineering 
cham craig chambers david ungar 
customization optimizing compiler technology self dynamically typed object oriented programming language 
proceedings sigplan conference programming language design implementation pages june 
cham craig chambers david ungar 
iterative type analysis extended message splitting optimizing object oriented programs 
proceedings acm sigplan conference programming language design implementation pages june 
cham craig chambers 
cecil language specification rationale 
technical report uw cse department computer science engineering 
university washington march 
revised march 
patrick cousot radhia cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
conference record fourth acm symposium principles programming languages pages january 
assessment call graph construction algorithms grove chambers dean jeffrey dean david grove craig chambers 
optimization object oriented programs static class hierarchy analysis 
proceedings ecoop aarhus denmark august 
springer verlag 
dean jeffrey dean 
program optimization object oriented languages 
phd thesis university washington november 
tr 
greg defouw david grove craig chambers 
fast interprocedural class analysis 
conference record th acm sigplan sigact symposium principles programming languages pages january 
peter deutsch allan schiffman 
efficient implementation smalltalk system 
conference record eleventh annual acm symposium principles programming languages pages january 
amer diwan eliot moss kathryn mckinley 
simple effective analysis statically typed object oriented programs 
oopsla conference proceedings san jose ca october 
emami rakesh ghiya laurie hendren 
context sensitive interprocedural points analysis presence function pointers 
proceedings acm sigplan conference programming language design implementation pages june 
fern mary fernandez 
simple effective link time optimization modula programs 
proceedings acm sigplan conference programming language design implementation pages june 
james gosling bill joy guy steele 
java language specification 
addison wesley reading ma 
david grove 
impact interprocedural class analysis optimization 
proceedings cascon pages toronto canada october 
david grove jeffrey dean charles garrett craig chambers 
profile guided receiver class prediction 
oopsla conference proceedings pages austin tx october 
david grove greg defouw jeffrey dean craig chambers 
call graph construction object oriented languages 
oopsla conference proceedings atlanta ga october 
david grove 
effective interprocedural optimization object oriented languages 
phd thesis university washington october 
hall mary hall ken kennedy 
efficient call graph analysis 
acm letters programming languages systems september 
hein nevin heintze david mcallester 
linear time control flow analysis 
proceedings acm sigplan conference programming language design implementation pages june 
heng fritz henglein 
efficient type inference higher order binding time analysis 
functional programming computer architecture 
urs hlzle david ungar 
optimizing dynamically dispatched calls run time type feedback 
proceedings acm sigplan conference programming language design implementation pages june 
urs hlzle ole agesen 
dynamic vs static optimization techniques object oriented languages 
theory practice object systems 
suresh jagannathan stephen weeks 
unified treatment flow analysis higher order languages 
conference record nd acm sigplan sigact symposium principles programming languages pages january 
john ralph johnson justin graver lawrence 
ts optimizing compiler smalltalk 
proceedings oopsla pages november 
published acm sigplan notices volume number 
kam john kam jeffrey ullman 
global data flow analysis iterative algorithms 
journal acm january 
gary kildall 
unified approach global program optimization 
conference record acm symposium principles programming languages pages october 
david kranz 
orbit optimizing compiler scheme 
phd thesis yale university february 
department computer science research report 
arun lakhotia 
constructing call multigraphs dependence graphs 
conference record twentieth acm sigplan sigact symposium principles programming languages pages january 
land william landi barbara ryder 
pointer induced aliasing problem classification 
conference record eighteenth annual acm symposium principles programming languages pages january 
flemming nielson hanne riis nielson 
infinitary control flow analysis collecting semantics closure analysis 
conference record th acm sigplan sigact symposium principles programming languages assessment call graph construction algorithms grove chambers pages january 
nicholas jens palsberg michael schwartzbach 
making type inference practical 
lehrmann madsen editor proceedings ecoop lncs pages utrecht netherlands june 
springer verlag 
pals jens palsberg michael schwartzbach 
object oriented type inference 
proceedings oopsla pages november 
published acm sigplan notices volume number 
pals jens palsberg christina 
polyvariant flow information intersection union types 
conference record th acm sigplan sigact symposium principles programming languages pages january 
pand pande barbara ryder 
static type determination 
proceedings sixth usenix technical conference 
phil phillips shepard 
static typing explicit types 
unpublished report dept electrical computer engineering royal military college canada kingston ontario canada 
john plevyak andrew chien 
precise concrete type inference object oriented languages 
proceedings oopsla pages portland october 
john plevyak 
optimization object oriented concurrent programs 
phd thesis university illinois urbanachampaign 
barbara ryder 
constructing call graph program 
ieee transactions software engineering 
marc shapiro susan horwitz 
fast accurate flow insensitive points analysis 
conference record th acm sigplan sigact symposium principles programming languages pages january 
shar micha sharir amir pnueli 
approaches interprocedural data flow analysis 
steven muchnick neil jones editors program flow analysis theory applications chapter pages 
prentice hall 
olin shivers 
control flow analysis scheme 
proceedings sigplan conference programming language design implementation pages june 
olin shivers 
control flow analysis higher order languages 
phd thesis carnegie mellon university may 
cmu cs 
bjarne steensgaard 
polyvariant closure analysis dynamic abstraction 
unpublished manuscript 
bjarne steensgaard 
points analysis linear time 
conference record rd acm sigplan sigact symposium principles programming languages pages january 
dan stefanescu zhou 
equational framework flow analysis higher order functional programs 
proceedings acm symposium lisp functional programming pages june 
robert tarjan 
efficiency linear set union algorithm 
journal acm 
vitek horspool uhl 
compile time analysis object oriented programs 
proceedings cc 
th international conference compiler construction pages 
springer verlag october 
robert wilson monica lam 
efficient context sensitive pointer analysis programs 
proceedings acm sigplan conference programming language design implementation pages june 
andrew wright suresh jagannathan 
polymorphic splitting effective polyvariant flow analysis 
acm transactions programming languages systems january 
