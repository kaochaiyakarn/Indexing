model polymorphism recursive types abadi plotkin synopsis model reynolds polymorphic lambda calculus provided allows recursive definition elements types 
technique class partial equivalence relations certain cpo 
allows combination inverse limits recursion intersection polymorphism 
ideal model provides interpretation rich type system polymorphism recursion model typed calculus 
search satisfactory semantics calculi recursive polymorphic types natural consider partial equivalence relations pers ideals 
ideals certain subsets universal domain replace certain pers 
example order interpret recursion pers satisfy completeness axiom considered 
study begun amadio 
left open find complete partial orders pers recursive types obtained applying usual construction 
case models digital equipment systems research center lytton avenue palo alto california dept computer science university edinburgh king buildings edinburgh eh jz 
part completed digital equipment systems research center 
lines girard see recursive definitions elements types available 
define class pers yielding complete partial orders 
partial orders obtained intrinsic intrinsic topologies corresponding idea pers considered authors 
general setting rosolini topos dominance 
scott advocated developing theory internal logic attempt pers feature true cpos 
provide model extension reynolds polymorphic calculus 
say add type expression tp recursive types term expressions recursive elements jx tp gamma tp isomorphism jx tp tp tp inverse see 
semantics seely model extra structure recursion 
omit evident interpretation new syntactical forms 
usual equations adds expressing isomorphism 
represent amadio metric space methods model kind turns essentially identical 
easily extend metric model deal subtypes case order theoretic model 
axioms pers somewhat restrictive force intrinsic partial orders page consistently complete disadvantage excluding convex powerdomain type constructor 
consider partial preorders pers equipped partial order field 
impose weaker axioms just completeness uniformity see obtain model extended allowing convex powerdomain type constructor 
extend order theoretic approach possible model theory constructions 
began attempt build cardelli longo model language quest records subtypes 
records produce new problems traditional view subtypes goes long way combination recursive types polymorphism bounded quantifiers defeated 
difficulty caused possibility type recursion going bound 
section describe cpo serves setting 
study partial equivalence relations section 
section define type constructions category pers 
sections give interpretation types terms section describes alternative metric approach 
move pers partial preorders section 
assume standard domain theoretic categorical concepts notation 
background assumptions partial equivalence relations cpo 
increasing sequence continuous projections upper bound identity finite range 


strict continuous retraction pairs gamma 
gamma 
gamma 
gamma 
theta theta gamma 
theta gamma 
theta 
gamma 

gamma 
point cpo natural numbers 

hold theta hx yi theta 

ffi ffi 
meet closure holds meaning non empty meets preserved preserve meets 
omit write allow untyped calculus notation elements note implies ffi min 
assumption equivalent saying bifinite particular finite 
scott domain 
obtain solve appropriate domain equation theta usual limit sequence iterates process see obtain modifying maps th iterate ensure finite 
partial equivalence relations notation 
jsj set fx jsj equivalence class set equivalence classes 
pers write mean implies fx fy associate subset ae fhx xi xg may write partial equivalence relations form category morphisms set theoretic functions jsj write uniquely determines write read realises page effective say effective exists element comp px fst snd comp hf ffi composable second element realising identity id pointed amadio needs completeness axiom pers model recursion completeness ae directed subset natural domain theory consider axioms relating infinite elements finite ones 
try assumption sb finite ta tb unfortunately class pers complete ones closed intersection 
property introduced amadio yield closure uniformity termed property algebraicity closure approximation prefer term finite elements uniform way pers 
note uniformity written intrinsic preorder defined putting jsj iff oe defines complete preorder jsj including functions considered continuous monotone respect 
assuming complete uniform reverse 
oe preorder jsj containing jsj lemma 
finite jsj oe iff 
finite iff oe proof 
set oe 
monotone respects evident 
continuity suppose fy directed ty oe ty 
uniform oe finite range 
oe 
follows part immediately 
follows part lemma complete preorder containing rest section complete uniform pers considered 
partial order antisymmetry 
jsj iff obtaining defined partial order 
theorem suppose antisymmetric 
partially ordered cpo 
element 
directed set jsj tx lub finite elements finite jsj 
proof 
jsj contains jsj 
completeness directed family fa ag finite non empty element element sequence lub lub contains jsj complete 
see finite suppose lub oe notation proof lemma oe completes proof noting lub write lubs intrinsic topology 
definition ae open intrinsic topology iff page clearly continuous respect intrinsic topology 
theorem suppose antisymmetric 
intrinsic topology scott topology 
proof set xg 
lemma open intrinsic topology 
theorem scott open union open intrinsic topology 
converse shows open intrinsic topology fv follows continuous preserves directed lubs 
order relate intrinsic order constructed pers intrinsic order properties particular meet closure property 
properties necessary constructions help understanding play role inequational logic meet closure pers non empty families sy 
meet closure condition resembles suggested scott kept constant 
shown meet closure property follows restriction finite families 
desirable avoid meet closure property bifinite cpos add powerdomains 
way achieving move partial equivalence relations partial preorders section 
meet closed equivalence class element 
lemma 
jsj 

jsj jsj finiteg 
jsj iff 
proof 
sx sy obtain 

part lub 
completeness get sx lub 

suppose finite jsj oe part 
part 
converse trivial 
part shows intrinsic order coincides preorders considered amadio completeness uniformity meet closure imply antisymmetry 
set jsj finiteg lub exists consistent completeness theorem 
continuous projection extending 
jsj iff iff 
consistent 
non empty family jsj proof omitted 
property shall consider says equivalence classes convex convexity 
iff complete uniform meet closed convex 
page constructions category pers need variety constructions build types 
start need products function spaces get simple types need intersections get polymorphism need certain inverse limits interpret recursive equations types 
inverse limits taken category pers available considered function spaces 
basic types pers intrinsic order cartesian closure known cartesian closed 
terminal object take fh ig unique 
products take theta yi hx ii projections fst thetat snd thetat pairing hf thetat function spaces take fhf gi jsj fx gx evaluation fst snd thetas currying thetas hx yi note bijection oe oe see constructions preserve axioms 

theta complete uniform 
proposition 
theta 

theta convex 
proof just consider function spaces 
part uses fact family uf fu finiteg part suppose convex take jsj 
fx gx hx 
showing gt jt induced order evident 
proposition 
hx yi thetat hx iff 
jsj fx gx 
converse holds complete uniform meet closed 
proof 
implication left right holds projections monotone 
implication right left holds hz yi thetat hx zi thetat monotone hx yi thetat hx yi thetat hx thetat similarly 
idea invention paul taylor 

implication left right holds function monotone 
direction jsj ffi gx ft ffi ft ffi intersection amadio showed uniform complete pers closed intersection 
preservation meet closure convexity easy 
proposition family complete uniform pers set converse holds meet closed convex 
proof implication left right holds monotonicity conversely assume set get 
page category pers take full subcategory consisting pers 
morphisms partially ordered iff jsj bijection isomorphism partial orders proposition 
obtain category sense element 
lubs chains directed sets exist defined pointwise composition continuous left strict 
get uniformity preserved limits solve domain equations consider uniform morphisms ffi ffi note uniform morphisms strict 
get meet closure preserved consider multiplicative morphisms preserving meets non empty families 
equivalent preserving binary meets uniform morphisms 
combination uniformity preserved products function spaces 
take subcategory uniform multiplicative morphisms sub category objects morphisms pairs gamma 
gamma 
inherits category structure hf gi hf iff set hf gi hg fi 
colimits construct colimits certain chains embedding projection pairs 
hs hf mn mn ii cochain pairs 
suppose ff mn ff mn ff ff 
define xs iff means 
ff realises morphisms sm sm hi cone embedding projection pairs ffi increasing lub identity hi colimiting regards intrinsic order iff ff sm ff iff sm interpreting types usual models interprets types functions set pers universal quantification intersection 
wish partial order structure morphisms solve recursive domain equations needs category pairs 
intersection yield functor needs functors effective 
generalise category pairs morphisms 
advantage effective functors automatically locally continuous sense 
say hf gi hy zi functor 
effective iff oe oe evident vector notation 
say oe realises note effectiveness condition behaviour functor arrows 
local continuity arises continuity 
say functor symmetric iff 

hm 
say oe realises symmetrically oe 
xm oe 
fst 
oe realises symmetric realises symmetrically 
xm equals hfst oe 
xm fst oe 
symmetric covariant functors arise naturally functors covariant arguments contravariant 
locally monotonic symmetric functors automatically preserve embedding projection pairs take advantage finding recursively defined types 
building model sense seely take global category page omega objects omega morphisms omega omega effective symmetric functors interpret type expressions 
category finite products omega fold product omega gamma write omega omega projection functors 
products functional types effective symmetric functors theta defined pers product function spaces hf gi theta hf hf theta theta hf gi hf hg morphisms right corresponding functors 
universal quantification suppose omega omega gamma symmetric realised oe 
define mf omega omega objects 
morphisms assume omega gamma set ip hx xi 
element realises identity omega gamma get element oe ip realises id oe ip realises morphism mf mf take mf unfortunately bounded universal quantification 
objects define ae omega omega ae aet evident definition morphisms 
recursive types suppose omega omega realised symmetrically oe wish define mf omega omega gamma define iterates omega omega constantly functor realised oe 
ffi 
realised oe oe oe 
note oe oe natural transformations nn defined setting id nn 
set 
oe ip 
realises yields cochain embedding projection pairs hf ff fst 
construct colimiting cone ae 
mf defining object part mf realising ae morphism part suppose takes mf ae ffi ffi ae realised ffl oe ffl ffl realiser composition note continuous function locally continuous ae mf colimiting 
follows basic lemma initial gamma algebra mf ff ff mf 
mf mediating morphism ae ae gamma just ae ffi ae inverse ff ffl oe ip realises independently interpreting terms interpret terms need indexed category op cat objects omega omega omega gamma symmetric effective functors 
morphisms take families realises say realises 
example second components ff defined provide morphisms needed interpret terms jx tp gamma tp omega omega get functor omega omega acts composition objects omega ffi ffi omega fibre cartesian closed structure preserved nose 
terminal object omega constantly functor omega omega gamma unique realised 
binary products omega product composition theta theta ffi hf gi 
projections realised fst snd 
realised tuple theta realised xi 
exponentiation 
gi 
evaluation morphism eval theta realised page fst snd 
theta realised curry 
realised xy hx yi 
universal quantification need describe functor omega indexed categories right adjoint diagonal omega omega indexed category gamma theta omega gamma define functor omega omega 
objects omega omega take 
morphisms realised say realises take mf mf interpret term expressions recursive elements omega theta need fix omega ffi hid gi 
realised hx yi realises usual fixed point operator 
metric space approach amadio introduced uniformity order solve type equations banach fixed point theorem 
method fact allows give seely style model extended recursive types elements turns closed types interpreted go interpret bounded quantification 
clear extend 
defines complete metric set pers gammac natural number 
cauchy sequence limit section xs seely style model take global category objects morphisms tuples hf 
contractive projection 
take omega theta act mf omega omega defined mf obtain contractive function omega omega contractive projects element projection 
similarly recursive types mf omega omega gamma define omega omega 
cases cauchy sequence take mf limit find actual equality mf mf 
indexed category op cat proceed objects omega omega omega gamma morphisms families realised single element case recursive types example interpret jx tp gamma tp identity 
fibres cartesian closed omega defined fix 
fact essentially re presentation previous model interpretation types object part previous interpretation terms exactly 
gained knowledge morphisms interpret jx tp gamma tp identities recursive types initial algebras 
show combines models single restrictions level morphisms 
proofs omitted 
gammac 
yields complete ultra metric compact lawson topology see 
show nonexpansive iff ffi ffi ffi example 
takes sup ultra metric functions sup jsj 
take em subcategory objects morphisms functors omega omega pi ffi projection contractive acts objects morphisms see take hf gi hf max 
em inherits finite product structure effective symmetric functors theta omega omega page contractive 
universal quantification defined preserves 
metric structure morphisms put considering recursive types mf omega omega gamma defined 
find mf limit cauchy sequence obtain actual equality mf mf get mf acts objects 
consider action gamma omega gamma mf mf 
sees equality id mf fixedpoint 
show considering ff fixed point ff identity 
show mf acts morphisms 
indexed structure em inherited evident functors em provide needed relation models 
partial preorder model pers yield intrinsic partial orders useful properties exploited construction model relevant giving logic necessary start pers results obtained directly preorders 
fact preorders preferable respects require assumptions 
preorder models compatible convex powerdomain constructions bifinite cpos 
difficulty original scott domain setting adding hoare smyth powerdomains 
outline main features model preorders 
drop assumption longer require scott domain bifinite cpo 
binary relation partial preorder preorder jsj fa 
partial preorder satisfies axioms completeness uniformity extends underlying partial order jsj jsj 
require antisymmetry convexity meet closure properties 
naturally partial equivalence relation associated iff bsa 
furthermore complete uniform 
intrinsic order obtained necessarily identical possibly stronger 
identical meet closed 
direction complete extensive partial preorder uniform 
write equivalence class jsj write set partially ordered iff 
define pers 
category ppos objects morphisms monotonic jsj write realises 
effective sense way 
analogue theorem holds algebraic cpo 
bifinite 
increasing sequence projections finite range lub identity 
intrinsic topology defined scott topology ppos morphisms ppos scott continuous 
ppos 
cartesian closed products function spaces defined analogue proposition trivial 
constructions preserve completeness uniformity 
intersection family ppos extensive respectively complete uniform family ordering morphisms pointwise get isomorphism oe 
full subcategory pq ppos category take pr subcategory uniform morphisms defined 
colimits pr definition seely model allowing interpretation page recursive elements types 
material metric spaces extend investigated 
turning powerdomains add assumption existence strict retraction pair ep gamma 
rp gamma 
assumption notation convex set containing 
identify 
restricting brevity ppos define power fhx xry xry obtaining 
useful lemmas showing lawson continuous ppos closed limits lawson topology 
associated functions 
union function considered retractions realises binary morphism turning semilattice free semilattice may 
associated functions organised strong monad moggi 
unit realised singleton function multiplication realised big union strength realised theta theta fxg theta arises question appropriate extension course add operator obtain types polymorphic constants associated functions 
ask language operational semantics model adequate considered programming language difficulties 
benefited comments cardelli 
curien 
amadio 
recursion realizability structures 
appear information computation 
america rutten 
solving reflexive domain equations category complete metric spaces 
proc 
third workshop mathematical foundations programming language semantics springer verlag lecture notes computer science pp 

appear jcss 
asperti martini 
categorical models polymorphism 
appear 
cardelli longo 
semantic basis quest 
research report systems research center digital equipment 
appear proceedings acm conference lisp functional programming 

relational semantics recursive types bounded quantification 
icalp springer verlag lecture notes computer science pp 

coquand gunter winskel 
di domains model polymorphism 
proc 
third workshop mathematical foundations programming language semantics springer verlag lecture notes computer science pp 

coquand gunter winskel 
domain theoretic models polymorphism 
information computation 

girard 
interpr etation fonctionelle elimination des coupures dans arithm etique order sup erieur 
th ese de doctorat etat paris 
gunter scott 
semantic domains 
appear handbook theoretical computer science eds 
meyer page nivat paterson perrin 
north holland 
hennessy plotkin 
full abstraction simple parallel programming language 
mathematical foundations computer science springer verlag lecture notes computer science pp 

johnstone 
stone spaces 
cambridge university press 
macqueen plotkin sethi 
ideal model recursive polymorphic types 
information control 
moggi 
computational lambdacalculus monads 
proc 
fourth lics pp 

plotkin 
powerdomain construction 
siam comput 

rosolini 
continuity effectiveness topoi 
phil 
thesis university oxford 
scott 
data types lattices 
siam comput 

seely 
categorical semantics higher order polymorphic lambda calculus 
journal symbolic logic 
smyth plotkin 
category theoretic solution recursive domain equations 
siam comput 

troelstra 
metamathematical investigations intuitionistic arithmetic analysis 
springer verlag lecture notes mathematics 
page 
