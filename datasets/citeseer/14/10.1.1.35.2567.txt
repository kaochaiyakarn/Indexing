published proceedings acm sigplan conference programming language design implementation vancouver pages translation validation optimizing compiler george necula university california berkeley necula cs berkeley edu describe translation validation infrastructure gnu compiler 
compilation infrastructure compares intermediate form program compiler pass veri es preservation semantics 
discuss general framework optimizer communicate validator transformations performed 
implementation rely help optimizer quite successful heuristics detect transformations take place 
main message practical translation validation infrastructure able check correctness transformations performed realistic compiler implemented ort typically required implement compiler pass 
demonstrate context gnu compiler number optimizations compiling realistic programs compiler linux kernel 
believe price infrastructure small considering qualitative increase ability isolate compilation errors compiler testing maintenance 
despite large body cm mp mor moo wo area compiler veri cation far able prove automatically optimizing compiler produces target programs semantically equivalent source versions 
prove compiler correct check correctness compilation 
observation inspired technique translation validation pss goal check result compilation source program detect pinpoint compilation errors techniques implement translation validation discuss initial experience research supported part national science foundation 
ccr nsf infrastructure 
eia gifts intel 
information necessarily re ect position policy government ocial endorsement inferred 
translation validation infrastructure gnu optimizing compiler 
argue errors commercial compilers source headaches programmers 
may true compiler manuals contain warnings optimizing compilers change code wouldn expect 
developers able trace bad code generated optimizations looking actual assembly code generated function 
mic warning suggests scenario user unfortunately accurate description state art compiler testing maintenance 
compiler testing bound important tedious demanding architectures targets 
preliminary experience suggests ort similar required implementing compiler pass compiler development team build ective translation validation infrastructure tvi 
infrastructure watches compilation takes place points precisely mismatches semantics program compiled semantics program individual compiler pass 
implemented prototype translation validator gnu compiler 
prototype able handle quite reliably intraprocedural optimizations gcc performs branch optimization common subexpression elimination register allocation code scheduling compiling realistic programs compiler linux kernel 
empirical validation infrastructure able isolate known bug gcc version 
experiments translation validator slows compilation factor 
cases tvi reports errors actual semantic mismatches due inability tvi understand precisely transformation took place transformation correct 
refer errors false alarms 
optimizations ratio false alarms low false alarm compiled functions 
certainly room improvement results need experimental validation believe translation validation promising technique achieving qualitative increase ability isolate compilation errors compiler testing maintenance consequently instructions call return label jump jump jump expressions op sel operators op 
memory upd syntax il intermediate language increase reliability compilers 
translation validation obviate need extensive compiler testing suites tool greatly increasing ectiveness compiler testing maintenance 
traditional compiler test procedure test source program compiled compiler report internal error resulting program run input values output known 
cases task tester inspect manually output program spot subtle compilation errors 
example exception handling code hard compile correctly hard test exhaustively 
tvi automates task comparing output program input program unoptimized version target program reporting exact nature position semantic mismatch requiring test cases compiled program 
checking program equivalence undecidable problem hope complete equivalence checking procedure 
equivalence checking possible compiler produces additional information guide translation validation infrastructure 
contribution framework information expressed simulation relation 
show example checking algorithm simulation relation discuss guidelines compiler writers generate simulation relations 
typically compiler pass transforms program limited way 
looking program transformation hope detect transformation took place possibly heuristics knowledge kind transformations compiler performs 
second contribution step inference algorithm uses simple heuristics match control ow graphs input output programs uses symbolic evaluation constraint solving complete checking 
way view algorithm inferencer simulation relations 
advantages translation validation realized weaker infrastructure attempt verify full semantic equivalence veri es output certain expected properties 
example touchstone certifying compiler nl proves type safety output compiling type safe subset programming language 
similarly special cln java popcorn mcg type safe subset spite obvious limitations form result checking helped early discovery numerous touchstone bugs code reused mature compilers 
time asked bene result checking techniques touchstone compilers unsafe languages checking preservation type safety ideally minor modi cations compiler 
believe hope achieve goals current describes initial experience path 
section discuss equivalence criterion simulation relations tvi uses 
introduce example program argue informally semantics preserved series transformations 
starting section formalize process showing rst symbolic evaluation pass collects equivalence constraints followed section description constraint solver 
section report preliminary experience implementation prototype context gcc compiler 
simulation relations equivalence criterion exposition purposes consider programs written intermediate language il syntax shown 
function body sequence il instructions 
instructions assignments temporary registers memory reads memory writes function calls returns labels unconditional jumps conditional branches 
rst argument function call denotes function called denotes sequence expressions 
going notation denote sequence elements 
expression language relatively simple containing temporaries global names integer literals composite expressions variety operators 
language close il intermediate language gnu compiler uses 
direction il di ers typical intermediate languages state memory represented explicitly 
particular upd denotes state memory write previous memory state address value denotes state memory call memory state function arguments expression sel denotes contents memory address memory state occasionally variables range memory states 
simulation relation relation il programs source target set elements form pcs pct pcs pct program points respectively sequence boolean expressions referring temporaries live respective program points 
current version system boolean expressions equalities contain temporaries left hand side temporaries right hand side 
informally simulation relation describes conditions program fragments equivalent 
quite possible equivalence criteria il programs 
criterion ne grained requires sequence memory operations prevent possible compiler optimizations 
coarse source memory safe target checked touchstone certifying compiler allow detection subtle errors optimizer 
order de ne equivalence program fragments rst de ne equivalence pair executions 
say executions equivalent lead sequence function calls returns 
returns returned value state memory 
function calls state memory prior call arguments address called function cases 
notion equivalence memory states deserves discussion want constrain include state memory locations spill slots 
constraint allow tvi check operation register allocator 
address issue assigning names fresh temporaries spill slots followed rewriting program change spilling instructions operations new temporaries 
ectively undoes spilling operation 
important added bene operation lack aliasing spill slots memory locations explicit 
renaming operation quite simple compilers simple indirect addressing frame pointer access spill slots 
context unsafe language possible guarantee location intended spill slot changed normal memory operation 
ignore possibility just compiler grounds behavior program unde ned 
doing adopt notion unde ned compiler 
equivalence criterion equivalence observable behaviors set observable events function calls returns 
equivalence criterion intended cover intraprocedural program transformations performed gnu compiler 
simulation relation correct element pcs pct pairs executions started pcs started pct states satisfy boolean conditions equivalent 
simulation relation witness program fragments equivalent 
note criterion program fragments required termination behavior 
imagine optimizing compiler producing simulation relation way explain observer program changed transformation 
needed way check easily simulation relations 
go step ahead show moderately aggressive optimizing compiler gcc possible infer simulation relation possible extend set observable events include memory writes heap 
order handle correctly rtl intermediate language gcc extend set observable events include memory reads writes volatile locations 
avoid modifying compiler 
doing accept advanced optimizations inference machine resulting false compilation errors reported 
discuss informally section example simulation relation checked go formalize process describe inference engine 
example consider program shown intermediate form typical transformations 
program writes values index array bytes running 
global variables variables locals represented temporaries intermediate language 
program split basic blocks labeled shows program optimizations 
register allocated hold temporary register hold temporary spilled memory location bp bp denotes frame pointer register 
loop inverted termination test duplicated 
induction variable assume aliasing induction variable 
compiler loop block computation stores result spill slot bp 
assume simulation relation shown check correctness 
omit example additional boolean expression element simulation relation stating memory states equivalent source target respective program points 
note rst element simulation relation says programs equivalent started states bp 
checking equivalence accomplished checking turn elements simulation relation 
row examine de nitions blocks involved proceed forward parallel source target programs 
hit return instruction sides case check state memory returned value sides pair related blocks case check constraints new pair 
checks succeed show inductive argument program fragments equivalent modulo constraints start row equivalence relation 
checking process element stops reach program points related element ensure termination checking process requiring elements relation 
postpone formalization notion discuss inference algorithm 
illustrate checking process show checking element easy element dicult 
check element start assuming aliasing assumption fact wrong index checked array bounds 
compilers assumption 
return bp bp bp bp return bp bp bp bp bp original program transformed program simulation relation example il program series transformations including loop inversion strength reduction register allocation spilling instruction scheduling 
right side simulation relation pair programs 
constraints hold 
control ow graphs simulation relation notice need advance block source side stay place target side order hit element simulation relation 
check constraints element met 
rst constraint evidently met assigned block second constraint met modi ed memory assumption directly 
check element assume constraints hold look pairs related paths source target current blocks pair related blocks 
pairs related related 
exactly discover paths explained section pairs check taken conditions establish constraints related blocks reach 
show checks related second pair paths 
primed notation refer values temporaries path 
check path conditions bp equivalently bp assumptions reduces proving bp bp done noting memory write block change spill slot 
recall treat spill slots temporaries memory addresses 
check constraint element equivalently bp 
bit tricky done knowledge compiler strength reduction 
case rule distributivity multiplication followed arithmetic simpli cation reduce goal bp 
remains prove requires arguing addresses aliased 
gcc assumption involves addresses distinct globals tvi 
reduce goal bp follows immediately assumptions bp 
example shows tvi similar knowledge algebraic rules aliasing rules compiler 
sample rules tvi uses check equivalence boolean expressions appearing simulation relation elements shown 
rules proving facts compiler proves implicitly process optimization assumptions commutativity additions usual rules saying equality equivalence relation congruence rules 
rules section reason contents memory reads rst refers contents memory location just written second alias information prove memory update ect contents memory location 
note rules reasoning contents memory location function call 
incompleteness system motivated current focus intraprocedural optimizations 
bottom part show rules reasoning equivalence memory states 
generality extend equivalence judgment form 
say states denoted equivalent possibly addresses contained set 
rst rules section typical substitutivity rules 
compiler reorder memory writes eliminate redundant memory writes rules necessary 
rules 
annotation necessary reason transformations change sequence memory writes 
boolean expression satis ability represents sum literals sel upd sel sel upd memory equivalence 


upd 
sel 
fe upd 

upd 
upd 

representative rules de ne equivalence checking 
third rule handles case don care memory location written fourth says writing address contains address equivalent rules designed match semantics intermediate language 
need rules describe properties il compiler uses transforming program 
mean tvi complex compiler 
compiler typically complex decide rules 
implementation tvi checker essentially pattern matcher pattern direct transcription corresponding logical rule 
result implementation scheme due order magnitude di erence size tvi compiler believe easier check inspection operation translation validator check implementation compiler 
attentive reader noticed checking process quite simple fact diculty lies coming simulation relation 
reliable way produced compiler 
moderately aggressive compilers gnu compiler possible infer simulation relation explained section 
symbolic evaluation section start describing translation validation algorithm details 
program il form split basic blocks start label return jump branch instruction 
core feature approach symbolic evaluation compute ect basic block 
illustrate major bene symbolic evaluation consider basic blocks return return blocks di erent takes purely syntactical look 
evaluate symbolically see equivalent return 
point symbolic evaluation abstracts minor syntactic details permutation independent instructions instruction scheduling renaming local temporaries register allocation change order computing independent subexpressions common subexpression elimination observation hardly new appeared predicate transformers dij value dependence graphs 
checking correctness program transformations appears new 
symbolic evaluation state consists program point set symbolic values live registers point 
translation validation scheme consider kinds states corresponding points kinds blocks follows ret rst form represents return instruction memory state returned value second represents jump block memory state values live registers third conditional branch guard successor blocks values live registers respectively 
basic block compute symbolic state block function value memory live registers block start 
purpose create initial symbolic register state mapping special memory register live registers initial values 
invoke symbolic evaluation function se sequence instructions contained initial symbolic register state 
result symbolic evaluation function symbolic evaluation state possibly depending variables allows de ne block evaluation state block transfer function follows def se se se se se sel se se upd se call se call se return ret se jump se jump jump symbolic evaluation algorithm denotes sequence instructions block set live registers start block symbolic evaluation function se de ned 
depending kind instruction hand symbolic evaluation state modi ed accordingly function se invoked recursively instruction 
write denote expression obtained applying substitution write denote state obtained setting note memory write instruction sets memory register call instruction modi es memory register register result call placed 
cases correspond terminal instructions build symbolic states directly 
example transfer function basic block def upd sel basic block def alternative view symbolic evaluation strategy described rewriting body il function purely functional program composed series mutually recursive function de nitions basic block transfer functions 
bene equivalence programs easier verify due lack side ects 
furthermore suggested example section symbolic evaluation produces syntactically identical transfer functions basic blocks di er names registers order non dependent instructions 
symbolic evaluation simulates symbolically runtime ects sequence instructions model accurately ects 
performs substitution symbolic evaluation phase decisions semantics various operators 
decisions postponed checking phase discussed 
checking symbolic state equivalence designed equivalence checking algorithms 
relies simulation relation available call checking algorithm rely information inference algorithm 
checking algorithm theoretically powerful constitutes correctness criterion completeness goal inference algorithm 
stage project want modify gcc wanted explore accurately infer simulation relation just passively observing compilation 
current inference algorithm limitations respect checking algorithm branches target program correspond branches source program constraints simulation relation equality constraints 
limitations inference algorithm suitable transformations gcc performs 
exception loop unrolling versions unrolling gcc uses 
checking algorithm simpler version inference algorithm discuss 
inference algorithm components 
component called scan walks source target programs parallel collects equivalence constraints 
component called branch assists scan determining branch source program eliminated side retained copied target program form reversed form 
handling case branch target program correspond branch source program 
third component inference algorithm called solve invoked simplify set equivalence constraints produced scan left 
case declare success 
failures occur branch module solve module 
cases tvi points exact nature failure human ascertain uncovered compiler bug just incompleteness issue tool 
case update tool just note validation know fail certain test case 
collecting constraints avors constraints collect set expression equivalence constraints relate expressions values equal substitutions free variables values satisfy memory expression equivalence relates memory expressions denote memory states contents coincides 
symbolic state equivalence relates states substitution free variables values satisfy lead sequence function calls returns 
function calls returns general form allows memory states di er set addresses described section 
executed memory state arguments 
main entry point infer scan component shown 
primed notation refer entities target program 
inference algorithm maintains lists pairs blocks 
done contains pairs related blocks processed todo pairs encountered processed 
list initialized start blocks source target respectively 
pair processed create new parameters stand values live registers entry invoke scanner 
scan procedure takes addition source target states sequence il instructions leading states start current pair related blocks processed 
scan rst follows jumps source target rst cases scan sides reach branch return 
process symbolic state sequence leading instructions accumulated accordingly 
scan examines source state return third case scan expects return target side 
scan terminates case adding constraints interesting case source state branch 
possibilities named eq eq meaning branch eliminated true false side retained branch corresponds target branch direction reversed 
decision case applies function branch discussed section control ow graph sequences instructions leading branch points 
case constraint negation operator added say source branch condition true scanning continues true side 
eq case target branch constraint added saying branches go direction 
helper function adds state equivalence constraint adds blocks todo list 
notice scan guaranteed terminate looks pair blocks 
furthermore practice blocks duplicated appear pair 
number constraints produced stage relatively small 
typically constraint conditional constraints return instruction join point state constraints successors 
surprise constraint generation including branch done seconds complete gcc sources 
additional constrains generated constraint solving moving stage describe brie operation branch module 
navigating branches branch module invoked scan module described encounters branch source program 
role branch module discover branch eliminated kept target program 
describe implementation branch heuristics ective experiments 
input branch consists instruction sequences function infer done todo todo todo todo nf done done create new parameters scan done solve function scan def scan 
elseif def scan 
elseif ret ret fm elseif switch branch case def scan 
case def fe scan 
case eq fe case eq fe default fail fail function fb done todo todo main entry point inference function scan component 
leading branch source leading branch return target 
order expose instructions follow jumps branches side branch ends return branch 
possible resulting situations shown source target discuss situation target side contains branch 
case return simpler 
source branch preserved correspond branch target side 
test perform follows note test considered false target side return similarity operations instructions sequences conditionals de ned 
operations performed heuristics results straight booleans scores implemented multiplication implemented maximum operator 
boolean conditionals similar obtained simple transformations assign low similarity scores pairs conditionals comparison operators closely related 
supplement boolean expression similarity heuristic compute instruction sequence similarity elements look sequence function calls instruction sequences 
purpose consider return call function return indirect function call call function indirect 
doing comparison append element sequence calls set function names called code instruction sequence 
information precomputed easy xpoint operation 
sequence calls instruction sequence pre similarity assign lowest score 
look instruction sequences lead points known related occur done todo lists 
assign high score case 
heuristics speci gcc similar heuristics implemented compilers 
look sequence serial numbers il instructions sequence 
il instruction unique serial number 
instructions eliminated duplicated transformation maintain serial number body modi ed slightly register allocation 
instructions newly introduced target detect serial numbers larger appearing source 
compute similarity score ratio number serial numbers appearing instruction sequences divided length shortest 
cases code duplicated heuristics 
case source line number information gcc places special il instructions instruction stream 
gcc careful move information moved instructions assist debugging way detect code duplication 
assign score computed sequence serial numbers 
heuristics able handle reliably transformations performed gcc loop unrolling 
problem current decision allow target conditionals copies source conditionals 
problem xed heuristics branch handle control ow transformations performed gcc 
techniques branch heuristics ones sensitive changes compiler easily transferable compilers 
truly general solution problem compiler annotate branches target program indicating relate source program 
obviate need heuristics greatly improve robustness tvi face modi cations compiler 
solving constraints nal stage inference process solves constraints collected scan 
kinds constraints expression constraints memory constraints state constraints 
strategy start solving simplest constraints rst 
nd simple constraint things remove verify appear lead circularity ects soundness algorithm 
replace occurrences nd pair basic blocks parameter introduced infer 
transfer functions 
add set boolean expressions contained element simulation relation corresponding state constraints form introduced add constraint 
intuitively simple constraints generated rst return instructions 
step propagates simple constraints predecessors block ectively moving start program 
reach start say initial states pair programs equivalent 
assume state simple expression constraints 
case try simplify expression memory constraints similar algebraic rules compiler uses 
example take constraint compute canonical form breaking toplevel additions subtractions multiplications rewriting term integer added weighted sum expressions 
example reduce constraint constraint turn simple constraint addition arithmetic simpli cation simplify memory operations equation sel upd sel side conditions checked arithmetic simpli er 
simpli ed zero second choice 
simpli ed non zero constant expression involving di erence addresses globals rst choice 
expression simpli ed 
simplify expression constraints anymore move memory constraints 
memory expression sequence memory updates function calls 
equivalence criterion handle programs compiler moves memory operations function calls 
split memory expressions segments function calls 
compare segments add constraints stating corresponding function calls memory states functions called arguments equal 
step memory expressions reduced contain just upd operations solve rule solve upd upd sel fm means simpli ed non zero constant di erence addresses globals 
ectively aliasing rules gcc uses 
second case default compiler reorder writes heap 
note rule weak face sophisticated reordering memory operations aliasing information 
currently problem gcc plan improve aspect checker 
note nite number parameters introduced scan simple constraint procedure guaranteed executed nite number times 
ensure termination sucient arrange simpli cation procedures terminate 
instructive consider situations solver fails 
happens simpli er procedures powerful compiler reasoning expression equivalence case simpli er memory states case compiler performs aggressive aliasing analysis 
ort maintaining translation validator spent simpli ers 
implementation details early experimental results implemented translation validation infrastructure handle intermediate language gnu compiler 
gcc compiler portable optimizing compiler additional front ends fortran java 
gcc excellent candidate experimenting translation validation easy availability source code documentation fact uses single intermediate language called rtl intended semantics documented 
gcc starts parsing source code translating directly rtl 
parsing gcc performs type checking optimizations procedure integration tail recursion elimination 
rest compiler conventional composed maximum passes depending optimizations enabled 
typical transformations branch optimization local global common subexpression elimination loop unrolling loop inversion induction variable optimizations local global register allocation instruction scheduling 
optimizations jump optimization common subexpression elimination run multiple times di erent passes 
access rtl programs obtained conveniently instructing gcc command line argument produce easy parse rtl dump pass 
result large dump les slows compilation considerably avoids need change gcc 
implemented translation validation infrastructure standalone program objective caml dialect ml 
implementation consists lines code 
parser utility functions needed validator integrated compiler 
symbolic evaluator lines solve module containing equivalence rules lines 
rest implementation dedicated auxiliary tasks performing liveness analysis conversion ssa form 
comparison implementation typical gcc pass lines code 
wrote shell script invokes gcc additional command line ags request dumps thirteen il les pass parse compare pairwise 
script substitute compiler building software systems compiler linux kernel 
general rule turn optimizations supported architecture aggressive level 
implementation follows closely algorithms described 
construct control ow graph perform symbolic evaluation blocks 
symbolic evaluation keep track de ned registers compute liveness information 
optimization exploring static single assignment form reduce number independent parameters basic block transfer functions program functions rtl instructions constraints gcc linux table sizes software systems ran translation validation 
number trivial equality constraints 
prevent excessive memory sure share representation identical subexpressions 
expensive operations performed algorithm substitution 
scan module collect symbolic state jumps extensively solving procedure 
reduce memory usage time required perform substitution technique explicit substitutions accl 
performing substitutions eagerly carry substitution expressions 
traverse expression hit register fetch accompanying substitution pair expression substitution continue traversal 
tested validator small examples lines worked problems 
precisely examples nd set arithmetic equivalence rules tvi aware 
real test tried tvi compiling gcc compiler linux kernel 
show table number functions compiled case total number il instructions typical sample number constraints arising checking pass 
questions want address experiments 
know semantic coverage strong design wanted know incomplete system moment 
measured ectiveness branch module 
wanted know constraints representing correctness condition program point solved solve module measure incompleteness simpli ers 
recall failures branch module recognize changes control ow graph failures solve module solve eliminate constraints translate directly false alarms compilation correct 
alarm investigated human want eliminate virtually false alarms 
wanted know fast validation process results validating compilation gcc shown table 
results linux kernel similar timings adjusted proportionally number constraints shown table 
columns correspond optimizations lines correspond order percentage failures branch module percentage unsolved constraints time minutes complete validation pass entire compiler pentium pro machine running mhz 
timings include dumping parsing time rtl idea integrate validator compiler 
including times compilation validation twice slow 
early results promising 
branch module turns ggg branch cse loop ra sched branch constr 
time min table synthesis false alarm ratios observe validation time compiling gcc passes 
quite ective fails cases loop unrolling designed handle 
number branch related false alarms validating common subexpression phase 
alarms due branch module able recognize reliably sequences adjacent conditionals eliminated 
second line table shows percentage constraints remain ed solve 
simpli er quite back phases noticed large number ed constraints validating result loop unrolling common subexpression elimination 
preliminary analysis test logs suggests ed constraints case simpli able 
problem mistaken branch result number invalid constraints generated scan 
hope improvement performance branch module bring large reduction ratio false alarms 
terms running time cost tvi observed average validation compilation phase takes times compilation phase 
add time dump rtl les parse tvi time doubled 
believe speed drastically improved optimizations constraint solver time spent 
example plan constraint solving avoid solving constraint twice 
quick validation bug isolating capabilities validator ran version gcc couple example programs known exhibit bugs register allocator loop unrolling 
cases bugs surfaced residual non simpli able constraints 
surprising tvi performs thorough semantic check 
alarm unrolling case accompanied false alarms program lines long 
hope infrastructure practice need false alarm problem especially loop optimizations 
related primary inspiration original translation validation pnueli siegel pss certifying compilation nl nec 
sense project seen tackling goals laid pss symbolic evaluation techniques nec context realistic compiler 
additional innovations required handle optimizations spilling overcome lack assistance optimizer 
possible case key techniques important symbolic evaluation 
advance pss similar goe language involved range optimizations handled ambitious 
pss translation validation applied non optimizing compilation signal compiler translates expressions fragment rtl loops function calls 
case kozen koz validation simpli ed considerably restricting optimizations source level construct compiled pattern target code inter pattern optimizations allowed 
advance previous similar til tmc popcorn mcg attempt validate full semantic equivalence source target opposed checking just preservation type safety 
current widely applicable example compilers unsafe languages ective isolating compiler bugs 
related rinard marinov rm rin 
compiler produces complete proofs transformation validator checks proofs 
formal framework simulation relations appears similar spirit rm 
fundamentally di erent attempts validate translation minimal help compiler making easily applicable existing compilers 
range transformations handle scale experiments ambitious previous 
issue detecting equivalence program fragments studied context merging program variants 
programs considered equivalent isomorphic program representation graphs hpr rr 
prg features symbolic evaluation step ignore syntactic details order unrelated instructions 
prg isomorphism powerful handle optimizations realistic compilers 
main message practical translation validation infrastructure able handle common optimizations realistic compiler implemented ort typically required implement compiler pass say common subexpression elimination 
demonstrate context gnu compiler number optimizations 
believe price small considering qualitative increase ectiveness compiler testing error isolation 
ideal world compilers cooperate translation validators emitting information happened code order take guesswork validator simplifying strengthening 
complete 
experimental data shows need improve validator order reduce number false alarms 
need take serious action running time validator 
believe signi cant improvement possible constraints generated processed 
moment handle intermediate phases gcc ignoring parser code generator 
parser harder handle hand relatively stable 
intend implement translation validation ia code generators 
case need extend infrastructure handle advanced optimizations exploit ia features speculative execution rotating register les 
implemented code necessary validating correct translation exception handling 
feel strong points translation validator exception handling notoriously hard compile correctly hard test 
explored major potential strengths translation validator ability turn theory regular compiler certifying compiler produces proofs pertaining target code 
precisely imagine simulation relations infer basis translating assertions proofs source program assertions proofs target programs ectively bridging semantic gap source target sound way 
particular avor proofs imagine translating easily available proofs typedness ultimate ect gcc compiler java front produce provably type safe native code components 
acknowledgments je foster mihai budiu dawn song hong wang ken mark wegman useful comments rahul help running experiments christopher rose writing latex package diagrams drawn 
accl martin abadi luca cardelli 
curien evy 
explicit substitutions 
journal functional programming october 
alessandro cimatti provably correct embedded veri er certi cation safety critical software 
computer aided veri cation 
th international conference 
proceedings pages 
springer verlag june 
cln christopher colby peter lee george necula fred blau mark 
certifying compiler java 
appear programming language design implementation pldi june 
cm martin 
approach compiler correctness 
acm sigplan notices june 
cygnus solutions 
testing framework 
www gnu org software html 
dij edsger dijkstra 
discipline programming 
prentice hall 
goe wolfgang 
rigorous compiler implementation veri cation 
rudolf editor proc 
workshop programming languages fundamentals programming pages 
hpr susan horowitz jan prins tom reps adequacy program dependence graphs representing programs 
proceedings fifteenth annual acm symposium principles programming languages pages san diego ca january 
koz dexter kozen 
ecient code certi cation 
technical report tr cornell university january 
mcg greg morrisett karl crary neal glew dan grossman richard samuels frederick smith david walker stephanie weirich steve zdancewic 
talx realistic typed assembly language 
proceedings acm sigplan workshop compiler support system software pages 
mic microsoft 
microsoft developer network library march 
moo strother moore 
mechanically veri ed language implementation 
journal automated reasoning december 
mor lockwood morris 
advice structuring compilers proving correct 
proceedings acm symposium principles programming languages pages 
mp john mccarthy james painter 
correctness compiler arithmetic expressions 
schwartz editor proceedings symposia applied mathematics 
american mathematical society 
nec george necula 
compiling proofs 
phd thesis carnegie mellon university september 
available cmu cs 
nl george necula peter lee 
design implementation certifying compiler 
acm sigplan conference programming language design implementation pages june 
pss amir pnueli siegel eli 
translation validation 
bernhard ste en editor tools algorithms construction analysis systems th international conference tacas volume lncs pages 
springer 
rin martin rinard 
credible compilers 
technical report mit lcs tr massachusetts institute technology december 
rm martin rinard darko marinov 
credible compilation 
proceedings run time result veri cation workshop july 
rr ramalingam thomas reps semantics program representation graphs 
technical report cs tr university wisconsin madison december 
tmc david tarditi gregory morrisett perry cheng chris stone robert harper peter lee 
til type directed optimizing compiler ml 
pldi conference programming language design implementation pages may 
daniel weise roger crew michael ernst bjarne steensgaard 
value dependence graphs representation taxation 
proceedings popl st acm symposium principles programming languages pages january 
wo mitchell wand dino oliva 
proving correctness storage representations 
proceedings acm conference lisp functional programming pages 
wuu yang susan horowitz thomas reps program integration algorithm accommodates semantics preserving transformations 
acm transactions software engineering methodology july 
william young 
mechanically veri ed code generator 
journal automated reasoning december 

