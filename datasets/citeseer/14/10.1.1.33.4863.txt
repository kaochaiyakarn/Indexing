automated temporal reasoning reactive systems allen emerson university texas austin austin tx usa 
growing need reliable methods designing correct reactive systems computer operating systems air traffic control systems 
widely agreed certain formalisms temporal logic coupled automated reasoning support provide effective reliable means specifying ensuring correct behavior systems 
discusses known complexity expressiveness results number logics common describes key technical tools obtaining essentially optimal mechanical reasoning algorithms 
emphasis underlying intuitions broad themes technical intricacies 
growing need reliable methods designing correct reactive systems 
systems characterized ongoing typically nonterminating highly nondeterministic behavior 
examples include operating systems network protocols air traffic control systems 
widespread agreement type temporal logic related formalism automata infinite objects provides extremely useful framework reasoning reactive programs 
classical approach temporal logic reasoning reactive programs manual obliged construct hand proof program correctness axioms inference rules deductive system 
desirable aspect proof systems may formulated compositional facilitates development program hand hand proof correctness systematically composing proofs constituent subprograms 
manual proof construction extremely tedious error prone due large number details attended 
correct proofs large programs difficult construct organize intellectually manageable fashion 
entirely clear realistic expect manual proof construction feasible large scale reactive systems 
historically advocated alternative automated approach reasoning reactive systems cf 
em ce ec 
basic idea certain important questions associated propositional temporal logic decidable 
model checking problem finite state transition graph temporal logic specification formula model 
useful automatic verification finite state reactive programs 

satisfiability problem temporal logic specification formula exist model 
useful automatic synthesis finite state reactive programs 
automated program reasoning various forms possible principle 
limiting factors complexity decision procedures expressiveness logics 
discuss factors interaction impact promise pitfalls automated program reasoning 
sketch known complexity expressiveness results number representative logics formalisms 
particular shall focus computation tree logic ctl variants ctl ii mu calculus iii tree automata 
shall discuss key technical tools obtaining essentially optimal decision procedures 
case model checking upshot practice complexity function structure size usually dominating factor regard useful logics effect efficient algorithms 
reason model checking applied quite successfully verify correctness debug real world applications 
potentially serious limitation model checking state space explosion global state graph concurrent system individual processes size exponential variety strategies state explosion problem including symbolic model checking state reduction techniques explored literature remain topic current research interest cf 
ku 
case testing satisfiability simple logic ctl tableau construction suffices obtain small model theorem asserts satisfiable formula small exponential size model exponential time decidability follows 
permits synthesize reactive programs ctl specifications wholly mechanical way 
model defines program meeting specification inconsistent decision procedure says specification reformulated 
potentially serious drawback nowadays widespread agreement type automation helpful opinion unanimous 
course complexity decision procedure 
somewhat surprisingly simplified ctl radically restricted syntax useful program synthesis decidable polynomial time 
logics greater expressive power ctl mu calculus reduce satisfiability nonemptiness tree automata 
pertinent technical tools include determinization complementation automata infinite strings trees 
intimate connections tree automata temporal logics mu calculus 
example mu calculus formulae simply alternating tree automata 
remainder organized follows 
section discusses preliminary material including nature reactive systems temporal logic general manual versus mechanical reasoning covered section technical definitions specific logics focus 
brief overview model checking section 
tableau approach decision procedures described illustrated ctl section 
automata theoretic approach decision procedures discussed illustrated ctl section 
section discusses expressiveness complexity issues including general overview tradeoffs summary key results 
considered section efficiently decidable temporal logics 
concluding remarks section 
preliminaries reactive systems ultimate focus concern development effective methods designing reactive systems cf 
pn 
computer hardware computer software systems usually exhibit concurrent parallel execution individual processes subcomponents running time competing shared resources coordinating activities achieve common goal 
processes subcomponents may geographically dispersed computation distributed 
cardinal characteristic reactive systems ongoing nature computation 
ideally reactive systems exhibit nonterminating behavior 
important practical examples reactive systems 
include computer operating systems network communication protocols computer hardware circuits automated banking teller networks air traffic control systems 
semantics reactive systems terms infinite sequences computation states 
computation sequences may turn organized infinite computation trees 
branching behavior reactive systems typically highly nondeterministic owing variety factors including varying speeds processes execute uncertainty time required messages transmitted communicating processes random factors environment 
high degree nondeterminism behavior reactive systems high degree unpredictable certainly practice 
reason testing means ascertaining correctness reactive system infeasible sequential programs 
accordingly appropriate formal methods precisely specifying rigorously verifying correct behavior reactive systems crucial case reactive systems 
temporal logic obvious difficulty formalisms originally developed sequential programs intended terminate initial state final state semantics little value trying reason reactive systems general final state 
pnueli pn recognize importance ongoing reactive systems need formalism suitable describing nonterminating behavior 
pnueli proposed temporal logic language specifying reasoning change time 
temporal logic basic form corresponds type modal tense logic originally developed philosophers cf 
ru 
provides simple basic temporal operators fp gp pnueli argued combined readily express important correctness properties interest reactive systems 
subsequent appearance pn hundreds thousands papers developing theory applications temporal logic reasoning reactive systems written 
dozens hundreds systems temporal logic investigated standpoint basic theory standpoint applicability practical problems 
large extent trend enrich elaborate pnueli original logic yielding logics increasingly greater expressive power 
obvious advantage expressive logics permit handling wider range correctness properties formalism 
counter trend simplified logics tailored narrowly construed applications 
event widespread consensus type temporal logic constitutes superior way specify reason reactive systems 
universal agreement just logics best general comments 
temporal logics classified number dimensions 
point temporal assertions true false moments time versus interval temporal assertions true false intervals time 

tense versus past tense operators 

linear time temporal assertions implicitly universally quantified possible executions reactive system versus branching time temporal assertions include explicit path quantifiers interpreted computation trees describing system execution 
propositional versus order sense majority temporal logic reason reactive systems focussed propositional point systems 
large number users linear time branching time frameworks 
preference branching time full generality subsumes linear time framework 
shall focus systems ctl ctl discussed ultimate branching time logic mu calculus pltl ordinary linear temporal logic 
re emphasized restricting attention propositional logics turn adequate bulk needs 
manual versus mechanical reasoning difficulty establishing correctness computer programs general special subtleties associated reactive systems particular great deal effort gone developing formal methods reasoning program correctness 
vast literature cf 
mp manual proof systems program behavior specified formal assertion language logic dialect temporal logic rigorous mathematical proof axioms inference rules deductive system logic program meets specification 
manual proofs program correctness offer advantages disadvantages 
advantages obvious 
principle possible completely formal conducting proof obtaining absolute guarantee soundness 
practice working complete true formality problematic achieve level quasi formal argument substituted 
quasi formal arguments useful providing degree assurance program correct 
quasi formal arguments mirror informal style human mathematician 
unfortunately permit errors argument creep line working mathematician notion rigorous strictly formal 
strictly formal proof conducted simply performing symbol manipulations 
exist algorithm text alleged constitute strictly formal proof assertion mechanically checks step proof legitimate say instance axiom results previous steps application inference rule 
complete formalization current state knowledge formal systems notations practical manual setting 
point additional drawbacks manual proof construction program correctness 
just proof ingenuity insight required develop proof 
problem complicated vast amount tedious detail coped general organized subtle ways formulating loop invariants forth 
may detail difficult organize proof intellectually manageable fashion 
upshot task manual proof construction extremely error prone 
source errors strong temptation replace truly formal reasoning quasi formal reasoning 
seen literature manual program verification frequently leads errors 
feel compelled assert controversial claim 
manual verification large scale reactive systems 
justification task error prone overwhelming degree 
strictly formal reasoning plethora technical detail overwhelming 
analogy consider task human adding decimal numbers digits 
rudimentary principle impossible practice human perform accurately 
similarly verification line programs hand feasible 
transcription errors prohibitive 
reasons plus convenience automation believe important focus mechanical reasoning program correctness temporal logic related formalisms 
approaches explore 
mechanical assistance verification programs validity tester applied assertions form intuitively assertions proved hold program new assertion established program 

mechanical verification finite state program meets specification formulated temporal logic model checking algorithm cf 
ce qs ces ku 

mechanical synthesis program meeting temporal specification decision procedure testing satisfiability cf 
ec mw pr 

executable temporal logic specifications 
approach may viewed elegant variation synthesis approach 
synthesis seen process compiling temporal logic specifications contrast approach amounts interpreting specifications fly 
note approach ambitious approach relies technical machinery approach decision procedure satisfiability validity 
argued approaches rely heavily approach 
event sequel shall focus approach model checking approach decision procedures satisfiability 
ctl ctl pltl section provide formal syntax semantics representative systems propositional temporal logic 
branching time temporal logics ctl extension ctl 
simpler branching time logic ctl computational tree logic allows basic temporal operators form path quantifier futures followed single usual linear temporal operators nexttime 
corresponds naturally think branching time logic 
ctl closely related branching time logics proposed la ec qs bpm proposed ce 
syntactic restrictions limit expressive power example correctness fair scheduling assumptions expressed 
consider richer language ctl referred informally full branching time logic 
logic ctl extends ctl allowing basic temporal operators path quantifier followed arbitrary linear time formula allowing boolean combinations nestings proposed unifying framework eh subsuming number systems including ctl pltl 
system pltl propositional linear temporal logic standard linear time temporal logic widely applications cf 
pn mp 
syntax give formal definition syntax ctl 
inductively define class state formulae true false states rules class path formulae true false paths rules atomic proposition state formula state formulae path formula ep ap state formulae state formula path formula path formulae path formulae xp set state formulae generated rules forms language ctl 
connectives introduced abbreviations usual way abbreviates abbreviates abbreviates fp abbreviates gp abbreviates abbreviate gfp infinitely abbreviate abbreviate uq 
take view ap abbreviates give terse syntax terms just primitive operators approach easier give syntax sublanguage ctl 
restricted logic ctl obtained restricting syntax disallow boolean combinations nestings linear time operators 
formally replace rules state formulae xp path formulae 
set state formulae generated rules forms language ctl 
boolean connectives introduced temporal operators defined abbreviations follows efp abbreviates agp abbreviates ef afp abbreviates egp abbreviates af 
note definition seen consistent ctl 
set path formulae generated rules define syntax linear time logic pltl 
semantics formula ctl interpreted respect structure set states total binary relation theta ap labeling associates state set consisting atomic proposition symbols underlying set atomic propositions ap intended true state may view labeled directed graph node set arc set node labels fullpath infinite sequence states convention denotes fullpath denotes suffix path 
write respectively mean state formula respectively path formula true structure state respectively fullpath 
define inductively follows iff iff iff case ep iff fullpath ap iff fullpath iff iff iff case iff implies xp iff formula ctl interpreted ctl semantics rule path formulae generated rule 
similarly formula pltl pure path formula ctl interpreted ctl semantics 
say state formula resp path formula valid provided structure state resp fullpath resp 
state formula resp path formula satisfiable provided structure state resp fullpath resp 
alternative generalized semantics define ctl logics various generalized notions structure 
example consider general structures set states labeling states usual family infinite computation sequences definition ctl semantics carries directly path quantification restricted paths provided fullpath understood refer fullpath usually want set paths generated binary relation cf 
em 
generalization define multiprocess structure refinement notion monolithic structure distinguishes different processes 
formally multiprocess structure set states finite family fr binary relations intuitively represents transitions process total associates state interpretation proposition symbols state 
just monolithic structure multiprocess structure may viewed directed graph labeled nodes arcs 
state represented node labeled atomic propositions true transition relation represented set arcs labeled index may multiple arcs labeled distinct indices pair nodes technically graph theoretic representation directed multigraph 
define nexttime operators relativized process indices 
example extend ctl allow ex iff ax iff implies generalize semantics ctl 
previous formulation ctl structures refers atomic formulae labeling nodes 
straightforward extend include effect arc assertions indicating process performed transition corresponding arc extension needed formulate technical definitions fairness constraints briefly describe 
fullpath depicted ffl ffl ffl ffl 
infinite sequence states alternating relation indices indicating process caused transition assume distinguished propositions en en ex ex intuitively en true state exactly process enabled transition process possible ex true transition performed process technically en atomic proposition state formula true exactly states domain en iff domain fs ex atomic arc assertion path formula ex iff fairness constraints cf 
fr el precisely captured unconditional fairness asserts process executed infinitely expressed ex 
weak fairness asserts process continuously enabled repeatedly executed expressed gen ex strong fairness asserts process enabled infinitely executed infinitely expressed en ex define single type general structure subsumes 
assume underlying set state symbols interpreted states additional set arc assertion symbols interpreted transitions typically think set indices names processes performed transition 
gener fullpath sequence states alternating arc assertions depicted 
say general structure set states total binary relation theta set mapping associating state interpretation state symbols transition interpretation arc assertion 
loss generality due including definition set theta fullpath form finite sequence states infinite sequence states sg consecutive pairs states paths related extensions needed define ctl general structure straightforward 
semantics path quantification specified rule carries directly general provided full path refers arc assertion iff alternative syntax essential idea basic modality 
formula ctl basic modality provided form ap ep contains arbitrary formula pltl 
similarly basic modality ctl form aq eq single linear temporal operators applied pure propositional arguments 
ctl respectively ctl formula thought built boolean combinations nestings basic modalities atomic propositions 
mu calculus ctl provides way extending ctl 
section describe way extending ctl 
view ctl sublanguage propositional mu calculus cf 
ko ec 
propositional mu calculus provides fixpoint operator greatest fixpoint operator possible give fixpoint characterizations branching time modalities 
intuitively mu calculus possible characterize modalities terms recursively defined tree patterns 
example ctl assertion efp computation path true eventually characterized exz fixpoint functional exz atomic proposition variable intuitively ranging sets states ex denotes existential nexttime operator 
give formal definition mu calculus 
syntax formulae propositional mu calculus generated rules atomic proposition constants atomic proposition variables exp formula 
negation formula 
conjunction formulae 
formula syntactically monotone propositional variable free occurrences fall number negations 
set formulae generated rules forms language connectives introduced abbreviations usual way abbreviates axp abbreviates ex abbreviates intuitively stands greatest resp 
fixpoint exp axp means true successor state reachable current state means jpj denote length number symbols say formula subformula formula provided viewed sequence symbols substring subformula said proper provided 
top level immediate subformula maximal proper subformula 
sf denote set subformulae fixpoint operators somewhat analogous quantifiers 
occurrence propositional variable subformula formula said bound 
occurrence free 
renaming variables necessary assume expression occurs sentence closed formula formula contains free propositional variables variable bound formula said positive normal form pnf provided variable quantified twice defined 
alternatively define jpj size syntax diagram negations applied atomic propositions 
note formula put pnf driving negations deep possible laws dualities 
double length formula 
proper defined way subformulae proper subformulae 
oe denote bound variable formula unique subformula oey quantified 
denote subformula oey called variable oey called variable 
oe subformula oe resp 
subformula main connective say top level oe subformula provided proper oe subformula proper oe subformula oe subformula basic modality oe sentence proper oe 
semantics set sigma atomic proposition constants set gamma atomic proposition variables 
ap denote sigma gamma sentences propositional mu calculus interpreted respect structure 
power set may viewed complete lattice 
intuitively identify predicate set states true 
false corresponds empty set bottom element true corresponds top element implication corresponds simple set theoretic containment provides partial ordering lattice 
say monotonic provided implies 
theorem tarski knaster 
monotonic functional 
fy fy fy fy false ranges ordinals cardinality state space finite ranges jsj true ranges ordinals cardinality state space finite ranges jsj 
formula free variables yn interpreted mapping interpreted predicate transformer 
write yn denote free variables yn valuation denoted vn assignment subsets vn free variables yn respectively 
denote value actual arguments vn cf 
ec ko 
operator defined inductively follows fs atomic propositional constant ap sn exp fs rg fs vn note syntactic restrictions monotonicity ensure greatest fixpoints defined 
usually write respectively respectively mean sentence respectively formula true structure state valuation 
understood write simply extensions just ctl ctl multiprocess versions mu calculus 
possible formulation ex exists successor state satisfying reached step process 
dually ax classical notation going back pdl fl write respectively 
discussion get intuition mu calculus noting extremal fixpoint characterizations ctl properties efp exz agp axz afp axz egp exz axz exz properties see fixpoint characterizations simple plausible 
difficult give rigorous proofs correctness ec el :10.1.1.53.3352
turns possible write highly mu calculus formulae readily apparent intuition regarding intended meaning 
discussed subsequently mu calculus rich powerful formalism come surprise 
comment mu calculus formulas really representations alternating finite state automata infinite trees see section 
basic automata deterministic finite state automata finite strings quite complex cans worms surprised potential 
hand mu calculus characterization correctness properties elegant formalism increasing favor especially europe owing simple elegant underlying mathematical structure 
interesting measure structural complexity mu calculus formula alternation depth 
intuitively alternation depth refers depth nesting alternating 
alternation significant entailing subformula forms example occurs scope occurs scope basic modalities af ef ctl expressed mu calculus alternation depth illustrated 
ctl formula 
example mu calculus characterization exy pax alternation depth appears inside alternation inside match form 
property meaning exists path matching regular expression expressed exz exy alternation depth 
hand properties associated fairness require alternation depth 
example fp path occurs infinitely characterized ex 
shown fp expressible alternation depth formula cf 
ec el :10.1.1.53.3352
denote mu calculus restricted formulas alternation depth turns modal temporal logics programs translated succinctly cf 
el :10.1.1.53.3352
interestingly known higher alternation depths form true hierarchy expressive power 
question bearing complexity model checking mu calculus discussed section 
model checking promising techniques automated temporal reasoning reactive systems began advent efficient temporal logic model checking ce cf 
em qs ces 
basic idea global state transition graph finite state reactive system defines kripke structure sense temporal logic cf 
pn give efficient algorithm checking state graph defines model specification expressed appropriate temporal logic 
earlier protocol community addressed problem analysis simple reachability properties model checking provided powerful uniform specification language form temporal logic single efficient verification algorithm automatically handled wide variety correctness properties including safety liveness properties equal ease 
technically tarski knaster theorem understood providing systematic basis model checking 
specifications formulated mu calculus logics ctl noted readily translatable mu calculus 
example calculate states ctl basic modality efp holds structure fixpoint characterization efp exz 
successively calculate ascending chain approximations false false false jsj false false 
intuition just false corresponds set states reach distance reachable state iff reachable steps size iff false size idea easily generalized provide straightforward model checking algorithm ctl entire 
tarski knaster theorem handles basic modalities 
compound formulae built nesting boolean combinations handled recursive descent 
naive implementation runs time complexity jm input structure input formula formulas nested deep 
improvements possible described section 
model checking algorithm dubbed global algorithm computes closed formula structure set states true 
technical characteristic global model checking algorithms subformula specification calculated associated set state potential practical drawback states structure examined 
model checking pltl ctl performed discussed section 
practice interested checking truth particular state gives rise local model checking algorithms best case may examine states structure worst case may cf 
sw 
connection note model checkers type decision procedure provide answers 
turns practice model checkers debugging verification 
industrial environments capacity model checker function debugger better appreciated utility tool verifying correctness 
consider empirical fact designs initially wrong go sequence corrections refinements truly correct design achieved 
suppose aspect correctness wish check simple invariance property form holds provided system started obviously initial state quite invariance may fact hold initial faulty design due conceptually minor tricky errors fine details 
iterations design process fact ef desirable circumvent global strategy examining calculate set ef checking member set 
exist state reachable detected longer necessary continue search examining heuristic underlying local model checking algorithms 
involve depth search start state looking confirming refuting states cycles algorithm terminate prematurely having determined formula true false basis portion examined limited search 
course may states examined finding refutation certainly truly correct design achieved states reachable examined 
practical cases refutation may quickly limited search 
discussion concerns referred extensional model checking explicit state model checking assumed structure including nodes arcs explicitly represented data structures adjacency lists adjacency matrices 
obvious limitation state explosion problem 
reactive system composed sequential processes running parallel global state graph essentially product individual local process state graphs 
number global states grows exponentially particular systems may happen final global state graph tractable size say states plus transitions 
number practical systems modeled useful level scenario model checkers particularly useful 
abstraction state graphs size extensional model checking helpful tool 
hand quickly infeasible represent global state graph large banking network automatic teller machines having just local states yield global state graph astronomical size amounting states 
major advance symbolic model checking techniques cf 
mcm pi cm practice able succinctly represent model check state graphs size states considerably larger 
key idea represent state graph terms boolean characteristic function turn represented binary decision diagram bdd cf 
br 
bdd model checkers remarkably effective useful debugging verification hardware circuits 
reasons understood bdds able exploit regularity readily apparent human eye hardware designs 
software typically lacks regularity bdd model checking helpful software verification 
refer reader mcm extended account utility bdds hardware verification 
great interest model checking methods avoid explicit construction global state graph 
cases possible give methods directly program text implicit representation state graph 
approaches process algebras ccs formalisms petri nets represent programs 
facilitates succinct representation possibly infinite families states exploitation compositional structure programs cf 
bs performing general type local model checking 
drawback general method longer fully automated basic reasons unsolvability halting problem infinite state spaces 
partially automated approaches intriguing 
decision procedures tableaux theoretic approach overview section discuss decision procedures testing satisfiability temporal logic formulas 
basic idea prove small model property logic asserts formula satisfiable finite model size bounded function length yields nondeterministic algorithm guess candidate model bounded size 
check 
logics process improved basic idea eliminate nondeterminism build small tableau graph encoding essentially potential models pseudo model check tableau ensuring contains structure eventualities invariances turn take care tableau structure defines genuine model logics tableau method natural powerful appropriate 
ctl logic 
key advantage fairly direct correspondence organization tableau syntax formula 
logics ctl tableau method normally conceived breaks 
apparent way derive natural tableau graph encoding possible models formula syntax 
fall back widely viewed standard paradigm today basic idea automata theoretic approach build finite state automaton infinite objects strings trees accepting essentially models test nonemptiness 
basic idea subsumes basic idea 
logics tableau method applicable tableau viewed defining automaton 
logics build automaton possible build tableau appeal certain difficult combinatorial constructions theory automata infinite objects 
important determinization automata 
power automata theory lie reservoir deep combinatorial results show construct automaton corresponding formula correspondence means apparent 
course opacity viewed drawback inherent problem 
tableau decision procedure ctl basic idea underlying tableau method follows 
formula initially construct tableau graph systematic case analysis 
nodes essentially sets subformulae meaning node conjunction associated subformulas node thought state satisfying subformulas potential model nodes cases complementation really needed 
complementation infinite string automata accomplished determinization cf 

automata infinite trees clear complementation performed determinization string automata 
correspond partitioning covering state space potential models subformulae hold state 
successively prune nodes inconsistent example nodes assert formula presently true false nodes assert eventually happens really 
pruning performed remains final tableau encodes potential models describe method greater detail 
build initial tableau bipartite graph consisting nodes node set formulae meaning conjunction 
prune tableau deleting inconsistent nodes 
constructed starting ff general method described decomposing node get set node successors method constructing node successors node set appears tableau successor set formulae appears node tableau 
similarly nodes 
bounds size perform ff fi expansion systematically decompose node testing satisfiability boolean combinations elementary formulae atomic propositions negations nexttime formulae way shown equivalent certain boolean combinations assertions nexttime 
decomposition note nonelementary formula may classified conjunctive formula ff ff ff disjunctive formula fi fi fi plainly ff formula fi formula 
temporal modality classified ff fi basis fixpoint characterization mu calculus 
example assuming structure total afh fi formula agh ff formula 
perform ff fi expansion formula resulting subformulae long possible 
yields collection fc sets formula justifying term node downward closed ff implies ff ff fi implies fi fi follows equivalent subset elementary formula general form fp exh exh create successors fg satisfiable iff satisfiable satisfiable 
justifies term node completing construction initial tableau pruned repeatedly applying deletion rules tableau stabilizes yielding final tableau conceivably empty 

delete node contains proposition negation 
delete node original successors deleted successors 

delete node original successors deleted 

delete node containing eventuality current version tableau described detail 
explain rule greater detail 
eventuality formula efh afh asserts eventually happen 
necessary ensure certificate happening tableau 
efh path tableau node path defines directed acyclic subgraph dag efh rooted certifying fulfillment efh starting handled similarly 
fulfillment afh means roughly speaking subtree rooted tableau frontier nodes contain precisely finite directed acyclic graph dag afh rooted frontier nodes nodes containing interior nodes interior node dag afh precisely tableau successors dag afh interior node dag afh tableau successors dag afh 
handle dag defined similarly 
existence dag checked efficiently iterative process amounting model checking account nodes intervening nodes 
proposition 
original formula satisfiable iff final tableau contains node containing proof sketch 
facilitate argument define node eventuality dag interior nodes elided fixed acyclic graph exactly successor successor potential chunk model certifying sufficient successors satisfy subformulae form exh ii fulfilled time frontier reached 
note spliced identifying nodes frontier roots 
suppose done exhaustive systematic way shown 
sn nodes states tableau eventualities 
matrix entries spliced shown 
level 
level level fig 

model formed resulting graph observe node propositionally consistent satisfies exh formulas formulas invariances agh satisfied 
follows downward closure correctness ax agh labels node downward closure 
successors labeled agh 
way invariances may seen take care 
possible problem eventualities may fulfilled 
eventuality afh fulfilled path formula afh propagated label nodes path 
eventually path hit root afh level go frontier occurs fulfilling eventuality 
see systematically constructed graph call node containing satisfiable 
establishes soundness decision procedure 
completeness algorithm may established follows 
satisfiable model state loss generality may assume unwound tree model 
quotient structure obtained identifying states satisfy exactly node label 
follows defines pseudo model contained tableau pruning 
essential point eventuality af holds state subtree rooted frontier nodes contain subtree collapsed yield dag af tableau eliminated account eventuality af unfulfilled 
size tableau exponential jf different subformulas appear nodes nodes 
pruning procedure implemented run time polynomial jt yielding exponential time upper bound 
matching lower bound established simulating alternating polynomial space turing machines cf 
fl cf 
eh ec theorem 
ctl satisfiability deterministic exponential time complete 
decision procedures ii automata theoretic approach resurgence interest finite state automata infinite objects due close connection temporal logic 
provide important alternative approach developing decision procedures testing satisfiability propositional temporal logics 
linear time temporal logics tableau formula viewed defining finite state automaton infinite strings accepts string iff defines model formula satisfiability problem linear logics reduced nonemptiness problem finite automata infinite strings 
related somewhat involved fashion satisfiability problem branching time logics reduced nonemptiness problem finite automata infinite trees 
logics known decision procedures elementary time complexity time complexity bounded composition fixed number exponential functions obtained reductions finite automata infinite trees 
automata transfers difficult combinatorics automata theoretic machinery 
investigations automata theoretic decision procedures fruitful active area research 
linear time automata infinite strings review basics automata theoretic approach linear time 
see va 
comprehensive account 
tableau construction ctl specialized essentially dropping path quantifiers define tableau construction pltl remembering linear structure ep ap extended closure pltl formula ecl defined fq appears node initial tableau simplified structure set nodes states theta consists transitions defined rule exactly formula xp ecl xp iff may view tableau pltl formula defining transition diagram nondeterministic finite state automaton accepts set infinite strings alphabet sigma ap models letting arc labeled set atomic propositions cf 
es 
technically tuple form sigma ffi phi fs state set unique start state ffi defined ffi states ag sigma ffi states ag 
acceptance condition phi described 
run input sigma infinite sequence states ffi fs note automaton accepts input iff run satisfies acceptance condition phi 
different types acceptance conditions phi may 
muller acceptance family sets states 
letting denote set states appear infinitely say run meets muller condition provided pairs automaton cf 
mcn ra acceptance defined terms finite list red green red green pairs sets automaton states may thought pairs colored lights flashes red light pair entering state set red satisfies pairs condition iff exists pair red flashes finitely green flashes infinitely 
convenient assume pairs acceptance condition formally temporal logic formula phi green red 
similarly complemented pairs cf 
st automaton negation pairs condition acceptance condition pairs infinitely green flashes implies red flashes infinitely 
complemented pairs acceptance condition formally temporal logic formula phi fred special case pairs complemented pair conditions buchi bu acceptance condition 
single green light oe 
final acceptance condition mention parity acceptance condition mo cf 
ej 
finite list sets states think colored lights 
condition highest index color flashes infinitely parity 
run correspond model formulae eventualities fulfilled 
check fulfillment easily define acceptance terms complemented pairs 
ecl eventualities uq pairs red green lights 
time state containing uq entered flash red time state containing entered flash green run accepted iff infinitely red flashes implies infinitely green flashes iff eventuality fulfilled iff input string model convert equivalent nondeterministic buchi automaton acceptance defined simply terms single green light flashing infinitely 
need terminology 
say eventuality pending state run provided observe run input corresponds model iff eventuality ecl pending iff eventuality ecl pending infinitely buchi automaton obtained augmenting state valued counter 
counter incremented mod th eventuality uq seen pending run counter reset flash green set counter 
flash green state 
observe infinitely green flashes iff uq pending infinitely iff pending eventuality eventuality fulfilled iff input string defines model exp exp states 
branching time tree automata similarly tableau construction branching time logic relatively simple modalities ctl viewed defining buchi tree automaton essence accepts models candidate formula 
precisely tree accepted automaton model satisfiable tree accepted automaton 
general automata theoretic techniques reasoning number relatively simple logics including ctl buchi tree automata described vardi wolper vw 
richer logics ctl tree automata essential 
tree automata describe finite automata labeled infinite binary trees cf 
ra 
set may viewed infinite binary tree empty string root node node successors successor successor 
finite infinite path tree finite resp infinite sequence node successor node sigma alphabet symbols infinite binary sigma tree labeling maps gamma 
sigma binary tree node labeled symbol sigma finite automaton infinite binary sigma trees tuple sigma ffi phi sigma finite nonempty input alphabet input tree finite nonempty set states automaton ffi theta sigma nondeterministic transition function start state automaton phi acceptance condition described previously 
run input sigma tree intuitively annotation input tree automaton states consistent transition function ffi formally run function ae ae ae ffi ae ae say accepts input tree iff exists run ae infinite paths starting root ae ffi sequence states goes path acceptance condition phi holds tree automata running graphs note infinite binary tree may viewed binary structure sg sg alternatively write 
define notion tree automaton running appropriately labeled binary directed graphs trees 
graphs accepted serve witnesses nonemptiness tree automata 
definitions 
ctl logics study property models unwound infinite tree 
particular esi shown ctl formula length satisfiable iff infinite tree model finite branching bounded iff satisfiable ary tree 
exposition tree automata easily generalized ary trees 
consider binary trees simplify exposition consistency classical theory tree automata 
binary structure consists state set labeling plus transition relation decomposed functions gamma 
specifies successor gamma 
specifies successor run automaton binary structure starting mapping ae ae ae ffi ae ae intuitively run labeling states consistent local structure transition diagram 
transition diagram tree automaton transition function ffi tree automaton viewed natural way defining transition diagram facilitates development algorithms testing nonemptiness 
transition diagram bipartite graph set states comprises set nodes nodes define allowable moves automaton 
intuitively nodes indicate nondeterministic choice depending input label nodes force automaton directions 
example suppose automaton ffi um ffi wn transition diagram contains portion shown 
resemblance transition diagram tree automaton ctl tableau striking 
fact really ctl models built nodes tree automata models built nodes shall see 
fact alternative equivalent formulation tree automata gh transition function information left transition function ffi theta sigma gamma 
giving possible left successor states independent right transition function ffi theta sigma gamma 
giving possible right successor states 
dual formulation tree automaton transition diagram just ctl models built nodes 
symbol alphabets purposes testing nonemptiness loss generality restrict attention tree automata single letter alphabet subsequently ignore input alphabet 
sigma ffi phi tree automaton input alphabet sigma sigma ffi phi tree automaton letter input alphabet sigma fcg obtained intuitively transition diagram making transitions symbol formally identical input alphabet sigma transition function ffi defined ffi sigma ffi 
nonempty iff nonempty 
ffifl fflfi ffifl fflfi ffifl fflfi ffifl fflfi ffifl fflfi ffifl fflfi ffifl fflfi ffifl fflfi qs delta delta delta deltaff au delta delta deltaff delta delta deltaff delta delta deltaff delta delta deltaff au au au au 
tm um vn wn ffifl fflfi nodes states nodes transitions fig 

portion tree automaton transition diagram henceforth assume dealing tree automata symbol alphabet 
generation containment helpful reconsider notion run take advantage organization transition diagram automaton 
intuitively run tree automaton binary structure starting provided generated unwinding transition diagram corresponds state copy node state successors consistent transition diagram 
say binary structure contained provided generated unwinding starting starting copy subgraph linear size model theorem theorem em cf 
vs 
significance provides basis method testing nonemptiness pairs automata shows existence small binary structure accepted automaton contained transition diagram provided automaton nonempty 
theorem linear size model theorem 
tree automaton symbol alphabet pairs acceptance condition phi red 
automaton accepts tree iff accepts binary model size linear size structure contained transition diagram proof 
phi pairs condition hr shows accepts tree accepts finite binary model starting state explain roughly obtained case phi involving single pair 
path node properties labeled automaton state ii node strictly labeled automaton state iii set automaton states interval coincides set states appear infinitely set nodes forms frontier finite subtree formed finite subtree identifying redirecting predecessor 
structure generated case pair follows phi 
finite structure phi generated obtain necessarily finite structure contained distinct nodes labeling states eliminate follows 
attempt delete redirecting predecessors successor 
precisely delete edges form replace edges form 
resulting structure call model phi reduced number duplicates 
try replacing 
resulting structure model phi done 
replacements fail yield model phi yield model phi introduces bad cycle 
bad cycle form predecessor transition suffix path original bad cycle form predecessor transition suffix path original suffix paths edges form bad cycle contradicts model phi 
technical fine point cycles satisfying pair condition closed union 
multiple pairs 
slightly subtle construction get case multiple pairs cf 
hr 
repeatedly eliminating duplicates way eventually get desired model contained 
model contained phi plainly unwound tree accepted linear size model theorem establish result cf 
ej 
theorem 
problem testing nonemptiness pairs tree automata np complete 
proof sketch membership np cf 
em vs pairs tree automaton accepts tree linear size contained transition diagram 
guess model 
efficient model checking algorithm el verify deterministic polynomial time red holds 
np hardness established reduction sat cf 
ej 
approach testing nonemptiness formulated terms pseudo model checking 
write jj gamma indicate technical definition binary model contained observe pairs automaton acceptance condition phi nonempty iff jj gamma phi 
simplicity illustrate pseudo model checking performed rudimentary case 
suppose phi dealing finitary acceptance condition path green light flash 
wish pseudo model check jj gamma 
reduce ordinary model checking fixpoint calculation 
start fixpoint characterization green axz 
notice directly fixpoint characterization account presence nodes intervening nodes diagram green inserted ex skips intervening appropriately 
jj gamma iff simple idea generalized considerably handle pairs acceptance cf ej 
phi pairs condition fred index set pairs gammai denotes fig 
pseudo model check phi fixpoint characterization terms simple formulae af ag induction number pairs 
phi red phi gammai pseudo model checking algorithm transition diagram simultaneously search graph contained check defines model pairs condition phi 
successively calculates set states false satisfiable transition diagram tarski knaster approximation 
effective size fixpoint characterization exponential number pairs 
pseudo model checking algorithm runs time proportional size fixpoint characterization polynomial size transition diagram 
shown ej yields complexity mn automaton transition diagram size pairs 
bound polynomial number automaton states degree polynomial proportional number pairs 
polynomial complexity size state diagram turns significant applications testing satisfiability explained 
related results complexity testing nonemptiness tree automata may ej pr ej 
decision procedure ctl branching time logics richer modalities ctl tableau construction directly applicable 
problem reduces constructing tree automaton accepts tree iff formula satisfiable 
tree automaton general involve complicated acceptance condition pairs complemented pairs simple buchi condition 
somewhat surprisingly known way build tree automaton involves difficult combinatorial arguments appeals delicate automata theoretic results mcnaughton construction mcn automata infinite strings subsequent improvements es sa ej 
original ctl formula converted auxiliary propositions normal form satisfiable iff original formula path quantifiers nested depth 
example ag egp ag ag egp means satisfiable iff satisfiable 
propositional reasoning simplify task testing satisfiability testing satisfiability boolean combinations subformulae form ap ep pure linear time formula 
precisely build tree automata forms 
composite product automaton readily obtained tested satisfiability 
turns easy build tree automata ep surprisingly crucial difficult step building tree automaton branching time modalities form ap terms string automaton corresponding linear time formula explain difficulty manifests just simple modality ap naive approach get tree automaton ap simply build string automaton run paths input tree 
natural fact 
see consider infinite paths xy xz input tree start common finite prefix eventually separate follow different infinite suffixes possible holds paths xy xz order nondeterministic automaton accept guess reading particular symbol finite prefix eventually read suffix suffix state string automaton guesses general different state guesses consequently single run tree automaton nondeterministic string automaton lead acceptance paths 
course string automaton deterministic difficulty vanishes 
ensure string automaton constructing tree automaton 
drawback determinization expensive operation 
appears unavoidable 
linear temporal logic formula length construct equivalent buchi nondeterministic finite state automaton strings size exp 
get tree automata ep size exp 
ap classical automata theoretic results yields tree automaton size triple exponential 
note triple exponential mean exp exp exp large size reflects exponential cost build string automaton described linear time formula plus double exponential cost mcnaughton construction 
ctl formula length nonemptiness composite tree automaton tested exponential time give decision procedure deterministic time complexity quadruple exponential improvement determinization process exponential improvement possible 
es shown due special structure string automata derived linear temporal logic formulae string automata single exponential blowup 
reduced complexity ctl decision procedure triple exponential 
improvement possible described 
size tree automaton measured terms parameters number states number pairs acceptance condition 
careful analysis tree automaton constructions temporal decision procedures shows number pairs logarithmic number states ctl get automaton double exponential number states single exponential number pairs 
described previous section algorithm ej shows test nonemptiness time polynomial number states exponential number pairs 
ctl yields decision procedure deterministic double exponential time complexity matching lower bound vs 
mu calculus pdl delta cf 
st similar techniques techniques applied get single exponential decision procedure cf 
ej se 
comments automata distinct advantages thinking automata theoretically 
obtaining decision procedures automata theoretic techniques provide known methods obtaining elementary time decision procedures expressive logics ctl mu calculus 
techniques general uniform 
example techniques combined yield single exponential decision procedure mu calculus ej 
problem obviously elementary exponential time cf 
kp se 
secondly automata provide general uniform framework encompassing essentially aspects temporal reasoning reactive systems cf 
vw vw va aks ku 
automata proposed potentially useful specification language 
automata bear obvious relation temporal structures state transition graphs concurrent programs possible account various types temporal reasoning applications program synthesis pr model checking conceptually uniform fashion vw 
verification systems automata developed cf 
ku 
temporal reasoning benefited automata 
converse holds automata inspired ideas temporal modal logics 
improved nonemptiness algorithm pairs tree automata discussed uses notion transition diagram tree automaton exploits relationship ctl tableau 
new types automata infinite objects proposed facilitate reasoning temporal logic cf 
st vs mp el 
exponential improvements single exponential complexity determinization string automata appeared special case es general case sa 
exponential improvements single exponential cost complementation automata appeared cf 
ej 
intuition phenomenon gained considering case ctl 
naive formulation tree automaton ctl formula complemented pair lights eventuality check fulfillment 
number lights linear formula length tableau transition diagram size exponential formula length 
determinization complementation string automata fundamental applications decision procedures temporal modal logics basic problems theory automata infinite objects right 
expressiveness versus complexity important characteristics temporal modal logic intended reasoning programs expressiveness referring correctness properties express ii complexity referring computational cost performing various types mechanical reasoning operations model checking satisfiability validity testing logic 
expressiveness characterized ways 
theoretical results established show logic strictly subsumed expressive power logic accordingly write mean property expressible formula expressible formula property expressible formula expressible formula analogously write possible establish various hierarchies relations expressive power logics 
possible characterize expressiveness logic relative 
possibility take particular logic formalism standard providing sense absolute yardstick logics compared 
see examples relative absolute expressiveness subsequently 
practice may concerned specific correctness properties expressed formalism 
general expressive better sufficient just able express invariance agp leads temporal implication ag af simple properties 
significant practical issue conveniently capture desired property 
related theoretical issue concerns succinctness specifications 
refers economy descriptive power formalism long formula required capture property 
formalisms equivalent raw expressive power differ radically succinctness 
example pltl order language linear order equivalent expressive power succinct meaning translation pltl may cause blowup length bounded fixed composition exponential functions 
may ask means better suited pltl specification reasoning reactive programs probably 
succinct essentially formalization right hand side definition temporal operators fp corresponds 
quite possible succinct 
certainly known complexity mechanical reasoning nonelementary 
pltl hand provide combination expressive power succinctness complexity mechanical reasoning ctl branching time framework 
tradeoffs general goals area formulate expressive logic possible lowest complexity decision problem relevant application hand understand tradeoffs complexity expressiveness 
connection point worth noting relationship syntactic complexity temporal logic formula computational complexity decision procedures 
appears related size structure automaton constructed formula 
relationship somewhat intricate 
expressiveness hierarchy hierarchy shown illustrates key points regarding expressiveness emphasize 
ctl ctl ctf ctl pdl delta tree automata thing note finite state pairs tree automata coincide expressive power mu calculus 
virtually mechanical reasoning operations performed terms tree automata branching time logics turns translated tree automata reasonable take tree automata standard branching time expressibility 
little research effort gone succinctness 
particularly valuable topics include identification tractable useful fragments equivalently regular expressions specification language general efforts gain deeper understanding relation syntactic complexity formula cost mechanical reasoning formula 
connection minor technical caveat comparing apples oranges context expressiveness tree automata originally defined run infinite binary trees distinguish left right 
contrast logics ctl mu calculus ax ex opposed interpreted models arbitrary arity distinguish left right 
variety ways formulate uniform compatible framework permitting note logic pdl delta strictly subsumed expressive power mu calculus 
pdl delta propositional dynamic logic infinite repetition operator essence permits assertions basic modalities form eff ff regular expression cf 
st 
pdl delta translated mu calculus essentially regular expressions translated linear time mu calculus cf 
el :10.1.1.53.3352
example xz xz 
similarly ep exz ep exz 
general translation conducted lines 
shown 

expressible pdl delta ternary structures directions arc labels cf 

ctl strictly subsumed expressive power pdl delta 
ctl translated pdl delta main idea linear time formula defines tableau construction equivalent buchi automaton cf 
es translated equivalent regular expression ff 
basic modality eh ctl maps eff pdl delta 
regular expressions strictly expressive pltl cf 
mp wo properties expressible pdl delta captured ctl formula 
true classic example property 
worth noting ctl syntax described sort shorthand ffi 
means basic modalities ctl form branching time logic followed pure linear time formula built linear time operators boolean connectives nestings compositions allowed indicated ffi 
expressiveness results cf 
eh 
compare ctl ctf precursor ctl ctl going back ec 
ctf may described logic 
plainly ctf formula ctl formula 
difference syntactically ctf permit arbitrary nesting linear time formulas basic modalities permit special infinitary operator effect dual support reasoning fairness 
ctl basic modality xp ctf formula shown inequivalent ctf formula 
ctl strictly expressive ctf 
logic ctl permitting basic modalities linear time components boolean combinations linear time operators ctl sublanguage ctf omitting meaningful comparisons 
way compare symmetric tree automata distinguish left right interpreted binary trees branching time logics 
see amorphous tree automata bg 
mu calculus equivalent tree automata reasonable common framework 
operator dual shown example fp expressible ctl ctl strictly subsumed expressive power ctf 
logic shown ctl basic modalities permit just single linear temporal operator plainly ctl sublanguage ctl conversely formula ctl translated equivalent ctl formula 
essence translation ctl formula fp fp equivalent ctl formula ef efp ef efp 
comment comparisons raw expressive power necessarily hold kind succinctness 
example ctl equivalent raw expressive power ctl translation ctl ctl effected exponential blowup 
ctl formula fp fp translated equivalent long ctl formula permutation ef ef efp furthermore ctl expressive pdl delta exponentially succinct 
complexity summary table summarizes key complexity results automated temporal reasoning 
left column indicates logic consideration associated entry middle column characterizes complexity logic model checking problem associated right column entry describes complexity satisfiability problem 
row describes particular logic pltl ctl ctl mu calculus 
logic model satisfiability checking testing pltl pspace complete pspace complete jm delta exp jp time ctl complete exptime complete jm delta jp time ctl pspace complete exptime complete jm delta exp jp time np np exptime complete jm delta jp time row deals pltl complexity analyzed sc 
cf 
va 
pltl model checking polynomially transformed pltl satisfiability testing 
essential point structure structure described pltl formula nexttime operator extra propositions characterize states successors state 
satisfiability problem pltl pspace complete 
practice bound amounts decision procedure complexity exp input formula length decision procedure specialization ctl build exponential sized tableau formula may viewed buchi nfa infinite strings tested nonemptiness time polynomial size automaton 
possible fact build automaton fly keeping track individual node successor node time guessing accepting path nondeterministic polynomial space 
serves show membership pspace satisfiability testing pltl model checking pltl virtue mentioned reduction 
generic reduction pspace bounded turing machines pltl model checking shown pspace hard follows pltl satisfiability testing pspace hard 
important multi parameter analysis pltl model checking performed lichtenstein pnueli lp yielding bound jm delta exp jhj input structure input formula associated algorithm simple elegant 
wish check path starting state satisfying pltl formula 
clarify formulated pltl model checking problem just way 
build tableau form essentially product graph theta view tableau test satisfiability 
amounts looking path product graph projection second coordinate defines model virtue projection coordinate path vardi wolper vw important recognition construction described cleanly uniformly purely automata theoretic terms 
define associated buchi nfa define buchi automaton product simply test nonemptiness 
algorithm complexity analysis lichtenstein pnueli thesis formulated despite potentially daunting exponential growth complexity pltl model checking size specification formula linear complexity size input structure matters applications specifications tend see interesting barringer executable temporal logics extending idea 
quite short structures tend large 
argument goes exponential growth tolerable small specifications fortunate cost grows linearly structure size 
main point concern simply structure size 
appears deal empirical anecdotal evidence lichtenstein pnueli thesis valid actual applications 
noted forthcoming section simple assertions expressible fragment ctl useful 
hand possible find instances lichtenstein pnueli thesis applicable 
formulated pltl model checking problem test effect eh 
applications linear time framework want know computations program satisfy specification amounts checking ah course check lichtenstein pnueli formulation handles 
pltl trivially closed complementation workable efficient solution paths problem terms lichtenstein pnueli formulation 
cf 
el 
row concerns ctl 
ctl model checking complete 
membership established ce simple algorithm tarski knaster theorem 
improved bound jm jjf input structure ctl formula ces 
satisfiability testing ctl complete deterministic exponential time eh 
upper bound established tableau method discussed previously 
lower bound follows generic reduction alternating polynomial space tm cf 
fl 
consider ctl 
model checking problem complexity pltl 
pspace complete multi parameter bound jm delta exp jf 
lower bound follows pltl model checking problem special case ctl model checking problem 
upper bound follows noted ah recursive descent handle boolean connectives nested path quantifiers 
particular check formula check agp label states holds auxiliary proposition check label states holds auxiliary proposition check fp gq 
course practice really necessary introduce auxiliary propositions 
simply observe subformulas agp state formulas label states hold evaluating top level formula 
ctl satisfiability tested deterministic double exponential time building tree automaton essentially double exponential size testing nonemptiness discussed previously 
lower bound follows generic reduction alternating exponential space tm vs 
come complexity mu calculus number interesting open questions concerning model checking 
tight bound known 
know np np ejs 
problems known 
suggests ought able show far resisted efforts number researchers 
hand say shown np complete get np np highly 
argument establishing membership np follows observing structure mu calculus formula nondeterministic tm guess threaded annotation states edges ranked subformulas 
ranks indicate times formula unwound threads indicate subformula state generates subformula successor state necessary check annotation propositionally consistent state founded 
membership np follows mu calculus trivially closed negation 
say useful fragments mu calculus 
recall notion alternation depth mu calculus formula referring depth significant nestings alternating greatest fixpoints 
indicate mu calculus fragment formulas restricted alternation depth tarski knaster theorem basic monotonicity considerations time bound jm delta jf shown cf 
el :10.1.1.53.3352
subsequent addressed improving degree polynomial simply cf 
cs 
fact improved jm delta jf cf 
lo technique trades time space stores roughly intermediate results 
method uses space jm delta jf 
contrast straightforward algorithm uses jm delta jf space 
course known practical properties including expressible pdl delta model checked low order polynomial time 
satisfiability testing mu calculus deterministic exponential time ej shown building tree automaton essentially equivalent mu calculus formula testing nonemptiness 
lower bound deterministic exponential time hard follows simulating alternating polynomial space tm 
automaton properties finite state automata infinite trees standard logics sort considering worth noting types reasonably properties correctness properties expressible finite state tree automaton 
property refer uniform inevitability 
succinctly encoding ctl 
property ordinary inevitability expressed ctl formula afp general form computation time note time occurs computation path depends specific path 
property uniform inevitability general form time computation single uniform time computation paths holds exactly time interestingly shown uniform inevitability definable finite state automaton infinite trees em 
argument akin establish pumping lemma ordinary context free languages 
uniform inevitability definable type pushdown tree automata 
mu calculus equivalent tree automata mu calculus equivalent expressive power tree automata 
result ej 
discuss argument information extracted 
note result easily obtained translation sns concatenated known results 
kp established mu calculus translated sns sns 
earlier ra established basic result tree automata equivalent sns ta sns 
showed restricted mu calculus call ta definition putting sns ta conclude ta 
limitation argument appeals complementation lemma proof step sns ta ra 
complementation lemma asserts tree language accepted finite state pairs automaton infinite trees complement language accepted finite state pairs tree automaton infinite trees 
original proof rabin ra extraordinarily difficult intricate lemma remains technically challenging results field 
technically formidable nature importance applications involving decidability logical theories number authors attempted give simpler proofs complementation lemma cf 
ra gh mu 
arguments ej prove directly ta showing give simplified proof complementation lemma translation mu calculus 
equivalence established showing ata ta emphasize ctl satisfiability require string automaton determinization tree automaton complementation 
ata denotes class alternating tree automata defined technically 
translations left right direct 
involves complementation lemma 
accomplish simplified proof complementation lemma simple idea tree automaton equivalent formula negation certainly formula trivially closed syntactic negation 
translated equivalent tree automaton recognizes precisely complement set trees recognized restricted mu calculus consists formulas built constructs forms atomic proposition constants negations atomic proposition variables restricted conjunctions form ex ex disjunctions greatest fixpoint operators 
syntactically closed complementation obviously semantically closed general missing directly establish complementation lemma 
ata idea underlying translation ata simple mu calculus formula alternating tree automaton 
detail syntax diagram mu calculus formula may viewed particular formulation transition diagram alternating tree automaton checks local structure input tree ensure organization required formula 
alternating automaton runs input tree threads syntax diagram unwound path general may multiple threads going path tree due conjunctions formula 
conjunctions associated multiple threads automaton alternating 
example syntax diagram 

shown 
indicated node syntax diagram subformula edge formula immediate subformulae 
addition edge occurrence back transition diagram consists nodes nodes 
nodes nodes corresponding connective node input symbol usually implicit indicating usual input consumed 
automaton starts state move state state nondeterministic choice 
automaton may enter state semantically closed proof requires appeal complementation lemma 
matters simplified noting binary tree functions just relations 
fig 

syntax diagram 

case checks input symbol labeling current node see matches case accepts rejects 
alternatively automaton may enter state node exercise universal nondeterminism 
automaton launches new threads control 
left branch 
right branch 
state 
move ensure left successor node automaton state move similarly state 
move ensure right successor node automaton state acceptance handled colored lights placed ensure regeneration founded 
way associate pair lights red green eventuality eventuality regenerated thread indicated syntax diagram traversing edge re entering node scope flash green scope exited flash red regenerated infinitely informally refers recursive unfolding formulae 
thread iff green fred holds 
call thread meeting associated pairs condition bad 
mu calculus formula true input tree iff associated ata accepts tree virtue existence run tree threads paths run bad 
amounts acceptance complemented pairs condition fred discuss alternating tree automaton needed show ata ta 
precise notion alternating tree automaton 
ata just ordinary nondeterministic ta existential universal nondeterminism 
reflected transition function permits transitions form ffi fr fs fr fs mk meaning automaton state current node input tree labeled symbol uses existential nondeterminism choose alternative moves 
possible existential move specified pair form fr fs automaton exercises universal nondeterminism go states left successor node states right successor node 
usual automaton starts designated start state root node input tree 
applying transitions run input tree constructed 
run just labeling nodes input tree automaton states superposition tree threads sequences automaton states input tree 
tip thread node labeled symbol ffi form branches extending threads form zr zr corresponding left successor zs zs corresponding right successor 
infinite tree comprised threads way constitutes run input tree 
automaton accepts input tree provided exists run input tree path thread meets acceptance condition automaton buchi pairs 
note run ae input tree may viewed tree superimposed input tree 
thee may copies automaton state tip different finite threads corresponding particular tree node 
copies may different existential moves 
merge different copies threads result general different original run 
history free alternating tree automaton accepting run accepting run existential choices depend current state position tree thread tip 
history free run necessarily tree superimposed input tree dag intuitively threads intertwined tree branch single copy automaton state tree node 
path input tree construction cf 
ej sa bundle collection infinitely threads path finite number states node 
turns alternating tree automaton corresponding mu calculus formula history free 
intuitive justification existential choice node take choice rank ensuring fulfilled soon possible 
alternative method essentially construct tree automaton testing satisfiability mu calculus formula se 
sharpening construction builds tree automaton equivalent mu calculus formula 
basically perform tableau construction get local automaton checking invariance properties inherent formula 
conjoin global automaton checks foundedness 
global automaton obtained follows build string automaton guesses bad thread tableau formula regenerated infinitely violation requirement wellfounded 
construction simultaneously complement string automaton 
tree automaton runs resulting string automaton paths tree desired global automaton checks liveness properties associated formulas 
restricted temporal logics considers longstanding previous trends decision procedures propositional temporal modal logics programs observes characteristics continual emphasis logics increasingly greater expressive power 
sought expressive temporal logic decidable single exponential time deterministically consequence fact temporal logic subsumes ordinary propositional logic reasonable presumption np strongly suggesting better general 
quest increasing generality richness expressive power 
discuss possibly promising counter trend cf 
ess limited logics characteristics limited logics exhibit greater specificity tailored particular applications 
limited logics restricted expressive power 
restrictions may limit raw expressive power economy descriptive power 
intended support efficient polynomial time decision procedures 
focus restricted logics ess ees 
quite delicate obtain logic restricted efficiently decidable time useful 
implications requirements give propositional logic full generality obviously logic subsuming propositional logic np hard 
atomic propositions disjoint exhaustive 
allow overlapping propositions subsets propositions yielding immediate combinatorial explosion 
practice restriction may onerous applications 
example may wish describe program may locations 
may described propositions loc loc syntax simplified 
simplification restrict formulas form assertion conjunction simpler assertions 
note purposes program specification fundamental typically wants program meets conjunction criteria 
simplification limit depth nesting temporal operators 
deeply nested temporal modalities rarely practice anyway 
simplified ctl consider simplified ctl 
turns corresponds precisely fragment ctl program synthesis ec 
formulae conjunctions assertions forms initial assertions ag invariance assertions ag af leads assertions ag assurance assertions ag ax successor assertions ex ex alphabet disjoint exhaustive propositions subject euclidean syntactic constraint esc formula conjuncts form ag ag ax ag conjunct formula 
esc ensures eventualities recoverable propositions 
significance practice esc restriction permits specification history free processes 
means eventualities pending state process irrespective path taken process initial state restricted syntax permits decision procedure ctl simplified yielding polynomial time decision procedure formulas 
understand broad terms possible helpful think automata theoretically vw 
automaton tableau ctl formula may thought product local automaton nexttime tableau global automaton product eventuality automaton eventuality afp size automaton size nexttime tableau times product sizes eventuality automaton 
eventuality automaton say afp states afp pending fulfilled required satisfied 
size automaton exponential number eventualities 
set pending eventualities determined set atomic propositions case owing esc local automaton serve entire automaton 
decision procedure amounts construct nexttime tableau input formula nexttime assertions 
atomic proposition node tableau 
node gets sets successor nodes nexttime assertion associated example ag ax ex node successors node successor nodes successors 
local automaton virtue esc entire automaton 
initial assertions determine start state 
check nonemptiness 
repeatedly delete bad nodes transition diagrams 
associated node set eventualities 
key step ensure finding appropriate dag ordinary ctl 
example consider formula comprised conjunction assertions loss generality may assume 
ag ag exs ag ax ext ag ax exp exr ag ax ex ag aft ag aft get initial tableau shown 
aft node delete propagate deletion incident edges nodes successors resulting tableau shown ii 
node violates successor assertion longer successor 
deleted spurious successor node 
iii final pruned tableau shown 
induces model shown iv 
restricted linear temporal logic consider logic turns efficiently decidable restricted linear temporal logic 
sake uniformity ctl syntax 
path quantifiers satisfiable formula linear model may viewed linear time logic 
alternatively path quantifiers may elided get formulae literally syntax pltl 
formulae conjunctions assertions forms ag invariance assertions ag af leads assertions ag ax successor assertions propositions disjoint exhaustive 
euclidean syntactic constraint related restriction 
establish theorem satisfiability tested deterministic polynomial time 
proof idea 
basic idea simple build nexttime tableau 
input formula satisfiable iff tableau total self fulfilling strongly connected iv ii iii fig 

decision procedure example subgraph means af appears appears suffices build initial tableau split scc delete non self fulfilling scc stabilization 
example consider formula comprised conjunction assertions ag ag ag axp ag ax ag ax ag ax ag afp ag aft initial nexttime tableau shown 
partitioned scc fp 
scc ftg deleted total 
node deleted scc fp sg 
afh 
see remainder scc split scc yielding ffp 
sole remaining scc collection fp rg total self fulfilling 
infinite path defines model original specification 
restricted initialized linear temporal logic 
illustrate boundary efficient decidability worst case intractability quite delicate 
certainly highly restricted 
useful specifications formulated properties expressed 
basic type assertion omitted initial assertion 
define restricted initialized linear temporal logic logic permitting formulas conjunctions assertions form initial assertions ag invariance assertions ag af leads assertions ag ax successor assertions propositions disjoint exhaustive euclidean syntactic constraint related restriction 
words equals plus initial assertion 
surprisingly small change increases complexity theorem satisfiability problem np hard 
idea proof follows 
state graph shown capture structure formula simple fig 

decision procedure fig 

model checking reduced satisfiability conjunction successor assertions ag axb ag ax ag ag ag assume ease exposition unique proposition labels node 
reduce model checking satisfiability iff fm afb ag afc ag afh satisfiable 
generalize argument reduce arbitrary model checking problems form fp satisfiability 
restricted form pltl model checking problem known np hard established sistla clarke sc 
intuition necessary consider possible permutations occur 
due proliferation computer microelectronics associated safety critical software undeniable growing need find effective methods constructing correct reactive systems 
factor systems common nondeterministic ongoing reactive nature complex 
conceivable easy describe general terms system supposed provide air traffic control system appears quite difficult get details straight 
temporal logic appears provide handle precisely stating just behavior occur variety levels detail 
automation temporal reasoning appears offer handle keeping track myriad associated points fine detail 
supported part nsf ccr src contract dp 
howard barringer colin stirling moshe vardi helpful comments preliminary version 
anderson verification temporal properties concurrent systems ph 
dissertation computer science department aarhus univ denmark june 
aks aggarwal kurshan calculus protocol specification validation protocol specification testing verification iii west ed north holland 
ak apt kozen limits automatic verification finite state systems ipl vol 
pp 

barringer fisher gabbay gough owens metatem framework programming temporal logic 
proc 
rex workshop stepwise refinement distributed systems models formalisms correctness netherlands springer lncs june 
bkp barringer kuiper pnueli may compose temporal logic specifications stoc 
bkp barringer kuiper pnueli really concurrent model temporal logic pp 
popl 
bpm ben ari pnueli manna temporal logic branching time 
acta informatica vol 
pp 

bg grumberg branching time temporal logic amorphous automata proc 
th conf 
concurrency theory hildesheim springer lncs pp 
august 
bs stirling local model checking infinite state spaces theor 
comp 
sci vol 
pp 

bcd browne clarke dill checking correctness sequential circuits proc 
ieee int 
conf 
comput 
design port ny pp 
browne clarke dill mishra automatic verification sequential circuits temporal logic ieee trans 
comp 
pp 
br bryant graph algorithms boolean function manipulation ieee trans 
computers 
bu buchi decision method restricted second order arithmetic proc 
inter 
congress logic methodology philosophy science pp 

ce clarke emerson design verification synchronization skeletons branching time temporal logic logics programs workshop ibm yorktown heights new york springer lncs pp 
may 
ces clarke emerson sistla automatic verification finite state concurrent system temporal logic th acm symp 
principles prog 
lang jan journal version appears acm trans 
prog 
lang 
sys vol 
pp 
april 
clarke jha exploiting symmetry temporal logic model checking th international conference computer aided verification crete greece june 
clarke grumberg brown characterizing kripke structures temporal logic theor 
comp 
sci cg clarke grumberg browne reasoning networks identical finite state processes proc 
th acm podc pp 

cg clarke grumberg avoiding state explosion problem temporal model checking podc 
cg clarke grumberg research automatic verification finite state concurrent systems annual reviews computer science pp 
cm clarke mishra automatic verification asynchronous circuits cmu logics programs workshop springer lncs pp 
may 
clarke grumberg brown reasoning identical processes inform 
comp cs cleaveland linear time model checking algorithm alternation free modal mu calculus formal methods system design vol 
pp 
april 
cl cleaveland analyzing concurrent systems concurrency workbench functional programming concurrency simulation automated reasoning springer lncs pp 

courcoubetis vardi wolper reasoning fair concurrent programs proc 
th stoc berkeley cal pp 
may 
cm coudert madre verifying temporal properties sequential machines building state diagrams computer aided verification clarke kurshan eds dimacs series pp 
june 
dgg dams grumberg gerth generation reduced models checking fragments ctl cav springer lncs 
di dijkstra discipline programming prentice hall 
dc dill clarke automatic verification asynchronous circuits temporal logic ieee proc 
pt 
pp 

em emerson branching time temporal logics design correct concurrent programs ph 
dissertation division applied sciences harvard university august 
em emerson alternative semantics temporal logics theor 
comp 
sci pp 

em emerson automata tableaux temporal logics proc 
workshop logics programs brooklyn college pp 
springer lncs june 
ec emerson clarke characterizing correctness properties parallel programs fixpoints 
proc 
th int 
colloquium automata languages programming lecture notes computer science springer verlag 
ec emerson clarke branching time temporal logic synthesize synchronization skeletons science computer programming vol 
pp 
dec 
ees emerson srinivasan limits efficient temporal satisfiability proc 
th annual ieee symp 
logic computer science philadelphia pp 
june 
eh emerson halpern decision procedures expressiveness temporal logic branching time journal computer system sciences vol 
pp 
feb 
eh emerson halpern revisited branching versus linear time temporal logic jacm vol 
pp 
jan 
ej emerson jutla complexity tree automata modal logics programs proc 
th ieee foundations computer sci ej emerson jutla simultaneously complementing automata proceedings th ieee symp 
logic computer science lics pp 

ej emerson jutla tree automata mu calculus determinacy proc 
rd ieee symp 

comp sci ejs emerson jutla sistla model checking fragments mu calculus proc 
th inter 
conf 
computer aided verification greece springer lncs pp 

el emerson lei efficient model checking fragments mu calculus ieee symp :10.1.1.53.3352
logic computer science lics cambridge mass june 
el emerson lei modalities model checking branching time strikes back pp 
acm popl journal version appears sci 
comp 
prog 
vol 
pp 
es emerson sistla symmetry model checking th international conference computer aided verification crete greece june full version appear formal methods system design 
es emerson sistla deciding full branching time logic proc 
workshop logics programs carnegie mellon university springer lncs pp 
june journal version appears information control vol 
pp 
june 
ess emerson sadler srinivasan efficient temporal reasoning pp th acm popl 
em emerson uniform inevitability finite automaton information processing letters pp 
january 
em emerson temporal modal logic handbook theoretical computer science vol 
van leeuwen ed elsevier north holland 
fl fischer ladner propositional dynamic logic regular programs jcss vol 
pp 

fr francez fairness springer verlag new york gabbay pnueli shelah temporal analysis fairness th annual acm symp 
principles programming languages pp 

gs german sistla reasoning systems processes journal acm july vol pp 
gh gurevich harrington trees automata games th acm stoc 
ht thomas computation tree logic ctl path quantifiers monadic theory binary tree icalp 
knowledge common knowledge distributed environment proc 
rd acm symp 
podc pp 

hs halpern shoham propositional modal logic time intervals ieee lics pp 

ha harel dynamic logic axiomatics expressive power phd thesis mit available springer lncs series 
ha harel dynamic logic handbook philosophical logic vol 
ii extensions classical logic ed 
gabbay guenthner reidel press boston pp 

applications th stoc pp 
may 
hs hart sharir probabilistic temporal logics finite bounded models th stoc pp 

hs hart sharir probabilistic temporal logics finite bounded models th acm stoc pp 

ho hoare communicating sequential processes cacm vol 
pp 

ha verifying concurrent processes temporal logic springer verlag lncs 
ho owicki verifying network protocols temporal logic proceedings trends applications computer network protocols ieee computer society pp 

hr rackoff emptiness problem automata infinite trees proc 
th ieee symp 
switching automata theory pp 

id ip 
dill better verification symmetry april 
je jensen colored petri nets basic concepts analysis methods practical vol 
analysis methods eatcs monographs springerverlag 
jr jensen rozenberg 
eds high level petri nets theory application springer verlag 
ka kamp hans tense logic theory linear order phd dissertation ucla 
ko specifying message buffers requires extending temporal logic podc 
ko kozen results mu calculus theor 
comp 
sci pp 
dec kp kozen parikh elementary proof completeness pdl theor 
comp 
sci pp 
kp kozen parikh decision procedure propositional mu calculus proc 
workshop logics programs university springer lncs pp 
june 
kt kozen tiuryn logics programs handbook theoretical computer science van leeuwen ed elsevier north holland 
ku kurshan testing containment omega regular languages bell labs tech 
report conference version kurshan reducibility analysis coordination springer verlag 
ku kurshan computer aided verification coordinating processes automata theoretic approach princeton university press princeton new jersey 
lr ladner reif logic distributed protocols proc 
conf 
theor 
aspects reasoning knowledge ed 
halpern pp 
los altos cal morgan kaufmann la lamport temporal logic programs th annual acm symp 
principles programming languages pp 

la lamport temporal logic proc 
ifip pp 

lps lehmann 
pnueli justice fairness ethics concurrent termination icalp lncs vol 
pp 
ls lehmann shelah reasoning time chance inf 
control vol 
pp 

lp pnueli checking finite state concurrent programs satisfy linear specifications popl pp 
jan 
lichtenstein pnueli zuck glory past brooklyn college conference logics programs springer verlag lncs june 
lo long browne clarke jha improved algorithm evaluation fixpoint expressions proc 
th inter 
conf 
computer aided verification stanford springer lncs june 
mp manna pnueli verification concurrent programs temporal framework correctness problem computer science boyer moore eds academic press pp 

mp manna pnueli verification concurrent programs temporal proof principles proc 
workshop logics programs kozen ed springer lncs pp 

mp manna pnueli verification concurrent programs temporal proof system proc 
th school advanced programming amsterdam netherlands june 
mp manna pnueli cook proof system pet language acm symp 
princ 
prog 
languages pp 

mp manna pnueli adequate proof principles invariance liveness properties concurrent programs science computer programming vol 
pp 

mp manna pnueli specification verification concurrent programs automata proc 
th acm popl mp manna pnueli hierarchy temporal properties podc 
mw manna waldinger better intermittent assertions proving program correctness cacm vol 
pp 
feb mw manna wolper synthesis communicating processes temporal logic specifications vol 
pp 
jan 
mp manna pnueli temporal logic reactive concurrent systems specification springer verlag mcm mcmillan symbolic model checking approach state explosion problem ph 
thesis carnegie mellon university 
mcn mcnaughton testing generating infinite sequences finite automaton information control vol 

mp mcnaughton counter free automata mit press 
mc mead conway vlsi systems addisonwesley reading mass 
meyer weak monadic second order theory successor elementarily recursive boston logic colloquium springer verlag lecture notes math 
berlin new york 
mo mostowski regular expressions infinite trees standard form automata proc 
th 
symp computation theory poland pp 
springer lncs 
mu muchnik games infinite trees automata dead ends new proof decidability monadic theory successors semiotics information pp 
russian 
mo moszkowski reasoning digital circuits phd thesis stanford univ 
mu muller infinite sequences finite machines th ann 
ieee symp 
switching theory logical design pp 

nguyen demers owicki gries model temporal proof system networks processes distr 
computing vol 
pp unpublished manuscript 
fixed points versus infinite generation proc 
rd ieee symp 
logic computer science pp 

ol owicki lamport proving liveness properties concurrent programs acm trans 
programming languages syst vol 
july pp 

pw pinter wolper temporal logic reasoning partially ordered computations proc 
rd acm podc pp 
vancouver aug pi computational theory implementation sequential hardware equivalence cav dimacs series vol dimacs tech 
report eds 
kurshan clarke june 
pi theory implementation sequential hardware equivalence ieee transactions computer aided design pp 
vol 

pe peterson myths mutual exclusion problem inform 
process 
letters vol 
pp 

pn pnueli temporal logic programs th annual ieee cs symp 
foundations computer science pp 

pn pnueli temporal semantics concurrent programs theor 
comp 
sci vol 
pp 
pn pnueli extremely fair termination probabilistic algorithms annual acm symp 
theory computing 
pn pnueli transition global modular reasoning concurrent programs logics models concurrent systems ed 
apt springer 
pn pnueli linear branching structures semantics logics reactive systems proceedings th icalp pp 

pn pnueli applications temporal logic specification verification reactive systems survey current trends current trends concurrency overviews tutorials ed 
de bakker de roever rozenberg springer lncs 
pr pnueli rosner synthesis reactive module th annual acm symp 
principles programing languages pp 
jan 
pr pnueli rosner synthesis asynchronous reactive module proc 
th int colloq 
automata languages programming italy july pp 
springer verlag lncs 
pr pratt decidable mu calculus nd focs pp 

pr prior past oxford press 
ru rescher urquhart temporal logic springer verlag 
qs sifakis specification verification concurrent programs cesar proc 
th int 
symp 
prog springer lncs pp 

qs sifakis fairness related properties transition systems acta informatica vol 
pp 

ra rabin decidability second order theories automata infinite trees trans 
ams pp 

ra rabin automata infinite objects church problem conf 
board 
math 
sciences regional series math 
amer 
math 
soc providence rhode island 
ra rackoff emptiness complementation problems automata infinite trees master thesis eecs dept mit 
ru rescher urquhart temporal logic springer verlag new york 
der de roever recursive program schemes semantics proof theory math 
centre tracts amsterdam 
sa safra complexity omega automata proc 
th ieee focs pp 

sa safra exponential determinization automata strong fairness acceptance condition proceedings th annual acm symposium theory computing pp 
victoria may 
si sistla theoretical issues design distributed concurrent systems phd thesis harvard univ 
sc sistla clarke complexity propositional linear temporal logic acm vol 
pp 
sistla clarke francez meyer message buffers axiomatized temporal logic information control vol 
nos 
oct nov pp 

si sistla characterization safety liveness properties temporal logic podc 
sistla vardi wolper complementation problem buchi automata applications temporal logic theor 
comp 
sci pp 
sms schwartz melliar smith state machines temporal logic specification methods protocol standards ieee trans 
communication com pp 

smv schwartz melliar smith vogt interval logic higherlevel temporal reasoning proc 
nd acm podc montreal pp 
aug 
st streett propositional dynamic logic looping converse phd thesis mit journal version appears information control 
se streett emerson propositional mu calculus elementary icalp pp july journal version appears automata theoretic decision procedure propositional information computation june 
sw stirling walker local model checking mu calculus pp 
springer lncs 
st stirling modal temporal logics 
handbook logic computer science gabbay ed 
oxford ta lattice theoretical fixpoint theorem applications pacific 
math pp 

th thomas star free regular sets omega sequences information control pp 
th thomas automata infinite objects handbook theoretical computer science vol 
van leeuwen ed elsevier north holland 
va vardi taming converse reasoning way computations proc 
workshop logics programs brooklyn ny lncs springer verlag pp 

va vardi verification concurrent programs automata theoretic framework proc 
ieee lics pp 
june va vardi temporal fixpoint calculus popl 
va 
vardi automata theoretic approach linear temporal temporal logic volume 
vs vardi stockmeyer improved upper lower bounds modal logics programs proc 
th acm symp 
theory computing pp 

vw vardi wolper process logic proc 
cmu workshop logics programs springer lncs pp 

vw vardi wolper automata theoretic techniques modal logics programs stoc journal version jcss vol 
pp 

vw vardi wolper automata theoretic approach automatic program verification proc 
ieee lics pp 

wo wolper temporal logic expressive focs journal version information control vol 
nos 
pp 

wo wolper synthesis communicating processes temporal logic specifications ph thesis stanford univ 
wo wolper tableau method temporal logic overview logique analyse june sept pp 

wo wolper expressing interesting properties programs propositional temporal logic acm symp 
princ 
prog 
lang pp 

wo wolper relation programs computations models temporal logic temporal logic specification springer verlag lncs april 
article processed macro package llncs style 
