cube proof systems intuitionistic predicate logic uustalu royal institute technology stockholm sweden vene university estonia attempt study proof theory intuitionistic predicate logic conventional intuitionistic predicate logic extended logical constants greatest fixpoint operators positive predicate transformers 
identify proof theoretically interesting natural deduction calculi logic propose classification cube basis relationships 
logics logics logical constants greatest fixpoint operators positive predicate transformers turned useful formalism number computer science areas 
classical st order predicate logic logic non deterministic imperative programs database query language 
relation description languages studied descriptive complexity theory finite model theory survey highly actual application see ef chapter 
modal propositional fragment applicable specification language state machines terminological logic 
typical problems interest applications decision sentence valid 
finite model checking sentence finite structure satisfy 
viable natural deduction calculi intuitionistic logics time fruitfully thought typed functional programming languages supporting inductive coinductive types 
application typical problems interest derivation normalization derivation find normal form computation derivation checking sentence derivation establish program verification derivation finding sentence find derivation establishes program construction 
comparison enormous attention problems centering notions classical validity satisfaction especially finite model checking verification finite state machines received research literature logics interest problems concerned notion intuitionistic proof modest 
attempt study proof theory intuitionistic predicate logic building due extent learned literature 
identify proof theoretically interesting calculi logic propose classification cube basis kista sweden kth se ee estonia cs ut ee relationships 
discuss application calculi cube program construction 
organized follows 
section prepare ground subsequent exposition laying particular fashion treating intuitionistic calculi typed functional programming languages employ 
section example standard calculus nd order intuitionistic predicate logic extended logical constant oe non deterministic arbitrary fixpoint operator positive predicate transformers 
calculus denoted nip 
fix terminology notation 
section introduce cube define extensions nip show typed functional programming languages 
state relationships calculi 
section discussion results section contains exposition toy examples program construction 
section point directions 
setting obvious orthodox way seeing intuitionistic calculus typed functional programming language relies direct interpretation sentences types derivations algorithms best formalized defining isomorphism homomorphism inverse homomorphism calculus typed calculus curry howard isomorphism 
codomain isomorphism sentential fragment nip extension girard system gir rey nice simply typed calculus 
codomain isomorphism full nip contrast dependently typed calculus heavy serve practical functional programming language 
general approach put forth leivant lei consider certain part structure sentences derivations essential typing computation relate typed calculus calculus means appropriate contracting homomorphism 
choose contraction kind sentences suppress occurrences individuals st order quantifiers derivations accordingly suppress occurrences individuals rules st order quantifiers predicates rules nd order quantifiers rules oe 
idea interpret sentences full glory specifications functions calculus medium program construction calculus stand component program exploitation programming language 
codomain contracting homomorphism full nip extension variant system implicit type coercions denoted syntax employ derives martin lof theory expressions nps chapter 
denotes application 
xn denotes abstraction xn signifies definitionally equal key postulate theory says xn xn 
operators expression application abstraction identified operators app calculi 
app fi 
confusing application open term term application operator app terms corresponds confusing plugging derivation open derivation plugging derivations rule oe modus ponens 
derivations syntax essentially due schroeder heister sh 
syntax notational variant general syntax 
part definition nip accompanied respective part definition sake brevity left logical constants associating inference contraction rules 
fact essential virtue known homomorphism full nip fragment 
homomorphism calculus typed calculus mapping sends sentences type terms derivations terms derivation establishes sentence corresponding term types corresponding type term derivation reduces term corresponding reduces corresponds 
pred omega omega times sent oe sent omega sent sent sent sent pred sent sent oe pred pred pred oe oe oe oe oei oe oe oee oe oe 
gamma oe oe 
oe fi 

gamma 
gamma fi 
gamma 
gamma fi 
gamma 
gamma oe oe oei oe oee fi 
gamma oe oe type omega type type type type type oe type type type term term term app term omega term term pi term term pi term term term oe term oe term oe term oe app fi cube shall introduce cube extensions nip parallel calculi introduce correspondent calculi 
functional programming point view calculi inductive type elimination rule recursion operator dually coinductive type rule corecursion operator 
calculus cube characterized inference contraction rules kind recursion corecursion operators captured inference rules varies 
calculi bottom front nodes nip iteration calculi top front nodes nip primitive recursion corecursion calculi bottom back nodes nip courses values iteration calculi top back nodes nip 

courses values recursion corecursion 
courses values iteration function definition scheme output function input defined terms outputs inputs immediately precede simple iteration terms outputs inputs precede 
cf 
relation courses values induction naturals simple mathematical induction 
order save space treat aspects dual give definitions just total calculi cube 
nip 

nip nip oo oo nip oo oo calculi ideally logical constant fixpoint operator predicate transformers 
pred pred pred type type type predicate transformer fixpoint 
calculi cube faithfully expresses fixed point predicate transformer positive 
predicate transformer called positive iff occurrence appears number antecedents implications oe 
positivity simple sufficient condition monotonicity turn sufficient condition existence greatest fixpoints 
regards applications non positive predicate transformers approaches cube 
calculi left applications simply forbidden 
calculi right names contain letter mendler constrast allowed predicate transformer expresses fixpoint certain positive particular case happens monotone equivalent calculi left calculi way detour removed derivation depends part structure predicate transformer applied 
part structure nicely condensed pseudo predicate transformer call shape notation jf 
predicate transformer shape obtained replacing occur special pseudo sentence blank 
contraction rule best formulated making auxiliary inference rule inference rules inference rule parametric shape forbidden non positive shape value parameter 
auxiliary inference rule states predicate transformer necessarily positive shape monotone 
encapsulates shape dependent derivation applications auxiliary inference rules 
jf map jf term omega term term term example calculus left calculus left hand bottom front node nip basic calculus 
inference rule states predicate transformer necessarily positive shape pre fixpoint inference rule park fixpoint induction principle states predicate transformer necessarily positive shape subsumed pre fixpoint note inference rule contraction rule jf jf 
gamma jf 
jf fi 
gamma 
jf jf 
wrap jf term term cata jf term omega term term term cata jf wrap jf fi map jf cata jf calculi right calculi inference rules shape parameter analog inference rule reason finds fixpoint predicate transformer jf definition see section 
example calculus right calculus right hand bottom front node inference rule states predicate transformer pre fixpoint inference rule states predicate transformer subsumed pre fixpoint 
gamma 
delta 
fi 
gamma ae 
delta 
ae 
term omega term term term iter term omega pi term omega term term term term iter fi ae iter ae calculi far calculi bottom front nodes inference rule behaves iteration operator 
calculi top front nodes inference rule behaves primitive recursion operator 
example calculus right hand top front node 
gamma 
delta 
fi 
gamma ae 
delta 
ae 
delta 
term omega term term term rec term omega pi term omega term term omega term term term term rec fi ae rec ae calculi bottom back nodes inference rule behaves courses values iteration operator 
example calculus right hand bottom back node 

gamma 
delta 

fi 
gamma ae 
delta 
ae 

cv term omega term term omega term term term cv iter term omega pi term omega term term omega term term term term cv iter cv fi ae cv iter ae nip formulated leivant lei acknowledged mendler men publication variant appeared geuvers 
aware accounts calculi back nodes cube literature 
hagino category theoretically motivated calculus hag relative calculus destructors cata inverse wrap appears gre chapter 
martin lof published calculus supporting iterated inductive definitions predicates early ml 
embeddings exist embeddings injective homomorphisms calculi adjacent nodes cube directions 
addition exists homomorphism basic calculus nip nip logical constants inference rules mapped identically associating inference rules 
characterize mapping image 
embeddings forward directions ffl left right ffl bottom top ffl front back inflationary 
embeddings backward directions ffl right left oe positive monotone 
note nd order quantifiers 
ffl top bottom left right oe oe oe note oe 
ffl back front left right oe oe embeddings forward directions straightforward 
top bottom embedding nip nip implicit par 
corresponding calculi explicitly 
homomorphism nip nip oe oe definition associating inference rules nip nd order quantifiers associating inference rules known due leivant lei bohm berarducci bb 
nip enjoy property strong 
calculi cube enjoy property exists homomorphism nip discussion calculi cube equally powerful terms expressible functions denotationally differ terms expressible algorithms operationally 
recursion courses values iteration allow efficient programming plain iteration 
iterative predecessor algorithm naturals expressible nip requires linear time 
nip contrast express better recursive algorithm computes constant time 
give examples program scheme construction calculi cube 
example factorial scheme define zero succ nat fact nat fact scheme specifying place function naturals terms number place function equations gamma gamma expressible follows zero oe fact succ fact nat oe fact 
nat oe fact iterative program scheme programs computes component pair corresponds program scheme constructible fi fst iter fi fl ffi case fl app inl app hfst ffi snd inr hfst snd ffi snd recursive program scheme corresponds program scheme constructible fi rec fi fl ffi case fl app app hfst hffi snd snd ii example fibonacci scheme define zero succ nat fibo nat fibo scheme specifying place function naturals terms numbers place function equations gamma gamma expressible follows zero oe fibo succ zero oe fibo succ succ fibo fibo oe fibo 
nat oe fibo iterative program scheme programs computes component pair gamma corresponds program scheme constructible fi fst iter fi fl ffi case fl app inl case snd ffi snd app hfst app hfst hfst hfst ffi snd snd iii inr hfst fst ffi snd courses values iterative program scheme corresponds program scheme constructible fi cv iter fi fl ffi case fl app case snd app hfst app hfst hfst hffi snd ffi snd iii calculi arranged cube showed function media construction functional programs 
pleased discover provides support recursive programming meaningful recursion corecursion operator 
intend continue research closer inspection perspectives practical applicability calculi program construction concerns specification methodology computer assistance program construction 
intend look connections category theoretic technology program construction advocated mathematics program construction calculation programs community 
vene grateful stockholm club district rotary international financing month visits royal institute technology stockholm 
bb bohm alessandro berarducci 
automatic synthesis typed programs term algebras 
theoretical computer science 
ef heinz dieter ebbinghaus jorg flum 
finite model theory 
perspectives mathematical logic 
springer verlag berlin 
herman geuvers 
inductive coinductive types iteration recursion 
nordstrom pettersson plotkin editors preliminary proceedings workshop types proofs programs sweden june pages 
dept computing science chalmers univ technology goteborg univ 
ftp ftp cs chalmers se pub cs reports proc dvi gir jean yves girard 
une extension de interpr etation de godel analyse son application elimination des coupures dans analyse la th eorie des types 
fenstad editor proceedings nd scandinavian logic symp oslo norway june volume studies logic foundations mathematics pages 
north holland amsterdam 
gre john greiner 
programming inductive inductive types 
technical report cmu cs school computer science carnegie mellon univ pittsburgh pa usa january 
hag hagino 
typed lambda calculus categorical type constructors 
pitt poign rydeheard editors proceedings nd int conf 
category theory computer science ctcs edinburgh uk sept volume lecture notes computer science pages 
springer verlag berlin 
howard 
formulae types notion construction 
seldin hindley editors curry essays combinatory logic lambda calculus formalism pages 
academic press london 
reprint manuscript written 
brian howard 
fixed points extensionality typed functional programming languages 
phd thesis technical report stan cs computer science dept stanford univ ca october 
lei daniel leivant 
reasoning functional programs complexity classes associated type disciplines 
proceedings th annual ieee symp 
foundations computer science focs tucson az usa nov pages 
ieee computer society press los alamitos ca 
lei daniel leivant 
contracting proofs programs 
odifreddi editor logic computer science volume apic studies data processing pages 
academic press london 
men paul mendler 
recursive types type constraints second order lambda calculus 
proceedings nd annual ieee symp 
logic computer science lics ithaca ny usa june pages 
ieee computer society press washington dc 
ml martin lof 
intuitionistic theory iterated inductive definitions 
fenstad editor proceedings nd scandinavian logic symp oslo norway june volume studies logic foundations mathematics pages 
north holland amsterdam 
nps bengt nordstrom kent petersson jan smith 
programming martin lof type theory volume int series monographs computer science 
clarendon press oxford 
par michel parigot 
representation data lambda calculus 
borger richter editors proceedings rd workshop computer science logic csl kaiserslautern frg oct volume lecture notes computer science pages 
springer verlag berlin 
rey john reynolds 
theory type structure 
robinet editor proceedings programming symp 
colloque sur la programmation paris france apr volume lecture notes computer science pages 
springer verlag berlin 
sh peter schroeder heister 
natural extension natural deduction 
journal symbolic logic 

