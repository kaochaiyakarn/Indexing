partial redundancy elimination ssa form robert kennedy sun chan shin ming liu raymond lo peng tu fred chow silicon graphics computer systems ssapre algorithm performing partial redundancy elimination entirely ssa form 
algorithm formulated new conceptual framework factored redundancy graph analyzing redundancy represents sparse approach classical problem partial redundancy elimination 
time provides new perspectives problem methods solution 
algorithm description theorems proofs showing algorithm produces best possible code criteria computational optimality lifetime optimality introduced temporaries 
addition base algorithm practical implementation ssapre exhibits additional compile time efficiencies described 
closing measurement statistics provided characterize instances partial redundancy problem set benchmark programs compare optimization time spent implementation ssapre classical partial redundancy elimination implementation 
data lend insight nature partial redundancy elimination demonstrate new approach 
categories subject descriptors programing languages language constructs control structures data types structures procedures functions subroutines pro gramming languages processors compilers optimization algebraic manipulation algorithms analysis algorithms artificial intelligence automatic programming program transformation general terms partial redundancy code motion static single assignment form additional key words phrases common subexpressions data flow analysis program optimization 
partial redundancy elimination pre powerful optimization technique developed morel renvoise morel renvoise 
technique removes partial redundancies program performing data flow analysis solves code placements 
global common subexpressions loop invariant authors address silicon graphics computer systems shoreline blvd mountain view ca 
peng tu address intel mission college blvd santa clara ca 
permission digital hard copy part material fee granted provided copies distributed profit commercial advantage acm copyright server notice title publication date appear notice copying permission association computing machinery 
acm 
copy republish post servers redistribute lists requires prior specific permission fee 
fl acm acm transactions programming languages systems vol 

somemonth pages 
delta robert kennedy computations special cases partial redundancies subsumed pre 
result pre important component global optimizers chow chow schwarz briggs cooper simpson 
alternative placement strategy called lazy code motion knoop knoop improves morel renvoise results avoiding unnecessary code movements removing bidirectional nature original pre data flow equations 
result lazy code motion optimal number computations reduced safe code motion kennedy lifetimes temporaries introduced minimized 
drechsler gives variant lazy code motion algorithm different data flow framework 
muchnick gives problem partial redundancy elimination classical methods solution 
approaches pre bit vector formulation problem iterative solution data flow equations 
presents new approach called ssapre chow shares optimality properties best prior knoop knoop drechsler static single assignment form 
static single assignment form ssa popular program representation modern optimizing compilers 
versatility stems fact addition representing program provides accurate definition def relationships program variables concise form cytron wolfe chow 
efficient global optimization algorithms developed ssa 
optimizations dead store elimination cytron constant propagation wegman zadeck value numbering alpern rosen briggs induction variable analysis liu live range computation global code motion click 
uses ssa restricted solving problems essentially program variables 
ssa readily applied solving expression problems concept def expressions obvious variables 
difficulty mentioned dhamdhere dhamdhere 
state essentially clear connection def information variables represented ssa form redundancy properties expressions 
demonstrating connection exploiting shows ssa approach pre expression problems plausible enlightening practical 
addresses pre problem expression problems addressed framework 
reasons ssa solution optimization problem desirable 
optimizations ssa share common characteristic require traditional iterative data flow analysis solutions 
take advantage sparse representation ssa 
sparse form information associated object represented places changes object occurs program 
sparse representations typically conserve memory space avoiding needless duplication data 
information propagated sparse representation smaller number steps dense structure speeding algorithms 
benefit fully sparseness sacrifice parallelism achieved acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta techniques operate entire program 
example traditional data flow analysis bit vectors operate program expressions parallel 
sparse schemes give parallelism operating element separately allows optimization decisions customized 
advantage ssa allows global optimization efficiently subsume local version optimization 
depending nature optimization traditional frameworks typically require separate implementations efficiency sake global version uses bit vectors basic block simpler faster local version performs optimization basic block 
global implementations optimization handle local version job usually substantially higher cost 
contrast ssa optimization algorithms need distinguish global local optimizations ssa directly exposes def relationships program 
algorithm handle global local versions optimization simultaneously efficiently 
amount effort required implement optimization correspondingly reduced 
similar reductions implementation effort optimizations prior sparse techniques similar choi apply techniques expression optimization problems 
motivation comes fact traditional data flow analysis bit vectors interface ssa form program representation 
def information encoded ssa converted bit vector form order apply bit vector algorithms 
process involves scanning contents basic block program initialize local data flow attributes bit vector form 
experience shown dense initialization data flow information takes time solution data flow equations 
transformation program put back ssa form subsequent ssa optimizations desired 
repeated updates ssa form due arbitrary modifications program add substantial compile time overhead choi 
contrast ssapre algorithm exploits built def information input ssa form intrinsically produces optimized output ssa form 
performs data flow propagation sparse graphs constructs 
entire program maintained valid ssa form ssapre iterates pre candidates 
rest organized follows 
section briefly reviews fundamentals ssa form presents factored redundancy graph frg forms basis sparse approach pre 
section describes ssapre algorithm detail stating related lemmas proofs 
section discusses theoretical aspects ssapre algorithm verifies correctness optimality 
section discusses practical issues related efficient effective implementation ssapre 
section compares contrasts steps ssapre bit vector pre analyzes complexity ssapre algorithm 
section provides measurement data compare implementation algorithm bit vector pre implementation characterize partial redundancy problems approach set benchmark programs 
section concludes discussing implications 
acm transactions programming languages systems vol 

somemonth 
delta robert kennedy 
ssa sparse pre background ssapre algorithm briefly define terms review characteristics ssa form discuss properties redundancy computations program 
define concept redundancy relation program computation factored redundancy graph frg represent relation 
briefly review connections ssa form classical definition relation program variable show frg redundancy relation share connections 
analogy ssa factored representation redundancy program foundation ssapre algorithm ability operate directly input program ssa form produce output directly ssa form 
control flow dominance assume code program optimized partitioned basic blocks property control may enter basic block may leave 
control flow graph basic blocks nodes edge block block control transfer directly loss generality assume program unique entry unique exit block block program lies path entry exit 
block said dominate block control flow path program entry encounters say strictly dominates dominates strictly dominates block control flow path strictly dominates say immediate dominator dominator tree abbreviated dt tree nodes basic blocks program root program entry block parent block block immediate dominator 
dominance frontier cytron block abbreviated df set blocks strictly dominated having predecessor dominated iterated dominance frontier cytron block abbreviated df smallest set blocks contains df fixed point pointwise application df delta 
ssa form section give brief review static single assignment ssa form program representation 
greater detail reader referred cytron 
definition 
program said ssa form variables defined exactly variable dominated variable definition 
definition strict programs nontrivial control flow require special consideration put ssa form 
say ssa form definition variable may assignment special operator denoted oe capture effects control flow 
presence assignment oe basic block means acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta exactly predecessors control flow graph operand oe variables program control arrives block th predecessor value important convention regarding oe operators purpose dominance relation uses definitions variables program operands oe regarded occurring ends corresponding predecessor blocks assignment oe result occurs block containing oe 
program control flow graph program put ssa form assigning unique version definition variable placing oe operators defining additional versions basic blocks reached multiple definitions original variable 
transformation version viewed variable right 
versions traditionally denoted applying subscripts name original program variable ssa versions variable denoted forth 
cytron gives efficient algorithm put program ssa form minimum number oe assignments 
remainder section discuss definition def relation connection ssa form 
def relation relation uses variables definitions assignments variables program 
graph representing relation edge leading variable reaching definition 
discussion explain ssa factored form def graph wolfe 
additional details connection ssa form def relation contained cytron 
defining factored def graph simplifying assumption definition killing definition fd dn set definitions reaching def edges dn basic block called oe block factoring point dominates paths contained node contained node final node node common cytron showed set oe blocks uses original program variable contained union iterated dominance frontiers blocks containing real definitions variable cytron 
control flow graph def relation variable define factored def graph follows nodes factored def graph uses definitions def relation plus oe node basic block oe block oe nodes represents oe assignment acm transactions programming languages systems vol 

somemonth 
delta robert kennedy collection oe operands oe block predecessor blocks 
edge factored def graph node representing including oe operands node representing immediate dominating definition may oe 
straightforward exercise verify factored def graph program variable equivalent minimal ssa form variable 
correspondence obvious ssa version variable ssa form corresponds edge factored def graph node corresponding node corresponding unique definition ssa version 
known easy check original def relation recovered factored def graph transitive closure discarding edges transitive closure oe oe operand endpoint 
foundation sparse pre section define terms outline basis framework analyze redundancy 
goal section show connections redundancy framework ssa form variables connections underlie intuition ssapre algorithm ability directly generate output ssa form 
convenience definitions assume basic block control flow graph program compiled reachable entry block program exit reachable basic block 
definition 
occurrences computation control flow path containing may alter value say redundant respect sparse approach pre relies representation directly expose partial redundancy representation derived discussion 
suppose occurrence redundant respect represent redundancy directed edge definition 
occurrence computation point program 
control flow path containing may alter value containing occurrence say exposed respect omega fe en set occurrences respect occurrence exposed redundant fa am set alterations value assignments operands expression respect exposed 
omega gamma block called phi block factoring point dominates paths recall oe operands viewed occurring ends corresponding predecessor blocks 
acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta contained node contained node final node node common take step formulating algorithm framework need additional definition definition 
say computation partially available point program control flow path leading real occurrence computation crossing may alter value computation 
say occurrence partially redundant occurrence computation partially available just 
way literature uses oe operator ssa form factor def relation variables paragraph introduce phi operator factors redundancy relation computation occurrences 
just oe operators viewed bona fide assignments variables ssa form regard instances factoring operator phi operands phi computation occurrences right term real occurrence distinguish occurrences computation correspond code program phi phi operand occurrences 
case oe operators operands view phi occurring block appears operands phi occurring ends corresponding predecessor blocks 
operands phi partially redundant counterpart ssa form denote symbol 
partially redundant real phi operand occurrence define representative occurrence nearest phi non real occurrences dominate reader easily verify representative occurrence defined unique 
control flow graph redundancy relation computation define factored redundancy graph frg follows nodes frg real occurrences redundancy relation plus phi node basic block phi block real occurrence upward edge frg partially redundant real occurrence partially redundant phi operand occurrence representative occurrence 
shows upward edges example frg factors edges redundancy relation 
reverse upward edge called downward edge 
set occurrences representative occurrence occurrences represents called redundancy class 
reader may think redundancy classes roughly analogous variable versions ssa form 
upward edges correspond def edges ssa edges factored def graph downward edges correspond def edges ssa 
underscore analogy say representative occurrence redundancy class defines class members 
clearly frg defined similarly factored def graph deal common ssa form 
example original redundancy relation recovered frg control flow graph way full def relation recovered ssa form 
see acm transactions programming languages systems vol 

somemonth 
delta robert kennedy ae ae ae gamma gamma psi theta theta theta theta theta bm factoring ae ae ae phi 
gamma gamma psi ak factored oe redundancy edge oe control flow edge fig 

factoring redundancy edges connections deeper analogy definitions properties particular frg computation connected closely ssa form computation temporary variable pre see section 
basics pre say computation available point program path path leading point computation occurs point property contains may alter value computation 
definition computation partially available exists path computation available computation fully available available path program entry say computation anticipated point path path computation occurs point property contains may alter value computation 
computation partially anticipated exists path computation anticipated computation fully anticipated anticipated path program exit 
computation fully anticipated say point safe respect computation knoop 
knoop term placement refer set points optimized program particular computation occurs 
say placement safe optimization introduced new values path program inserted computation occurs point computation fully anticipated fully available kennedy 
requirement intended prevent incorrect behavior optimized program presence computations may cause exceptions division zero 
safety considered fundamental requirement literature proposed methods eliminating partial redundancies adhere requirement morel renvoise chow drechsler dhamdhere dhamdhere knoop drechsler 
say placement computationally optimal safe placement result fewer occurrences computation path entry exit program 
computational optimality important requirement partial redundancy elimination acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta theta theta theta theta thetafl fully redundant gamma gamma gamma psi partially redundant pre theta theta theta theta thetafl fully redundant inserted gamma gamma gamma psi fully redundant insertion pre fig 

full partial redundancies early methods morel renvoise chow lacked property 
property achieved methods requiring insertion synthetic basic blocks certain control flow edges see section 
consider redundancies associated computation yields value procedure compiled 
occurrence fully redundant fully available just point occurrence program fully redundant computations safely removed simply deleting 
fully redundant occurrence 
occurrence partially redundant partially available just point occurrence 
partially redundant fully redundant occurrence 
eliminating strictly partial redundancies involves inserting new computations render occurrences fully redundant deleted 
shows larger example program ssa form optimum pre performed 
computations consideration expressions compute values program deleted occurrences replaced loads temporary variable introduced optimization 
ensure temporary contains correct value accessed optimized program value expression saved temporary subset points expression evaluated 
important practical concern register pressure result introducing temporaries 
address concern pre chow dhamdhere drechsler heuristic modifications system data flow equations introduced morel renvoise techniques directly morel renvoise achieved goal minimizing lifetimes introduced temporaries 
particular pre schemes perform code motion introduced unnecessary temporary removing redundancy examples 
lifetime optimality introduced temporary variables subject constraint computational optimality achieved knoop 
research achieves result includes drechsler 
algorithms framework morel renvoise harmful transformation example introduced blocks deleted block 
acm transactions programming languages systems vol 

somemonth 
delta robert kennedy central observation suppose computationally optimum pre performed replacing expression uses temporary variable places computations deleted 
central observation leading algorithm pre observation 
edge def relation corresponds directly redundancy edge redundancy edge introduced pre deleted occurrence inserted computation redundancy edges may correspond def edges temporary edge represents redundancy safely eliminated property expression value turns available head tail edge 
imagine task pre algorithm determining set redundancy edges expression refining edge sets form def relation expression temporary variable 
notice def relation expression temporary tells transform program points points replace computation expression temporary definition points places compute expression value save temporary 
closely connecting redundancy relation expression relation temporary variable introduced pre expression observation implicitly connects frg expression ssa form optimized expression temporary variable 
connection main property allowing algorithm efficiently produce output ssa form 
frg ssapre analysis performed ssapre algorithm operates frg expressions optimized algorithm incorporates method constructing frg 
frg representation shares characteristics ssa form method build frg closely parallels standard ssa construction algorithm 
steps ssapre algorithm construct frg operands phi indicating paths expression evaluated 
step called phi insertion inserts phi iterated dominance frontier occurrence second step called rename assign redundancy class numbers occurrences values compute positions program 
phi frg serve anchor points placement analysis pre 
placement analysis involves separate data flow analysis steps 
third step ssapre performs backward data flow propagation frg identify phi safe 
fourth step willbeavail performs forward data flow propagation graph predict phi computation available insertions pre 
data flow results fifth step finalize pinpoint locations program computation inserted 
finalize identifies occurrences fully redundant account effects insertions refines frg form isomorphic ssa graph point optimized output completely determined represented updated frg 
step acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta transforms code form optimized program 
temporary introduced save reuse values corresponding instances redundancy eliminated ssapre 
partial redundancy elimination optimizations treated choi choi algorithm cast sparse data flow evaluation graph framework 
frg expression flow graph terminology willbeavail steps ssapre examples class procedures call evaluations 

ssapre algorithm section describe ssapre algorithm 
authors earlier rosen dhamdhere knoop drechsler assume critical edges control flow graph removed inserting empty basic blocks edges 
breaking edges allows model insertions edge placements insert ends predecessor blocks 
idea inserting basic blocks critical edges expand opportunities safe code motion appears originated rosen possibly drechsler 
dhamdhere proposed related technique splitting edges demand 
assume input program ssa form 
assume prior computation dominator tree dt iterated dominance frontiers df respect control flow graph program 
structures computed program put ssa form algorithm cytron 
simplifying assumptions input ssa program oe assignment property left hand side operands versions original program variable live ranges different versions original program variable overlap 
assumptions guaranteed hold immediately program put ssa form cytron relaxed cost difficult presentation implementation algorithm 
interested reader invited investigate changes involved relaxing assumptions 
assume expressions represented trees leaves constants ssa renamed variables 
ssapre applied lexically identified expression independently regardless subtree nesting relationships 
section describe strategy exploits nesting relationship expression trees obtain greater optimization efficiency ssapre 
indirect loads candidates ssapre memory aliases critical edge tail block multiple successors head block multiple predecessors 
computations belong lexically identified expression apply exactly operator exactly operands ssa versions variables ignored identifying expressions 
example lexically identical forms instances lexically identified expression 
acm transactions programming languages systems vol 

somemonth 
delta robert kennedy oe oe exit oe oe oe oe exit optimization optimization fig 

example program ssa form optimization indirect variables ssa form order ssapre handle 
form chow allows ssapre uniformly handle indirect loads expressions program 
description base algorithm initial ssa construction steps expressions phi insertion rename expressions program simultaneously passing entire program 
remaining steps algorithm efficiently applied expression separately 
section describe alternative scheme allows steps algorithm applied lexically identified expression separately 
program shown running example illustrate various steps call program distinguish additional examples interspersed illustrate situations appear program examples assume working expression program 
presentation ssapre organized steps algorithm 
describe step state prove various lemmas establishing theorems ssapre section 
details ssapre establish items notation 
notation refer th lexically identified expression denote set phi operators frg expression omit simplicity compactness show control flow graphs examples critical edges examples chosen breaking edges material difference 
acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta oe phi delta delta fig 

phi insertion due oe expression operand index symbol confusion result steps ssapre referring handle single expression time understood refer current expression consideration 
phi insertion step phi expression needed different values expression reach common point program 
different situations cause phi expressions placed expression appears insert phi iterated dominance frontier df cytron occurrence may come correspond definition expression temporary 
second situation causes insertion phi oe variable contained expression oe indicates alteration expression reaches merge point 
phi block caused oe block turn reflects assignment block 
shows running example program phi insertion step 
phi justified real occurrences presence oe variable algorithms ssa oe placement linear time complexity place phi johnson sreedhar gao 
adapt algorithm cytron easier understand implement 
details lemma precise establish definition 
intuitively intended capture set points program current value expression may change 
definition 
evaluation expression real occurrence phi occurrence assignment operand acm transactions programming languages systems vol 

somemonth 
delta robert kennedy phi delta delta oe phi delta delta oe exit fig 

program phi insertion say evaluation reaches point program path control flow graph evaluation encounter evaluation distinguish assignments expression operands evaluations say assignments operands expression value 
lemma 
sufficiency phi insertion basic block phi inserted expression exactly evaluation reach entry proof 
suppose different evaluations expression reach entry case dominate suppose loss generality dominate exists block dominates reached lies df may 
real occurrence phi phi insertion step placed phi contradicting proposition reaches hand assignment operand expression values reaching oe correctness input ssa form 
phi insertion placed phi contradicting proposition reaches section describes efficient implementation omits phi operators promised lemma unnecessary participate optimization corresponding expressions partially anticipated omissions occur 
acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta rename step rename step assigns redundancy class numbers expression occurrences 
redundancy class numbering important properties 
occurrences identical class numbers identical values 
second control flow path includes different class numbers expression cross assignment operand expression phi 
apply ssa renaming algorithm cytron conduct preorder traversal dominator tree modification 
addition renaming stack variable program maintain renaming stack expression entries expression stacks popped dominator tree traversal backtracks past blocks contain 
maintaining variable expression stacks allows decide efficiently occurrences expression redundancy class number 
kinds occurrences expressions program occurrences original program call real occurrences phi inserted phi insertion step phi operands regarded occurring ends predecessor blocks corresponding edges 
rename algorithm performs steps encountering occurrence expression phi assign new class number 
check current version variable version top variable rename stack version corresponding variable occurrence top rename stack 
variable versions match assign class top stack record upward edge representative occurrence writing representative occurrence field def 
variable versions match cases real occurrence assign new class number phi operand assign special class phi operand denote value unavailable point 
push stack proceed 
shows initial graph formed example renamed 
nodes frg annotated assigned redundancy class numbers square brackets 
lemma 
correctness renaming occurrences expression assigned class rename expression value occurrences 
proof 
lemma follows directly fact rename step assigns occurrences expression class ssa versions expression operands match 
appeal single assignment property correctness ssa renaming algorithm variables cytron complete proof 
lemma 
assigned classes capture redundancy occurrences assigned class numbers rename exactly holds control flow path reach passing real non oe assignment operand expression meaning redundancy occurrences acm transactions programming languages systems vol 

somemonth 
delta robert kennedy 
phi oe 

phi oe 
exit 
initial frg upward edges shown fig 

initial frg program path possibly empty case upward edges frg representative class representative class implying redundancy exposed algorithm 
proof 
suppose control flow path pass assignment operand expression 
proof proceed induction number phi expression traversed encounters phi establishing basis induction 
hits phi phi defines apply induction hypothesis part corresponding operand phi 
save space prove object constructed phi insertion rename steps fulfills definition frg section 
leave proof straightforward exercise interested reader required establish correctness algorithm 
section describes detail implementation rename step derives greater efficiency thoroughly exploiting ssa form input program 
step criterion required pre insert computation computation safe anticipated point insertion kennedy morel renvoise knoop 
condition serves ensure inserted computations introduce exceptions paths lacked acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta phi phi exit fig 

propagation step optimization inserted computations introduce new redundancy program 
frg constructed rename node represents real occurrence expression phi 
shown ssapre insertions necessary phi safety needs computed points phi appear 
factored redundancy graph safety sparsely computed propagation upward edges 
phi safe control flow path phi expression evaluated program exit altered redefinition variables 
loops exit happen due cases path exit phi redundancy class occur path exit occurrence phi redundancy class operand phi safe 
case represents initialization backward propagation compute safety phi initially marked safe 
propagation case phi initially marked safe algorithm searches upward edges traverse real occurrence expression clearing safe flag phi visited 
traversing real occurrence expression blocks propagation algorithm assumes phi operand marked flag real true path phi operand representative occurrence crosses real occurrence class 
convenient perform initialization case safe computation real flags dominator tree preorder pass frg 
rename conducts pass include calculations rename step minimal overhead 
initially safe flags true real flags false 
rename assigns new class real occurrence expression sets operand phi encounters program acm transactions programming languages systems vol 

somemonth 
delta robert kennedy procedure reset real def phi return def safe return safe false operand reset 
reset procedure safe operand reset 
fig 

algorithm exit examines occurrence top stack pushing current occurrence 
top stack phi occurrence rename clears phi safe flag class represents occur path current occurrence exit 
rename assigns class phi operand sets operand real flag real occurrence class appears top rename stack 
example phi block marked safe initialization rename step 
step propagates false value safe phi block upward edge appearance class operand phi block definition phi block 
gives propagation algorithm 
running example program phi safe 
lemma 
correctness safe phi marked safe expression fully anticipated phi 
proof 
note phi marked safe rename safe 
ssa renaming algorithm property definition dominates uses 
suppose phi appears top stack rename creates new class real occurrence phi operand encounters program exit 
case program exit encountered phi obviously safe path dominator tree phi exit containing phi 
similarly rename assigns new class real occurrence expression operand different version current occurrence version phi 
exists path dominator tree phi current occurrence assignment lemma assignment real assignment oe 
expression fully anticipated phi top stack 
observation phi safe flag gets cleared step safe path upward edges acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta frg phi safe edge path crosses real expression value 
path appears recursion stack reset procedure time safe flag cleared 
need show phi safe marked 
fact straightforward property depth search propagation performed reset 
willbeavail step willbeavail step task predicting expression available phi occurrence insertions pre 
finalize step insertions performed incoming edges corresponding phi operands expression available insertion phi avail predicate true 
willbeavail begins computing set phi occurrences expression value safely available 
willbeavail effectively computes set phi expression value available computationally optimal placement exactly phi expression available ssapre resulting placement minimizes live ranges introduced expression temporary 
willbeavail step consists forward propagation passes performed sequentially conduct simple reachability search frg expression 
pass computes avail predicate phi initializing true phi 
begins boundary set phi expression available safe set insertions 
phi satisfy safe predicate valued operand 
avail predicate set false phi false value propagated nodes safe reachable downward frg edges excluding edges real true 
propagation step avail false phi safe placement computations expression available 
phi avail true designate range safe program areas insertion expression plus areas safe expression fully available original program 
second pass works region computed pass determine phi expression available insertions implicitly determines latest final insertion points 
pass computes information responsible minimizing live ranges introduced expression temporary analogous computation predicate drechsler 
works propagating predicate initializes true avail true 
begins phi operands corresponding real occurrences expression program propagates false value forward points insertions postponed moved downward introducing entry points region valued phi operands thought ssapre earliest insertion points 
may earliest insertion points knoop drechsler bit vector schemes allow earliest insertion non merge blocks 
acm transactions programming languages systems vol 

somemonth 
delta robert kennedy phi oe phi exit fig 

example showing role unnecessary new redundancy 
second pass avail phi avail avail example program phi block satisfies safe avail 
expression value safely available insertions blocks predicate prevents insertion eliminate redundancy unnecessarily extend live range expression temporary 
running example phi satisfy avail 
convenience define predicate indicate phi operands perform insertions say insert holds phi operand hold phi satisfies avail operand real false operand operand defined phi satisfy avail 
gives willbeavail propagation algorithms 
recall term placement refers set points program particular expression value computed 
lemma 
correctness avail phi satisfies avail safe placement computations expression available immediately result phi satisfying exactly avail reachable real occurrence downward frg edges 
acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta procedure reset avail avail false operand def 
real safe avail reset avail reset avail procedure compute avail program avail true program safe avail operand reset avail compute avail procedure reset false operand def 
reset reset procedure compute avail operand def 
real reset compute procedure willbeavail compute avail compute willbeavail fig 

algorithm willbeavail phi 
proof 
phi satisfying avail 
satisfies safe result immediate safe insert computations expression operands 
safe satisfies avail note expression available unoptimized program path phi valued operand downward edges lacking real frg 
phi satisfy avail 
algorithm reset avail flag recursion stack reset avail gave path bearing witness fact safe set insertions expression available acm transactions programming languages systems vol 

somemonth 
delta robert kennedy lemma 
correctness avail phi satisfies willbeavail exists computationally optimal placement expression value available immediately phi 
proof 
inspection compute algorithm set avail phi satisfying willbeavail exactly set avail phi reachable downward edges frg avail phi operand satisfying real 
path downward edges frg avail phi operand satisfying real false avail true 
prove induction length available computationally optimal placement 
safe fact avail means operands fully available unoptimized program 
trivially available computationally optimal placement making result available 
case safe contains edges real operand operand fully available optimized program insertion redundant respect real occurrence corresponding operand contradicting computational optimality 
safe exist real occurrences unoptimized program redundant respect real occurrences corresponding operand computationally optimal placement eliminate redundancy 
way accomplish perform insertions expression fully available safe contains edge apply induction hypothesis phi defining operand corresponding final edge conclude operand available computationally optimal placement 
consequence computationally optimal placement available argument basis step previous paragraph 
lemma shows avail predicate computed willbeavail faithfully corresponds availability program insertions performed phi operands satisfying insert 
lemma 
correctness avail union set insertions chosen ssapre set real occurrences expression available immediately phi phi satisfies avail 
proof 
establish direction simple induction proof showing path leading particular phi optimized program expression unavailable phi satisfy avail 
proposition path downward edges frg passing phi edges satisfy real insert avail 
follows directly fact valued operand insertion performed operand marked avail 
fact acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta valued operand implies insertion required available 
see notice gamma implies operand corresponding final edge defined phi avail real occurrence expression control flow path defining phi operand perform insertion operand satisfy avail 
establish direction suppose satisfy avail 
satisfy avail satisfies 
case available optimized program insertions performed ssapre safe 
case processed reset meaning reachable downward edges phi satisfying avail 
insertion required result available avail algorithm performs insertion 
finalize step finalize step plays role transforming factored redundancy graph optimized form reflects insertions phi operand 
finalize step consists parts finalize finalize 
finalize performs tasks real occurrence expression marked flag called reload indicate computed spot reloaded temporary 
phi avail true insertions performed incoming edges correspond phi operands expression available 
phi avail predicate true may oe phi avail part ssa form frg edges avail phi updated refer real inserted occurrences 
frg structure updated reflect factored def relation expression temporary optimized program 
restructuring accomplished resetting def field operand phi satisfying avail real occurrence reloaded temporary def fields refer expression occurrences definitions corresponding ssa versions temporary 
tasks responsibility finalize real occurrence reloaded temporary marked save flag expression value saved temporary 
extraneous phi removed 
finalize creates table avail def available definitions perform tasks 
indices table redundancy class numbers current expression 
avail def point expression occurrence defines value occurrences redundancy class reload class seen 
defining occurrence real occurrence phi avail true 
finalize performs preorder traversal acm transactions programming languages systems vol 

somemonth 
delta robert kennedy oe phi fig 

example showing available definitions redundancy class dominator tree program control flow graph 
course traversal visit representative occurrence value saved version temporary visits occurrences redundant computation replaced reload class phi operand oe operand 
processing order finalize modeled standard ssa rename step cytron finalize require renaming stack ssa versions assigned limited changes needed 
initially entries avail def 
course traversal finalize process occurrences follows phi avail false needs done phi ssa form real temporary 
visiting class time set avail def phi 
real occurrence avail def encountering time point value occurrences class available 
avail def set occurrence dominate current occurrence current occurrence definition class shows situation arise phi block satisfy avail branch phi class number available definition store expression temporary 
class represented phi correspond different versions expression temporary example 
avail def occurrence dominate current occurrence update avail def current occurrence 
current occurrence available value class set reload flag record value avail def def 
operand phi successor block avail phi false recall phi operands considered occurring corresponding predecessor blocks 
acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta procedure finalize redundancy class current expression avail def occurrence current expression preorder dt traversal order class phi occurrence avail avail def real occurrence avail def avail def dominate reload false avail def reload true def avail def phi operand occurrence phi successor block operand avail satisfies insert insert current expression block containing def inserted occurrence def avail def finalize fig 

algorithm part finalize needs done 
operand satisfies insert insert computation current expression current block set def refer inserted computation 
satisfy insert set def refer current available definition redundancy class full algorithm finalize 
determine real occurrences saved temporary finalize performs backward search frg 
search begins set real occurrences marked reload progresses backward upward edges def field reloaded real occurrence set finalize visit finalize 
real occurrence defines phi operand real occurrence encountered search computed saved temporary save flag occurrence set 
removal extraneous phi frg minimization necessary task far pre concerned 
extraneous phi take space program representation may affect efficiency ssa optimizations applied pre 
removing extraneous phi requires changing occurrences acm transactions programming languages systems vol 

somemonth 
delta robert kennedy procedure set save real occurrence save true phi occurrence operand processed set save def real inserted avail phi appearing df extraneous false set save procedure set replacement replacing def avail th operand defined extraneous set replacement replacing def replace th operand replacing def real occurrence satisfying reload def def replacing def gamma fgg set replacement procedure finalize satisfying avail extraneous true real occurrence save false operand processed 
false real occurrence satisfying reload set save def satisfies avail extraneous operand def 
phi extraneous def def 
real def 
inserted set replacement def gamma ffg finalize fig 

algorithm second part finalize redundancy class refer different class defines value phi 
frg minimization implemented variant oe insertion step ssa construction cytron johnson sreedhar gao 
initially mark phi extraneous 
applying oe insertion algorithm find mark phi extraneous iterated dominance frontier set real occurrences save flag set plus inserted computations 
pass extraneous phi determine acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta phi phi exit phi exit finalize finalize fig 

effect frg minimization replacing class 
extraneous phi represents redundancy class operand redundancy class defined extraneous phi replacing class phi propagate replacing class downward edges replacing class phi known replacing class occurrence defined phi known replacing class occurrence replacing class phi 
see 
straightforward see method correctly replaces extraneous phi non extraneous occurrences 
effect frg minimization finalize step seen algorithm discovered value block reloaded expression temporary phi block extraneous 
shows form program frg minimization removes extraneous phi updates real occurrence block referred 
shows example program finalize step 
new classes introduced defined inserted computations blocks respectively real occurrences original program reloaded temporary 
lemma 
correctness save reload point reload temporary contains value expression 
proof 
lemma follows directly finalize algorithm fact rename assigns redundancy classes occurrences traversing frg dominator tree preorder 
particular finalize ensures directly reload dominated available definition 
live ranges different redundancy classes overlap reloaded occurrence refer available definition 
acm transactions programming languages systems vol 

somemonth 
delta robert kennedy 
phi oe 

phi oe 
exit 
final frg upward edges shown fig 

program finalize lemma 
optimality reload optimized program compute expression point fully available 
proof 
straightforward check optimized program reloads expression value occurrence defined phi satisfying avail reloads expression value occurrence dominated real occurrence class 
need note avail accurately reflects availability optimized program lemma definition insert insert phi operands insertion required achieve availability 
step factored redundancy graph processed finalize remaining task update ssa program representation reflect results pre 
involves introducing expression temporary purpose eliminating redundant computations 
step walks frg dominator tree preorder 
real occurrence save true generates save result computation new version phi operand occurrences real occurrences reload flag set replaces computation ssa version determined version assigned occurrence representative occurrence 
inserted occurrence saves value inserted computation new acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta oe oe oe oe exit fig 

program version phi generates corresponding oe shows running example program step 

theoretical results section derive main results ssapre lemmas 
theorem 
ssapre chooses safe placement computations path entry exit exactly values computed optimized program original program 
proof 
insertions take place points satisfying safe theorem follows directly lemma 
theorem 
ssapre generates reload correct expression value temporary real occurrence point expression value available point optimized program 
proof 
theorem follows fact reload generated real occurence dominated avail phi class case appeal lemma availability expression reload point real occurrence class marked save finalize 
theorem 
ssapre generates save temporary real occurrence insertion point hold acm transactions programming languages systems vol 

somemonth 
delta robert kennedy expression value unavailable optimized program just point expression value partially anticipated just point saved value 
proof 
theorem follows directly lemma fact finalize algorithm sets save flag real occurrence control flow path occurrence occurrence reload flag set intervening save 
theorem 
ssapre chooses computationally optimal placement safe placement result fewer evaluations expression path entry exit control flow graph 
proof 
need show redundancy remaining optimized program eliminated safe placement computations 
suppose control flow path optimized program leading computation expression computation expression assignment operand expression theorem expression value available just dominated real occurrence class lemma defined avail phi lemma 
assignment expression operand definition class lie real occurrence avail phi phi avail 
phi satisfy operands reached safe 
safe set insertions available eliminating computation theorem 
ssapre chooses lifetime optimal placement specifically point just insertion ssapre denotes computationally optimal placement expression fully available proof 
theorem direct consequence lemma theorem 
theorem 
ssapre produces minimal ssa form generated temporary 
proof 
minimality result follows directly correctness minimality dominance frontier oe insertion algorithm cytron 
phi remaining finalize justified iterated dominance frontier real inserted occurrence saved temporary 

practical implementation section discuss issues related efficient practical implementation ssapre optimizing compiler 
implementation take advantage sparse approach dramatically reducing maximum storage needed optimize expressions program 
accomplished maintaining worklist contains different lexically identified expressions await processing ssapre 
absence redundancy exploit nesting relationship expression trees avoid unnecessary ancestral part tree 
efficient forms algorithms phi insertion rename computation save finalize step versions section 
acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta worklist driven pre algorithms section phi insertion rename expressions program simultaneously passing entire program 
handling expressions creates overhead memory usage phi expressions program need represented renaming stacks expressions coexist rename step 
details issue representing frg expression explicit section 
worklist driven pre approach addresses issues 
worklist driven approach manage lexically identified expressions need worked pre worklist 
add initial pass collect occurrences scans program create initial worklist 
lexically identified expression represent occurrences program set occurrence nodes 
occurrence node provides information pinpoint location occurrence program 
collect occurrences pass needs look entire program 
steps ssapre operate lexically identified expression occurrence nodes 
applying steps ssapre lexically identified expression individually decouple pre expression treatment expressions 
intermediate storage allocated optimizing expression recycled optimizing expression 
total memory working set size needed perform pre expressions program substantially reduced 
scheme allows parallel invocation pre different lexically identified expressions parallel processing facilities available 
occurrence nodes created collect occurrences called real occurrence nodes correspond occurrences expression input program 
kinds occurrence nodes represented steps ssapre 
real occurrence nodes phi insertion creates phi occurrence nodes represent phi inserts 
phi occurrence nodes creates phi predecessor occurrence nodes block predecessor block containing phi 
phi predecessor occurrences serve place holders phi operands operands regarded occurring predecessors block containing phi 
represent factored redundancy graph occurrence node class field storing redundancy class number assigned 
phi predecessor node real occurrence node represents representative class def field points representative occurrence redundancy class fields represent upward edges factored redundancy graph 
phi occurrence nodes phi operands result provided 
separately exit occurrence nodes indicating reach point program exit 
rename step initializing safe flag 
remaining steps ssapre need visit occurrence nodes order corresponding preorder traversal dominator tree dt control flow graph maintain sequence occurrence nodes sorted order 
precompute depth number dfn number descendents acm transactions programming languages systems vol 

somemonth 
delta robert kennedy 
des node dt 
basic blocks determine dominates formula dominate dfn dfn dfn des walk sequence basic blocks dominator tree preorder dominate true indicates descending dt 
dominate false alerts need take appropriate action due fact backtracking dt case rename necessary pop renaming stack version top stack defined block dominates observations allow walk occurrence list dominator tree preorder recursive descent dominator tree 
nested expressions optimizing expression time allows exploit absence redundancy nested expression trees speeding ssapre 
definition explain mean definition 
compound expression expression consists operator operates results additional operators expression 
example expression gamma compound consists gamma operator operates result contrast simple expression 
pre needs applied operations compound expression may exhibit redundancy 
prior approaches pre bit vectors typically assign separate bit vector slot operation compound expression apply pre expressions encoded bit vectors simultaneously 
take advantage important observation regarding redundancies compound expressions observation 
redundancy exists compound expression redundancy exists operators expression 
conversely simple expression exhibit redundancy compound expression contains simple expression exhibits redundancy 
example redundancy exists gamma redundancy exist exhibit redundancy gamma exhibit redundancy 
redundancy inference drawn regarding redundancy gamma operation gamma consequence theorems elimination redundancy results converting expression temporary observation leads strategy dealing optimization compound expressions 
strategy defer pre compound expressions converted simple expressions redundancy elimination constituent expressions 
worklist driven approach implies simple expressions allowed worklist 
optimizations proceed simple expressions converted temporaries turn causes compound expressions simple expressions 
new simple expressions formed entered worklist 
example gamma simple expression entered worklist collect occurrences 
ssapre worked redundant acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta input program collect occurrences initial worklist expr 
phi insertion rename initial ssa graph willbeavail finalize final ssa graph update add new exprs worklist 
output program fig 

ssapre implementation flow chart occurrence replaced temporary pre converts gamma gamma new simple expression formed step entered new member worklist 
redundancies gamma redundancies gamma eliminated ssapre processes gamma expression gamma yield gamma processed gamma remain compound expression processed ssapre 
absence redundancy ssapre terminates quickly skip processing compound expressions 
presence redundancies approach secondary effect converting evaluation compound expressions essentially triplet form result simple expression saved temporary operand evaluation simple expression 
effect undesirable compound expressions reconstructed performing copy propagation temporaries locally occurring 
copy propagation temporaries eliminated dead store elimination 
usual case program eventually translated machine instructions triplet form poses obstacle target architectures 
strategy deals cleanly interaction optimizations nested expressions speeding optimization skipping compound expressions exhibit redundancy 
strategy hard implement bit vector acm transactions programming languages systems vol 

somemonth 
delta robert kennedy pre typically works expressions program simultaneously take advantage parallelism possible bit vector operations 
ssapre deal simple expressions implementation simplified 
shows flow chart implementation ssapre worklists incorporates strategy dealing compound expressions 
demand driven phi insertion phi insertion algorithm section sparse insert phi due variable assignments alter occurrence corresponding expression 
particular need insert phi merge point reaches occurrence expression expression partially anticipated merge point phi contribute optimization pre need correspond oe final ssa form expression real temporary 
section technique substantially reduces number unnecessary phi inserted 
resulting algorithm sparse sense phi inserted justified appearing iterated dominance frontier real occurrence expression appearing point expression partially anticipated 
recall section phi placed iterated dominance frontiers real occurrences expression assignments operands expression points necessarily contain combined iterated dominance frontiers set assignments real expression temporary 
sparse phi insertion algorithm types phi insertions performed pass program second type phi insertion performed demand driven way 
set df phis keep track phi inserted iterated dominance frontiers occurrences expression set var phis keep track phi inserted due occurrence oe th variable expression come occurrence expression update df phis 
variable occurrence check defined oe 
update var phis phi block contains oe may participate optimization current occurrence may apply earlier points program necessary check recursively updates var phis operand oe occurrences program processed places insert phi union df phis var phis 
full algorithm phi insertion step 
demand driven technique take advantage ssa representation input program 
lemma replaces lemma demand driven context 
lemma 
sufficiency phi insertion basic block phi inserted expression partially anticipated entry exactly evaluation expression reach entry proof 
suppose different evaluations expression reach entry case dominate suppose loss generality dominate exists block dominates reached lies df may acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta procedure set var phis phi phi var phis var phis var phis containing phig operand phi defined oe set var phis phi set var phis procedure phi insertion expression df phis fg variable var phis fg occurrence program df phis df phis df variable ssa variable th position defined oe set var phis phi expression variable df phis df phis var phis insert phi df phis phi insertion fig 

algorithm demand driven phi insertion 
real occurrence phi phi insertion step placed phi contradicting proposition reaches hand assignment operand expression values reaching oe correctness input ssa form 
phi insertion processed expression occurrence responsible partial anticipation placed phi contradicting proposition reaches delayed renaming rename algorithm described section maintains version stacks variables program addition redundancy class stacks expressions 
apart additional storage updating variable version stacks requires keeping track changes values expressions variables 
versions variables may appear pre candidate expression algorithm sparse 
goal worklist driven approach able perform steps ssapre solely occurrence nodes desire rename algorithm perform job passing entire program 
describe delayed renaming technique efficient version rename step ssapre 
acm transactions programming languages systems vol 

somemonth 
delta robert kennedy defining top current condition assigning applying stack occurrence occurrence class number phase case real real corresponding variables rename case real phi operand ssa versions rename case phi real definitions rename case phi phi operand variables dominate rename table assigning class numbers rename discussing greater detail redundancy class numbers assigned method section 
rename step maintains redundancy class stack time top stack gives class number corresponding defining occurrence node assigned expression preorder traversal dt 
phi defines new class question assign new class numbers applies real occurrences phi operands 
plus fact defining occurrence top stack correspond real occurrence phi leads different situations arise situations shown table real occurrence expression phi operand class number top expression renaming stack versions variables occurrence match current versions renaming stacks variables 
decision question assign new class number sole purpose variable stacks rename algorithm section 
defining occurrence top expression renaming stack phi versions variables phi provided phi occurrence node 
situation corresponds cases table cases rename uses different method determining current version variable matches version variable phi occurrence expression 
basic block containing phi location current occurrence expression 
suppose considering variable expression 
assignment defines current version definition ssa dominates ae denote dominance relation ae maintenance expression renaming stack preorder traversal dt ae ae ae ae ae ae implies version different version ae implies version version ae necessary sufficient condition version condition cases table 
respectively phi oe basic block say dominates 
variable stacks unnecessary cases variable versions explicitly expressions rely variable stacks find current versions variables expression 
cases difficulty renaming phi operand real occurrence expression available provide current versions variables 
solve problem delayed renaming strategy split rename step separate passes 
pass rename rename minus maintenance variable stacks 
renaming acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta procedure assign new class occ class occ count push occ stack count count assign new class procedure rename count stack empty set rename fg occurrence current expression preorder dt traversal order top stack dominate pop stack phi occurrence assign new class real occurrence stack empty assign new class top stack real occurrence corresponding variables ssa version class class def assign new class phi occurrence definitions variables dominate class class def set rename set rename fy assign new class phi operand occurrence stack empty def top stack class class def rename fig 

algorithm rename phi operand cases applying method shown table rename optimistically assumes version version top expression version stack 
note assumption correct operand 
class number right 
rename performs solely occurrence nodes expression expression version stack maintains visiting occurrence nodes 
rename encounters real occurrence expression defined phi adds real occurrence set builds second pass 
acm transactions programming languages systems vol 

somemonth 
delta robert kennedy function oe opnd res block containing phi defines copy variable defined oe replace th operand oe return oe opnd res procedure rename operand processed 
false set rename empty remove real occurrence set rename phi defines operand processed index oe opnd res def 
assigned rename real occurrence corresponding variables ssa version change needed def 
phi occurrence definitions variables dominate change needed set rename set rename fy def 
processed 
true rename fig 

algorithm rename algorithm rename 
graph built rename optimistic sense presumes redundancy may 
final renaming phi operands delayed second pass rename 
rename works set built rename contains real occurrences defined phi 
real occurrence provides current versions variables phi 
version variable phi rename determines version variable predecessor block presence absence oe variable merge block function oe opnd res 
algorithm applies methods cases table defining occurrence retrieved upward edge frg top expression renaming stack 
phi operand assigned acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta phi oe phi phi oe phi rename rename fig 

operation delayed renaming rename correct rename resets 
phi operand correct defined phi rename manufactures real occurrence node containing versions variables phi operand adds manufactured occurrence set recursively ensure verification variable versions operands defining phi 
example rename sets operands phi block refer class phi representing class block appears top expression renaming stack operands encountered 
rename places block real occurrence set occurrences processing rename class represented phi 
rename processes real occurrence algorithm discovers class correct operand phi representing class 
determination follows current versions expression variables block phi operand occurs operand oe block version appears real occurrence oe block 
algorithm concludes class correct phi operand definitions dominate representative occurrence class 
concluding operand correct algorithm builds expression viewed occurring block enters occurrence set occurrences processed 
second phi operand block algorithm discovers definition current version block dominate phi represents class 
second operand block phi reset 
delayed renaming relies seeing real occurrence expression determine versions variables phi phi operands 
real occurrence seen expression partially anticipated phi 
acm transactions programming languages systems vol 

somemonth 
delta robert kennedy efficient eliminate dead phi early process building frg see section 
phi expression partially anticipated guaranteed dead final ssa form expression temporary delayed renaming algorithm incorporates additional function determining phi live 
delayed renaming task require dead store elimination pass 
efficient save computation finalize recall section order compute save predicate real occurrence finalize algorithm searches upward edges frg real occurrences satisfying reload sets save real occurrence encounters available definition 
ways implementor reduce cost save computation 
technique observation real occurrence available definition real occurrence operand phi satisfying avail safe saved temporary 
real occurrences recognized processing phi operands part finalize save predicates set time 
remaining save predicates established graph search second part finalize search restricted phi satisfy avail safe 
demand driven phi insertion delayed renaming number phi quite small benefit approach compilation time may noticeable 
second technique practice set save predicate relies observation target architectures generating intermediate code saves expression result temporary cost expression results computed registers level machine code anyway 
consequently implementor feel worthwhile dispense entirely graph search determine save predicate replace simple heuristic sets save real occurrence available definition real occurrence operand phi satisfies avail 
heuristic clearly sets save occurrence saved may set save 
main disadvantage heuristic setting save unnecessarily final ssa form expression temporary non minimal 

analysis formulation optimal code motion algorithm ssapre selfcontained gain additional insight comparing ssapre implementation lazy code motion 
regard phi insertion rename steps construct factored redundancy graph corresponding initialization data flow information steps faster ssapre take full advantage ssa form input program 
safety corresponds attribute lazy code motion correlation part involves forward propagation data flow information direct 
shown algorithm yields results lazy code motion quite plausible forward propagation parts ssapre implementation lazy code motion proven essentially equivalent 
acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta analysis propagates respect control flow graph ssapre propagates respect sparse ssa graph propagation ssapre take fewer steps 
effect heightened tendency set save set replacement searches limit sections graph considered subsequent steps 
factored redundancy graph allows ssapre maintain generated temporary easily ssa form 
complexities various steps ssapre easily established 
assuming implementation described section rename willbeavail finalize steps linear respect sum number nodes edges frg 
phi insertion step omega gamma insertion domination frontiers explained section linear time ssa oe placement algorithms lower 
second kind phi insertion due variable oe linear demand driven algorithm 
program size ssapre total time number edges nodes control flow graph respectively 
pleasing ssapre replaces solution data flow equations initialization local data flow attributes bit vector pre 

measurements section repeat compile time performance measurements specint specfp benchmark suites chow related discussion contrasting compilation efficiencies bit vector implementation pre implementation ssapre 
offer perspective compilation efficiency ssapre presenting statistical data characterize partial redundancy problems benchmark suites 
statistics generated optimizer component silicon graphics compiler suite 
intraprocedural global optimizer uses ssa internal program representation performing optimizations liu chow kennedy lo 
ssapre phase incorporates practical implementation techniques described section 
measurements benchmarks compiled optimization level intraprocedural analyses optimizations performed 
implementation ssapre incorporates additional functionalities strength reduction linear function test replacement described kennedy 
suppressed extra optimizations collecting statistics results reflect effects partial redundancy elimination 
remainder section discuss sets statistical data 
section compare time spent performing pre bitvector implementation implementation ssapre 
section measure fraction expressions require full processing ssapre 
section estimate degree sparseness achieved ssapre measuring size frg divided size control flow graph 
section provide statistics pre problems benchmarks results applying pre 
acm transactions programming languages systems vol 

somemonth 
delta robert kennedy benchmark bit vector pre ssapre ratio go ksim gcc compress li ijpeg perl vortex table ii 
time msec 
spent pre compiling specint benchmark bit vector pre ssapre ratio tomcatv swim su cor hydro mgrid applu turb apsi fpppp wave table iii 
time msec 
spent pre compiling specfp optimization time measurements optimizer uses variant ssa called internal program representation chow 
prior ssapre implementation version compilers optimizer bit vector morel renvoise algorithm chow perform pre known algorithms optimizations 
section compare performance ssapre bit vector implementation specint specfp benchmark suites 
measured running time optimized benchmark code differences implementations pre noticeable 
interested comparing optimization efficiencies sparse approach bit vector approach 
implementations pre ssa representation program 
bit vector pre starts determining local attributes setting bit vectors data flow analyses 
bit vectors represented arrays bit words operations efficient 
bit vector pre update ssa representation program encodes effects pre bit vector form ready emit output program non ssa representation 
timing bit vector pre includes local attributes phase solution time pre data flow equations 
correspondingly omit step ssapre timing include collect occurrences pass ssapre acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta steps 
tables ii iii give timing results measured mhz silicon graphics power challenge 
measurements tables ii iii show widely different results various benchmarks 
specint benchmarks ssapre uses time bit vector approach perl go 
specfp benchmarks ssapre usually slower times case mgrid 
examining sizes characteristics benchmark procedures detail characterize measurement results situations ssapre implementation superior bit vector implementation 
see efficiency sparse implementation stands mainly large procedures 
small procedures sparse graph simpler control flow graph harder beat performance bit vectors process expressions time 
advantage sparse implementations increases procedure size 
large procedures expressions appear procedure sparse representations smaller compared control flow graph 
despite strong bias bit vector pre faster set measurements think ssapre promising 
time complexity collecting local attributes omega gamma 
number techniques contribute speeding bit vector data flow analysis little promise overcoming cubic complexity local attribute collection bit vector approach 
data flow analyses sped time spent collecting local attributes come dominate bit vector pre spends time local attributes collection phase optimizing benchmarks 
cubic complexity optimization efficiency issue large procedures 
trend inlining compilation large procedures commonplace efficiency advantages sparse implementation obvious 
expression candidates section show implementation scheme ssapre avoids working compound expression pre converted simple expression 
scheme observation simple expression exhibits redundancy compound expression contains exhibits redundancy 
scheme relies fact compound expression redundancy component expressions eventually converted temporaries causing expression simple expression 
tables iv column gives number program units benchmark 
benchmark count number lexically identified expressions program unit sum program units benchmark 
total represents number pre problems benchmark shown column column shows number expressions simple expressions converted simple expressions ssapre represents number lexically identified expressions ssapre 
column shows scheme exploiting absence redundancy nested expression trees ssapre process pre candidates traditional pre schemes handle 
acm transactions programming languages systems vol 

somemonth 
delta robert kennedy benchmark program total simple exprs units exprs exprs bypassed go ksim gcc compress li ijpeg perl vortex average table iv 
lexically identified expressions specint benchmark program total simple exprs units exprs exprs bypassed tomcatv swim su cor hydro mgrid applu turb apsi fpppp wave average table lexically identified expressions specfp way take advantage expression processing mode speeding pre detect problem trivial answer 
find pre candidates occur entire program unit occurrence result insertion phi conclude pre opportunity expression 
phi insertion step check phi inserted inserted expression occurs program unit bypass rest ssapre steps 
method allows number pre candidates require full processing ssapre reduced 
column tables iv shows total number expressions benchmark require full processing ssapre application check bypassing 
column shows combining schemes ssapre fully process half original pre candidates 
rest measurements fully processed expression candidates 
density define density quotient size ssa graph formed ssapre size control flow graph program unit 
low value acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta average benchmark benchmark nodes edges density go ksim gcc compress li ijpeg perl vortex average table vi 
density pre problems specint average benchmark benchmark nodes edges density tomcatv swim su cor hydro mgrid applu turb apsi fpppp wave average table vii 
density pre problems specfp density implies frg simpler control flow graph sparse approach greater speed advantage compared solution method control flow graph 
compute size graph number nodes plus number edges 
factored redundancy graphs nodes real occurrences phi 
number edges frg equal number real occurrences reuse existing class number assigned new class number plus number phi operands entire ssa graph 
perform measurement rename delayed renaming algorithm frg representation largest 
pre candidate perform measurements compute density frg 
average data pre candidates benchmark 
tables vi vii show results specint specfp benchmarks respectively 
columns give average number nodes edges respectively factored redundancy graphs pre candidates benchmark 
column gives average density benchmark 
average density ranges exception fpppp shows density 
fpppp density skewed routine fpppp average density routine fpppp single basic acm transactions programming languages systems vol 

somemonth 
delta robert kennedy benchmark real phi insertions deletions go ksim gcc compress li ijpeg perl vortex average table viii 
average factored redundancy graphs specint benchmark real phi insertions deletions tomcatv swim su cor hydro mgrid applu turb apsi fpppp wave average table ix 
average factored redundancy graphs specfp block contains hundreds expression occurrences 
specint benchmarks average density 
specfp benchmarks excluding fpppp average density 
lower density specint benchmarks accounts observation section ssapre compile time performance relative bit vector pre implementation better specint specfp 
pre opportunities characterize pre problems counting number real occurrences phi frg 
opportunities pre represented number insertions deletions performed 
perform measurements frg average pre candidates benchmark 
columns tables viii ix show data specint specfp benchmarks respectively 
additional columns show ratios percent phi insertions deletions real occurrences 
factored redundancy graphs specfp benchmarks real occurrences specint benchmarks benchmark suites generate similar numbers phi expression 
deletions specfp benchmarks specint benchmarks average real occurrences deleted specfp deleted acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta specint 
contrast insertions quite rare insertion factored redundancy graphs specfp benchmarks 
shows majority deletions due full partial redundancy 
li shows exceptionally low deletion percentage 
table iv li lexically identified expressions distributed program units 
translates expressions program unit expressions require full processing ssapre 
low density expressions requiring full processing atypical may related low incidence redundancy li 
number deletions shown tables viii ix confirms importance pre optimizing compilers 

sparse approach problem redundancy elimination factored representation redundancy relations expressions program 
factoring relevant control flow merge points essential exposing partial redundancies observation highlights time close relationship pre ssa form 
data flow analyses pre focused locations factoring operator phi 
ssapre framework capitalizes prior techniques computing manipulating ssa form 
ssapre depends input program ssa form maximum efficiency intrinsically produces output ssa form 
ssapre enables pre seamlessly integrated global optimizer uses ssa internal representation 
implemented ssapre redundancy elimination framework version compilers gained valuable practical experience empirical insight redundancy characteristics broad cross section real programs 
previous uses ssa directed problems related variables 
ssapre represents ssa solve data flow problems related expressions program 
opens possibility solve data flow problems representing form factored dependency edges performing data flow analyses resulting sparse graph 
lo applied approach performing load store placement optimizations 
candidate optimizations framework code hoisting register shrink wrapping chow live range shrinking 
pre traditionally provided context integrating additional optimizations framework optimization operator strength reduction joshi dhamdhere chow dhamdhere knoop dhamdhere 
kennedy techniques allow strength reduction linear function test replacement performed ssapre framework 
lo techniques incorporate speculative code motion ssapre framework including execution profile data improve code placement accomplished pre speculation 
combining optimizations permits synergy effects results exceed expectations 
acm transactions programming languages systems vol 

somemonth 
delta robert kennedy notation conventions section offer table symbols terse definition pointer section item defined explained detail 
notation english term detail see dt dominator tree section page 
df dominance frontier section page 
df iterated dominance frontier section page 
oe ssa factoring operator section page ssa version variable section phi redundancy factoring operator section page non partially redundant operand phi section page arbitrary computation expression section particular occurrence computation section th lexically identified expression section page expression temporary section expression evaluation definition page set phi current expression section page arbitrary expression operand lemmas authors rune dahl anonymous referees comments earlier draft responsible substantial presentation 
alpern wegman zadeck 
detecting equality values programs 
conference record fifteenth acm symposium principles programming languages 

briggs cooper 
effective partial redundancy elimination 
proceedings acm sigplan conference programming language design implementation 

briggs cooper simpson 
value numbering 
software practice experience june 
choi cytron ferrante 
automatic construction sparse data flow evaluation graphs 
conference record eighteenth acm symposium principles programming languages 

choi sarkar schonberg 
incremental computation static single assignment form 
proceedings sixth international conference compiler construction 

chow 
portable machine independent global optimizer design measurements 
tech 
rep phd thesis computer systems laboratory stanford university 
dec chow 
minimizing register usage penalty procedure calls 
proceedings acm sigplan conference programming language design implementation 

chow chan kennedy liu lo tu 
new algorithm partial redundancy elimination ssa form 
proceedings acm sigplan conference programming language design implementation 

chow chan liu lo 
effective representation aliases acm transactions programming languages systems vol 

somemonth 
partial redundancy elimination ssa form delta indirect memory operations ssa form 
proceedings sixth international conference compiler construction 

chow killian weber 
engineering risc compiler 
proceedings ieee compcon 

click 
global code motion global value numbering 
proceedings acm sigplan conference programming language design implementation 

cytron ferrante rosen wegman zadeck 
efficiently computing static single assignment form control dependence graph 
acm trans 
programming languages systems oct 
dhamdhere 
fast algorithm code movement optimisation 
sigplan notices 
dhamdhere 
new algorithm composite hoisting strength reduction optimization corrigendum 
journal computer mathematics 
dhamdhere rosen zadeck 
analyze large programs efficiently 
proceedings acm sigplan conference programming language design implementation 

dhamdhere 
strength reduction large expressions 
journal programming languages 
drechsler 
solution problem morel renvoise global optimization suppression partial redundancies 
acm trans 
programming languages systems oct 
drechsler 
variation knoop steffen lazy code motion 
sigplan notices may 
wolfe 
induction variables detecting classifying sequences demand driven ssa form 
acm trans 
programming languages systems jan 
wolfe 
chain approach live variables 
tech 
rep cse oregon graduate institute 
apr johnson pearson pingali 
program structure tree computing control regions linear time 
proceedings acm sigplan conference programming language design implementation 

joshi dhamdhere 
composite hoisting strength reduction transformation global program optimization 
international journal computer mathematics parts ii 
kennedy 
safety code motion 
international journal computer mathematics 
kennedy chow dahl liu lo 
strength reduction ssapre 
proceedings seventh international conference compiler construction 
knoop steffen 
lazy code motion 
proceedings acm sigplan conference programming language design implementation 

knoop steffen 
lazy strength reduction 
journal programming languages mar 
knoop steffen 
optimal code motion theory practice 
acm trans 
programming languages systems oct 
liu lo chow 
loop induction variable canonicalization parallelizing compilers 
proceedings fourth international conference parallel architectures compilation techniques 

lo chow kennedy liu tu 
register promotion sparse partial redundancy elimination loads stores 
proceedings acm sigplan conference programming language design implementation 
morel renvoise 
global optimization suppression partial redundancies 
comm 
acm feb 
muchnick 
advanced compiler design implementation 
morgan kaufmann publishers san francisco 
acm transactions programming languages systems vol 

somemonth 
delta robert kennedy rosen wegman zadeck 
global value numbers redundant computations 
conference record fifteenth acm symposium principles programming languages 

schwarz landwehr 
optimizer ada design experiences results 
proceedings acm sigplan conference programming language design implementation 

simpson 
value driven redundancy elimination 
tech 
rep 
phd thesis dept computer science rice university 
apr sreedhar gao 
linear time algorithm placing oe nodes 
conference record second acm symposium principles programming languages 

wegman zadeck 
constant propagation conditional branches 
acm trans 
programming languages systems apr 
wolfe 
high performance compilers parallel computing 
addison wesley 
received april accepted september acm transactions programming languages systems vol 

somemonth 
