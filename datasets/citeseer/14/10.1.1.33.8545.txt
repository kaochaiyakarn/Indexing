counting computational interpretation linear logic chirimar lehman brothers chirimar lehman com carl gunter university pennsylvania gunter cis upenn edu www cis upenn edu gunter home html jon riecke bell laboratories riecke research att com www research att com orgs ssr people riecke april develop formal methods reasoning memory usage level abstraction suitable establishing refuting claims potential applications linear logic static analysis 
particular demonstrate precise relationship type correctness language linear logic correctness counting interpretation primitives language draws rules course operation 
semantics low level express sharing copying highlevel away details memory layout 
enables formulation proof result describing possible run time counts values linear type 
contents operational semantics memory programming language linear logic semantics properties semantics linear logic memory discussion proofs main theorems article appear journal functional programming 
preliminary version appeared proceedings acm conference lisp functional programming 
research reported article partially supported onr young investigator award number nsf number ccr nrl number number 
discussions contributed investigation exposition samson abramsky andrew appel val breazu tannen amy felty gunter james hicks dave macqueen diana meadows andre scedrov phil wadler david wise anonymous referees 
variety efforts exploit ideas linear logic design analysis programming languages 
contention perspective proposals view linear logic tool analyzing structure call memory graph represent run time data program 
memory graph simply directed graph finite set functions map finite sets called roots nodes graph 
mathematical abstraction run time structure holds data activation records procedures heap allocated objects 
argue programming language linear logic yields fine grained information memory graph evolves run time providing information exploited program analysis 
particular information provided linear connectives concerns counts nodes memory graph count node sum degree node graph number root elements mapped 
counting long col db albeit controversial bak app history technique avoiding garbage collection 
aside direct managing memory counting offer unifying view code optimizations various code generation strategies seen attempts control counts optimizations performed 
example correctness place updating relies ensuring count object 
attempts study programming languages fall roughly groups 
analog curry howard correspondence basis design language linear logic abr hol laf lm mac consider systems similar linear logic called ll specific applications instance gh wad consider systems detect single threading 
system falls category extent added additional constructs recursive functions bring closer traditional functional programming languages 
convey spirit ideas constructs discussed literature just mentioned look concrete example 
consider program left side table 
code implements addition function terms functions incrementing decrementing 
syntax sml set familiar computational primitives recursive definition branching conditional local definition 
looking closely definition addition possible note difference formal parameters add variables body definition 
value needed test conditional evaluated branch conditional may evaluated branch conditional 
hand variable needed regardless branch conditional body taken 
particular value needed twice may case brings aspects difference variables may different number times exactly table translating linear logic language 
fun add add add fun add share fetch dispose add fetch add store fetch add store twice second value shared separate uses 
program right version addition function written program linear logic annotations slight notation define precisely 
new primitives share dispose store fetch 
share primitive indicates needed twice bound variable second variable variables share value bound 
dispose primitive indicates sharing variables branch conditional 
primitive store creates sharable value fetch obtains shared value 
interpretation ll specific operations share dispose explicitly manage counts share able dispose able objects created consulted store fetch ed 
example table occurence share indicates pointers needed value associated count associated value incremented branch conditional pointers longer needed count associated value decremented 
analogs store fetch operations delay force operations appear functional programming languages 
languages delay primitive evaluation term supplied force primitive argument 
happens value delayed term computed returned memoized applications force 
abramsky abr argued natural way view operational semantics store fetch operations ll follow approach 
dispose primitive analog programming languages 
typically object disposed deallocated operation unsafe lead dangling pointers 
ll language primitive dispose deallocate memory safe semantics decrement count deallocation happens count falls zero 
share command unique ll name accurately reflects way interpreted 
primary goals offer approach rigorously expressing proving optimizations obtained analyzing ll language 
particular adage linear values pointer linear values updated place 
wadler wad informally observed claims stated care count maintained copying negate advantage place updating 
operational semantics allows check claim rigorously particular show linear variables may fail count counting operational semantics uses sharing heavily case linear variable unique pointer safely updated place 
problem arises linear variable falls scope abstraction non linear variable 
express theorem asserting precisely value linear variable maintain count 
broader theme investigation developing level abstraction semantics programming languages permits low level concepts formalized clear relevant way 
significant progress formulating theorems programming languages memory gg wo examples treating garbage collection run time storage representation respectively hope contribute foundation advances direction 
concerned question computational interpretation intuitionistic linear logic fragment language negation par operation 
fact restrict language obtained linear implication gammaffi course operations results extended intuitionistic ll 
rest read linear logic mean implicational fragment intuitionistic linear logic 
language properties stages 
second section discusses operational semantics memoization aim putting place basic notation approach subsequent sections 
third section describes syntax typing rules high level operational semantics language 
fourth section describes low level operational semantics language 
invariants express basic properties memory graph semantics precisely expressed proved 
fifth section demonstrates basic properties semantics including correspondence high level semantics independence scheme allocate new memory 
sixth section uses operational semantics prove static condition linear value count shows ll language amenable analysis memory usage 
seventh section discusses various aspects technical results attempts provide additional perspective 
technical proofs deferred appendix 
operational semantics memory give preview operational semantics ll language describing familiar operational semantics simple functional language store delay fetch force operations 
base preliminary discussion language grammar true false succ pred zero 
fix store fetch primitive syntax classes variables numerals respectively 
variant pcf sco plo bgs augmented primitive operations forcing delaying evaluations 
expression fix recursive definitions 
key providing semantics language represent memoization computing fetch primitive certain recomputation 
aim provide semantics fairly high level abstraction known natural semantics des kah 
semantics described ps explicit substitution lau intermediate representation function applications variables arguments 
approaches simple slightly purposes 
approach described cgr distinction environment association variables locations store association values locations 
sharing computation results achieved creating multiple location holds delayed computation called thunk 
value delayed thunk needed calculated memoized 
define precisely notation basic operations environments stores memory allocation 
fix infinite set locations loc letter denoting elements set 
say partial function finite just case domain definition finite 
ffl environment finite partial function variables locations ae denotes environment env denotes set environments 
notation ae returns location associated variable ae update environment notation ae 
ae 
symbol denotes empty environment 
shorthand 

ffl value numeral boolean pointer susp rec closure closure ae recclosure ae 
letter denotes value value denotes set values 
ffl storable object value thunk thunk ae 
storable denote set storable objects 
ffl store finite partial function oe loc storable 
symbol oe denotes store denotes empty store store denotes set stores 
notation update stores updating environments 
store oe location define oe 
store obtained updating oe binding storable object need relation allocating memory cells 
subset product storable theta store theta loc theta store allocation relation store oe storable object oe oe oe ffl dom oe dom oe dom oe fl ffl locations dom oe oe oe ffl oe definition abstracts away issue exactly new locations 
specificity choose allocation relation new function write new oe pair oe oe new oe 
course operational semantics independent choice allocation relation point formalize describing semantics ll language 
operational rules language natural semantics rules form ae oe oe domain ae contains set free variables location domain oe holds result evaluation 
writing semantics form rules appendix cgr somewhat cumbersome kind primitive pseudocode readily translated natural semantics 
example consider store primitive evaluated store ae oe oe new thunk ae oe new susp oe read follows 
evaluate store environment ae store oe allocate new location holding thunk composed environment ae 
oe new store location thunk held 
result evaluation store obtained oe allocating new location holding susp thunk ae structure generated store storable value susp paired new location 
note particular evaluated 
structure added memory depicted 
interesting part evaluator essence memoization way fetch primitive handled 
argument fetch evaluated return storable value form susp 
content location examined determine suspension evaluated value evaluated case form thunk ae 
content value pointer value returned thunk evaluated updated value 
pointer value thunk returned result 
pseudo code description fetch ae oe oe ae oe case oe susp 
case oe thunk ae oe ae oe oe 
susp 
oe note clause case oe suspension 
case assume behavior interpreter fetch undefined 
assumption simplifies rules allows ignore effect run time type errors 
rules ignore run time type errors 
approach taken modelling memoization 
interpretation store allocates location holds thunk returns location holds pointer susp location 
returned value 
rule read store ae oe new thunk ae oe answer question instructive relates way represent distinction copying sharing model 
choose return location holding thunk value store opposed returning location holding pointer thunk require change fetch command 
particular location obtained essential put value oe location value thunk may sought fetch ae oe oe ae oe case oe thunk ae oe ae oe oe 
oe 
oe note second line bottom program values store say value thunk copied location case oe small value integer occupies word storage little difference copying value versus returning pointer earlier implementation 
value oe large copying may expensive 
language considering involve copying closure modest expense fuller language involve copying string functional array expensive 
oe mutable value copying probably incorrect problem functional language hand 
semantics directly represent cost associated copying abstracts away measure size value treat copying avoided favor sharing indirection feasible 
suggests third approach semantics fetch store implemented interpretation fetch uses indirection returned value fetch ae oe oe ae oe case oe thunk ae oe ae oe oe 

oe viewed boxed value 
possibly closer way memoization implemented compilers 
semantics ll language section approach complicates semantics slightly efficient way counting done 
approach accomodate alternative major changes 
implementation memoization involves idea mutating store 
functional parts language respect potential side effects store memoization may cause 
operations pass store appropriate manner 
doing correctly may save recomputation 
instance application operation described rec recclosure ae 
structure generated fix ae oe oe ae oe oe ae oe case oe closure ae ae 
oe store resulting evaluating evaluating similarly store resulting evaluating evaluating application 
variety ways implement recursion 
reasonably efficient approach create circular structure 
approach simplified restricting interpreter programs constructs form fix term form restriction necessary typical call value programming languages 
semantics recursions fix ae oe oe new oe oe new recclosure ae 
oe oe 
rec creates circular structure 
language create single cell holding recclosure looped back cells additional cell holding rec semantics ll language facilitate connections type system 
need change semantics applications operator evaluates rec pointer traced recclosure turn operator evaluates recclosure operator way closure 
implementation actual functional programming languages single recursion probably recursive calls jump instruction 
quite difficult formalize source approach describe interpreter 
important thing purposes recursive calls allocate memory recursive closure 
means far memory concerned little difference implementing recursion jump implementing circular structure 
cycle created way introduces extra complexity structure memory course cycles introduced way precisely form pictured 
easy provide clean type system language described 
technical convenience tag certain bindings types binding occurence abstraction ensure program unique type derivation 
important discussion hand drop tags bound variables reduce clutter 
types language include ground types nat bool numbers booleans respectively higher types functions unary operation delayed programs type typing rules store fetch elimination operations respectively store fetch operations ll language essentially types 
programming language linear logic term assignment linear logic 
programming language ll reasonable attempt completion analogy curry howard correspondence intuitionistic logic traditional functional programming languages ml haskell ll basing language curry howard correspondence ll immediately problematic ll originally described girard gir sequent calculus 
programming languages syntax typing system natural deduction called nd formulation intuitionistic logic sequent calculus formulation type checking algorithms easier describe nd formulations 
progress nd form intuitionistic ll gradual part substitutivity fails obvious formulations definition type system satisfies substitutivity property typed programs closed substitution gamma delta variables gamma delta distinct gamma delta denotes substitution bound variables renamed avoid capture free variables sml mth mt prototypical example language nd presentation satisfies substitutivity property 
merely coming nd presentation ll satisfies substitutivity outstanding problem 
absence system lincoln mitchell lm mackie mac wadler wad authors preceeding cgr employed approaches obtain virtues nd system ll 
system proposal benton bierman de paiva hyland satisfy substitutivity property lacks desirable properties nd presentation intuitionistic logic freedom need commuting conversions glt 
refer reader fuller discussion 
table natural deduction rules term assignment linear logic 
gamma gamma gammaffi gamma gammaffi delta gamma delta gamma delta gamma delta dispose gamma delta gamma delta share gamma gamma gamma gamma store gamma gamma fetch propositions fragment linear logic consider grammar gammaffi ranges atomic propositions 
proofs linear propositions encoded terms grammar store fetch share dispose notation essentially corresponds cgr lm modulo incorporating adjustments 
store operation store binds variables expression share operation share binds variables notation store somewhat unwieldy writing programs programs involving store bind variables clause variables 
free variables store shorthand expression store 
typing rules language appear table symbols gamma delta denote type assignments lists pairs distinct variable type 
rules built assumption left hand sides symbol legal type assignments rule typing applications type assignments gamma delta appear concatenated rule disjoint variables 
type checking rule corresponds proof rule nd presentation linear logic 
instance rules share dispose essentially correspond proof rules generally called contraction weakening respectively store fetch correspond ll rules called promotion dereliction 
due presence explicit rules weakening contraction rules type checking dispose share easily see free variables typed term exactly contained type assignment 
particular note taken form rule store operation puts value body bindings free variables location shared different terms reduction type changes correspondingly construct fetch corresponds reading stored value type changes may nd presentations ll base type system 
belief results robust respect exact choice term assignment type checking rules 
results including negative results say values linear type may pointer hold system described cgr expect true languages described lm mac 
programming language linear logic 
fully realize ideas ll basis programming language essential go core language 
language extended includes linear logic connectives pairing sums tensor omega plus phi 
suitable nd proof rules connectives term assignments proofs rules described places mac lm 
challenging question extend language include constructs curry howard correspondence useful guide 
examples fall category arrays general recursive datatypes involving linear implication recursive definitions functions 
treat recursive function definitions question proper treatment recursive definitions ll language simpler general recursive datatypes fundamental arrays 
language essentially synthesis pcf term language encoding ll natural deduction proofs 
types grammar nat bool gammaffi types leading nat nat gammaffi bool called linear form called non linear 
letters denote types 
set raw terms language grammar true false succ pred zero 
fix store fetch share dispose table typing rules non logical constructs 
nat true false bool gamma nat gamma succ nat gamma nat gamma pred nat gamma nat gamma zero 
bool gamma gammaffi gamma fix gamma bool delta delta gamma delta letter denotes variable denotes numeral operations correspond special rules linear logic term constructors pcf 
usual definitions free bound variables pcf apply lines grammar 
typing rules language combining tables 
rules deserve special explanation 
rule checking expression checks branches type assignment terms contain free variables 
type checking rule allows variables appear multiple times violate intuition variables branch taken execution program 
second slightly mysterious form typing rule recursions related idea formal parameter recursive definition share dispose interesting 
consider example rendering program table language fix store add nat nat nat share zero 
fetch dispose dispose add fetch add store pred fetch succ store liberties taken dropping parentheses improve readability 
recursive function add defined gets branches recursive call non linear type 
definition addition function prototypical example programs recursive functions language 
fact high level lowlevel semantics interpret recursions fix form store gammaffi table interpreting linear core dispose share store store store fetch table interpreting pcf extensions true true false false succ pred pred zero 
true zero 
false true false fix store store fix store restriction closely connected restriction interpreting recursion mentioned previous section difference occurrence store 
restriction essential simplify semantic clause recursion somewhat compromising way programs generally written 
natural semantics 
tables give high level description interpreter language written natural semantics 
natural semantics describes partial function proof trees 
notation read term halts final result proof rules terms interpreter function halts called canonical forms easy see form rules canonical forms true false store 
natural semantics tables describes call value evaluation strategy 
operands applications evaluated canonical form substitution takes place 
basic property semantics types preserved evaluation theorem suppose proof carried easy induction height proof tree semantics high level natural semantics useful specification language proving facts theorem 
want implement semantics directly explicit substitution terms expensive standard representation terms closures graphs order perform substitution efficiently 
problem high level semantics go far providing computational intuition ll primitives language 
example dispose operation treated essentially op 
apparent relationship connectives memory semantics entirely suppresses concept memory 
order understand constructs linear logic memory construct semantics relates ll primitives counting 
semantics linear logic primitives dispose share maintain counts 
basic structure counting interpreter outlined section 
environments values storable objects definition 
want maintain counts definition stores change 
store function oe loc 
theta storable left part returned pair denotes count 
abusing notation oe denote storable object associated location oe 
denote new store oe location holds storable object count left unaffected 
count cell denoted refcount oe 
domain store oe set dom oe fl loc refcount oe change definition store forces adjustment definition allocation relation 
subset product storable theta store theta loc theta store allocation relation store oe storable object oe oe oe ffl dom oe dom oe dom oe fl ffl locations dom oe oe oe refcount oe refcount oe ffl oe refcount oe 
basic structure underlying store may captured abstractly graph 
formally graph tuple sets vertices edges respectively functions called source target functions respectively 
note may edge source target multiple edge graphs called multigraphs 
degree number elements vertex reachable vertex path list edges 
memory graph tuple ae ae graph list functions ae ae function finite domain codomain 
functions ae called root set memory graph 
ae jae gamma number elements domain ae ae count vertex sum degree jae gamma vertex memory graph said reachable ae reachable element image ae state triple ae oe list locations ae list environments oe store 
assumed set locations image environment ae contained dom oe 
definition ae oe state ae ae ae memory graph induced defined follows 
vertices graph locations dom oe edges determined definition 
ffl dom oe oe susp oe rec edge ffl suppose dom oe oe closure ae thunk ae 
dom ae edge ae 
ng 
root set induced memory graph list ae ae 
instance state ae oe dom ae fxg ae oe thunk 
oe oe susp oe true induces memory graph 
abuse notation write oe graph induced oe root set 
primarily concerned states satisfy collection basic invariants 
root set memory graph 
definition state ae oe count correct dom oe refcount oe equal count 
definition state ae oe called regular written provided conditions hold count correct 
dom oe finite 
dom oe oe thunk ae refcount oe 
cycle memory graph induced arises form rec recclosure nodes oe rec oe recclosure ae 
ae 
dom oe oe thunk ae domain ae set free variables typeable 
similarly oe closure ae recclosure ae domain ae set free variables typeable 
term said typeable type context gamma type gamma convenient abuse notation slightly denoting states writing locations environments store grouping official definition 
example ae oe ae read ae ae oe cons operation puts datum head list 
chance confusion long lexical conventions distinguish parts tuple locations environments properly ordered left right 
order lists irrelevant regularity ae oe ae permutations ae respectively ae oe 
fact explicit mention 
table definition dec ptrs 
dec ptrs oe dec oe oe true false dec ptrs dec oe oe susp refcount oe dec ptrs env ae dec oe oe thunk ae refcount oe dec ptrs env ae dec oe oe closure ae refcount oe dec ptrs env ae oe recclosure ae 
dec dec dec oe oe rec refcount oe refcount oe dec ptrs env ae oe rec dec dec dec oe oe recclosure ae 
refcount oe refcount oe dec oe dec ptrs env ae oe oe domain ae fx oe dec ptrs ae oe 
oe dec ptrs ae oe gamma basic counting operations 
interpreter need auxiliary functions manipulate counts 
functions dec increment decrement counts 
formally oe increments count returns resultant store dec oe decrements count returns resultant store 
operations env ae oe dec ptrs oe increment decrement counts multiple cells 
formal definition env ae oe oe domain ae fx oe ae oe 
oe ae oe gamma words env ae oe increments counts locations range ae returns resultant store 
note location count may incremented operation variables may map location ae 
operation dec ptrs oe returns updated store decrements count location count falls zero recursively decrements counts cells pointed formal definition appears table example appears left side assumed part graph store oe transformed right side calling dec ptrs oe 
operation dec ptrs oe single example dec ptrs operation 
complex operation interpreter 
operations local parts memory graph require recursive definition 
key characteristic semantics fact dec ptrs oe rule evaluating dispose 
basic laws capture relationships maintained allocation update operations states table 
laws proven appendix give proof attenuation law show proofs go 
suppose ae oe refcount oe oe closure ae recclosure ae thunk ae 
note state ae ae dec oe count correct environment ae placed root set accounting edges coming closure thunk disappeared memory graph 
property holds state dom oe dom dec oe properties follow directly hypothesis 

property called attenuation law pointers previously held inside store drawn root set 
goal define interpreter ll programming language 
understand interpreter essential appreciate invariants influence design 
describe theorem interpreter expected satisfy proof theorem definition interpreter 
interpreter function interp takes arguments term environment ae store oe 
assumed domain ae set free variables image ae contained domain oe 
result interp ae oe pair oe oe store location domain oe oe value viewed result computation 
binary infix appending lists 
theorem stated follows theorem ae oe ae state suppose typeable term 
interp ae oe oe oe ae 
ae ae ae dom oe reachable ae ae memory graph induced contents count remain unchanged reachable ae memory graph induced oe ae 
part theorem says regularity preserved execution typeable terms 
second part theorem expresses call table memory graph laws 
attenuation laws suppose ae oe refcount oe 
oe closure ae recclosure ae thunk ae ae ae dec oe 
oe susp ae dec oe 
laws decrement ae oe oe constant ae dec oe 
ae oe refcount oe ae dec oe 
ae oe ae dec ptrs oe 
laws increment ae oe dom oe ae oe 
suppose ae oe ae dom oe dom ae 
ae ae env ae oe 
environment law suppose dom ae 
ae ae oe iff ae 
ae oe 
allocation laws ae oe oe new oe constant ae oe 
suppose ae ae oe oe equal new closure ae oe new thunk ae oe new recclosure ae oe fv dom ae 
typeable ae oe 
ae oe oe new susp oe new rec oe ae oe 
update laws suppose ae oe oe constant dom oe 
ffl reachable memory graph induced ae oe 
susp 
ffl oe recclosure ae 
ae oe 
rec 
ae oe refcount oe oe susp oe thunk ae ae ae dec dec oe 

reachability property 
special case interest says evaluation program environment ae store oe affect locations dom oe reachable ae 
extra complexity statement required maintain usable induction hypothesis proof property 
simplified version theorem expressed follows corollary suppose closed typeable term 
interp oe oe 
assumption typeable crucial proof theorem terms may maintain counts correctly 
instance term dispose store cause run time error maintenance counts dispose try access portion memory count zero get dangling pointer error 
example shows terms may cause premature 
term share dispose store causes space leak count cell holding store greater zero garbage execution 
interpreting linear core 
proof theorem induction number calls interpreter 
proof proceeds considering case program evaluated 
interpretation variable obtained looking variable environment interp ae oe ae oe store ae oe ae regular consequence environment law assumption domain ae fxg 
reachability condition clearly satisfied output store input store 
evaluate abstraction create new closure place new cell return location updated store interp ae oe new closure ae oe prove regularity state preserved suppose oe new closure ae oe oe ae allocation law 
reachability condition satisfied output store differs input store extending 
term environment ae domain includes free variables ae restriction environment ae free variables evaluation application follows interp ae oe oe interp ae oe oe interp ae oe case oe closure ae recclosure ae refcount oe interp ae 
dec oe interp ae 
env ae dec oe reader may compare rule rule application section 
key difference semantic clauses manipulation counts rule conditional breaks evaluation function body cases count location holds value operator branch conditional performs counting arithmetic 
resulting semantics clause looks similar denotational semantics hud information counts included semantics clauses 
note environment ae split subterms fact typeable implies ae ae ae 
various forms sort property repeatedly semantic clauses 
prove preservation regularity state application start assumption ae oe ae 
equivalent ae ae oe ae 
ae oe ae oe ae hold induction hypothesis abbreviate induction hypothesis ih 
possibilities count oe equal 
refcount oe attenuation law says ae dec oe ae 
environment law implies ae 
dec oe ae desired follows ih 
hand refcount oe ae env ae dec oe ae 
ae 
env ae dec oe ae done ih 
see reachability property holds interpretation application suppose dom oe unreachable ae ae ae ae ae unreachable unreachable ae ae unreachable ae ae ae ih unreachable ae ae memory graph induced state resulting evaluation second application ih allows conclude unreachable ae memory graph induced oe ae 
definition memory graph implies unreachable ae unreachable ae 
ae memory graphs induced states ae 
dec oe ae ae 
env ae dec oe ae 
desired follows ih 
proof reachability similar remaining cases omit arguing rest discussion 
expression store interpreted evaluating terms locations building environment maps creating thunk environment returning location holding suspension thunk interp store xn mn ae oe oe interp ae oe delta delta delta oe interp mn ae mn oe gamma ae xn 
oe new thunk ae oe new susp oe prove desired property maintained note repeated application induction hypothesis allows conclude ae oe ae 
oe ae 
oe new susp oe 
oe ae 
fetch suspended object complex operations 
evaluate thunk suspension holds 
code similar interpreter section examined earlier addition counting arithmetic clause dealing recursion interp fetch ae oe oe interp ae oe case oe susp 
case oe thunk ae refcount oe interp ae dec dec oe oe interp ae dec dec oe 
oe 
susp 
refcount oe dec oe dec oe rec 
dec oe ih oe ae 
suppose oe susp oe thunk ae 
refcount oe ae dec dec oe ae done ih 
suppose hand refcount oe 
ae dec dec oe 
ae oe 
susp ae ih reachability property ensure applicability 
specifically oe location reachable ae reachable oe oe 
susp create illegal loop memory graph 
cases oe value oe rec left reader 
share command increments count location interp share ae oe oe interp ae oe interp ae 
oe ae oe ae ih ae oe ae 
follows environment law ae 
oe ae result follows ih 
dispose command decrements count location 
requires calculating consequences possibly removing node memory graph count disposed node falls 
interp dispose ae oe oe interp ae oe interp ae dec ptrs oe ae oe ae ih ae dec ptrs oe ae 
result follows ih 
interpreting pcf extensions 
interpreter evaluates constant simply creating cell holding value constant 
interp ae oe new oe interp true ae oe new true oe interp false ae oe new false oe regularity preserved cases follows immediately 
rules arithmetic boolean operations pcf mimic rules high level operational semantics 
interp succ ae oe oe interp ae oe new oe dec oe interp pred ae oe oe interp ae oe oe new dec oe new gamma dec oe interp zero 
ae oe oe interp ae oe oe new true dec oe new false dec oe prove desired property successor operation note oe ae follows ih done 
proofs cases similar 
conditional statement expected form count condition decremented branches interp ae oe oe interp ae oe oe true interp ae dec oe interp ae dec oe ih implies oe ae 
oe true desired follows 
interpret recursion need rule similar rule interpreting store 
interp fix store xn mn ae oe oe interp ae oe delta delta delta oe interp mn ae mn oe gamma ae xn 
oe new oe oe new recclosure ae 
oe oe 
rec interpretation store repeated application ih implies ae oe ae 
oe ae 
desired follows 
properties semantics order counting interpreter sense satisfy number invariants correctness criteria 
section describe precisely 
space leaks 
short example kind property expects semantics satisfy consider idea space leaks expressed formalism 
state ae oe say location reachable ae reachable ae ae 
desired property expressed follows theorem suppose ae oe ae regular state dom oe reachable ae ae 
typeable interp ae oe oe dom oe reachable ae 
theorem proved induction number calls interpreter 
invariance different allocation relations 
design interpreter correct exact memory usage pattern unimportant final answers returned interpreter 
allocation relation new completely determines memory usage cell count filled matter allocation relation 
set formally follows allocation relation interp partial interpreter function defined place new 
recall environment store empty domains denoted 
prove statement induction number calls interp suppose allocation relations 
interp oe interp oe 
oe true false oe oe 
naive induction runs interpreter return intermediate results numbers booleans 
need strengthen induction hypothesis 
interp returns closure suspension result returned interp may literally instance interp may return location holding susp interp may return location holding susp 
values renaming locations domain returned store oe formalizing notion stores equivalent renaming locations done underlying graphs 
stores equivalent underlying graph representations isomorphic function values held cells equivalent formally definition states ae oe ae oe congruent isomorphism oe oe dom oe refcount oe refcount oe dom oe 

dom ae dom ae dom ae ae ae 
oe true false oe oe 
oe susp oe susp 
oe rec oe rec 
oe closure ae oe closure ae dom ae dom ae dom ae ae ae 
oe recclosure ae oe recclosure ae dom ae dom ae dom ae ae ae 
oe thunk ae oe thunk ae dom ae dom ae dom ae ae ae 
may prove lemma suppose ae ae oe ae ae oe congruent 
interp ae oe oe interp ae oe oe resultant states ae oe ae oe congruent 
closure share closure 

susp thunk true 
closure store example valofcell operation 
proof deferred appendix 
lemma theorem follows directly theorem suppose allocation relations 
interp oe interp oe 
oe true false oe oe 
correctness interpreter 
need verify counting semantics implements natural semantics tables evaluating closed term base type yields result semantics 
proof proceeds induction number steps evaluation height proof tree direction number calls interp direction 
need expanded induction hypothesis carry proof relate values held memory locations terms 
define extraction functions valof ae oe valofcell oe 
intuitively function valofcell extracts term storable value held location store oe function valof replaces free variables extracted versions cells bound free variables ae 
idea easy understand intuitively example 
suppose instance cell holds thunk dispose 

holds susp holds holds true store oe 
valofcell oe dispose store true 
larger example appears counts ignored oe store depicted valofcell oe share store true formal valof valofcell simultaneous induction table appendix 
similar definition plo unwinding closure relative secd machine state 
interpreting terms arbitrary type induction hypothesis relate values returned natural semantics values returned counting interpreter 
key definition missing definition related values 
attempt extend statement theorem directly closed terms iff interp oe valofcell oe statement holds basic values hold values types 
problem arises counting interpreter results evaluating store natural semantics 
instance evaluating term share zero 
fetch store succ natural semantics returns value store succ evaluating expression counting semantics returns value unwinding store 
proof requires relating terms evaluated terms evaluated 
definition read requires evaluation iff closed denotes term missing subterm term resulting subterm 
reflexive transitive closure relation necessary order express desired property theorem suppose typeable dom ae fv closed valof ae oe 
suppose ae ae oe 

interp ae oe oe valofcell oe 

interp ae oe oe valofcell oe 
extra assumptions state ae ae oe satisfies invariants constructing execution counting interpreter 
proof deferred appendix 
linear logic memory examine question circumstances ensured location holding value linear type maintain count 
general guarantee locations holding linear values count evaluation program 
consider example term share zero 
fetch store evaluation suspension placed location turn holds pointer location holding thunk containing value 
location passed pointers called created share pictorially susp thunk evaluation continues point fetch contents location evaluated location holding suspension updated point pointer passed evaluation zero 
pictorially susp cell containing pointers linear type nat 
clearly issue location holding linear value accessible location holding non linear susp 
static condition know happen 
difficult face circumstances computation alter memory graph linear value brought location referenced non linear value 
consider term nat nat gammaffi nat store term type nat gammaffi nat evaluation may create memory graph location holding brought precisely circumstance count increased pointers passed susp 
need know happen way ensure linear value maintains count 
help point proof theory linear logic 
note problem term relies having term type nat gammaffi nat 
stand point linear logic translation correspondence suspicious assumption 
proposition gammaffi provable ll situation illustrated runs contrary proof theoretic facts propositions moved boxes proof net cut elimination gir 
directly prove static property exists ll programming language suggest hope 
assert desired property precisely need terminology 
say storable object linear numeral boolean closure recclosure say non linear form susp rec thunk ae 
say location non linear store oe oe non linear object similarly location linear store oe oe linear object 
key property concerns nature path memory graph location root set 
definition suppose oe ae regular state dom oe 
location said linear path satisfies properties 
oe linear 
refcount oe 
note conditions satisfied path satisfied unique path path condition satisfied 
convenient say path satisfying conditions linear 
regular state ae oe ae say linear ae domain ae unique linear path ae prove desired property need know basic facts types evaluation 
high level semantics expressed subject reduction theorem ll programming language 
conjuction correctness theorem version result low level semantics lemma suppose oe ae regular state dom ae fv valof ae oe interp ae oe oe 
valofcell oe theorem wish express says program evaluated environment location linear value location deallocated linear location returned result evaluation 
statement intended formally capture idea location linear environment left untouched count 
unfortunately assertion contains term deallocate needs precise 
assert count location linear result computation problem case count falls allocation relation reallocate location hold value unrelated placed originally 
impossible assert interesting outcome computation 
resolve worry restriction allocation relation insisting range 
assumption harmless sense precise theorem 
result interest asserted precisely follows theorem suppose ae oe ae regular state dom ae fv valof ae oe typeable 
linear ae range new interp ae oe oe properties holds regular state oe ae 
refcount oe 
refcount oe linear proof proof induction number calls interp 
exhibit key cases leave reader 


evaluation begins follows interp ae oe oe interp ae oe oe oe closure ae recclosure ae fact linear ae means reachable exactly ae ae consider cases separately 
reachable ae induction hypothesis ih subcases applies refcount oe 
assumption reallocated new follows refcount oe 
ii 
refcount oe linear memory graph linear path list locations associated path fact counts equal means edges uniquely determined 
locations reachable ae imply count greater 
theorem contents counts locations change evaluation linear oe ae oe form closure ae recclosure ae linear ae ae 
dec oe ae 
know refcount oe conclude interp ae 
dec oe oe desired follows ih 
reachable ae assumption linear path image ae locations path reachable ae count equal 
theorem values unchanged evaluation unreachable oe ih possibilities regarding regular state oe ae obtained evaluating refcount oe 
assumption reallocated new refcount oe needed 
ii 
refcount oe case ih implies linear path subcases consider refcount oe refcount oe 
consider second leave reader 
laws know state ae 
env ae dec oe ae regular hard check linear ae 
interp ae 
env ae dec oe oe done ih 

store 
case reachable exactly environments ae evaluation interp ae oe oe 
interp ae oe gamma oe ih possibilities regular state ae ae oe ae arising evaluation count zero oe linear path case holds done reallocated remainder computation theorem satisfied 
hand second case impossible lemma valofcell oe type oe value form susp rec 
contradicts assumption linear count oe done new 
share 
evaluation compute interp ae oe oe interp ae 
oe oe reachable exactly environments ae ae consider cases separately 
reachable ae reasons discussed case store ih implies refcount oe done new 
reachable ae linear path ae theorem unaffected evaluation particular reachable linear ae regular state ae 
oe ae done ih 
remaining cases treated similarly 
see example theorem applied reasoning properties depend memory graph suppose want evaluate add store empty environment empty store 
key steps ffl add store evaluates oe oe closure ae 
ffl oe evaluates oe oe 
ffl body add evaluated mapped point conditions required theorem true 
know count exceed long deallocated reallocated 
implies safe update place recursive call 
similar analysis applies definitions multiplication recursive functions variable accumulator store result 
technique proof allows achieve goals hudak hud defined collecting interpretation counts 
discussion chosen particular natural deduction presentation linear logic 
proposed different formulations linear logic interesting carry similar investigations formulations 
instance abramsky abr sequent formulation linear logic 
system satisfies substitutivity essentially rule sequent presentation cut rule precise clear means doing type inference language 
mac lm attempted reconcile problems type inference substitutivity proposing restricted forms properties 
approach modify linear logic adding new assumptions 
instance wad propose isomorphic perspective identification collapse levels indirection suspension fundamentally change character language 
approaches presentation ll compatible explanations framework yield slightly different results 
example way ll judgements form gamma delta gamma set intuitionistic assumptions types non linear variables delta multi set linear assumptions types linear variables 
approach suit results section better presentation singles linear variables clearly provides simpler term language 
hand connection counts clear formulation 
possible fold counting operations interpretation garden variety functional programming language intuitionistic logic 
ways result differs semantics ll language illuminating 
choices 
approach maintain invariant interp evaluated triples ae oe domain ae exactly set free variables evaluating application example essential account possibility free variables shared means interpreted counts variables common incremented may deallocated evaluation begins interp ae oe oe interp ae env ae ae oe oe interp ae oe case oe closure ae recclosure ae refcount oe interp ae 
dec oe interp ae 
env ae dec oe deallocation variables driven requirement free variables lie domain ae arises particularly semantics conditional interp ae oe oe interp ae env oe oe true interp ae dec dec ptrs env gamma oe interp ae dec dec ptrs env gamma oe alternative approach providing counting semantics intuitionistic language delay deallocation variables minute permit application interp triples ae oe domain ae includes free variables may include variables 
possible simplify interpretation conditional interp ae oe oe interp ae oe oe true interp ae dec oe interp ae dec oe burden disposal shifts evaluation constants interp ae oe new dec ptrs env ae oe basic difference counting interpretation intuitionistic logic approaches just described versus counting linear logic way ll primitives distinctions explicit code 
ll primitives possible describe certain kinds code motion concern memory deallocated 
example program dispose dispose shown equivalent higher level semantics dispose program viewed preferable counting semantics may deallocate locations referenced sooner 
example program dispose equivalent dispose different variables 
transformation may significant value deallocated needlessly held closure 
proving programs ones equivalent far high level semantics concerned facilitated fixed point denotational semantics ll language 
reasonable semantics kind extension semantics call value operation interpreted lifting operation domains 
semantics possible extend adequacy result standard techniques section gun win 
question ll language useful intermediate language compiler analysis intuitionistic programming languages certainly related techniques translating 
analogy various studies subtleties transformation cps ld example 
closer analogy translation language meant executed call name call value language primitives delaying store ing forcing fetch ing 
standard translation purpose issues arise translation arise translation intuitionistic linear logic 
instance pair programs strongly reminiscent table appears discussion compiler sample test suite gab 
problem addressed technique strictness analysis ah strictness analysis translation efficient translated program optimized 
techniques known translating intuitionistic logic linear logic 
illustrate consider combinator written ml syntax fn 
fn 
fn 
apply girard translation result syntax similar table program fn 
fn 
fn 
share fetch store fetch store fetch store fetch program having erasure fn 
fn 
fn 
share evidently simpler efficient program 
analog strictness analysis applies ll translation clearly needed ll intermediate language practical significance analyzing intuitionistic programs 
counting interpreter associated invariance properties easily extended linear connectives omega phi unclear handle classical connectives 
extending results dynamic allocation arrays difficult structures create cycles 
instance assumed integers booleans assignable mutable cells 
see little detail assume nat bool typing rules follows gamma gamma ref ref gamma ref gamma ref gamma ref gamma create cell initialized value term term evaluated value copied new cell interp ref ae oe oe interp ae oe new oe dec oe location holds immutable value new mutable cell created value initial value 
assignment mutates value associated cell interp ae oe oe interp ae oe oe interp ae oe dec oe 
oe obtain value held mutable cell denoted contents cell copied new immutable cell interp ae oe oe interp ae oe new oe dec oe code creating cell code dereferencing look dual sense cell creation ref copies contents immutable cell mutable dereferencing copies contents mutable cell immutable 
language designed way similar scheme force delay primitives restrictions ml values mutable 
restriction types elements held cells similar block structured languages permit higher order procedures assigned variables cells 
demonstrated language design guided analog curry howard correspondence applied linear logic interpreted providing fine grained information counts memory graphs produced program run time 
ll language may useful detecting proving correctness forms program analysis proofs main theorems rely counts nodes memory graphs 
secondary theme illustrated approach expressing proving properties programs level abstraction properties memory graphs significant lower level properties memory layout abstracted away 
isolating level abstraction useful correctness proofs lower levels correctness memory allocation scheme 
proofs main theorems verification basic laws table proposition laws section hold 
proof proof may section proof similar 
need verify 
suppose ae oe holds oe numeral boolean ae dec oe 
note outgoing edges memory graph induced dom dec oe state 
dom oe dom dec oe properties follow directly hypothesis 

suppose ae oe refcount oe ae ae dec oe 
hypothesis follows refcount oe root set 
refcount dec oe count correct satisfying 
dom oe dom dec oe properties follow directly hypothesis 

completes verification part 
proposition law holds generally 
ae oe ae dec ptrs oe 

ae ae oe ae dec ptrs env ae oe 
proof induction total number calls dec ptrs dec ptrs env 
basis suppose number calls cases 
dec ptrs called 
subcases oe true false 
dec ptrs oe dec oe 
ae dec ptrs oe 
oe susp thunk ae closure ae refcount oe 
dec ptrs oe dec oe ae dec ptrs oe 
oe rec recclosure ae refcount oe 
dec ptrs oe dec oe ae dec ptrs oe 
proofs main theorems 
dec ptrs env called 
dec ptrs called dom ae empty set 
dec ptrs env ae oe oe ae dec ptrs env ae oe 
induction hypothesis suppose total number calls dec ptrs dec ptrs env greater 
main cases 
dec ptrs called 
subcases depending count value stored 
oe susp refcount oe 
dec ptrs oe dec ptrs dec oe 
ae dec oe induction ae dec ptrs dec oe 
ae dec ptrs oe 
oe thunk ae refcount oe 
dec ptrs oe dec ptrs env ae dec oe 
ae ae dec oe induction ae dec ptrs env ae dec oe 
ae dec ptrs oe 
oe closure ae refcount oe 
similar previous case 
oe recclosure ae 
oe rec refcount oe refcount oe 
dec ptrs oe dec ptrs env ae dec dec dec oe 
oe dec dec dec oe state ae ae oe count correct disappeared memory graph 
satisfies properties dom oe dom oe 
induction ae dec ptrs env ae oe 
ae dec ptrs oe 
oe rec oe recclosure ae 
refcount oe refcount oe 
dec ptrs oe dec ptrs env ae dec dec dec oe 
similar previous case 

dec ptrs env called 
number calls greater dom ae fx 
ae ae ae oe dec ptrs env ae oe dec ptrs ae dec ptrs dec ptrs ae oe follows repeated applications induction hypothesis ae dec ptrs ae oe 
completes induction hypothesis proof 
proposition laws section hold 
proof verify law individually 
suppose ae oe dom oe 
ae oe 
pointer root set count incremented count correct 
dom oe dom oe properties follow directly hypothesis 

proofs main theorems suppose ae oe ae dom oe dom ae 
ae ae env ae oe follows easy induction size dom ae arguments similar case 
suppose ae ae oe dom ae ae 
ae oe 
root set points identical memory graph induced identical 

converse similar omitted 
suppose ae oe oe new oe constant ae oe 
new allocation relation refcount oe refcount oe location oe oe refcount oe refcount oe 
note count correct location oe different oe location pointer root set 
verifies property 
dom oe finite dom oe finite property holds new create additional cycles memory graph thunks closures properties hold 
suppose ae ae oe oe new closure ae oe new thunk ae oe fv dom ae typeable ae oe 
new allocation relation refcount oe refcount oe location oe oe refcount oe refcount oe 
see property count correctness holds note pointers ae accounted closure thunk stored count 
see dom oe dom oe fl finite dom oe thunk refcount oe hypothesis guarantees property 
cycles created induced memory graph new holds 
holds hypothesis 

suppose ae oe oe new susp oe new rec oe 
ae oe follows manner similar previous case 
suppose ae oe oe constant 
prove statement follows similarly 
suppose dom oe reachable memory graph induced ae oe 
susp 
degree greater degree nodes remains 
satisfies property 
dom oe dom oe domain oe finite satisfying property 
new thunks created property holds reachable cycle satisfies property 
property holds thunks closures added oe 

suppose ae oe refcount oe oe susp oe thunk ae ae ae dec dec oe 

verify property note refcount oe hypothesis 
proofs main theorems pointers mentioned root set follows count correct 
clear properties hold 
completes verification part 
proof lemma lemma suppose ae ae oe ae ae oe congruent 
interp ae oe oe interp ae oe oe resultant states ae oe ae oe congruent 
proof induction number calls interp 
cover cases core language leave cases reader 
cases easier read isomorphism oe oe states congruent 

interp ae oe ae oe 
interp ae oe ae oe resultant states ae ae oe ae ae oe congruent 

interp ae oe new closure ae oe oe 
allocation relation ffl dom oe dom oe dom oe fl ffl locations dom oe oe oe refcount oe refcount oe ffl oe closure ae refcount oe 
note interp ae oe new closure ae oe oe 
allocation relation ffl dom oe dom oe dom oe fl ffl locations dom oe oe oe refcount oe refcount oe ffl oe closure ae refcount oe 


clear isomorphism oe oe 
consider resultant states ae oe ae oe 
isomorphism conditions congruence states satisfied just need show properties stating relationship values stored locations satisfied 
contents cells oe oe change new locations oe closure ae oe oe closure ae dom ae dom ae dom ae ae ae facts follow hypothesis 
resultant states congruent 
proofs main theorems 

interp ae oe oe ffl interp ae oe oe ffl interp ae oe oe ffl oe closure ae recclosure ae 
hypothesis environments ae ae domain divided ae ae applications induction hypothesis ffl interp ae oe oe ffl interp ae oe oe states ae oe ae oe congruent 
particular note oe closure ae recclosure ae 
cases refcount oe 
refcount oe counts 
states ae 
ae oe ae 
ae oe congruent follows induction hypothesis interp ae 
dec oe oe ae oe ae oe congruent 
putting pieces see interp ae oe oe desired 
refcount oe 
refcount oe counts 
ae 
ae oe ae 
ae oe congruent induction interp ae 
env ae dec oe oe ae oe ae oe congruent 
putting pieces see interp ae oe oe desired 

fetch 
interp ae oe oe 
induction interp ae oe oe states ae oe ae oe congruent 
main cases oe susp oe rec 
leave second case reader relatively straightforward consider case 
suppose oe susp 
definition congruence oe susp 
subcases depending object held oe thunk ae 
congruence oe thunk ae 
subcases depending count refcount oe 
tuples congruent refcount oe 
note states ae ae dec dec oe ae ae dec dec oe congruent ae ae domain match multigraph isomorphism domains 
proofs main theorems induction interp ae dec dec oe oe states ae oe ae oe congruent 
putting steps see interp ae oe oe ii 
refcount oe 
similar previous case 
oe thunk ae 
cases depending count refcount oe refcount oe 
interp ae oe dec oe states ae dec oe ae dec oe congruent 
ii 
refcount oe 
similar previous case 
completes induction proof 
proof theorem recall section order prove correctness theorem needed definition unwind term store 
definition functions performing task valof valofcell appears table 
obvious definitions reachable cells affect value returned valof valofcell 
instance reachable store oe oe dec oe valofcell oe valofcell oe 
fact arguments follow 
essential proof theorem notion term evaluated 
section defines relation terms expresses relationship 
prove lemmas relationship canonical forms 
lemma canonical form canonical form 
shape numeral boolean store store 
proof cases consider delta nontrivial case canonical canonical 
second case canonical case delta true false delta store delta 
canonical shape lemma canonical form proof definition know order canonical case delta delta true false delta store delta 
case cases lemma canonical form proofs main theorems table definitions valof valofcell 
valof ae oe valofcell ae oe valof ae oe valof ae oe dom ae valof ae oe valof ae oe valof ae oe valof fetch ae oe fetch valof ae oe valof share ae oe share valof ae oe valof ae oe dom ae valof dispose ae oe dispose valof ae oe valof ae oe valof ae oe valof true ae oe true valof false ae oe false valof succ ae oe succ valof ae oe valof pred ae oe pred valof ae oe valof zero 
ae oe zero 
valof ae oe valof fix ae oe fix valof ae oe valof ae oe valof ae oe valof ae oe valof ae oe valof store ae oe store valof ae oe valof ae oe valof ae oe dom ae valofcell oe oe true oe true false oe false valof ae oe oe closure ae oe recclosure ae dom ae store valofcell oe oe susp valof ae oe oe thunk ae valof fix store ae oe oe rec oe recclosure ae 
dom ae proofs main theorems proof easy induction length lemma 
need similar definition state counting interpreter evaluated 
basically state evaluated tracing root set storable objects held nodes identical thunks replaced evaluated forms 
formally definition say ae oe ae oe reachable root set dom oe dom oe 
oe true false closure ae recclosure ae oe oe ae oe ae oe 
oe susp rec oe thunk oe susp oe oe 
oe susp oe thunk ae oe susp oe thunk ae ae oe ae oe oe susp oe thunk interp ae oe oe oe oe ae oe ae oe dom ae ae oe ae oe 
difficult prove reflexive transitive states 
difficult prove lemmas lemma suppose ae ae oe interp ae oe oe 
ae oe ae oe 
lemma valof ae oe ae ae oe ae ae oe valof ae oe 
proof easy induction number calls interp proof second easy induction definition valof 
machinery prove main correctness theorem 
theorem suppose typeable dom ae fv closed valof ae oe 
suppose ae ae oe 

interp ae oe oe valofcell oe 

interp ae oe oe valofcell oe 
proof part proven induction height proof consider cases core language leave cases pcf extensions reader 
ease readability various cases separate induction case cases variable canonical form 
cases seen immediately 
canonical form proofs main theorems variable form rules guarantees interp ae oe returns result oe valofcell oe valof ae oe 
lemma follows valofcell oe 
instance interp ae oe new closure ae oe oe 
ae ae oe dom oe new cell oe reached oe 
valofcell oe valof ae oe valof ae oe desired 
hand variable canonical form interpretation required counting interpreter 
divide cases depending rule proof 
case consider valof ae oe valof ae oe 
typeable free variables disjoint 
step evaluate operator operand 
induction interp ae oe oe valofcell oe 
need show really holds closure 
lemma valofcell oe shape 
ae ae ae oe theorem ae ae oe oe thunk 
possibility left oe closure ae recclosure ae need evaluate operand 
lemma know ae ae oe ae ae oe 
valof ae oe lemma valof ae oe 
induction hypothesis interp ae oe oe valofcell oe 
interp ae oe oe follows lemma ae oe ae oe oe closure ae recclosure ae evaluate application subcases refcount oe refcount oe 
case leave case reader 
refcount oe ae 
ae dec oe laws follows ae oe ae oe ae dec oe lemma valof ae 
dec oe 
induction interp ae 
dec oe oe proofs main theorems valofcell oe 
shows interp ae oe oe valofcell oe 

store store need consider case store valof oe valof ae oe 
typeable free variables disjoint 
valof ae oe induction interp ae oe oe valofcell oe 
lemma ae ae oe ae ae oe theorem ae ae oe 
valof ae oe lemma valof ae oe 
similar repeated applications induction hypothesis interp ae oe gamma oe valofcell oe lemma gamma ae oe gamma gamma ae oe ae 
new thunk ae oe oe new susp oe oe lemma find store valofcell oe desired 

fetch store case consider fetch valof ae oe 
induction interp ae oe oe store valofcell oe 
theorem ae oe 
store valofcell oe oe value follows lemma oe susp rec valofcell oe 
consider case oe susp leave case reader 
subcases oe thunk ae 
subcases proofs main theorems refcount oe 
note reachable ae state ae oe cycle composed solely rec recclosure contradicts regularity state valof ae dec dec oe laws ae ae dec dec oe 
follows induction interp ae dec dec oe oe valofcell oe desired 
ii 
refcount oe 
note reachable ae illegal cycle memory graph induced ae oe 
valof ae dec dec oe 
holds 
law ae ae dec dec oe 

follows induction interp ae dec dec oe 
oe valofcell oe 
reachable ae dec oe 
theorem follows reachable oe valofcell oe 
susp desired 
oe thunk ae 
valofcell oe value 
subcases refcount oe 
valofcell dec oe follows lemma valofcell dec oe 
ii 
refcount oe 
similar previous subcase omitted 

share case consider share valof ae oe valof ae oe 
typeable free variables disjoint 
valof ae oe follows induction interp ae oe oe valofcell oe 
lemmas valof ae oe theorem ae ae oe 
laws ae 
ae oe valof ae 
oe follows induction interp ae 
oe oe valofcell oe desired 
proofs main theorems 
dispose case similar previous case omitted 
completes proof part 
second part proven induction number calls interp 
consider cases core language leave cases pcf extensions reader 

interp ae oe ae oe oe 
note valofcell oe valof ae oe valofcell oe 
ae ae oe oe oe ae value valofcell oe canonical form 
lemma valofcell oe desired 


similar previous case 


interp ae oe oe follows interp ae oe oe interp ae oe oe oe closure ae recclosure ae valof ae oe closed valof ae oe valof ae oe 
induction valofcell oe valofcell oe lemmas valofcell oe 
oe closure valofcell oe abstraction lemma follows refcount oe valof ae 
dec oe 
hand refcount oe valof ae 
env ae dec oe 
case follows induction hypothesis valofcell oe conclude valofcell oe 

store 
evaluates interp ae oe oe interp ae oe oe 
interp ae oe gamma oe ae 
oe new thunk ae oe oe new susp oe proofs main theorems valof ae oe follows store valof oe valof ae oe 
induction valofcell oe 
evaluate term sequence note valof ae oe valof ae oe induction valofcell oe 
extending induction hypothesis yields valofcell oe 
note lemmas valof oe follows store valof ae oe valofcell oe valofcell oe desired 

fetch 
evaluates interp ae oe oe theorem ae oe 
valof ae oe follows fetch valof ae oe 
induction valofcell oe note oe susp rec consider case leave reader 
oe suspension follows lemma valofcell oe store store subcases oe thunk ae 
subcases depending count refcount oe 
interp ae dec dec oe oe 
state ae oe regular follows reachable ae illegal cycle memory graph induced valof ae oe valof ae dec oe induction valofcell oe valofcell oe desired ii 
refcount oe 
interp ae dec dec oe 
oe oe oe 
susp 
note state ae oe regular reachable ae illegal cycle memory graph induced valof ae oe valof ae dec dec oe 
induction valofcell oe proofs main theorems ae oe 
susp holds theorem accessible valofcell oe valofcell oe 
susp valofcell oe valofcell oe desired 
oe thunk ae 
case straightforward left reader 

share 
evaluates interp ae oe oe interp ae 
oe oe valof ae oe case share terms valof ae oe valof ae oe 
induction valofcell oe oe oe 
lemmas valof ae oe valof ae oe valof ae 
oe 
induction valofcell oe valofcell oe desired 

dispose 
similar previous case omitted 
completes proof second claim proof theorem 
proofs main theorems abr samson abramsky 
computational interpretations linear logic 
theoretical computer science 
appear 
ah abramsky hankin editors 
interpretation declarative languages 
ellis horwood 
app appel 
compiling continuations 
cambridge university press 
bak baker 
list processing real time serial computer 
communications acm 
benton bierman de paiva hyland 
term assignment intuitionistic linear logic 
announced types electronic mailing list 
bgs breazu tannen gunter scedrov 
computing coercions 
wand editor lisp functional programming pages 
acm 
bloss hudak young 
optimizing compiler modern functional programming language 
computer journal 
cgr chirimar carl gunter jon riecke 
proving memory management invariants language linear logic 
proceedings acm conference lisp functional programming pages 
acm 
col collins 
method overlapping erasure lists 
communications acm 
db deutsch bobrow 
efficient incremental automatic garbage collector 
communications acm 
des despeyroux 
proof translation natural semantics 
proceedings symposium logic computer science 
ieee 
gab gabriel 
performance evaluation lisp systems 
mit press 
gg goldberg 
polymorphic type reconstruction garbage collection tags 
clinger editor lisp functional programming pages 
acm 
gh juan guzm paul hudak 
single threaded polymorphic lambda calculus 
proceedings fifth annual ieee symposium logic computer science pages 
proofs main theorems gir jean yves girard 
linear logic 
theoretical computer sci 
glt jean yves girard yves lafont paul taylor 
proofs types 
cambridge university press 
gun gunter 
semantics programming languages structures techniques 
foundations computing 
mit press 
hol holmstrom 
linear functional programming 
johnsson peyton jones karlsson editors implementation lazy functional languages pages 
william howard 
formulae types notion construction 
hindley seldin editors curry essays combinatory logic lambda calculus formalism pages 
academic press 
hud hudak 
semantic model counting abstraction 
interpretation declarative languages pages 
ellis horwood 
preliminary version appeared proceedings acm conference lisp functional programming august pp 

kah gilles kahn 
natural semantics 
proceedings symposium theoretical aspects computer science volume lect 
notes computer sci new york 
springer verlag 
laf yves lafont 
linear machine 
theoretical computer sci 
lau launchbury 
natural semantics lazy evaluation 
graham editor conference record twentieth annual acm sigplan sigact symposium principles programming languages pages 
acm 
ld lawall danvy 
separating stages continuation passing style transformation 
graham editor conference record twentieth annual acm sigplan sigact symposium principles programming languages pages 
acm 
lm patrick lincoln john mitchell 
operational aspects linear lambda calculus 
proceedings seventh annual ieee symposium logic computer science pages 
mac mackie 
functional programming language linear logic 
master thesis university london 
mt milner tofte 
commentary standard ml 
mit press 
proofs main theorems mth milner tofte harper 
definition standard ml 
mit press 
hearn 
linear logic interference control preliminary report pitt editor category theory computer science volume lecture notes computer science pages berlin 
springer verlag 
plo gordon plotkin 
call name call value calculus 
theoretical computer sci 
plo gordon plotkin 
lcf considered programming language 
theoretical computer sci 
ps 
adequate operational semantics sharing lazy evaluation 
technical report psu cs pennsylvania state university 
sco scott 
type theoretical alternative cuch iswim 
unpublished manuscript 
wad wadler 
linear types change world 
broy jones editors programming concepts methods 
north holland 
wad wadler 
substitute linear logic 
manuscript 
wad philip wadler 
linear logic 
proceedings symposium partial evaluation semantics program manipulation pages 
acm 
wise hess hunt ost 
uniprocessor performance counting hardware heap 
unpublished manuscript 
win winskel 
formal semantics programming languages 
foundations computing 
mit press 
wo wand oliva 
proving correctness storage representations 
clinger editor lisp functional programming pages 
acm 
