fl kluwer academic publishers boston 
manufactured netherlands 
duplication partial evaluation better understanding reflective languages asai asai tokyo ac jp department information science faculty science university tokyo ku tokyo japan satoshi matsuoka ipl tokyo ac jp department mathematical engineering faculty engineering university tokyo ku tokyo japan akinori yonezawa yonezawa tokyo ac jp department information science faculty science university tokyo ku tokyo japan received october revised august march editor daniel friedman akinori yonezawa 
presents general implementation framework reflective languages 
allows systematically build reflective languages favorable properties user programs allowed access change parts metalevel interpreters reflective facilities available level exists conceptually infinite tower interpreters interpreter runs efficiently conventional directly implemented interpreter reflection 
scheme divided stages 
define interpreters give operational semantics level conceptually construct infinite tower interpreters 
duplicated obtain directly executed interpreters introducing double interpretation maintain interpreters 
partial evaluation employed collapse double interpretation single interpretation 
illustrate scheme implementing particular reflective language called black scheme general applied reflective languages 
gives complete scheme implementation black demonstrates examples 
show system delta abstraction introduced blond constructed framework 
keywords reflection partial evaluation interpreter direct execution interpretation infinite regression black black los 
reflective programming languages provide high flexibility extensibility allowing user programs access change language implementation semantics 
change language semantics conventional non reflective languages need fully understand low level implementation details carefully alter implementation interpreter compiler usually written lower level languages 
reflective languages allow modifications language framework high level abstractions understanding low level implementation 
flexibility extensibility reflection important practical purposes basis open implementation 
important characteristic reflective languages tower structure 
reflective languages user programs baselevel level interpreted interpreter running level level metalevel turn interpreted interpreter running level 
conceptually infinite tower interpreters 
reflective languages permit user programs execute programs level tower possibly accessing modifying interpreters upper levels 
infinite tower structure difficult implement reflective languages 
conventional lisp reflective languages brown blond tower simulated lazily creating interpreters directly executed machine interpretation level 
directly executed interpreters preferable efficiency impossible user programs alter parts interpreters selectively machine code form 
example suppose want modify metalevel interpreter prints expressions evaluates 
structure implementation metalevel interpreter available user programs achieve just inserting print function appropriate place interpreter code 
modifications possible brown blond interpreter directly executed available single monolithic function called meaning 
jefferson friedman hand simple reflective interpreter ir user programs allowed access change metalevel interpreters 
interpreter running level implemented ordinary user defined functions interpreted interpreter level freely redefine change subsequent behavior 
ir implemented executing interpreter top drawbacks extremely inefficient due double triple interpretation requires construction infinite tower want achieve reflection level 
highly flexible extensible reflective languages fulfill requirements 
user programs allowed access change parts metalevel interpreters 

reflective facilities available level 

interpreter runs efficiently reflection reasonably parts modified 
general framework implementation reflective languages satisfy requirements 
specific scheme divided stages 
define interpreters give operational semantics level conceptually construct infinite tower interpreters 
conventional reflective languages metalevel interpreters observed user programs confused actual implementation 
clear separation user observable interpreters implemented interpreters plays important role better understanding reflective languages 
duplicate interpreters obtain directly executed interpreters avoid infinite regression 
maintain interpreters infinite tower constructed 
level initially consist directly executed interpreter extra interpreter tentatively introducing inefficient double interpretation 
partial evaluation employed collapse double interpretation single interpretation 
resulting tower interpreters implementable finite resources lazy creation executes user programs efficiently single directly executed interpreter allows modification component interpreters 
practice create interpreters lazily 
obtained tower approximation original reflective tower exhibits reasonable favorable characteristics ffl satisfies requirements achieving sufficient flexibility efficiency 
ffl approximated fragments interpreter naturally understood directly executed compiled code interpreted code 
faithful implementation infinite tower imposes inefficiency due double triple interpretation dynamic compilation 
dynamic compilation partial evaluator interesting topic open research area discuss 
aim constructing static system flexibility efficiency obtained dynamic compilation 
illustrate scheme particular reflective language called black scheme general applied reflective languages 
fact delta abstraction introduced blond shown easily implementable framework 
organized follows 
section introduces black language metalevel interpreter defines operational semantics level 
sections discuss duplication partial evaluation respectively 
actual scheme implementation black section followed example black program executions section 
section describe system delta abstraction implemented framework 
related discussed section concludes section 
appendix shows black implementation code covered section 
comprise complete scheme interpreter black obtainable ftp camille tokyo ac jp pub black black tar 
reflective language black black scheme reflective language infinite tower interpreters brown blond 
contrast brown blond reifier takes baselevel expression environment continuation 
special reflective construct exec metalevel evaluates expression level 
executed level metalevel interpreter allowed access change metalevel interpreter ir nesting exec metalevel access change interpreter level 

metalevel interpreters observed user programs describe operational view language black define interpreters give initial operational semantics level 
standard continuation passing style cps scheme interpreters differences mentioned go examine definition detail 
define operational semantics level show user programs metalevel interpreters constructed giving way access change 
note interpreter shown section actual implementation black user observable 
actual implementation section executes user programs way regarded executed tower interpreters 
interpreter level consists functions variables shown figures appendices 
call evaluator functions collectively comprise evaluator 
main function named base eval distinguish eval scheme standard functions defined 
notable characteristics base eval handles exec special form lambda closures represented lists unique cons cell named lambda tag tag 
shows functions potentially cause related variables 
function eval em called base eval expression exec metalevel special form evaluates body metalevel primitive variant exec metalevel 
words reflection employed explain reflection 
natural consequence defining semantics language level semantics black language 
execution exec metalevel causes operations understood single level semantics explained magical way primitive em interpreter level 
base apply applies function arguments 
initially cause fact 
intuitively speaking downward occurs directly executed compiled evaluator functions define base eval exp env cont cond number 
exp cont exp boolean 
exp cont exp string 
exp cont exp symbol 
exp eval var exp env cont eq 
car exp quote eval quote exp env cont eq 
car exp eval exp env cont eq 
car exp set 
eval set 
exp env cont eq 
car exp lambda eval lambda exp env cont eq 
car exp eval exp env cont eq 
car exp exec metalevel eval em exp env cont eq 
car exp exit eval exit exp env cont eval application exp env cont define eval var exp env cont pair get exp env pair 
pair cont cdr pair error list eval var unbound variable exp env cont define eval quote exp env cont cont car cdr exp define eval exp env cont base eval car cdr exp env lambda pred pred base eval car cdr cdr exp env cont base eval car cdr cdr cdr exp env cont define eval set 
exp env cont var car cdr exp body car cdr cdr exp base eval body env lambda data pair get var env pair 
pair set value 
var data env cont var error list eval set unbound variable var env cont define lambda tag cons lambda tag define eval lambda exp env cont lambda body cdr cdr exp lambda params car cdr exp cont list lambda tag lambda params lambda body env define eval exp env cont eval body cdr exp env cont define eval body body env cont define eval local body null 
cdr body base eval car body env cont base eval car body env lambda eval local cdr body null 
body error eval body null body env cont eval local body 
standard functions observed user programs define eval exit exp env cont base eval car cdr exp env lambda error env cont define eval list exp env cont null 
exp cont base eval car exp env lambda val eval list cdr exp env lambda val cont cons val val define eval application exp env cont eval list exp env lambda base apply car cdr env cont define eval map fun lst env cont null 
lst cont base apply fun list car lst env lambda eval map fun cdr lst env lambda cont cons 
standard functions observed user programs continued define eval em exp env cont cont primitive em car cdr exp define base apply operator operand env cont cond procedure 
operator cond eq 
operator map eval map car operand car cdr operand env cont eq 
operator scheme apply base apply car operand car cdr operand env cont pair 
operator primitive procedures cont scheme apply operator operand evaluator functions cont scheme apply operator operand pair 
operator eq 
car operator lambda tag lambda params car cdr operator lambda body car cdr cdr operator lambda env car cdr cdr cdr operator eval body lambda body extend lambda env lambda params operand cont error list function operator env cont define old env define old cont define error exp env cont set 
old env env set 
old cont cont exp 
functions observed user programs define init cont env level turn cont cont lambda answer write level write write turn display primitive write answer newline write level write write turn display 
base eval read env lambda ans init cont env level turn lambda cont cont ans define run env level answer init cont env level lambda cont cont answer define init env list list cons car car cons cdr cdr cons cons cons cons list list cons pair 
pair 
cons null 
null 
cons cons eq 
eq 
cons eqv 
eqv 
cons equal 
equal 
cons set car 
set car 
cons set cdr 
set cdr 
cons append append cons newline newline cons read read cons write primitive write cons cons cons cons cons cons 
cons 
cons quotient quotient cons remainder remainder cons number 
number 
cons symbol 
symbol 
cons boolean 
boolean 
cons string 
string 
cons cons length length cons cons procedure 
primitive procedure 
cons map map cons scheme apply scheme apply cons empty env empty env cons pairs pairs cons extend extend cons set value 
set value 
cons get get cons define value define value cons copy copy cons get global env get global env cons base eval base eval cons eval var eval var cons eval quote eval quote cons eval eval cons lambda tag lambda tag cons eval lambda eval lambda cons eval eval cons eval body eval body cons eval set 
eval set 
cons eval em eval em cons eval exit eval exit cons eval application eval application cons eval list eval list cons base apply base apply cons error error cons eval map eval map cons init env filled cons init cont init cont cons run run cons old env old env cons old cont old cont cons primitive procedures primitive procedures define value init env copy init env init env 
bootstrapping functions observed user programs applied new level spawned 
clause top level cond base apply simply written procedure 
operator cont scheme apply operator operand write user observable interpreter need treat higher order functions evaluator functions separately distinguished clause exist standard interpreter actual implementation 
primitive procedures primitive functions redefined shown appendix 
error report error 
called eval exit 
simply ignores current continuation returns exp terminating level 
termination stores current environment continuation old env old cont respectively users resume execution typing old cont value 
shows bootstrapping functions initial environment 
level interpreter created executing run init env start starts read eval print loop defined init cont 
environment represented list frames association lists 
initial environment init env contains frame holds primitive functions evaluator functions define level 
init env name init env temporarily bound line bound copy init env 
thing notice init env primitives write procedure treat lambda closures appropriately bound primitive write primitive procedure appendix respectively 
environment manipulation functions shown appendix 
destructive operations lists set car 
set cdr 
realize baselevel side effects see set value 
define value 

structure reflective tower definition interpreter level tower structure black depicted 
thick lines connect functions call thin arrow indicates source interprets target 
initially user program runs level interpreted level interpreter turn interpreted level interpreter 
suppose execute program containing exec metalevel level 
body executed level level interpreter illustrated 
evaluator functions level uniformly interpreted ordinary user defined functions level interpreter level interpreter visible level environment 
freely access change symbolic names base eval eval var denote level interpreter envn omitting continuations simplicity 
black tower executing depicted infinite tower envn 
level level level level level level env env env env env env hj hj pq xx hj pq xx pq xx xx hj hj pq pq xx eval var base eval base apply eval var base eval base apply eval var base eval base apply eval var base eval base apply 

tower structure black 
notes strictly speaking interpreter reasons 
primitive em part defined language 
situation avoided took primitive em reflective construct black exec metalevel 
realized defining function define eval primitive em exp env cont base eval car cdr exp env lambda val cont primitive em val replacing corresponding clause base eval 
primitive em inherently introduces large amount dynamic behavior language 
primitive em allows dynamically construct metalevel code install dynamically exec metalevel allows dynamic installation statically known code 
causes problems constructing interpreter compiler language require dynamic compilation techniques 
employed exec metalevel retaining possibility static compilation 
reason non lack definitions special forms cond define 
easily programmed omitted brevity 

example program know structure interpreter level easily modify extend language 
achieved allowing user programs access set functions comprising interpreter 
consider example program changes metalevel interpreter exec metalevel 
consider program exec metalevel old eval base eval set 
base eval lambda exp env cont write exp newline old eval exp env cont program executed level expression 
executed level base eval eval var evaluator functions defined 
function base eval replaced closure displays expression evaluating 
functions eval example call base eval change new base eval called 
executing program obtain behavior 
cons cons cons level interpreter regarded defining operational semantics level language black effectively allows dynamically modify operational semantics language 

duplication tower interpreters previous section shown interpreter needs interpreted interpreter level causing infinite regression 
implement finite resources terminate regression run interpreter executable code interpreting interpreter level 
env env env env env env 
exact approach directly executable interpreter interpreter quite similar envn shape differs envn ways 
interpreted directly executed compiled 
secondly performs additional tasks lazy creation metalevel interpreters 
denote directly executed interpreter level envn calligraphic font clearly distinguish envn envn executable scheme program mimics execution envn envn interpreted contains magical construct primitive em 
regardless resemblance distinction original interpreter envn envn call duplication important 
fact slight inconsistency main issue section 

exact approach straightforward approach implementing infinite tower create interpreters lazily needed 
call approach exact faithful operational semantics envn shown section 
illustrates approach rectangles ovals represent directly executed code interpreted code respectively 
initially user program interpreted directly executed interpreter env 
exec metalevel executed env env created thereon env interpreted env 
consequence longer interpreted env doubly interpreted env env env env env env env env 
approximate approach case nested reflective constructs interpreters created interpreted stack interpreters reaches executable 
usually identical interpreters env env isomorphic executed simultaneously 
note envn distinct envn envn actual executing interpreter takes care lazy creation interpreters envn conceptual interpreter supposedly running giving semantics level 
approach faithful operational semantics envn yields quite inefficient interpreter 
reflection complete metalevel interpreter env created small part redefined 
way access efficient directly executed interpreter env unfortunate user programs usually change interpreters drastically small change leave parts unchanged 

approximate approach approximate approach hand provides access directly executed interpreters 
constructing metalevel interpreter envn directly executed interpreter envn user programs approximation envn illustrates scenario 
initially user program interpreted env just exact approach 
reflective construct executed run level env typically env environment created constructing env interpreted env result access evaluator functions efficient interpreter env furthermore execution efficiently interpreted env doubly env env accessing env may convert data representation env interpreted program env interpreting program different data representations 
blond conversion represented application shifting operators possible perform operations black time env interact desirable efficiency reasons especially presence side effects cyclic data structure 
done actual implementation blond conversion avoided data representation env approximate approach avoids double interpretation allows access directly executed interpreters works leaves side effects metalevel interpreter 
user programs redefine env reflection duplicated approximation env affected redefinition 
user programs illusion metalevel interpreter envn modification attempt envn cause inconsistency running interpreter interpreter user programs expect see 
say allowing access directly executed interpreters lose metalevel interpreters 

duplication sharing approach way re introduce directly resolve inconsistency 
envn redefined envn corresponding envn dynamically envn envn method interesting se involves dynamic compilation partial evaluator general scope 
approach take conservative better approximation tower interpreters 
simple approximate approach described previous section allow replacement evaluator functions tower approximated single interpreter envn interpreters approximate accurately making side effects effective 
may leads original problem inefficiency due double triple interpretation 
case exactly interpreters avoid partial evaluation discuss section 
illustrates approach partial evaluation applied 
initially user program doubly interpreted interpreters env env 
reflection env env created interpreted new interpreters possibly accessing env 
important thing notice environment env shared env env env contains bindings level interpreter env side effecting operations interpreted env changes env changes propagate env sharing correctly reflecting user env env env env env env env env env env env env 
approach modification level 
show double interpretation env env reduced single interpretation partial evaluation giving ability access directly executed interpreters redefine 
efficiency degradation due user modification minor modified env interpretation env env occurs modified code executed 
unmodified parts directly executed 
considering user modifications usually small benefit efficiency direct execution flexibility redefining metalevel interpreters 

evaluator functions primitives metalevel interpreter duplication sharing approximation reflective tower employed interpreters 
natural question ask sufficient 
words possible framework 
redefinition metalevel evaluator functions certainly allowed explained previous section 
function metalevel interpreter available user programs access redefinition 
enables example extend language adding new special forms change behavior language debugging purposes 
redefine metalevel interpreter long language program metalevel confined original scheme 
framework support side effects involve interactions level 
example side effects interpreter cause inconsistency suppose want modify behavior baselevel programs going levels redefining env evaluator functions env interpreted differently 
example debug tracing function application env possible exact version black way exec metalevel exec metalevel old eval application eval application set 
eval application lambda exp env cont write exp newline old eval application exp env cont unfortunately expected approach env modified sharing env env env env change env env distinct interpreters share env 
modification interpreted modified env expected interpreted env interpreted original env changes env affect metalevel user code behavior metalevel interpreter code env remains unchanged likewise baselevel program example traces printed user code level 
side effects interpreter effective accurate approximation interpreters 
duplicate env env get directly executed interpreter env share env env env changes env propagate env baselevel 
unfortunately eliminate triple interpretation partial evaluation techniques enable reduce double interpretation reducing single interpretation amount employing dynamic compilation 
discuss phenomenon section 
accept level approximation give side effects 
mean side effects meaningless 
behavior metalevel evaluator functions modified changing interpreter behavior metalevel user code modified 
example execution print trace 
metalevel evaluator functions replaced user defined code modification affect behavior replaced functions affect behavior baselevel programs 
leads natural view evaluator functions compiled executed primitive functions 
section stated evaluator functions supposed interpreted interpreter level 
longer interpreted directly executed primitive compiled functions 
behavior clearly defined section executed black boxes 
words replace evaluator functions user defined functions manipulate internal execution 
env env env env env env env env env 
interpreters approximation note accepted black boxes standard scheme libraries 
example consider map scheme behavior map clearly defined define map fun lst null 
lst cons fun car lst map fun cdr lst usually compiled primitive 
define slightly different version map replace original map change original map 

partial evaluation infinite tower interpreters shown implementable duplication sharing resulting interpreter quite slow due double interpretation user program level interpreted interpreters envn envn 
remove double interpretation employ partial evaluation techniques 
knowing envn envn change env env env env env env 
tower interpreters partial evaluation specialize envn argument envn partial evaluation treat env dynamic unknown value changes environment remain effective 
effect partial evaluation significant result partial evaluation envn envn function exactly envn envn structure similar envn contains accesses envn runs efficiently envn directly implemented version envn shows structure tower partial evaluation 
contrast user programs interpreted interpreters 
note envn envn allows redefinitions evaluator functions 
operationally exactly 
partial evaluation perform manual due technical reasons see section 
actual partial evaluator partially evaluate simple examples manually derive portions envn envn examples provide sufficient information construct envn env fully section 

basic idea partial evaluator function takes program necessarily arguments returns program specialized known arguments 
program arguments partial evaluator executes program possible leaving computation unknown inputs programs executed runtime 
output program called residual pro gram typically runs faster original program specified inputs performed partial evaluation time computation uses known arguments 
partial evaluator collapse envn envn envn env envn basically interpreter result partially evaluating envn envn envn envn regarded known value 
envn shared envn envn may modified implicitly envn partially evaluate accesses env result accesses resulting interpreter envn envn structure envn explicit accesses envn places envn implicitly accessed envn interpreted envn 
examples partial evaluation see accesses envn examine simple examples 
partially evaluate envn base eval exp env cont 
partial evaluation proceeds unfolding evaluator functions envn argument envn application eval application envn executed call eval list 
evaluates base eval exp env cont envn evaluation base eval eval var called produce residual code cdr get base eval envn envn unknown partial evaluation time obtain value base eval 
eval list base apply called generate code applies cdr get base eval env arguments 
assuming continuation envn cont result follows proc cdr get base eval envn cond procedure 
proc scheme apply proc list exp env cont pair 
proc eq 
car proc lambda tag lambda params car cdr proc lambda body car cdr cdr proc lambda env car cdr cdr cdr proc eval body lambda body extend lambda env lambda params list exp env cont error list function proc envn result quite similar base apply looks env define meta follows environment lookup subsequent application define meta proc name args proc cdr get proc name envn cond procedure 
proc scheme apply proc args pair 
proc eq 
car proc lambda tag lambda params car cdr proc lambda body car cdr cdr proc lambda env car cdr cdr cdr proc eval body lambda body extend lambda env lambda params args error list function proc envn rewrite result follows meta base eval exp env cont abstracting meta observe result just structure original expression presence meta meta 
quite similar base apply envn looks metalevel environment envn obtain value base eval 
note environment access performed partial evaluation time 
value base eval obtained applied normally base apply value base eval executable function identified procedure 
primitive meta simply applies arguments 
value user defined function means base eval replaced user calls envn eval body interpret user defined base eval correctly 
words meta effectively encapsulates tasks necessary metalevel maintain changeability property evaluator functions 
see example 
specializing envn respect eval base eval car cdr exp env lambda pred pred base eval car cdr cdr exp env cont base eval car cdr cdr cdr exp env cont get meta base eval car cdr exp env lambda pred pred meta base eval car cdr cdr exp env cont meta base eval car cdr cdr cdr exp env cont structure result just original definition eval meta value evaluator functions may user defined functions partial evaluator code envn meta apply sensitive redefinition 
important observations examples 
obtain envn envn just inserting meta appropriate places 
code necessary evaluator functions replaceable meta secondly resulting envn envn runs far efficiently envn envn meta apply applies evaluator functions immediately redefined envn envn runs efficiently envn allows redefine evaluator functions 
say view meta hooks realize redefinition evaluator functions 
conventional reflective systems hooks inserted ad hoc manner 
succeeded deriving hooks schematic way duplicating partially evaluating interpreters giving proper semantic account 
knowing meta serve hooks various versions envn envn doing partial evaluation 
inserting meta specified function calls obtain efficient interpreter contains hooks necessary places 
example meta inserted primitive function calls car cdr usually section insert meta calls cps evaluator functions want interpreter general purpose assumption metalevel interpreter usually changed 
practice insert interesting parts prevent unnecessary hooks 
example removing meta apply call eval var base eval provides interpreter eval var 
function calls executed efficiently hooks 
sufficient eval var function interested note hooks difficult reduce triple interpretation single interpretation 
result partially evaluating interpreters contains hook function application 
hooks unfolded runtime partial evaluation respect interpreter progress entire interpreters 

notes automatic partial evaluation actual partial evaluator partially evaluated envn envn manually obtain envn envn mainly reasons 
envn contains special construct primitive em eval em treat specially correctly coordinate levels making fully automatic partial evaluation difficult 
secondly user defined lambda closures represented lists envn partially evaluating envn respect evaluator function envn yield lambda closure representing reified data structure plain list containing parameters body captured environment 
example suppose specialize envn respect eval quote envn lambda exp env cont cont car cdr exp 
element expression lambda eval lambda envn called evaluate expression immediately return data structure representation lambda closure lambda tag exp env cont cont car cdr exp envn convert actual executable lambda closure need know decomposed executed eval body base apply lambda closure 
automatically extracting knowledge incorporating existing partial evaluators difficult 
current goal partial evaluator obtain information constructing envn envn manually believe current approach sufficient 
obtain envn env partial evaluator black employ dynamic compilation 

implementation black shall concrete implementation black scheme 
section appendix gives complete implementation black 
previous sections shown black interpreter implemented lazily creating envn envn actual strategy employed lazily create metacontinuation envn envn 
metacontinuation proposed brown refined blond provides convenient means maintaining information levels tower 
enables share evaluator functions envn env leads simpler clearer implementation 

metacontinuation metacontinuation infinite list pairs environment continuation 
mcont env cont mcont intuitively holds environments continuations current level 
environment continuation level envn cont respectively 
baselevel metacontinuation written env cont env cont structure shift tower obtain metacontinuation level simply removing element 
likewise shift tower obtain metacontinuation level consing current environment continuation 
metacontinuation infinite list practice employ stream lazy list implementation 
cons stream initial metacontinuation defined follows 
see section precise definition init mcont 
define init mcont cons stream list copy init env init cont init mcont shifting level implemented replacing current metacontinuation mcont tail mcont shifting level achieved replacing mcont cons stream list env cont mcont env cont represent current level environment continuation respectively 

evaluator functions implement black interpreter create common interpreter shared levels 
interpreter generate envn env instantiating appropriate metacontinuation level result type evaluator functions exp env cont mcont answer mcont domain 
initially consider evaluator functions shift levels 
play roles implicit reduction 
analogous stores denotational semantics explicit functions side effects 
appendix shows evaluator functions shift levels 
resemble corresponding functions envn simply obtained inserting meta apply applications cont cps evaluator functions 
cases applied functions userdefined lambda closures meta apply invokes task metalevel interpretation 
code meta apply differs section 
see section details 
note scheme implementation black interpreter observed user programs exec metalevel 
observed interpreter envn shown section merely implement black scheme visible user programs occurs 

evaluator functions consider evaluator functions require 
function eval em defined follows metacontinuation cont value 
mcont 
answer functions exp env cont 
mcont 
answer meta apply symbol proc list values 
mcont 
answer define base eval exp env cont cond number 
exp meta apply cont exp boolean 
exp meta apply cont exp string 
exp meta apply cont exp symbol 
exp meta apply eval var exp env cont eq 
car exp quote meta apply eval quote exp env cont eq 
car exp meta apply eval exp env cont eq 
car exp set 
meta apply eval set 
exp env cont eq 
car exp lambda meta apply eval lambda exp env cont eq 
car exp meta apply eval exp env cont eq 
car exp exec metalevel meta apply eval em exp env cont eq 
car exp exit meta apply eval exit exp env cont meta apply eval application exp env cont define eval var exp env cont pair get exp env pair 
pair meta apply cont cdr pair meta apply error list eval var unbound variable exp env cont define eval quote exp env cont meta apply cont car cdr exp define eval exp env cont meta apply base eval car cdr exp env lambda pred pred meta apply base eval car cdr cdr exp env cont meta apply base eval car cdr cdr cdr exp env cont define eval set 
exp env cont var car cdr exp body car cdr cdr exp meta apply base eval body env lambda data pair get var env pair 
pair set value 
var data env meta apply cont var meta apply error list eval set unbound variable var env cont define lambda tag cons lambda tag define eval lambda exp env cont lambda body cdr cdr exp lambda params car cdr exp meta apply cont list lambda tag lambda params lambda body env 
evaluator functions eval em exp env cont 
mcont 
answer meta apply symbol proc list values 
mcont 
answer define eval em exp env cont lambda mcont meta env car head mcont meta cont car cdr head mcont meta mcont tail mcont meta apply base eval car cdr exp meta env lambda ans lambda mcont meta apply cont ans cons stream head mcont mcont meta mcont notice eval em receives metacontinuation mcont explicitly extracts metalevel environment continuation metacontinuation level body argument exec metalevel evaluated meta env meta mcont metalevel 
side effects metalevel execution meta env modified replace metalevel evaluator functions subsequent interpretation 
recall meta env env section looked determine evaluator functions run execution baselevel programs 
executing body result applied cont time metalevel environment continuation pushed back metacontinuation computation continues baselevel 
switching body exec metalevel correctly executed metalevel 
consider function base apply 
base apply involve explicit reflective operations necessary fact base apply proc list values env cont 
mcont 
answer define base apply operator operand env cont cond procedure 
operator cond eq 
operator map meta apply eval map car operand car cdr operand env cont eq 
operator scheme apply meta apply base apply car operand car cdr operand env cont pair 
operator primitive procedures meta apply cont scheme apply operator operand evaluator functions lambda mcont scheme apply operator operand cons stream list get global env env cont mcont pair 
operator eq 
car operator lambda tag lambda params car cdr operator lambda body car cdr cdr operator lambda env car cdr cdr cdr operator meta apply eval body lambda body extend lambda env lambda params operand cont meta apply error list function operator env cont structure base apply base apply envn insertion meta apply 
major difference related clause inner cond statement 
standard scheme interpreter clause selected operator procedure higher order functions handle map scheme apply primitive procedures 
evaluator functions black directly executed primitives 
occurs application evaluator functions base apply requires shifting level 
consider situation base eval level replaced user defined lambda closure 
rectangles ovals denote directly executed functions interpreted functions respectively 
replaced base eval interpreted level interpreter evaluator functions level directly executed 
suppose user defined base eval level calls default directly executed evaluator function eval var executing eval var exp env cont 
application level interpreter running execute user defined base eval application level evaluator function eval var running requiring downward 
observe closely eval var exp env cont interpreted level understand base apply expression passed level base eval clause selected call level 
calls eval list evaluate eval var exp env cont level base apply called apply eval var 
eval var lambda closure level evaluator function clause base apply selected 
metacontinuation received explicitly global environment current continuation placed 
application computation proceeds level 
put global environment current environment metacontinuation required 
case environments metacontinuation extracted going level eval em meta apply 
cases execution starts global environment environment captured closure applied 
level level level hj hj eval var base eval base apply eval var base eval base apply 

tower structure base eval level replaced 
meta apply meta apply apply arguments function appropriately calling metalevel interpreter necessary 
meta apply operational semantics envn result partial evaluation invisible user programs exclusively black language implementation default evaluator functions 
meta apply symbol proc list values 
mcont 
answer define meta apply proc name cont operand lambda mcont meta env car head mcont meta cont car cdr head mcont meta mcont tail mcont operator symbol 
proc name cont cdr get proc name cont meta env proc name cont cond procedure 
operator pair 
operator primitive procedures meta apply base apply operator operand meta env meta cont meta mcont scheme apply operator operand evaluator functions mcont meta apply base apply operator operand meta env meta cont meta mcont code meta apply simple compared base apply delegates task application metalevel base apply cases 
extracting metalevel environment continuation metacontinuation metacontinuation statement meta apply looks operator metalevel environment 
check proc name cont symbol meta apply apply cont evaluator functions 
proc name cont passed symbol indicates argument cont cont function directly executable function lambda closure need lookup environment operator meta apply branches evaluator function 
operator evaluator function directly applied level 
hand operator turns evaluator function indicates evaluator function modified user programs 
primitive function user defined lambda closure inapplicable object case error occur 
cases delegate metalevel base apply handle appropriately metalevel 
note application evaluator functions delegated metalevel base apply cause infinite regression 
move error define old env define old cont error exp env cont 
mcont 
answer define error exp env cont lambda mcont meta env car head mcont meta cont car cdr head mcont meta mcont tail mcont set value 
old env env meta env set value 
old cont cont meta env meta apply meta cont exp meta mcont termination level implemented applying metalevel continuation meta cont metalevel metacontinuation meta mcont throwing away current continuation cont 
store value current environment continuation metalevel environment meta env set value 
observe statement set 
old env env appeared eval exit envn simulated 
regard result partially evaluating envn respect set 
statement 

bootstrapping functions show definition bootstrapping functions miscellaneous functions complete implementation black 
bootstrapping functions interpreter level simple 
init cont run obtained simply inserting meta apply appendix 
init env identical envn shown 
environment manipulation functions functions identical ones envn see appendices 
remaining functions bootstrapping tower interpreters 
black system booted constructing metacontinuation executing continuation define black base mcont init mcont copy init env env car head base mcont cont car cdr head base mcont mcont tail base mcont cont start mcont metacontinuation base mcont constructed calling init mcont returns metacontinuation level level define init mcont level env env copy init env cons stream list env meta init cont env level env init mcont level env env environment level sharing environments done meta init cont define meta init cont env level env define value init env env env share env display new level loaded newline lambda result meta apply run env level result meta init cont returns initial continuation initiates level running run 
creating level sets init env current environment environment contains directly executed evaluator functions visible user programs 

example execution section demonstrate example executions black 

black new level loaded 
new level loaded 
new level loaded 
start 
cons 
prompt shows level number iterations level usual 
see top levels metacontinuation initially expanded 
need execution metalevel interpreter requires environment examined metalevel interpreter modified 
third left unexpanded lazy lists cons stream implemented hold promises thunks tail part head part tail part 
input trace program section 

exec metalevel old eval base eval set 
base eval lambda exp env cont write trace write exp newline old eval exp env cont new level loaded 
base eval 
see new level created lazily 
traces displayed expected 

car cons trace car cons trace car trace cons trace cons trace trace 
confirm base eval level redefined exiting level 

exit bye trace exit bye trace bye bye 
new level created created 

base eval lambda exp env cont write trace write exp newline old eval exp env cont 
level interpreter running traces longer displayed 
confirm base eval level redefined observe binding old eval base eval 
inspect environment captured lambda closure install level new special forms break inspect changing level interpreter 
break opens read eval print loop environment break executed argument evaluates true 
similarly inspect opens loop captured environment argument closure 
enable set breakpoints program navigate environments inspect value variables 

exec metalevel load break blk new level loaded 
done 
inspect see value old eval base eval 

inspect base eval inspect loop inspect 
base eval lambda exp env cont write trace write exp newline old eval exp env cont inspect 
old eval compound procedure base eval inspect 
exit bye inspect bye 
exit inspect loop simply exit 
continuation level stored old cont resume execution level calling 

old cont hello hello 
observe prompt says 
level hello regarded return value exit bye input prompt 
level traces displayed 

trace trace trace trace 
inspect installed level 
inspect base eval trace inspect base eval trace inspect eval var unbound variable inspect 
define loop prompt env ans write ans newline display prompt display 
base eval read env lambda ans loop prompt env ans define eval break pred env cont define run break loop result loop break env break loop write break newline cont result null 
pred run break loop base eval car pred env lambda pred pred run break loop cont define eval inspect closure env cont base eval closure env lambda closure lambda env car cdr cdr cdr closure result loop inspect lambda env inspect loop write inspect newline cont result original eval application eval application set 
eval application lambda exp env cont cond eq 
car exp break eval break cdr exp env cont eq 
car exp inspect eval inspect car cdr exp env cont original eval application exp env cont 
new special forms break inspect break blk note error causes 
errors just way exit level error message exit value 

implementing delta abstraction implementation framework limited constructing black 
define different language delta abstraction introduced blond exec metalevel show interpreter constructed implementation framework 
delta abstraction reflective procedure reifier receives current expression environment continuation arguments evaluates body metalevel 
differs exec metalevel explicitly receives baselevel information enables extend language modifying metalevel interpreter 
example current expression passed unevaluated form define bound 
special form returns true argument bound false follows define bound 
delta exp env cont cont pair 
get car exp env manipulating continuations define various variants call cc delta abstraction 

interpreter observed user programs build system delta abstractions framework define interpreter observed user programs 
envn obtain making small changes envn new clause added cond statement base eval handle delta special form eq 
car exp delta eval delta exp env cont eval delta returns list representing delta abstraction unique cons cell delta tag just eval lambda uses lambda tag represent lambda abstraction 
define delta tag cons delta tag define eval delta exp env cont delta body cdr cdr exp delta params car cdr exp cont list delta tag delta params delta body eval application able handle delta abstractions 
define eval application exp env cont base eval car exp env lambda operator pair 
operator eq 
car operator delta tag apply delta operator cdr exp env cont eval list cdr exp env lambda operand base apply operator operand env cont evaluating function arguments parts exp evaluates function part branches 
delta abstraction calls apply delta evaluating arguments part 
evaluates arguments part calls base apply 
function apply delta evaluate body delta abstractions metalevel defined directly delta abstractions operators 
defining define application delta abstractions handled apply delta 
know internal execution evaluator functions invisible define apply delta black box procedure 
similar case eval em envn original black 
register newly introduced functions variable init env 
add bindings init env cons delta tag delta tag cons eval delta eval delta cons apply delta apply delta 
implementation having defined interpreter observed user programs straightforward obtain implementation 
cases simply insert meta apply 
clause inserted base eval eq 
car exp delta meta apply eval delta exp env cont new evaluator functions define eval application exp env cont meta apply base eval car exp env lambda operator pair 
operator eq 
car operator delta tag meta apply apply delta operator cdr exp env cont meta apply eval list cdr exp env lambda operand meta apply base apply operator operand env cont define delta tag cons delta tag define eval delta exp env cont delta body cdr cdr exp delta params car cdr exp meta apply cont list delta tag delta params delta body apply delta needs metacontinuation define apply delta operator operand env cont lambda mcont meta env car head mcont meta cont car cdr head mcont meta mcont tail mcont delta params car cdr operator delta body car cdr cdr operator meta apply eval body delta body extend meta env delta params list operand env cont meta cont meta mcont meta env meta cont extracted metacontinuation body delta abstraction evaluated meta cont meta env extended baselevel information 
bindings user views registered init env 
implementation delta abstraction allows side effects metalevel interpreters meta apply call evaluator functions 
contrast blond way extend language define reifier baselevel 
disable side effects framework just throw away meta apply take simple approximate approach shown section 
related black originally designed clarify various semantic aspects rscheme strongly influenced rscheme 
black rscheme default evaluator functions directly executed replaced freely user defined functions 
contribution black general implementation framework 
rscheme replacement evaluator functions achieved indirection table called system object table sot 
sot ad hoc addition metalevel interpreter semantic significance necessity clear 
duplication partial evaluation infinite reflective tower shown sot semantically subsumed metalevel environment 
jefferson friedman implemented finite reflective tower ir executing interpreter top 
ir provides high flexibility black rscheme suffers extreme execution overhead furthermore implements finite account tower 
duplicating partially evaluating interpreter obtain infinite reflective tower directly executable 
global environment shared levels ir efficiency considerations black level global environment independent customization 
reflective language allows redefinition interpreters direct execution 
divides interpreter parts called prelim dispatch allows access redefinition user 
language considered special instance framework user visible interpreter consists just prelim dispatch 
framework divide interpreter arbitrary way inserting meta apply appropriate places 
particular black implemented cps evaluator functions exposed user programs access redefinition 
introduced brown refined blond 
systems achieved infinite tower directly executed interpreters black 
allow redefinition interpreter assumption identical interpreter runs levels 
limits changes extensions possible 
black allows freely redefine evaluator functions simultaneously achieving direct execution default interpreters 
framework brown blond understood sharing original duplication 
metalevel environment shared compiled away partial evaluation time inconsistency arises side effects ignored 
lisp pioneering lisp reflective languages 
implementation complex clearly explained 
global environment lisp shared levels impossible replace evaluator function particular level 
conjecture lisp interpreter similar black interpreter implemented 

shown staged general framework implementation reflective languages construction interpreter level duplication partial evaluation 
resulting languages favorable properties ffl user programs allowed access change metalevel interpreters 
ffl reflective facilities available level 
ffl interpreter runs efficiently direct execution 
interpreter obtained scheme approximation reflective tower gives consistent natural view reflective tower regarding evaluator functions compiled primitives 
scheme implemented reflective language black demonstrated examples 
framework shown simple general help understanding various reflective languages 
fact shown delta abstraction blond realized framework 
major challenge undertaking compilation modified metalevel interpreter partial evaluation techniques 
employ dynamic compilation interpreters get slower drastically modified 
partially evaluating metalevel interpreter respect modified interpreter hope obtain modified interpreter directly executable 
lead compilation reflective programs 
acknowledgments grateful suggestions extensive discussions reflection 
olivier danvy daniel friedman john simmons ii carolyn talcott watanabe shigeru chiba jeff helpful comments 
anonymous referees precise comments criticisms helped considerably improve 
notes 
em abbreviation exec metalevel 

term primitive arguments evaluated application 
note exec metalevel special form evaluate body 
eval em exec metalevel expression evaluated metalevel value car cdr exp car cdr exp 

scheme apply apply underlying scheme applies function arguments 
name apply confusing presence base apply meta apply appears 

say basically env contains additional code lazy creation interpreters section assume envn contains operations primitive em eval em ignore code 
eval em needs special treatment described section 
ignore case base eval unbound envn 
reason primitive functions written cps meta directly need inline code eval 
primitive functions user observable interpreter written cps obtain result inserting meta 
argument applies evaluator functions written direct style include environment manipulation functions get extend shown appendix 
suppose want trace variable accesses 

correctly compiled version internal behavior modified changing metalevel interpreter 

confuse similarly named variables mcont meta cont meta mcont 
mcont metacontinuation baselevel holds information levels baselevel meta cont continuation metalevel interpreter meta mcont metacontinuation metalevel holds information levels metalevel 

notice proc name cont symbol ignore case unbound meta env done section 
justified unbound meta apply exclusively application evaluator functions registered init env 

eval inspect installed level error occur expression eval inspect assumes argument lambda closure 

assuming continuations 

implementation delta abstractions section obtainable ftp 

abelson sussman sussman structure interpretation computer programs cambridge mit press 

danvy intensions extensions reflective tower conference record acm symposium lisp functional programming pp 
july 

des rivi eres private communication september 

des rivi eres smith implementation procedurally reflective languages conference record acm symposium lisp functional programming pp 
august 

friedman wand reification reflection metaphysics conference record acm symposium lisp functional programming pp 
august 

matsuoka yonezawa reflective object oriented concurrent language run time kernel proceedings international workshop reflection meta level architecture pp 
november 

jefferson friedman simple reflective interpreter proceedings international workshop reflection meta level architecture pp 
november extended version appears volume 

jones gomard sestoft partial evaluation automatic program generation new york prentice hall 

kiczales new model abstraction software engineering proceedings international workshop reflection meta level architecture pp 
november 

rees clinger revised report algorithmic language scheme sigplan notice vol 
december 

simmons ii jefferson friedman language extension class interpreters indiana university technical report september 

smith reflection semantics lisp conference record th annual acm symposium principles programming languages pp 
january 

wand friedman mystery tower revealed non reflective description reflective tower conference record acm symposium lisp functional programming pp 
august 
appendix appendix contains code appear main body 
code section appendix comprise complete scheme implementation black obtained ftp camille 
ac jp pub black black tar start black load code section section appendix invoke black defining scheme apply define scheme apply apply note primitive functions environment manipulation functions actual implementation part user observable interpreter envn 
primitive functions primitive functions procedure 
write redefined treat lambda closures appropriately 
define primitive procedure 
operand arg car operand procedure 
arg pair 
arg eq 
car arg lambda tag define primitive write arg pair 
arg eq 
car arg lambda tag lambda params car cdr arg lambda body car cdr cdr arg lambda env car cdr cdr cdr arg write cons lambda cons lambda params lambda body write arg define primitive procedures list car cdr cons list pair 
null 
eq 
eqv 
equal 
set car 
set cdr 
append newline read primitive write 
quotient remainder number 
symbol 
boolean 
string 
length primitive procedure 
map scheme apply pairs extend get set value 
define value copy get global env 
environment manipulation functions environments represented list frames association lists 
destructive operations lists set car 
set cdr 
realize define set 
define empty env define pairs params args cond null 
params symbol 
params list cons params args cons cons car params car args pairs cdr params cdr args define extend env params args cons pairs params args env define get var env null 
env pair var car env pair 
pair pair get var cdr env define set value 
var value env pair get var env pair 
pair set cdr 
pair value define define value var value env pair var car env pair 
pair set cdr 
pair value set car 
env cons cons var value car env define copy env define copy local env null 
env cons cons car car env cdr car env copy local cdr env null 
env cons copy local car env copy cdr env define get global env env define get global env local env null 
cdr env env get global env local cdr env null 
env env get global env local env 
evaluator functions functions obtained simply inserting meta apply corresponding functions envn evaluator functions exp env cont 
mcont 
answer define eval exp env cont meta apply eval body cdr exp env cont define eval body body env cont define eval local body null 
cdr body meta apply base eval car body env cont meta apply base eval car body env lambda eval local cdr body null 
body meta apply error eval body null body env cont eval local body define eval exit exp env cont meta apply base eval car cdr exp env lambda meta apply error env cont define eval list exp env cont null 
exp meta apply cont meta apply base eval car exp env lambda val meta apply eval list cdr exp env lambda val meta apply cont cons val val define eval application exp env cont meta apply eval list exp env lambda meta apply base apply car cdr env cont define eval map fun lst env cont null 
lst meta apply cont meta apply base apply fun list car lst env lambda meta apply eval map fun cdr lst env lambda meta apply cont cons init cont env number number cont 
mcont 
answer define init cont env level turn cont meta apply cont lambda answer write level write write turn display primitive write answer newline write level write write turn display 
meta apply base eval read env lambda ans meta apply init cont env level turn lambda cont meta apply cont ans run env number value 
mcont 
answer define run env level answer meta apply init cont env level lambda cont meta apply cont answer 
