efficient extensible algorithms multi query optimization roy bombay seshadri bell labs 
sudarshan bombay complex queries commonplace growing decision support systems 
complex queries lot common sub expressions single query multiple queries run batch 
multi query optimization aims exploiting common subexpressions reduce evaluation cost 
multi query optimization viewed impractical earlier algorithms exhaustive explore doubly exponential search space 
demonstrate multi query optimization heuristics practical provides significant benefits 
propose cost heuristic algorithms volcano sh volcano ru simple modifications volcano search strategy greedy heuristic 
greedy heuristic incorporates novel optimizations improve efficiency greatly 
algorithms designed easily added existing optimizers 
performance study comparing algorithms workloads consisting queries tpc benchmark 
study shows algorithms provide significant benefits traditional optimization acceptable overhead optimization time 
complex queries commonplace especially due advent automatic tools help analyze information large data warehouses 
complex queries lot common subexpressions extensive views referred multiple times query ii correlated nested queries parts inner subquery may depend outer query variables forming common sub expression repeated invocations inner query 
scope finding common sub expressions increases greatly consider set queries executed batch 
example sql stored procedures may invoke queries executed batch data analysis reporting requires batch queries executed 
task updating set related materialized views feature increasingly supported commercial systems generates related queries common sub expressions 
address problem optimizing queries common sub expressions known multi query optimization 
traditional query optimizers appropriate optimizing queries common sub expressions locally optimal choices may globally optimal plans example demonstrates 
example queries locally optimal plans individual best plans respectively 
best plans common sub expressions 
choose plan may locally optimal clear common sub expression computed queries may globally optimal choice 
hand blindly common sub expression may lead globally optimal strategy 
example cost joining expression enormous compared cost plan may sense reuse available 
example illustrates job multi query optimization ordinary query optimization recognize possibilities shared computation ii modify optimizer search strategy explicitly account shared computation find globally optimal plan 
multi query optimization past sel ssn sg cls ps prior concentrated primarily exhaustive algorithms 
concentrated finding common subexpressions post phase query optimization fin sv gives limited scope cost improvement 
discuss related detail section 
search space optimization doubly exponential size queries exhaustive strategies impractical result multi query optimization hitherto considered expensive useful 
show multi query optimization practical developing novel heuristics presenting performance study demonstrates practical benefits 
dag representation rou rr gm compactly represents alternative query plans 
algorithm constructing dag algebraic transformations volcano optimization algorithm gm making approach extensible 
novel aspect dag construction algorithm lies ensures common sub expressions detected unified ii takes account sharing computation subsumption examples sharing include computing oe result oe 
novel heuristic search algorithms explicitly account shared computation identifying subexpressions materialized shared 
heuristics volcano ru lightweight modifications volcano optimization algorithm 
third heuristic greedy strategy iteratively picks subexpression gives maximum reduction cost materialized reused 
important contributions lies novel optimizations greedy algorithm implementation efficient 
addition choosing intermediate expression results materialize reuse optimization framework chooses physical properties sort order materialized results 
algorithms handle choice temporary indices create materialized results database relations 
show perform multi query optimization nested queries multiple invocations parameterized queries different parameter values 
believe main contribution showing engineer system smoothly integrate extensions allowing seamlessly 
implemented commutativity shown join node join node inputs exchanged equivalence node expanded dag transformations initial query dag representation query initial query dag representations query optimizer volcano optimization framework modified implement multi query optimization algorithms additional effort lines code 
conducted performance study multi query optimization algorithms queries tpc benchmark queries tpc schema 
study presents savings estimated cost actual run times commercial database queries 
performance results show multi query optimization algorithms give significant benefits single query optimization acceptable extra optimization time cost 
extra optimization time compensated execution time savings 
heuristics beat basic volcano algorithm general greedy produced best plans followed volcano ru volcano sh 
dag representation queries section describe dag representation queries 
dag directed acyclic graph nodes divided nodes nodes nodes children nodes nodes children 
node dag corresponds algebraic operation join operation select operation oe 
represents expression defined operation inputs 
refer nodes operation nodes 
node represents set logical expressions generate result set set expressions defined children nodes node inputs 
shall refer nodes equivalence nodes henceforth 
query tree initially represented directly dag formulation 
example query tree initially represented dag formulation shown 
equivalence nodes nodes shown boxes operation nodes nodes shown circles 
initial expanded similar gm applying possible transformations node initial query dag representing set queries 
suppose transforma tions possible join associativity commutativity 
plans plans equivalent modulo commutativity obtained transformations initial dag 
represented dag shown 
shall refer dag transformations applied expanded dag 
note expanded dag exactly equivalence node subset fa cg node represents ways computing joins relations subset 
details expansion step appendix extensions dag generation multi query optimization section outline novel extensions dag generation algorithm aid multi query optimization 
describe extensions briefly details appendix appendix extension deals identification common subexpressions 
query contains subexpressions logically equivalent syntactically different initial query dag contain different equivalence nodes representing subexpressions 
dag expansion dag generation algorithm find nodes equivalent unify nodes replacing single equivalence node 
unification step novel compared volcano gm 
second extension detect handle subsumption 
example suppose subexpressions oe oe appear query 
result obtained result additional selection oe oe oe 
represent possibility add extra operation node oe dag 
similarly oe oe introduce new equivalence node oe add new derivations 
new node represents sharing accesses selection 
similar derivations help aggregations 
example dno sum sal age sum sal introduce new equivalence node dno age sum sal add derivations equivalence node dno age 
dag generation algorithm introduces new equivalence nodes operations takes care avoid combinatorial explosions number nodes 
idea sharing computation ways similar proposed earlier rou sel sv contribution engineering contribution showing integrate dag expansion allowing search components multi query optimization algorithms avoid dealing explicitly sharing 
apply multi query optimization batch queries queries represented single dag sharing subexpressions 
dag rooted pseudo operation node created root equivalence nodes queries inputs 
hashing scheme volcano gm detect repeated subexpressions 
volcano uses scheme detect repeated derivations expression different transformations avoid creating unnecessary new equivalence nodes perform extra step unifying existing equivalence nodes 
unification important recognizing common subexpressions 
physical dag properties results expression sort order form part logical data model called physical properties gm 
physical properties intermediate results important intermediate result sorted join attribute join cost potentially reduced merge join 
holds true intermediate results materialized shared 
straightforward refine dag representation represent physical properties obtain physical andor dag 
search algorithms easily understood dag representation physical properties physical dags 
brevity explicitly consider physical properties 
implementation handles physical properties appendices provide relevant details 
reuse multi query optimization algorithms section study class multi query optimization algorithms reusing results computed earlier parts query 
extensions volcano optimization algorithm 
consider extensions briefly outline basic volcano optimization algorithm 
volcano optimization algorithm operates expanded dag generated earlier 
finds best plan node performing depth traversal dag starting node 
cost operation node cost executing operation plus cost children inputs operator cost equivalence node minimum costs children alternatives obtaining result represented equivalence node 
volcano caches best plan finds equivalence node case node re visited depth search dag 
branch bound pruning performed carrying cost limit relevant discussion algorithms benefit equally pruning 
lack space omit details refer readers gm 
volcano sh algorithm strategy call volcano sh expanded dag optimized basic volcano optimization algorithm 
best plan produced volcano optimization algorithm may common subexpressions 
case decide cost manner materialize share subexpression recompute time required 
materialization node involves storing result disk assume pipelined execution operators may possible recomputation node cheaper cost materializing reusing node 
fact experiments section quite occasions cheaper recompute expression 
outline simple algorithm deciding nodes materialize reuse 
find common subexpressions traversing optimal plan depth manner 
traversal keep track number times equivalence node shared number uses example equivalence node refined multiple physical equivalence nodes required physical property physical dag 
optimal plan 
choice materialization done depth traversal common subexpressions 
materialization cost number reuses theta reuse cost number reuses theta cost recomputation decision materialize reuse common subexpression materialized 
cost recomputation calculated choice materialization descendants known point time traversal depth 
note basic volcano optimization algorithm exploit subsumption derivations deriving oe oe oe cost locally optimal 
perform pre pass main part checking subsumption nodes plan produced basic volcano optimization algorithm 
subsumption derivation applicable cost decision conjunction materialization shared expression node 
example cost materializing oe computing oe compared cost computing directly cheaper shared expression oe materialized 
techniques choosing nodes materialize heuristic decision materialize taken locally assuming shared ancestors materialized 
shared ancestor node materialized actual number uses node may greater computed depth traversal 
expensive technique eliminates order dependence consider materializing subset set common subexpressions choose subset smallest cost 
problem addressed volcano ru section 
basic idea volcano sh similar sv volcano sh recalculate cost recomputation earlier materialization choices 
volcano ru algorithm intuition volcano ru follows 
consider example 
best plans shown example sharing possible volcano sh 
optimizing realize best plan shared choice plan may best batch queries volcano ru algorithm optimizes sequence keeping track plans chosen earlier queries considering possibility reusing parts plans 
queries optimized 
volcano ru algorithm optimizes sequence optimizing mark equivalence nodes dag part best plan candidates reuse 
optimizing query volcano search strategy change cost computation marked nodes cost marked equivalence node minimum materialization cost reuse cost recomputation cost 
optimization carried dag shared nodes may revisit equivalence node optimizing different queries 
visit equivalence node node optimized node marked chosen materialized best plan query ignore materialization cost node formula optimizing queries 
part optimization process unmarked part best plan query far reuse old cached plan node equivalence node 
reason nodes may marked optimized may provide cheaper way computing equivalence node 
note equivalence node query best plan computed current query optimized discard stored best plan recompute 
volcano search algorithm new definition cost marked nodes reoptimization unmarked nodes guarantees plan chosen query best assuming marked nodes best plans queries shared nodes shared 
phase volcano ru executes volcano sh optimizing individual queries detect exploit common subexpressions optimized queries 
step essential earlier phase volcano ru consider possibility sharing common subexpressions single query equivalence nodes marked optimizing entire query 
reuse exhaustive algorithms volcano ru reuse decisions earlier able predict query 
example swap example easy see volcano ru fail come globally optimal plan 
fact volcano ru obtain globally optimal plan example irrespective order queries optimized local best plan globally optimal plan involves appendix outline optimal exhaustive algorithm backtracking considers plans locally optimal accounts reuse nodes current plan 
implementation algorithm worked small queries exhaustive algorithms problem practical large queries 
greedy algorithm algorithms previous section attempt reuse nodes plan discovered far optimizing parts query 
section algorithm different optimization philosophy 
algorithm picks set nodes results shared materialized reused finds optimal plan results nodes shared node results shared 
repeated different sets nodes find best set nodes shared 
amplify philosophy motivate greedy heuristic describe simple exhaustive algorithm 
describing exhaustive algorithm need simple definition 
set nodes bestcost denote cost optimal plan results nodes shared 
described volcano ru algorithm basic volcano optimization algorithm appropriate definition cost nodes find bestcost 
simple exhaustive algorithm iterate subset set nodes dag choose subset opt minimum value bestcost 
bestcost opt cost oe set equivalence nodes dag oe pick node smallest value bestcost fxg bestcost fxg bestcost fxg oe greedy algorithm globally optimal plan easy see exhaustive algorithm doubly exponential size initial query dag impractical 
outline greedy heuristic attempts approximate opt constructing node time 
node gives maximum reduction cost materialized chosen element added greedy algorithm described expensive due large number nodes set large number times function bestcost called 
important novel optimizations greedy algorithm efficient practical 

optimization observation nodes shared globally optimal plan obviously subset ones shared plan query 
sufficient initialize nodes shared plan query 
call nodes sharable nodes 
instance expanded dag corresponding example sharable 
efficient algorithm finding sharable nodes appendix effects restricting set sharable nodes quantified section 
second optimization observation calls bestcost line albeit different parameters 
simple option process call bestcost independent calls 
symmetric difference parameters successive calls bestcost small sense call leverage done previous call 
describe novel incremental cost update algorithm section maintains state optimization calls bestcost incrementally computes new state old state 

third optimization call monotonicity heuristic avoids having invoke bestcost fxg line 
describe optimization detail section 
incremental cost update sets bestcost called successively line closely related symmetric difference small 
incremental cost update algorithm exploits results earlier cost computations incrementally recompute optimal plan 
function gamma gamma empty equivalence node minimum topological sort number remove old cost cost min cost operation node children cost min reading cost relation cost cost changed parent operation node cost cost inputs cost operation add parent equivalence node incremental cost update outlines incremental cost update algorithm 
set nodes shared point time previous call bestcost parameter 
incremental cost update algorithm maintains optimal cost computing equivalence node shared node shared 
new set nodes shared call bestcost parameter 
incremental cost update algorithm starts nodes gamma gamma propagates change cost nodes upwards parents turn propagate changes cost parents change cost 
perform propagation arbitrary order worst case propagate change cost node multiple times example node ancestor node 
simple mechanism avoiding repeated propagation uses topological numbers nodes dag 
dag generation dag sorted topologically descendant comes ancestor sort order nodes numbered order 
cost propagation performed topological number ordering heap built topological number 
heap efficiently find node minimum topological sort number step 
implementation additionally take care physical property subsumption 
details issues involved modified incremental cost update algorithm appear appendix monotonicity heuristic function bestcost called node normal circumstances 
outline determine node smallest value bestcost efficiently monotonicity heuristic 
define bestcost gamma bestcost fxg 
notice minimizing bestcost line corresponds maximizing benefit defined 
suppose benefit monotonic 
intuitively benefit node monotonic increases nodes get materialized formally monotonic 
associate upper bound benefit node maintain heap upper bounds 
initial upper bound benefit node uses notion maximum degree sharing maximum number times node shared single plan 
maximum degree sharing computed algorithm finds sharable nodes described appendix initial upper bound just cost evaluating node multi query optimization times maximum degree sharing 
heap efficiently find node maximum follows iteratively node top chosen current benefit recomputed heap reordered 
remains top deleted heap chosen materialized added assuming monotonicity property holds values heap upper bounds node added node maximum real benefit 
monotonicity property hold node maximum current benefit may top heap procedure heuristic finding node greatest benefit 
experiments section demonstrate procedure greatly speeds greedy algorithm 
queries experimented results exactly monotonicity heuristic 
extensions section briefly outline incorporate creation temporary indices ii optimize nested queries exploit common sub expressions iii optimize multiple invocations parameterized queries 
costs may substantially reduced creating temporary indices database relations materialized intermediate results 
incorporate index selection model presence index physical property similar sort order 
algorithms executed physical dag choose results materialize physical properties 
index selection falls simply special case choosing physical properties absolutely changes algorithms 
nested queries repeatedly invoked correlated evaluation 
parts nested query depend value correlation variables potentially shared invocations rr illustrated query query select cost select min cost option evaluating query materialize share outer level query nested query invocations assuming correlated evaluation 
index attribute required efficient access nested query selection correlation variable 
best plan outer level query uses join order materializing sharing quite provide best plan 
extend algorithms handle nested queries just small amount effort 
key intuition nested query invoked times benefits due materialization multiplied number times invoked results depend correlation variables considered materialization 
nested query invariant optimization techniques rr fall special case 
note decorrelation nested queries alternative usually results queries common subexpressions multi query optimization useful 
algorithms extended optimize multiple invocations parameterized queries 
parameterized queries queries take parameter values selection predicates stored procedures common example 
parts query may invariant just nested queries exploited multi query optimization 
extensions implemented system details appear appendix performance study algorithms implemented extending modifying volcano query optimizer developed earlier 
coding done basic optimizer approx 
lines common code took lines volcano sh volcano ru took lines greedy took lines 
optimizer rule set consisted select push join commutativity associativity generate bushy join trees select aggregate subsumption 
implementation incorporates optimizations apk join transformations prevent repeated derivations expressions 
implementation algorithms included sort aggregation merge join nested loops join indexed join indexed select relation scan 
implementation incorporates techniques discussed including handling physical properties sort order presence indices base intermediate relations unification subsumption dag generation sharability algorithm greedy heuristic 
block size taken kb cost functions assume mb available operator execution 
standard techniques estimating costs statistics relations 
cost estimates contain component cpu component seek time msec transfer time msec block read msec block write cpu cost msec block data processed 
assume intermediate results pipelined input iterator model volcano saved disk result materialized sharing 
materialization cost cost writing result sequentially 
tests performed single processor mhz pentium ii machine mb memory running linux 
optimization times measured cpu time user system 
volcano volcano sh volcano ru greedy optimization time secs logscale volcano volcano sh volcano ru greedy optimization stand tpcd queries basic experiments goal basic experiments quantify benefits cost heuristics multi query optimization volcano sh volcano ru greedy plain volcano style optimization base case 
experiment stand tpcd workload experiment consisted queries tpcd benchmark 
tpcd database scale gb total size clustered index primary keys base relations 
results discussed plotted 
tpcd query large nested query repeated invocations nested query correlated evaluation benefit reusing intermediate results 
query volcano ru lead improvement plan estimated cost secs 
returned volcano greedy results plan significantly reduced cost estimate secs 
decorrelation alternative correlated evaluation manually decorrelated version due decorrelation batch queries 
multi query optimization gives substantial gains decorrelated query resulting plan estimated costs secs decorrelation results common subexpressions 
clearly best plan multi query optimization coupled decorrelation 
observe cost decorrelation greedy volcano cost plain volcano results indicates multi query optimization useful queries decorrelation possible 
test ran optimizer variant clause changed clause prevents decorrelation introduced introducing new internal operators anti semijoin rr 
replaced correlated predicate ps partkey partkey ps partkey partkey modified query volcano gave plan estimated cost secs greedy able arrive plan estimated cost improvement factor 
considered tpcd queries common subexpressions case 
algorithms lead plan approximately half total execution time secs execution stand tpcd queries ms sql server cost returned volcano 
greedy arrives similar improvements volcano sh volcano ru lead appreciable benefit query 
volcano sh volcano ru take time space volcano 
greedy takes time queries 
terms relative time taken greedy needed maximum times time volcano took maximum just seconds small compared benefits 
total space required greedy ranged times algorithms absolute values quite small bit kb 
results microsoft sql server study benefits multi query optimization real database tested effect queries mentioned executed microsoft sql server running windows nt mhz machine mb memory 
tpcd database scale tests 
encoded plans generated greedy sql 
modeled sharing decisions creating temporary relations populating deleting 
indicated greedy created indexes temporary relations 
encode exact evaluation plan sql sql server optimization 
measured total elapsed time executing steps 
results shown 
results indicate multi query optimization gives significant time improvements real system 
important note apparent benefits conservative reasons 
due encoding sharing sql temporary relations stored re read 
sharing incorporated evaluation engine pipelined reducing cost 
operator set sql server restricted support sort merge join queries submitted index nested loops 
optimizer times indicated worthwhile materialize relation sorted order cheaply merge join aggregation encode sql sql server 
multi query optimization properly integrated system benefits significantly larger consistent benefits cost estimates 
query time taken reduced secs 
secs 
sql server performed bq bq bq bq bq volcano volcano sh volcano ru greedy bq bq bq bq bq optimization time secs logscale volcano volcano sh volcano ru greedy optimization batched tpcd queries relation original result multi query optimization 
numbers match cost estimates clearly multi query optimization useful 
reduction decorrelated version secs 
secs best plan sql server multi query optimization greedy decorrelated query 
query speeded just secs 
secs 
secs 
secs 
plans sharing generated greedy 
experiment batched tpcd queries second experiment workload models system tpcd queries executed batch 
workload consists subsequences queries tpcd queries common subexpressions 
query repeated twice different selection constants 
composite queries bq bq defined follows simply consisted queries 
effects volcano sh volcano ru depend order queries ran tests different orderings queries batch forward reverse average measurements 
experiment tpcd database scale assumed clustered indices primary keys database relations 
results workload shown 
workload volcano sh volcano ru achieve improvement volcano respect cost returned plan incurring negligible overheads 
difference volcano sh volcano ru queries implying choice plans earlier queries change local best plans queries 
greedy performs better achieving improvement volcano uniformly better algorithms 
expected volcano sh volcano ru essentially execution time space requirements volcano 
greedy takes seconds largest query set bq volcano takes slightly second 
estimated cost savings bq seconds clearly extra optimization time cost secs 
extra time spent greedy spent 
similarly space requirements greedy factor volcano absolute difference bq kb 
benefits greedy clearly cq cq cq cq cq volcano volcano sh volcano ru greedy cq cq cq cq cq optimization time secs volcano volcano sh volcano ru greedy optimization scaleup queries outweigh cost 
scaleup analysis see algorithms scale increasing numbers queries defined new set relations psp psp identical schema sp num denoting part id subpart id number 
relations defined sequence component queries sq sq component query sq pair chain queries consecutive relations psp psp join condition psp sp psp 
queries pair sq selection psp num selection psp num arbitrary values measure scaleup composite queries cq cq cq consists queries sq sq gamma cq uses relations psp psp gamma join predicates gamma selection predicates 
query cq particular relations join predicates select predicates 
size base relations psp psp varied tuples assigned randomly tuples block 
index assumed base relations 
cost plan optimization time workload shown 
relative benefits algorithms remains similar earlier workloads volcano ru gives somewhat better plans volcano sh 
greedy continues best relatively expensive 
optimization time volcano volcano sh volcano ru increases linearly 
increase optimization time greedy practically linear small super linear component 
largest query cq relations join predicates select predicates time taken seconds 
size dag increases linearly sequence queries 
conclude greedy scalable quite large query batch sizes 
better understand complexity greedy heuristic scaleup workload addition optimization time measured total number times cost propagation occurs equivalence nodes total number times cost recomputation initiated 
result plotted 
note addition size dag number sharable nodes increases linearly queries cq cq cq cq cq cq number cost propagations greedy cq cq cq cq cq number cost recomputations greedy complexity greedy heuristic cq 
greedy considered expensive worst case complexity number nodes dag sharable number edges dag 
multi query optimization dag tends wide tall add queries dag gets wider height increase height defined individual queries 
result shows workload number times cost propagation occurs equivalence nodes number times cost recomputation initiated increase linearly number queries 
observed complexity worst case complexity 
number times costs propagated equivalence nodes constant cost recomputation 
number nodes dag affected single materialization vary number queries exploited incremental cost recomputation 
height dag remains constant number relations query fixed reasonable assumption 
effect optimizations series experiments focus effect individual optimizations optimization scaleup queries 
consider effect monotonicity heuristic addition greedy 
monotonicity heuristic node materialized benefits recomputed sharable nodes materialized 
monotonicity heuristic addition average benefits recomputed time range cq cq 
contrast monotonicity heuristic cq benefit recomputations time leading optimization time seconds query seconds monotonicity 
scaleup worse monotonicity 
best plans produced monotonicity heuristic assumption virtually cost queries ran 
monotonicity heuristic provides large time benefits affecting quality plans generated 
find benefit sharability computation measured cost greedy sharability computation turned node assumed potentially sharable 
range scaleup queries optimization time increased significantly 
cq optimization time secs 
secs 
sharability computation useful optimization 
discussion check effect memory size results ran experiments increasing memory available operators mb mb mb 
cost estimates plans decreased slightly relative gains essentially remained different heuristics 
experiments volcano ru better volcano sh cases run times similar volcano ru preferable 
exist cases volcano ru finds plans greedy time space hand experiments saw cases additional investment time space greedy pays get substantial improvements plan 
smarter optimization sense cost incurred optimization offset savings execution time query 
execution cost query benefit due optimization depends size underlying data 
illustrate fact ran batched tpcd query bq considered experiment tpcd database scale total size gb 
volcano returned plan estimated cost secs 
greedy obtains plan cost estimate secs improvement secs 
extra time spent optimization seconds negligible relative gain 
summarize low cost queries take seconds may want quick dirty job especially query cheap syntactically complex 
expensive queries canned queries optimized rarely executed frequently large databases clearly sense greedy 
related multi query optimization problem addressed fin sel ssn sg cls ps cr sv 
sel ssn sg cls ps describe exhaustive algorithms representation query set alternative plans having set tasks tasks may shared plans different queries 
exploit hierarchical nature query optimization problems tasks subtasks 
solutions integrated optimizer 
sv considers sharing best plans query similar volcano sh seen yield best sharing 
considers queries expressed single multi dimensional expression 
cr addresses issue management cache previous results considers select project join spj queries 
consider general class queries 
problem materialized view index selection rou rss cn gup related multi query optimization problem 
view selection problem viewed finding best set sub expressions materialize workload consisting queries updates 
multi query optimization problem differs assume absence updates keep mind cost computing shared expressions view selection problem concentrates cost keeping shared expressions date 
interesting note multi query optimization needed finding best way propagating updates base relations materialized views rss 
algorithms view selection problem similar spirit greedy algorithm 
significant difference optimization greedy algorithm incrementally compute various benefits avoid recomputation benefits monotonicity property 
contrast earlier greedy algorithms integrated optimizer incremental computation possible 
probably reason authors claim greedy algorithm quite inefficient selecting views materialize cube queries 
normal sql queries modeled tpc benchmarks performance study section indicates greedy heuristic quite efficient optimizations 
rr considers problem detecting invariant parts nested subquery teaching optimizer choose plan keeps invariant part large possible 
performing multi query optimization nested queries automatically solves problem address 
multi query optimization algorithms implement query optimization presence materialized cached views subroutine 
virtue working general dag structure techniques extensible solutions cr 
problem detecting expression compute studied ly yl sel address problem choosing materialize problem finding best query plans cost fashion 
algorithms described context volcano optimizer commercial database systems microsoft tandem volcano optimizers 
algorithms modified added top existing system style bottom optimizers main change way dag represented constructed 
described novel heuristic search algorithms volcano sh volcano ru greedy optimization 
algorithms dag representation queries 
generation dag algebraic transformations rendering approach extensible 
novel extensions dag generation algorithm detect common sub expressions subsumption derivations 
addition shown represent index selection nested queries representation 
number techniques greatly speed greedy search strategy 
implementation demonstrated algorithms added existing optimizer reasonably small amount effort 
performance study queries tpc benchmark demonstrates multi query optimization practical gives significant benefits reasonable cost 
benefits multi query optimization demonstrated real database system 
greedy strategy uniformly gave best plans benchmarks best queries volcano ru cheaper may appropriate inexpensive queries 
believe laid groundwork practical multi query optimization multi query optimization form critical part query optimizers 
includes extensions ideas 
algorithms extended deal space constraints materialized results 
instance greedy algorithm select equivalence nodes order benefit unit space gup space exhausted 
important area lies dealing large sets queries large workloads size workload reduced abstracting queries instance replacing queries differ just selection constants parameterized query invoked multiple times 
scheduling multiple pipelines parallel help remove cost materialization cases example shared relation scan implemented data warehouse 
extending optimizer consider scheduling including issue partitioning memory pipelines area 
plan extend perform materialized view selection index selection need consider update costs case plan exploit greedy algorithm optimizations 
acknowledgments supported part engage technologies systems 
part roy supported ibm fellowship 
wish helped build basic volcano optimizer dan ashok motivating engage fusion project paul larson sridhar ramaswamy providing useful feedback earlier drafts 
apk cesar martin kersten 
complexity transformation join enumeration 
intl 
conf 
large databases pages athens greece 
surajit chaudhuri ravi krishnamurthy potamianos kyuseok shim 
optimizing queries materialized views 
intl 
conf 
data engineering taipei taiwan 
cls ee peng lim srivastava 
multiple query optimization depth branchand bound dynamic query ordering 
intl 
conf 
information knowledge management cikm 
cn surajit chaudhuri vivek narasayya 
efficient cost driven index selection tool microsoft sql server 
intl 
conf 
large databases 
cr chen 
implementation performance evaluation query optimizer integrating query result caching matching 
extending database technology edbt cambridge uk march 
fin finkelstein 
common expression analysis database applications 
sigmod intl 
conf 
management data pages orlando fl 
gm goetz graefe william mckenna 
extensibility search efficiency volcano optimizer generator 
technical report cu cs university colorado boulder december 
gup gupta 
selection views materialize data warehouse 
intl 
conf 
database theory 
harinarayan rajaraman ullman 
implementing data cubes efficiently 
sigmod intl 
conf 
management data montreal canada june 
quass 
physical database design data warehouses 
intl 
conf 
data engineering 
ly larson yang 
computing queries derived relations 
intl 
conf 
large databases pages stockholm 
ps park arie segev 
common sub expressions optimize multiple queries 
proc ieee cs intl conf 
data engineering los angeles february 
rou 
view indexing relational databases 
acm trans 
database systems 
rr rosenthal reiner 
architecture query optimization 
sigmod intl 
conf 
management data orlando fl 
rr jun rao ken ross 
reusing invariants new strategy correlated queries 
sigmod intl 
conf 
management data seattle wa 
rss kenneth ross divesh srivastava sudarshan 
materialized view maintenance integrity constraint checking trading space time 
sigmod intl 
conf 
management data may 
sac griffiths selinger astrahan chamberlin lorie price 
access path selection relational database management system 
proceedings acm sigmod international symposium management data pages 
amit shukla prasad deshpande jeffrey naughton 
materialized view selection multidimensional datasets 
intl 
conf 
large databases new york city ny 
sel sellis 
intelligent caching indexing techniques relational database systems 
information systems pages 
sel sellis 
multiple query optimization 
acm transactions database systems march 
sg sellis ghosh 
multi query optimization problem 
ieee transactions knowledge data engineering pages june 
ssn kyuseok shim sellis dana nau 
improvements heuristic algorithm multiple query optimization 
data knowledge engineering 
sv subramanian shivakumar venkataraman 
cost optimization decision support queries transient views 
sigmod intl 
conf 
management data seattle wa 
jian yang qing li 
algorithms materialized view design data warehousing environment 
intl 
conf 
large databases 
yl yang larson 
query transformation psj queries 
intl 
conf 
large databases pages brighton august 
zhao prasad deshpande naughton amit shukla 
simultaneous optimization evaluation multiple dimensional queries 
sigmod intl 
conf 
management data seattle wa 
dag generation generation expanded logical dag performed procedure shown 
procedure invoked root dag returns entire logical dag created 
procedure eq unexpanded logical operation node op child eq input op apply possible logical transformations op may involve creating new equivalence nodes resulting logical expression logical expression expression dag add logical operation child eq previous instance equivalence node eq different eq unify eq eq mark op expanded physical dag generated logical dag procedure 
subgoal logical equivalence node physical property returns physical equivalence node corresponding generating exist 
entire physical dag generated invoking root query desired physical properties query 
procedure logical equivalence node desired physical property physical equivalence node exists property return create physical equivalence node operation node algorithm guarantees property create physical operation node input ith input physical property required input algorithm set input enforcer generates property create enforcer node set input null null denotes physical property requirement return unification appendix turn problem identifying possible common sub expressions 
extend volcano idea detecting identical logical expressions problem 
volcano equivalence node unique id turn means logical expression identified uniquely logical operation ids inputs 
volcano maintains hash table logical expressions hash key combination operation ids inputs 
transformation generates logical expression volcano checks hash table current dag 
check recursive procedure checking inputs getting unique ids hash table find hash key table 
hash key duplicate transformation logical expression produced inserted hash table 
addition transformation existing expression placed equivalence node sub expression newly created expression hash table new equivalence node unique id created parent example generate result transformation 
hash table inserted child parent equivalence node 
subexpression hash table new equivalence node created parent expression query common subexpressions expression may generated transformations different equivalence nodes 
instance query subexpression subexpression different equivalence nodes initial query dag 
equivalence node corresponding 
transformation generate hashing procedure find find node 
new instance generated 
equivalence nodes representing expression 
volcano optimization algorithm ignores fact keeps equivalence nodes separate 
correct problem fully detect common subexpressions perform unification equivalence nodes replaced single equivalence node say 
replaced 
hash keys operations changed operations may duplicated dag turn equivalence node parents unified 
unification algorithm dag generation algorithm executed tandem 
pass get minimal completely expanded dag dag completely expanded distinct equivalence nodes child operation nodes obtained series transformations 
expression subsumption reuse suppose subexpressions oe oe appear query 
result obtained result additional selection oe oe oe 
general oe obtained oe oe 
call derivations subsumption derivations subsumption derivations introduce selection ffl suppose expressions oe oe occur logical dag add new logical operation node oe parent child 
ffl suppose expressions oe oe oe occur logical dag equivalent add new logical operation node oe child equivalence node parent new logical equivalence node corresponding result operation 
nodes introduce new selection operation node oe child parent exhaust possible applications transformations example set selections oe disjunction combination candidate 
avoid generating combinations exponential blow generate just ones described 
similarly introduce subsumption derivations groupby expressions 
example expressions dno sum sal dno max sal derived means projections dno sum sal max sal 
nodes dno sum sal age sum sal derived dno age sum sal dno age 
additionally rules types combined single rule applies individually applies 
introduce derivations logical dag perform bottom traversal logical dag fully expanded 
new derivations applied set select groupby operation nodes equivalence node visited 
exhaustive backtracking algorithm exhaustive backtracking algorithm finds optimal plan dag queries 
name suggests algorithm examines possible plans backtracking chooses minimum cost plan 
plans examined order affecting correctness simplicity presentation generate plans traversing physical dag left right fashion described 
example consider expanded query dag 
set alternative plans follows fa ig fa jg fa ig fa jg fa ig fa jg 
computing cost query plan cost common sub expressions counted 
example exhaustive algorithm implementation details describe basic idea implementation exhaustive algorithm 
gives pseudo code exhaustive algorithm 
backtracking algorithm 
algorithm uses global stack called active stack keeps track set nodes correspond subgoals remain explored point time ancestor node active stack active stack explored ancestor stack explored 
expanded logical dag generated applying transformation rules identifying common subexpressions described appendix expanded complete physical dag applying basic volcano cost pruning disabled 
exhaustive search backtracking performed physical dag function 
call current plan consists current choice far current plan called partial plan appended plan nodes active stack called completion partial plan form complete plan input query 
call active stack containing set nodes current partial plan represented set nodes returns best plan nodes nodes materialized available reuse scan cost 
return active stack contains sequence extended volcano algorithm exhaustive algorithm computes cost plan node assuming nodes current plan time node explored materialized available reuse scan cost 
function called root physical dag element active stack initially 
active stack empty nodes remain explored means complete plan update best plan cost pruning discussed guarantees inputs output best completion current partial plan function active stack empty complete plan update best plan current plan update cost limit current plan cost nodes left explored pop node say active stack current plan add cost reusing current cost call subtract cost reusing current cost add current plan choice left right physical operation nodes current cost cost cost limit add current plan add cost current cost push children right left active stack call pop nodes pushed active stack subtract cost current cost delete current plan remove current plan push active stack exhaustive search algorithm plan cheaper best plan 
active stack empty top element node active stack popped 
node marked current partial plan empty plan cost scan cost intermediate relation corresponding returned signifying required result materialized 
explore physical operation node turn left right 
physical operation node explored pruned cost physical operation node cost operation corresponding physical operation node considering cost inputs added cost current plan greater best cost plan far 
notice recursive call inside loop physical operation nodes children popped node tried 
nodes explored choices choice changed illustrate algorithm example dag saw earlier 
square nodes represent nodes circular nodes represent physical operation nodes 
algorithm starts root active stack 
choice root pushes children active stack 
follow right left order pushing children node stack order followed 
pops active stack includes current plan 
chooses pushes pops active stack chooses successive steps 
stage current partial plan active stack 
goes explore node 
pops active stack includes partial plan 
successive steps takes choice pushes pops takes choice stage nodes stack valid plan fa ig 
backtracking starts 
backtrack past choice backtrack past 
point removed current plan pushed active stack 
part current plan need retain 
step backtrack past delete active stack 
choice algorithm takes choice continues exploration 
get plan fa jg 
backtracking starts 
algorithm goes past past 
point push active stack 
backtracking continues move past point chooses pushes pops chooses algorithm continues explore examines plans order mentioned 
optimization exhaustive algorithm memoization 
discuss optimization need define notion sharability 
incorporating memoization exhaustive algorithm recall state active stack defines nodes explored backtracking state reached multiple times due different alternatives earlier subgoals 
explain caching auxiliary information plan stack state optimize reusing cached plans 
discussion set nodes active stack denote sharable dents nodes point execution algorithm consider partial plan far contents active stack point 
set sharable nodes composite plan nodes leads optimal completion partial plan suppose point time optimization partial plan far forms contents active stack point set shared nodes guaranteed optimal completion caching memoization done pairs set nodes active stack set sharable nodes current partial plan pair composite partial plan nodes leads optimal completion current partial plan maintained 
cache entry pair added just line just returns set nodes active stack computed outlined 
call top level recursive set nodes active stack set sharable nodes partial plan far cache searched pair 
partial plan cache pair added current partial plan give complete plan exploring nodes 
illustrate example 
verified sharable node physical dag 
start stage partial plan generated far fa gg set nodes partial plan 
set nodes left explored forms contents active stack point 
algorithm finds partial plans corresponding choices 
assume best partial plan ff jg 
cached pair fg 
note set sharable nodes partial plan obtained earlier empty 
algorithm takes choice partial plan fa hg containing nodes sharable nodes 
point cache hit fg partial plan ff jg cached returned 
note change set nodes shared partial plan obtained far unexplored dag best plan 
algorithm generates fa ig set nodes shared partial plan far unexplored part dag 
partial plan cached pair best plan new partial plan earlier part different best plan shared sub expressions 
algorithm continues exploration 
maintain set sharable nodes current partial plan fly 
purpose global stack called stack 
node popped active stack line ref 
pushed stack sharable 
similarly sharable node pushed back active stack line popped stack 
guarantees point time contents stack exactly set sharable nodes current partial plan 
caching strategy needs know stack state set sharable nodes descendents computing expensive 
computed nodes stored entail significant storage overhead 
alternative cache pairs active stack set sharable nodes current plan 
words just described take intersection set sharable nodes current partial plan sharable nodes descendents nodes partial plans set sharable nodes best plan rest dag identical 
alternative avoids cost computing set sharable nodes descendents hand may fewer cache hits compared memoization algorithm previously described partial plans differ set sharable nodes intersection sharable descendents active stack state may identical 
handling physical property subsumption incremental cost update incremental algorithm discussed section gets complicated fact cyclic derivations possible physical dag 
instance sorted attribute derived sorted attribute vice versa means sort 
choose physical expressions materialized careless choosing plan best plan may obtained sorting result vice versa 
clearly cyclic plan implemented 
appendix consider issue finding best plans presence implicit cycles physical equivalence nodes 
split task finding best plan parts logical equivalence nodes second physical equivalence nodes logical equivalence node 
task addressed earlier section address second task 
luckily finding best plan second subtask simplified enforcer nodes involved cycles enforcer nodes single inputs 
briefly sketch algorithm 
set physical equivalence nodes equivalence class cost obtaining enforcer dummy enforcer case cost taken zero 
physical equivalence node may external computation cost cost best algorithm plan 
construct weighted directed graph node physical equivalence nodes dummy external node representing physical equivalence node set base relations materialized physical equivalence nodes node 
nodes external node connected directed edges representing cost enforcer converts result physical equivalence node corresponding tail result physical equivalence node corresponding head 
nodes algorithm plans directed edge external node weight cost best algorithm plan 
node mark set corresponding physical equivalence node materialized 
algorithm finds shortest paths external node node 
shortest paths represent cost best plan node case nodes marked 
keep track best costs introduce dummy node called summary node edge node graph external node cost cost shortest path 
consider subgraph induced summary node marked nodes find minimum cost directed spanning tree known edmond algorithm 
spanning tree gives best plan marked physical equivalence node consideration marked nodes edge summary node minimum cost spanning tree best plans unmarked nodes lie shortest path corresponding edge 
best plan unmarked node covered corresponds shortest path node marked nodes summary node 
note solution heuristic extent marked physical equivalence nodes may needed best plan eliminated minimum spanning tree may resulted 
know set nodes get 
conservatively assume may compute spanning tree marked nodes 
sharability appendix outline detect equivalence node shared 
plan tree plan tree obtained replicating shared subplans plan completely eliminate sharing 
degree sharing logical equivalence node evaluation plan number times occur plan tree degree sharing logical equivalence node expanded dag maximum degree sharing equivalence node evaluation plans represented dag 
logical equivalence node sharable degree sharing expanded dag greater 
degree sharing sharability physical equivalence node inherited associated logical equivalence node 
simple algorithm compute degree sharing node detect node shared 
sub dag node consists nodes edges nodes original dag 
node dag node sub dag rooted represent degree sharing sub dag rooted clearly nodes 
values node dag computed values children follows 
operation node obtained adding children equivalence node obtained maximum children degree sharing node dag root dag 
possible directly compute degree sharing physical equivalence nodes done earlier implementation 
physical dag significantly bigger logical dag performing computation logical equivalence nodes result corresponding physical equivalence nodes cheaper 
space minimized computing time discarding computation value 
procedure worst case time complexity ne number nodes dag number edges dag 
reduces cost illustrated performance experiments reduces number nodes considered materialization 
handling nested parameterized queries section outline mechanism representing nested queries dag framework 
outline optimize queries 
stored procedures sql standard source parameterized queries invoked multiple times calls queries selection predicate constants 
parametrized queries opportunity optimization different invocations 
techniques handling multiple invocations parameterized queries essentially similar handling nested queries 
briefly indicate connections 
nested query forms part predicate select operation outer query 
extend child equivalence node represents result inner query 
descendants share nodes dag outer query 
optimizers perform block time optimization share optimization effort outer inner query 
correlated nested query select operation node descendant contain correlation variable outer query 
call node node 
clearly result expression contains node varies different calls subquery depending value correlation variable materialized shared calls different parameter values 
tag equivalence node node occurs ancestor nodes non 
tagging performed efficiently dag constructed 
represent cost multiple executions inner query create pseudo operation parent cost times cost estimate number times nested query invoked pseudo operation parent new equivalence node parent selection operator predicate contains inner query 
constructions rest optimization algorithms unchanged consider materializing nodes tagged non 
savings due materialization expression node get multiplied fold node 
important point note construction allows share computation multiple invocations nested subquery nested subquery outer level query see example 
extensions allow memoization subquery results intermediate results subqueries correlation variable values possible 
reduce number times subquery evaluated sac 
optimizations independent optimizations conjunction 
note nested subquery results subquery invoked times distinct parameter values 
query decorrelation essentially attempts rewrite correlated query way outer longer exist proposed technique optimizing nested queries 
query decorrelation applicable may efficient correlated evaluation cases 
applied decorrelation typically produces set queries place nested query set queries benefit multi query optimization 
rao ross rr address issue finding components subqueries invariant calls choosing materialize cost manner 
optimization falls special case optimization techniques parameterized queries 
note parameterized query invocations essentially nested query invocations parameterized constants playing role correlation variables 
techniques described applied parameterized queries 

