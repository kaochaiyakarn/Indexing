race condition detection parallel computation semaphores philip klein lu robert netzer department computer science brown university providence rhode island cs january race condition detection parallel computation semaphores philip klein lu robert netzer hil rng cs brown edu department computer science brown university address problem arising debugging parallel programs detecting race conditions programs semaphores synchronization 
npcomplete detect race conditions programs semaphores 
show remains np complete programs allowed semaphores 
case single semaphore lu give previously known polynomial time algorithm runs time number processors total number semaphore operations executed 
algorithm detects special class race conditions 
cope general race condition detection problem give np log time algorithm 
output algorithm compact representation determine constant time race condition exists operations 
race condition detection crucial aspect developing debugging shared memory parallel programs 
explicit synchronization usually added programs coordinate access shared data race conditions result synchronization force concurrent processes access data expected order 
way dynamically detect races program trace execution analyze traces afterward 
central part dynamic race detection compute trace order shared memory accesses guaranteed execution synchronization executed 
accesses location guaranteed execute particular order considered race 
programs semaphore operations synchronization operations belonging different processes potentially executed order different traced 
fast algorithms computing order execution semaphore operations executed case tractable programs single semaphore 
algorithms exactly detect race conditions executions programs 
past shown exactly detecting races programs multiple semaphores npcomplete developed exact algorithms cases problem efficiently solvable programs types synchronization weaker semaphores heuristics multiple semaphore case 
complexity case constant number semaphores open question 
give theorem settle open question 
theorem race condition detection problem semaphore npcomplete 
case semaphore give fast algorithms 
goal solve problem efficiently possible parallel programs typically long running resulting large traces analyzed quickly algorithms 
algorithm determines semaphore operations executed different order execution semaphore operation increments semaphore operation waits semaphore greater zero decrements semaphore 
operations typically wait synchronize condition true shared buffer non empty operations typically signal condition true 
detect race exists particular operations runs time space linear total number semaphore operations 
second algorithm answers question pairs operations detect races execution runs np log time number semaphore operations number processors 
reduction scheduling computing order execution semaphore operations executed requires solving scheduling problem 
determine operations guaranteed executed fixed order determine valid subschedule execution operations exists precedes valid schedule interleaving processes semaphore operations honors semantics semaphore style synchronization linear ordering operations point ordering number operations exceeded number operations meaning semaphore nonnegative 
valid subschedule prefix valid schedule 
trace indicates preceded actual execution valid subschedule exists precedes executed order 
consider subschedule deadlocks happen execution parallel programs 
determining valid schedule exists precedes equivalent special case sequencing minimize maximum cumulative cost 
describe problem explain equivalence paragraphs 
acyclic directed graph costs nodes schedule topological ordering nodes ordering nodes consistent arcs 
cumulative cost nodes schedule just sum cost nodes 
minimizing maximum cumulative cost attempt sure cumulative cost stays low schedule 
problem np complete general node costs restricted sigma 
kameda time algorithm special case series parallel graph time bound improved log 
part solution give log time algorithm applicable chain graph graph consisting union disjoint directed paths 
existence problem valid schedule precedes reduced problem chain graph augmented inter chain edge 
add edge assign costs nodes gamma node operation operation compute minimum maximum cumulative cost 
clearly cost zero valid schedule 
augmented chain graph series parallel algorithm abdel kameda applicable 
show problem solved polynomial time 
fact special case interest costs sigma give linear time algorithm 
single pair race condition detection order detect race conditions need find valid subschedule containing maximum cumulative cost minimized 
note valid subschedule valid schedule prefix subgraph graph prefix subgraph arc node gamma node ii arc nodes arc clearly graph interest parallel chains augmented arc prefix subgraph determined cut comprising 
problem address reduced finding cut valid schedule prefix subgraph determined cut minimal maximum cumulative cost 
maximum cumulative cost optimal subschedule contains zero valid subschedule exists optimal valid subschedule 
positive valid partial schedule maximum cumulative cost valid subschedule greater equal positive 
shall show best cut linear time 
theorem suppose graph consisting disjoint chains comprising nodes node represents operation operation 
nodes determine time valid subschedule precedes pair race condition detection application parallel debugging important exactly detect races 
need determine pairs nodes fortunately compact representation information 
represent information sufficient indicate node chain containing node precedes valid 
representation size np number nodes number chains 
representation determine constant time race operations race exists operation precede 
determine precede obtain node chain preceded valid 
node numbered precede precede consider complexity constructing representation 
clearly constructed sequence calls algorithm theorem 
show better fact time required algorithm logn times time required simply write output 
theorem suppose theorem 
compact representation relation precedes valid constructed np log time space 
contribution previously best race detection algorithm semaphore runs time 
positive result improves time complexity factor log 
furthermore race conditions considered general race condition considered valid schedules valid 
specifically precede defined existence valid schedule subschedule precedes race condition defined regarded race condition 
algorithms polynomial time algorithms detect general race conditions programs semaphores 
negative result shows long parallel programs uses semaphore detecting race condition special general npcomplete 
rest organized follows 
section gives preliminary definitions lemmas 
sections prove theorem theorem theorem respectively 
preliminaries definition notation suppose acyclic graph node costs 
introduce schedules 
terminology adapted 
schedule sequence nodes consistent precedence constraints imposed arcs segment schedule consecutive subsequence 
delta delta delta sequence nodes 
cost denoted sum costs nodes 
height node defined sum costs nodes height denoted maximum height node node maximum height called peak 
node minimum height called valley 
reverse height denote height minus cost note height reverse height nonnegative 
schedule optimal height minimum schedules denote height optimal schedule 
sequence delta delta delta nodes called chain edges incident nodes gamma nodes denoted pred succ respectively 
start denote denote note single node 
denote chain starting gamma denote height reverse height hump nodes cost node circle 
definition gamma 
peaks useful 
longest chain starting gamma longest chain clear context graph intended may omit subscript note notation defined acyclic graph composed disjoint chains case interest 
suppose chain containing peak node preceding nonnegative height node height cost case call hump say useful peak definition illustrated 
say hump hump cost negative hump cost nonnegative 
concerned primarily graphs consisting disjoint union chains 
convenience assume graph existence initial preceding nodes terminal nodes cost zero 
pred succ 
rest section describe properties humps schedules 
adapted 
hump decomposition part scheduling algorithm graphs abdel kameda show linear time sequence nodes decomposed set humps 
algorithm decomp shown 
takes chain input outputs set disjoint subchain hump 
repeat loop produces humps second repeat loop produces function decomp fg valley repeat peak pred valley pred succ pred valley repeat peak valley succ return algorithm decompose chain set humps chain decomposed humps humps humps 
loop alternates identifying peaks valleys 
difficult see sequence nodes consecutive valleys hump 
example shown 
chain decomposed decomp humps humps 
chain say hump decomp 
proved decomp properties 
hump decomposition properties 
suppose decomp precedes 


valley decomp set humps second sequence nodes obtained clustering numbered nodes node 
decomp succ set humps 

disjoint chains humps respectively order 
humps cc delta delta delta order 
third property implies decomp cc decomp decomp turn decompose chain humps need concerned internal structure humps 
hump need store 
chain consisting humps represented length sequence pairs 
call sequence hump representation chain 
third hump decomposition property straightforwardly derive hump representation hump representation particular decomp decomp computing decomp cc takes time linear hump clustering lemma concerns operation schedule called clustering nodes hump 
suppose hump useful peak schedule nodes consecutive say clustered hump clustered say schedule clustered 
hump clustered schedule modify schedule 
cluster nodes change positions nodes nodes consecutive order nodes unchanged 
example shown 
lemma acyclic graph node costs hump suppose schedule obtained clustering nodes useful peak schedule 
example shown 
height schedule smaller schedule 
follows lemma clustered optimal schedule clustered schedules graph shown 
prove lemma follows 
proof lemma original lemma restricts chain graph 
prove follows properties hold restriction 
suppose delta delta delta delta delta delta useful peak suppose delta delta delta segment delta delta delta 
difference segment delta delta delta replaced hw delta delta delta gamma delta delta delta jp gamma jp delta delta delta gamma delta delta delta gamma suppose definition chains precedence relations imposed note precedes node succeeds node follows precedence constraint schedule denote heights respectively 
note set nodes preceding change 
show ff exists fi ff fi 
ffl ff ff jp 
ffl ff ff delta delta delta ff 
hump delta delta delta gamma 
ff ff 
ffl ff ff gammac gamma gamma delta delta delta gamma ff 
hump gammac gamma gamma delta delta delta gamma gamma node precedes ff ff 
follows 
nodes preserve heights lemma proved 
follows lemma optimal schedule clustered 
standard order consider series sm subsequences nodes 
standard order satisfies properties standard order properties ffl series consists negative costs followed nonnegative costs ffl negative costs nondecreasing order height nonnegative costs nonincreasing order reverse height 
humps chain hm order series delta delta delta hm standard order hump decomposition property 
lemma subsequences nodes 
suppose abs bas series ba standard order 
example sequence clustered schedule graph 
note series humps schedule standard order reverse height hump zero second hump 
schedule obtained exchanging clustered humps height schedule 
proof lemma original version lemma restricts humps prove follows property holds restrictions 
heights nodes changed suffices ensure ab ba ffl series ba standard order 
follows 
ffl series ba standard order gamma gamma 


ffl 
cases equal lemma proved 
hump merging schedule standard form clustered series humps standard order 
schedule standard form 
recall lemma optimal schedule clustered 
humps clustered may order 
humps chain order schedule 
take consecutive humps different chains order exchange positions 
lemma resulting ordering height series exchanges eventually obtain follows height optimal 
argument shows schedule standard form optimal schedule fh hm series delta delta delta hm standard order 
suppose graph composed chains 
chain composed hump followed hump 
second chain composed humps 
schedule height 
schedule obtained previous clustering hump useful peak 
clustered schedule height 
obtained previous schedule clustering hump 
clustered schedule minimum height 
merge returns sequence nodes obtained concatenating humps standard order 
merge delta delta delta hm assume uniqueness merge breaks ties arbitrary fixed way 
argument lemma 
lemma composed disjoint chains merge ip decomp optimal schedule example shown 
schedule clustered series humps standard order optimal schedule graph 
abdel kameda show merge ip decomp obtained log time 
note output function merge may unique 
loss generality may define merge follows output unique suppose composed disjoint chains ip decomp 
define merge delta delta delta hm fh hm series delta delta delta hm standard order 
furthermore standard order contains contains precedes merge 
algorithm single pair graph composed disjoint chains recall 
cost node gamma 
valid 
nodes section show determine linear time precede valid subschedule notation vector nodes called cut node call th cutpoint prefix subgraph subgraph ip gamma 
frequently encounter cuts differ cutpoint denote cut defined schedule schedule node 
denote height optimal schedule 
suppose 
compute follows 
pred 
clearly sg optimal schedule optimal schedule 
direction true 
follows note nonnegative 
signify valid subschedule precedes 
signify true 
note partial order 
basic idea valid subschedule valid schedule prefix subgraph cut cut valid schedule precedes minimum contain follows 
problem determining reduced computing minimum height set chain graphs augmented arc clearly immediate questions arise 
compute height cope fact exponential number prefix subgraphs contain 
contained disjoint chains respectively 
observation ease situation 
suppose subschedule containing subschedule obtained discarding nodes succeeding clearly 
loss generality minimum computed cuts node subschedule considering schedule contains question longer issue 
turns second question issue 
show order obtain minimum height schedules suffices consider cuts 
particular cuts uniquely determined th cutpoint 
algorithm algorithm takes inputs 
contain contain algorithm proceeds iteratively different cutpoint precede iteration algorithm calls function best obtain minimum height schedule cuts designated comparing heights schedules respect different algorithm outputs minimum height schedules precede give algorithm compute best cut corresponding vw 
function best essential part algorithm 
subset pg cut looks best cut corresponding vw 
case interested fi jg 
optimal schedule returned 
note depends value maximum determined simply chains indices designated 
choices different mutually independent 
key efficient algorithm 
best explicitly specify hump representation cutpoint implicitly specified hump specifically step implies step step imply highest hump height considering schedules specified slightly differently 
step subchain pred schedule returned step 
correctness answer questions subsection 
sufficient try nodes function chain containing chain containing fvg decomp succ gamma best fi jg return function best decomp gamma decomp gamma pred decomp merge fh fh merge return algorithm compute best cut corresponding vw 

best return optimal schedule 
lemma cut suppose subchain containing 
hump containing 
valley pred 
define pred pred pred 
note pred lemma hump defined step 
lemma answers question 
definitions difficult see sequence returned best optimal schedule cut correctness relies lemma answers second question 
lemma cut 
subset pg containing best 

rest subsection prove lemma lemma 
need lemma prove lemma 
lemma cut suppose node preceding 
define valley 
proof second hump decomposition property exists series nodes subchain succ hump 
suppose optimal schedule 
obtained clustering hump succ useful peak 
lemma optimal schedule 
obtained removing hump succ 
clearly 
schedule 
lemma proved follows 
proof lemma pred choice immediate lemma 
hump definition decomp pred valley pred pred 
pred hump 
claim start hump 
valley pred pred valley start 
definition humps precede useful peak follows useful peak useful peak start 
start hump 
denote start 
clearly 
hump 
define lemma 
suppose optimal schedule clustered 
write inserting sequence succ immediately obtain schedule hs 
show 
equal maximum 
clearly 
combining obtain 
denote set gamma pg 
lemma special case lemma composed gamma numbers 
lemma cut 
best 

proof define valley gamma lemma cut schedule 
definition best differ th components 
show 
decomp gamma 
define merge defined step step best 
clearly sw optimal schedule 
sw 
choice contains hump 
uniqueness assumption merge write sw defined step best 
prove showing claims 
claim succeeds sw 
contains hump hump gamma appears obtain schedule sw inserting sequence succ immediately obtaining show 
equal maximum 
clearly definition defined step best composed humps heights choice hump gamma height follows standard order humps step best defined step best 
highest hump write follows case choice 
combining obtain sw 
claim proved 
claim precedes sw 
succ 
choice difficult see decomp gamma decomp gamma decomp choice decomp contains humps heights note hump height standard form suffix write sw removing sw obtain schedule 
show sw 
equal maximum 
clearly sw hump height follows sw combining obtain sw 
claim proved 
followed claims 
combining prove lemma 
ready prove lemma 
proof lemma recall equal best 
suppose cut optimal schedule 
algorithm prove lemma 
procedure proceeds iterations value varies pg 
value updated 
optimal schedule follows lemma holds loop 
show terminates lemma proved 
execution best 
execution best 
values change loop proceeds 
show eventually arguing eventually holds 
definition best step finished gamma contains humps 
iterations loop gamma contains hump henceforth hump decomp gamma iteration contains moved definition best 
follows value nonincreasing iterations moved algorithm terminates 
implementation recall decomp runs time linear jcj length chain follows time complexity step step 
suppose order nodes assigned loop order subsection focus implementing best loop runs time 
number iterations lemma ensures size jc 
follows number iterations 
procedure mod best cut optimal schedule algorithm transforms prove lemma showing algorithm terminates 
lemma suppose chain node costs sigma 
number humps decomp jcj 
proof costs nodes gamma hump height contains nodes 
reason hump reverse height contains nodes 
hump decomposition property heights humps decomp different reverse heights humps decomp 
humps humps decomp jcj 
proves lemma 
compact representation humps sake efficiency deal internal structure humps best 
suffices represent hump pair compact representation humps 
computed steps set pairs 
clearly steps takes time 
contents change different iterations 
step step need executed 
fi jg decomp gamma 
suppose th iteration 
order nodes assigned need recompute decomp gamma scratch 
th execution step gamma obtained appending hump succ gamma gamma gamma 
argument hump decomposition properties subsection th execution step takes ji gamma time 
follows lemma time complexity executions step theta 
priority tree compute efficiently need priority tree complete binary tree leaves 
leaf keeps values count 
cost st leaf number humps height st leaf count zero nonzero respectively 
internal node maximum children 
follows root priority tree correct value priority tree built time 
hump added deleted priority tree updated time logn 
fixed compute th iteration add humps gamma gamma remove humps gamma gamma update priority tree 
third hump decomposition property tp ji gamma gamma ji gamma gamma jc time complexity executions step theta log 
hump tree obtain value necessary know value need obtain height 
similarly actual value irrelevant 
compare step height 
need data structure compute heights efficiently 
set humps hump tree binary tree composed complete binary subtrees 
subtree leaves 
tn left subtree right subtree 
st leaf tn associates set humps height st leaf associates set humps reverse height gamma subtree rooted set humps associated leaves define merge merge 
clearly 

heights computed keep node hump tree takes space 
show compute node leaves root 
leaf humps height tn reverse height difficult see lx equal st leaf tn gamma gamma st leaf internal node computed information kept children suppose left right children respectively 
way associate humps leaves series hh standard order 
follows hump tree built time jlj 
built inserting hump done efficiently 
suppose insert hump add st leaf tn hump add gamma st leaf update simply update internal nodes path root deleting hump done similarly replacing addition subtraction 
clearly insertion deletion take time logn 
compute heights need maintain hump tree hump tree suppose gamma set humps gamma fh 
suffices maintain hump tree procedure th leaf tn root tn parent left child recompute recompute hump tree gamma procedure acts humps heights removed hump tree 
gamma hump gamma true 
hump tree values efficiently obtained procedure 
procedure acts humps heights removed hump tree gamma resulting respectively 
clearly takes logn time 
maintain hump tree gamma iteration log space keep modified information obtaining information need restore hump tree gamma time log 
th iteration 
obtain hump tree gamma gamma gamma need insert humps gammai gamma remove humps gamma gamma insertion deletion takes logn time follows time complexity obtaining hump tree previous iteration theta log 
recall building hump tree takes jlj time 
nodes ji gamma 
follows time complexity building hump tree gamma 
arguments implement best time complexity 
theorem proved 
algorithm pairs recall composed disjoint chains nodes 
section show determine relations pairs nodes linear time algorithm single pair nodes applied pairs takes time 
faster algorithm runs time np log 
algorithm denote node preceded valid subschedule output pair algorithm value node note means nodes preceded valid subschedule describe procedure computes pair algorithm simply calling convenience succ succ succ 
start 
procedure shown 
algorithm starts letting letting 
repeat loop proceeds replacing pred 
zero algorithm reports succ 
replacing pred repeat loop continues procedure search new 
correctness induction show correctly computes procedure keeps replacing pred 
succ 
succ start correct 

follows 
precedes succ succ 
succ correct value 
confirms induction basis 
procedure repeat succ pred pred algorithm compute suppose procedure correctly reports succ value succ certain iteration repeat loop 
need show remaining iterations correctly computed 
succ succ succ 
follows succeeding words locate node preceded suffices start testing reason reports correct value 
correctness ensured 
implementation show subsection implement run time jc jc log 
follows time complexity pair algorithm np log 
suppose time call hump tree gamma decomp decomp gamma pred gamma fh kp decomp follows subsection call computed time logn need considered 
remaining iterations replace pred replace pred 
remaining lemma guarantees compute need try cutpoint lemma consider iteration 
algorithm computes cutpoint zero 
proof definition computing succ succeeds assume contradiction node succeeding cut 
follows succ contradicts fact succ succeeds note iteration repeat loop moved position 
costs sigma hump decomposition property number humps updated gamma consecutive iterations constant 
execution takes time log 
number iterations repeat loop jc jc execution takes time jc jc theta log remaining thing efficiently build hump tree execution 
hump tree constructed time consider moment just finished pair algorithm call 
current hump tree fh kp decomp humps deleted execution 
obtain hump tree add humps fh decomp decomp delete humps fh decomp insert humps fh decomp decomp gamma pred hump decomposition done time jc jc jc jc insertion deletion humps done time jc jc jc jc theta log combining obtain time complexity pair algorithm jp jc jc jp jc jc theta log jp jc jc theta log np log 
theorem proved 
np completeness section show determining chain graphs operations semaphore 
proof reduction np complete uniform cost problem node costs restricted sigma 
reduction steps 
problem uniform cost graph nodes construct log chain graphs semaphores 
step reduction shows problem reduced determining log chain graphs valid schedule 
second step shows logn chain graphs simulated chain graph semaphores 
words simulated chain graph valid schedule simulating chain graph valid schedule 
step shows simulating chain graph valid schedule chain graph 
show proof works defined schedule definition notation chain graph 
node operation semaphore 
operation semaphore incrementing value gammas decrementing value 
subschedule valid value semaphore nonpositive execution subschedule 
nodes exists partial schedule precedes say clearly determining np 
allowed semaphore prove np hardness step reduction uniform cost problem 
step acyclic directed graph nodes cost node gamma 
suppose know 
construct chain graph composed chains operations semaphores argue valid schedule 
note obtained logn queries chain graph semaphores valid schedule 
number nodes positive costs 
gamma number nodes negative costs 
clearly gamma gamma sum node costs number outgoing arcs semaphores distinguish semaphores write ff fi chains initially empty 
construct procedure construct runs polynomial time 
loss generality assume gamma gamma number second statement procedure construct nonnegative 
construct arc append cost append ff cost gamma append gammas ff append ff gammas ff append copies gammas append gammas fi append copies fi append gamma gamma copies ff append copies gammas ff procedure constructs chain graph valid schedule 
example shown 
intuition follows 
operation ff corresponds sign ff reflects cost semaphores enforce execution operations ff obey precedence constraints imposed instance order reach gammas ff unlock chain 
gammas ff know ff executed gammas ff gammas fi ensure long fi executed operations executed 
function copies gammas ff clear larger easier valid schedule 
purpose ff gammas ff pairs gamma gamma copies ff clear proceed 
basically ensure kind pairwise schedule long valid schedule 
verify number gammas 
rest subsection prove gamma gamma fi ff ff gammas ff fi gammas ff gammas ff gammas ff fi fi ff ff ff gammas ff gammas ff fi gammas gammas gammas gammas gammas gammas gammas fi gammas fi gammas fi gammas fi gammas fi ff example step reduction 
suppose determine graph left 
construct construct chain graph right 
note ff gammas ff statements construct 
follows lemma lemma exists valid schedule chains right height graph left 
valid schedule 
implication proofs valid schedule valid schedule executable procedure pairwise proofs 
lemma valid subschedule contains ff 
proof valid subschedule described lemma show 
operation ff valid contains ff contain operations suppose order kn definition construct reachable precede follows sequence delta delta delta kn schedule suffices show 
assume contradiction 
count operations ff maximum value ff greater execution note gamma gammas ff hope bringing maximum value ff zero 
construction know gamma gammas ff preceded ff 
follows count operations ff maximum value ff greater zero execution contradicts fact valid schedule lemma immediate lemma 
lemma valid schedule 
lemma valid schedule 
proof delta delta delta kn schedule 
sum costs clearly gamma gamma sum node costs know claim executed procedure pairwise 
note schedule executed pair wise operation gammas immediately followed operation chain graph pairwise schedule show 
show loop pairwise finished procedure pairwise arc execute gammas execute ff execute gammas ff execute ff gammas ff execute gammas ff execute ff execute gammas fi execute fi gamma execute gammas ff execute ff procedure pairwise lemma th iteration loop pairwise executed furthermore executing th iteration ffl remaining operations copies gammas followed fi ffl gamma copies gammas ff available hard see execution loop pairwise remaining operation gammas fi second loop pairwise finished copies fi available lemma know executing loop number gammas ff gamma equal number ff loop pairwise finished 
lemma proved 
remains prove lemma proof lemma prove lemma induction convenience abbreviate entire proof 
know incoming arcs nodes 
loop index iteration execute operation 
consider statement 
ffl gammas ff gamma gamma 
ff definition construct 
execute part statement problem 
second operation gammas ff steps increase number gammas ff available 
ffl ff 
node 
execute part statement problem 
number gammas ff available decreased 
clearly executing iteration executed operation remaining operations exactly described lemma 
note executing iteration number available gammas ff definition construct 
executing iteration number available gammas ff exactly gamma confirms inductive basis 
integer assume lemma holds show holds consider th iteration 
note arc executed 
inductive hypothesis know copies gammas available executing th iteration 
index proceed problem exactly copies definition construct 
consider 
ffl gammas ff gamma gamma 
know ff part proceed problem 
second operation gammas ff steps increase number available gammas ff 
ffl ff gamma 
inductive hypothesis says number gammas ff available gamma gamma executing th iteration 
number gamma gamma gamma gamma 
part statement executed problem 
number available gammas ff decreased 
th iteration executed remaining operations required 
follows inductive hypothesis number available gammas ff gamma gamma case analysis see number exactly gamma executing th iteration 
lemma proved 
valid schedule lemma know 
follows proof lemma valid schedule executable pairwise 
lemma 
lemma valid schedule valid schedule executable pairwise 
second step subsection show constructed step simulated chain graph uses semaphores chains 
chain denoted composed gammat gammat 
remaining chains obtained follows 
replace operation gammas unit gammau 
unit gammau sequence operations shown 
denote chains clearly constructed polynomial time 
note sequence operations unit arranged gammau unlock 
specific suppose initial value case operations executed 
consider graph ij composed units gammau forms single chain 
easily verify ij valid schedule 
fact holds gammat 
gammat pairs gammat gammat gammat gammat gammat 
gammat pairs gammat gammat sequence operations gammau left right 
direction 
emphasize relevant proof 
executing operations ii values go back gamma 
claim valid schedule valid schedule 
part straightforward 
suppose valid schedule 
lemma know valid schedule executable pairwise 
note execute operations decrease value semaphores 
clearly remaining chains units completely executed sequence corresponding operations executed pairwise 
valid schedule 
takes added prove direction claim 
unit active third operation executed 
unit finished inactive fifth operation executed 
suppose valid schedule 
consider sequence units active valid schedule 
follows lemma corresponding sequence operations valid schedule fact pairwise schedule gammas immediately followed lemma consider execution valid subschedule 
active unit unit active gammau 
active gammau finished active 
unit active active units finished 
proof valid schedule unit active 
show statement lemma holds 
moment gammat gammat available 
hope activating unit unit guarded 
assume contradiction unit active 
note soon active executed 
gammat executed far way activate unit 
execution proceed 
unit gammau active see second statement lemma holds verifying 
ffl active gammau finished unit active execution blocked 
ffl active unit execution blocked 
ffl execution blocked 
execution blocked 
active unit units active order activate units hope gammat active order reach gammat preceding consecutive penetrated 
gammat active gammau executed 
active units gammau finished unit active 
confirms third statement lemma 
note soon active finished active gammau situation exactly situation execution 
gammat gammat available hope activating units 
argument follows inductively 
lemma proved 
third step operation operation claim valid schedule 
note considered valid schedules claim holds trivially node valid sub schedule general defined part straightforward reason 
remains prove direction claim 
valid subschedule precedes consider sequence units active executing follows lemma corresponding sequence operations valid subschedule definitely contains ff valid schedule lemma lemma 
follows claim subsection valid schedule 
abdel scheduling application register allocation deadlock problems university waterloo phd thesis 
abdel kameda scheduling minimize maximum cumulative cost subject series parallel precedence constraints operations research 
abdel kameda strictly optimal schedules cumulative scheduling problem computing 
ghosh padua event synchronization analysis debugging parallel programs supercomputing november 
garey johnson computers intractability guide theory npcompleteness freeman 
helmbold mcdowell class synchronization operations permit efficient race detection university california santa cruz technical report january 
helmbold mcdowell wang jz 
analyzing traces anonymous synchronization international conference parallel processing august ii ii 
lu klein netzer detecting race conditions parallel programs semaphore workshop algorithms data structures 
netzer ghosh efficient race condition detection shared memory programs post wait synchronization international conference parallel processing august ii ii 
netzer miller complexity event ordering shared memory parallel program executions international conference parallel processing august ii ii 

