heuristics automatic localization software faults technical report serc tr hsin pan eugene spafford software engineering research center computer sciences building purdue university west lafayette cs purdue edu july keywords software testing debugging dynamic program slicing fault localization 
developing effective debugging strategies guarantee reliability software important 
analyzing debugging process experienced programmers distinct tasks consistently performed determining statements involved program failures selecting suspicious statements contain faults making hypotheses suspicious faults variables locations restoring program state specific statement verification 
tasks performed direct assistance debugging tool debugging effort easier 
built prototype debugging tool spyder assist users conducting tasks 
spyder executes task dynamic program slicing fourth task backward execution 
research focuses second task reducing search domain containing faults referred fault localization 
heuristics dynamic program slices information obtained testing 
family tree heuristics constructed study effective application heuristics 
relationships heuristics potential order explored 
preliminary study conducted examine effectiveness heuristics proposed 
results study show promise fault localization heuristics suggest criteria precise application heuristics standard selecting thresholds 
new debugging paradigm equipped heuristics expected reduce human interaction time significantly aid debugging complex software 
research supported part software engineering research center purdue university national science foundation industry university cooperative research center nsf ecd national science foundation ccr 
condensed version appears 
software life cycle total cost may expended testing debugging phases ensure quality software 
developing effective efficient testing debugging strategies important 
standards terminology errors defined inappropriate actions committed programmer designer 
faults bugs manifestations results errors coding program 
program failure occurs unexpected result obtained executing program certain input existence errors faults 
testing explores input space program causes program fail debugging tries locate fix faults bugs failures detected test 
testing debugging closely related existing debugging tools attempt interface testing tools 
conventional debugging tools adb dbx command driven tend stand 
fault localization techniques current debugging tools setting breakpoints developed changed little 
users discover useful information debugging 
major steps involved debugging process locating correcting faults 
previous studies locating faults difficult important task debugging 
focus develop methods automatically localize faults enhance debugging process reduce human interaction time 
result study support new debugging paradigm proposed 
surveying experienced programmers debug software distinct tasks consistently performed determining statements involved program failures execution paths exact behavior program failures influence statements understood selecting suspicious statements contain faults making hypotheses suspicious faults variables locations restoring program state specific statement verification 
task achieved executing program step step debugging tools 
debugging tool automatically highlight execution path program input task accomplished efficiently 
second third tasks currently performed manually examining code program failures assistance debugging tools 
fourth task debugging tools dbx gdb support facilities allowing users set breakpoints code verify values variables 
obviously debugging effort easier tasks performed direct assistance debugging tool 
built prototype debugging tool spyder assist users conducting tasks :10.1.1.30.3437
spyder performs task dynamic program slicing automatically find dynamic slice program variables locations test cases terms data control dependency analysis 
dynamic slice denoted dyn wherep target program variable location andt test case :10.1.1.30.3437
dyn contains statements affecting value location executed test case execution paths program inputs special cases dynamic program slicing 
conducting fourth debugging task spyder restore program state desired location backtracking program execution location need program 
described focuses second task reduce search domain containing faults readers referred details dynamic program slicing backtracking respectively 
referred fault localization 
heuristics dynamic program slices provided spyder information obtained testing proposed 
rest organized follows 
heuristics proposed illustrated second section 
section family tree proposed heuristics constructed study effective application 
examples results preliminary studies heuristics section 
brief survey related section 
contributions extensions research suggested 
approach history development fault localization find techniques prototype systems programs restricted structure solve limited problems 
efficient debugging paradigm deals broader scope faults needed 
background tasks performed process debugging collect valuable information locating faults 
information may come program specification program behavior execution results program execution test cases testing deterministic decisions general approach systematically analyzes complicated information benefit debugging exist adopt heuristic approach gather useful information different cases 
believe heuristics cover varied situations help localize faults 
dynamic program slicing determine statements affecting program failures search domain faults reduced 
guaranteed dynamic slices contain faults missing statement specification faults investigate statements affecting program failures reasonable strategy debugging 
analyzing semantics values variables suspicious statements dynamic slices discover valuable information debugging 
choose dynamic slices search domain locate faults 
developed family heuristics reduce search domain dynamic slices provided spyder information obtained testing 
heuristic suggest set suspicious statements size usually smaller size dynamic slices 
proposed heuristics suitable specific kinds faults debugging power uniting heuristics expected surpass currently debugging tools 
testing phase cases running program different kinds information 
goal extract information possible debugging 
test cases get better results investigating information obtained testing 
prefer thorough test finish testing process satisfy criteria selected testing method possible 
thorough test existence faults program detected test case cause fail 
test cases called error revealing test cases td 
likewise test cases generates correct results called non error revealing test cases tu 
analyzing results program failures help identify suspicious variables output variables contain unexpected values 
dynamic slices respect suspicious variables corresponding test cases constructed heuristics 
dynamic slice dyn contains parameters target program variable location test case define metrics inclusion frequency influence frequency 
inclusion frequency statement number distinct dynamic slices containing statement influence frequency statement dyn number times statement visited dyn 
varying test case variable parameters get different kinds dynamic slices determine corresponding metrics 
heuristics applied dynamic slices metrics obtained 
moment effectiveness heuristics automatic fault localization different program location parameters clear subject ongoing research 
notations terminology heuristics listed appendix heuristics heuristics fault localization dynamic slices proposed 
heuristics constructed different test case parameters similar constructed different variable parameters 
vary variable parameter able verify value variable regard location test case 
error revealing non error revealing test case sets obtained directly thorough test preferred employ heuristics different test case parameters 
order explain heuristics clearly illustrate heuristics notations different test case parameters heuristics 
heuristics applied cases different variable parameters sixteen similar heuristics obtained heuristic 
heuristics heuristics proposed varying test case variable parameters 
clarity simplicity proposed heuristics primarily developed assuming fault failed program 
heuristics suitable case multiple faults 
heuristic indicate statements dyn tu jt dyn td statements dynamic program slices respect test cases non error revealing error revealing test cases highlighted 
heuristic covers statements available dynamic slices 
heuristic indicate statements dyn tu 
heuristic users focus statements dynamic program slices respect non error revealing test cases tu 
faulty statements statements fault triggered propagated result 
statements heuristics 
heuristic indicate statements low inclusion frequency dyn tu 
statement frequently involved correct results chance faulty 
exist non error revealing test cases tu error revealing test cases td heuristic employed find faulty statements dyn tu 
faulty statements exist lead wrong results executing test cases tu 
heuristic indicate statements dyn tu jt dyn td low including zero inclusion frequency counted non error revealing test cases tu 
failures may caused missing statements 
issue briefly discussed section 
modification heuristic 
statements dyn tu dyn td considered inclusion frequency statements counted tu simply zero 
idea heuristic faulty statements executed executed test cases tu 
approach flexible heuristic highlight suspicious statements heuristic 
heuristic indicate statements dyn tu intersection empty set 
study necessity statements correct results 
heuristic indicate statements highest inclusion frequency dyn tu heuristic intersection empty set 
studying necessity statements inevitable getting correct results help understand nature faults 
heuristic highlights exactly statements 
hand ignore statements lead correct results focus statements suggested heuristic 
heuristic indicate statements jt dyn td 
heuristic users focus statements dynamic program slices respect error revealing test cases td 
heuristic indicate statements high inclusion frequency jt dyn td 
statement leading incorrect results chance faulty errors confined statements executed 
exist error revealing test cases td non error revealing test cases tu heuristic employed find faulty statements dyn td 
heuristic indicate statements jt dyn td intersection empty set 
heuristic indicate statements highest inclusion frequency jt dyn td heuristic intersection empty set 
faults commonly cause program failures heuristic locate faulty statements quickly especially faulty statement single fault 
heuristic indicate statements difference set jt dyn td dyn tu jt dyn td dyn tu statements involved execution program failures tested cases tu statements appearing dynamic slices respect error revealing test cases td highly contain faults 
test cases td tu method worth trying 
statements indicated heuristic difference set results heuristic heuristic 
heuristic indicate statements difference set jt dyn td dyn tu jt dyn td dyn tu heuristic similar rigorous heuristic statements executed test cases td considered 
heuristic indicates statements appearing dynamic slices error revealing test cases failures dynamic slices non error revealing test cases correct results 
difference set empty 
heuristic indicate statements difference set dyn tu jt dyn td dyn tu jt dyn td executed non error revealing test cases tu statements included get correct results 
statements lead incorrect result 
dependency analysis statements may provide useful information locating faults 
heuristic indicate statements finding difference set results heuristic heuristic 
ignore statements contribute correct results focus statements suggested heuristic 
heuristic indicate statements difference set dyn tu jt dyn td dyn tu jt dyn td heuristic similar rigorous heuristic statements executed test cases tu considered 
heuristic indicates statements appearing dynamic slices non error revealing test cases correct results dynamic slices error revealing test cases failures 
difference set empty 
heuristic indicate statements dyn tu jt dyn td high inclusion frequency jt dyn td low inclusion frequency dyn tu 
heuristic combination heuristics 
suitable statements involved dyn td dyn tu elements td tu thorough test 
statements leading incorrect results involved correct program execution highly contain bugs 
statements ratio corresponding inclusion frequency dyn td corresponding inclusion frequency dyn tu useful indicator 
higher ratio statement higher chance statement contains faults 
heuristic set statements located heuristics especially indicating statements low inclusion frequency dyn tu heuristics contain faults belongs branch decision block exp exp logical expression exp examined 
logical expression exp executed decide executed inclusion frequency predicate statement statement statement equal greater 
indication predicate statement inclusion frequency effective 
heuristic reminds users examine logical expression exp predicate statement 
heuristic indicate statements high influence frequency dyn td 
influence frequency measures effect statements executed loop counted inclusion frequency 
logic heuristic heuristic statements contributing incorrect results faulty 
heuristic indicate statements low influence frequency dyn tu 
heuristic words excludes statements high influence frequency dyn tu statements leading correct results faulty 
heuristic heuristics sixteen similar heuristics obtained varying variable parameter different test case parameters respect cases able verify value suspicious variables respect location test case order construct vd having incorrect value vu having correct value 
sixteen new heuristics indicate potential faulty statements feature dynamic slices variable parameter 
heuristic indicate statements jv stmt vd tx tx represents selected test case td tu stmt tx set statements suggested heuristics vd mentioned heuristic 
idea heuristic similar heuristic 
wrong variable values caused fault statements indicated heuristic suspicious 
heuristic indicate statements jv stmt vd tx stmt vu tx heuristic derived heuristic information obtained varying variable test case parameters 
heuristic indicate statements jv stmt vd tx stmt vu tx heuristic derived heuristics 
specific criteria applying heuristics studied 
example threshold statements high inclusion frequency jt dyn td suggested highest percent statements union sorted inclusion frequency 
users allowed set threshold different purposes 
preliminary study discovers better way decide threshold 
suggestion discussed section 
heuristics experiments relational decision decision path analysis execution paths studied cousins 
approaches similar concept heuristic useful theirs 
approach moment allows users vary parameters variable test case dynamic slices contain statements affecting program failures possible faulty statements suggested heuristics family tree proposed heuristics superset subset relationship derivation relationship intermediate node threshold needed precise suggested theirs approaches 
information provided heuristics 
aid heuristics reduced search domain faults smaller set suspicious statements anticipated 
functions dynamic instrumentation provided spyder help manage examination 
instance reaching definition shows latest definition variable subset def chain program dependency analysis enables trace back find place suspicious variable went wrong 
backtrack function effectively executes program reverse preset breakpoint reached just forward program execution suspended breakpoints 
short efficient debugging session conducted locating faults reduced domain heuristics effective functions dynamic instrumentation 
analysis constructed family heuristics study effective algorithms applying heuristics 
family relationships heuristics potential order explored 
examined heuristics different test case parameters heuristics constructing family tree 
argument applied heuristics different variable parameters indicated heuristic 
node represents heuristic 
solid line connects upper parent lower child nodes superset subset relationship statements indicated parent upper node contain child lower node 
dotted line links upper node lower node derived upper node superset subset relationship 
bold nodes heuristics require thresholds dot intermediate nodes heuristics derived construct complete family tree 
statements highlighted heuristics intermediate nodes give basic information debugging 
contrast descendant heuristics provide helpful information 
intermediate nodes heuristic root family tree heuristic root subtree respect non error revealing test cases heuristic root subtree respect error revealing test cases 
applied traversing heuristics tree 
heuristics subtree rooted dynamic slices respect non error revealing test cases 
heuristics especially different highlight statements lead correct results suggest studying necessity statements correct results 
ignore statements focus statements involved family tree statements suggested heuristic 
case represent corresponding compliment heuristics 
heuristics dynamic slices respect error revealing non error revealing test cases functions interpreted global analysis 
hand conduct local analysis dynamic slice time 
prefer perform global analysis 
local analysis conducted reduce search domain locate faulty statements 
family tree heuristics threshold requirements especially nodes preferred threshold requirements 
suggest precise set statements indicate different set statements different thresholds 
pair nodes superset subset relationship parent heuristic evaluated child heuristic conducts analysis result parent heuristic analysis 
discussion global analysis summarized group applying heuristics nodes 
group applying heuristics threshold requirements 
search domains provided heuristics group contain statements provided heuristics group 
top order employing heuristics preferred results upper nodes lower nodes 
heuristic try strictest threshold 
faulty statements suggested region threshold increased gradually search domain expanded accordingly 
group applying suspicious statements ignored heuristics 
traversing family tree interpret top steps refining suspicious statements bottom steps extending search domain 
users guess get set suspicious statements examination 
tool help refine extend search domain traversing family tree heuristics 
result global analysis set suspicious statements reduced search domain dynamic slices 
verify faulty statements heuristics performing local analysis employed dynamic slice time 
statements indicated global local analyses examined highlighted statements 
program executable blocks decisions uses fault types statements wrong logical expression wrong logical operator find wrong variable find wrong variable find missing statement faults find find gcd wrong initialization value naur missing simple logical expression naur missing simple logical expression naur missing predicate statement transp wrong initialization value wrong logical operator table tested programs techniques steps discussed applied heuristics different variable parameters indicated heuristic heuristics different test case variable heuristics 
reduced search domain faults proposed heuristics analysis needed identify faulty statements highlighted suspicious region 
ongoing research provide automated decision support verification 
results preliminary study simple trial conducted examine effectiveness heuristics proposed 
major goal fault localization reduce search domain containing faults effectiveness analyzed comparing known faulty statements suspicious domains suggested heuristics tested program 
section discuss selection tested programs results obtained applying heuristics 
tested programs eleven test programs selected constructed programs 
programs collected previous studies known experimental programs previously studied faults 
table gives size complexity tested program 
column lists number executable statements showing size tested program 
columns obtained data flow coverage testing tool automatic test analysis programs developed bellcore 
definitions quoted man pages 
column blocks represents number code fragments containing control flow branching 
column decisions shows number pairs blocks block ends control programs described appendix prog 
types blocks decisions uses uses tu td tu td find tu td find tu td find tu td gcd tu td naur tu td naur tu td naur tu td transp tu td tu td table measurement test case adequacy flow branch second block target branches 
column uses predicate uses indicates number triples blocks block contains assignment variable second block ends control flow branch predicate containing variable third block target branches 
column uses sum uses pairs blocks block contains assignment variable second block contains variable contained predicate 
data flow coverage criteria columns help understand complexity tested program 
fault types tested program column 
tested programs fault easily examine effectiveness proposed heuristics fault localization 
results mentioned section thorough test preferred applying proposed heuristics 
conduct thorough test construct test case sets non error revealing test case set tu error revealing test case set td 
set data flow criteria selected program provided tested program analyzed blocks decisions uses uses 
test case satisfies criteria certain degree executed tested program 
summary satisfaction degree table consists percentage counts criteria show adequacy prog 
find find find gcd naur naur naur transp highlighted statements contain faulty statements highlighted statements executable statements highlighted statements statements highlighted table effectiveness analysis heuristics threshold requirements selected test cases 
employed satisfy coverage criteria possible guarantee adequacy 
experiment test cases tu added improve satisfaction degree causing program failure 
test cases td added improve satisfaction degree program failure 
information table contains highest percentage reached selected test cases 
heuristics applied tu td output variables tested programs spyder 
set suspicious statements suggested heuristic selected program 
measure effectiveness proposed heuristic examined known faulty statements contained suggested statements 
compared reduced domain size original tested program number executable statements domain suggested root heuristic family 
results rows tables 
percentage entry tables tells degree effectiveness reduced search domain 
star superscript entry indicates suggested statements containing known faulty statements 
heuristics low promising percentage especially row preferred 
prog 
find find find gcd naur naur naur transp highlighted statements contain faulty statements highlighted statements executable statements highlighted statements statements highlighted table continued effectiveness analysis heuristics threshold requirements discussed section heuristics threshold requirements applied heuristics requirements 
results applying heuristics threshold requirements table 
heuristics considered separately intermediate nodes search domains highlighted significantly reduced domain provided 
interested heuristics table 
entries empty set related heuristics indicate suspicious statements fault localization ignored 
empty set provided corresponding compliment heuristic ignored search domain indicated compliment heuristic size suggested 
features mentioned section heuristics complement heuristics considered find effective methods applying 
instance high percentage row program transp indicates suggested domain reduced 
domain suggested examined small size 
low percentage row program gcd precisely indicates statements correct results semantics statements help realize faults tested program 
ignored corresponding prog 
find find find gcd naur naur naur transp highlighted statements contain faulty statements highlighted statements executable statements highlighted statements statements highlighted rank critical level ranked levels effective table effectiveness analysis heuristics critical threshold requirements high percentages 
heuristics threshold requirements table 
statements involved heuristic threshold requirements ranked metric heuristic inclusion frequency grouped ranks statements rank group 
different groups rank associated group contains fault referred critical level 
threshold heuristic set critical level assure suggested domain containing faults 
minimal threshold referred critical threshold 
critical level decided suspicious statements highlighted heuristic 
table rows critical thresholds ratio rank critical level number ranked levels ratio suspicious statements critical level statements involved heuristic statements highlighted respectively 
faulty statements belong statements involved heuristic critical threshold entry rows program transp table 
entry indicating statements low inclusion frequency dyn tu program example illustration 
groups different inclusion frequency obtained dyn tu group ranked lowest inclusion frequency contains statements second group ranked contains statements inclusion frequency third group ranked contains statement inclusion frequency fourth group ranked contains statement inclusion frequency fifth group ranked contains statement inclusion frequency 
faulty statement statement second group 
critical level associated second group seventeen statements including faulty having statements second having statements groups highlighted 
decide critical threshold row ranks ratio rank critical level total number ranked levels critical threshold row statements ratio suspicious statements critical level statements suggested 
heuristic designed enhance location faults predicate expression heuristics effective 
consider results heuristics precise critical threshold hard define 
table rows indicate number predicate statements tested program divided number executable statements number statements highlighted respectively 
row tells effectiveness locate faulty predicate statements 
means heuristic applicable faults corresponding tested program predicate statements 
means faulty predicate statements located heuristic combined heuristics 
heuristic provide effective information heuristics locating faulty predicate statements 
discussion determination thresholds heuristics requirement affect effectiveness size suggested domains 
unique threshold suggested domain reasonably small consistently contain faults highly desirable 
table critical thresholds various heuristics row range 
standard threshold decided wide scope 
hand find critical thresholds row 
thresholds ranked levels easy ranked level gradually 
conclude choose thresholds ranked levels ranked levels standard threshold time criterion employing heuristics 
comparing size percentage search domains suggested heuristics tested program cases domains provided heuristics threshold requirement precise provided heuristics requirement 
prefer examine search domains suggested heuristics threshold requirements extra effort needed decide critical thresholds 
tables hard conclude heuristic effective 
appropriate heuristics proposed handle different situations 
program behavior type faults affect effectiveness heuristics 
provide general approach apply heuristics 
types faults missing assignment heuristics directly cover faults suggested domains 
analyzing statements highlighted heuristics semantics suspicious variables statements analysis approaches mentioned lead identification faults :10.1.1.30.3437
instance missing predicate statement program naur located analyzing semantics statements suggested heuristics table 
faults wrong initialization program gcd transp changed missing initialization statements indirectly locate faults missing initialization statements analyzing semantic variables suspicious statements highlighted heuristics 
approaches fault localization test knowledge error revealing mutations derived mutation testing dynamic program slices currently development authors 
approaches help fault localization 
related section brief survey typical fault localization techniques 
traditional debugging techniques dumping memory scattering print statements setting breakpoints users tracing program execution provide utilities examine snapshot program execution 
users strategies fault localization 
shapiro proposed interactive fault diagnosis algorithm divide query algorithm debugging programs represented computation tree logic programs written prolog 
computation tree target program recursively searched bugs located fixed 
applied approach locating faults programs written pascal 
method users point procedures contain bugs debugging tools needed debug faulty procedures 
similar result obtained 
knowledge approach attempts automate debugging process techniques artificial intelligence knowledge engineering 
knowledge classified faults nature program behavior usually required approach 
prototype debugging systems developed approach early 
knowledge programs real world complicated 
prototype systems handle restricted fault classes simple programs 
program slicing proposed weiser approach debugging 
method decomposes program statically analyzing data flow control flow program referred static program slicing 
program dicing proposed lyle weiser attempts collect debugging information correctness suspicious variables involved static program slices 
focus debugging tool program dicing find location fault 
static program slices contain irrelevant statements fault localization inefficient studying program slicing dynamic cases get exact execution path warranted 
dynamic program slicing powerful facility debugging dependency analysis 
systematically applied fault localization 
agrawal dissertation briefly alluded idea combining dynamic program slices data slices fault localization :10.1.1.30.3437
heuristics dynamic slices collected varying test cases variables location variables 
current testing debugging tools separate 
tool functions integrated benefit 
osterweil tried integrate testing analysis debugging gave solid transform information testing debugging benefit 
clark richardson suggest certain test strategies symbolic evaluation classified failure types debugging purposes 
example describe idea research conducted 
stad system testing debugging tool successfully integrate debugging testing 
mentioned testing debugging parts share information implementation purposes share results data flow analysis 
debugging part stad invoked fault detected testing session leads users focus possible erroneous part program locate fault precisely 
program error locating assistant system implementation debugging tool stad 
korel laski proposed algorithm hypothesis test cycles knowledge obtained stad localize faults interactively 
stad supported subset pascal limited program errors considered 
cousins proposed heuristics locate suspicious statement blocks testing 
program partitioned decision decision paths dd paths straight line codes existing consecutive predicates program 
test data sets obtained testing detects existence faults 
heuristics employed predict possible dd paths containing bugs number times dd paths involved test data sets 
ideas related heuristic fault localization strategies proposed 
deficiency method execution paths dd paths special case dynamic program slicing examined 
reducing search domain statement blocks dd paths suggestion provided locating bugs 
approaches proposed lyle weiser cousins suspicious variables test cases respectively heuristics developed considering test cases variables location variables 
believe methods obtain helpful information reduce search domain effectively 
concluding remarks support spyder proposed heuristics new debugging scenario described follows users find program failures testing methodology provided integrated testing tool debugging tool interactively helps users reduce search domain faults dynamic instrumentation dynamic program slicing backtracking information obtained testing phase tool supports fault prediction strategies reduced domain test information users retest program assure program failure prevented faults located fixed 
tool support new debugging scenario integrated testing environment conduct program dependency analysis monitor execution history backtracking provide fault prediction strategies information obtained failure analysis fault classification 
set heuristics proposed confine search domain bugs small region 
heuristics dynamic program slices collected varying test cases variables location variables 
preliminary results studies indicate effectiveness feasibility proposed heuristics 
guaranteed faults domains suggested proposed heuristics confined small region containing faults information leading fault discovery provided analysis 
continue study nature program failures faults information obtained testing methodology develop foundation heuristics develop promising approaches 
expect new debugging paradigm equipped heuristics significantly reduce human interaction time aid debugging complex software 
authors richard demillo suggesting idea constructing family tree proposed heuristics section agrawal building prototype debugging tool spyder shi liu martin reviewing early drafts article 
bellcore making available research purdue 
th pacific northwest software quality conference reviewers provided valuable comments suggestions 
agrawal demillo spafford 
dynamic slicing presence unconstrained pointers 
proceedings acm sigsoft fourth symposium testing analysis verification tav pages victoria british columbia canada october 
agrawal demillo spafford 
execution backtracking approach program debugging 
ieee software may 
agrawal horgan 
dynamic program slicing 
proceedings acm sigplan conference programming language design implementation pages white plains new york june 
acm sigplan notices june 
agrawal spafford 
execution backtracking approach program debugging 
proceedings th pacific northwest software quality conference pages portland oregon september 
agrawal spafford 
bibliography debugging backtracking 
acm software engineering notes april 
agrawal :10.1.1.30.3437
automatic debugging computer programs 
phd thesis purdue university west lafayette indiana august 
released technical report serc tr software engineering research center purdue university west lafayette indiana september 
ansi ieee 
ieee standard glossary software terminology 
ieee std 
ieee new york 
boyer levitt 
select system testing debugging programs symbolic execution 
proceedings international conference reliable software pages 
acm sigplan notices june 
gordon bradley 
algorithm bound greatest common divisor integers 
communications acm july 
budd 
mutation analysis program test data 
phd thesis yale university new haven connecticut 
lori clarke debra richardson 
application error sensitive testing strategies debugging 
proceedings acm sigsoft sigplan software engineering symposium high level debugging pages pacific grove california march 
acm software engineering notes august acm sigplan notices august 
james larry cousins 
automatic software fault location decision decision path analysis 
afips proceedings national computer conference pages chicago illinois june 
demillo lipton 
hints test data selection help practicing programmer 
computer april 
ducasse anna maria emde 
review automated debugging systems knowledge strategies techniques 
proceedings th international conference software engineering pages singapore april 
kevin dunlap 
debugging dbx 
unix programmers manual supplementary documents berkeley software distribution 
computer science division university california berkeley california april 
frankl stewart weiss 
experimental comparison effectiveness uses edges adequacy criteria 
proceedings acm sigsoft fourth symposium testing analysis verification tav pages victoria british columbia canada october 
peter fritzson kamkar 
generalized algorithmic debugging testing 
proceedings acm sigplan conference programming language design implementation pages toronto canada june 

test data aid proving program correctness 
communications acm may 
goodenough gerhart 
theory test data selection 
ieee transactions software engineering se june 

algorithm 
acm transactions mathematical software 
hoare 
algorithm find 
communications acm april 
horgan london 
data flow coverage language 
proceedings acm sigsoft fourth symposium testing analysis verification tav pages victoria british columbia canada october 
bogdan korel 
program error locating assistant system 
ieee transactions software engineering se september 
bogdan korel janusz laski 
stad system testing debugging user perspective 
proceedings second workshop software testing analysis verification pages banff canada july 
bogdan korel janusz laski 
dynamic slicing computer programs 
journal systems software november 
bogdan korel janusz laski 
algorithmic software fault localization 
proceedings fourth annual hawaii international conference system sciences pages hawaii january 
james lyle 
evaluating variations program slicing debugging 
phd thesis university maryland college park maryland december 
james lyle mark weiser 
automatic program bug location program slicing 
proceedings nd international conference computers applications pages beijing prc june 
mcnamee 
algorithm sparse matrix package part 
communications acm april 
myers 
art software testing 
john wiley sons 
naur 
programming action clusters 
bit 
leon osterweil 
integrating testing analysis debugging programs 
editor software validation pages 
elsevier science publishers north holland 
pan spafford 
automatic localization software faults 
proceedings th pacific northwest software quality conference portland oregon october 
hsin pan 
debugging dynamic instrumentation test knowledge 
technical report serc tr software engineering research center purdue university west lafayette indiana september 
roger pressman 
software practitioner approach 
mcgraw hill second edition 
ramamoorthy ho chen 
automated generation program test data 
ieee transactions software engineering se december 
scott 
location logical errors pascal programs appendix implementation problems waterloo prolog technical report uiucdcs department computer science university illinois urbana champaign urbana illinois april 

uiuc eng 
rudolph 
knowledge program debugging systems 
ieee software may 
ehud shapiro 
algorithmic program debugging 
mit press cambridge massachusetts 
phd thesis yale university new haven connecticut 
richard stallman 
gdb manual third edition gdb version 
free software foundation cambridge massachusetts october 
iris vessey 
expertise debugging computer programs process analysis 
international journal man machine studies november 

fault investigation trial 
technical report serc tr software engineering research center purdue university west lafayette indiana september 
mark weiser 
programmers slices debugging 
communications acm july 
mark weiser 
program slicing 
ieee transactions software engineering se july 
mark weiser jim lyle 
experiments slicing debugging aids 
elliot soloway iyengar editors empirical studies programmers pages 
ablex publishing norwood new jersey 
workshop empirical studies programmers washington dc june 
appendix notations terminology notation terminology proposed heuristics follows td set error revealing test cases detect existence faults represents number test cases td 
tu set non error revealing test cases detect existence faults represents number test cases tu 
vd vu set variables incorrect correct value respect location test case andp ld lu set locations variable incorrect correct value respect dyn dynamic slice contains statements affecting value location executed test case dyn td td td dynamic slice respect error revealing test case td dyn tu tu tu dynamic slice respect non error revealing test case tu dyn vd vd vd dynamic slice respect variable vd incorrect value 
dyn vu vu vu dynamic slice respect variable vu correct value 
dyn td union dynamic slices different test case parameters respect error revealing test cases 
dyn tu union dynamic slices different test case parameters respect non error revealing test cases 
dyn td intersection dynamic slices different test case parameters respect error revealing test cases 
dyn tu intersection dynamic slices different test case parameters respect non error revealing test cases 
inclusion frequency statement number dynamic slices containing statement 
influence frequency statement dyn number times statement visited dyn 
slightly different notations study dyn ld dyn lu dyn vd dyn vu dyn vd dyn vu 
interpretations similar 
appendix tested programs source code tested programs written programming language may obtained authors 
program calculates mean set input integers 
percentages inputs equal mean number inputs equal mean divided total number inputs reported 
version directly translated pascal version fault accidentally introduced transformation 
fault incorrect logical expression statement 
working variable mean integers value zero calculation result incorrect 
calendar program analyzed budd tries calculate number days days year 
wrong logical operator placed compound logical expression statement 
fault causes errors leap years 
find program hoare deals input integer array size input array index execution elements left equal elements right greater equal 
faulty version find called extensively analyzed select demillo frankl weiss 
experiment find version includes missing statement fault wrong variable logical expressions 
wrong variable placed find find respectively 
bradley gcd program analyzed budd calculates greatest common divisor elements input integer array experiment missing initialization fault gcd changed wrong initialization erroneous constant 
gerhart goodenough analyzed erroneous text formatting program originally due naur 
minor modification program experiment 
specification program follows text consisting words separated blanks nl new line characters convert line line form accordance rules line breaks text blank nl line filled far possible long lines contain characters 
program naur missing path fault simple logical expression compound logical expression missing 
fault blank appear word line word exact length characters 
form line incorrect judged rule 
program naur missing path fault simple logical expression compound logical expression missing 
fault causes word input text ignored word followed blank nl 
program naur contains missing predicate statement fault statement missing 
case provision process successive line breaks blanks 
program transp adopted experiment frankl weiss generates transpose sparse matrix density exceed 
faults identified original fortran program 
translated correct version reintroduced faults 
fault happens features fortran language reproduced fault wrong initialization erroneous constant 
tested program known experimental program takes input integers length sides triangle decides type triangle scalene isosceles equilateral illegal 
program contains faulty statements fault type wrong logical operator 

