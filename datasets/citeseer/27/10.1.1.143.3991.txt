safe programming level abstraction dissertation faculty graduate school cornell university partial fulfillment requirements degree doctor philosophy daniel joseph grossman august daniel joseph grossman rights reserved safe programming level abstraction daniel joseph grossman ph cornell university memory safety type safety invaluable features building robust software 
safe programming languages high level abstraction programmers little control data representation memory management 
control reason remains de facto standard writing systems software extending legacy systems written cyclone language aims bring safety style programming sacrificing programmer control necessary low level software 
combination advanced compile time techniques run time checks modern language features helps achieve goal 
dissertation focuses advanced compile time techniques 
type system quantified types effects prevents incorrect type casts dereferences data races 
intraprocedural flow analysis prevents dereferencing null pointers uninitialized memory extensions prevent array bounds violations misused unions 
formal machines rigorous proofs demonstrate compile time techniques sound safety violations address impossible 
formal evaluation establishes design goals equal importance 
language remains expressive 
rejects safe programs permits idioms regarding generic code manual memory management lock synchronization null pointer checking data initialization 
second language represents unified approach 
small collection techniques addresses range problems indicating problems alike originally 
biographical sketch dan grossman born january st louis missouri 
far diligent support st louis sports teams produced world series victory appearances super bowl victory appearances stanley cup finals 
graduating parkway central high school dan peers selected male politician 
dan spent summers working scout 
years managed camp business operations typewriter carbon adding machine 
dan received computer science electrical engineering rice university 
awards signified termination convenient access la restaurant produces world best 
dan completed hiking mile trail 
day describe really long walk years dan lived primarily ithaca new york completing doctorate computer science cornell university 
ice hockey skills improved considerably 
dan state united states alaska hawaii nevada michigan minnesota wisconsin south carolina 
airports michigan minnesota nevada south carolina 
lifetime dan eaten green 
iii drew myers 
enjoyed great mentors summer john reppy rob deline undergraduate matthias felleisen 
cornell computer science staff members particularly great help 
friends dinner bought beer played hockey soccer went theatre played bridge cases time ithaca truly special 
person gets see name paragraph 
effort brief just say kate responsible leaving ithaca happier person arrived 
family shown support pursuits come surprise encouraged graduate school 
occasionally ignored advice read papers 
importantly taught dedication integrity prerequisites undertaking nature 
am grateful financial support national science foundation graduate fellowship intel graduate fellowship 
vi table contents thesis safe level programming 
relation dissertation cyclone 
explanation thesis 
contributions 
overview 
examples techniques type variables 
singleton integer types 
region variables 
lock variables 
summary type level variables 
definite assignment 
null pointers 
checking tag variables 
interprocedural flow 
summary flow analysis applications 
type variables basic constructs 
universal quantification 
existential quantification 
type constructors 
default annotations 
size calling convention 
mutation 
polymorphic 
mutable existential packages 
informal comparison problems 
vii evaluation 
news 
bad news 
formalism 
syntax 
dynamic semantics 
static semantics 
type safety 
related 
region memory management basic constructs 
region terms 
region names 
quantified types type constructors 
subtyping 
default annotations 
interaction type variables 
avoiding effect variables 
existential types 
run time support 
evaluation 
news 
bad news 
advanced examples 
formalism 
syntax 
dynamic semantics 
static semantics 
type safety 
related 
type safe multithreading basic constructs 
multithreading terms 
multithreading types 
multithreading kinds 
default annotations 
interaction type variables 
interaction regions 
viii comparing locks regions 
combining locks regions 
run time support 
evaluation 
news 
bad news 
formalism 
syntax 
dynamic semantics 
static semantics 
type safety 
related 
uninitialized memory null pointers background contributions 
basic analysis 
reasoning pointers 
evaluation order 
analysis 
states 
expressions 
statements 
extensions 
evaluation 
reality 
run time solutions 
supported idioms 
unsupported idioms 
example iterative list copying 
example cyclic lists 
constructor functions 
formalism 
syntax 
dynamic semantics 
static semantics 
iterative algorithm 
type safety 
related 
ix array bounds discriminated unions compile time integers 
types 
quantified types 
subtyping constraints 
arrays 
discriminated unions 
evaluation 
related 
making arrays safe 
static analysis 
languages 
related languages systems programming languages 
language interoperability 
safe machine code 
safe implementations 
static approaches 
summary techniques 
limitations 
implementation experience 
context 
chapter safety proof chapter safety proof chapter safety proof chapter safety proof bibliography list figures chapter formal syntax 
chapter dynamic semantics statements 
chapter dynamic semantics expressions 
chapter dynamic semantics heap objects 
chapter dynamic semantics type substitution 
chapter kinding context formedness 
chapter typing statements 
chapter typing expressions 
chapter typing heap objects 
chapter return 
chapter typing states 
chapter formal syntax 
chapter dynamic semantics statements 
chapter dynamic semantics expressions 
chapter dynamic semantics heap objects 
chapter dynamic semantics type substitution 
chapter kinding formedness 
chapter effect constraint containment 
chapter typing statements 
chapter typing expressions 
chapter typing heap objects 
chapter return 
chapter typing deallocation 
chapter typing states 
example multithreading terms type information example correct multithreaded cyclone program 
chapter formal syntax 
chapter dynamic semantics programs 
chapter dynamic semantics statements 
xi chapter dynamic semantics expressions 
chapter dynamic semantics type substitution 
chapter kinding formedness context sharability 
chapter effect constraint containment 
chapter typing statements 
chapter typing expressions 
chapter return 
chapter typing release 
chapter typing junk 
chapter typing states 
chapter formal syntax 
chapter semantics bindings renaming 
chapter dynamic semantics statements 
chapter dynamic semantics expressions 
chapter formedness 
chapter ordering 
chapter typing statements 
chapter typing expressions 
chapter typing tests 
chapter typing program states 
chapter safety proof invariant 
chapter safety proof invariant 
xii chapter thesis programming languages implementations essential tools software development provide precise framework specifying computer behavior realizing specification 
language easier constructs language level abstraction suitable task hand 
programming language originally developed writing operating system just type program 
level abstraction programs complete control byte level representation data placement data memory 
lower levels abstraction control flow limited intraprocedural jumps function call return 
programmer manage data processing needs tedious assembly level decisions instruction selection register allocation procedure calling convention 
level abstraction appeals tasks operating systems device drivers resource constrained embedded systems runtime systems higher level languages data lack better term call problems level tasks 
higher level languages provide strong abstractions allow defined modular programs 
example bad fragment program arbitrarily modify part entire program data 
incorrect behavior worse function exits program diverges computes wrong answer local defined effects 
date programmers level tasks choose safe languages higher levels abstraction unsafe languages natural level 
language designers proposed various solutions dilemma 
convince developers task really level task desire control data representation resource management misguided 
second provide debugging tools traditional debuggers lint tools unsafe languages 
third provide foreign function interfaces safe language code call code vice versa 
fourth compile code unconventional manner safety violations detected occur run time 
alternative propose rich language static invariants source level flow analysis provide programmers convenient safe language level abstraction 
substantiate claim colleagues developed cyclone programming language implementation safe 
dissertation focuses certain cyclone language design features 
particular evaluates cyclone type system flow analysis addresses safety issues uniform manner 
rest introductory chapter motivates compile time guarantees level programming section provides cursory description actual cyclone language dissertation narrower focus section explains dissertation thesis section highlights technical contributions section describes structure subsequent chapters section 
particularly urge reading section properly acknowledges cyclone 
dissertation assumes familiarity type systems operational semantics chapters require familiarity safe level programming memory safety crucial writing reasoning software 
example consider program uses simple password checking routine int check char static char pwd return strcmp pwd pwd variable visible check function function mutates pwd conclude function passes pointer array holding second argument strcmp 
legal program property holds 
illegal programs compilers reject 
implementation programs undefined conventional compilers choose implementations mutate pwd 
soundly reasoning check requires rest program safety violations 
dissertation explains prevents safety violations including incorrect type casts dangling pointer dereferences data races uninitialized memory null pointer dereferences array bounds violations incorrect unions 
safe languages exist variety techniques enforce safety 
language restrictions certain violations impossible 
example uninitialized memory impossible declarations initializers 
automated memory management garbage collection prevents dangling pointer dereferences 
advanced type systems support generic code allowing unsafe type casts 
run time checks prevent safety violations execution 
example safe languages prevent array bounds violations storing array lengths arrays implementing subscript operations check lengths 
safe language cyclone uses techniques 
particular quantified types similar ml haskell 
level language gives programmers substantial control data representation resource management run time checks 
treat higher level language counterproductive level tasks 
inappropriate rely exclusively hidden fields array lengths garbage collection 
cyclone programmers cyclone language express safety critical properties lifetime data objects array lengths stored 
design point challenging compared language express properties exposed programmers described language 
compared higher level languages properties exposed programmers left implementation 
dissertation explores set uniform techniques addresses challenge 
relation dissertation cyclone cyclone implementation currently available world wide web www cs cornell edu projects cyclone www research att com projects cyclone 
distribution includes tens thousands lines cyclone code part compiler written cyclone 
extensive user manual describes full language overview previously published 
section briefly summarize cyclone techniques applications explaining dissertation focus departures actual cyclone 
cyclone safe programming language retains extent possible syntax semantics idioms ideally cyclone permit exactly programs safe known ideal mathematically impossible 
restrict programs manageable subset subset impoverished realistic programming 
extensions discussed detail dissertation programmers express invariants cyclone compiler infer 
extensions capture idioms require features disallowed cyclone 
example cyclone exceptions allow setjmp longjmp 
general cyclone ensures safety range techniques including sophisticated types intraprocedural flow analysis run time checking safe interface standard library 
preventing null pointer dereferences provides example techniques interact synergistically library function getc undefined typically unsafe behavior callers pass null 
incur run time cost checking null body getc cyclone type function indicates callers may pass null 
argument satisfy precondition cyclone insert run time check call site 
alternately programmers type system propagate null invariant functions data structures appropriate 
furthermore flow analysis determine extra checks unnecessary conditional tests loop guards source program 
relying run time checking programmers control run time cost catch errors compile time 
relying invariants prove strong pointers null 
relying intraprocedural flow analysis prove weak safety relies interprocedural invariants 
integrating approaches programmers choose appropriate task resorting unsafe languages 
implementing cyclone conventional implementation programmers easily resort linking code 
ability cyclone convenient extending incrementally porting systems written projects cyclone 
colleagues implement cyclone compiler related tools including memory profiler documentation generator scanner generator parser generator 
ported applications benchmarks cyclone measure difficulty porting run time cost ensuring safety 
ported floppy disk device driver windows cyclone 
entire driver written cyclone 
ways corrupt operating system notions safety cyclone captures guarantees cyclone provides device driver necessary insufficient 
general safety necessary insufficient aspect correct software 
researchers extended cyclone interesting systems 
medianet multimedia overlay network 
servers written cyclone exploit support safe memory management 
open kernel environment allows partially trusted extensions operating system kernel 
exploit isolation memory safety affords employ additional run time techniques prevent excessive resource consumption 
system uses modified version cyclone active network extensions 
dissertation focuses cyclone type system flow analysis 
ignore important issues syntax language extensions exceptions pattern matching idiosyncratic features variable argument functions 
ignore safety critical issues simple preventing jumps scope local variables difficult supporting nul terminated strings 
investigate quantitative results implementation experience cited 
focus developing core set compile time techniques provides foundation cyclone safety 
explain techniques demonstrate usefulness develop machines model relevant considerations prove machines techniques 
dissertation substitute user manual serve primer language 
section explains thesis techniques demonstrate describe specific disparities actual cyclone dissertation 
aspects language discussed dissertation evolving discussion may accurately reflect current language implementation 
example designing features take advantage restrictions aliasing 
second dissertation deviates cyclone concrete syntax favor readable symbols greek letters 
general compile time variables written back quote character followed identifier write allow subscripts primes 
third dissertation ignores difficulty implementing cyclone 
example implementation runs architectures provides safe interface standard library designed safety mind 
example provide useful error messages despite cyclone advanced type system 
fourth material chapters thoroughly implemented tested 
am confident design described chapters sound useful claim confidence features extensively development cyclone 
explanation thesis previous section background explain mean thesis rich language static invariants source level flow analysis provide programmers convenient safe language level abstraction 
rich language static invariants type system describes terms detail compiler generate code properly accesses fields calls functions 
part type size 
size distinguishes floating point types scalars lets compilers adjust alignment constraints precisely code generation conventional hardware requires doing 
contrast cyclone type system richer language 
types distinguish lifetime object length array lock guards data value int pointer null 
distinctions crucial preserving safety resorting compilation strategies runtime checks inappropriate level abstraction 
additions describe invariants 
example pointer type indicate refers array elements 
assignment change array refers cause refer array short 
cyclone type system just ad hoc collection annotations 
feature describes safety critical condition array length object live lock held type equality hold 
correspondingly compile time variables array lengths object lifetimes locks types 
fact just type variables different kinds 
letting functions universally quantify kinds compile time variables natural feature requires essentially additional support kind 
similarly tools existential quantification type constructors effects constraints singleton types twice 
subsequent chapters fully explain jargon 
short encoding necessary safety conditions understood type system technology get compile time language rich powerful uniform elegant 
source level flow analysis safety conditions invariants strong effective programming flow analysis refine static information program point 
examples include ensuring programs initialize memory ensuring integer array bound 
imperative language implicit run time checks program point specific information crucial 
type theory certainly describe information conventional flow analysis appears natural 
flow analysis mean restrictive just analysis ascribes different information different program points 
particular analysis path insensitive 
example cyclone rejects program analysis concludes uninitialized int int int new return point conditional assume uninitialized 
return statement reachable point analysis rejects program 
sophisticated analysis determine feasible execution paths safe 
distinction flow sensitivity path sensitivity depends domain analysis information store program point 
example analysis concludes conditional uninitialized conclude second conditional safe 
analysis source level mean definition terms cyclone source programs compiler reports errors source level terms 
requirement crucial flow analysis part language definition opposed internally compiler 
distinction affects design analysis 
leads favor simplicity usual definition explainable language implementors truly understand details 
second analysis difficult define terms simpler intermediate language 
convenient safe language programmers programming language precise definition 
cyclone just tool magically tries find safety violations programs language exact rules constitutes legal program 
cyclone safe intuitive concept difficult define 
informally write cyclone function mutates contents arbitrary address 
positively parts cyclone programs enforce strong abstractions 
example consider silly interface struct foo type struct foo foo int int foo struct foo consider implementation struct foo int struct foo foo int return new foo int foo struct foo return safe language conclude result call foo ignoring null pointers clients break struct foo abstraction 
unsafe language poorly written malicious clients forge struct foo held int foo compute 
trivial define safe language reject programs 
important aspect convenience allowing users write safe programs wish write 
definition subject called turing languages loops recursion equally expressive write program way write equivalent program ability write program behavior meaningless metric 
case better goal safe program legal cyclone program safety program undecidable attain goal remains useful qualitative metric 
possible answers question cyclone accept program including unmodified program cyclone program 
program needs cyclone type annotations cyclone program 
terms need local modification structure program need change 
equivalent cyclone program exists necessary change data representation control flow program 
roughly speaking convenience favors answers near list 
machine generated programs difference answers small explicit type information increases burden programmers important emphasize cyclone designed humans 
certain decisions sacrifice expressiveness favor human convenience 
choice default annotations important part convenience humans 
level abstraction noted chapter differs higher level languages conventional implementations programmer guide representation data order fields struct levels indirection management resources reclamation memory 
low level control data important level tasks primary reason remains popular language implementing low level systems 
strictly speaking standard expose representation resource management details programmers 
ansi compliant implementation add bounds fields arrays pad struct definitions check runtime dangling pointer dereferences 
words implement high level language 
doing loses advantages low level systems 
thesis claims provide safe language resorting high level implementation techniques 
example cyclone implementation compiles pointers machine addresses just conventional compilers 
level abstraction distinguishes cyclone safe lower level languages typed assembly language 
languages require level detail appropriate assembly language better assembly building large systems precisely interest portability programmer productivity willing sacrifice control details calling convention instruction selection register allocation 
measure level ease interoperability 
cyclone change data representation calling convention programmers give function cyclone type call directly cyclone code 
data conversion cost resulting program safe cyclone type programmer chooses 
example giving function void id void return type id enriches cyclone unchecked cast 
write system cyclone resorting necessary resorts assembly necessary applications reduce code subject safety violations 
rich type systems flow analyses safety safe programming languages level abstractions new putting cyclone unique point language design space 
bringing safety language aimed helping develop low level systems possible reason soundly systems terms user defined abstractions 
focusing compile time techniques safety avoid performance costs hidden run time information 
sound compile time analysis inherently conservative 
contributions language design largely involves combining adapting known features difficult identify original contributions getting related descriptions subsequent chapters identify dissertation unique aspects best knowledge briefly discuss highlights published previously 
adaptation quantified types language straightforward interpolation higher level polymorphic languages uniform data representation typed assembly language instantiation ia assembly language kind size type 
subtle violation type safety caused natural combination mutation aliasing existential types previously unknown 
published problem solutions explored chapter european symposium programming 
novel aspects static type system region memory management explored chapter involve techniques making palatable source language interprocedural analysis 
aspects include default annotations function prototypes regions operator representing region names type 
contributions include integrating regions conservative garbage collection integrating regions stack allocated storage vault system developed similar ideas concurrently subtyping region outlives relationship dynamic rc compiler similar notion :10.1.1.14.7406:10.1.1.14.7406
published description cyclone memory management acm conference programming language design implementation 
type system mutual exclusion chapter adapts line aimed java :10.1.1.1.5802
adapted ideas language type variables main contribution realizing striking correspondence solutions chapter regions solutions natural threads 
contributions include small extension easier reuse code thread shared data code uses callee locks idiom integration region memory management require garbage collection thread shared data notion sharability enforcing thread local data remains thread local 
published acm international workshop types language design implementation 
flow analysis detect uninitialized memory null pointer dereferences old idea 
java elevated part source language definition 
interesting aspects analysis developed chapter incorporation points information soundness despite specified order evaluation 
definite assignment analysis java simpler pointers uninitialized memory java completely specifies order evaluation 
singleton integer types chapter array bounds discriminated unions straightforward insights previous chapters 
having provided compile time variables various kinds addressed interaction polymorphism features mutation nonuniform data representation developed sound approach flow analysis checking certain integer equalities inequalities proved straightforward 
extensions flow analysis appear novel interesting weaker sophisticated compile time arithmetic dml 
important contribution emphasized dissertation cyclone implementation joint effort see 
written ported lines cyclone code 
type variables regions definite assignment proven crucial features development am confident aspects cyclone real multithreading singleton integers experimental features remain largely unimplemented 
words material chapters thoroughly exploited material chapters 
see consistently dissertation potential aliasing primary cause restrictions maintain safety 
powerful technique establish values aliases analysis chapter explicit type system :10.1.1.14.7406
part cyclone described taken approach 
important tool safe expressive language dissertation focuses far go 
important exception fact memory allocated aliases memory 
cyclone collaboration number colleagues 
trevor jim research greg morrisett cornell university cyclone original designers continue main designers implementors language evolves 
people contributed significantly design implementation including baudet james cheney matthew harris michael hicks frances wang 
impossible identify particular feature cyclone say reasons 
language design interactions features designing feature isolation little sense 
second cyclone team typically designs features informal conversations refines members team experience 
dissertation presents features am responsible 
subject caveats roughly exceptions greg morrisett designed cyclone type variables 
discovered bad interaction existential types see chapter obscure reasons problem early versions cyclone 
formalism regions chapter joint greg morrisett wang 
greg morrisett implemented type checking regions 
michael hicks provided examples text section 
choosing default annotations group effort 
greg morrisett designed implemented compile time arithmetic chapter enables nontrivial arithmetic expressions array subscripts union discrimination 
overview chapter provides series examples explain key ideas dissertation informally 
readers familiar quantified types flow analysis may wish skip description referred explicitly subsequent chapters 
conversely readers wanting just rough idea may wish read chapter exclusively 
chapters address different cyclone features 
particular chapter discusses type variables chapter discusses region system memory management chapter discusses multithreading chapter discusses definite assignment null pointers chapter discusses array bounds discriminated unions 
chapters involve flow analysis chapters primarily involve flow analysis 
chapter similar organization sections devoted description safety violations prevented basic description cyclone features maintain safety remaining expressive convenient advanced description features particular interact features earlier chapters discussion limitations address small formal language suitable modeling chapter interesting features discussion related safety violations addressed exception chapter rigorous proof establishes chapter formal language relevant safety property 
proofs long detailed relegated appendices 
appendices prove theorems chapters respectively 
appendix begins overview proof structure 
understanding main results dissertation require reading sections formal languages accompanying proofs 
languages add level precision possible english 
full cyclone allow focus just interesting features 
corresponding proofs tedious add assurance cyclone safe give insight cyclone safe 
various chapters develop separate languages related informally similarity remains possible subtle interaction separately modeled features remains unknown 
unfortunately syntactic proof techniques compose adding features complicates parts proofs 
techniques ill equipped handle complex models consider 
chapter discusses related safe languages 
projects focused techniques complementary cyclone strengths run time checking compile time restrictions aliasing 
tools sacrifice soundness order find bugs effectively requiring explicit information programmers 
chapter offers 
reiterate ideas chapter introduces small set techniques helps prevent wide array safety violations 
advantage repeating point speak terms examples technical details developed dissertation 
second discuss general limitations approaches taken dissertation 
briefly discuss experience cyclone place larger context producing quality software 
chapter examples techniques explain safety violations endemic programs avoid series example programs 
cyclone programs small set techniques ways address different safety violations 
simple examples give flavor interesting invariants programs 
example bad memory access preventing programs simplest terms dissertation void int compiler accept program 
technically meaning undefined implementation dependent programmers expect execution write address fail address writable 
address assembly language notion understanding program requires breaking higher level abstraction memory 
reason code linked code protect data maintain invariants enforce abstractions 
desire allow code 
unfortunately reasonable code act incorrectly 
type variables example type equality parameters programs assume types multiple values type system state enforce fact choosing particular type 
void void void function reasonable abstraction assigning pointer type safety requires points value type equality violate memory safety int int type checks argument type int second argument type int 
programmers expect call assign functions type ok allow arguments void ok void void printf cyclone solves problem type variables parametric polymorphism higher level languages including ml haskell 
programmers state necessary type equalities 
example examples legal cyclone void void ok implicit examples universal quantification free type variables type roughly 
void 
uses implicitly instantiate 
example type appropriate arguments 
hand ok suffices instantiate int int 
furthermore give type ok assignment type check 
general type variables function types indicate types allowing programs apply functions values types 
avoid needing code duplication run time type information restrictions types instantiate type variable ignore issue 
example type equality class types create class data object type polymorphic functions suffice 
standard example call back client registers server call back function data pass call back invoking 
server allow different clients different types data call backs 
simple version idiom look technically guarantee sizeof int sizeof void 
consistently ignore detail 
struct int void void env struct cb null void register cb void ev int fn void cb env ev cb fn int invoke cb return cb cb env clients access cb functions type register cb allows inconsistent types fields cb int assign int return void bad register cb assign invoke cb previous example void lenient express necessary type equalities invoke cb requires parameter type cb type cb env 
definition struct express requirement 
cyclone uses type variables existential quantification 
simplified incorrect cyclone program revise chapter 
struct int env struct cb null void register cb ev int fn cb fn env int invoke cb fn ev cb fn ev type definition means value type struct exists type fields types indicated definition 
initializer cb typed letting int 
call int witness type existential package cb 
function register cb changes witness type cb type parameter ev 
bodies register cb invoke cb special forms easier type checker ensure functions cb consistently 
expression form fn env constructor expression creates value type struct field holding fn second holding env 
initializing fields expression easy check type 
assigning fields separately leaves intermediate state necessary type equality hold 
declaration fn ev cb pattern binds type variable term variables fn ev statement 
type variable gives name unknown witness type cb pattern initializes fn ev cb cb ev respectively 
extracting fields time ensures intervening change witness type 
example type equality container types final example importance type variables fragment library linked lists 
write struct list void hd struct list tl struct list map void void struct list lst lst null return null struct list ans malloc sizeof struct list ans hd lst hd ans tl map lst tl return ans function map returns list application element lst 
type safety may require certain type equalities uses void 
intend hd fields linked list hold values type different lists may values different types 
furthermore expect parameter type lst elements expect result type elements map result 
cyclone express invariants struct list hd struct list tl struct list map struct list lst lst null return null struct list ans malloc sizeof struct list ans hd lst hd ans tl map lst tl return ans struct list type constructor type level function type 
struct list int struct list int different types 
polymorphism map type provided argument function pointer correct type 
seen common uses void polymorphic functions call back types container types 
type variables programmers express type equalities committing particular type 
universal quantification existential quantification type constructors type variables capture uses void cyclone powerful language unchecked type casts 
techniques known theory programming languages high level languages ml haskell 
adapting ideas cyclone largely straightforward dissertation explores complications great depth 
furthermore examples show tools capture static invariants conventional types 
singleton integer types oftentimes programs safe int values particular constants 
adding singleton int types associated constructs cyclone lets programmers encode invariants 
example array bounds parameters function supposed write sz elements array arr points void write int unsigned sz int arr int sz arr violate safety clients pass value sz greater length arr 
cyclone pointer types include bounds underlying array languages pascal universal quantification lets write functions operate arrays length unknown callee void write int tag sz int arr int sz arr example stands unknown compile time integer conventional type 
type arr int null means pointer elements 
type tag value int value 
distinction bit subtle example type tag type 
code type checker accepts call rejects second void int write write rejected example array bounds fields data structures refer arrays programmers fields hold array size 
cyclone existential quantification captures data structure invariant need prevent bounds violations elts field struct tag sz int elts void write struct int struct arr arr write important idiom discriminated unions programs memory different types data need casts union types notoriously unsafe 
common int enum field record type data currently memory field discriminates variant occupies memory 
course programmers correctly maintain check tag 
singleton int types int richer form union types encode idiom encode array bounds fields 
section examples 
discussed cyclone ensures functions write safe implementations discussion section 
discussed techniques universal quantification existential quantification type constructors useful conventional types integer constants 
higher level languages language mechanisms bounded arrays builtin discriminated unions advanced typing constructs useful 
providing cyclone impose fewer restrictions data representation 
region variables way violate safety dereference dangling pointer access data object deallocated 
access cause memory error segmentation fault 
insidious memory reused different type access violate invariants new data object 
example dangling stack pointers compiler computer compiles example call attempts write address 
int int return int int return void int int function accesses local storage calls storage deallocated 
calls storage aliases different types 
compiler warn obvious examples directly returning easily create equivalent examples evade implementation dependent analysis 
higher level languages standard solution safety violation give addressable objects infinite lifetimes conceptually 
avoid memory exhaustion garbage collector reclaims memory implicitly 
cyclone want manage memory conventional implementations stack allocation local variables preserving safety 
goal partition memory regions objects region conceptual lifetime 
constructs allocate memory local declaration blocks compile time region names pointer types include region names 
region name restricts values type point 
example modify type checker return types need mention region names scope 
chapter describes cryptic reason detail 
point standard techniques variables scope help prohibit dangling pointer dereferences 
requiring region names pointer types restrictive onerous due universal quantification type constructors inference default annotations 
example region polymorphic functions int add ps int int return void assign int pp int pp function add ps universally quantifies region names non dangling pointers int values valid arguments 
fact typechecker fills omitted region names pointers function parameters fresh region names optional 
function bodies cyclone infers region names 
reasons earlier examples correct noted despite omitted region names 
function assign default rule omit region name need establish type pp points 
knowing type equality assignment cause dangling pointer dereference deallocated 
functions region polymorphism allows clients call stack pointers heap pointers combination thereof 
example type constructors region name parameters struct list hd struct list tl type constructor struct list parameters type elements region name describes spine list allocated 
earlier definition legal cyclone unannotated pointers type definitions default special heap region conceptually lives forever 
revised definition describe lists living spines instantiating name heap region lists shorter lifetimes instantiating region name 
explained idioms functions return newly allocated memory 
explained just show quantified types type constructors help prove programs dereference dangling pointers 
chapter explains advanced features problems arising combination regions existential types 
lock variables multithreaded programs unsynchronized access shared memory violate safety 
discuss problems assume built function spawn creates thread runs parallel caller 
prototype void spawn void void void arg int sz function executes new thread control 
passed pointer copy arg null 
third argument size arg spawn needs copy 
copy shallow spawning spawned thread share memory reachable arg 
cyclone write void spawn void arg sizeof sz annotation indicates safe multiple threads share values type 
example pointer race condition architectures concurrent access memory location produces undefined results 
simple program potential data race int int int gp void int int spawn gp sizeof int return gp invocation reads gp invocation writes gp read produce unpredictable bit string 
demonstrate cyclone requires mutual exclusion known simplistic way avoid data races accessing thread shared data global variables 
example eleven existential package race condition architectures assume reads writes pointers atomic explicit synchronization programs corrupt pointer values 
assumption synchronization helps maintain user defined data structure invariants 
furthermore necessary safe mutable existential types cyclone code continues example demonstrates void invoke int ignore invoke cb int id int return void race int register cb assign spawn invoke null sizeof int register cb id spawned thread invokes call back cb reads fields calls field 
race uses register cb change cb hold int function expecting int 
bad interleaving spawned thread read field thread change cb spawned thread read env field 
case expect program write address 
situation arises threads share existential package 
race conditions multithreaded cyclone requires thread shared data protected mutual exclusion lock mutex 
order programmers describe lock protects particular thread shared data object recall code example slightly incorrect memory management 
introduce singleton lock types annotate pointer types lock thread hold dereference pointer 
example twelve synchronized access universal quantification lets functions take locks data locks guard simple example shows int read lock lk int sync lk return lock name type variable describes lock type 
pointer type indicates thread hold lock named dereference pointer 
explicit effect necessary default effect function see chapter require caller hold lock named 
term sync means acquire lock blocking thread holds execute release lock existential quantification allows storing locks data structures data guarded locks 
type constructors lock name parameters allow single lock guard aggregate data structure 
shown pointer types thread shared data include lock name name thread hold lock type lock dereference pointer 
thread local pointers special annotation living data special region annotation 
thread local data require synchronization 
short basic system ensuring mutual exclusion uses typing constructs memory management system 
chapter explains issues regarding threads locks including ensure code acquires lock accessing data guarded lock ensure thread local data escape single thread write libraries operate thread local thread shared data allow global variables multithreaded programs summary type level variables programs safe maintain collection invariants type system express 
invariants include type equalities values type void int values holding lengths arrays int values indicating current variant union type pointers referring deallocated storage mutual exclusion thread shared data 
seen invariants essential safety 
capture idioms cyclone significantly enriches type system 
particular added conventional type variables singleton int constants region names singleton lock names 
pointer types carry annotations restrict values type 
important point additions uniform sense 
allow universal quantification existential quantification type constructors parameterized addition 
similarities type system approximates set live regions set held locks explain chapter 
additions enforce invariants type checker ensures property holds structured context 
local data invariants strong 
give examples invariants strong 
dataflow analysis cases 
definite assignment allocate memory value type putting value memory 
memory valid value violates safety 
example thirteen uninitialized memory example assignment statements cause unpredictable behavior uninitialized memory 
void int int malloc sizeof int simple solution requires programmers specify initial values allocating memory 
local declarations initializers suffice 
heap memory provide form new malloc initializes new memory result evaluating solution inserts initial values implicitly programmers omit 
doing difficult types separate compilation 
violates spirit acting solutions uninitialized memory impossible ignore fact separating allocation initialization useful omitting initializer serves self documentation subsequent execution initialize value 
correct code full uninitialized memory new port code cyclone unnecessary modification 
common idiom stack allocate storage value type pass local variable address initializer known constructor function 
idiom requires pointers uninitialized memory 
initializing memory values program incurs unnecessary run time cost 
cyclone allow uninitialized memory check compile time program definitely assigns memory 
term definite assignment java similar sophisticated flow analysis 
maintain conservative approximation possibly uninitialized memory locations program point 
example fourteen definite assignment simple example correct cyclone code int bool int new new return code correct control flow path return statement exists remains uninitialized 
example simple reasons control flow structured 
general features goto require analyze code iteratively 
pointers uninitialized memory malloc 
specified order evaluation order arguments function evaluated complicates having sound tractable analysis 
pass uninitialized memory function 
complications jumps pointers evaluation order function calls orthogonal actual problem uninitialized memory approach problems address flow analysis 
essence approach incorporate points information pointer hold value returned call malloc analysis require explicit annotations interprocedural idioms initializer functions 
null pointers cyclone type system distinguishes pointers null written definitely null written 
dereferencing pointer operators violate safety 
solution compiler insert explicit check null throwing exception failure check redundant case mandatory check introduces performance cost 
introduce checks flow analysis prove redundant 
warn user inserted checks 
example fifteen null checks code int int int int int ans null return ans ans inserted check null ans compiler inserts check addition needs check null return statement executed 
addition needs check null second addition thrown exception 
sound reasoning redundant checks aliasing crucial 
example addition need check points information addresses need check involving memory location eliminated unknown pointers location may exist 
trapping access address normal implementation null insufficient access large address 
checking tag variables null checks easy insert check needs pointer 
subscript type check unsigned 
run time need value type tag 
implementations safe high level languages typically implement bounds checking storing values hidden locations 
doing dictates data representation hallmark high level languages 
cyclone pursue alternatives 
implementation try find value type tag scope subscript 
doing awkward 
second subscript ternary operator forcing programmer provide correct bound 
solution porting code difficult eliminate redundant tests 
solution pursue flow analysis conjunction type system prove subscripts safe 
main limitation restricted notion mathematical equalities inequalities 
dissertation limited notions essentially equalities inequalities constants variables choice decidable arithmetic appears orthogonal issues 
example sixteen array bounds checking example compiler accepts loop bound properly guards subscript 
formally control flow path arr 
compiler rejects second loop cyclone includes sophisticated compile time arithmetic reasoning int twice sum tag sz int arr int ans int sz ans arr int sz ans arr rejected return ans note aliasing important 
example global variable body loop included function call loop safe 
know smaller 
example seventeen implicit checking programmers prefer convenience implicit checking encode auxiliary function struct tag sz elts subscript struct arr int ind arr ind return ind throw techniques check discriminated unions 
fact limited arithmetic union tags typical idioms switch statement easier support 
interprocedural flow seen flow analysis go invariants provide expressive system initializing memory checking null pointers checking array bounds checking union variants 
scalability separate compilation intraprocedural flow analysis function call conservative assumptions function type 
enrich function types annotations express flow properties 
compiler uses properties check callee caller 
example function parameter pointer say function initializes parameter 
check function assuming parameter points uninitialized memory ensure function initializes memory returns 
call site allow passing pointer uninitialized memory assume function call initializes memory 
tag variables express relations 
doing shifts burden establishing inequality caller function call rejected allowing callee assume relation 
introduce relations type definitions creator value type establish relations 
user value assume 
consider null types shorthand property possibly null pointer types 
summary flow analysis applications properties require multiple steps allocation initialization run time checking array bounds flow analysis proves valuable 
interacts type system synergistically type system ensures type tag type tag flow analysis checking conversely calls function type requiring tag flow analysis check call 
function calls unstructured control flow features cyclone sound tractable flow analysis technically interesting 
specified evaluation order 
second potential aliasing local variables 
analysis chapter conservative assumptions features 
remain effective incorporates points information 
chapter type variables cyclone uses type variables quantified types type constructors eliminate need potentially unsafe type casts allowing code operate values different types 
review facility casts various idioms safe require casts impoverished type system 
discussion identifies idioms type variables capture 
expression type expression casts type 
compile time expression type 
run time means result evaluating converted value type 
conversion occurs depends 
numeric type int float char conversion produces bit sequence program number 
cyclone type checker allows casts conservatively assuming bit sequence result 
casts numeric types pose problem safety little say 
cyclone aggregate struct union type clear general conversion sense 
programmers cast integral type int char pointer type doing bad practice 
pointer type cast integral type sizeof sizeof resulting value cast back type expect get value original pointer 
void better practice cyclone uses type variables place void 
cyclone forbids casting integral type pointer type 
remaining casts pointer types 
safe casts overcoming lack subtyping 
example type definitions casting struct struct safe gcc extension allows casting union field union exactly type 
extension technically interesting 
struct int struct struct int implicit low level view memory cast sense pointers machine addresses field struct begins address struct 
cyclone allows casts defining subtyping implicit memory model allowing casts supertypes 
dissertation describe subtyping detail 
source pointer pointer casts code reuse 
code manipulates pointers values pointed code correctly pointer types 
sanctioned way write polymorphic code type void pointer types 
polymorphic code pointers cast void 
presumably code eventually values pointed 
doing requires casting void back original pointer type 
safety problem checks second cast correct pointer type void point value type 
cyclone forbids casting void pointer type allow casting void 
rest chapter explains cyclone type variables eliminate need void capturing important idioms code reuse 
common void user defined discriminated unions chapter explores idiom detail 
course determining program casts void correctly undecidable exist correct programs void map naturally cyclone programs 
section presents type variables related features describe programming idioms polymorphic code class types function closures call backs libraries container types 
material adapts known ideas language readers willing endure unusual syntax skip 
section discusses low level memory model particularly values having different sizes complicates addition type variables 
section discusses type variables safe cyclone despite mutation 
describes newly discovered unsoundness involving aliased mutable existential types cyclone solution 
section novel chapter previously published idea important language designers considering mutable existential types 
section evaluates type system describing limitations 
section presents formal language reasoning soundness cyclone type variables particularly important light section somewhat surprising result 
section discusses related 
appendix proves type safety formal language 
basic constructs form type cyclone type variable written 
certain constructs introduce type variables particular scope 
scope type variable describes values unknown type 
power type variables opposed void type variable describes unknown type scope 
constructs introduce type variables motivate inclusion explain usage 
techniques render optional cumbersome notation explanations 
defer complications nonuniform data representation section 
universal quantification simplest example universal quantification function id return function polymorphic callers instantiate different types function values different types 
example type int type int id int type int id int type int 
general function introduce universally bound type variables 
writing function name 
type variables scope parameters return type function body 
type function universal type 
example type id id pronounced id takes returns conventional notation universal types function types write 
section explains id types 
polymorphic function value universal type instantiate type variables types 
example id int type int id int 
interesting examples polymorphic functions take function pointers arguments 
code applies function element array elements 
void app void arr int arr function call type checks argument type function expects 
show code reusable types int global variable functions modify void add int int void add ptr int void add int arr app int add int arr void add int arr app int add ptr arr resorted global variables type app argument pass argument functional languages function closures 
better approach passes value function pointer 
type value irrelevant implementation app app polymorphic 
void app void env arr int env arr int global variable functions modify void add int int int void add ptr int int void add int arr app int int add int arr void add int arr app int int add ptr arr users app pointer identifying value modify chosen run time values 
short universal quantification type variables powerful tool encoding idioms code need know certain types need relate types multiple arguments array elements function pointer argument app arguments results argument return type id 
conflate types void sacrificing ability detect inconsistencies type system 
cyclone refined information polymorphism induces run time cost 
type instantiation just compile time operation 
compiler duplicate code compiled version app regardless number types program uses 
similarly instantiation require function body compile uses app separately implementation app 
run time type information pass app exactly information secret arguments describing type instantiation important reasons 
meets goal acting introducing extra data run time cost 
writing reusable code practice want penalize code 
second complicated compile polymorphic code differently monomorphic code example suggests id return int int return void bool int int id int id int type need support indirect function calls know run time calling 
extra run time cost functions calling convention precludes secret arguments 
cyclone supports class polymorphism polymorphic recursion 
means universal types appear function types appear just types top level functions 
silly example requires feature void void int int int int polymorphic recursion lets recursive function calls instantiate type variables differently outer call 
feature function quantifying instantiations 
silly example uses polymorphic recursion slow id int return slow id return class polymorphism polymorphic recursion natural features 
emphasize inclusion absent languages notably ml usually full type inference undecidable 
cyclone provides convenient mechanisms eliding type information support full inference 
easily supports expressive features 
find important chapters 
existential quantification cyclone struct types existentially quantify type variables example struct env int english value type struct exists type env field type field function expecting argument type scope field definitions 
common types library interface lets clients register call backs execute event occurs 
different clients register call backs different types flexible library writer choosing type call backs process 
library calls field struct value argument env field struct value known type function expects 
short stronger interface void type env argument type existential types describe class types 
example describe simple abstraction sets integers type struct intset elts void add int void remove int bool member int elts field stores data necessary implementing operations 
abstraction demands clients assume particular storage technique elts existential quantification ensures 
example create sets store elements linked list sets store elements array 
types class sense choose sort set run time 
put sets lists sets arrays array element type struct intset 
encode data structures universal quantification closed functions 
strongly typed languages existential types se 
class function closures class objects sense objectoriented programming 
features known similarities existential types 
types constrain private state fields existentially bound types free variables class function private fields object enforce strong abstractions 
language class data hiding construct impoverished suffices encoding simple forms 
example existential types encode closures forms objects 
difficult complications cyclone arise existential types modify examples section chapter problems disappear replaced data hiding feature 
providing feature language 
cyclone provides existential types closures objects give programmers control data representation primary goals 
compiling closures objects requires deciding represent private state 
doing involves space time trade offs depend program programmers see decisions 
prefer provide powerful type system programmers decide 
term level constructs creating values existential types 
call values existential packages 
creating existential package choose types existentially bound type variables fields right types choice 
call types witness types existential package 
serve similar purpose types instantiate polymorphic function 
witness types exist run time 
simplify checking programs create packages correctly require creating package constructor expression example uses struct defined int deref int return int twice int return int struct bool return int env deref return int env twice code executes body statement int witness type returned value int 
return type just struct witness type part 
allow inconsistent fields env deref typed 
existential package cyclone provides pattern matching unpack called open package example int struct pkg env fn pkg return fn pattern binds fn copies env fields pkg 
introduces type variable 
scope fn rest code block example rest function 
types fn int respectively call fn type checks 
scope type 
example write id 
require reading fields package pattern matching individual field projections require building package 
part allowing operators existential types simplifies type checking 
creating package check correct witness types 
package clearly defines types fields scope introduced type variables 
unpack package different type variables name irrelevant type system properly distinguishes binding occurrence example function pointer unpack environment 
type constructors type constructors type parameters concisely describe families types 
applying type constructor produces type 
example type constructor describe linked lists struct list hd struct list tl type constructor struct list type level function type produces type 
types struct list int struct list int struct list struct list int different 
type formal parameter scope field definitions 
type tl field struct list types struct list produces describe homogeneous lists elements type 
type constructors encode sophisticated idioms 
type constructor describe lists elements alternate types struct hd struct tl building values types type constructors produce different types 
example struct list int put int hd field struct list int tl field 
type struct list int hd tl types int struct list int respectively 
conventional type constructors describe container type write library polymorphic functions type 
example prototypes describe general routines linked lists int length struct list bool cmp bool struct list struct list struct list append struct list struct list struct list map struct list compared write just struct list hd field type void prototypes express exactly callers callees need know ensure list elements correct type 
example append presume appends inputs return list elements type inputs lists elements type 
calling append instantiated type caller process result knowing elements type 
type constructors existential quantification interact 
example struct fn type constructor encoding function closures struct fn env constructor describes functions environment type 
course different values type struct fn environments different types 
library provide polymorphic functions operations closures creation application composition currying uncurrying 
type constructors extremely useful cause technical challenges cyclone 
formalisms dissertation model 
parameters typedef provide related convenience 
parameters typedef bound type definition 
apply typedef produce type example typedef struct list list right binding occurrence 
typedef transparent completely equivalent definition 
writing list int just abbreviation struct list int 
default annotations added universal quantification existential quantification type constructors programmers encode large class idioms reusable code resorting unchecked casts 
far focused type system expressiveness describing features reduce burden programmers 
techniques show examples require syntax 
add features subsequent chapters revise default rules accommodate 
function definitions function prototypes top level function body type definition outermost function implicitly universally quantifies free type variables 
writing id list map list write id list map list explicit quantification necessary class polymorphism void void int int omitting quantification polymorphic second instantiation polymorphic functions selection witness types implicit 
type checker infers correct instantiation witness types arguments field initializers respectively 
examples struct env int struct list lst id map id lst return env id polymorphic recursion poses problem function types explicit 
inference require immediately applying function example shows void int int id fact type inference uses unification known technique see described dissertation function bodies explicit type annotations optional 
chapter discusses problems type inference cyclone practice omit explicit types function bodies 
occurrence polymorphic function implicitly instantiated delay instantiation requires explicit syntax example void int id instantiate instantiate int instantiate int third unpack need give explicit type variables 
type checker create correct number type variables gives terms appropriate types 
write int struct pkg env fn pkg return fn type checker creates type variable scope user provided type variable 
fourth omit explicit applications type constructors apply types 
function bodies unification infers omitted arguments 
cases function prototypes function argument types type checker fills omitted arguments fresh type variables 
writing int length list write int length list practice need explicit type variables express equalities terms unknown type 
reason programmer create type variables types occur element type length type checker creates names fills 
mean type constructors types just application implicit 
rules omitting explicit type annotations require type checker perform interprocedural analysis 
function complete type determined prototype body type checker process function body 
size calling convention different values cyclone different sizes meaning occupy different amounts memory 
example expect struct int fields larger struct int fields 
conventionally values type size call size values type size type 
implementations flexibility choosing types sizes order accommodate architecture restrictions native word size alignment constraints sizes compile time constants 
sizes known struct declarations known incomplete structs struct 
enable efficient code generation greatly restricts types appear 
example struct forbids declaration struct struct int implementation know room allocate variable type struct struct 
type struct simple efficient way compile short size types known permits pointers 
cyclone type variables types confront problems 
cyclone provides solutions explain introducing kind system describes 
kinds classify types just types classify terms 
chapter kinds boxed 
type kind pointer types int kind consistently assume consider term boxed strange historical accident 
dissertation means pointers things represented just int size calling convention void 
saying int just concise saying integral type represented void solutions type variables correspond type variables kind type variables kind type variable binding occurrence usually specifies kind default examples section type variables kind simple rules dictate type checker uses kinds restrict programs universally quantified type variable kind instantiated type kind existentially quantified type variable kind witness types kind kind subject restrictions struct types essentially occur directly pointers programs dereference pointers type 
type variables introduced existential unpack specify kinds 
th type variable kind th existentially quantified type variable type package unpacked 
formally type variables kind stand types convert void sense examples section type variables place void 
forbid instantiating struct type reasons forbids casting struct type void 
type variables kind common restrictions silly example struct void swap struct tmp tmp swap quantifies type kind instantiate swap type 
final addition type variables kind useful 
unary type constructor sizeof describe size type value type cyclone default kind depending type variable simpler default rules dissertation 
sizeof sizeof 
allow sizeof compiler knows size types pointers 
purpose sizeof give cyclone types primitive library routines write function copying memory void mem copy dest src sizeof sz possible implement function cyclone provide safe interface implementation 
sophisticated version example appears chapter 
giving float kind deserves explanation assume float size void int 
architectures different calling convention floating point function arguments 
float kind implementation polymorphic function native calling conventions example demonstrates float float return return void bool float float discussed section ml community explored reasonable solutions giving float kind preserve data representation float just floating point number function just code pointer secret arguments possibly exponential increase amount compiled code 
cyclone prefer expose problem programmers encode solutions manually 
mutation type safety demands expressiveness gained type variables allow program view data object wrong type 
mutable locations common cyclone notorious source mistakes safe language design 
section describe potential pitfalls cyclone avoids 
polymorphic cyclone called polymorphic allow programs void bad int null legal cyclone int int give null pointer type tempting give type 
instantiating give type 
assigning instantiation int put value second instantiation int wrong leads violation memory safety 
avoid problem suffices disallow type instantiation form left expression cyclone left side assignment argument address operator valid left expressions 
formal languages dissertation precisely solution formal syntax instantiation left expression 
fact values types terms universal types functions functions left expressions 
formal languages null 
solution actual cyclone implementation convoluted class functions function definition expression form 
function designator name function implicitly means function call implicitly dereferences function pointer 
cyclone means allow means 
unsoundness results code immutable 
having code pointers different types refer code problem pointer types wrong 
expressions sense 
quirk allows implementation check explicitly left expressions form function designators type instantiations syntax concrete writing universal type universal type function type 
type instantiations ultimately applied function designators 
formal languages quirk 
type syntax orthogonal formed type polymorphic values functions 
disallow function definition 
assign function location take location address 
notion immutability allow left expression valid immutable left expression 
section briefly describes safe polymorphic languages prevent polymorphic 
mutable existential packages appear researchers carefully studied interaction existential types features mutation address operator 
orthogonality suggests existential types cyclone permit mutation acquiring address fields just ordinary struct types 
abilities genuinely useful 
example server accepting call backs mutation reuse memory different call backs expect data different types 
introduce aliasing useful 
small example value type struct polymorphic function void swap swapping locations contents permit call swap 
unfortunately features create subtle unsoundness 
feature mutating location holding package hold different package different witness type supported naturally 
type struct copies fields fields 
note assignment change witness type example struct void int env void ignore int int void assign int int void int ptr struct ignore struct assign ptr forbid access existential package fields operators way acquire address package field 
need feature swap example 
pattern matching acquire field addresses cyclone provides patterns pattern id matches location binds id location address 
continuing example pattern env arg arg arg alias env arg opened type case 
patterns allow mutating fields discriminated union variants originally added cyclone 
point created existential packages assignment modify memory existential type patterns get aliases fields 
appears smooth integration features natural language level abstraction 
unfortunately features conspire violate type safety void int ptr struct ignore struct assign ptr env arg arg call arg executes assign passing int expect int allowing write arbitrary address 
went wrong type system 
express equality parameter types type value arg points 
assignment changes witness type equality false 
developed solutions 
solution forbids patterns match fields existential packages 
uses patterns sound assignment package mutates fields package 
call solution aliases opened type second solution forbids assigning existential package aggregate value existential package field 
call solution witness changes solutions independent suffices different solutions different existential packages 
existential type declaration programmer decide restriction compiler enforces 
current implementation supports aliases opened type believe useful solutions easy enforce 
emphasize exact source problem mention aspects problematic 
pointers witness types problem 
example struct void int env pattern env arg intervening assignment changes package witness type change type value arg points 
second assignment pointer existential package problem changes package pointer refers change package witness type 
third known typing rule opening existential package forbid introduced type variable occurring type assigned term type variable scope 
case term statement type unit type prefer condition trivially satisfied 
multithreading introduces similar problem chapter addresses existential unpack unsound witness change binding arg 
exclude witness change binding package fields 
informal comparison problems potential problems discussed result quantified types aliasing mutation natural suppose logical duals problem 
correspondence issues particularly illuminating point similarities may suggest duality 
related polymorphic discussed detail section 
polymorphic example assigns variable instantiated type instantiates variable different type 
contrast existential package example assigns value type creating alias opened type 
ml value restriction clever way prevent types exploiting expressions types values ml 
effectively prevents certain types mutable locations contents 
contrast witness changes solution prevents certain types mutation location 
exception linear type systems know treatment universal types permits types values mutable locations change aliases opened type solution 
unclear invariant lines look polymorphic 
evaluation evaluate cyclone features chapter qualitatively start optimistic assessment features provide 
describe disappointing limitations address 
news type variables provide compile time equalities unknown types 
compared describe interfaces polymorphic code types precisely void 
compared safe languages provide code reuse 
existential types give programmers class data types sacrificing control data representation 
building existential packages look code difference local 
put way porting code struct converts easily existential type require changing function bodies access fields struct 
restructuring code necessary 
existential types chapter hide chapters modify leak information 
type constructors provide elegant way describe container types lists dictionaries hashtables universal quantification describes polymorphic routines types 
cyclone implementation includes powerful collection container type libraries applications extensively 
libraries requires notation overhead gain advantage void confuse types 
general default annotations intraprocedural type inference allow programmers write little necessary type safety 
writing void swap feel burdensome hardly exist concise way express important type equality 
type constructors types allow clever programmers type system encode restrictions clients library 
fairly known trick called phantom types type variables type implementation example interface struct read struct write struct myfile struct myfile struct read open read char struct myfile struct write open write char char read struct myfile struct read void write struct myfile struct write char void reset struct myfile void close struct myfile interface prevents reading myfile opened writing writing myfile opened reading 
polymorphism allows closing resetting myfile 
implementation struct myfile need run time information indicating read write phantom types limits 
soundly provide function changes myfile read write client keep alias old type 
similarly interface require clients call close myfile 
cyclone kind distinction burdensome types occur pointers struct types converted void 
inconvenience inherent exposing data representation infeasible support polymorphism types different sizes calling conventions imposing run time cost duplicating code 
provides little support types bit easy accept section explores possible improvements 
restricting programmers introduce type quantifiers universal quantification function types existential quantification struct types usually restrictive 
see consider small formal grammar types int types type variables int function types pair types anonymous struct types pointer types existential types universal types 
cyclone implementation grammar restrict form quantified types 
argue informally generality useful describe value type 
describe value ignoring kind distinctions expressions type unusable 
just 
int int just int 
cyclone provides 
appears expressions type unusable call function 
just 
cyclone provides analogue 
similar value type strictly useful 
constructing similar value easy type checking expressions type respectively exploit type respectively 
just respectively 
note describe mutable values 
useful allow disjoint sum type especially conjunction types 
return cyclone notation example 
suppose want implement list library 
write recalling describes pointers null new allocates new memory struct hd struct tl struct struct struct empty return new null struct cons struct 
keep implementation clients declaring just struct 
lists struct really sum type field null pointer 
empty lists representation regardless element type wastes space allocate memory call empty 
avoid waste need struct mt null struct empty return mt course type variable mt uses universal quantification 
suffers polymorphic problem note type instantiation appears left side expression need prohibit mutation types constructed struct additions clients share empty lists element type share empty lists different element types 
bad news cyclone provides compile time refinement types 
simple example tempting allow programs void swap void swap idea assumes values types 
true branch statement type checker include constraint 
addition questionable utility tempting constraints describing equalities inequalities type level variables introduce subsequent chapters 
particular chapter term level tests introduce type level constraints 
primary goal dissertation demonstrate tools useful meaningful variety problems constraints type variables merit consideration 
unfortunately refinement example unsound assumption underlying hold 
suppose int int 
condition hold allowing swap put int expect pointer 
subtyping unsound pointer equality checks introduce equality constraints 
obey strict subtype relationship values types equal unsound introduce type equality constraint 
sound ways term level tests pointer equality introduce type level constraints 
example type system chapter express roughly constant integer system works constant integers safe programs may check complex properties determine value type 
principled approach provides explicit representation type terms describing types terms 
terms separate terms types describe language exposes data representation 
important writing certain generic functions garbage collectors 
easier justifiable addition explicit subtyping constraints form 
adding constraints preconditions polymorphic functions achieves bounded quantification example void return constraint requires instantiation type subtype 
body soundly assume constraint holds subsumption type check function call 
bounded quantification permissive type give result type 
callers strict subtype assume result call subtype 
section discusses known problems bounded quantification 
kind system information type variables kind extremely coarse just struct types example write function works arrays elements bytes long 
adding descriptive kinds straightforward 
example describe types sizeof long types alignment constraints calling convention sizeof implementation dependent portable code assume value 
consider refining kind information program 
example sizeof give kind typed assembly languages kinds sizes known :10.1.1.12.2113
believe better solution recognize level tasks inherently include parts benefit language support 
application implementation dependent assumptions language implementation check property automatically 
real bit level data representation calling convention matter application able specify assumptions implementation compiler check code accordingly 
terms example code manipulating arrays byte elements remains portable implementation dependent assumption guards type 
similar assumptions allow reasonable operations casting struct int struct char appropriate architectures 
cyclone strange hybrid exposes data representation terms field order levels indirection committing size types alignment fields 
mentioned previously relax rules types appear duplicating code type instantiated 
approach closer templates 
valuable alternative widely performance critical libraries hashtables level indirection prove costly 
difficult maintain separate compilation 
polymorphic recursion problem takes care bound amount generated code 
example program need infinite amount code 
struct legal cyclone void struct struct struct bigger bigger avoided design path cyclone largely designers explored extensively 
inability cyclone type system express restrictions aliases locations causes cyclone forbid safe programs 
example pointer safe store pointed location temporarily provided code expecting reads location holds 
aliases location exist property easier check statically 
example allow patterns fields mutable existential packages provided witness changing mutation occurs variable bound pattern dereferenced 
restricted aliasing possible check mutation occurs 
small problems cyclone design type variables casts deserve brief mention 
cast meaning type dependent 
example casting float int treat bit sequence integer 
cleaner design distinguish coercive casts run time effect ones 
similar distinctions exist 
second forbidding direct access existential package fields inconvenient 
simple flow analysis infer unpacking implicit field access violating soundness 
third partial instantiation type constructors polymorphic functions convenient suggested 
instantiation order means type constructor function creator determines partial allowed 
shortcoming exists term level functional languages currying 
partial applications described chapter just shorthand implicit full applications 
necessary partially instantiate universal type delay rest instantiation 
extended cyclone implementation support true partial instantiation 
example necessary involves memory management see chapter 
fourth cyclone higher order type constructors 
way parameterize type constructor type constructor 
date sufficient demand implement feature 
formalism investigate soundness features chapter especially presence complications described sections section develop formal machine type system 
machine defines programs manipulate heap mutable locations 
locations hold integers pointers 
machine gets stuck program tries dereference integer 
type system universal quantification existential quantification solutions section 
theorem section ensures typed programs lead stuck machines 
usual formal model lets give precise meaning language design ideas ignore issues orthogonal safety concrete syntax floating point numbers prove rigorous result 
keep model proof tractable simplifications omitting type constructors memory management 
inherent trade exists simplifying focus relevant issues potentially missing actual unsoundness due subtle interaction 
section defines syntax programs program states 
section presents rules machine executes 
section presents type system 
practice static semantics source programs type safety proof requires extending type system type check program states 
proceeding emphasize novel aspects formalism 
cyclone distinguish left expressions right expressions statements 
definitions classes terms mutually inductive dynamic static semantics comprise interdependent judgments 

functions execute return statements 
formalism void cyclone 
separate judgment encodes simple syntax directed analysis ensure function terminate returning 
actual cyclone implementation uses flow analysis 

allow aliasing mutable fields assignment aggregate values aggregate 
feature complicates rules accessing mutating type checking aggregates 

classify types kinds type system prohibits programs need know size type variable kind 
support solutions mutable existential packages syntax distinguishes styles existential types 
type system defines set assignable types disallow witness changes 
type safety proof requires type system maintain witness types packages patterns 
induction hypothesis strong show evaluation preserves typing 
formalisms subsequent chapters include features describe detail chapter simpler setting 
machine look third feature models important part cumbersome chapter restrict left expressions prevent address fields 
restriction simplicity 
features capture chapter interesting aspects 
subsequent formalisms avoid complications features introduce disallowing type variables kind eliminating patterns 
chapter simple 
syntax presents language syntax 
model execution program state consisting heap data statement control 
heap reuse variables represent addresses heap maps variables values 
write empty heap 
allow implicit reordering heaps act partial maps 
terms include expressions statements 
statements include expressions executed effect return statements return sequential composition conditionals loops 
variable binding extends heap binding assume unique binding convertible 
memory management concern dynamic semantics contracts heap 
forms existential packages 
form open binds copy contents evaluation open binds pointer contents evaluation form corresponds patterns 
simplicity produces pointer entire contents particular field 
expressions include integers function definitions explicit type parameters pointer creations pointer dereferences pairs field accesses assignments function calls type instantiations existential packages pack 
package creation witness type 
explicit mention technical convenience 
stranger expression forms remain 
call form call maintains call stack term syntax function call rewritten form function return eliminates 
variables write variables paths expression form xp 
empty path xp variable write short hand 
need nonempty paths source programs 
values may pairs packages paths refer parts values 
path just sequence defined section refer pair components refers value inside existential package 
write sequence followed 
blur distinction sequences sequence elements convenient 
means path continuing means path valid left expressions subset valid right expressions 
type system enforces restriction 
invalid left expressions type check occur operator left side assignment 
types include type variables base type int products pointers existentials universals 
consider quantified types equal systematic renaming bound type variable conversion 
compared cyclone replaced struct types anonymous product types pairs eliminated user defined type constructors 
type variable bindings include explicit kind 
aliasing relevant uses pointers kinds types int terms return open open xp call pack ip values xp pack heaps states contexts xp chapter formal syntax explicit 
particular value product type record pointer record 
distinguish approaches existential types annotate allowing witness changes allowing aliases opened type 
technical points treat parts typing context implicitly partial maps convenient 
write assume dom 
write similarly union contexts disjoint domains implicitly assuming 
dynamic semantics deterministic relations define small step operational dynamic semantics 
program state rules establish 
relation related relations expressions interdependent statements expressions contain 
relations describe paths direct access mutation values 
type substitution gives operational meaning open 
types play essential run time role view substitution effectless operation useful proving type preservation 
describe definitions detail 
ds dom ds ds return return ds ds ds open pack ds get pack open xp ds return return open open ds open open ds chapter dynamic semantics statements ds rule ds rule extends heap 
convertible assume name heap location 
bindings exist forever statement return reasonable 
rules ds unsurprising rules simplifying sequences conditionals loops 
rule ds uses simplify results opening existential package 
result scope substitute package witness type rule ds uses binds variable address package contents 
keep type checking syntax directed append path 
way refer package contents package 
get relation described acquire witness type need substitution 
rules ds congruence rules evaluate terms contained larger terms 
putting multiple rule just conciseness 
interesting distinction get xp dr set xp dr xp xp dr vi dr call dr call return dr call dr call dr xp xp pack pack xp xpi dl dr dr xp xp dl dl dl chapter dynamic semantics expressions get get get get get set get get pack set set set set set set pack pack chapter dynamic semantics heap objects open expression right expression open left expression 
right expressions evaluate values rules dr 
get set relations handle details reading mutating heap locations dr dr 
rules dr dr eliminate pointers pairs respectively 
rules dr dr introduce eliminate function calls pass function argument 
rule dr uses type substitution instantiation 
rules dr congruence rules 
note evaluation order left right dr indicates left expression positions 
left expressions evaluate form xp 
need rules type system restricts form left expressions 
interesting rule dl appends field projection path 
contrast left expressions right expressions compare results dl dr 
left expressions result terminal form rule applies rule dr applies 
get relation defines paths destruct values 
examples get get pack 
get package contents witness change 
set relation defines paths update parts values set means updating part corresponding produces 
example set 
type substitution completely straightforward 
replace free occurrences type variable type 
subsequent chapters omit uninteresting cases definition 
chapter cases interesting 
example dynamic semantics variation previous types int int contexts expressions xp xp call call pack pack statements right side expression return return open open open open note mean implicitly rename avoid capture 
chapter dynamic semantics type substitution unsoundness example 
assignment function pointers idea 
specify style existential types 
pack int open pack int lines allocate values heap 
line location contains pack int 
line substitutes int location contains 
line contains contains pack int 
line assigns causes line stuck 
complete example need choose 
fortunately section explains choice produces typed program 
type information associated packages paths keeps type checking syntax directed 
define erasure function heaps replaces pack removes paths 
straightforward prove erasure evaluation commute semantics treats open 
static semantics program execution begins empty heap source program just statement allow require styp type ret rules figures respectively 
ensures conventional type checking terms inappropriate operations refer undefined variables 
ensures terminate executing return statement 
styp judgment type checking judgments right expressions left expressions rtyp ltyp interdependent just corresponding run time relations 
part judgments irrelevant source programs 
described captures invariant packages terms form open mutated 
gettype relation static analogue get relation 
type check paths 
int ak dom ak wf asgn int asgn asgn asgn asgn asgn asgn wf wf wf wf wf wf asgn asgn asgn wf wf xp chapter kinding context formedness rtyp styp ss rtyp styp return ss styp styp styp ss rtyp int styp styp ss rtyp int styp styp styp styp rtyp dom styp ss ss rtyp styp dom dom styp open ss ltyp styp dom dom styp open ss chapter typing statements gettype wf ltyp xp sl rtyp sl ltyp ltyp ltyp sl gettype wf rtyp xp rtyp sr rtyp wf rtyp int sr rtyp rtyp ltyp rtyp sr sr ltyp rtyp asgn rtyp ltyp ltyp sr rtyp rtyp sl sr rtyp rtyp sr rtyp sr rtyp rtyp rtyp sr rtyp ak rtyp styp ret rtyp call sr sr rtyp ak rtyp pack styp ret dom rtyp sr rtyp wf dom rtyp sr sr chapter typing expressions xp gettype gettype xp xp gettype xp gettype xp gettype xp gettype xp gettype chapter typing heap objects ret return ret ret ret ret ret ret ret ret open ret open chapter return htyp htyp rtyp htyp get pack xp htyp styp ret prog chapter typing states type checking restricts types appear judgments 
ak wf judgments primarily ensure type variables scope 
kinding judgment forbids types pointers 
prevent manipulating terms unknown size formalizing restriction somewhat contrived dynamic semantics formal machine trouble allowing terms unknown size 
asgn judgment describes types mutable expressions 
need judgments check source programs 
describe invariant need prove type safety section 
allowed source program prog describe judgments detail 
type variables type kind size known 
prevent types unknown size derive derive simplicity assume function types known size cyclone 
imagine implementing function definitions values size pointers code simplification justifiable 
types subject known size restriction 
require ak derive ak 
types asgn known size types form occur pointers 
give quantified types kind argued earlier doing useful 
exploit fact rules asgn lenient allow asgn instantiate type form 
enrich kind system distinguish assignable box kinds box kinds useful 
formed contexts wf judgments known size types free type variables 
describe heaps necessary 
typing rules statements unsurprising describe 
rule ss uses context ensure functions return values wrong type 
rule ss body binding checked extended context usual 
rules ss ss allow forms existential 
expected extend type bound term variable depends form unpack ss ss 
reuse type restriction existential types convert 
ss valid left expression type check ltyp opposed rtyp ss 
type ss form essence restriction types 
kinding assumption ss ss technical point ensure free occurrence possible conversion open statement 
note previous minor error enforce open valid left expression 
terms accidentally omitted assumption assumed type safety proof lval 
rules ltyp subset rules rtyp 
restricted form left expressions directly just conventional type checking judgment expressions 
subsequent chapters rules valid left expressions lenient syntactic restriction valid right expressions uniformity chapter uses separate judgment 
syntactic restriction suffices chapter programs read access data 
subsequent chapters reject right expression program access allow left expression access describe type checking rules right expressions 
type check xp sr uses gettype relation derive type type form acquire contents existential package package type form 
types assignable mutation interfere 
furthermore path package 
remember witness types packages unpacked statement form open witnesses change sound xp 
program executes packages unpacked 
fact need gettype source programs forbid nonempty paths 
sr prevents dereferencing pointer value unknown size 
sr hold surprises 
sr ensures valid left expression type assignable 
sr normal rule function call 
sr requires ret prove execution produce stuck terms form call sr sr conventional quantified types 
ak judgment types instantiations witnesses unknown size 
sr sr ensure functions return assume correct kinds quantified types 
cyclone require functions closed modulo global variables require appear top level 
rules ret straightforward 
terminating statements return ret judgment conservative analysis forbids possibility 
judgment prog describes invariant establish type safety 
heap type check free variables type variables 
checking htyp allow mutually recursive functions heap 
mutually recursive data encoded functions recursive types 
second xp value heap location xp describes existential package witness type package type indicate witness change 
third type check describe heap 
require ret really matter 
type safety appendix proves result definition 
state stuck form return 
theorem type safety 
styp ret reflexive transitive closure stuck 
informally typed programs continue evaluating terminate may terminate 
related seminal theoretical foundation quantified types programming languages polymorphic lambda calculus called system girard reynolds invented independently 
general purpose programming languages notably standard ml ocaml haskell quantified types type constructors allow code reuse 
higher level languages generally restrict types type variable represent 
polymorphic function instantiated type including records floating point types 
simpler implementations add level indirection records floating point numbers avoid code duplication 
sophisticated analyses compiler intermediate languages avoid unnecessary levels indirection 
extreme ml lack polymorphic recursion lets program compilers code essentially duplicating polymorphic functions type instantiated 
amount generated code appears tolerable practice 
defines template instantiation terms code duplication making template functions closer advanced macros parametric polymorphism 
example simple compromise current ocaml implementation records arrays floating point numbers add level indirection numbers 
polymorphic code accessing array cyclone terms type check run time array holds floatingpoint numbers run time type information necessary 
class polymorphism polymorphic recursion ml haskell enjoy full type inference programs need explicit type information 
type inference undecidable uncomputable term explicit types type check add class polymorphism polymorphic recursion 
haskell includes polymorphic recursion requires explicit types functions 
languages encourage functions conventional wisdom considers cyclone approach requiring explicit types function definitions intolerable 
room compromise inference powerful type systems exists proposals ml extensions additions haskell implementations demonstrate 
section described bounded quantification types increase cyclone type system expressiveness 
type theory bounded quantification received considerable attention particularly role encoding object oriented idioms 
important negative result concerns bounded quantification interaction subtyping sound consider subtype subtype subtype 
conventional subtyping rules rule subtyping universal types subtyping question types subtype undecidable 
common compromise require equal bounds example :10.1.1.117.695
possibility require explicit subtyping proofs hints proofs source programs 
problem polymorphic discussed section received attention ml community 
ml commitment full type inference advanced module system types complicate problem 
called weak type variable solutions kind distinction respect mutation fallen favor 
simple value restriction suffices 
essentially binding receive universal type initialized syntactic value variable immutable function definition 
solution interacts type inference appears tolerable practice 
cyclone explicit typing solution forbidding type instantiation left expressions natural 
explicit existential types designing programming languages 
mitchell plotkin seminal showed constructs types rep types clu clusters abstype declarations standard ml really existential types 
encodings closures objects existential types suggest lack explicit existential types languages sense issue terminology 
current haskell implementations include existential types class values suggested ufer 
existential packages immutable problem section irrelevant 
lower level typed languages included existential types encountered unsoundness problem 
example typed assembly language way create alias opened type cyclone patterns 
way change type value heap assigning existential package means making pointer refer different heap record 
xanadu language compile time reasoning integer values aliases opened type 
roughly int short hand uses int values implicitly include necessary open expressions 
expression copies value aliasing problem 
appears witness types change mutating heap allocated int change witness 
languages linear existential types provide solution different ones 
systems existential package fortiori aliases opened type 
walker morrisett exploit invariant define open introduce new bindings 
mutates location holding package hold package contents 
run time type information open actual effect 
vault system linear existential types :10.1.1.14.7406
formally opening vault existential package introduces new binding 
practice vault type checker infers put open pack terms rewrite terms bindings open statements introduce 
inference may vault existential types convenient 
section suggested extending cyclone way programs runtime tests refine information unknown type safely 
apparent disadvantage extension violate parametricity known concept reasoning behavior polymorphic functions 
simple example polymorphic lambda calculus term type behave equivalently function returns 
pierce sangiorgi clever trick showing languages mutable ml violate parametricity 
morrisett zdancewic argued true source ability violate parametricity aliasing values types value available types int 
naumann banerjee restricted aliasing establish parametricity setting mutation 
cyclone restrict aliasing type system ensure parametricity 
ensures basic memory safety 
typed assembly language implementation ia architecture powerful kind system cyclone details widely known 
number kind mi describes types memory objects consuming bytes 
kinds corresponds kind cyclone 
assembly level padding alignment explicit giving types descriptive kinds appropriate 
fine granularity assembly language instructions difficult type system allow safe value 
example pointer value type kind push copy pointed value stack 
doing requires adjusting stack pointer bytes executing multiple move instructions parts value 
believe details allowing operations implemented 
ghc haskell implementation provides alternate forms floatingpoint numbers records extra levels indirection 
uses restricted cyclone 
values types essentially kind language type variables kind unboxed records appear certain syntactic positions 
extensions programmers control data representation improve performance certain applications 
remarkably little quantified types languages 
smith volpano describe integration universal types formal development similarities consider struct types 
need existential types 
type quantification way prohibit unsafe casts void 
chapter discusses approaches 
chapter region memory management cyclone uses region memory management prevent dangling pointer dereferences 
memory object exactly region region objects deallocated simultaneously 
avoid run time overhead system encodes lifetime information type system 
despite imposing structure system allows important idioms 
integrates style stack allocation regions unbounded size immortal heap allows implicit conservative garbage collection 
usually code operate objects regardless allocated 
range options important step cyclone goals 
provide control memory management safe high level languages sacrificing safety resorting hidden run time requiring code duplication 
specifically system preventing dangling pointer dereferences sound programs dereference dangling pointers 
static dereferencing dangling pointer compile time error 
run time checks determine memory deallocated 
convenient minimize need explicit programmer annotations supporting idioms 
particular uses addresses local variables require modification 
exposed programmers control objects allocated long live 
usual local variables stack allocated 
comprehensive treat memory uniformly including stack heap optionally garbage collected regions 
scalable system supports separate compilation analyses intraprocedural 
section describes basic techniques achieve design goals 
section describes interaction region system quantified types 
critical issue interacting data hiding constructs existential packages dangling pointers reflected type 
cyclone solution existential types bit convenient type information code existential types remains simple 
section describes simple run time support necessary region system 
compared language imposes restrictions call free function requires explicit type information 
section describes informally strengths region system extensions needed capture additional idioms 
extensions experimental parts cyclone dissertation cover depth 
region system relatively mature aspect cyclone extensively 
previously published chapter borrows heavily measures programmer burden performance cost relative code 
measurements corroborate subjective evaluation 
section appendix formal machine regionbased memory management prove type system safe 
machine safety implies objects accessed deallocated 
compared machine chapter heap structure precisely objects regions 
discussed section cyclone system include region information type system 
explicitly typed low level language designed human programmers technical contributions explained chapter region subtyping discipline region lifetimes induces outlives relationship regions lets provide useful subtyping discipline pointer types 
simple effects eliminate need effect variables complicate interfaces novel regions type operator 
default annotations combine local inference algorithm system defaults reduce need explicit region annotations 
integration existential types combination region subtyping simple effects integration class types relatively simple 
readers familiar previous cyclone regions may wish focus sections appendix sections just revisions 
section gives detailed description related 
basic constructs section presents basic features cyclone memory management system 
starts constructs creating regions allocating objects part simple departure small 
corresponding type system involved pointer type carries region annotation 
exploit quantified types type constructors avoid committing particular regions just terms chapter avoid committing particular types 
show regions lifetimes induce subtyping pointer types 
point type syntax quite verbose explain features practice eliminate region annotations 
region terms cyclone memory region flavors single heap region conceptually lives forever stack regions correspond local declaration blocks dynamic regions lexically scoped lifetimes permit unlimited allocation static data objects reside heap 
primitives malloc new create new heap objects 
new operation malloc takes expression initializes memory 
explicit mechanism reclaiming heap allocated objects free 
cyclone programs link boehm demers weiser conservative garbage collector reclaim unreachable heap allocated objects 
section discusses interaction collector regions 
stack regions correspond local declaration blocks entering block local declarations creates storage lifetime corresponding lexical scope block 
function parameters stack region corresponding function lifetime 
short cyclone local declarations function parameters layout lifetime dynamic regions created construct region identifier statement 
region lifetime execution bound region handle primitives rnew allocate objects associated region 
example rnew returns pointer int allocated region handle initialized 
handles class values caller may pass handle function allocate associated region 
predefined constant heap region handle heap new malloc just short hand heap region rnew 
declaration block dynamic region deallocated execution leaves body enclosed statement 
execution leave due unstructured jumps continue goto return exception 
section explains compile dynamic region deallocation 
region system imposes changes representation pointers meaning operators 
hidden fields counts maintaining region information run time 
infrastructure preventing dangling pointer dereferences type system making dereferences compile time error 
region names ignoring subtyping pointers point exactly region 
pointer types include region name region point 
example int describes pointer int region named 
invariant pointers particular region basic restriction impose undecidable problem detecting dangling pointer dereferences tractable 
pointer types different region names different types 
handle region corresponding type region 
subtyping handle types singletons handles type handle 
region names fall flavors corresponding region flavors 
region name heap block labeled int name refers stack region block creates 
considering function definition labeled block function named region named parameters allocated 
statement region defines region name created region 
type region 
cases scope region name corresponds lifetime corresponding region 
give types examples 
type region type rnew type 
int declared block type int similarly type type 
dereference pointer safety demands region live 
goal determine compile time code follows dangling pointer 
suffices ensure pointer types region names scope 
example code ill typed int int code creates storage deallocated line assignment creates dangling pointer assignment dereferences 
cyclone rejects code scope declared 
change declaration region name assignment fails type check type int cyclone existential types allow pointers escape scope regions just closures functional languages 
general rely simple scoping mechanisms ensure soundness 
track set live region names control flow point 
keep analysis intraprocedural novel type effects system track interprocedural liveness requirements 
delay full discussion effects section 
understand correct region name pointer type helps emphasize left expressions types region names 
example type int left expression type region name similarly right expression type left expression region name assignment form safe region named live 
section describes type checking rules left expressions precisely 
quantified types type constructors region names type variables describe regions terms 
kind system distinguishes region names type variables region name kind incomparable kinds describe ordinary types 
region names type variables define region polymorphic functions types hide region names type constructors parameters 
section demonstrates natural features extremely important expressiveness cyclone region system 
particular region polymorphism common type polymorphism 
universal quantification functions cyclone region polymorphic actual regions arguments results 
way functions manipulate pointers regardless point stack heap dynamic region 
example contrived program fact abstracts region name takes pointer region named void fact int result int int fact result int int main fact return executed program returns value 
main pass fact heap pointer type fact instantiated 
recursive call instantiates name local stack region 
polymorphic recursion allows pass pointer locally declared variable run time instance fact modifies recursive call modifies caller stack frame 
alternatively written function void fact int result int fact result result third version uses dynamic region hold intermediate results void fact region int result int int rnew fact result int main region int rnew return fact function main creates dynamic region handle uses rnew allocate initial result pointer 
calls fact instantiating passing handle 
stack allocation fact uses dynamic region hold recursive result consuming space proportional space reclaimed control returns main 
region name function prototypes assume guarantee region equalities unknown regions 
examples typecheck assign pointer wrong region void int pp int pp rejected void int pp int pp accepted region equalities crucial return types particularly return value placed caller specified region int identity int return int region return rnew example heap region type int ensures caller pointed object conceptually live forever 
realistic code uses region polymorphism 
example ignoring nul terminators strings null pointers cyclone string library provides prototypes char strcpy char const char char const char char region const char int strlen const char parametricity ensures strcpy returns pointer argument 
course functions region polymorphic example shows int null void set int existential quantification existential quantification region names relate regions pointers handles example demonstrates struct int int region value type struct swap contents point mutate fresh locations allocated struct useless sense cyclone program 
explained section region named may deallocated case accesses unsound 
strengthen definition struct existential type definitions chapter useful 
type constructors struct definitions contain pointers cyclone allows definitions take region name parameters 
example declaration lists pointers ints struct int hd struct tl ignoring subtyping value type struct list hd fields point tl fields point 
invariants possible type tl struct declaration describe lists regions hd tl alternated element 
type abbreviations typedef region parameters 
example define region allocated lists heap allocated pointers typedef struct list subtyping region corresponding outlives region corresponding sound cast type type 
region discipline outlives relationships common create region know region currently live outlive 
example local variable hold different function arguments void int int int int 
subtyping program fails type check type int change type int int assignments illegal 
subtyping assignments subtyping cast implicitly ensure soundness allow casting subtype cast allow putting location code expects 
problem usual covariant subtyping 
allow casts const subtype enforce read access const values 
support deep subtyping combined polymorphic recursion powerful allow stack allocation structures arbitrary size 
created region outlives live regions rule suffices establish outlives relationships 
safety function requires arguments outlives relationship function explicit constraint expresses partial order region lifetimes 
constraint part function type assumed type checking function body precondition calling function 
simple example void set int int constraint indicates region named outlives region named 
default annotations cyclone employs combination carefully chosen defaults intraprocedural inference reduce dramatically amount necessary explicit type information 
region names type variables rules section apply 
pointer type includes possibly implicit region name rules gain importance compared chapter 
rules slightly different region names section explains 
due type inference function bodies implicit type instantiation polymorphic functions implicit subtyping cyclone programmers rarely write region names function bodies 
particular region names local declaration blocks explicitly 
block explicit label type checker just creates region name 
explicit labels type instantiations previous examples expository purposes 
function definitions function prototypes top level implicitly universally quantify free type variables including region names explicit bindings previous examples chapter unnecessary 
explicit bindings necessary class polymorphism 
explicitly bound type checker infers kind type variable uses argument result types 
furthermore type checker fills omitted region names function argument types fresh type variables region kind 
function result types fresh type variable default region polymorphic function return pointer region return null 
function return types default region name rules programs fact example need region annotations void fact int result int int fact result int int main fact return words code program ports cyclone modification 
generally explicit annotations necessary express region equalities safety relies 
example write void int pp int pp code elaborates void int pp int pp fails type check int int 
programmer insert explicit region annotation assert appropriate equality relation parameters void int pp int pp realistic examples string library prototypes earlier unnecessary annotations char strcpy char const char char const char char region const char int strlen const char default rules type definitions convenient 
type checker uses place omitted region names 
type variables including region names explicitly bound 
example struct lst example annotations removed 
fortunately type definitions usually account small portion program text 
recursive struct definitions difficult take struct definition omitted region annotations implicitly type constructor arguments automatically filled region names 
types rules sense field definitions available 
providing interface programmers give explicit type constructor parameter names kinds anyway 
second recursive mutually recursive types clear parameters type constructor 
naively generating fresh region name omitted require infinite number region names definition struct lst int hd struct lst tl 
complication type constructors require explicit instantiation need rules order inferred parameters 
default rules regularity assuming recursive instances instantiated arguments addition cyclone 
defining type constructors requires explicit region names 
partially apply parameterized type definitions elided arguments filled rules pointer types 
aggressive feature typedef struct lst heap copy ans null null tl ans new lst new hd ans return ans defaults parameter type return type 
inference compiler gives ans type return statement requires ans function return type type initializer type 
interaction type variables section suggested scope restrictions region names prevent pointers escaping scope region 
particular function block return assign value type outside scope definition simply write formed type result 
cyclone mechanism type abstraction property hold 
way hide pointer type result pointer escape scope region 
existential types provide exactly ability 
closures objects provide similar ability languages essential problem class types crucial safe strongly typed languages 
cyclone programs create dangling pointers safety demands programs dereference pointers 
address problem type system keeps track set region names considered live program point 
walker crary morrisett call set live regions capability 
allow dereferencing pointer type system ensures associated region name capability 
similarly allow function call cyclone ensures regions function access live 
function types carry effect records set regions function access 
capability program point enclosed function effect region names declaration blocks dynamic region statements containing program point 
idea effects ensure soundness due tofte talpin 
cyclone effect system differs substantially previous 
departure tofte talpin system calculate default effects function prototype inferring function body preserve separate compilation 
default effect includes set region names appear argument result types 
instance prototype int int int elaborates int int int default effect 
absence polymorphism default effect conservative bound regions function access 
programmer override default explicit effect 
example dereferences argument strengthen prototype adding explicit effect follows int int int stronger type callers instantiate name possibly deallocated region pass dangling pointer 
unsurprisingly effects exceedingly rare 
second departure tofte talpin system effect variables type variables effect kind 
effect variables serve purposes simulate subtyping unification inference framework 
second set regions data hiding construct need access 
third set regions type hides 
cyclone effect variables abandoned approach reasons 
support effect subtyping correctly tofte talpin inference algorithm requires effect variables prenex quantified function type unique effect variable effect 
invariants unification fail 
explicitly typed language cyclone awkward enforce invariants 
furthermore prenex quantification prevents class polymorphism cyclone supports 
second effect variables appear library interfaces making libraries harder understand 
consider type polymorphic sets effect variable struct set list elts int cmp set consists list elements spine list region 
know elements allocated instantiate 
comparison function cmp determines set membership 
elements type known type cmp effect variable set regions access comparing values 
effect variable type region variable abstracted set structure 
suppose library exports set clients abstractly struct set region kind effect kind client discern connection abstracts set regions hidden comparison function access 
avoiding effect variables simplify system retaining benefit effect variables type operator regions 
novel operator just part type system exist run time 
intuitively regions represents set region names occur free 
particular regions int regions regions regions 
regions regions 
regions type variables regions treated set region variables effect variable 
example regions regions 
default effect function type simply includes regions 
way instantiate resulting function type effect includes free region names 
rewrite set example follows struct set list elts int cmp regions connection type parameter function effect apparent data structure longer needs effect variable parameter 
regions default effect int cmp need write 
suppose wish build set int value particular comparison function unnecessary annotations expository purposes int cmp ptr int int return set int build set list int return set elts cmp cmp ptr default effect cmp ptr 
instantiating int effect cmp regions int equals 
result build set type checks 
fact function default effect succeed 
consequently programmers need explicitly mention effects designing libraries 
particular choice definition regions ensures programs default effects dangling pointers fail type check effects 
prove conjecture 
essence definition permissive programs dangling pointers natural choice 
interestingly definition regions introduce type variables regions include type variable region name free sound 
matters substitute set occurrences regions maintain effect equalities assumed type checking code scope 
proof formed definition regions sound observe proof appendix uses property regions introduce type variables 
existential types mentioned existential types allow cyclone programs create dangling pointers example demonstrates struct intfn int func env env int read int return struct intfn int struct intfn ans int func read env return ans witness type int appear result type struct intfn typed 
type checker rejects attempted call func field struct intfn int apply intfn struct intfn pkg intfn func env pkg return rejected effect regions pattern match add bound type variables current capability doing unsound 
existential package far dissertation ill typed reason 
existential packages usable conjunction region system leak information prove call safe leaking information longer hide data 
effect variables offer solution 
enrich constraints indicate region form effects 
constraint holds variables exists variable outlives 
example revise struct intfn struct intfn int func env env constraint defines region bound struct intfn regions outlive having current capability sufficient call func 
example struct intfn witness type mention regions heap 
allowing bounds provide flexibility requiring types live forever programmers memory management just add bound existentially bound type variables 
doing fixes earlier examples 
run time support code generation run time support cyclone regions simple 
heap stack manipulation exactly dynamic regions represented linked lists pages page twice size previous 
region handle points list current allocation point page rnew place object 
insufficient space object new page allocated 
region deallocation frees page 
garbage collector included dynamic region list pages acquired collector 
collector supports explicit deallocation free regions 
note collector simply treats region pages large objects 
reachable stack scanned pointers heap allocated objects ensuring objects preserved 
advantage interface simplicity cost collection time object dynamic region appears reachable live dynamic regions scanned objects reachable dynamic regions reclaimed 
code generator ensures regions deallocated lifetimes due unstructured control flow 
intraprocedural jump return easy determine statically regions deallocated transferring control 
throwing exception number regions deallocate known statically 
store region handles exception handlers integrated list operates manner 
exception thrown traverse list deallocating regions reach exception handler 
transfer control longjmp 
fashion ensure region deallocated control returns 
evaluation section informally evaluates region system strengths idioms conveniently captures weaknesses inconvenient restrictions lift 
section presents advanced examples encountered practice system supports 
news cyclone approach memory management meets primary goals 
preserves safety addressable objects garbage collected heap 
access run time cost generated code pointer dereferences exactly grouping objects regions types form capture lifetime information type system fine grained pointer different type 
lexically scoped lifetimes cyclone regions restricts coding idioms described section captures common idioms contributes eliminating explicit region annotations 
local declaration blocks lexically scoped lifetimes cyclone system describes naturally 
functions cause parameters escape stored data structure outlives function call take address local variables 
passing address local variables dangerous practice 
cyclone programmers hesitant technique type system ensures safe 
cyclone dynamic regions capture idiom caller determines function result lifetime callee determines result size 
division responsibility common result size may depend computation callee know caller knows result 
idiom awkward implement 
callee allocates result malloc caller free difficult call free twice memory 
programs resort simpler interface caller allocates space result hopefully large 
functions gets sprintf library notorious examples 
caller guesses wrong callee usually fails commits buffer overrun 
course programs implement dynamic regions 
lifetimes cyclone region subtyping useful region live function entry outlives regions function creates 
need worry region name aliasing 
function free region named left scope allowing access region named free safe caller instantiate region 
integration garbage collection lets programmers avoid burden manual memory management application need 
allows convenient program evolution path prototypes rely garbage collection profiling guide manual optimizations dynamic regions reduce memory consumption 
default effects region annotations extremely 
previously published measured possible port applications cyclone writing average explicit region annotation lines 
key result implicit instantiation quantified types ensures callers write extra information region polymorphic functions 
effects form regions avoid effect variables container types 
result cyclone programmers need know effects existential types 
simple region bound constraints usually suffice 
system full power effect variables uses regions effect occur effects regions imposes restrictions effect variable 
inferring correct instantiations guaranteed succeed programs may need explicit instantiations 
simulation effect variables indicates cyclone system fully explicit form powerful due lack effect variables 
bad news biggest restriction imposed regions lexically scoped lifetimes 
garbage collected heap objects objects reclaimed region leaves scope 
shortcomings lexically scoped lifetimes sketching extension safely allows programmers deallocate regions program point avoids access run time cost 
greg morrisett advisor designed extension importance complement static regions warrants brief description 
understand limits lexical scope consider scheme copying garbage collection couched region terms create region allocate objects 
big create region copy live data free continue place lexically scoped regions reclaim create need collect created 
bound number garbage collections compile time scheme 
common structure long running numerical calculations event servers 
problem lexical scope global variable point memory pointer hidden existential type 
region name global scope 
pointer hidden existential package region bound 
bound true heap pointers 
garbage collection way reclaim memory accessible global variables 
third shortcoming program control structure force regions live longer necessary 
extreme example void int int run long time void region allocate lot int rnew safe free region creates soon call initializes address problems add new flavor region created deallocated expression 
handles regions types form means region named handle region named deallocated region named deallocated deallocated sooner 
primitive functions allow creation deallocation struct newregion struct newregion rnew region void free rnew returns new region name existentially bound 
usual unpacking existential add current capability 
add construct region open type 
construct throws exception deallocated binds handle region gives type region adds capability attempt free region free raises exception 
avoid run time cost accessing objects region opening deallocating regions require run time checks potential exceptions 
region flavor avoid problems lexical scope 
long running loops copying collection technique problem handles deallocated regions reclaimed 
support restricted aliasing handle avoid shortcoming 
turning type system rule pointer type region name prove inconvenient 
example consider incorrect code int 
bool int int return region name return type correct function return pointer region named pointer region named 
constraints give function type int bool int int return data structures pointers point variety regions constraints struct definitions analogous way 
technique unnecessarily restrictive part program know serve purpose example 
solution annotate pointers effects including effect variables region names 
example effect variables give type int bool int int 
access effect current capability 
disadvantage extension type inference difficult 
believe require solving arbitrary set inequalities 
language designed humans clear added expressiveness justifies added complications 
obvious limitation cyclone programs deallocate individual objects 
putting object region option 
example list objects list element different type 
systems restrict aliasing allow idioms 
example known acyclic list elements reachable spine list safe deallocate list elements provided list subsequently 
region system suffers significant 
interface dynamic regions coarse resource conscious programming 
wider interface allow programs set initial page size determine policy growing region current page full set maximum size region allocation fails 
similarly interface garbage collector coarse objects dynamic region appear live fields objects potentially pointers 
sophisticated interfaces possible 
example regions disallow pointers collector need scan 
possibility setting maximum object size say bytes region informing collector 
way pointer address region cause collector scan addresses second way keep callee allocating heap region type system little prevent space leaks 
revisit decision heap region accessible regions probably correct default applications 
third inconvenient parameterize struct definitions region names 
common collection interdependent mutually recursive type constructors suffices parameterize region name region name pointer types applications definitions 
different note sound allow subtyping constraints formalism chapter 
example polymorphic functions different constraints may type subtype type provided constraints imply constraints 
subtyping amounts bounded quantification constraints 
chapter referred known results bounded quantification types subtyping undecidable 
constraints problem appears simpler constraints just relate sets type variables carefully investigated decidability 
advanced examples section describes sophisticated uses existential types interaction region system 
examples help demonstrate cyclone power limitations eliminating effect variables 
impose programmer burden cyclone code 
closure library cyclone closure library provides collection routines manipulating closures functions hidden environments type represent type struct fn regions env typedef struct fn fn type fn describes closures produce 
call closure capability include regions regions regions 
region bound means having capability establishes regions 
write routines create closures fn fn hf regions return fn env apply fn fn code env env return code env apply type checker fills region bound type routines tasks composing closures converting function pointer closure easy write 
interesting functions currying uncurrying 
languages functions closures functions types curry uncurry cyclone write tuple construction tuple field access 
implementing uncurry straightforward lambda fn fn arg return apply apply arg arg fn uncurry fn fn regions return fn lambda usual build closure takes pair applies original closures appropriately 
explicit constraint type uncurry redundant argument types cyclone infer constraints argument types 
unnatural restriction original closures region bound 
lenient harder read solutions exist original closures bounds uncurry additional constraints 
possibility change definition struct fn bound regions type parameter 
doing simulates effect variables 
uncurry take closures bounds return closure bound 
implement curry inner fn env second return apply env new env second fn outer fn regions return fn inner new fn fn curry fn regions return fn outer usual applying closure creates second closure holding argument original closure environment 
applying second closure applies original closure newly created pair 
interesting point solution type checks constraints outer discharged outer instantiated curry 
call fn curry type check parameter constraint free function type 
fact type checker discharges constraints function called impossible implement curry definition struct fn 
iterators example data type iterator returns successive elements hidden structure 
define type constructor struct iter regions env bool env dest typedef struct iter iter iterator creator provide function field returns false elements 
element function store dest 
existential type allows iterator maintain state remember elements remain 
class polymorphism universal quantification allows call select element stored 
example iterator client store results stack heap 
parameter struct iter elements stored region subtyping region specified creating iterator 
iterator library provides function bool iter iter dest iter env env iter return env dest real creating iterators 
representative example iterator linked lists 
struct list hd struct list tl typedef struct list list bool iter list elts left dest elts left return false dest elts left hd elts left elts left tl return true iter iter region rgn list lst regions return iter env rnew rgn lst iter iter witness type list private state pointer list remaining elements 
iter field delay instantiation type parameter purpose syntax 
minor point iter read list elements give explicit effect omitting regions turn avoid needing constraint regions iter 
implemented complicated iterator red black trees 
formalism section defines formal machine models interesting aspects region system 
machine objects allocated region regions obey discipline 
run time heap structure simple partial map chapter 
distinguish heap region model garbage collection 
type safety implies programs access objects deallocated regions 
furthermore terminating programs deallocate regions allocate 
stack regions dynamic regions prove programs allocate stack regions created 
fact technically static semantics allows handles stack regions prevent suffices forbid explicit handles source programs 
type system combination type system formal machine chapter additions necessary modeling region types type variables kind effects function types constraints quantified types singleton types region handles 
provide subtyping pointer types outlives kinds effects constraints types int region terms return open region pop xp call pack rnew rgn ip values xp pack rgn heaps states contexts chapter formal syntax relationship 
simplicity subtyping types adding subtyping probably difficult 
machine proof similar earlier technical report version small improvements corrections formalisms chapters 
particular treatment paths chapter constraints allow just run time regions named integers type variables 
difference matter taste clear run time type information means type variable context describe regions created 
difference source programs 
formalism chapter similarly uses integers run time locks type variables 
syntax presents language syntax 
compared language chapter eliminate patterns add constructs necessary reason cyclone region system 
focus additions 
kinds include types region names 
source programs type variables kind know kind write remind syntactic class 
run time name actual regions integers 
names region singleton type kind know type kind write remind 
actual cyclone handles types form region pointer types include region names describing pointed value resides 
function types include explicit effect describe regions live calling function 
source programs effect set type variables 
kind mean region named live 
generally mean region names mentioned type stands live 
simplifies matters allow effect regardless kind 
run time region names integers effects include assume effects identical usual notions set equality associativity commutativity idempotence 
clear definition substitution identical equal sets sense 
quantified types introduce constraints 
constraint means describes live regions describes live regions 
put way assuming live conclude live 
instantiate universal type constraints hold instantiation 
similarly existential package existential type type constraints hold package witness type 
constraint holds type variables exists type variable 
nature regions introduces constraints allocating region named know current capability 
term forms similar terms chapter 
open constructs allocate location stack region region deallocated enclosed statement terminates handle 
compiletime region name region variable name bound enclosed statement 
term region corresponds region cyclone creates region binds handle placing region executes deallocates region 
explicit cyclone 
statement form pop appear source programs 
placeholder term syntax machine deallocates region executing expression forms chapter rnew rgn exactly rnew cyclone 
actual region handle region region handles values 
function definitions include explicit effects constraints keep type checking syntax directed explicit region name parameter inducing region name function name 
heap structure corresponding regions 
stack regions maps locations values allocated region right 
assume regions distinct domains unique variable repeated 
abuse notation write mean dom 
program state sg includes garbage data sg live data current code machine stuck tries access sg sg effect program behavior 
contains deallocated regions practice keep run time 
explicit sg just technical device keep program states referring free variables dangling pointers 
type check terms context specify run time region names scope kinds type variables types regions locations known constraints current capability 
source programs empty contains predefined heap region program state sg sg induce 
section presents details heap affects typing context 
convenient write cr respectively 
partial maps mean union implicitly require domains disjoint 
similarly means followed 
implicitly consider 
particular spop epop judgments restrict order program deallocates regions 
order unimportant may treat set writing mean form mean dynamic semantics chapter rules rewriting defined terms interdependent judgments statements left expressions right expressions figures accessing mutating parts aggregate objects defined auxiliary judgments type instantiation involves type substitution essential run time effect 
describe judgments detail 
rule ds creates new region hold stack object puts region right deallocated regions region run time name fresh substitute type variables run time region names rely conversion ensure fresh avoid type substitution 
deallocate right time insert appropriate pop statement 
rules ds just rules ds chapter 
rule ds creates new dynamic region 
just ds holds handle rgn new region 
rules ds ds elimination rules pop deallocate regions 
apply region rightmost live sgs dom sgs sg sg pop ds sg sg ds sg sg ds sg return sg return ds ds sg sg sg sg ds sg open pack sg ds sgs dom sgs sg region sg rgn pop ds sg pop sg ds sg return pop sg return ds sg sg sg return return sg sg sg open open sg sg sg pop pop ds ds chapter dynamic semantics statements get sg xp sg dr set sg xp sg dr sg xp sg xp dr sg sg vi sg sg call dr sg call return sg dr sg dom sg rnew rgn sg dr sg sg call call dr sg sg sg dr sg dr dr sg sg sg sg xp xp sg sg sg sg sg sg rnew rnew sg rnew rnew sg pack pack dr sg xp sg xpi dl sg xp sg xp dl sg sg dl sg sg dl chapter dynamic semantics expressions get get get get get set set set set set chapter dynamic semantics heap objects region machine stuck 
rules add region garbage stack 
region position garbage stack irrelevant stack accessed 
congruence rules ds hold surprises 
chapter putting multiple rule just conciseness 
rules dr dr get set relations simpler chapter eliminated patterns access update live data 
complicated extra structure importantly sg machine stuck active term xp sg 
rules analogues rules chapter dr 
rule defines allocation dynamic region 
creates new location puts returns pointer cyclone regions syntactic effect 
effects union primitive effects form decision simplifies static judgments regarding effects constraints slightly complicates definition type substitution effects effect define regions regions types effects defined 
type safety proof uses fact regions produces effect formed long formed 
rest definition substitution conventional 
static semantics valid source program statement type checks empty context styp terminate returning ret contain pop statements spop 
chapter type checking judgments statements left expressions right expressions figures interdependent gettype relation types aggregate objects 
interesting change type checking left expression determines type region name describing location 
expressions access memory assignment right expression xp effect substitution regions constraint substitution type substitution int int region region constraint regions regions regions regions type regions regions regions int regions regions regions regions regions regions regions regions regions regions regions regions regions regions region regions regions notes mean implicitly rename avoid capture 
omit formal definition terms contexts simply substitute contained terms types constraints effects 
chapter dynamic semantics type substitution wf dom wf wf wf wf wf int wf wf wf wf wf dom wf region wf dom wf wf wf wf wf wf wf chapter kinding formedness type check current capability constraints establish memory deallocated 
judgment acc defines notion general notion eff defines 
judgment type check function call current capability establish function effect 
need lift notion implication constraints eff check quantified types constraints 
defines judgments 
defines judgments ensuring types correct kinds typing contexts formed 
constraints effects types may free occurrences type variables regions provided context 
judgments figures sophisticated necessary source programs 
judgments spop epop relax requirement programs pop statements imposing structure ensure programs deallocate regions correct order access eff acc eff acc eff eff eff eff eff eff eff eff eff eff eff eff eff eff chapter effect constraint containment rtyp styp ss rtyp styp return ss styp styp styp ss rtyp int styp styp ss rtyp int styp styp styp ss rtyp dom dom styp styp ss rtyp dom dom styp styp open wf dom dom region styp styp region styp styp pop ss ss ss chapter typing statements rtyp ltyp sl gettype wf ltyp xp ltyp ltyp sl sl ltyp regions acc cr ltyp ltyp ltyp sl sl gettype acc wf rtyp xp rtyp acc rtyp wf rtyp int sr sr rtyp rtyp sr sr rtyp rtyp ltyp rtyp sr rtyp rtyp rtyp ltyp rtyp acc rtyp sr sr sr rtyp rtyp eff sr rtyp styp ret rtyp call sr rtyp cr eff rtyp sr rtyp cr eff cr rtyp pack sr wf dom dom styp ret rtyp sr rtyp wf rtyp sr rtyp rtyp region acc cr wf sr rtyp rnew rtyp rgn region sr rtyp regions acc cr rtyp chapter typing expressions sr gettype gettype gettype gettype gettype chapter typing heap objects ret return ret ret ret ret ret ret pop ret ret ret open ret region chapter return spop spop pop spop spop spop epop spop spop spop epop epop spop epop spop spop spop open epop xp epop epop rgn epop epop epop epop epop xp epop epop pack spop epop spop spop region epop epop epop epop epop epop epop epop rnew epop spop spop return spop epop call chapter typing deallocation epop epop epop epop epop rnew htyp htyp htyp rtyp epop htyp htyp htyp htyp 
hn 

sg 
rg 

htyp sgs styp ret spop prog sg chapter typing states deallocated regions 
htyp judgments derive context judgment prog type checks entire program states 
describe judgments detail omitting descriptions straightforward type checking rules 
judgments just ensure constraints effects refer meaningless free type variables regions 
kinding judgment simpler chapter types mutable known size 
ensure rule quantified types forbids type variable kind interesting aspect judgment kind rules require region kind types kind acc eff judgments straightforward 
implicit set equalities associativity commutativity rules eff amount showing constraints exists outlives 
rules ss complicated concern terms create regions 
type check contained statement extend compiletime name created region extend having appropriate type region name extend current capability region live executes extend region lifetimes 
language composite operations allocate region allocate object execute statement deallocate region complicated rules 
hypotheses rules straightforward 
note ss handle type region 
rule ss just adds current capability check pop important include capabilities check pop live doing impossible type safety proof establish type check deallocated 
rules ltyp quite simple 
region name region name aggregate object resides region 
rules acc judgment explicitly evaluation left expressions access memory evaluation contained right expression 
requiring left expressions refer live memory allows dangling pointers xp type check pointed memory deallocated 
hand rules type checking right expressions acc eff judgments 
example sr acc hypothesis prove expression xp stuck 
see include deallocated regions 
rule sr reason ltyp includes region name need type reason rule sr need region name forbid mutating deallocated memory 
rule sr forbids function calls current capability establishes function effect 
rules sr sr ensure constraints introduced quantified types provable known constraints context 
constraints false rules sound assume quantified type constraints rules sr ss 
rules sl sr allow subtyping pointer types 
earlier erroneously omitted sl 
language safe type preservation hold 
ret judgment defined rules sr sr chapter 
intuition spop deallocate regions right left order deallocate region twice 
pop executes deallocating correct left region 
furthermore terminates deallocate region actual definition slightly restrictive 
example requires pop statements nested inside 
technically syntax path root active redex include pop statements 
htyp judgments add region maps value type 
values need nonempty capability type check execute type check 
require epop ensure function bodies heap pop statements 
rule prog sg usual heap type check allowing cyclic type check heap context 
free occurrences type variables regions sg 
type check heap constraints sound assume spop ensures deallocate regions order consistent 
rg sound constraint form constraint means describes live region describes live regions holds vacuously live 
type safety appendix proves result definition 
state sg stuck form return sg 
theorem type safety 
styp ret contains pop statements reflexive transitive closure stuck 
note attempt access object garbage heap sg lead stuck state 
related safe polymorphic language static region memory management cyclone represents unique promising point design space systems share features 
section describes systems approaches memory management 
making safe systems aim code safe chapter describes 
static bug finding tools lclint successor splint perform unsound useful analyses find potential dangling pointer dereferences space leaks 
annotations describe invariants counting pointer uniqueness 
cyclone avoiding analysis errors requires restricted coding idioms additional annotations cyclone soundness guaranteed 
way static tools reduce false positives rewriting code 
systems safe change data representation insert runtime checks detect dangling pointer dereferences run time 
example pointers compiled machine addresses plus integers representing object pointed code manipulating pointers maintain integers 
run time system maintains table live integers dereferences require checking table 
integers reused 
performance overhead substantial 
allow stack pointers activation records need associated integers 
approach requires changing data representation difficult link legacy object code 
systems keep integers separate table indexed pointer values 
ccured system takes hybrid approach recover performance 
object freed entire storage immediately reclaimed marked inaccessible 
subsequent accesses check mark signal error object dereferenced 
ultimately mark reclaimed garbage collector avoid leaks 
program static analysis ensures dangling stack pointers exist 
analysis conservative programmers rewrite code 
main advantage systems require modification legacy code 
soundly preserve data representation object lifetimes common reasons static regions tofte talpin seminal implementing ml regions provides foundation regions ml kit 
programming kit convenient compiler automatically infers region annotations 
small changes program drastic unintuitive effects object lifetimes 
program effectively understand analysis try control indirectly certain idioms 
ml kit includes optional support accurate garbage collection regions 
doing requires changing region inference creates dangling pointers 
number extensions basic tofte talpin framework avoid constraints region lifetimes 
examples ml kit includes reset region primitive cyclone experimented feature aiken provide analysis free regions early walker propose general systems freeing regions linear types 
systems expressive framework 
instance ideas capability calculus implement type safe garbage collectors language 
systems designed source level programming 
designed compiler intermediate languages analyses ignore issues minimizing annotations providing control user 
projects vault henglein aim provide safe source level control memory management regions :10.1.1.14.7406
vault powerful type system allows region freed leaves scope types enforce code free region 
vault restricts region aliasing tracks fine grained effects 
result programming vault require annotations 
henglein designed flexible region system require behavior 
system monomorphic order unclear extend support polymorphism existential types key difficulties chapter 
typed assembly language microsoft cil provide support type safe stack allocation 
system allows programmers mix stack heap pointers systems place strong restrictions stack pointers 
instance microsoft cil prevents pointers placed data structures returned results 
regions closely related gay aiken rc compiler earlier system 
provide language support efficient counting detect region deallocated remain pointers 
dynamic system priori restrictions regions lifetimes pointer point rc approach encode memory management idioms 
rc eager detect errors compile time eager fails dangling exist followed 
rc safe language approach regions sound 
pointer qualifiers keep rc overhead low imposing invariants counting unnecessary 
general invariants checked run time static analysis removes checks 
traditional pointers point heap stack 
rc include areas region system traditional pointers involves counting 
second pointers point region containing object 
counts track pointers outside region rc avoid counting 
cyclone uses region name equalities capture region idiom counting fact pointer points container region unimportant run time 
third rc region creation construct take parent region 
run time checks parent region freed new region 
qualifier allows pointers ancestor regions 
parent pointers cyclone region subtyping 
counting forces restrictions cyclone 
rc forbids casts int void cyclone terms instantiating int leads code know manipulating pointer region 
cyclone region system need know information conservative garbage collector 
second rc forbids longjmp cyclone terms exceptions code decrements counts due local variables executed 
activation records avoid problem 
regions general idea region memory management allocating object regions objects deallocated simultaneously old possible document uses 
gay aiken nicely summarize systems regions including require simultaneous deallocation 
regions called arenas zones 
sense optimizing compilers analyses stack allocate objects related 
essentially cyclone provides programmers technique type system verifies soundly 
garbage collectors inappropriate real time tasks real time specification java extends java objects essentially regions 
cyclone terms creation object essentially handle separate lexically scoped region 
default location allocated objects object heap 
users allocate objects explicitly set new default 
cyclone scheme creates implicit stack regions region objects deallocated control leaves appropriate scope 
cyclone lifetime real time java object part type 
attempting create older region younger causes run time exception 
assignment statement include lifetime check static analysis eliminate checks dangling pointers exist 
incorrect object occur twice region stack exception occurs second attempted 
error impossible cyclone separate creation handles regions 
summary systems convenient cyclone ccured take away control memory management 
static systems capability calculus provide powerful region constructs designed intermediate languages programming convenience cyclone 
systems rc safe flexible offer static guarantees 
chapter type safe multithreading chapter extends cyclone locks threads 
programs create acquire release locks spawn new threads 
threads communicate shared mutable heap locations 
enforce safety extend type system enforce mutual exclusion shared data allow unsynchronized access thread local data 
extensions interact smoothly parametric polymorphism region memory management preceding chapters develop 
motivate safe multithreading mutual exclusion 
sketch chapter structure highlight technical contributions 
writing multithreaded programs difficult writing single threaded programs typically far possible execution sequences human reasoning automated testing 
particular easy unintended data race thread accessing data thread mutates data leave program data inconsistent state 
multithreaded applications style data representation resource management important operating systems extending cyclone multithreading useful important application domains 
programmers intend programs race conditions 
reason extending type system guarantee data races occur useful 
eliminates potential source errors allows thread violate invariant temporarily update shared data structure assurance threads view data state violating invariant 
fact preventing data races multithreaded cyclone essential presence races cyclone type safe 
cyclone implementation ensure reads writes words memory atomic 
system just uses conventional compiler gcc native thread library 
underlying architecture shared memory multiprocessor prevent data races corrupting memory race condition pointer yield arbitrary result course violates memory safety 
system enforcing atomic access words insufficient safety require writing multiple words intervening access 
mutating existential package witness type changes unsafe allow access fields old witness type new 
common example struct field holding length array field points 
allowing updates records refer shorter longer arrays desirable forbid access length field wrong 
short reasons enrich cyclone type system guarantee absence data races 
programs supposed races static assurances increase reliability 

updating may atomic implementation races corrupt pointers 

type safety require writes multiple memory locations thread reads 
reasons apply form expressive safe low level multithreaded language 
perspective designing type safe language optional mandatory section describes cyclone basic techniques making potential data races compile time error 
approach strikingly similar approach making dangling pointer dereferences compile time error 
compile time lock names run time locks 
lock type pointer type includes lock name 
lock types lock name describe run time lock 
pointer type lock name indicates lock mediates access pointed data 
type system ensures thread accesses data holds appropriate lock 
crucial complication notion thread local data 
memory need lock type system enforce thread uses memory 
thread local data rule exception 
data programs easier write efficient 
kind system distinguishes sharable unsharable types library clients pass thread local shared data 
section describes interaction type variables representing locks type variables representing types 
chapter need way describe access rights necessary value unknown type 
novel type constructor compile time constraints 
regions natural notion subtyping 
section describes interaction multithreading region system 
earlier sections ignore deallocation 
systems analogous orthogonal 
interesting interaction comes allowing threads share data live forever 
prevent thread accessing data deallocated 
section describes necessary run time support multithreading 
cyclone multithreading operations quite conventional easy implement top native thread system 
interaction regions requires interesting run time data structures 
section evaluates system 
main strengths uniformity region system efficient access shared data structures 
main weakness lack support synchronization idioms lock mutual exclusion 
sections appendix model interesting aspects multithreaded cyclone prove type safety result 
machine requires mutation take steps type safety implies absence data races 
semantics models difficulty ensuring safety presence nonatomic operations significantly complicates safety proof 
regain simplicity model omits memory deallocation left expressions form section describes related 
chapter largely adapts closely related race detection type systems higher level languages 
particular flanagan abadi freund developed idea singleton lock types effects 
applied ideas large java programs 
furthermore boyapati lee rinard approach thread local data similar mine :10.1.1.1.5802
chapter technical contributions adapting ideas integrate parametric polymorphism complicates effect language regions 
result works particularly caller locks idioms 
callers pass special nonlock thread local data callees callee locks idiom 
addition allows code reuse boyapati system incurring essentially unnecessary overhead thread local case 
integration regions allows shared data objects live forever 
kind system collects additions coherent type language clearly describes types sharable 
type safety proof formal machine thread local data 
furthermore previous formal prevented data races machines races violate type safety 
basic constructs section extensions cyclone multithreading 
design goals include statically enforce mutual exclusion shared data 
synchronization explicit programmer 
allow libraries operate shared local data 
represent data access memory exactly single threaded programs 
allow accessing local data synchronization 
avoid interprocedural analysis 
multithreading terms support multithreading add primitives statement form cyclone 
primitives cyclone types implement entirely library written spawn function takes function pointer pointer value size value 
executing spawn evaluates sz respectively copies fresh memory pointed new doing copy requires sz executes new thread 
spawned thread terminates returns spawning thread continues execution 
note points shared copy shallow local new thread 
newlock function takes arguments returns fresh lock 
locks mediate access shared data shared object lock thread hold accessing object 
explained type system connection objects locks 
nonlock constant serves 
acquiring nonlock runtime effect 
purpose provide value real lock unnecessary corresponding data local 
void int void lock plk int sync plk struct lkint lock plk int void struct lkint plk void lock lk newlock int new int new struct lkint new lkint plk lk spawn sizeof struct lkint lk nonlock example multithreading terms type information statement sync evaluates lock nonlock acquires lock executes releases lock 
thread hold lock time acquisition may block thread releases lock 
note cyclone prevents deadlock 
uses constructs includes type information expect legal cyclone 
accesses callers hold appropriate lock shared 
lock needed call long plk lock function spawns thread function lock lk pointer 
threads increment lk mediates access 
thread local safe pass nonlock 
just call 
multithreading types key extension cyclone type system lock names exception type level variables describe run time locks 
lock names exist run time 
lock type lock lock name 
key void lu int void lu lock plk int sync plk struct lkint ls lock plk int void lu struct lkint lkint plk lk ptr lk ptr void lk newlock int new int loc new struct lkint loc new lkint plk lk spawn sizeof struct lkint lk nonlock example correct multithreaded cyclone program restriction include lock names pointer types example int 
allow dereferencing pointer type type checker ensure thread holds lock type lock 
absence data races relies lock existing 
thread local data fits system having special lock name loc 
give nonlock type lock loc annotate pointers thread local data loc 
allow dereferencing pointers reachable argument spawn 
type variables lock names loc scope 
introduce lock names universal quantification existential quantification type constructors capture important idioms 
functions universally quantify lock names callers pass pointers different lock names 
example type information omitted including annotations unnecessary due defaults 
instantiate functions lock name 
section explains kind annotations ls lu 
instantiation implicit 
examples instantiates type second instantiates loc 
function type effect set lock names written parameters callers hold 
example function empty effect really means loc effects key enforcing locking discipline program point assigned effect current capability 
function entry point function effect 
statement inherits effect enclosing statement sync type lock sync adds current capability type allow current capability 
similarly function call type checks current capability instantiation superset callee effect 
example call type checks caller holds necessary lock 
type newlock ls lock exists lock name lock name 
usual unpack value existential type 
declaration lk newlock unpack 
introduces variable lk lock name 
scope rest code block 
lk bound new lock type lock 
unpack lock multiple times names acquiring lock term type lock permit dereferencing pointers lock name 
existentials important user defined types 
type struct lkint example pointer lock name lock plk 
name existentially bound type definition 
newlock struct lkint value requires unpack pattern form binds lk plk giving lk type lock ptr giving ptr type int 
form struct lkint value fields types consistent respect implicit instantiation 
noted earlier existential types example need mutual exclusion 
suppose threads share location type struct lkint 
thread mutate struct assigning different struct lkint value hold different lock 
mutation safe thread uses shared struct mutation point plk changed 
type definitions lock name parameters 
example list int values struct lst lu lu int hd struct lst tl defines type constructor applied lock names produces type 
thread local data struct lst loc loc choice 
universal quantification functions lists operate thread local data 
different locking idioms 
example prototypes int length lu lu struct lst int sum lu lu struct lst int sum lu lu struct lst lock void append lu lu lu struct lst struct lst length suppose computes list length caller acquires lock list spine length access list elements 
caller locks idiom sum sum uses hybrid idiom caller acquires elements lock sum presumably acquires spine lock 
suppose append mutates argument appending copy second argument spine 
lists different lock names spines precisely append copies second spine 
length elements accessed 
multithreading kinds familiar typing technologies ameliorate restrictions lock names impose 
techniques apply naturally treat lock names types describe locks values 
kinds distinguish ordinary types lock names 
sense lock names kind types kind kinds sharable possibly unsharable 
lock name lock newlock creates kind ls loc kind lu 
kind ls lu lock name kind lu 
subsumption check calls lk ptr lk example 
prevent thread local data reachable argument passed spawn memory kinds 
example kind kind kind ls 
general type kind contain kind lu 
expected au 
bit polymorphism give spawn type void spawn lu void loc sizeof kinding ensures shared data uses locking 
effect new threads hold locks 
effect spawn copies second argument points 
section explains value type sizeof sizeof type system ensures callers pass correct size 
example instantiate spawn type struct lkint type existentially bound lock name definition kind ls 
term lkint plk nonlock ill formed nonlock type lock loc struct lkint requires lock name kind ls 
default annotations type system far requires lock name pointer type lock type effect function 
extend simple techniques omitted type information vast majority annotations optional 
function effect omitted implicitly includes lock names appearing parameters types 
default idiom caller locks second lock names optional 
filled depends context function bodies unification engine infer lock names 
type definitions loc 
function parameter return types generate fresh lock names include default effects 
discuss options lock names generate 
top level functions implicitly universally quantify free lock names 
third default sharability kinds inference remains intraprocedural 
techniques fill defaults function bodies 
maintain separate compilation 
different strategies generating omitted lock names function prototypes different benefits 
generate different lock name unannotated pointer type 
strategy function calls type check 
prototype explicit locking annotations function body type check returns parameter assigns parameter local variable hold different parameters similar problems chapter region subtyping give region annotations local variables 
second exploit region annotations prototype lock name pointer types explicit region name 
refinement strategy takes care function bodies things return parameters 
suffice bodies region subtyping lock names enjoy subtyping 
furthermore callers pass objects region guarded different locks 
third just loc omitted lock names 
solution advantage single threaded programs type check multithreaded programs global variables 
section discusses global variables require locks 
means programmers extra annotations write code safe multithreading callers acquire locks 
strategies useful cyclone support convenient syntax 
possibility pragma changes strategy pragmas change meaning prototypes programs difficult humans understand 
similar argument pragma default region annotation prototypes 
example second strategy techniques allow abbreviated prototypes void int void lock plk int struct lkint ls lock plk int void struct lkint void lock names variables optional 
interaction type variables resolve issues type variables multithreaded cyclone 
prevent thread local data data guarded loc thread shared 

extend effects ensure polymorphic code uses proper synchronization 
sketched solution issue previous section type kind includes sharability addition versus sharability means type describe thread local data 
actual definition inductive type syntax sharability means part type kind bu au lu 
combining parts type kind richer types bs bu au bs bu au bs au ls lu 
sharability necessary spawn code uses sharability extend effects consider function app calls parameter parameter type effect effect describe effect know takes 
give app effect app unusable thread shared data assume holds locks caller passes acquire 
solution introduces locks new form effect represents effect consisting lock names type variables occurring 
write polymorphic app function void app bu void locks locks instantiate int effect means call app hold locks int 
example polymorphic function calls app current capability include locks 
including locks effect function type universally quantifies describes caller locks idiom 
described section idiom want programmers omit explicit effects 
default effect polymorphic function includes locks type parameters 
app example omit effects 
fact making short hand bu au polymorphism poses problem type checking single threaded code multithreaded code 
write polymorphic code callee locks idiom wrong example void app bu lu void locks lock lk sync lk want call app locks held acquires lk calling expresses connection capability app calls locks effect 
solution enriches function preconditions constraints form effects 
chapter constraint means current capability sound include current capability example write void app bu lu void locks lock lk locks sync lk call current capability constraint cover effect locks omit 
callers app establish constraint instantiating respectively know locks locks 
support instantiating needs caller held locks sophisticated type void app bu lu au void lock lk locks locks locks summary polymorphism compelled add way describe lock names unknown type locks way constrain lock names locks 
features express locks thread hold value unknown type 
choice default effect programmers usually ignore additions 
needed polymorphic code callee locks idioms 
dually show example need existential types caller locks idioms 
interaction regions far described multithreaded cyclone data deallocated 
garbage collection maintain illusion region system chapter gives programmers finer control 
section describe region system analogous locking system combining systems allows threads share data 
comparing locks regions correspondence static type systems regions locking striking fascinating 
singleton types locks handles type variables different kinds decorating pointer types locks regions describing requirements types sync region gaining access rights loc available resources constraints revealing partial information types 
compelling reasons depth analogy 
accessing memory safely requires appropriate region live appropriate lock held 
type variables pointer type annotations effects capture aspects access rights way safe dereference pointer type current capability includes 
level type system oblivious fact names region names lock notion access rights 
systems constructs amplifying rights region sync increase current capability lexically scoped statement 
lexical scope simplifies rules determining current capability essential 
differences region locking systems products natural distinction region allocated deallocated lock acquired released multiple times 
little reason separate region creation right access region 
hand locking system separates newlock sync 
region lifetime orderings induce natural notion subtyping region construct introduces compile time constraint 
acquire locks multiple times locking system subtyping 
put way regions fixed ordering locks allow programs form sync lk sync lk sync lk sync lk 
known techniques preventing deadlock impose partial order locks 
complicated kind system locks arises difference loc safe access memory guarded 
restrictions loc describe thread local data 
restricted example prevent space leaks garbage collector kind system regions sophisticated 
combining locks regions basic constructs regions locking compose pointer types carry region names lock names 
accessing memory requires region live lock held 
continuing earlier example app type void app void regions locks regions locks combining rules default annotations suffices write void app void interesting interaction ensuring thread access region thread deallocates 
impose stricter type spawn 
prevent spawned thread accessing memory spawning thread deallocates region bound ensure shared data reach heap spawn recall uses quantify type second argument points add precondition regions solution sound thread shared data heap 
add expressiveness introduce construct 
type check spawn quantify region name change precondition regions require type region 
words new argument handle indicating shared value region bound 
way share stack pointer threads 
doing safely impose overhead local variables cyclone programmers expect fast 
handle call corresponding region live spawning thread deallocated spawned thread terminates 
section explains run time system maintains invariant 
remaining complication subtyping section explains cyclone allows casting long outlives 
means deallocate region named threads spawned handle terminated 
dynamic region run time system support added complication efficiently stack region 
prevent casting stack pointers dynamic region pointers calls enrich region kinds kinds sharability definitely sharable rs rd ru 
stack region name kind rd programmer chooses rs ru dynamic region name 
region name describes live region point region named created introduce kind rd kind rs 
handle passed region name kind rs 
single threaded programs choose rd dynamic region names 
run time support run time support cyclone basic thread operations simple 
garbage collection heap region collector course support multithreading 
newlock sync spawn operations easy translate operations common thread packages posix threads 
translate nonlock distinguished value sync checks trying acquire lock 
cost check small check required reentrant locks 
add kind ld describe loc kind omit checks nonlock complication unnecessary 
non local control jumps return statements exceptions minor complication thread release lock sync acquired control transfers outside scope sync 
jumps return statements compiler insert correct lock releases checks nonlock 
exceptions maintain thread run time list locks acquired installing exception handler 
interesting run time support implementation deallocate region thread done 
necessary information dynamic region handle contains list live threads including thread created 
thread list live dynamic region handles created 
list sorted lifetime 
lists internally thread shared run time system uses locks mediating access 
maintain lists follows 
starting spawned thread add handle thread list 
spawned thread terminates remove handle thread list 
handle thread list empty handle youngest handle list deallocate region remove handle handle list recur older handle handle list 

region executing create region add handle young thread handle list add executing thread handle thread list 
control leaves remove executing thread handle thread list 
handle thread list empty handle youngest handle list deallocate region remove handle handle list 
dynamic regions thread creates continue lifetimes 
stack regions deallocated dynamic regions created restrict region subtyping 
note lists doubly linked add amortized cost region 
evaluation section informally evaluates strengths weaknesses cyclone support multithreading 
strengths mentioned useful summarize 
weaknesses analogous region system weaknesses amount lack support sound synchronization idioms lock mutual exclusion 
news data races compromise cyclone safety type system prevents 
race prevention static hurt run time performance 
importantly multithreaded programs read write memory locations just single threaded programs 
alternative safe design generate code memory access acquired lock performed access released lock 
performance suffer optimizations reduce number lock operations programmers control 
way describe cyclone sync operation effect system say programmers optimizations hoisting lock acquisitions assigning locks memory locations 
type system prevents errors disallows safe optimizations 
explicit function effects keep analysis intraprocedural allowing callee locks hybrid idioms 
caller locks idioms produce simplest efficient single threaded code fewer lock acquisitions lock passing default effects encode idiom 
decision means functions acquire locks passed invariably need explicit effects 
type check default effect called contexts deadlock 
locks reentrant deadlock acquiring locks useless 
notion thread local data supports special case memory location reachable thread creates 
race conditions memory impossible lock necessary 
multithreaded applications memory remains thread local cyclone aims impose little burden possible case 
solution default lock name loc 
function parameters solution burdensome fresh lock names implicit effect restricting functions usefulness 
function bodies intraprocedural inference require fewer annotations assuming loc 
design ensure requires annotations 
ultimately objective evaluation single threaded programs type check multithreaded code 
kind system remains simple kinds powerful give spawn cyclone type 
lets programmers write code thread local thread shared data 
thread local data common case default assume function parameters thread local 
kind annotations necessary terms reachable arguments spawn 
nonlock term simple trick allowing clients callee locks code thread local data 
explained detail thread system interacts smoothly parametric polymorphism region memory management 
small disadvantage sharable regions may outlive construct creates 
programmers desiring stronger memory reclamation assurances declare dynamic regions unsharable 
disadvantage run time system maintain region information synchronization 
expect run time system multithreaded language incur synchronization overhead 
bad news sound decidable type system cyclone data race prevention necessarily conservative forbidding race free programs 
describe limitations address 
thread shared data immutable mutated need locking 
expressing read invariant straightforward take const seriously qualifier polymorphism important code reuse 
similarly reader writer locks allow mutation concurrent read access 
annotating pointer types read write locks pose technical problems 
short type system assumes read thread shared data requires exclusive access immutability reader writer locks safe alternatives 
global variables thread shared require lock name annotations 
means need locks lock names global scope 
worse single threaded programs global variables type check multithreaded programs need lock names 
note thread local variables thread wide scope problem 
oftentimes thread shared data initialization phase thread shared 
phase locking unnecessary 
simple flow analysis probably suffice allow access locking long object shared 
support trivial common case allocating initializing data new guarded necessary hold 
incorporating flow analysis obtains flexibility chapter provides initialization 
data objects migrate threads needing locking 
example producer consumer pattern producer thread puts objects shared queue consumer thread removes 
producer objects enqueuing objects need locks 
idiom safe restricted aliasing producer retained object type system ill equipped support 
analogy memory management continues safe call free precisely subsequent computation retained 
technology suitable supporting safe uses free suitable supporting object migration 
related permits object migration generally distinguish unique pointers type system ensures pointers object point 
synchronization mechanisms mutual exclusion locks prove useful 
examples include semaphores signals 
important expose implementation details lock spin lock 
general cyclone support mechanisms designed threads library posix threads provides 
libraries require changing language compiler enforce clients libraries safely 
thread system limitations region system limitations may onerous practice 
example locks held execution corresponds lexical scope 
way callee release lock caller acquires reduce parallelism threads blocked callee acquire locks caller releases allow flexible library interfaces 
java restriction encountered substantial criticism design decision 
type system suffers lack principal typing chapter describes 
possible solutions analogous 
example pointer types carry effects 
dereferencing pointers require current capability implied entire effect 
shortcomings deserve brief mention 
annotation burden reusable type constructors increases threads 
ameliorate problem support type level variables stood region name lock name 
write abstracted region lock 
similar combination prove useful term level regions objects region lock allow region handle serve lock 
separating regions locks powerful merging convenient 
second type system support guarding different fields struct different locks 
analogy regions breaks sense different fields struct different lifetimes 
main problem supporting different locks different fields annotate pointer types 
third types struct foo need explicit sharability annotations assume unsharable 
problem pronounced type constructors struct bar explicit annotation mean application type constructor sharable arguments sharable 
essentially need leak implementation unsharable fields uses loc 
chapter problem hidden uses restrict client type 
bears repeating prevent deadlock type system compatible reentrant locks help bit 
deadlock undesirable violate type safety 
formalism section defines formal machine type system capture cyclone support multithreading 
formalism formalisms earlier chapters supports claim similar techniques prevent different safety violations 
focus chapter machine differs earlier ones summary essential differences 
compensate complications threads introduce simplifications 
integrate memory management objects live forever chapter 
forbid quantification types unknown size chapter 
allow left expression possible take address field assign part aggregate object 
holds pair easy simulate assigning field 
second machine state includes multiple threads 
thread scheduling nondeterministic thread capable step 
thread comprises statement control set locks currently holds 
machine set available locks held thread single shared heap 
type safety proof uses type system partitions heap thread local portions thread thread shared portion divided distinguish portions guarded locks held different threads 
partitioning purely proof technique 
machine flat heap run time information ascribing locks locations 
contrast chapter regions existed run time 
third assignment takes steps holds expression step 
thread reads junk value stuck dynamic semantics allow 
type system prevents data races reading junk impossible 
fourth kind system includes reasons explained earlier chapter 
formalism include regions include definitely sharable sharability 
despite striking similarities constructs regions chapter locks chapter creation locks scope lock names different 
chapter statements created locations regions included binding occurrence region name scope subsequent statement 
chapter statements create locations include bound occurrence lock name scope course 
similarly sync statement acquires lock exists 
discussion section differences exactly expect 
kinds effects constraints types int lock loc terms return open sync release spawn call pack nonlock newlock lock values pack nonlock lock heaps locks threads states tn contexts syntax chapter formal syntax presents language syntax 
focus constructs relevant multithreading 
kinds include distinguishing types known size types unknown size lock names 
kinds include sharability indicates part type describes thread local data 
source programs type variables loc kinds form 
particular loc kind lu 
run time name actual locks integers 
describe lock lock name kind ls 
term lock programs refer lock type lock lock kind 
know type kind ls lu write remind 
effects constraints exactly chapter represent lock sets inequalities regions sets outlives relationships 
particular way hold constraints useful type variables 
chapter implicitly identify effects set equality including associativity commutativity idempotence 
expected quantified types introduce constraints function types include explicit effects types pointers locks include lock names 
statement forms just earlier chapters 
open forms specify lock name guards location statements allocate 
lock name scope 
access requires current capability constraints imply executing thread holds 
term sync evaluates lock acquires lock potentially remaining stuck thread releases lock executes releases lock 
remember lock release sync lock evaluates release provided available 
statement form spawn evaluates function value creates new thread evaluate function called value 
actual cyclone require size passed value known 
version spawn implementable function simpler 
novel expression forms include nonlock thread local data newlock creating fresh lock lock form inappropriate source programs describes lock 
form junk inappropriate source programs 
machine uses mutating heap location include machine knows value written thread performing mutation takes step 
lock set implicitly 
region sets chapter lock sets encode orderings locks outlives relationship 
thread takes step modify lock sets set locks program created set locks held thread set locks held thread 
form sets unimportant abbreviate thread holds exactly locks executes program state tn includes set created locks set available locks heap threads 
explicit redundant union lock sets thread technically convenient maintain separately 
final technical considerations analogous similar ones chapter type context includes set created locks empty source programs kinds type variables types lock names term variables current capability collection assumed constraints 
write cl respectively 
heaps implicitly chapter contexts 
juxtaposition hh union maps assume disjoint domains 
write mean li si li si tn tn dp li si li si tn tn dp tj return tk tn tn chapter dynamic semantics programs dynamic semantics dp rules rewriting nondeterministic allow thread take step defined rules describe 
rule dp thread takes step spawn new thread 
rule dp thread spawns new thread takes step 
rule dp clean rule remove terminated threads hold locks 
necessary type safety 
thread create new lock acquire release lock change shared heap create new thread 
single thread evaluation rules fig ure form lh sopt meaning thread lh changing heap set created locks set available locks 
sopt thread spawned sopt new thread 
starts threads held 
mention interesting aspects statement rewriting rules 
rule ds allocates initializes fresh heap location 
spirit machine require steps initialize location immediate initialization simpler need prove fresh locations accessed synchronization 
see discussion initialization section rule ds encodes fact acquiring nonlock run time effect ds applies necessary lock available 
conversely rules ds ds appropriate lock available 
rule ds rule creates new thread 
spawned thread starts statement return 
evaluation rules right expressions left expressions 
simpler previous chapters allow form interesting rules dr dr dr 
steps mutation takes 
result dr ds dom ds ds return return ds ds ds open pack ds lh sync lock lh release ds sync nonlock ds lh release lh ds lh return release lh return ds spawn return ds sopt sopt return sopt return sopt sopt open sopt open sync sopt sync spawn sopt spawn spawn sopt spawn ds sopt sopt release sopt release ds chapter dynamic semantics statements dr junk junk dr dr dr vi call dr call return dr lh newlock lh pack lock ls lock dr dr dr sopt call sopt call dr sopt sopt sopt dr sopt sopt sopt sopt sopt pack sopt pack sopt sopt sopt sopt dr dl sopt sopt dl chapter dynamic semantics expressions constraint locks locks locks locks type locks locks locks int locks locks locks locks locks locks locks locks locks locks locks locks locks locks lock locks locks loc notes omit formal definition substitution identical chapter definition 
changes locks effect lock lock loc loc 
chapter dynamic semantics type substitution state dr applies machine evaluate threads inbetween 
note dr apply location holds 
relaxed rule way write write data race go undetected 
precondition type safety theorem section precludes write write races implies thread stuck holds 
rule dr creates new lock 
uses ensure new lock uniquely identified 
result existential package type newlock 
rules ds dr substitution eliminate type variables 
describes definition substitution 
interesting part replacing locks effects substituting 
definition locks free lock names omitting loc just regions chapter free region names 
locks lock 
need hold lock acquire fact hold choosing locks lock locks sensible choice 
definition locks introduce free type variables safe 
straightforward check types essential run time effect 
prove type erasure result expect doing straightforward 
static semantics valid source program statement leading program state form type checks empty context styp terminate returning ret contain release statements srel contain junk expressions jf 
judgments similar chapter 
interdependent judgments define type checking statements right expressions figures 
expressions access memory type check current capability constraints establish thread holds lock guards location location thread local 
judgments acc eff eff ensure threads hold necessary locks access memory call functions eliminate universal types introduce existential types 
judgments define various properties type level kind judgments ensure types correct kinds level constructs 
wf free type variables 
kinding subsumption rule sk defines 
shr loc judgments help partition heap type shared local portions 
shr location sharable type lock name sharable kind 
loc location sharable 
assuming wf unique shr loc 
programs relax ban release statements junk expressions 
judgments srel erel spop epop chapter 
specifically srel ensures releases locks releases lock need hold lock lock released 
judgments formalize intuition junk appear thread process mutating heap location 
specifically junk free junk junk free junk free active redex junk judgments type check heaps program states 
htyp ensures heap values appropriate types consistent assumptions locks guard locations 
hlk partition heap locks different threads hold 
prog partitions heap appropriately ensures entire state formed 
specifically describe exactly locks available held thread lock sets share elements 
heap divide shared heap hs thread local heaps 

shared heap closed typed 
thread local heaps typed may refer wf dom wf wf wf wf wf sk int bs wf sk wf wf wf wf sk sk sk dom sk ls loc lu au au wf lock wf dom wf loc shr wf au lu wf wf wf wf wf shr ls shr loc loc loc ls loc chapter kinding formedness context sharability acc loc eff acc eff acc eff eff eff eff eff eff eff eff eff eff eff eff eff eff chapter effect constraint containment rtyp styp ss rtyp styp return ss styp styp styp ss rtyp int styp ss styp rtyp int styp styp styp rtyp styp dom styp ss ss rtyp dom dom styp lu au styp open ss rtyp lock locks styp styp sync styp styp release ss ss rtyp rtyp cl styp spawn chapter typing statements ss wf ltyp sl rtyp ltyp sl acc wf rtyp rtyp rtyp sr ltyp rtyp sr sr rtyp rtyp rtyp acc sr rtyp sr wf rtyp int sr rtyp rtyp sr rtyp ltyp rtyp acc rtyp sr rtyp rtyp eff rtyp rtyp cl eff rtyp sr styp ret rtyp call sr sr rtyp cl eff cl au rtyp pack styp ret dom shr wf wf rtyp rtyp wf au rtyp cl wf rtyp lock lock sr wf rtyp nonlock lock loc sr sr rtyp rtyp junk sr sr sr wf rtyp newlock ls lock sr chapter typing expressions ret return ret ret ret ret ret ret release ret ret ret open ret sync chapter return srel srel release srel srel srel erel srel srel srel erel erel srel erel srel srel srel open srel sync erel erel erel lock erel nonlock erel newlock srel erel erel srel srel return erel erel erel erel erel erel erel pack erel erel erel erel srel spawn erel erel erel erel erel srel erel call erel erel srel spawn erel erel erel erel erel erel junk chapter typing release js js release js jf js je jf jf js je js js return jf je junk js je call jf jf je jf js js open js sync je je je je je je je pack jf je jf je je je jf jf je jf js spawn jf je js spawn jf je je je jf je note omit formal definition jf respectively jf jf means term respectively form junk chapter typing junk htyp htyp rtyp erel htyp hlk ln hs sh hlk hlk htyp hs shr hlk jf iu htyp iu loc iu li hlk iu styp si ret si li srel si si prog ln sn chapter typing states locations hs 
divide hs sh holds locations guarded available locks hold locations guarded locks thread holds 
structure heap statement si type check threads local heaps return release exactly locks li junk free possibly mutating location 
having described structure type system highlight interesting rules 
kinding rules loc encode essence thread locality 
kinding rule pair types require sharability components loss expressiveness 
allow quantified types kinds form useful 
function types sharable 
decision requires forbid functions refer unsharable free variables see sr 
actual cyclone restriction simple free variables refer functions immutable global variables 
simpler restriction formalism require functions free variables impossible mutable encode recursive functions 
definition loc bit uses absence kinding derivation 
rigorous approach include definitely unsharable sharability adjust kinding rules accordingly sharability loc 
rules effect constraint containment exactly chapter acc loc 
turning typing rules ss ss amplify current capability expected 
locks effects include loc type lock loc 
rule ss spawned function effect threads holding locks 
function argument sharable spawned spawning threads access 
actual cyclone allow sharable type argument 
rule sr complicated shr allow free sharable locations 
rule sr simple typing judgments restrict junk occur 
rules sr sr give types expect 
particular newlock type existential package evaluates 
turning js je establish term evaluation step rewrite junk rule junk note je type safety appendix proves result definition 
program tn badly stuck badly stuck thread 
badly stuck thread thread return sopt sopt theorem type safety 
styp ret junk free release statements reflexive transitive closure badly stuck 
theorem ways stronger ways weaker theorems earlier chapters 
stronger establishes thread sound just thread badly stuck 
weaker type system allows deadlock 
thread stuck lock unavailable 
fact entire machine stuck threads waiting locks 
definition thread badly stuck long take step additional lock available 
definition includes threads need unavailable lock 
related synchronization idioms techniques detecting synchronization errors language support multithreading far numerous fully describe 
section focuses closely related improve cyclone multithreading 
cyclone system preventing data races similar line flanagan abadi began 
seminal publication singleton lock types lock type annotations mutable explicit effects called permissions function types prevent data races small formal language 
term level constructs correspond closely spawn sync newlock 
semantics prove programs data races race machine stuck 
allow universal existential quantification lock types ordinary types 
extend type system partial order prevents deadlock 
adapting object oriented languages flanagan abadi chose term level variables lock names type level variables 
change introduces limited form dependent type types mention terms 
avoiding type variables may palatable programmers introduces complications 
variables stand mutable locations language unsound contain lock 
type restricts type sufficiently saying type lock result sound mutation useless 
second rules type equivalence notion term equivalence 
determining terms evaluate lock trivially undecidable restrictive rules necessary 
programmer control restrictions cyclone approach flexible letting programmers gives compile time names locks independent locks stored accessed 
term variables affords flanagan abadi advantages 
java objects locks reusing term variables lock names economical 
second self variable java lock name better integrates system common notions object subtyping 
term equality takes self variables account 
example method result locked method self variable variable scope call site equivalent say result locked variable scope call site names object method invoked 
flanagan freund adapted ideas java implemented result number previously unknown synchronization errors 
java system provides type constructors classes parameterized locks support thread local data 
lock names final immutable term variables 
support thread local data class declaration indicate instances class thread shared 
classes thread shared classes mutable fields guarded locks fields holding thread local objects 
thread local class thread shared super class downcasts thread shared type thread local type including thread local class overriding methods declared thread shared class forbidden 
clear type system enforce data thread local 
focus minimizing explicit annotations finding potential data races appear race freedom proofs exist 
boyapati rinard developed similar system allows code reuse cyclone terms allowing loc instantiate lock name parameter 
object thread local thread shared depend class instantiation lock name parameters class 
result allows just code reuse cyclone analogue nonlock 
system supports extensions described section including object migration unique pointers pointers data aliased unsynchronized sharing immutable data 
safely support downcasts target type lock name parameters source type 
general object run time type information necessary check target type instantiates class correctly 
subsequent boyapati lee rinard extends system deadlock prevention 
resorts implicit run time type passing necessary support safe downcasts 
associated report explains avoid run time type passing common cases implement scheme unmodified java virtual machine 
boyapati systems accompanying formalisms type safety proofs 
guava java dialect static data race prevention 
class hierarchy rigid distinction thread local sharable objects 
allows synchronized access methods fields 
move operator soundly allows object migration 
race detection systems dynamic :10.1.1.11.3056
usual dynamic static approaches complementary different expressiveness performance convenience trade offs 
cyclone type safety needs data race prevention static approach feels appropriate 
easier implement change code generation 
cyclone system prove programs deterministic 
domains parallel numerical computations stronger guarantees help detect errors 
open systems operating systems servers determinism impossible 
preventing data races individual memory locations objects insufficient preventing application level races 
application may intend keep objects synchronized 
procedural abstraction controls access objects suffices relevant procedures appear atomic 
flanagan qadeer develop type system enforcing atomicity 
note underlying memory model ensures atomic access words functions atomic explicit synchronization 
static analyses find thread local data eliminate unnecessary locking java 
adapting interprocedural escape analyses cyclone reduce annotations complicate language definition 
safe languages low level applications described detail chapter allowed threads 
vault type system restricts aliases track stateful properties data compile time :10.1.1.14.7406
mechanisms termed adoption focus allow tracking state lexical scope knowing aliases data 
scoping technique relies crucially absence concurrent access 
ccured unmodified legacy applications compiled detect memory safety violations 
key performance program static analysis eliminate unnecessary run time checks 
analysis assumes program single threaded 
arbitrary thread interleavings expect conservative results 
run time checks thread safe 
making require expensive synchronization precise control thread scheduling 
system older unsound approach static race detection programs 
factors violate soundness 
analyzes programs simply assumes memory safe 
second uses mutable variables lock names 
wrongly conclude program race free threads acquire lock reading lock changed acquisitions 
bug finding tool unsoundness may programs rarely sort mistake 
am aware combines multithreading safe memory management real time specification java 
described chapter java extension regions lexically scoped lifetimes attempting create older region younger run time error 
cyclone thread oldest region appear thread stack regions 
region deallocated thread done 
words cyclone real time java support thread shared regions way 
real time java type system notion lifetime regions cause complications cyclone lead subtyping restrictions 
chapter uninitialized memory null pointers chapter describes cyclone prevents reading uninitialized memory dereferencing null pointers 
allowing operations easily compromise safety 
allocating memory pointer int cyclone specify initial value practice implementations leave value memory contained previously possibly arbitrary int 
dereferencing null pointer unspecified behavior 
implementations implement null null type struct expect write address corresponding size fields preceding 
size may large may suffice low addresses inaccessible 
insert check null raise exception performance reliability encourage elimination redundant checks 
simplicity chapter usually assumes implementation insert implicit checks programs dereference null pointers rejected compile time 
solve problems techniques differ substantially solve problems earlier chapters 
types regions locks solutions relied invariance object lifetime require type region lock 
safe programs maintain invariants restrictions reasonable help undecidable problems tractable 
problems chapter invariance restrictive 
amounts requiring immediate initialization forbidding declarations omit initializers hurt performance porting code difficult 
pointers sensible enforce null invariant cyclone provides option 
idioms linked lists null 
possibly null pointer allow programs test run time null dereference 
problems warrant solutions determine program point specific flow sensitive information 
variable possibly uninitialized point initialized assignment 
variable possibly null point assumed null appropriate test subject caveats due aliasing 
chapter develops sound intraprocedural flow analysis 
flow analysis modern language implementations section describes novel issues arise cyclone particularly specified evaluation order pointers uninitialized data 
section presents analysis informally focusing interprets code transforming state 
section evaluates approach describes sophisticated examples 
section defines formal machine declarative type theoretic formulation flow analysis 
precision valuable sophistication analysis connection declarative formulation analysis algorithm remains informal 
machine dynamic semantics soundness proven appendix implies typed programs attempt dereference null pointers destruct junk values result reading uninitialized memory 
section discusses related source level flow analysis 
background contributions simple dataflow analysis approximates local variables initialized null straightforward application known techniques 
important issues complicate analysis cyclone analysis general purpose source language part language definition inappropriate define analysis terms simplified intermediate representation 
analysis language specified evaluation order 
analysis reasons pointers particular locations including uninitialized ones 
analysis language exceptions exception handlers increases number possible control transfers 
analysis reasons struct fields separately 
doing significantly complicates implementation turns orthogonal interesting issue 
section describes simple flow analysis background introduce cyclone terminology 
purposely 
sections describe problems surrounding pointers evaluation order respectively 
solutions section important technical aspects 
basic analysis intraprocedural dataflow analysis assign local variable value call rvalue reasons explained section program point function body 
null pointers initialization domain rvalues sense possibly uninitialized variable initialized variable may null initialized variable definitely null initialized variable definitely null domain forms lattice means approximate 
partial order reflexive transitive closure relation holding 
map variables rvalues state 
interpret statements transforming states 
example state program point assignment maps state assignment maps 
declaring variable extends state mapping 
statements analysis fail map maps 
tests refine state 
example maps map 
program point state approximate state control flow predecessors 
example branch conditional statement maps branch maps state conditional map 
control flow cycles loops require analysis iterate compute states program point control flow predecessors prior analyzing statement program point 
example state loop loop body loop state loop approximating state done 
analysis terminates infinite sequence states element strictly approximate previous 
giving appropriate meaning statement just sketched analysis fail know executing function dereference null pointer uninitialized memory 
reasoning pointers description ignored analysis code creates initializes uses non null pointers 
maps say transforms state maps ignores fact create alias 
example code safe void int int null solution involves making worst case assumptions variables address taken 
analysis enrich states information track unknown aliases memory location exist 
example conservatism unnecessary program point analysis determine exactly aliases fact tracking aliases appears crucial supporting malloc principled way 
consider simple safe example void int int malloc sizeof int assignment point uninitialized memory 
accessing unsafe assignment rvalues far ill equipped analyze code malloc 
assignment safe choice choice renders malloc useless rejecting ensuing assignment solution adds rvalues describing points named locations 
solution significantly complicates notion state approximating 
leads powerful system conventional flow analyses preventing safety violations 
intraprocedural analysis limited alias information ill suited track properties large data structures lists 
safety suffices require data initialized rvalue 
data structure invariant data null solution check exploit invariant 
enrich type system types form describe null pointers 
section explains types interact rvalues 
summary analysis adds information points information interaction null types 
additions add significant expressiveness 
example section presents code create circular lists type struct int val struct prev struct safe languages way create circular data structures invariants 
evaluation order cyclone fully specify order evaluation expressions assume evaluates 
flexibility complicates defining sound flow analysis 
example reject null 
section defines variations problem different solutions section different variations 
example variations consider null safe expression 
lenient actual semantics require order called sequence points 
example 
legitimate evaluation orders 
evaluating inner function call various times respect 
certain expressions restrict evaluation order 
example comma operator ensures executed 
remain legitimate evaluation orders 
matters worse forbids expressions nondeterministic evaluation order 
specifically read write writes location separated sequence point program illegal result implementation dependent read determine value write 
cases standards compliant implementation perform arbitrary computation 
safer alternative ordering semantics allow evaluation orders deem reads writes writes location sequence points illegal 
put way implementation actual semantics assume lack aliasing may hold 
execute expressions correctly order evaluation remains lenient 
alternative section formalizes formalism sequence points expressions 
lenient alternative permutation semantics function call en implementation execute expressions order execute part part 
similarly assignment statements operators addition allow left right left 
semantics rule languages scheme ocaml problem worth investigating 
eliminate issue entirely deterministic semantics java define language expressions function calls evaluate subexpressions left right fixed order 
lenient approach enforce purity semantics forbidding expressions write memory 
making assignments statements expressions insufficient function call include assignment statements mutate caller local variables passed pointers 
general lenient approaches transfer obligation proving optimizations safe programmer implementation 
examples fixing evaluation order increase register pressure allowing writes aliased locations restrict instruction selection 
conventional compilers perform optimizations compiler chosen evaluation order issues cleanly separated 
actual cyclone implementation compiler produces code invokes compiler 
cyclone preserve safety target language fixed evaluation order 
technically incorrect implementation assumes ordering semantics analysis section presents essential aspects cyclone flow analysis 
description states explaining capture points information null invariants 
explain analysis expressions key ideas null types problems 
explain analysis statements focusing join states tests refine information 
delay description relevant language features aggregates recursive types goto exceptions 
states state maps location type rvalue 
locations allocation sites include local variables occurrences malloc 
dangling pointers concern think malloc declaring local variable evaluating address 
just distinct variable malloc occurrence 
consider types form int type describe null 
esc escaped unesc unescaped means aliases location may known exactly 
example state program point flip null consider escaped 
rvalues location 
explained form previously 
rvalue describes values point location produced allocation site pointer information inherent part domain 
location allocated unesc rvalue type provided programmer malloc 
location escaped difficult analysis track contents soundly known assignment statements mutate 
state ill formed escaped location rvalue appropriate escaped locations type 
particular type case 
analysis fails formed state describes program point 
example rejects void int int function safe escaped uninitialized wellformed state suffices 
states need appropriate definition written domains map location type allocation sites types invariant 
require map approximate unesc esc approximate rvalue 
addition approximations section add considers escaped 
approximation forgets alias defined imply formed formed 
section statements describes join operation fails produces formed approximation formed states 
expressions previous chapters analyze left expressions right expressions differently 
case state expression produce state describing expression transforms input state due effects assignments 
right expressions produce rvalue describing expression result 
left expressions produce lvalue location representing unknown location 
describe interesting cases discussing evaluation order complications 
left expressions consider form right expression 
produces lvalue change state 
analyze produce rvalue state result 
lvalue know location 
lvalue fail dereference null uninitialized pointer 
analysis right expressions similar 
example null abstractly evaluates transform state 
variable look rvalue state 
resulting rvalue depending analysis left expression function call fails argument rvalue 
analysis right expression interesting resulting rvalue depend type rvalue look rvalue context 
type giving rvalue giving rvalue suffices analysis fails 
conclude know initialized 
uninitialized fail 
result 
interesting case assignment 
abstractly evaluates location unescaped change rvalue resulting rvalue 
lvalue escaped rvalue correct type 
note rule lets escaped type type abstractly evaluates 
descriptions function calls assignments ignored underspecified evaluation order 
example unsound analyze null assuming left right evaluation state analyze permissive 
discuss alternatives determine soundness various semantics defined section 
determinization easy translate cyclone way gives deterministic semantics left right 
translation introduce local variables hold temporary results 
example int int 
particular example original expression safe actual semantics necessary introduce local variables define cyclone deterministic semantics 
obvious advantage code problems specified evaluation order irrelevant 
languages continue lenient semantics resort determinization investigate options 
target language maintaining deterministic semantics lead longer compile times slower generated code 
effects may tolerable practice 
exhaustive enumeration simple way analyze expression soundly analyze possible evaluation order ensure safe take join resulting typing context rvalue produce result 
approach computationally intractable 
example permutation semantics analyzing function call arguments requires 
permutations 
furthermore arguments may suffer combinatorial explosion manifest outer context 
checks 
ordering semantics possibilities exist 
approach insufficient actual semantics ill defined programs infinite number possible evaluations 
compiler heuristics achieve precision combinatorial approach practice suffering intolerable compile times 
example expressions huge numbers potential evaluation orders probably pure sense approach 
purity expression write memory evaluation order affects safety expression result 
ignoring function calls prohibiting writes expressions specified evaluation order probably reasonable 
prevent common idioms including 
actual semantics need prohibit writes 
suffices prohibit writes change state 
prohibiting writes restrictive requiring analysis expression function argument conclude state started 
explain approach 
furthermore useful allow expressions change typing context doing expressions may execute unsafe 
final approach changed sets addresses issue 
joins expression 
en suppose analyzed state produce produce 
join operation described analysis statements produce state strictly approximate iterate place resulting state 
keep iterating approximate states expression causes change procedure essentially analyzes expressions execute number times 
interpretation approximate exploiting fact expression executes exactly clearly sound permutation semantics obviously sound ordering semantics expressions sequence points comma operators 
words sound 
example consider expression null 
join approach conclude state rvalue 
ordering semantics code unsafe assign null just dereferencing 
permutation semantics code safe 
restore soundness options 
purity approach 
words type check expressions sequence points strictly appeared positions may execute interruption 
second try allow sequence expression change flow information expression invalidate change 
approach reject null allow 
approach describes soundly 
changed sets join approach purity approach way subexpression expression specified evaluation order affect typing context expression 
consider int initialize rvalue remain 
actual cyclone common result shortcoming unnecessary implicit checks null command line option programmers permit dereferencing possibly null pointers 
case implementation may insert implicit check null potentially raise exception 
flow analysis avoid inserting checks necessary 
example second assignment need check assuming unesc null assignment thrown exception 
practice code form quite common 
flow analysis avoid checking null earlier check appears specified evaluation order position 
small enhancement achieves necessary expressiveness iterate joins approach maintain changed set expression 
set unescaped locations expression changes rvalue 
location appears changed set safe rvalue corresponding expression executed 
change expressions changed location provided changed expression rvalue 
compared join approach purity approach enhancement acknowledges expressions execute incorporate effects resulting state 
changes final result state iterate reject expressions null 
statements analysis takes statement state approximating state control flow predecessors produces sound state point statement 
procedure completely conventional result result result result join results 
description see section interesting subroutines analysis test expressions computing joins 
test expressions conditionals loop guards safe approach analyze expression described previous section state produced result control flow successors 
approach refine state endeavor conservative possible 
specifically text expression unescaped rvalue analyze true successor example having rvalue false successor loop example having rvalue 
require test exactly refine states successors 
analysis robust certain syntactic equalities writing null null fortunately rvalues lvalues produced analysis right expressions left expressions provide exactly need test form rvalue act test syntactically simpler accounting effects simplifying away 
test form analysis left expressions give lvalue treat test just accounting effects 
techniques provide reasonable level support tests 
entire test rvalue analysis determines control flow compile time choose state impossible branch 
usual iterative analysis propagate explicit state approximates 
addition dubious value source programs simplifies iterative analysis natural analogous similar support java discussed section 
turn computing formed join formed states program point multiple control flow predecessors 
key issue locations may escape result join 
example unesc rvalue flip escaped conditional rvalue 
furthermore rvalue escaped afterward 
describe algorithm ensures properties 
input states domain type location 
compute preliminary rvalue follows rvalues inputs 
preliminary esc esc 


exactly 


furthermore put escaped set containing locations encounter producing preliminary escaped set modify preliminary state set empty remove unescaped change escaped 
rvalue fail produce sound formed result 
change rvalue correct escaped locations type 
old rvalue add escaped set 
process terminates time remove element escaped set change location unesc esc reduce set size 
result approximate step 
point escaped set escaped exactly need result formed 
note procedure soundly subsume cycle known pointers collection unknown initialized pointers 
extensions having described interesting features analysis consider complications lack thereof encountered extending analysis full cyclone language 
aggregate values allocation site struct type track field separately 
field struct type track fields inductively 
enrich rvalues aggregates 
example type struct int int allocating maps rvalue 
analysis produces analysis produces 
similarly information form 
alias aggregate escaped esc esc 
field escaped due state reflect 
notions extend point wise covariantly aggregates 
lvalues take form fn rvalues fn 
aggregate assignment allow struct type 
assignment part known unescaped location change part location rvalue 
appropriate rvalue escaped location struct type natural extension rules aggregates 
recursive types somewhat surprisingly recursive types require change analysis cause run forever 
essentially depth pointsto information state bound finite number allocation sites function 
creating data structure potentially unbounded size requires loop recursion reuse allocation site 
subtle property analysis state describes location allocation site produced 
prove property induction long iterative analysis runs 
intuition program point allocation site impossible state indicate rvalue analysis naturally loses ability track multiple locations allocation site creates 
section describes analysis works loop creates list 
analysis track cycles impossible recursive types 
prevents state having cycle points information 
cycle escapes join operation ensures entire cycle escape 
argued operation terminates 
goto unstructured control flow goto break continue poses little problem iterative flow analyses including 
state jump analysis analyze target jump state approximate 
jumps cause loops analysis may iterate 
usual implementation stores state jump target tracks iteration necessary 
exceptions integrating exceptions straightforward algorithm conservative exception occur 
cyclone statements form try catch case case pn sn 
expression throw transfers control si provided evaluates exception matches pi statement catches exception 
si executes exception occurs reasonable check conservative flow information 
check si state approximate state type check statement expression 
section explains java analysis just state 
function call executed terminate prematurely exception important analysis soundly approximates flow information exceptions thrown analysis intraprocedural 
key require location esc reachable argument function 
put way function argument checked assignment unknown location 
requiring esc analysis sound regardless function call throws exception 
type checking throw simple require safely evaluates initialized exception 
sound produce state explicit 
evaluation having informally defined analysis evaluate result qualitatively 
formalism argues analysis sound focus expressive admitting actual cyclone implementation lenient safe considering better just rely run time techniques initialization null pointers 
focus important idioms analysis permits section section 
sections sophisticated examples 
section describes extension supporting simple form interprocedural initialization 
reality actual cyclone implementation lenient chapter far suggested 
differences interesting technical perspective convenient programmers sacrificing safety 
require initializing numeric values 
junk bits leads unpredictable program behavior violate memory safety 
allow reading values previous uses memory number security implications 
main reason concession lack support arrays 
allows omitting initializer character buffer 
text manipulation programs extra pass buffer initialize hurt performance 
second sequence zeros appropriate type type non null components programmers calloc initialize memory type 
example calloc sizeof int creates initialized array length replacing int int illegal 
third compiler option allows dereferences possibly null pointers 
option compiler inserts implicit checks raising exception encountering null 
terms formalism allow rvalue 
unescaped dereference refine location rvalue just tests 
intuitively dereference raise exception null 
tempting allow checking null expression dereference 
analogy chapter allows point deallocated storage 
allowing expressions difficult impossible check null dereference occurs 
naively raise exception 
check null address operator 
run time solutions considering complexity flow analysis limitations worth asking cyclone simply initialize memory check null runtime 
implementation optimize away initializers checks provably unnecessary 
sacrificing programmer control compiletime error detection primary motivations dissertation gain simplicity 
implicit initialization cyclone difficult java precisely null types 
languages null implemented sequence zeros appropriate type 
trivial find initializer type known size 
cyclone possible invent initializers simple 
need create initialized memory type take address 
recursive types create initializers infinite size 
function types invent code 
function body raise exception example 
types part program knows type implementation provide initializer 
technique basically amounts having default constructors values types implicitly calling constructors run time 
supported idioms despite complexity analysis useful simple idioms separating allocation initialization memory 
example accepts code assuming int argue uninitialized local variables poor style 
requiring unused initializers just incorrect programs easier debug runtime errors predictable 
sound analysis better omit unnecessary initializers possible analysis proves initializer useless 
omitting initializer better describes program marginally efficient 
argue real problem distinction expressions statements 
languages write initializer computation statement function calls expression language weak 
restructuring code way amounts functional style programming 
commitment imperative features expanding language initializers trouble worth 
example straightforward malloc struct pr int int struct pr int int struct pr ans malloc sizeof struct pr ans ans return ans expect code example porting application uses heap allocated memory 
requires track fields separately points information 
resorting ad hoc restrictions memory initialized immediately created analysis naturally subsumes common case 
example uses null types void int int int illegal illegal body statement assign int subtype int safe treat value value 
flow information assignment notes contains 
statement assignments may occurred assignments illegal 
interesting example uses run time test determine pointer null 
int int return return refine value test function parameters initially unescaped 
function suitable auxiliary function programmers want dereference int pointers concern compile time assurances performance 
programmers desires compiler simply insert implicit checks memory dereference 
programmers safely avoid redundant checks example shows struct list hd struct list tl int length struct list lst int ans lst null lst lst tl ans return ans reading lst tl need check lst null control flow path dereference test lst null succeeded 
points information allows simple copies struct pr int int struct pr int int struct pr ans malloc sizeof struct pr int ans struct pr ans return ans point points information captures certain notions aliasing 
example ans points allocated memory ans points memory field initialization point field 
initializes field 
convoluted code may deserve specific support product uniform set rules subject syntactic peculiarities 
unsupported idioms section focuses conservatism arising aliasing path insensitivity lack interprocedural support importantly lack array support 
aliasing path insensitivity despite points information analysis treats pointers quite conservatively 
conservatism arises code void int null safe rejected reject program rvalue analysis reason precisely code safe similar examples aliasing void int int null null unsafe intervening function call problematic refer global variable 
possible know aliases local variable void int int int rejected uninitialized memory escapes analysis path insensitive flow information analyzing know exactly aliases analysis rejects program escapes initialized 
possibility allow escaped uninitialized data 
add rvalue express points uninitialized data known exactly points 
assigning initialized data change initialized 
cyclone implementation extension complexity worthwhile 
path insensitivity culprit local variables escaping 
assign unknown location know exactly points escapes 
pass function escapes analysis intraprocedural 
dereference possibly null pointer escaped location necessary copy pointer unescaped location test void int int null copying necessary intervening assignment escaped location compromise soundness 
making copy known idiom defensive programming encouraging analysis enforces 
path insensitivity introduces approximations causing locations escape sense described 
canonical example data correlation statements example int int int null return return safe rejected return possible dereferences null example analysis rejects statement null 
interprocedural idioms extension described section allow passing uninitialized data functions 
extension captures simplest safe idioms 
null pointers support interprocedural idioms letting subtype 
subtyping allow subtype polymorphism function parameter type operate data type 
preceding chapters provided parametric polymorphism features types region names lock names 
subtype polymorphism weaknesses example demonstrates int int null putc return polymorphism express return type null parameter 
equality lets callers assume result null parameter null 
adding polymorphism create uniform type system unclear feature necessary practice 
arrays shortcomings described far interesting ones technical point view serious limitations practice concern arrays 
short arrays initialized created array element value type 
allow delaying initialization pointers arrays initialized refer initialized arrays 
initialization palatable cyclone supports comprehensions example argument new initializer 
chapter explains types arrays pointers arrays include size array 
silly example creates arrays int int int int arr int arr arr int arr new return declarations create stack allocated arrays initialized comprehensions :10.1.1.117.695
body comprehension variable example bound index initialized second comprehension copies prefix arr arr 
comprehensions convenient initializers form en cyclone prohibits omitting array initializer 
common omit initializer loop complicated idiom initialize array 
common malloc create array analysis support 
example shows pointers arrays omit initializers 
extending flow analysis reason array indices useful understandable way difficult 
index expressions compiletime constants treat arrays just struct values need arrays language 
allowing slightly complicated index expressions uninitialized arrays difficult 
consider example int int conclude initialized need correct loop invariant 
specifically entering loop body elements 
initialized 
control flow path test expression loop invariant implies initialized 
automatic synthesis invariants loops requires analysis incorporate sound arithmetic 
dissertation investigate extensions 
resort comprehensions special language construct trivial ensure array initialized 
example iterative list copying consider code copying list 
syntax new list heap allocates struct list initializes hd tl fields respectively 
struct int hd struct tl struct copy struct struct result prev line null return null line result new list hd null line prev result line tl null tl line prev tl new list hd null line prev prev tl line line return result line example contrived 
polymorphic version part cyclone list library 
written cyclone support static detection dereferences 
analysis allows dereferences lines follow explicit tests null lines intervening assignments interestingly analysis allow dereferences prev lines inserting implicit checks 
describe iterative analysis reaches conservative 
allocation sites lines names respectively 
state typing context analyzing line maps hd tl prev result 
analyzing loop body time state line maps tl prev result 
maps hd tl 
iterate rvalues prev loop incomparable 
join states prev map 
doing requires fields escape tl maps joined state 
second iteration left hand side assignment line dereference null prev maps assigning unknown location 
similarly line right hand side evaluates contents unknown location 
prev tl type struct resulting rvalue 
assignment prev maps 
iterate consider dereferences prev potentially unsafe 
explained analysis rejects code 
code safe see analysis reject code suppose inserted function call result lines 
function prev tl line evaluate null result remove element list 
change allows analysis accept function struct copy struct struct result prev line null return null line result new list hd null line prev result line tl null tl line struct tmp new list hd null prev tl tmp line prev tmp line line return result line analysis difference right hand side line second iteration abstractly evaluates 
intuitively tmp eliminates implicit assumption escaped location mutated lines 
example cyclic lists struct type implement nonempty doubly linked cyclic lists integers list element points element struct int val struct prev struct prev fields null code traverses lists needs check null 
functions combining cyclic lists inserting new element cyclic list straightforward void append struct lst struct lst struct lst struct lst prev lst lst lst prev lst prev void insert struct lst int struct malloc sizeof struct val prev lst prev lst lst prev prev interesting function creates new single element list struct int struct ans malloc sizeof struct ans val ans prev ans ans ans return ans points information essential accepting function 
suppose rvalues include ans 
consider assignment ans prev 
remaining sound rvalue right hand side 
adding rvalue describing pointers partially initialized values help ans prev ans ans prev point value initialized prev field aliasing 
cyclic initialization problem fairly known ml community 
ml way create cyclic list defined 
necessary datatype prev fields possibly null order create initial cycle 
ml type system flow sensitivity fields check refer list elements 
alternative flow sensitive static checking special term form creating initializing cyclic data 
constructor functions intraprocedural analysis support idiom caller passes pointer uninitialized data callee initializes 
callee allow uninitialized 
furthermore assume initialized call 
implemented somewhat ad hoc extension cyclone support idiom 
idiom common unnecessary 
change return initialized object replace 
idiom different interprocedural assumptions calls require explicit annotation changes callee type 
attribute initializes indicates function initializes th parameter 
attribute parameters types form 
attribute changes analyze caller callee 
callee parameter initializes starts value fresh reachable control transfer caller return statement function return type void require rvalue 
level indirection necessary functions type check void int attribute initializes int new initialize correct memory caller appears sound allow rvalues form initialized parameters 
know initialized call 
reinitialization harmless 
unfortunately typing rules just described subtle unsoundness callee assumes parameter initializes points distinct memory 
chooses fresh variable name 
function initializes multiple arguments forbid callers passing location arguments 
general callee assumes unescaped enforce fact call site 
allow parameters 
fact require distinct unescaped locations 
support constructor functions limited 
support idiom callee return value indicating initialized parameter 
limitation callers pass null initialized parameters indicate want value 
supporting idiom require rvalue indicating null furthermore unclear express state returning caller 
formalism section develops machine uninitialized data dereferences machine stuck 
static semantics captures key ideas chapter flow analysis 
appendix proves programs formed unconventional type system get stuck execute 
greatest difference actual flow analysis chapter formalization formalism takes declarative approach 
syntax directed iterative 
type checker guess states approximate check loops 
assigns state program point flow sensitive information 
section sketch adjust type system conventional flow analysis 
section discusses advantages disadvantages formalizing analysis type system 
types int terms return junk values junk heaps variable sets states rvalues lvalues unesc esc type contexts renamings syntax chapter formal syntax presents syntax formal language 
formalizing null pointers uninitialized memory simpler formalisms chapters 
particular functions quantified types 
statements include expressions executed effect return statement halts program return memory allocation sequential composition conditionals loops 
allocation variable declaration memory lives forever 
memory initially holds junk initialized assignment expression 
variable escape scope static semantics reason bind enclosing statement 
bound statement continuation just sequential composition 
expressions include integer constants nondeterministic form producing unknown integer variables pointer creation pointer dereference assignment uninitialized data junk construct evaluating expressions unspecified order 
including ensures analysis fully determine program behavior input functions 
preceding chapters distinguish left expressions right expressions 
evaluation order unspecified treats expressions right expressions 
conventional implementations constant null pointers 
heap maps variables values 
junk value type element syntax class defined rename identical dom contained replaced 
return wf wf wf chapter semantics bindings renaming static semantics ensures typed program tries dereference junk test conditional 
consider heaps implicitly treat partial maps convenient 
formalize aggregates recursive types malloc 
straightforward features significantly complicate language soundness proof ways 
section explains interesting complication malloc causes 
aggregates recursive types syntax types extremely simple 
pointer type indicate null invariant form 
preceding chapters typing contexts map variables types 
typing contexts flow sensitive information described rvalues 
consider typing contexts implicitly treat partial maps convenient 
typing judgment right expressions produces rvalue approximates value expression evaluate run time 
briefly describes pointers point describes describes values sequence pointer dereferences produce junk describes values may junk unreachable describes values including junk 
similarly typing judgment left expressions produces lvalue approximates variable expression evaluate runtime 
form means expression evaluate examples include expression assuming typing context ensures rvalue expression form approximates left expressions 
indicates unesc pointers known 
precisely heap typing judgment gives heap type rvalue subtyping judgment typing contexts enforces property 
hand esc rvalue type 
formedness judgment typing contexts enforces property 
formal type system tracks flow sensitive information way lets variables appear conventional type system consider scope allow implicit conversion 
judgment ensures allocations distinct variables contains precisely variables 
source programs property straightforward actual compiler achieves internally giving allocation site unique name 
formal dynamic semantics means unrolling loop change bindings copy loop body 
machine state includes set names loop rule uses mapping renaming 
mapping formed respect written wf injective map variables elements defines wf formal semantics carefully address renaming issues technical distractions help explain flow analysis 
readers consider ignoring uses variable sets just accept formalism handles variable clashes systematic renaming 
dynamic semantics dynamic semantics straightforward interesting facts deserve mention 
rule ds allocates memory extending heap variable mapping junk 
return statement unreachable see ds irrelevant 
rules ds ds indicate machine stuck test expression uninitialized 
rule ds uses renaming ensure copies loop body allocate different locations 
new bindings part global set variables 
previous chapters implicit conversion accomplished goal 
rules dr dr formalize unspecified evaluation order particular require expression evaluated example heap map 
section explains problematic formal language sequential expressions actual cyclone traditional type checking precedes flow analysis strange scoping exist 
junk ds ds ds return return ds junk ds dom wf rename ds ds ds chapter dynamic semantics statements comma operator 
rule dr result result 
semantics expressions refer expressions allocate 
static semantics defines formedness judgments 
formed lvalues mention variables assumed 
formed rvalues restriction restrictions regarding types 
variable esc rvalue fixed type 
restriction key ensuring type preservation assignment escaped locations 
extend restrictions typing contexts wf 
typing context formed closed wf 
just possible enforce information sound unknown pointers variables unesc 
ordering judgments enforce property 
judgment wf technical restriction typing contexts static semantics unreachable code 
type checking unreachable code pathological important proving type preservation 
technically convenient unnecessary safety require include variable variable 
rules ss st judgment 
actual flow analysis algorithm typing contexts 
dr dr dr dr dr dl dl dr chapter dynamic semantics expressions dr dom wf wf wf int wf int unesc wf int unesc wf int unesc wf wf unesc wf wf wf wf unesc wf unesc wf unesc dom wf unesc wf unesc wf wf wf dom wf chapter formedness unesc esc esc esc chapter ordering rtyp styp ss dom wf styp return ss styp styp styp ss tst styp styp ss tst styp styp styp styp unesc ss ss styp wf styp ss styp wf styp ss chapter typing statements rtyp junk sr rtyp sr rtyp int sr rtyp int sr ltyp rtyp sr rtyp int sr rtyp rtyp sr rtyp rtyp ltyp rtyp aval rtyp sr rtyp rtyp sr rtyp sr ltyp rtyp sr rtyp rtyp sr rtyp int rtyp int rtyp rtyp sr rtyp sr rtyp wf rtyp sr sr wf esc aval wf aval rtyp rtyp sr ltyp sl rtyp ltyp sl rtyp ltyp sl ltyp wf ltyp sl ltyp ltyp sl chapter typing expressions rtyp dom wf tst st rtyp dom wf tst st rtyp dom wf tst st ltyp unesc tst unesc unesc st rtyp tst st chapter typing tests htyp htyp rtyp htyp htyp styp wf dom dom prog chapter typing program states defines ordering judgments formalize lose information choosing approximate flow information 
indicates locations escape associated rvalue may need change result formed 
judgment lets forget variable left value escaped 
similarly lets forget value initialized forget value 
forget points information pointed location escaped 
judgment form indicating assumptions approximate 
rules extend ordering judgments point wise imply formed 
statements presents typing rules statements 
typing contexts describe flow sensitive information statements expressions typecheck typing context produce typing context 
styp resulting context 
rule ss uses typing judgment explained 
rule ss formalizes notion control flow return sound produce 
impose technical restrictions simplify safety proof 
rules ss ss demonstrate reuse typing contexts describe control flow 
control flows ss uses context produced context assumed 
test expressions conditionals loops typing judgment explained produces typing contexts test 
rule ss context 
produce result context 
rules ss ss provides subsumption equality overly restrictive 
rule ss resulting type context false context test control flow terminates loop 
strange variable sets ss ensure variables allocate 
particularly want allow behavior ss typing context produced statements return mention rule ss formalizes fact memory allocation produces fresh uninitialized memory aliases known 
apply dom 
treatment differs algorithm section keeps allocation sites state 
extending simpler declarative system 
implementation extends states way equivalent keeping locations states 
subsumption rule ss lets produce conservative typing context 
rule forget bindings exist necessary loop body conditional branch allocates memory 
rule ss lets restrict domain result formed 
tempting domain restriction part ordering rule unesc unesc unesc show dom 
lose expressive power restricting domain approximate rvalues 
expressions presents interdependent typing judgments expressions 
judgment right expressions form rtyp right expression type rvalue approximating values evaluate effect produces 
similarly typing judgment left expressions concludes type lvalue typing context 
appears rules explicit information typing contexts formedness ordering hypotheses information 
rules conventional type systems appropriate rule may depend various rvalues just syntax term type checked 
rule sr sr type check effect free expressions produce consume 
constant integer possibly null pointer rules 
cases rvalue 
nonzero integer type int rvalue 
similarly evaluates initialized integer may 
sr type rvalue 
rules sr sr type check expressions form expressions evaluate nonzero pointers 
left evaluate location evaluate typing rules left expressions ensure appropriate 
rules sr exploit range information typechecking information points location case holds appropriate rvalue 
know points require junk require rvalue 
rvalue depends type indicates type indicates rule sr 
need rules type form rule sr provides appropriate subtyping 
remaining expression forms dynamic semantics specify order evaluation 
reasons explain section sound require affects flow information sequential expressions 
require type check produce consume 
rule sr technique interesting feature 
sr ensure assignment safe produce resulting flow information 
auxiliary aval judgments avoid having assignment rules 
purpose disallow assigning integers pointers vice versa 
allow assigning value junk aval ensures vice versa rule sr 
escaped appropriate escaped location formedness hypotheses aval rules enforce 
type flow information change 
unescaped assignment change flow information 
rule sr weak support malloc assignments form malloc sizeof add allocation site context 
suffices add rule case memory allocation safe regardless evaluation order 
special rule unnecessary changed sets approach described section 
rules sr provide subtyping 
rule sr lets treat nonzero pointers possibly zero pointers 
rule unsound left expressions 
rules sr sr conclude approximate respectively 
subsumption may necessary expressions undefined evaluation order flow information change assignment escaped locations produced formed 
expressions allocate necessary restrict domain typing context 
result lemmas appendix simpler expressions statements 
rules typing left expressions straightforward adaptations similar rules right expressions 
right expressions dereference values junk 
subsumption useful source programs helps establish type preservation machine takes step rule dl 
tests typing rules conditionals loops judgment tst defines 
judgment ensure sound approximations assuming evaluates nonzero value respectively 
determine statically irrelevant statements type check context executed 
fact explains rules st typing context rule st lets refine rvalue unescaped location 
rule formalizes intuition expression rvalue zero respectively zero rvalue respectively 
rule st addresses case test affect flow information 
states type check program states judgments 
rules type checking heaps expect 
typecheck program state type check context describes require formed escaped locations appropriate rvalues 
may possible define algorithm finds approximate htyp determine exists reason practice check source programs 
true earlier chapters type checking rules heaps essentially syntax directed 
hypotheses prog technical conditions control renaming 
allocations distinct variables heap 
run time dynamic semantics uses avoid reusing variables subsume variables source program prog amounts ensuring program type checks empty typing context name clashes 
summary type theoretic techniques specify static semantics incorporates flow sensitive information including points information 
tricks deserve mentioning 
express possible control flow typing context multiple times rule 
second ensure points information sound allowing flow information determine location points location aliases known 
third subsumption typing contexts specify relationship 
subsumption rules contain part type system lead directly algorithm 
fourth allow appropriate test expressions refine flow information 
fifth analysis little restrict variables scope disallow implicit conversion 
iterative algorithm section describes formal declarative type system differs iterative flow analysis reduce differences 
importantly formal system allows approximate states see rules ss sr sl iterative analysis uses particular join operation program point multiple control flow predecessors 
wellknown results flow analysis suggest iterative analysis lose expressive power restriction 
straightforward enforce similar restriction formal system 
essentially remove subsumption rules static semantics modify rules terms multiple control flow predecessors join operator 
loops need fixpoint operator iteration join 
approach specified evaluation order assuming expressions may execute multiple times fixpoint operator sr sr 
making typing contexts see ss st iterative algorithm produces explicit 
adding formalism straightforward 
essential additions axioms wf styp tst 
easily dismiss sources nondeterminism 
tests st st apply st st apply 
assigning type subsuming recall cyclone implementation type checking precedes flow analysis 
earlier compiler phase assigns types expressions 
dissertation discuss details subtyping type inference 
technical point declarative type system powerful iterative analysis join operation needs rvalue approximate chooses escaped failing uninitialized 
static semantics lets replace leave unescaped 
type safety result implies join operation flexible regard remains sound 
iterative flow analysis handles unstructured control flow naturally awkward extend declarative system 
static semantics goto problem context include map labels states 
mapped state goto approximate check 
expected formalism guesses mapping flow analysis discovers iteratively 
dynamic semantics require substantial modification support goto 
local term rewriting longer suffices 
lower level view execution explicit program counter machine state suffice 
discussed chapter particularly typed assembly language takes approach 
type safety appendix proves result definition 
state stuck value return 
theorem type safety 
styp reflexive transitive closure stuck 
proof surprisingly difficult 
omitting pairs recursive types sequential expressions unstructured control flow formalism allows focus essential properties 
machine dereference junk theorem implies prevent operations 
related flow sensitive information modern compilation program analysis 
compiler textbooks explain define implement dataflow analyses intermediate representations source programs 
analyses enjoy understood mathematical foundations support correctness efficient implementation 
section discuss related unusual features chapter flow analysis 
features include analysis general purpose source language part language definition 
analysis statically prevents safety violations resulting uninitialized data dereferencing null pointers 
analysis language specified evaluation order 
analysis incorporates points information 
formalism analysis uses type theoretic techniques describes flow sensitive information 
source language flow analysis java definition requires implementations enforce particular compile time flow analysis 
analysis prevents reading uninitialized local variables prevents value returning methods reaching method body 
analysis interprets accurately accept methods int true void int int int widespread java evidence general purpose programming language effectively include conservative flow analysis definition 
analysis supports common idioms programmers little need learn specific rules 
example omit initializers wish resulting error messages guide initializers 
suspect programmers interaction gain approximate understanding analysis satisfies needs 
flow analyses java cyclone quite similar served inspiration starting point 
java analysis simpler reasons 
method local variables uninitialized 
object fields including array elements class static fields implicitly initialized default values null object constructor called class initialized respectively 
decision avoids difficult interactions subclassing order constructors get called 
second address operator 
previous reason fact means pointers uninitialized memory 
cyclone terms form java rvalues just 
locations escape need 
analysis rules left expressions simpler variable lvalue left expressions lvalue 
third java analysis prohibits uses possibly uninitialized locations 
rvalue appear expression form cyclone permissive 
example allow long unescaped 
effect change rvalue 
java initialized location uninitialized 
terms cyclone formalism typing context java expression produces approximate typing context consumes 
allowing cyclone may uninitialized useful 
important allow contains rvalue contains 
assignment produces approximate typing context 
fourth java goto 
cyclone statement unreachable statement contained unreachable 
conservatively determine reachability java method body top pass code 
fifth evaluation order java deterministic 
turns reasons simplify java analysis algorithmic implementation need iterate 
expressions exe cution order iterative join approach developed chapter unnecessary 
statements iteration necessary control transfer destination analyzed approximate context control transfer source 
java analyze method bodies top bottom control transfers analyzed statements arise continue reaching loop body 
cases source context approximate variables uninitialized initialized 
fact locations stay initialized simplifies analysis exception handlers 
cyclone necessary analyze catch clause typing context encountered corresponding try body program points contained nested exception handler 
java suffices analyze initial typing context try body 
java aggregate values pointers aggregate values need rvalues form put way impossible initialize part uninitialized variable 
static control null pointer checking memory initialization java considers null pointer dereferences run time error 
implementations may static analysis omit unnecessary checks null way programmers express null invariant cyclone types 
research projects explored tools languages provide ability 
esc java splint provide annotations indicating function parameter object field pointer null 
systems check assertions compile time subject soundness restrictions described chapter 
systems warn dereferences possibly null pointers 
systems tools concern defining terms programming language precise notion restrictions enforce 
hndrich leino investigate retrofitting safe object oriented languages java null types 
main complication object fields array elements null types 
object fields initialized null run time 
ensure remain null hndrich leino propose extending flow analysis constructors ensure constructor assigns fields 
restriction suffice constructor object constructing assigning fields 
problem precisely java initializes object fields implicitly 
distinguish types objects constructors completed 
non null fields objects types value may null non null values may assigned 
assignment flow analysis may assume value null 
terms formalism chapter technique essentially adds new rvalue allows wf esc 
esc dereference assign pointer 
analysis assignment esc 
type preservation holds 
arrays non null hndrich leino require run time check program assigned array element 
cyclone restrictive requires immediate initialization arrays 
language approach popular functional languages eliminate null require programmers discriminated unions 
retrieving actual pointer possible pointer requires special syntax pattern matching 
drawback actual pointers implicit subtypes possible pointers 
specified evaluation order number languages specified evaluation order surprisingly little flow analysis languages 
example scheme permutation semantics function application sense described section 
scheme community extensively researched approaches control flow analysis statically approximating functions expression evaluate 
knowledge presentations assumed fixed evaluation order 
analyses flow insensitive case evaluation order irrelevant 
assumption reasonable purpose analysis optimization compiler perform analysis choosing evaluation order 
actual semantics just language definition large source confusion 
iso standards committee considered complicated formalisms sequence points allowed 
reasonable formalism theorem prover show legal expressions deterministic evaluation order affect result 
fact deterministic formal proof prove result expressions sequence points specified evaluation order positions 
interestingly unsoundness join approach chapter results class expressions fact may coincidence 
result provides important excuse flow analyses examining code assume source program legal analysis soundly choose evaluation order expressions 
assumption hold program undefined analyzing impossible anyway 
excuse ordering semantics splint attempts find expressions undefined evaluation order analysis incomplete 
analyses assume left right evaluation order 
ccured compiles code way ensure safety 
implements left right evaluation certainly compatible standard 
incorporating points information cyclone analysis incorporates simple points information 
primary motivation support delayed initialization heap allocated memory malloc 
compilers include points information flow analyses 
precompute points information different analysis 
analysis provide set possible locations expression evaluate 
subsequent analyses sets approximate effect assignments data uninitialized null 
cyclone points information analysis part language definition having analysis choice 
steensgaard presents particularly fast flow insensitive interprocedural points analysis 
describes slower flow sensitive approaches 
refined extended steensgaard basic approach 
andersen dissertation develops points analysis partial evaluator avoid overly pessimistic assumptions pointers 
program analyses reason pointers determine pointers 
particularly powerful approach shape analysis shape graphs statically approximate structure run time heap 
earlier nodes graph correspond allocation sites source program somewhat cyclone flow analysis uses allocation sites define space rvalues 
approach difficult analysis prove properties data structures unbounded size 
way cyclone create list uninitialized data list element allocated different program point 
sophisticated shape analyses sagiv reps wilhelm eschew correspondence shape graph nodes allocation sites 
shape graphs notion corresponds linearity type theoretic terminology allows graphs summarize structure data structures unbounded size 
dor rodeh sagiv shape analysis pointer analysis find errors programs manipulate pointers 
approach conservative reports errors program leak memory access deallocated storage attempt dereference null 
rough sense main difference cyclone analysis technique generating pointer information 
shape analysis sophisticated leads usual advantages disadvantages respect performance accuracy understandability type theoretic approach smith walker morrisett alias types develops type system points information roughly comparable cyclone analysis 
differences deserve explanation 
distinguish type level location names term level locations cyclone uses variables allocation sites purposes 
result cyclone rejects code int malloc sizeof int malloc sizeof int new alias types framework conditional continuation final assignment polymorphic location name conditional branches jump continuation instantiating type level name differently 
second term language idealized assembly language control transfers amount continuation passing style 
result locations location names leave scope system encounter complications led abandon conversion chapter formalism 
sequences language restrict primitive instructions assignment memory allocation primitive instructions precede 
restriction avoids need typing judgments produce typing contexts 
third locations escape explicit type level application unescaped linear location name polymorphic function expecting escaped nonlinear location name 
technique replaces ordering judgments formalism 
fourth allow explicit deallocation unescaped locations 
straightforward add free primitive cyclone takes pointer unescaped location forbids subsequent location 
cyclone alias types allows run time tests refine flow information possibly null null tested location unescaped 
prior alias types typed assembly language support cyclic lists section 
subsequent combined location names recursive types express aliasing relationships data structures unbounded size 
extension subsumes linear type systems express pointer refers location pointer refers 
shape analysis technology allow allocate list uninitialized data initialize element list 
formalizing cyclone analysis type system interpretation 
theory interpretation type systems sufficiently powerful foundations program analysis different formalisms different proof engineering benefits 
type safety proof appendix shows declarative formulation flow analysis strong keep dynamic semantics getting stuck 
examining dynamic semantics see impossible dereference uninitialized values correctness analysis follows metalevel corollary 
took considerable effort revise analysis produce algorithm similar power prove notion similarity 
contrast interpretation approach problem define semantics expressions manipulate values type system 
syntactic techniques prove safety prove semantics dynamic semantics appropriately related abstraction function maps concrete values values 
having established semantics valid interpretation guaranteed correct sense expression abstractly evaluates concretely evaluate value result dynamic semantics get stuck 
furthermore domain infinite chains form 
ri distinct know algorithm implement interpretation 
type system proving type preservation require changing term syntax executing loop bodies require systematic renaming dynamic semantics 
interpretation allow implicit conversion term variables proving valid interpretation require maintaining connection different copies loop body 
prove expression program point evaluates value certain properties 
standard approach change term syntax include labels convert terms 
dissertation determine approach better show type systems describe flow sensitive compile time information including pointer analysis 
furthermore syntactic approach soundness wright felleisen advocate establish safety 
chapter array bounds discriminated unions preceding chapters developed advanced type system flow analysis preventing flavors safety violations code 
chapter sketch similar techniques preventing incorrect array indexing misuse union values 
array bounds violations violate memory safety directly restricting value expression arr write 
union values leads unsafe programs writing union member reading member equivalent unchecked type cast 
problems shall simplifying assumption unsigned integer determines correct array representing length union indicating member written 
integer known compile time stored tested run time 
implementations high level languages simply store array lengths tags corresponding data objects 
accessing data objects involves implicit checks integers 
cyclone appropriate expose checks data representation decisions programmers 
extending techniques earlier chapters promising 
introducing compile time integers type variables stand quantified types type constructors encode connection integers objects describe 
extend flow analysis approximate value mutable integers array indexing current type value union 
chapter sketches extensions informally evaluates 
formal semantics type safety result 
features quite experimental actual cyclone implementation 
current applications little 
extensions natural sound true approach taken problems 
material chapter support pointer arithmetic 
consider detail decide nontrivial arithmetic facts compile time 
specific form arithmetic constraints decision procedure orthogonal basic approach developed chapter 
briefly describe interval approach rvalues previous chapter set constraints approach closer current cyclone implementation 
choosing powerful usable arithmetic remains ongoing 
rest chapter organized follows 
section describes extensions type system describing lengths arrays 
section uses types extended flow analysis enforce safe array indexing 
delay discussion union types section 
section presents sophisticated union types extends flow analysis reason union values 
section evaluates extensions 
section discusses related 
chapter uint abbreviation unsigned int 
compile time integers section explain add known unknown integers type system reason array lengths 
add tag types called types literature modify pointer types include lengths 
additions suffice type checking cyclone constructs creating arrays 
examples quantification compile time integers 
describe subtyping induced type system changes 
types just chapter introduced kind region names chapter introduced kind lock names introduce kind integer types 
add types positive integer 
example type kind term type terms kind give term type tag 
tag type constructor takes type kind produces type kind fact 
constructor analogous constructor region chapter produced type handle region name 
expected pointer types include compile time integers length 
example int describes pointers arrays integers 
braces type just syntax int looks odd 
general build pointer type element type type kind omitted length short hand 
additional types suffice type checking constructs create arrays pointers 
give variable array type provided array size known 
example int declares hold array length 
type implicitly promoted int 
cyclone implicit promotion resulting type int 
build array length depends run time information requires malloc consider 
chapter described cyclone determine arrays created malloc get initialized 
special syntax creating initializing array initializer form creates array length element initialized substituted 
new produces pointer heap allocated array 
type expression type assuming type uint type tag 
example new type uint points array squares 
type system far typing rules restrictive create array length depends run time information 
add type variables kind unknown compile time integers 
example variable type tag new type form 
convention range type variables kind turn introducing type variables 
quantified types expected universal quantification lets functions take unknown integer constants 
example function array length caller specifies tag len val return new len val clearly callee know length 
need extension caller compute length run time 
key realize uint equivalent tag integer value unknown constant 
existential unpack convert uint tag type 
example code truly creates array unknown length len fgetc stdin read input unpack int arr new len declaration peculiar syntax unpacking uint usual unpack introduces type variable kind scope rest block 
important unpack uses fresh location value type tag 
violate type safety explained section 
existential quantification important user defined types 
simple example lets programmers store array bounds pointer array struct arr tag len arr letting users specify bounds flexible compiler inserting implicit bounds array 
example define type tag describes arrays struct tag len int arr double arr flexibility limited 
indicate array elements longer array unknown size add types form 
words symbolic arithmetic type level operators addition 
require array elements type 
restriction precludes example element array points array length 
data structure represent triangular matrix 
support types unknown size limited extent example struct tag len int arr allow types unchecked casts programmers limitation 
cyclone suffices give kind type struct size object type unknown 
programmers create arrays local variables types 
disallow fields arr 
subtyping constraints type system extensions lead natural notions subtyping 
tag subtype uint second treat longer array shorter array 
example int subtype int 
known compile time integers deciding subtyping obvious 
unknown compile time integers subsumption know certain compile time inequalities 
example subsume int int know track inequalities constraints chapters 
quantified types introduce constraints form 
example function access elements array passed caller know array returned longer int int way introduce constraint caller satisfy inequality compile time passing pointer type int 
way run time tests 
example type tag type tag lets assume 
set assumed constraints depends program point 
sophisticated constraints lead richer notions arithmetic 
example current cyclone implementation accepts constraint 
important conflicting design goals constraint language expressiveness having tractable decision procedure determining set constraints implies set constraints 
procedure necessary eliminating quantified types discussed array indexing 
arrays having extended type system account correspondence array lengths integers holding lengths turn ensuring operations stay bounds 
simple solution replace subscript operation ternary operator sub 
operator equivalent evaluated raise exception 
suffices treat sub polymorphic function arguments types uint tag respectively 
solution gives way programmers ensure statically subscript operations fail programmers remove provably unnecessary checks 
noticed disadvantages implicit null checks dereferencing possibly null pointers chapter 
consider extend chapter flow sensitive analysis reason values index arrays 
approach uses conjunction intervals approximate value expression type uint terminology chapter extend rvalues conjunctions intervals 
approximate uint assuming bit machine 
sound presence aliasing rvalue contents escaped location 
unescaped locations precise 
example subsume expression type tag uint resulting expression rvalue 
know value 
result flow expressions 
example type tag declaration uint gives rvalue 
run time tests produce precise intervals 
example consider unescaped rvalue 
type check knowing holds value range knowing holds value range 
allowing conjunctions important may know relative ordering unknown compile time integers 
example successive run time tests ensure reason prefer interval vice versa 
obvious purpose rvalues check subscript operations 
type allow rvalue implies 
consider details decision procedure 
run time tests flow analysis influence type checking introducing compile time inequalities 
unfortunately current cyclone implementation strictly phases type checking including constraints flow analysis 
current cyclone implementation takes approach similar previous chapter extends constraints mutable integers 
approach track inequalities information difficult compute accurate approximations necessary 
example assume know escapes join state conclude able achieve expressiveness current implementation 
approaches accept important idioms 
programmers write functions sub wish rely dynamic checks sub arr uint elt tag len elt len return arr elt throw second verify straightforward loops function adds elements array int add int arr tag len int ans int len ans arr return ans accept sophisticated examples 
example function returns array hold twice elements struct arr tag len arr struct arr double struct arr arr len len arr arr len return len new len arr arr return arr len arr existential type hides correspondence lengths argument result 
initializer type checks subsume type len tag uint run time tests flow analysis accept array subscript expressions initializer 
execute arr len 
second earlier test len ensures note assume len len 
analysis perform level mathematical reasoning sound len may greater gb bit machine 
general arithmetic overflow soundness difficult 
safe example current implementation support int int tag tag uint uint int ans ans return ans return accept function state initialization imply 
mentioned join operation accuracy possible 
possible conjunction intervals approach key join operation expand states include intervals redundant due compile time inequalities 
example add intervals true branch interval 
similarly add intervals false branch 
second produce joined state assuming compile time inequalities program point join 
example inequalities 
true branch false branch conclude 
analogously true branch false branch conclude 
discriminated unions section explains compile time integers enforce safe unions 
key addition enrich union types member associated constraint 
example declarations encode arithmetic expressions struct exp struct struct exp exp struct exp exp union int num requires struct exp negation requires struct exp reciprocal requires struct plus requires struct minus requires struct times requires struct divide requires struct exp tag tag union suppose type union means plus member value accessible reading writing 
existential quantification definition struct exp member accessible 
clients unpack values test value tag field regain information necessary access value field 
clients mutate struct exp values hold different variants long fields mutated simultaneously 
similar encoding type system represent connection tag field member field written 
type checker check code checks tag field reads appropriate member different members union type guarded requires clauses decision procedure prove overlap hold 
value type union allow accessing member guard holds 
compile time inequalities produce information 
continuing example allow code exp tag switch case num break case negation break default break branch switch statement know type union equals 
branches similar 
rules compile time inequalities expressive accept code uses binary search determine tag values 
require determining exact variant allowing access safety demand 
example safe cast union union 
existential types struct exp type constructors union way lets encode discriminated unions tag run time 
desired programmers choose put tag test value 
techniques rely type invariance far way change member union value accessible mutate existential package contains 
escaped locations endeavor better 
unknown pointers location 
ensure access correct member mutation require correct member change location type union tag updated time existential type 
unescaped locations flow analysis allow changes member accessible 
unescaped location type union flow analysis tracks member written 
specifically suppose definition union members 
fn ranges rvalues 
possible values location possibly uninitialized fi member written fi contains value approximates 
assuming unescaped allow right expression flow analysis determines member written 
allow result assigning member change rvalue join control flow paths members written different forget initialized 
essentially unescaped locations change type union union 
point location escapes program point pointers location known exactly member written indicated location declared type 
flexibility lets reuse unescaped locations example void struct exp struct exp union exact type irrelevant example struct exp flip num exp tag plus exp exp exp tag check example type checker record implicit casts union union union 
flow analysis ensure casts safe occur unescaped 
implicit casts may interact type inference give type checker awkward flexibility 
design choice distinguish union types change members 
allow escape 
suffices style union type different restrictions depending location 
evaluation described ensure safe arrays unions cyclone 
key addition type system compile time integers including type variables standing unknown constants 
flow analysis extended states integer constraints accessible member union values 
compared problems earlier chapters factors arrays unions difficult solutions complicated 
programs manipulate integers ways safe nontrivial mathematical facts 
words numbers enjoy interesting relations type locks initialization state 
implementing run time checks null pointers straightforward check needs possible pointer 
run time checks array lengths union members require appropriate tag 
tag passed necessary operators 
techniques developed address point type system connect tags data flow analysis separate run time tests data access 
incorporating arithmetic presence mutation overflow remains ongoing 
fortunately choosing constraint language decision procedure appears largely orthogonal 
important aspect design explicit data objects discriminated unions arrays carrying lengths existential types 
technology chapter ensure safely 
describe specific limitations approach suffers 
consider advanced idioms discussed earlier dissertation 
basic assumption tag describing array length union value known statically held particular location run time 
safe programs may ways determine value tag 
example storing array length divided length 
example representation triangular matrix described earlier 
far common example nul terminated string convention safe access successive string elements encountering 
convention completely different way determining array length run time 
cyclone experimental support nul terminated strings discuss 
final example programs go phases union values type member member 
major limitation lack support pointer arithmetic 
example allow code len arr code arr arr 
architectures compilers produce faster code 
actual cyclone implementation allows pointer arithmetic pointers implicit bounds fields run time checks 
pointer programmers control data representation relatively slow pointer arithmetic 
common union types allows convenient access overlapping subranges bits pointers 
example value small bit fields total size sizeof int union member struct type suitable reading fields union member type int 
easy set fields simultaneously example 
technically forbids reading member member written conventional implementations allow idioms 
assuming conventional implementation safe cyclone allow reading union member type 
cyclone implementation allows access 
final point prototypes form void int arr syntactically pleasant void tag arr 
important distinction mutating change length arr 
allowing syntactic sugar straightforward 
consider idioms encountered earlier chapters support compile time integers 
generic function copy data 
example library provides function prototype void memcpy void const void size similar prototype give cyclone memcpy const sizeof tag cyclone version suffers problems 
implementable cyclone way copy value unknown size 
give type function implemented second represent amount data copy arguments size element type number elements 
overcome limitation enriching language compile time arithmetic expressions write tag sizeof 
third prevent caller passing overlapping memory regions arguments 
memcpy undefined regions overlap 
similar function allows overlap 
trade memcpy may execute faster 
second example proves successful 
chapter described initializes attribute function parameters 
attribute indicates caller pass non null pointer unescaped possibly uninitialized location 
callee initialize location returning 
ad hoc extension allow callee return value indicating initialized location 
technology developed chapter hope union type tag type encode idiom 
possible step exploiting actual cyclone require initializing union int requires int requires tag union attribute initializes new return return unfortunately universal quantification incorrect function 
callee chooses tag caller 
correct quantification existential exists integer callee returns value type tag initializes appropriate union member 
minimum need extend cyclone existential quantification function types 
caller needs way unpack existential function call introduces 
data object contains function result location callee referred put way caller passes type callee bound existential function result 
require special syntax packaging function result simpler abandon initializes attribute rewrite return existential type holding tag union value struct pr tag union struct pr return pr new return pr related section discusses projects prevent unsafe array union accesses reason integer values compile time 
far exists thorough review 
focus systems preventing array bounds violations static analyses reasoning integer values languages express array lengths union tags type systems 
considerable overlap areas distinction somewhat arbitrary 
making arrays safe simplest way prevent array bounds violations code compile pointers carry size pointed object run time 
runtime checks terminate program soon violation occurs 
obviously approach loses static assurances changes data representation programmers expect promised 
project am aware uses technique part implementation ensures safety safe 
safe pointers carry information determine pointed object deallocated 
problem changing data representation requires recompiling program impossible source code standard library unavailable 
avoids shortcoming storing auxiliary information table indexed machine addresses 
course pointer dereference look information auxiliary table 
systems suffer substantial performance degradation pointers occupy extra space pointer dereference requires run time checks 
ccured project uses program static analysis avoid overhead 
analysis avoid changing data representation pointer need point array length 
upper bound negative index expressions pointer subtraction 
program static analysis linear size program 
programmers specify representation pointers passed returned code compiled ccured 
appear ccured exploit user variable holds array length 
project focused arrays uses unions treated casts run time checks 
ccured provides special support nul terminated strings making implicit terminator inaccessible user programs 
chapter compares cyclone ccured general 
published ccured provides excellent description commercial tools similar goals 
projects focused misuse strings buffers hold 
example wagner automatically buffer overruns real code audited manually 
integer intervals primary abstraction approximate integer variable interval 
generate interval constraints completely solving constraints 
scalability constraint generation flow insensitive 
model character buffers length string hold nul terminator allocated size 
recall cyclone chapter reason nul terminators 
analysis knows important library routines strlen affect determine buffer values 
bug finding tool unsound respect aliasing 
language integer constraints sophisticated cyclone allows operations addition 
constraint solver bounding boxes approximate approaches described section 
dor precise analysis find subtle safety violations generating false positives 
relies integer analysis uses polyhedra precise bounding boxes 
analysis sound absence errors guarantees absence bound errors functions require explicit preconditions postconditions 
analysis handle multilevel pointers applied large programs 
static analysis section describes general approaches static reasoning integer values array lengths union values 
compared described projects essential connection approach forbidding array bounds errors generate verification condition implies absence 
verification condition require precondition expression implied evaluated value length array evaluates 
theorem prover try prove verification condition 
verification condition generator theorem prover sound proof establishes absence bounds errors 
architecture underlies extended static checking esc java code touchstone certifying compiler 
separates problems finding mathematical fact hold determining fact hold 
theorem provers incomplete slow 
projects investigated traditional compiler approaches bounds check elimination 
example gupta describes straightforward approach flow analysis reducing number bounds checks 
analysis sophisticated cyclone reasons 
interprets arithmetic operators including multiplication division 
second determines safe hoist bounds checks loops 
cyclone interested suffice programmers hoist checks analysis verify result safe 
bodik gupta sarkar eliminates bounds checks analysis check consider elimination attempts avoid irrelevant check sparse representation operate full control flow graph 
aim support simple fast bounds check elimination 
describes wide variety previous approaches bounds check elimination 
rinard symbolic analysis approximate values pointers array indices accessed memory regions 
producing constraint system reduced linear program avoid limitations fixpoint flow analyses 
application approximating memory expression access static detection array bounds errors 
flow analyses invariably need compute implications integer constraints involving unknown integers 
literature includes understood solution procedures restricted classes inequalities linear inequalities 
omega calculator popular tool simplifies presburger formulas contain affine constraints logical connectives universal existential quantifiers 
formulas intractable theory calculator proved efficient practice 
bounds check elimination described claims simple arithmetics sophisticated cyclone supports suffice 
contrast data dependence community uses somewhat similar techniques optimize numerical applications 
detect bounds violations seek reorder memory accesses 
paek give account approaches representing results array access analysis 
omega calculator enable transformations better exploit memory hierarchies 
unclear optimizing numeric applications inherently requires sophisticated arithmetic reasoning bounds checks elimination heretofore ambitious goals 
eliminating redundant checks discriminated union tags equivalently finding checks fail languages scheme values belong discriminated union 
eliminating checks important performance primitive operation addition check type tags operands numbers 
wright cartwright developed practical soft typing implementation scheme 
soft typing essentially type inference subtyping programs remain typable 
precise types lead fewer run time tags checks 
wright cartwright summarize approaches including flow analysis interpretation 
approach approximating values works languages scheme set analysis 
flanagan dissertation investigates analysis realistic language avoid program analysis techniques inhibit scalability 
languages turn languages expose representation arrays unions checks associated safe 
talx implementation typed assembly language intel ia architecture support compile time integers describe data representation 
array types singleton integer types quantified types union types essentially assembly language equivalent corresponding features cyclone 
published tal describe system code producers eliminate unnecessary bounds checks 
macros necessary reading writing array elements macros perform checks 
unpublished david walker eliminates shortcoming extent 
tracks chapter calls compile time constraints 
furthermore small proof logic lets programs prove results form subject assumed constraints 
compared cyclone allowing proofs flexible flow analysis basically encodes restricted class proofs 
fixed width arithmetic limits collection sound axioms 
walker requires unpacking integers singleton types reasoning values 
pleasing type theoretic standpoint flow analysis requires treating loops polymorphic code 
cyclone approach probably palatable humans 
talx union types 
annotations conditional jumps guide type system refine possible union members jump destinations 
annotations essential unsurprising cyclone need 
necula proof carrying code provides richer set arithmetic axioms programs prove array bound lengths 
compilers producing code theorem provers eliminate checks necessary 
instantiations code am aware dictated data representation arrays discriminated unions part policy 
richer language eliminating checks weaker language describing data 
xi restricted form dependent type reason array lengths unions ml typed assembly language imperative language called xanadu 
full generality dependent types indexed terms 
means undecidability term equality equal type equality undecidable 
xi uses separate language type index expressions connects language terms singleton types 
chapter essentially thing simply terminology dependent type find misleading syntax types include terms 
terminology aside xi systems compile time integers quantified types type constructors cyclone 
constraint language sophisticated including quantification arithmetic operators 
restricted linear equalities variant fourier variable elimination solve restriction compile time efficiency 
xi integers express invariants array lengths union members 
examples include length linked list balance properties red black trees 
constraint language expressive express append function takes lists lengths returns list programmers write explicit loop invariants tolerate run time checks xi developed significant techniques 
xi imperative languages shares technical similarities dissertation significantly 
formalism xanadu variables change type unescaped variables described precisely chapter change rvalue 
systems typing judgments produce typing contexts 
xi allow pointers variables 
sense treats invariant variables type invariant 
technical contribution cyclone support statically tracking state changes aliased objects long unescaped 
eliminate run time distinction variables heap addresses 
difference cyclone supports mutating existential types xi considered pointers existential types 
chapter investigated ramifications decision great detail 
cyclone considers avoidance unnecessary levels indirection hallmark style programming 
matter emphasis xi interested user defined data representation proving run time checks fail 
example formalism xanadu assumes primitive operation acquiring length array array 
safe assembly language supports common implementation trick pointers usually distinguishable small integers talx implementation 
supporting trick cyclone possible requires existential quantification single word small integer pointer 
chapter related languages systems dissertation describes safe low level programming language advanced type system sound flow analysis 
level endeavor relates program correctness program semantics program analysis language design 
furthermore topics memory management multithreading efficient array manipulation studied areas decades research results 
topics appropriate chapters related 
contrast chapter takes macroscopic view prior concurrent safe low level programming 
focus just closely related cyclone differs 
enumerate research projects contributions categorize projects 
cyclone projects employ combination approaches categorization approximation 
programming languages relevant support low level systems 
discussion includes industrial strength languages ada modula research prototypes 
describe approaches describing data representation foreign function interfaces 
section contrasts cyclone lower level safe languages typed assembly language 
section describes systems unconventional data representation memory management implement safely 
section briefly surveys compile time approaches checking safety properties including theorem proving model checking type qualifiers dependent types pointer logics user defined compiler extensions 
programming languages section contrasts safe safe programming languages support controlling data representation resource management 
ada ada general purpose programming language substantial support modularity abstraction concurrency user defined data representation 
compared cyclone safe higher level abstraction 
ada big language relevant features discuss 
ada escape mechanisms performing unsafe operations memory deallocation 
ada enforce memory initialized behavior undefined error occurs 
cyclone escape mechanism write part application safe subset ada relies entirely optional garbage collection memory management 
exception limited types cyclone terms programmers declare objects type allocated fixed size region programmer picks size 
region deallocated control leaves scope type declaration 
run time failure occurs program allocates objects type 
cyclone fix size regions simple extension conjoin notion type lifetime 
ada generics allow polymorphic code ml functors clu clusters templates 
generics second class constructs instantiation occurs compile time 
templates conventional implementations generate code distinct instantiation 
chapter explains technique produces code avoids unnecessary levels indirection program data 
ada packages modules support hiding code data type definitions 
ada feature prove useful cyclone types private fields 
size alignment fields exposed packages code packages fields 
technique allows packages allocate objects type access fields type efficiently 
prevents separate compilation 
implementation type private fields changes necessary recompile packages type 
ada lets programmers specify size bits order record fields numeric types 
support user specifying location data necessary safety array bounds discriminated union tags 
modula modula general purpose programming language rigidly distinguishes safe unsafe modules 
depend placing trust unsafe modules cyclone place linking code 
code unsafe modules may perform unsafe operations 
modula uses object oriented paradigm code reuse 
implementation controls data representation objects 
modula records numeric types user specified size 
modula implementation language spin extensible operating system proving example modula useful writing untrusted systems extensions 
spin implementors identified language extensions considered essential task 
allowed casting arrays bits appropriate record types contain pointers 
cyclone ability 
second require untrusted code ephemeral meaning system safely terminate code time 
compiler checks ephemeral code perform inappropriate operations allocate memory 
cyclone notion language support systems conventions transactions 
third class modules dynamic linking system reconfiguration 
cyclone support linking 
spin project reports tolerable overhead garbage collection resort coding conventions explicit buffers reduce reliance collector 
language ensure extra conventions followed correctly 
low level services spin device drivers written language interoperability modula compiler produces interfaces modula types 
furthermore data allocated modula visible garbage collector remaining code 
systems programming high level languages dissertation presupposes implementing operating systems run time systems benefits controlling data representation resource management research projects performed tasks high level languages 
systems benefit safe languages require unsafe extensions try minimize extensions 
operating systems implemented java include kernel 
drscheme programming environment includes substantial support running untrusted extensions operating systems manage untrusted user processes 
systems address important requirements cyclone limiting resources amount memory allocate revoking resources aborting process recovering locks holds 
back compare techniques java systems 
czajkowski von eicken describe resource accounting scheme underlying kernel 
hawblitzel von eicken taken language approach luna system type system distinguishes irrevocable pointers 
techniques developed dissertation appear ill equipped address style process oriented resource control 
oke project modified cyclone ensure untrusted kernel extensions safe 
general safe language avoids performance overhead running untrusted code separate virtual memory spaces 
jikes java virtual machine implemented entirely java extensions reading writing particular words memory 
extensions necessary services garbage collection available untrusted components 
ensemble system uses ocaml implement flexible infrastructure distributed communication protocols 
developers provide substantial comparison early system written argue safety higher level abstractions led smaller flexible robust implementation little performance impact 
crucial data structure garbage collection proved inappropriate resorted explicit counting 
fox project uses standard ml various systems tasks network protocol stacks 
project contends safe languages certified code see section increase program reliability 
vault vault programming language uses sound type system restricts aliasing ensure compile time programs objects interfaces correctly :10.1.1.14.7406
tracking state objects file descriptors type system formalize interface protocols 
example vault ensure programs close files exactly 
key technology type system spirit capability calculus ensures aliases tracked objects lost 
extensions termed adoption focus ameliorate strong restrictions capabilities violating safety 
incorporating restricted aliasing cyclone ongoing 
restricted aliasing allows safe explicit memory deallocation free function allowing vault implementation garbage collector 
easier vault environments operating systems hostile automatic memory management 
deline hndrich implemented windows device driver vault 
vault interface kernel ensures driver obeys important protocols modifying interrupt packets passing ownership parts system 
implemented device driver cyclone 
compared vault cyclone interface prevent unsafe operations 
words driver memory safe provided interface crash operating system 
lesson memory safety necessary sufficient 
hand cyclone level view data representation welcome 
cyclone device driver lines code performing operations inexpressible cyclone 
contrast vault driver lines code primarily converting vault data representation data representation 
vault cyclone research prototypes exploring powerful approaches compile time checking low level software 
overlap regions type variables remains realize smooth integration approaches 
language attempts improve addition syntactic improvements pointer type syntax additional language constructs tuples multiple return values support polymorphic functions 
compared cyclone project interested remaining closer interested ensuring safety 
control control combines severe restrictions interprocedural flow analysis ensure small lines real time control systems safe run time checking user annotations 
system disallows pointer arithmetic casts pointer types making impossible write generic code 
interprocedural analysis expressive arithmetic prove safe reject program 
primitive deallocate heap allocated data sense region flow analysis ensures dangling pointer dereferences result 
designers claim simple form memory management suffices small control applications 
null pointer dereferences uninitialized pointers checked run time hardware protection trap handlers incur performance overhead checks succeed 
consider thread shared data 
language interoperability implementations high level languages provide access code data written language 
facilities require way describe foreign function argument types foreign data representation 
conversely implementations programs code data written high level language 
interoperability mechanisms related cyclone key requirement explicit definition data representation appropriate level abstraction 
projects am aware check interoperability interface safety 
fisher pucella reppy explore design space foreign function foreign data interfaces 
compiler intermediate language bol low level unsafe language rich describe interfaces 
bol sufficiently powerful allow compiler infrastructure implement cross language inlining 
fact bol interoperability lightweight infrastructure uses bol implement primitive operations arithmetic 
blume provides standard ml programs direct access data programs 
approach uses ml type system encode invariants data accessed 
compiler extensions provide direct access memory 
systems idl interface description language describe code data committing particular language 
fact idl uses assumptions interesting extensions 
example attribute indicate arguments type char strings 
example reminiscent safety attribute specifying argument length array argument 
language implementations typically support idl generating stub code mediate mismatch implementation internal data representation decisions appropriate external interface 
languages specify interface code resorting idl 
known example java native interface 
allowing code access high level language structures usually amounts providing header files describing implementation data representation decisions 
interesting conventions maintaining run time system assumptions ability find roots garbage collection 
solution compile code multiple languages common virtual machine 
virtual machine provides run time system code multiple source languages 
compilers produce metadata describe data produce 
virtual machines assume security resource management obligations traditionally relegated operating systems 
project designing language suitable target language variety high level language 
provides open run time system virtual machine approach 
example high level language implementation provide code run time system uses find garbage collection roots 
extending run time system call back code way avoids complicated language describing data representation 
fact types describe little size data needs compile low level language 
safe machine code projects implemented frameworks verifying prior execution machine code obeys certain safety properties 
verifying machine code lets ensure safety trusting compiler produces setting network delivers 
motivation leads systems substantially different cyclone practice 
expect object code machine generated result compilation safe machine languages convenient machines humans 
particular expressiveness takes precedence convenience simplicity 
second implementing checker simpler implementing compiler 
framework reduce size trusted computing base 
typed assembly language tal imposes lambda calculus inspired type system assembly code 
early showed compilers safe source languages produce tal machine code plus typing annotations 
particular type system encode low level control decisions calling conventions simple implementations exception handling 
explored regions linear types avoid relying conservative garbage collection heap allocated data 
implementation ia architecture included important extensions kind system discriminating types sizes link checker safely linking separately compiled object files 
explored techniques reduce size type annotations time type checking tal programs 
compared cyclone tal lower level view control slightly lower level view data 
notion language procedure boundaries lexical scope 
language exposes byte level size alignment data 
proof carrying code pcc uses annotations object code verify code meets safety policy 
encoding policies formal logic policy designers change policy changing implementation checker 
practice policies written cater calling conventions procedure boundaries data representation particular compilers including java compiler compiler small subset 
compared cyclone tal policies allowed sophisticated proofs eliminating array bounds checks express memory management invariants aliasing invariants optimized data representations 
reducing size annotations time checking focuses eliding simple proofs encoding proofs directions search proof checker follow 
techniques proofs smaller probably convenient machines humans little sense cyclone 
tal pcc led implementations trusted components containing lines code researchers taken minimalist foundational approach pcc 
systems trusts implementation expressive logic encoding machine semantics logic encoding safety policy 
compiler writer prove type system tal sound respect safety policy prove program compiler output typed 
unclear techniques projects cyclone implementation trustworthy 
crary encoded tal languages formal metalogic 
foundational pcc project reduces trusted computing base unclear techniques apply human centric programming languages 
minimalist approach tried remove garbage collection trusted computing base 
powerful type systems supporting intensional type analysis regions allow untrusted programmers write simple garbage collectors 
cyclone far restrictive writing garbage collector necessary typing technologies far complicated general purpose programming language 
type checking proof checking foundation checking machine code xu techniques akin shape analysis flow analysis 
approach requires explicit annotations entry point untrusted code expensive techniques synthesize induction invariants loops recursive functions 
approach allows checking code unmodified compilers compilers unsafe languages programs machine instructions 
furthermore type system physical type checking described section model heap handle existential types discriminated unions 
xu focus inferring array sizes safety array indexing 
interpretation program modifying model heap captures alias points information approaches 
cyclone stronger support sophisticated data invariants support array bounds points information 
kozen efficient certifying compilation ecc tends favor elegance simplicity fast verification complex policies frameworks 
exploiting structure code verified quickly easily verify control flow memory safety properties 
dissertation ecc checks code separates operations array subscripts primitive steps bounds checks dereferences 
focus cyclone type system expressive allow programmers move checks safely hoisting loops 
usually straightforward extend ecc handle optimizations 
safe implementations contrary programmers expectations standard imposes weak requirements implementation data representation resource management 
implementation impose safety run time checks 
pure run time approaches austin developed system called safe 
translating pointers machine addresses implementation translates pointers records including lifetime array bounds information 
pointer dereference uses auxiliary information ensure safety 
program record deallocation heap objects stack frames 
safe supports including tricky issues variable argument functions 
disadvantages approach include performance programs run order magnitude slower conventional implementation changes making difficult interface unchanged code 
jones kelly solve problem storing auxiliary information separate tables 
pointer machine address pointer dereference uses address look auxiliary information table 
developed extension gcc compiler allows pointers carry bounds information subscript expressions check bound 
discussed dissertation cyclone form pointer type carries run time bounds information 
pointers permit unrestricted pointer arithmetic 
subscript operations incur run time check 
cyclone compile time approaches discussed dissertation programmer choice convenience implicit run time checks performance data representation advantages unchanged code generation 
cyclone provides little support run time approaches detecting dangling pointer dereferences 
extension described section partial solution works individual heap objects stack regions 
tools purify electric fence stackguard examples run time techniques detect bounds violations dereferences 
techniques include hardware virtual memory protection generate traps 
example way detect dangling pointer dereferences allocate object different virtual memory page page inaccessible object deallocated 
performance costs tools mean primarily debugging 
different systems different limitations 
example electric fence detects heap object violations 
advantage tools replace libraries rewrite object code avoids recompilation 
software fault isolation provides sound coarse grained memory isolation untrusted components 
assigns components portion application address space rewrites components object code typically masking operations ensure memory accesses fall space 
approach necessarily detect bugs appropriate applications share data component boundaries simple language neutral 
approaches exploiting static analysis static analysis prove run time checks unnecessary system recover cyclone advantages 
particular performance cost change data representation fewer points potential run time failure 
automatic analysis convenient 
programmer generally control cyclone 
ccured system uses scalable program static analysis safe implementation show programmers analysis results help static debugging 
analysis sound 
essence distinguish pointer types carry bounds information 
ccured kinds pointer types cyclone sequence pointers allow adding nonnegative values pointers permit unidirectional pointer arithmetic 
wild pointers pointer point values different types 
important ccured notion polymorphism wild pointers strictly lenient type variables 
run time type checks require run time type information cyclone implementation 
discriminated unions tags course information hidden programmers 
ccured relies conservative garbage collection prevent dangling pointer dereferences 
programs stack pointers placed data structures need manually rewritten 
described chapter unclear extend ccured support multithreading 
main convenience ccured cyclone programmers need indicate pointers refer arrays potentially unknown length 
cyclone accept unmodified programs ccured require manual changes 
example ccured may translate different occurrences type different data representations forbids expressions form sizeof 
ccured support valid idioms local allocation buffer creates large array characters casts pieces array different types 
ccured implementation ensures left right evaluation order expressions cyclone imposes ordering restrictions summarize cases performance program compiled ccured acceptable convenience cyclone ccured compelling legacy code 
cyclone language approach easier programmer control data representation run time checks occur 
explicit type system may easier write new code cyclone 
yong runtime type checking rtc tool reduce performance cost static analysis 
particular analyses employ correspond closely cyclone features 
include ensuring data initialized ensuring pointers null 
cyclone analyses take input precomputed flow insensitive points analysis cyclone worstcase assumptions escaped locations 
points information allows rtc avoid redundant checks repeated data reads determine intervening mutation data possible 
ccured rtc maintains runtime type information memory safely eliminated store information underlying data 
rtc explicit support threads 
static approaches section describes projects compile time techniques ensuring software enjoys safety properties 
projects discussed analyze programs 
address questions project 
properties checked 

assurances project give 

techniques implementation 

project complement cyclone approach 
point repeat implemented system projects find real bugs real software 
projects previous section 
empirical evidence programs years people harbor safety violations 
physical type checking chandra developed tool checks type casts programs :10.1.1.30.6614
identify safe idioms requires casts including generic code void simulating object oriented idioms 
programs include downcasts casting pointers prefix fields struct vice versa 
view supertype describes prefix memory described equivalent may shorter 
novel constraint inference algorithm assigns types expressions consulting actual types source program 
empirical results show tool determine percent casts fit sensible idioms 
remaining casts deserve close scrutiny 
downcasts may safe 
tool consider potential safety violations 
cyclone supports idioms identified extent safety allows 
chapter discussed support generic code 
subtyping discussed dissertation uses similar notion physical layout 
downcasts supported 
object oriented idioms avoided features existential types discriminated unions better object support remains 
cyclone strongly typed reason ignore program type annotations 
type qualifiers foster uses type qualifiers enrich type system user extensible way 
qualifiers const volatile restrict lets programmers define new ones 
qualifiers enjoy partial order examples const non const null possibly null system qualifier polymorphism 
interprocedural flow sensitive analysis eliminates need explicit annotations 
practice programmers annotate key interface routines 
example qualifier distinguishing user pointers kernel pointers helps detect security violations operating systems code 
functions may produce user pointers functions security demands consume user pointers require annotations 
system infers flow user pointers program 
aliasing assumptions sound conservative cyclone 
techniques cyclone complementary 
cyclone focus memory safety extensible 
extensibility find extending base language time new safety violation arises 
hand assumes input program valid ansi sound assumes memory safety 
systems overlap somewhat 
example systems prevent null pointer dereferences 
extended static checking esc java predecessor esc modula uses verification condition generation automated theorem proving establish properties programs running 
checker analyzes programs safe language compare cyclone takes quite different approach eliminating similar errors 
identifies potential errors including null pointer dereferences array bounds violations data races incorrect downcasts deadlocks 
second checks program meets partial specifications users annotation language 
esc java translates java simpler internal language generates verification condition axioms describing java hold program meet partial specification uses theorem prover prove verification condition generates warnings prover fails prove condition 
architecture involves components cyclone conventional compiler type checking followed flow analysis 
esc java implementation sound complete 
incompleteness stems theorem prover sound operates logic modularity verification condition means abstraction lead verification condition unnecessarily strong 
unsoundness stems ignoring arithmetic overflow avoid spurious warnings analyzing loops bodies execute 
user specify esc java unroll loops larger fixed number times 
system treats loops explicit invariants soundly 
cyclone uses distinct syntax terms compile time values tag annotation language esc java contains subset java expressions 
programmers reusing expressions easier 
convenient perspective designing type system 
dependent type systems terms specifications mutation complicates matters 
reduce programmer burden spurious warnings houdini tool attempts infer annotations esc java subroutine 
similar approach inferring cyclone prototypes cyclone compiler subroutine prove useful 
lint tools original lint program simple syntactic checking find errors reported early compilers 
sophisticated tools implement basic idea finding anomalies code compile time 
lclint successor splint intraprocedural analysis optional user provided function annotations find possible errors avoid false positives 
vast number annotations give users control tool warning block code 
early focused ensuring code respected datatype interfaces modification externally visible state global variables documented 
subsequent focused safety violations including null pointer dangling pointer dereferences memory leaks 
pointer annotations include notions uniqueness aliasing return value may function parameter 
expressive power annotations cyclone region system appear incomparable capture similar idioms 
lclint warns uses uninitialized memory annotation similar cyclone initializes attribute see section 
lclint sound complete 
particular analysis acts loop bodies execute 
checks expressions incorrect specified evaluation order 
parts tool assume orders equivalent 
cyclone benefit separation concerns 
splint tool primary extensions support finding potential violations support allowing user define new checks 
arrays function annotations describe minimum maximum indexes array function may access 
expression language indexes includes arithmetic combinations identifiers constants 
tool uses arithmetic constraints algebraic simplification analyze function bodies 
appear type definitions describe programs store array lengths 
analyze loops splint uses set heuristics find common loop idioms 
idioms include pointer arithmetic patterns cyclone support 
splint assumes bounds violation occur loop iteration simplification works practice 
splint extensibility allows programmers declare new attributes specify assignments control flow joins combine attributes 
language rich track values string tainted external input 
extension language appears weaker metal language described 
prefix tool finds program errors null pointer dereferences memory leaks dangling pointer dereferences 
commercial applications comprising total code base lines code 
prefix expects explicit annotations trivial 
primary challenge implementing prefix avoiding spurious warnings discover static information provided prefix attempts find fixed collection errors including appears array bounds errors 
unsound considers evaluation order expressions 
prefix ensures scalability generating model function model call sites 
evaluates recursive call cycles small number times typically twice 
models quite rich require properties parameters produce results depends parameter values describe effects memory including global variables 
prefix examines feasible execution paths fixed limit avoid time exponential function size 
heuristics guide paths examine 
rich language relations constraints variables discovers infeasible paths crucial avoiding spurious warnings 
generic notion resource tracks similar problems freed memory reading closed file handle 
prefix produces excellent error messages describing control paths reasons warning 
filters unimportant warnings memory leaks code executes shortly application terminates 
cyclone prefix different techniques 
prefix certainly useful large commercial applications modify code insert explicit annotations 
errors detects impossible cyclone providing annotations straightforward writing new code 
detection misused resources leaks revocation finer grained cyclone support resource management 
engler developed metal language tool allow users write static analyses 
language primitive notions state machines patterns matching language constructs 
features extremely easy write analyses check idioms functions release locks acquire floating point operations allowed analysis automatically implemented compiler extension term 
simple application specific analyses thousands bugs real systems 
metal language allows analyses execute arbitrary code quite expressive 
scalability usefulness engler exploits lint tools 
examples include assumptions memory safety aliasing recursive functions 
checking quite syntactic 
example analysis forbids call allow code assigns function pointer variable calls expect code things bug finding tool may suffer false negatives 
tool employs context sensitive interprocedural path sensitive intraprocedural dataflow analysis 
analyses take time exponential size programs cost occur practice aggressive caching analysis results tendency programs simple control structures respect constructs relevant analysis crucial 
tool finds thousands potential bugs uses statistical techniques rank ones actual errors 
potential violations arise control flow paths function false positives resulting imprecise analysis engler uses statistics infer analyses automatically 
essentially tool guess policies calls follow calls report potential violation policy followed time 
similar spirit mining specifications uses machine learning techniques analyze runtime call sequences 
prove useful similar statistical techniques control impenetrable error messages cyclone compiler especially porting code 
example errors follow calls compiler suppress errors try find stronger type extensibility provides difficult emulate language cyclone 
clever programmers write interfaces leverage type checker enforce properties applicationspecific idioms calling sequences remain difficult capture 
example cyclone compiler invariant types syntax tree passed check valid type function syntax tree type checked 
lack automated support checking invariant produced plenty bugs 
short complement sound static checking 
model checking model checker ensures implementation meets specification systematically exploring states implementation reach 
specifications equivalent temporal logic formulas exhaustive state exploration establish implementation model formula formal logic sense 
initial conditions model environment possible state transitions model checker search state space 
encountering error state transition path taken 
compared conventional testing model checking achieves greater coverage checking state twice 
compared flow analysis type systems model checking naturally path sensitive 
model checking model checking software large field describe focus projects model check code 
contrast systems require human software state machine 
checking abstraction catch logical errors necessarily implementation errors 
challenge software model checking state explosion problem typical systems distinct states infinite efficient checker remember states visited 
verisoft cmc model check implementations event handling reactive code running code scheduler induces systematic state exploration 
programmers provide specification check entry points event handlers code implementation assumed environment 
verisoft runs different system processes different system processes 
safety violations compromise model 
cmc uses operating system process 
systems assume implementations process deterministic observable transitions 
model checker assumes code terminates internal nondeterminism 
safety violation presumably leads nondeterminism reading arbitrary memory locations compute result 
cmc detect safety violations dangling pointer dereferences memory leaks 
slam blast automatically create model soundly abstracts program model check model specification 
model meet specification model checker creates counterexample 
theorem prover determines counterexample applies program results model 
system automatically generates additional predicates induce model model check 
architecture known verify refine loop 
sound model correct abstraction code complete report counterexamples apply code process may terminate 
furthermore systems assume program array bounds violations order evaluation errors 
theorem provers assume arithmetic overflow 
blast uses lazy abstraction efficiency 
completely rebuild model refinement iteration 
additional predicates induce model parts model relevant counterexample 
blast run programs lines 
systems verify find bugs device drivers lines 
holzmann ax uno tools model checking techniques check programs 
assumes programs ansi 
extracts model represents table 
users modify table interpret certain operations correctly function calls message sends 
framework preclude tools ensure modification sound focus extracting model automatically 
uno metal lint see 
default looks uses uninitialized variables array bounds violations arrays known size null pointer dereferences 
uses model checking techniques intraprocedural analysis 
exploit path sensitivity cyclone 
appear support nested pointers data structures 
uno lets programmers write new checks uno interprets enriched ways match definitions uses program checked 
compared cyclone model checking superior technology checking application specific temporal properties 
projects described demonstrate feasible medium size programs considerable complexity 
generated counterexamples useful fixing bugs 
systems sound respect safety violations incorrect type casts remain caveats array bounds 
furthermore model checking remains slower practice type checking 
technologies complementary sound type system detecting safety violations safety integral result compilation model checkers check interesting properties prone false positives 
interesting enrich cyclone path sensitive checking model checking techniques control potentially exponential number paths 
dependent types section describes xi dependent types soundly checking properties low level imperative programs 
argue imperative languages decidable type systems important clear separation term expressions type expressions 
difference dependent types cyclone approach little principle 
xi systems expressive compile time arithmetics 
integrating arithmetics explicit loop invariants cyclone pose technical problems may simple 
checking section describes dor shape analysis pointer analysis check safety violations 
call absence violations sophisticated analyses sound produce precise alias information cyclone 
check memory unreachable 
current enrich cyclone pointers may achieve goals precision 
discussed section dor integer analysis detect misuse strings 
extend approach ongoing 
appears confirm experience cyclone important abstractions ensuring safe arrays describe values index expressions 
section describes wagner uses abstraction functions unsound aliasing assumptions find bugs 
property simulation das esp project uses technique call property simulation path sensitive verification program properties scalable 
seek verify properties similar checked model checking tools slam enjoying scalability interprocedural dataflow analysis 
way distinguish model checking conventional flow analysis consider treatment control flow merge points 
model checking maintains information paths merge flow analysis soundly merges state 
key insight esp property checked strike middle ground viewing property finite state machine error state indicate property met esp merges states paths finite state machine state 
property simulation takes input global alias analysis input soundness issues relegated preceding phase 
esp gains efficiency checking property time definition property guide precision analysis 
contrast cyclone compiler checks safety violations time 
cyclone incorporate path sensitivity faster check properties independently 
chapter dissertation designed justified compile time restrictions form type system flow analysis ensure cyclone safe language 
techniques quantified types points information allowed resulting system achieve significant expressiveness 
similar approaches solve problems including incorrect type casts dereferences data races uninitialized data null pointer dereferences array bounds violations misused unions 
similarity supports thesis system safe convenient 
chapter summarize similarities solutions argue capture natural level expressive power 
describe general limitations approaches taken 
section describes implementation status dissertation experience cyclone implementation 
section briefly places larger picture building safe robust software systems 
summary techniques type variables type variables quantified types type constructors singleton types describe data structure invariants necessary safety 
invariants describe data value necessary safe manipulation data value 
integer describing length lock ensures mutual exclusion region handle describing lifetime value unknown type passed code reachable 
cases type variable data values changes kind type variable 
bind type variables universal quantification existential tion type constructor 
universal quantification allows code reuse 
existential quantification lets define data structures overly restrict invariants 
example field length array field points committing particular length 
type constructors reuse data descriptions large data structures 
example define list arrays arrays length 
existential quantification type constructors programmers enforce invariants range granularities 
singleton types types value type prove useful regions locks compile time integers 
cyclone region handles type locks type distinct integer constants tag type 
singletons ensure typing rules primitive constructs sound 
example region handles type type give allocation expression rnew imply lifetime long 
similarly test concludes value type tag greater conclude inequality wrong constant 
effects constraints data structures enjoy safety critical invariants code safely access data depends program point 
effects summarize safe program point necessary call function 
call effect capability 
examples include names held locks names live regions inequalities compile time constants 
run time operations influence effects 
example acquiring lock executing statement increases effect statement 
similarly tests integers introduce inequalities succeeding control flow branches 
effects function preconditions keeps type checking intraprocedural 
type checker ensures call sites satisfy effect assumes effect check function 
effect language includes regions live locks held type system restrictive polymorphic code 
say function quantifies type variable safe call call instantiates type describes live data 
effects describe situation analogous locks 
existential types need way describe type lifetime locks particular call site 
solve problem constraints bound effect locks 
constraints prove useful describing outlives relationships regions preconditions functions callee locks idiom 
prior integrating effects type variables effects constraints effects form locks 
shown effects convenient user defined data types cyclone effects simulate effects 
flow analysis safety issues data structure invariants prove insufficient sound flow analysis flexible conventional type system approach 
problems include dereferences possibly null pointers uninitialized data safe invariant uninitialized data mutable integers necessary loops variable access different elements array 
program point analysis assigns location roughly corresponding local variable allocation point value value soundly approximates actual value represents may uninitialized null integer intervals 
pointers aliasing pervasive programs soundness expressiveness require flow analysis maintain pointer information summarize 
analysis intraprocedural additional function preconditions capture common interprocedural idioms 
analysis takes conventional flow analysis approach checking program point single state soundly approximates states control flow predecessors 
analysis path insensitive 
points information address operator lets programs create arbitrary aliases location sound flow analysis assume aliases exist 
sound assume aliases exist memory allocated variable declaration call malloc 
furthermore tracking pointer information necessary separating allocation initialization data heap 
handle issues principled way cyclone flow analysis includes points information worst case assumptions locations aliases known 
program point may know location hold pointer location particular analysis result malloc expression result point location representing allocation 
enforce soundness presence unknown aliases analysis maintains may pointer location tracked points information 
pointed location value determined type 
particular remain initialized possibly null type disallows null pointers 
compile time error create unknown alias uninitialized memory 
limitations undecidable program commits safety violation sound compiletime techniques necessarily reject safe programs 
section describes general sources approximation possible approaches relax 
data structure invariants combination existential types type constructors gives programmers considerable power describing invariants restrictions scope type variables limitation 
example consider thread shared linked list integers existential types lock field list node describe list integer guarded possibly different lock 
type constructor describe linked list integer guarded lock 
techniques invariants possible 
describe lists odd list positions third 
lock list positions second fourth 

describe lists elements lock second lock 
impossible describe invariant lists locks integers th lock list guards th integer list 
similarly integers array mechanism exists locks half array elements 
appear type theoretic constructs extend support data structures unfortunately threatens thesis cyclone gives programmers control data representation 
possible way overcome gap prove data type equivalent standard typing techniques developing appropriate proof language may prove difficult 
programmers express certain object oriented idioms cyclone type system 
recursive existential types permit object encodings prove insufficient optimized data representations advanced notions subtyping 
may suffice extend cyclone additional forms quantified types 
type inference implicit downcasts reduce programmer burden cyclone advanced type system imposes intraprocedural type inference implicit run time checks 
explicitly typed program checks occur defined programmers maintain control 
example dereferencing possibly null pointer assigning possibly null pointer null pointer compiler insert check warn programmer 
unfortunately clear infer types implicit checks principled way example demonstrates 
keyword indicates type checker infer declaration type 
void int int new printf null fail run time check 
assignment fail depends type type int fails 
type int fails 
undesirable result type inference affect program behavior unclear metrics guide inference 
example choice leads inserted run time check 
aliasing cyclone flow analysis tracks points information programmers provide annotations describe stronger points information 
particular flow analysis track information pointer depth depth number pointer dereferences needed reach location depends number allocation sites function 
escaped locations includes locations large pointer depth cyclone assumes pessimistic aliasing assumptions 
language expressing stronger alias information cyclone powerful 
example restrict type qualifier indicate function parameter points location function body reach parameter 
underway add unique pointers cyclone 
unique pointer pointer pointed location 
type distinction unique nonunique pointers distinguishes uniqueness invariant 
unescaped location holds unique pointer safe treat pointed location unescaped 
cyclone flow analysis adding unique pointers type system lets programmers express uniqueness invariants unbounded data structures linked lists 
unique pointers permit manual memory deallocation safe migration exclusive access thread 
unique pointers general restrict permit unknown aliases provided aliases unavailable scope 
distinction illustrates static system define virtual partition heap require unknown pointers location reside part partition 
idea underlies focus operator vault language investigated logic bunched implications 
reiterate discussion chapter distinguishing alias information points information 
accept code safe point location know location 
relations type flow information cyclone point wise meaning information location independent 
example may know null way express null null 
lack aliasing information example 
arithmetic loops discussed chapter cyclone supports little compile time arithmetic 
len holds length array arr accept len arr assuming unsigned len arr 
loops safe nontrivial properties fixed width arithmetic 
cyclone support loop invariants describe parts arrays 
limitation impossible check loops correctly perform operations initialize elements array 
resource exhaustion discussed safety violations result consuming excessive resources 
example programs open files allocate memory exceed limits set operating system underlying hardware 
cyclone implementation handle problems having routines open files allocate memory throw exceptions resource exhausted 
static support ensuring programs exceed resource bounds 
omission cyclone useful embedded systems 
worse current cyclone implementation detect stack overflow 
nested function calls stack allocated objects exhaust memory control flow stack 
situation lead illegal memory access segmentation fault corruption heap allocated data 
unfortunately difficult detect stack overflow hurting performance function calls 
implementation experience dissertation empirical results cyclone implementation 
results exist 
quantitative measurements regarding code changes necessary port code cyclone run time performance implications suggest cyclone practical choice 
furthermore subsequent changes cyclone led substantial improvements 
particular benchmarks spend time loops iterate arrays 
support allowing users hoist array bounds checks loops array length compile time constant significantly improves results benchmarks 
techniques described chapter improvement possible 
section brief qualitative observations cyclone programming experience relevant dissertation 
cyclone support quantified types provides excellent support generic libraries linked lists hashtables 
practice libraries simple 
callers instantiate type variables explicitly need cast results 
second cyclone region memory management quite practical 
compile time guarantee stack pointers misused convenient stack pointers regions simple idioms callers determine object lifetimes callees determine object sizes 
simply garbage collected heap fast faster regions 
third applications cyclone compiler need control data representation 
emphasized dissertation cyclone provides built support arrays carry run time size information discriminated unions carry run time tags 
built features pervades cyclone code 
particular cyclone supports full pointer arithmetic pointers arrays implicit bounds fields 
dissertation helped design built features 
example problem mutable existential types discussed chapter applies mutable discriminated unions programmer choose data representation 
fourth support multithreading implemented 
similarity features suggests implement practical system compile time guarantee freedom data races system exist 
fifth support separating allocation initialization data successful 
occasionally lack path sensitivity flow analysis forces programmers include unnecessary initializers 
problematic lack support initializing different array elements separately 
arrays hold types null legal values calloc place malloc proves useful cyclone supports implicit initialization arrays cyclone 
practice problem led implementation check initialization numeric data 
compromise ensures compiler rejects programs due uninitialized character buffers 
may bugs result correct initialization characters unnecessary memory safety 
context dissertation develops approach ensuring low level systems written language enjoy memory safety 
cyclone language proof rich language static invariants source level flow analysis provide programmers convenient safe language level abstraction 
chapter summarized cyclone compile time analysis approximate solution undecidable problem 
uses small set techniques give programmers substantial low level control significant limitations remain 
memory safety language just way help programmers produce better software 
memory safety ensure correctness 
best help isolate parts software system programmers soundly compositional reasoning building systems 
safety compositional reasoning just means 
interested correct software software certain properties security leaking privileged information 
hopefully memory safe low level language provide suitable foundation build assurances higher level properties 
enforcing properties memory safety impossible practice 
little hope rewrite world software cyclone reasons 
different programming languages different tasks 
large systems comprise code written languages 
language safe assumption code written language incorrect foreign code induce disaster 
cyclone useful brick creating robust systems hope research focuses mortar connects code written different languages compiled different compilers targeted different platforms 
appendix chapter safety proof appendix proves theorem repeat definition 
state stuck form return 
theorem type safety 
styp ret reflexive transitive closure stuck 
proofs dissertation proof follows syntactic approach wright felleisen advocate 
key lemmas preservation known subject reduction prog prog 
progress prog form return exists 
lemmas strengthen order prove inductively proof theorem straightforward induction number steps taken reach know prog 
prove prog theorem assumptions letting 
induction hypothesis preservation lemma suffice 
progress lemma ensures stuck 
proving lemmas requires auxiliary lemmas 
state lemmas prove bottom order presenting proving lemmas fixing minor omissions proofs previous give top description proof structure 
preservation follows term preservation lemma terms type check step return preservation lemma evaluation preserves ret need prove term preservation lemma term call 
progress follows term progress lemma 
substitution lemmas provide usual results appropriate type substitutions preserve necessary properties terms types contained need cases term preservation lemma employ substitution 
canonical forms lemma provides usual arguments term progress lemma determine form value type 
judgments terms rely judgments heap objects get set gettype proofs term preservation term progress require corresponding lemmas heap objects 
heap object safety lemmas lemmas fill need 
lemmas quite obvious facts 
lemma amounts preservation progress get relation informally gettype indicates value type path get produces value type progress set relation informally legal path change value 
prove results proofs require reasoning paths 
lemma amounts preservation set relation 
interesting part showing asgn judgment preserves correctness context means witnesses style packages changed 
set lemma proves induction obvious fact parts parts path compatible 
lemma provides result part parts path 
patterns significantly complicate lemmas see corresponding lemmas chapter see simpler lemmas patterns 
path extension lemmas add path elements right paths 
example prove case dl term preservation 
proofs require induction heap object judgments destruct paths left 
remaining lemmas provide technical results aforementioned lemmas need 
typing formedness lemmas conclude types contexts formed typing derivations need satisfy assumptions lemmas 
uninteresting add hypotheses static semantics lemmas hold 
commuting substitutions lemma provides equality necessary cases proof substitution lemma involve second type substitution 
substitution lemmas polymorphic languages invariably need commuting substitutions lemma seen explicitly stated know conventional name 
need useless substitutions lemma reuse variables heap locations 
heap free type variables type substitution change describe 
weakening lemmas conventional devices argue unchanged constructs properties extended contexts context larger heap 
lemma context weakening 



wf xp proof 
proof induction derivation 

proof induction derivation wf previous lemma 
lemma term weakening 
suppose wf 
xp gettype xp gettype 

ltyp ltyp 

rtyp rtyp 

styp styp proof proof induction assumed gettype derivation 
follows xp dom xp xp 
proofs simultaneous induction assumed typing derivation 
cases ss sr conversion ensure dom 
cases sl sr follow proof dom 
lemma heap weakening 

wf htyp htyp 
hh 
proof proof induction heap typing derivation term weakening lemma 
second proof induction assumed derivation fact dom hh 
lemma useless substitutions 
suppose dom 


wf 

wf xp xp 
proof proof induction assumed derivation 
proofs induction assumed derivation lemma 
lemma commuting substitutions 
free 
proof proof induction structure 
result substitutions assumption free 
result substitutions 
type variable int substitutions useless 
cases follow induction definition substitution 
lemma substitution 
suppose ak 


ak ak 
asgn asgn 

wf wf 

wf wf 

ret ret 

wf xp gettype xp gettype 

ltyp ltyp 
rtyp rtyp 
styp ltyp 
proof 
proof induction assumed derivation 
cases induction 
case int trivial 
case type variable trivial 
case inverting ak ensures desired 
similarly case form trivial 
case type variable derive desired 
inverting ak ensures derive rule pointer types possibly subsumption rule 

proof cases assumed derivation previous lemma 

proof induction assumed derivation 
cases induction 
cases int pointer types trivial 
case type variable trivial 
case inverting ak ensures desired 

proof induction assumed derivation substitution lemma 
lemma corollary previous lemma 

proof induction assumed derivation 
type substitution irrelevant ret 

proof induction assumed derivation 
case trivial 
cases starts induction 
remaining case derivation form gettype xp xp gettype induction gettype xp 
commuting substitutions lemma ensures gettype xp 
useless substitution lemma ensures xp xp gettype xp derive xp gettype desired 
note lemma somewhat unnecessary program state reached source program nonempty paths type check gettype judgment open types 
put way rules sl sr require closed nonempty 
prove restricted type system sound easier just include lemma 

proof simultaneous induction assumed derivations proceeding cases rule derivation 
case satisfy hypotheses rule substitution rule derive desired result 
cases explain just conclude necessary hypotheses 
omit cases sl identical cases sr 
sr left middle right hypotheses follows substitution lemmas respectively 
sr left hypothesis follows induction 
right hypothesis follows substitution lemma 
sr hypothesis follows induction 
sr hypothesis follows induction 
sr hypothesis follows substitution lemma 
sr hypothesis follows induction 
sr hypotheses follow induction 
sr left middle hypothesis follow induction 
right hypothesis follows substitution lemma 
sr hypotheses follow induction 
sr left hypothesis follows induction 
right hypothesis follows substitution lemma 
sr derivation form rtyp ak rtyp left hypothesis induction provide rtyp 
right hypothesis substitution lemma provide ak 
derive rtyp 
commuting substitutions lemma ensures type want 
sr derivation form rtyp ak rtyp pack left hypothesis induction provide rtyp commuting substitutions lemma ensures rtyp 
middle hypothesis substitution lemma provide ak right hypothesis substitution lemma provide derive rtyp pack desired 
sr left hypothesis follows induction 
right hypothesis follows substitution lemma 
sr left hypothesis follows induction implicit context reordering 
formedness hypothesis follows substitution lemma 
ss case hypotheses follow induction 
ss cases substitution lemma provides kinding hypothesis induction context reordering provides typing hypotheses 
lemma typing formedness 

wf xp gettype 
ltyp wf 
rtyp wf 
styp wf 
styp ret proof proof induction gettype derivation 
case trivial 
cases starts induction inversion kinding derivation 
remaining case induction hypothesis applies inverting kinding derivation get inverting gettype derivation ensure xp dom wf provides xp context weakening lemma get xp substitution lemma get xp 
remaining proofs simultaneous induction assumed typing derivations 
cases follow trivially explicit hypothesis induction definition cases sl sr lemma 
case sr uses substitution lemma 
case sr uses definition wf determine function argument type kind statement cases argue contained expressions return 
examples case ss uses fact ret vacuously satisfy case ss uses fact ret invocations induction hypothesis provide lemma return preservation 
ret ret 
proof proof induction derivation proceeding cases rule derivation ds ret implies ret ds ret implies ret ret 
ds return trivially ret ds ret implies ret ret cases ret ds argument previous case applies 
ds case holds vacuously ret ds open ret implies ret substitution lemma ensures ret derive ret 
ds case analogous previous 
ds ret ret form subexpression irrelevant 
ds ret ret ret 
case induction hypothesis lets composition rules derive ret 
case rule applies regardless statement 
ds ret ret form subexpression irrelevant 
lemma canonical forms 
suppose rtyp 
int 
xp pack pack proof proof inspection rules rtyp form values 
lemma path extension 

suppose get 
get get derive get pip pack get pu derive get pup 
suppose xp gettype 
xp gettype xp gettype 
xp dom xp gettype xp 
proof 
proof induction length result follows inspection get relation 
longer proceed cases leftmost element case inverting get derivation induction hypothesis suffice 

proof induction length result follows inspection gettype relation 
longer proceed cases leftmost element case inverting xp gettype derivation induction hypothesis suffice 
lemma heap object safety 

get 

get get get 

suppose htyp get rtyp xp gettype exists get 
rtyp 
exists set 
corollary htyp gettype hold 

suppose addition previous lemma assumptions asgn 
xp dom 

suppose addition previous lemma assumptions set rtyp 
rtyp xp dom get pack xp 
corollary htyp gettype asgn set rtyp hold 
proof 
proof induction length 
proof induction length 

proof induction length 
gettype relation ensures get relation ensures get 
letting assumption rtyp means rtyp 
trivially derive set 
longer paths proceed cases leftmost element inverting assumption xp gettype provides xp gettype 
inverting assumption rtyp provides rtyp 
applying path extension lemma assumption get provides get 
induction hypothesis applies underlined results 
exists get rtyp desired 
furthermore exists set 
derive set satisfies desired result letting 
case analogous previous 
inverting assumption xp gettype provides xp gettype xp 
inverting assumption rtyp provides rtyp pack 
applying path extension lemma assumption get pack provides get 
get pack heap object safety lemma know xp 
induction hypothesis applies underlined results xp 
exists get rtyp desired 
furthermore exists set 
derive set pack pack satisfies desired result letting pack 
corollary holds get htyp ensures rtyp 

heap object safety lemmas ensure exactly get 
furthermore rtyp 
proof proceeds induction structure 
int canonical forms lemma ensures path extension lemma ensures derive get 
get pack impossible necessary xp dom 
cases analogous case int replacing different form value 
lemma holds vacuously derive asgn 
canonical forms lemma ensures 
path extension lemma ensures derive get get pack impossible necessary xp dom 
applying path extension lemma assumption xp gettype provides xp gettype 
inverting assumption asgn provides asgn 
underlined results assumptions get rtyp induction hypothesis applies xp dom desired 
argument analogous 

proof induction length 
set relation ensures 
gettype relation ensures 
assumption rtyp means rtyp 
heap lemma ensures xp dom second holds vacuously 
longer paths proceed cases leftmost element inverting assumption xp gettype provides xp gettype 
inverting assumption set provides set 
applying path extension lemma assumption get provides get 
inverting assumption rtyp provides rtyp 
underlined results assumptions rtyp asgn induction hypothesis applies 
rtyp xp dom get pack xp 
derive rtyp desired 
xp dom provides get pack xp 
get path extension lemma ensures form heap object safety lemma precludes 
induction provides result need 
applying heap object safety lemma provides get pack xp inversion provides get pack xp 
derive get pack xp desired 
case analogous previous 
inverting assumption xp gettype provides xp gettype xp 
inverting assumption set provides set pack pack 
applying path extension lemma assumption get pack provides get 
inverting assumption rtyp pack provides rtyp 
get pack heap object safety lemma know xp 
underlined results assumptions rtyp asgn induction hypothesis applies xp 
rtyp xp xp dom get pack xp 
derive rtyp pack desired 
xp dom provides get pack xp 
get pack path extension lemma ensures form case trivial get witness type change okay xp dom 
case follows induction 
corollary holds get htyp ensures rtyp 
definition extension 
extends exists 
lemma term preservation 
suppose htyp 
ltyp exist extending htyp ltyp 
rtyp exist extending htyp rtyp 
styp exist extending htyp styp proof proof simultaneous induction assumed derivations term take step proceeding cases rule 
noted 
dl inverting ltyp xp provides gettype wf 
applying path extension lemma provides gettype pi derive ltyp xpi dl inverting ltyp xp provides ltyp xp 
dl inverting ltyp provides rtyp 
induction induction hypothesis applies derive ltyp 
dl inverting ltyp provides ltyp 
induction hypothesis applies induction derive ltyp 
dr inverting rtyp xp provides gettype 
heap object safety lemmas provide rtyp 
dr inverting rtyp xp provides gettype rtyp asgn 
heap object safety lemma provides rtyp xp dom correct sense 
letting derive needed results 
dr inverting rtyp xp provides ltyp xp implies rtyp xp sl sr identical hypotheses 
dr inverting rtyp provides rtyp vi dr inverting rtyp provides rtyp ret rtyp ss sr results derive rtyp call 
dr inverting rtyp call return provides rtyp 
dr inverting rtyp provides rtyp ak 
substitution lemma provides rtyp 
wf useless substitution lemma ensures 
rtyp 
dr arguments similar 
inverting typing derivation provides induction hypothesis applies contained dr dr dr 
induction provides htyp appropriate typing judgment transformed contained term 
conclude appropriate typing judgment transformed outer term static rule original typing derivation 
dr need return preservation lemma sr 
cases contained terms 
term weakening lemma type check unchanged terms 
argument require extend 
ds inverting styp provides styp rtyp 
typing formedness lemma provides wf wf heap weakening lemma provides htyp rtyp provides htyp heap weakening lemma provides underlined results obligations 
ds inverting styp provides styp ds inverting styp return provides styp return ds inverting styp provides styp 
ds inverting styp provides styp 
ds inverting styp provides styp rtyp int 
typing formedness lemma provides wf rtyp int 
results ss ss ss derive styp 
ds inverting styp open pack provides styp rtyp ak substitution lemma provides styp 
applying useless substitution lemmas typing formedness lemma wf provides styp 
ss lets derive styp desired 
ds inverting styp open xp provides styp gettype heap object safety lemmas provide rtyp pack 
inverting result provides rtyp ak 
substitution lemma provides styp 
applying useless substitution lemmas typing formedness lemma wf provides styp 
xp impossible extension violate assumption 
may xp dom case fine 
applying term weakening lemma gettype provides gettype 
applying path extension lemma result provides gettype pu 
sl sr derive rtyp 
applying term weakening lemma styp provides styp 
ss lets derive styp desired 
ds cases inductive arguments similar cases dr 
term weakening lemma allows unchanged contained terms type check binding forms open conversion ensures sense 
lemma term progress 
suppose htyp 
ltyp form xp exists 
rtyp value exists 
styp form return exists 
proof proof simultaneous induction assumed typing derivations proceeding cases rule sl form xp 
sl induction value take step dl applies 
value pointer type canonical forms lemma provides form xp 
dl applies 
sl induction xp take step dl applies 
xp dl applies 
sl case analogous previous 
sr heap safety lemma provides get dr applies 
sr case analogous sl dr dr place dl dl 
sr induction value take step dr applies 
value product type canonical forms lemma provides form 
dr applies 
sr case analogous previous 
sr value 
sr induction xp take step dr applies 
value 
sr 
value value value induction ensures take step dr applies 
value 
sr 
xp induction ensures take step dr applies 
value induction ensures take step dr applies 
typing derivation heap object safety lemma provide hypothesis dr 
sr 
induction value value value take step dr applies 
value function type canonical forms lemma provides function 
dr applies 
sr induction return take step dr applies 
return inspection ret provided inversion typing derivation shows case impossible 
case dr applies 
sr 
induction value take step dr applies 
value universal type canonical forms lemma ensures polymorphic value 
dr applies 
sr induction expression inside package value take step dr applies 
value 
sr value 
sr value 
ss induction value take step ds applies 
value 
ss induction value take step ds applies 
form return ss induction take step form return case ds applies 
second case ds applies 
third case ds applies 
ss ds applies 
ss induction value take step ds applies 
value type int canonical forms lemma ensures ds ds applies 
ss induction value take step ds applies 
ds applies 
ss induction value take step ds applies 
value existential type canonical forms lemma ensures existential package 
ds applies 
ss induction form xp take step ds applies 
form xp gettype 
heap object safety lemma provides exists get rtyp canonical forms lemma provides form pack ds applies 
straightforward check preservation progress properties stated proof type safety theorem corollaries return preservation lemma term preservation lemma term progress lemma 
lemmas apply hypotheses prog preservation lemmas suffice conclude prog 
lemmas stronger static context extension inductive proofs 
appendix chapter safety proof appendix proves theorem repeat definition 
state sg stuck form return sg 
theorem type safety 
styp ret contains pop statements reflexive transitive closure stuck 
presenting proving necessary lemmas bottom order summarize structure argument explain lemmas imply type safety theorem 
theorem assumptions imply prog simple induction number steps taken shows suffices establish preservation prog sg sg prog progress prog sg stuck 
prove properties inductively need analogous lemmas right expressions left expressions chapter memory allocation complicates matters 
chapter explains hypotheses prog rule type check capability require rp spop change restrictions apply induction hypothesis form pop allow access deallocate necessary generalization prog defined conceptually partitions live regions statement expression acceptable type checks capability consisting regions se deallocates regions sp subject restrictions spop epop 
judgments statement type pop preservation lemma type pop progress lemma prog 
sg es region deallocated shrinking sp growing sg region allocated growing sp live location mutated changing se sp type heap remain unchanged 
type pop preservation lemma demonstrates type context heap induces strong resulting state typed situations 
interesting induction hypothesis pop proof conceptually shifts deepest region sp region se apply induction 
applying type pop preservation lemma sp conjunction return preservation lemma implies statement preservation need 
similarly applying type pop progress lemma sp conjunction ret implies statement progress need 
type pop progress lemma relies canonical forms lemma usual heap object safety lemma progress results involving paths simpler chapter access control lemma 
lemma ensures acc hypotheses suffice prevent programs trying access sg stuck 
languages programs may access locations scope lemmas unnecessary 
proving type pop preservation lemma requires auxiliary lemmas 
new region preservation lemma technical point cases allocate regions statements region assume constraint 
typing context step provides 
substitute 
lemma proves constraints suffice type check substitution 
subtyping preservation lemma proves results hold inversion rules sr sl 
progress heap object safety lemmas provide results paths associated relations get set gettype 
proofs simple patterns chapter 
values effectless lemma ensures rtyp epop means type checks regardless current capability intuitively evaluating values access heap contains pop statements 
lemma crucial allowing values escape scope 
auxiliary lemmas preservation conventional 
term substitution lemma provides preservation result need dynamic steps type substitution 
heap type formedness lemma just describes assume heap locations inverting htyp judgments 
typing formedness lemma lets typing judgments conclude context formedness types kinds 
type substitution lemma provides type level results need prove typing formedness lemma term substitution lemma 
eighth lemma needs type canonical forms lemma obvious 
remaining lemmas commuting substitutions useless substitution various weakening lemmas serve purpose chapter 
need prove analogous results effects constraints types 
commuting substitutions lemma effects interesting prove regions regions 
weakening lemmas semantic notion stronger effects constraints eff judgments useful notion syntactic extension 
lemma context weakening 

wf wf 

wf wf 



wf wf 

eff eff eff 
acc eff eff acc 
eff eff eff 
proof 
induction derivation wf 
induction derivation wf previous lemma 
induction derivation previous lemmas 
induction derivation wf previous lemma 
induction derivation eff interesting case derivation ends corresponding axiom 
case eff ensures eff 
inspection acc judgment previous lemma eff rule transitivity 
induction derivation eff context weakening lemma lemma term weakening 
suppose wf eff eff 
ltyp ltyp 
rtyp rtyp 

styp styp proof simultaneous induction assumed typing derivations proceeding cases rule derivation ss cases follow induction 
ss cases follow induction context weakening lemma 
induction hypothesis applies conversion implicit reordering fact eff implies eff fact eff implies eff 
ss case follows induction applies eff implies eff sl case trivial 
sl cases follow induction 
sl case follows induction context weakening lemmas 
sr case trivial 
sr cases follow induction 
sr trivial 
sr case follows induction context weakening lemma 
sr case follows induction context weakening lemma 
sr case follows induction 
sr cases follow induction context weakening lemmas 
sr cases cases ss 
sr induction hypothesis applies function body function explicit effect explicit effect connection ignored type check function 
sr case follows induction context weakening lemma 
sr case trivial sr case sl 
lemma heap type weakening 
suppose wf wf eff 

htyp htyp 
htyp htyp proof proof induction derivation htyp term weakening lemma 
second proof induction derivation htyp lemma 
lemma useless substitution 
suppose dom 

wf 

wf 


wf 
proof proof induction assumed derivation appealing definition substitution preceding lemmas necessary 
lemma type canonical forms 
dom 
proof inspection rules lemma commuting substitutions 
suppose free 


proof 
induction structure assuming set equalities usual cases trivial 
case induction 
substitutions produce regions right side rely assumption free definition regions outer substitution useless 
left substitution produces regions right produces regions 
inductive argument structure ensures sets 

induction structure previous lemma 
induction structure cases int trivial 
cases pair types pointer types handle types induction 
case function types induction commuting substitutions lemma 
cases quantified types induction commuting substitutions lemma 
case trivial 
substitutions produce right side rely assumption free outer substitution useless 
substitutions produce 
lemma type substitution 
suppose 

wf regions 
wf wf 

wf wf 


wf wf 

wf wf 

eff eff 

acc acc 

eff eff 
proof 
induction assumed kinding derivation cases regions trivial 
cases pair types pointer types handle types induction 
case function types follows immediately rule right hypothesis 
cases type variables singleton types follow rules assumptions definition wf 
induction provides wf regions 
trivial induction wf shows wf wf 
wf regions desired 

induction derivation wf previous lemma ensures interesting case 

induction derivation wf previous lemma 
induction derivation cases immediate induction 
case function types uses type substitution lemma 
case quantified types uses type substitution lemma implicit reordering type variable contexts 

induction derivation wf previous lemma 
lemma corollary type substitution lemmas 
induction derivation eff axioms follow definition substitution 
cases induction 

inspection derivation acc previous lemma type substitution lemma type canonical forms lemma ensure form appropriate acc 

induction derivation eff type substitution lemma lemma typing formedness 

gettype cr cr 
ltyp wf cr cr 
rtyp wf cr 
styp wf styp ret cr proof proof induction gettype derivation 
result immediate inversion kinding derivation ensures induction hypothesis applies 
remaining proofs simultaneous induction assumed typing derivations proceeding cases rule 
cases invert kinding derivations implicitly cover cases step may subsume kind sl sr cases follow definition cr wf kind typing formedness lemma 
sl sr case follows induction inversion kinding derivation type term hypothesis 
sl sr cases follow induction left hypothesis inversion kinding derivation type right hypothesis sr kinding rule pointer types 
sr case trivial 
sr cases follow induction kinding rules pointer pair types 
sr case follows induction middle hypothesis 
sr case follows induction left hypothesis inversion kinding derivation function types 
sr case follow induction 
sr case follows induction left hypothesis inversion kinding derivation quantified type type substitution lemma middle hypothesis typing derivation 
sr case follows right hypothesis induction left hypothesis 
sr cases trivial 
sr case follows induction inversion kinding derivation handle type kinding rule pointer types 
sr case follows kinding rule singleton types 
ss cases follow induction 
note ret obligation holds vacuously ss ss 
ss cases follow induction expression typing hypothesis kinding hypothesis 
ss case follows immediately hypotheses 
ss case follows induction fact formed formed 
lemma heap type formedness 
htyp dom form rtyp epop proof induction htyp derivations lemma term substitution 

ret ret 

spop spop 
epop epop 

gettype gettype 

suppose 
ltyp ltyp 
rtyp rtyp 
styp styp 
proof 
induction derivation ret 
simultaneous induction derivations spop epop 
induction derivation gettype 
simultaneous induction assumed derivations proceeding cases rule case satisfy hypotheses rule substitution rule derive desired result 
case just list lemmas arguments needed conclude necessary hypotheses 
cases sr sr commuting substitutions lemma just cases sr ans sr chapter see details 
sl definition substitution term substitution lemma type substitution lemma sl induction sl induction type substitution lemma type substitution lemma sr definition substitution term substitution lemma type substitution lemma applies right hypothesis ensures cr wf type substitution lemma sr induction type substitution lemma applies typing formedness lemma ensures cr wf sr induction sr type substitution lemma sr induction sr induction type substitution lemma applies typing formedness lemma ensures cr wf sr induction type substitution lemma sr induction term substitution lemma sr induction type substitution lemma type substitution lemma ensure derive result commuting substitutions lemma want 
sr induction applying commuting substitutions lemma result type substitution lemma type substitution lemma type substitution lemma sr induction term substitution lemma type substitution lemma sr induction type substitution lemma type substitution lemma sr induction type substitution lemma applies typing formedness lemma ensures cr wf sr type substitution lemma sr induction type substitution lemma type substitution lemma ss induction ss induction type substitution lemma sg 
rg 

se 
ij hj re 
ij 
ij sp ij hj 
hn rp ij 

htyp hind sg se sp rg re rp hind sg se sp rg re rp styp rp spop sind sg se sp rg re rp hind sg se sp rg re rp rtyp rp epop sg se sp rg re rp hind sg se sp rg re rp ltyp rp epop lind sg se sp rg re rp chapter safety proof invariant ss type substitution lemma induction type substitution lemma ss induction lemma return preservation 
ret sg ret 
proof proof induction derivation dynamic step 
similar corresponding proof chapter omit details 
lemma values effectless 

epop epop xp 

rtyp wf rtyp 
ltyp xp wf ltyp xp proof proofs induction structure values 
cases show deallocation rules disallow nonempty type checking rules require formedness 
lemma access control 

hind sg se sp rg re rp acc dom se 

assume dom se 
proof 
acc eff regions 
furthermore hind hypotheses ensure describes regions se form 
suffices prove stronger claim eff describes regions se describes regions se 
proof induction derivation eff 
interesting case rule uses fact 
case follows hind hypotheses 

lemma corollary previous heap type formedness lemma 
lemma canonical forms 
suppose rtyp 

int 



xp 

pack 
region rgn proof inspection rules rtyp form values lemma heap object safety 

gettype gettype gettype 

rtyp gettype get rtyp 
rtyp gettype rtyp set rtyp 

gettype rtyp exists get 

gettype rtyp exists set 

epop get epop 
epop epop set epop proof cases proof induction length 
result immediate induction hypothesis suffices 

result immediate induction hypothesis suffices 

result immediate rtyp induction hypothesis inversion derivation rtyp rule sr suffice 

induction hypothesis canonical forms lemma suffice 

induction hypothesis canonical forms lemma suffice 

result immediate induction hypothesis definition epop suffices 

result immediate induction hypothesis definition epop suffices 
lemma subtyping preservation 

rtyp xp ltyp xp 
ltyp xp acc rtyp xp 

rtyp xp acc rtyp xp 

ltyp xp ltyp xp ltyp xp proof 
induction derivation rtyp xp rule sr hypothesis suffices 
rule sr rtyp xp regions acc cr induction ltyp xp sl ensures desired result 

induction derivation ltyp xp rule sl hypotheses acc sr ensure desired result 
rule sl ltyp xp regions acc 
acc regions acc know eff regions eff regions regions 
derive eff regions acc 
typing formedness lemma type canonical forms lemma ensure acc applies 
induction hypothesis ensures rtyp xp 

lemma corollary previous lemmas 

induction derivation ltyp xp rule sl inversion heap object safety lemma suffice 
rule sl result follows induction 
lemma new region preservation 


eff proof induction obligation eff prove rewriting showing eff 



invoking induction hypothesis ensures eff 
context weakening lemma ensures eff derive eff context weakening lemma ensures suffices show eff suffices show eff trivial eff trivial eff follows 
lemma type pop preservation 
suppose 
sg respectively sg respectively sg 
sind sg se sp rg re rp respectively sg se sp rg re rp respectively lind sg se sp rg re rp exist 
es 
gr 

eff 
sind re respectively re respectively lind re proof proofs simultaneous induction typing derivations implied sind lind assumptions proceeding cases rule 
subtyping technique easier induction dynamic derivations 
case 
situations arise proof sketch structure argument situations 
dynamic step change heap sg sg say situation local 
letting se sp rg rp suffices show styp rp spop respectively rtyp rp epop respectively ltyp rp epop 
second arguments induction follow similar form 
say situation inductive 
invoke induction hypothesis hind assumption change inversion type checking deallocation assumptions conclude type checking deallocation facts induction requires 
invoking induction hypothesis provides hind gre satisfying 
provides typechecking deallocation results derive type checking deallocation results need 
apply various weakening lemmas establish hypotheses necessary type checking result 
hind result induction type checking deallocation results established situation follows 
sl case holds vacuously dynamic rule applies 
sl 
inversion rtyp rp epop 
dl dl applies 
dl xp situation local 
subtyping preservation lemma ensures ltyp xp inversion ensures rp epop xp 
dl situation inductive rtyp epop 
ltyp epop 
sl inversion rtyp rp epop 
dl dl applies 
dl xp situation local 
subtyping preservation lemma ensures ltyp xpi inspection ensures rp epop xpi 
dl situation inductive ltyp epop 
ltyp epop sl inversion ensures ltyp regions acc cr situation inductive epop hypothesis applies unchanged 
ltyp epop context weakening lemmas ensure regions acc ltyp sr inversion ensures gettype wf rp epop xp rp 
dr applies situation local 
heap type formedness lemma ensures epop cr rtyp term weakening lemma ensures rtyp heap object safety lemmas ensure epop rtyp 
sr 
inversion rtyp acc rp epop 
dr dr applies 
dr xp situation local 
subtyping preservation lemma ensures rtyp xp 
inversion ensures rp epop xp 
dr situation inductive rtyp epop 
context weakening lemma ensures acc rtyp epop 
sr inversion rtyp rp epop 
dr dr applies 
dr situation local 
inversion values effectless lemma ensure rtyp vi rp epop vi rp 
dr situation inductive rtyp epop 
rtyp epop sr case holds vacuously dynamic rule applies 
sr inversion ltyp rp epop 
dr applies 
situation inductive 
ltyp rp epop 
rtyp rp epop 
sr 
inversion rtyp rtyp 
dr applies value 
value situation inductive 
inversion epop rp epop 
inversion rp epop provide rp epop epop values effectless lemma ensures rp 
induction rtyp epop 
term weakening lemma rtyp 
rtyp epop 
value situation inductive 
inversion rp epop epop 
induction rtyp epop 
term weakening lemma rtyp 
rtyp epop 
sr 
inversion ltyp rtyp acc dr dr dr applies 
dr xp inversion values effectless lemma rp epop gettype cr rtyp 
heap type formedness lemma ensures location holds cr rtyp epop set heap object safety lemmas ensure cr rtyp epop letting se sp holds trivial induction hind assumption cr htyp shows cr htyp sgs es 
fact acc ensures se 
hind sg rg re rp 
rtyp rp epop follow 
dr situation inductive 
inversion rp epop epop 
induction ltyp epop 
term weakening lemma rtyp 
context weakening lemma acc rtyp epop 
dr situation inductive 
inversion epop xp rp epop 
inversion rp epop provide rp epop epop values effectless lemma ensures rp 
induction rtyp epop 
term weakening lemma ltyp context weakening lemma acc rtyp epop 
rtyp eff 
dr dr applies 
dr situation local call 
inversion values effectless lemma rp epop sr 
inversion rtyp spop ret cr styp context weakening lemma cr styp derive rtyp call epop call 
dr situation inductive 
argument argument sr addition context weakening lemma ensures eff 
sr call inversion styp ret rp spop dr dr apply 
dr situation local return inversion ensures rtyp rp epop dr situation inductive styp spop return preservation lemma ensures ret rtyp call epop call sr 
inversion rtyp cr eff rp epop 
dr dr applies 
dr situation local 
inversion ensures cr rtyp wf rp 
substitution lemma useless substitution lemma wf ensure cr rtyp epop 
context weakening lemma eff ensure rtyp 
dr situation inductive rtyp epop 
rtyp epop 
sr pack 
dr applies 
situation inductive 
inversion rtyp cr eff cr rp epop 
induction rtyp epop 
context weakening lemma eff rtyp pack epop pack 
sr cases hold vacuously dynamic rule applies 
sr rnew inversion rtyp region rtyp acc dr dr applies 
dr rgn inversion ensures rp epop values effectless lemma ensures cr rtyp hind assumption trivial induction htyp derivation shows cr htyp sgs es se sp location holding 
fact acc ensures 
hind sg rg re rp 
derive cr rtyp rp epop conclude fact requires 
follow extends rest context unchanged 
dr situation inductive 
argument argument sr addition context weakening lemma ensures acc sr case holds vacuously dynamic rule applies 
sr inversion ensures rtyp regions acc cr situation inductive epop hypothesis applies unchanged 
rtyp epop context weakening lemmas ensure regions acc rtyp ss cases ds applies situation inductive 
inversion rtyp ss rp epop induction rtyp epop styp spop ss 
inversion styp styp 
ds ds ds applies 
ds situation local 
inversion rp epop values effectless lemma rp spop 
rp spop 
ds situation local 
inversion rp spop 
ds situation inductive 
inversion rp spop spop 
induction styp spop 
term weakening lemma styp 
styp spop 
ss 
ds applies situation local 
inversion rtyp int styp epop spop rp 
trivially rtyp int epop 
styp spop 
ss 
inversion rtyp int styp styp rp epop spop spop 
ds ds ds applies 
ds situation local 
values effectless lemma rp rp spop 
proof ds analogous 
ds situation inductive induction rtyp int epop term weakening lemma styp styp 
styp spop 
ss 
ds ds apply 
ds argument analogous case ss explain differences value place rgn type place region 
conclude rp values effectless lemma rp epop need values effectless lemma show typed heap capability 
ds situation inductive inversion rtyp cr styp cr rp epop epop 
induction rtyp epop term weakening lemma styp 
context weakening lemma styp spop 
ss open 
inversion rtyp cr styp cr rp epop spop 
ds ds applies 
ds situation local pack 
rp epop sion rtyp cr eff context weakening lemma cr substitution lemma cr styp spop 
typing formedness lemma ensures wf useless substitution lemma ensures cr styp 
eff term weakening lemma ensures cr styp 
styp rp spop 
ds situation inductive induction rtyp epop 
term weakening lemma styp 
context weakening lemma styp open spop open 
ss region 
ds applies 
inversion cr region styp rp spop hind sg se rg re 
sg se rgn rg region 
re 

heap type weakening lemma htyp gs derive htyp gs es hind re 
spop derive spop pop substitution lemma ensures spop pop 
remaining obligation styp pop 
context weakening lemma ensures region styp substitution lemma useless substitution lemma wf ensure region styp 
new region preservation lemma context weakening lemma ensure region styp derive styp pop 
ss pop inversion cr styp spop rp 
ds ds ds apply 
ds ds 
inversion spop values effectless lemma ensure sp letting sg se rg hold 
inverting hind assumption form form 
letting simple induction shows holds 
simple induction assumed htyp derivation ensures cr htyp gs es intuitively heap typing 
fact sets equal typing weakening lemma ensures htyp gs es 
choosing outlives conclude hind re 
values effectless lemma inversion typing derivation cr styp 
typing weakening lemma ensures styp 
spop conclude sind re ds 
apply induction hypothesis need appropriate hind fact cr styp spop 
inverting hind assumption ensures sp form 
letting se se re re observe derive hind sg se rg re 
induction hypothesis inversion ensure hind re gre styp spop holding 
inverting hind fact induction ensures form letting observe gre gs es gs derive hind sg re 
gre styp derive styp pop spop derive spop pop holds 
easy verify 
lemma type pop progress 

sind sg se sp rg re rp return exists sg 
sg se sp rg re rp exists sg 

lind sg se sp rg re rp xp exists sg 
proof proofs simultaneous induction typing derivations implied sind lind assumptions proceeding cases rule 
case 
sl case trivial form xp 
sl 
value canonical forms lemma ensures form xp dl applies 
inversion ensures rtyp rp epop result follows induction dl 
sl form xp dl applies 
inversion ensures ltyp rp epop result follows induction dl 
sl case follows induction 
sr xp 
access control lemma ensures dom se 
hind hypotheses heap type formedness lemma values effectless lemma ensure rtyp 
heap object safety lemma ensures dr applies 
sr case analogous case sl dr dl dr dl 
sr value canonical forms lemma ensures form dr applies 
inversion ensures rtyp rp epop result follow induction dr 
sr case trivial value 
sr 
form xp value 
inversion ensures ltyp rp epop result follows induction dr 
sr 
values value 
value inversion ensures rtyp rp epop result follows induction dr 
inversion ensures rtyp rp epop result follows induction dr 
sr 
form xp value inversion typing derivation ensures acc gettype 
access control lemma ensures dom se 
hind hypotheses heap type formedness lemma values effectless lemma ensure rtyp 
heap object safety lemma ensures dl applies 
form xp inversion ensures ltyp rp epop result follows induction dr 
inversion ensures rtyp rp epop result follows induction dr 
sr 
values canonical forms lemma ensures function dr applies 
value inversion ensures rtyp rp epop result follows induction dr 
inversion ensures rtyp rp epop result follows induction dr 
sr call return dr applies 
inversion ensures styp rp spop ret ensures form result follows induction dr 
sr 
value canonical forms lemma ensures polymorphic term dr applies 
inversion ensures rtyp rp epop result follows induction dr 
sr pack 
value value 
inversion ensures rtyp rp epop result follows induction dr sr cases trivial value 
sr rnew 
values canonical forms lemma ensures form rgn 
acc access control lemma ensures names heap se conversion ensures dr applies 
value inversion ensures rtyp region rp epop result follows induction dr 
value value inversion ensures rtyp rp epop result follows induction dr 
sr case trivial value 
sr case follows induction 
ss value result immediate 
inversion ensures rtyp ss rp epop result follows induction ds 
ss 
ds applies 
return ds applies 
inversion ensures styp rp spop result follows induction ds 
ss ds applies 
ss value canonical forms lemma ensures ds ds applies 
inversion ensures rtyp int rp epop result follows induction ds 
ss value conversion ensures ds applies 
inversion ensures rtyp rp epop result follows induction ds 
ss value canonical forms lemma ensures existential package ds applies 
inversion ensures rtyp rp epop result follows induction ds 
ss conversion ds applies 
ss pop rp spop pop values effectless lemma ensures rp hind assumptions ensure sp youngest live region 
ds applies 
return argument ds applies 
rp spop ensures rp spop 
assumptions hind derivation ij ij 

letting se ij hj ij hj 
hn 
ij hind assumptions derive hind sg rg ij 
particular er sgs es inverting original typing derivation ensures er ij rtyp 
underlined induction ensures take step result follows ds 
appendix chapter safety proof appendix proves theorem repeat definition 
program tn badly stuck badly stuck thread 
badly stuck thread thread return sopt sopt theorem type safety 
styp ret junk free release statements reflexive transitive closure badly stuck 
presenting proving necessary lemmas bottom order summarize structure argument 
similar proof chapter simpler locks unordered complicated junk expressions 
type soundness theorem simple corollary preservation progress lemmas 
turn lemmas follow type release preservation return preservation type release progress lemmas respectively 
lemmas establish type preservation progress individual thread strengthening claims apply inductively typed statement expression appropriate type context 
prog necessary assumptions statement expression complicated define judgments describe accurately concisely 
rules merge locks held threads shared heap locations guarded locks hx lx 
furthermore suffice say li srel li erel li describes locks held thread containing distinguish locks released statements containing call le locks release statements contained call lr 
require li lr srel le determine type check 
top level statements 
really judgments capture exactly statement expression reduction preserves 
interesting part case preservation proof arguments judgment example lr change order prove result reduction satisfies property 
return preservation lemma proof preservation lemma show threads return 
case dr type release preservation lemma 
access control lemma establishes static context permits term access heap location location local thread guarded lock thread holds 
lemma cases dr dr type release preservation lemma argue heap accessible executing thread junk free 
sharable values need sharable context lemma establishes value type kind context value type context unsharable locations omitted 
intuitively needed locations type check value value sharable 
lemma case ds type release preservation lemma spawning thread involves moving values different thread 
lemma cases dr ds assigned location sharable assignment involves moving value heap case part heap type check unsharable locations 
canonical forms lemma describes form top level values type variables scope 
usual lemma type release progress lemma proof argue form values types 
term substitution lemmas establish proper substitution types terms preserves important properties 
expected lemmas cases involving substitution dr ds preservation proofs 
heap type formedness lemma provides obvious properties locations typed heap 
properties subsequent proofs need conclude properties location knowing heap type checks context 
values effectless lemma provides properties values 
properties subsequent proofs refine information provided assumptions 
example proving type preservation rule dr lemma conclude lr derive lr erel lr erel 
typing formedness lemma shows typing rules formedness hypotheses conclude context result types formed right kinds 
lemma conclude context formedness need explicit assumption type check result evaluation step apply various weakening lemmas 
lemma conclude kinds types typing judgments necessary establish assumptions lemmas type substitution lemmas 
type substitution lemmas show various type level properties preserved appropriate type substitutions 
lemmas necessary prove term substitution lemmas case sr typing formedness lemma 
commuting substitutions lemma necessary usual polymorphic languages type substitution previous chapters demonstrated 
chapter proof slightly nontrivial definition substitution effects 
type canonical forms lemma restricts form types kind ls 
lemma restrict form proving properties acc case ds type release preservation lemma proof 
provides results needed prove typing formedness lemma term substitution lemma 
results immediate 
useless substitution lemmas obvious 
show properties preserved substitution know part static context contain substituted type variable 
specifically case sr term substitution lemma needs lemma function free variables heap locations closed types 
similarly cases type release preservation lemma proof substitution useless substitution lemma obtain appropriate context type checking result evaluation step 
various weakening lemmas serve usual purpose preservation proofs 
reduction steps extend heap set allocated locks provides larger context type checking values case locks kind checking types 
weakening ensures enlarging context value fail type check 
structure preservation argument produces additional needs weakening 
example reading sharable value heap value copied place type checked sharable values term refer thread local values 
weakening type check terms context permissive typically explicit assumptions provide permissive permissive ones terms type check 
omit uninteresting proofs analogous corresponding proofs chapter 
state lemmas facts require inductive arguments 
lemma context weakening 

wf ll wf 

wf ll wf 

ll 

wf ll wf 

eff eff eff 
acc eff eff acc 

eff eff eff 
shr ll shr 

loc wf ll loc 
lemma term weakening 
suppose wf ll eff eff 
ltyp ll ltyp 

rtyp ll rtyp 

styp ll styp lemma heap type weakening 
suppose ll wf 
htyp ll htyp 
hlk ll hlk lemma useless substitution 
suppose dom 

wf 

wf 



wf 
lemma type canonical forms 

loc dom 

au lu 
furthermore ls 

au au 

au 

au 

lock lu 
proof proof induction assumed kinding derivation 
induction necessary step derivation may subsumption 
cases lemma subsumption derive type kind au lu 
lemma commuting substitutions 
suppose free 





lemma type substitution 
suppose 

wf locks 
wf wf 

wf wf 


wf wf 

wf wf 

eff eff 

acc lu acc 

eff eff 
lemma typing formedness 

ltyp wf cl au cl lu 

rtyp wf cl au 

styp wf styp ret cl au 
proof omit proof 
simultaneous induction assumed typing derivations 
cases result type part hypotheses result type sl sr sr sr sr sr type canonical forms lemma 
chapter analogous results established directly typing formedness lemma proof chapter 
lemma heap type formedness 
htyp wf dom dom 
furthermore dom rtyp erel 
lemma term substitution 

ret ret 

srel srel 
erel erel 

jf jf 
jf jf 

suppose 
ltyp ltyp 
rtyp rtyp 
styp styp 
proof omit proofs analogous proofs chapter trivial inductive arguments 
mention unusual cases proving lemma simultaneous induction assumed typing derivations 
case sr assumption wf useless substitution lemma ensure wf shr derive jf hlk lx hlk hxs hlk hs htyp shs shr htyp hu loc le 

hind hxs hs hu lx lr le hind hxs hs hu lx lr le styp lr srel sind hxs hs hu lx lr le hind hxs hs hu lx lr le rtyp lr erel hxs hs hu lx lr le hind hxs hs hu lx lr le ltyp lr erel lind hxs hs hu lx lr le chapter safety proof invariant result need 
case ss typing formedness lemma type canonical forms lemma ensure locks 
case induction definition substitution effects suffices derive result need 
lemma return preservation 
ret sopt ret 
lemma values effectless 

erel erel 

rtyp wf rtyp 
ltyp wf ltyp 

je je lemma access control 
suppose 
hind hxs hs hu lx lr le 

acc dom proof hind derivation heap type formedness lemma wf wf second assumption ensures lu 
type canonical forms lemma ensures loc derivation assumption provides shr loc dom 
case derivation assumption provides htyp hu heap type formedness lemma ensures dom hu 
acc ensures hind derivation ensures le 
importantly lx 
hlk assumptions means dom hxs dom 
heap type formedness lemma dom conclude dom 
lemma canonical forms 
suppose rtyp 

int 





pack 
lock loc nonlock 

lock lock lemma sharable values need sharable context 
suppose 
shr loc 
rtyp 
rtyp proof proof induction structure 
technically cases need fact part formed formed ensure wf 
sr ensures result 
inverting typing assumption ensures 
third assumption type canonical forms lemma ensure ls 
loc ensures derive desired result 
inverting typing assumption ensures styp shr 
loc show 
technically proof induction size 
context weakening lemma suffices derive desired result 
result follows induction extending static semantics 
result follows induction static semantics 
pack semantics 
result follows induction static nonlock sr ensures result 
lock sr ensures result 
lemma type release preservation 
suppose 
sopt respectively sopt respectively sopt 
sind hxs hs hu lx lr le respectively hxs hs hu lx lr le respectively lind hxs hs hu lx lr le exist xs 
sh sh 
rle 
sind xs lx le respectively xs lx le respectively lind xs lx le 
ll 

xs hxs xs hxs 
sopt ret sopt srel sopt jf sopt styp sopt proof proofs simultaneous induction derivations dynamic step proceeding cases step derivation 
hj sh 
heap change trivial letting xs hxs hs hu lock collection changes trivial letting lr 
sopt holds vacuously 
heap change lock collection changes sopt case local 
local case remains hind need provided inverting typing assumption 
suffices show hj lr srel styp respectively hj lr erel rtyp respectively hj lr erel ltyp 
inverting hind assumption assume hj lr srel styp respectively hj lr erel rtyp respectively hj lr erel ltyp 
assumptions derive obligations underlining case 
inductive cases follow similar form invoke induction hypothesis invert sind respectively lind assumption provide hind assumption type checking assumption release assumption junk assumption 
induction hypothesis apply hind assumption unchanged invert assumptions get facts need 
result induction provide result need xs result induction remains hind need provided inverting induction 
assumptions inversion derive facts need derive 
inductive cases just explain facts invoke induction hypothesis result derive facts need 
case underline facts 
dl case local 
je inverting hj ensures jf hj derive hj inverting lr erel ensures lr erel inverting ltyp ensures ltyp 
dl 
case inductive 
inverting hj ensures hj 
inverting lr erel ensures lr erel 
inverting ltyp ensures rtyp 
induction hypothesis provides erel erel rtyp ltyp 
dr 
case local 
inverting hj ensures jf hj 
inverting lr erel ensures lr 
inverting rtyp ensures acc wf access control lemma ensures dom hj 
jf hj 
hind assumptions ensure hs hu typed dom hj heap type formedness lemma ensures erel rtyp rtyp 
case term weakening lemma ensures rtyp 
dr junk 
inverting assumption ensures hj lr erel rtyp 
inverting rtyp rtyp acc 
access ensures wf control lemma ensures dom hj 
hs hu 
case hu case hs 
letting xs hxs lr sopt follow immediately assumptions 
show hind hxs lx lr le 
dom hu hind derivation assumptions provides hypotheses htyp inverting htyp hu provides htyp 
rtyp values effectless lemma ensures rtyp rtyp junk 
inverting lr erel ensures lr erel values effectless lemma ensures lr 
erel junk underlined facts derive htyp dom hs hind derivation assumptions provides hypotheses htyp sh hlk follows derivation hlk hs inverting htyp shs provides htyp sh 
rtyp values effectless lemma ensures rtyp rtyp junk 
shr know 
sharable values need sharable context lemma ensures rtyp junk 
inverting lr erel ensures lr erel values effectless lemma ensures lr 
erel junk underlined facts derive htyp sh conclude hxs lx lr le junk show rtyp lr erel 
inverting hj values effectless lemma ensures jf hj jf derive junk junk junk free 
rtyp derive rtyp junk facts inverting rtyp see derive rtyp junk 
dom hs dom hu showed lr erel derive lr erel junk dr junk inverting assumption ensures hj junk lr erel junk rtyp junk 
inverting hj junk ensures hj junk jf jf 
hs junk hu junk 
case hu case hs letting xs hxs lr sopt follow immediately assumptions 
show hind hxs lx lr le 
dom hu hind derivation assumptions provides hypotheses htyp inverting htyp hu provides htyp erel junk rtyp junk 
inverting typing release results ensures rtyp erel underlined facts derive htyp dom hs argument analogous place show hlk follows derivation hlk hs conclude hxs lx lr le show rtyp lr erel follow inversion rtyp junk lr erel junk showed hj junk jf jf derive dr case local 
je inverting hj ensures jf hj derive hj inverting lr erel ensures lr erel inverting rtyp ensures acc wf derive rtyp 
dr vi 
case local 
assume argument analogous 
values effectless lemma je inverting hj ensures jf hj jf 
derive hj 
values effectless lemma lr erel lr inverting lr erel ensures lr erel lr matter rule derives lr erel 
inverting rtyp ensures rtyp 
dr call 
case local 
values effectless lemma inverting hj ensure jf hj jf jf derive jf call call 
values effectless lemma inverting lr erel ensures lr erel srel derive erel call 
inverting rtyp ensures styp ret rtyp eff 
context weakening lemma styp ss sr derive rtyp call 
dr call return case local 
inverting hj call return ensures hj inverting lr erel call return ensures lr erel inverting rtyp call return ensures rtyp 
dr 
case local 
values effectless lemma inverting hj ensure jf hj jf term substitution lemma ensures jf hj 
values effectless lemma inverting lr erel ensure lr erel term substitution lemma ensures lr erel 
inverting rtyp ensures rtyp wf au eff 
term substitution lemma ensures rtyp 
useless substitution lemma ensures rtyp 
term weakening lemma ensures rtyp 
dr newlock pack lock ls lock 
letting xs hxs hs hu lr follow immediately 
show hind choice know dr ensures 
obligations follow inversion hind hxs hs hu lx lr le context weakening lemma heap type weakening lemma 
hxs hs hu lx lr le 
conclude hxs hs hu lx lr le show hj rtyp lr erel 
inverting hj newlock ensures jf hj 
jf conclude hj 
inverting lr erel newlock ensures lr derive lr erel 
inverting rtyp newlock ensures ls lock wf derive obligation follows note wf follows wf context weakening lemma wf rtyp lock lock rtyp pack lock ls lock ls lock ls eff ls lock au dr call call case inductive 
inverting hj call ensures hj inverting lr erel call ensures lr srel inverting rtyp call ensures styp ret induction hypothesis provides call srel erel call styp return preservation lemma ensures ret rtyp call 
dr inductive cases 

inverting hj ensures hj 
inverting lr erel ensures lr erel 
inverting rtyp ensures ltyp 
induction hypothesis provides erel erel ltyp rtyp 

inspection dynamic semantics inverting hj ensures hj jf 
similarly lr erel erel 
inverting rtyp ensures ltyp rtyp acc 
induction hypothesis provides jf erel erel erel ltyp 
term weakening lemma rtyp 
acc derive rtyp 
dr inductive cases 

inverting hj ensures hj 
inverting lr erel ensures lr erel 
inverting rtyp ensures rtyp acc 
induction hypothesis provides erel erel rtyp rtyp acc 
inverting hj ensures hj 
inverting lr erel ensures lr erel 
inverting rtyp ensures rtyp 
induction hypothesis provides erel erel rtyp rtyp 

inverting hj ensures hj je 
inverting lr erel ensures lr erel lr erel lr erel 
inverting rtyp ensures ltyp rtyp acc 
induction hypothesis provides erel erel rtyp 
term weakening lemma ltyp 
acc derive rtyp 

inverting hj ensures hj 
inverting lr erel ensures lr erel 
inverting rtyp ensures rtyp eff 
induction hypothesis provides erel erel rtyp context weakening lemma 
eff derive rtyp 
value 
inverting hj ensures hj jf 
inverting lr erel ensures lr erel erel 
inverting rtyp ensures rtyp rtyp 
induction hypothesis provides erel erel rtyp 
term weakening lemma rtyp derive rtyp 

inverting hj ensures jf hj values effectless lemma ensures je 
inverting lr erel ensures erel lr erel lr erel erel values effectless lemma ensures lr 
inverting rtyp ensures rtyp rtyp 
induction hypothesis provides erel erel rtyp 
term weakening lemma rtyp derive rtyp 
value 
inverting hj ensures hj jf 
inverting lr erel ensures lr erel erel 
inverting rtyp ensures rtyp rtyp eff 
induction hypothesis provides erel erel rtyp 

term weakening lemma rtyp derive rtyp 

inverting hj ensures jf hj values effectless lemma ensures je 
inverting lr erel ensures erel lr erel lr erel erel values effectless lemma ensures lr 
inverting rtyp ensures rtyp rtyp eff 
induction hypothesis provides erel erel rtyp 
term weakening lemma rtyp derive rtyp 

pack pack 
inverting hj pack ensures hj 
inverting lr erel pack ensures lr erel 
inverting rtyp pack ensures rtyp eff au 
induction hypothesis provides hj pack erel erel pack rtyp 
context weakening lemma ensures au 
eff derive rtyp pack 
ds 
inverting styp ensures rtyp styp 
typing formedness lemma inversion ensures lu type canonical forms lemma ensures loc lx lr le 
choice xs depends 
loc xs hxs hs hu 

xs hxs hs hu 

lx xs hxs hs hu 

xs hxs hs hu 
cases letting lr follow easily 
show hind xs lx lr le hind assumption proceeding cases 
obligations immediate htyp hu follows htyp hu heap weakening lemma rtyp loc follows loc 

obligations possible heap weakening lemma immediate hlk hs follows hlk hs heap weakening lemma htyp shs follows htyp shs heap weakening lemma rtyp sharable values need sharable context lemma shr follows shr directly derivable ls 

case case lx hlk hxs lx show lx hlk hxs 
case case hlk show hlk show jf follows jf jf prove 
sind obligations remain 
styp reordering styp 
values effectless lemma inverting lr srel ensure lr srel hj lr srel 
values effectless lemma inverting ensure jf hj jf jf cases jf 
ds 
case local 
values effectless lemma je inverting hj ensures jf hj jf 
hj 
values effectless lemma inverting lr srel ensures lr srel lr srel 
inverting styp provides styp 
ds return return case local 
inverting hj return ensures hj return inverting lr erel return ensures lr erel return inverting styp return ensures styp return ds 
case local 
je inverting hj ensures jf hj jf 
hj 
lr erel ensures lr inverting lr erel ensures erel lr srel 
inverting styp ensures styp 
ds case analogous previous 
ds 
case local 
inverting hj ensures jf hj jf jf 
jf derive hj 
inverting lr srel ensures lr erel srel 
erel derive lr srel 
inverting styp ensures rtyp int styp 
rtyp int derive styp 
ds open pack 
case local 
inverting hj ensures hj jf term substitution lemma ensures hj 
inverting lr srel ensures lr erel srel term substitution lemma ensures lr srel 
inverting styp ensures rtyp eff styp lu au 
term substitution lemma ensures styp 
typing formedness lemma ensures wf useless substitution lemma kinding ensure styp 
eff term weakening lemma ensures styp 
rtyp derive styp 
ds sync lock release hind assumption ensures hlk 
trivial induction derivation ensures write shi hlk hlk hi 
inverting lr srel sync lock ensures lr srel 
letting xs hxs hu follow immediately 
note 
show hind hxs hu lx le hind 
know jf jf shi 
argued hlk 
le hlk hs hlk hi trivial induction shows ile hlk obligations provided directly hind assumption sh shs 
conclude sind hxs hu lx le release show release styp release srel release inverting hj sync lock ensures jf hs jf hu jf 
hind assumption know jf jf hi 
derive release showed srel derive srel release inverting styp sync lock ensures rtyp lock lock locks styp 
locks derive styp release ds sync nonlock 
case local 
je nonlock inverting hj sync nonlock ensures jf hj jf 
hj 
lr erel nonlock ensures lr inverting lr srel sync nonlock ensures lr srel lr srel 
locks nonlock inverting styp sync nonlock ensures styp 
ds release values effectless lemma inverting lr srel release ensures lr srel hind assumption ensures hlk hs 
trivial induction derivation ensures write hs shi le hlk hlk hi 
letting xs hxs shi hu follow immediately 
note 
show hind hxs hu lx le hind 
values effectless lemma inverting hj release ensures jf jf hj jf hi 
jf know jf 
hlk hlk hi trivial induction shows hlk 
argued le hlk obligations provided directly hind assumption sh shs 
conclude sind hxs hu lx le show shu styp srel showed 
inverting hj ensures hj jf 
inverting lr srel ensures lr erel srel 
inverting styp ensures rtyp styp 
induction hypothesis provides erel erel rtyp term weakening lemma ensures styp styp 
open argument analogous case type checked different context 
inverting typing derivation provides lu au 
context weakening lemma ensures lu au need derive styp open 
sync argument analogous case type checked different context 
spawn value spawn 
inverting hj spawn ensures hj jf 
inverting lr srel spawn ensures lr erel erel 
inverting styp spawn ensures rtyp rtyp 
induction hypothesis provides hj spawn erel srel spawn rtyp 
term weakening lemma ensures rtyp context weakening lemma ensures derive styp spawn 
spawn spawn 
inverting hj spawn ensures jf hj values effectless lemma ensures je 
inverting lr srel spawn ensures erel lr erel lr erel erel values effectless lemma ensures lr 
inverting spawn styp ensures rtyp rtyp 
induction hypothesis provides spawn erel erel spawn rtyp 
term weakening lemma ensures rtyp context weakening lemma ensures derive styp spawn 
ds cases 

case inductive 
inverting hj ensures hj jf 
inverting lr srel ensures lr srel srel 
inverting styp ensures styp styp 
induction hypothesis provides jf srel srel srel styp 
term weakening lemma ensures styp styp 
release release inverting lr srel release ensures lr form lr lr srel 
letting le le hind assumption hypotheses easily derive hind hxs hs hu lx lr le 
inverting hj release ensures hj 
inverting styp release ensures styp 
applying induction hypothesis underlined facts provides xs hold le place le place 
induction satisfy corresponding obligations directly 
letting induction le equivalent rle obligations 
induction sind xs lx le inversion ensures hind xs lx le assumptions ensure hind xs lx le styp styp release srel srel release release 
follows form underlined facts 
lemma type release progress 

sind hxs hs hu lx lr le return exist sopt sopt 

hxs hs hu lx lr le exist sopt sopt 

lind hxs hs hu lx lr le exist sopt sopt 
proof proofs simultaneous induction typing derivations assumptions proceeding cases implied sind lind step styp rtyp ltyp derivation 
hj 
stated apply induction hypothesis assumed hind assumption unchanged inversion establish typing release junk facts necessary derive appropriate sind lind fact 
sl case trivial sl 
value canonical forms lemma ensures form dl applies 
inversion ensures hj rtyp lr erel 
result follows induction dl 
sr inverting rtyp ensures dom 
inverting hind assumption ensures htyp shs htyp hu heap type formedness lemma ensures dom dom dr applies 
sr case analogous case sl dr dl dr dl sr value canonical forms lemma ensures form dr applies 
inversion ensures hj rtyp lr erel 
result follows induction dr 
sr case trivial value 
sr 
value 
inversion ensures hj ltyp lr erel 
result follows induction dr 
sr 
values value 
value inversion ensures hj rtyp lr erel 
result follows induction dr 
inversion ensures hj values effectless lemma ensures je lr erel values effectless lemma ensures lr erel lr rtyp 
result follows induction dr 
sr 
inverting rtyp ensures dom 
inverting hind assumption ensures htyp shs htyp hu heap type formedness lemma ensures dom dom dom dr applies long 
values effectless lemma inverting hj ensures jf hj suffices show dom wf know lu 
type canonical forms lemma ensures loc loc assumption shr ensures dom htyp hu heap type formedness lemma ensure dom hu 
inverting rtyp ensures acc 
hind assumptions means le lx 
hlk assumptions dom hxs dom 
dom hj 
inversion ensures hj ltyp lr erel 
result follows induction dr 
value inverting hj ensures junk hj 
case hj hj junk ensures hj junk dr applies 
case inversion ensures rtyp lr erel result follows induction dr 
sr 
values canonical forms lemma ensures form dr applies 
value inversion ensures hj rtyp lr erel 
result follows induction dr 
inversion ensures hj values effectless lemma ensures je rtyp lr erel values effectless lemma ensures lr erel lr 
result follows induction dr 
sr call return dr applies 
know ret inversion ensures hj styp lr srel result follows induction dr 
sr 
value canonical forms lemma ensures dr applies 
inversion ensures hj rtyp lr erel 
result follows induction dr 
sr pack value value 
inversion ensures hj rtyp lr erel 
result follows induction dr 
sr cases trivial value 
sr case holds vacuously hj junk sr case trivial value 
sr rule dr applies 
ss value result immediate 
inversion ensures hj rtyp lr erel result follows induction ds 
ss case analogous previous case 
ss 
ds applies 
return ds applies 
inversion ensures hj styp lr srel 
result follows induction ds 
ss rule ds applies 
ss 
value inverting styp ensures type int canonical forms lemma ensures ds ds applies 
inversion ensures hj rtyp int lr erel result follows induction ds 
ss 
value ds applies 
inversion ensures hj rtyp lr erel result follows induction ds 
ss open 
value inverting styp open ensures existential type canonical forms lemma ensures existential package 
ds applies 
inversion ensures hj rtyp lr erel result follows induction ds 
ss sync 
value inverting styp sync ensures rtyp lock 
typing formedness lemma ensures lock lu type canonical forms lemma ensures loc 
case canonical forms lemma ensures lock ds applies long available 
statement lemma weak assuming available suffices 
case canonical forms lemma ensures nonlock ds applies 
value 
inversion ensures hj rtyp lock lr erel result follows induction ds 
ss release return ds ds applies long 
inverting lr srel release ensures lr 
inversion ensures hj styp lr srel lr lr result follows induction ds long hind hxs hs hu lx lr le le le hind assumption provides facts need note lr le 
ss spawn 
values dr applies 
value inversion ensures hj rtyp lr erel 
result follows induction ds 
inversion ensures hj values effectless lemma ensures je rtyp lr erel values effectless lemma ensures lr erel lr 
result follows induction ds 
lemma preservation 
prog threads prog 
proof proof cases rule 
case dp ln sn thread takes step 
inverting prog conditions type release preservation lemma satisfied letting hxs 
sh 

uh 
hs hu lx 
li li 
ln lr li le si lemma ensures rle sh ish 
li si rle li si 
ln sn write statement lemma writes lemma hold 
establish prog prog shown rle 
letting sh shown sh 
uh uh 

sh 
ns suffices choose js xs 
sh 
ns 
choose js possible exception xs hxs ensures lx hlk xs lx 
lj case js hind assumption provides htyp shr hlk jf 
remaining obligations involve threads thread provides obligations iu li ret follows inverting prog return preservation lemma 
thread appropriate weakening lemmas prog ensure ju htyp ju loc ju ju styp sj 
need weakening prog ensures ret sj lj srel sj 
remaining obligations involve js case provides sj derive sj 
similarly provides lj hlk 
heap weaken ing lemma fact suffices derive lj hlk js long lj exactly put js 
case dp entire argument previous case 
remains establish assumptions new thread call 
letting type release preservation lemma provides obligations thread 
trivial 
case dp li si return thread threads done 
assumptions prog suffice show prog 
li inverting li hlk ensures 
complication account fact garbage 
take ju show prog ju 
assumptions provided immediately prog 
ju iu htyp ju iu 
loc ju iu 
wf ju iu 
ju iu styp sj 
sj assumption proven induction size assumptions type check separately heap weakening lemma 
second assumption proven induction size iu assumptions loc ju loc iu 
third assumption proven induction size iu assumptions wf ju wf iu 
fourth assumption follows term weakening lemma 
fifth assumption form si assumption si values effectless lemma ensure jf 
assumption sj ensures sj 
lemma progress 
prog ln sn si return li exists li si sopt sopt 
note case subsumes situation needs added 
proof li si arbitrary thread assumption hypotheses prog conditions type release progress lemma satisfied letting hxs 
sh 

uh 
hs hu lx 
li li 
ln lr li le si cases type release progress lemma hold 
fact impossible values effectless lemma provides ret assume ret return assumption li srel values effectless lemma ensure li 
program take step dp 
remaining possibility allowed directly lemma proving 
case necessary dp dp lets program take step 
prove type soundness theorem induction length execution sequence 
trivial establish prog theorems assumptions progress lemma ensures theorem holds steps 
preservation lemma ensures state steps 
progress lemma ensures theorem holds steps 
appendix chapter safety proof appendix proves theorem repeat definition 
state stuck value return 
theorem type safety 
styp reflexive transitive closure stuck 
proof proof induction number steps reach zero steps assumptions show prog 
steps induction preservation lemma proved appendix ensure prog 
progress lemma proved appendix ensures stuck 
presenting proving necessary lemmas bottom order identify novel aspects proof give top overview proof structure 
novel proof obligations include assignments escaped locations preserve heap typing 
result follows type rvalue wf esc preservation similarly reduce difficult establish assumed typing may subsumption type check weaker context case necessarily type checks stronger context may loop 
somewhat surprisingly case heap type checks extension weaker context type checks extension 
rtyp htyp analogously left evaluation conventional preservation rtyp appropriate strong inductive proof 
specifically expressions specified evaluation order preservation requires 
fact subsumption show 
interestingly extended preservation result fails hold add sequence expressions described section 
permutation semantics result hold need safety 
ordering semantics result necessary 
weakening lemmas typing judgments allow extensions assumed typing context appear produced context 
extension result weak due specified evaluation order 
contexts extend assumed context subject technical conditions avoid variable clashes 
preservation copying loop body requires systematic renaming argue renamed copy type checks produces mention variables allocates 
progress lemma ensures typed program states stuck 
usual cases canonical forms lemma argue form values 
example value rvalue 
case st interesting derivation uses ltyp need take right expression step 
subtyping preservation lemma ensures expression typed 
case ss argue possible systematic renaming rule ds applies 
preservation lemma ensures evaluation preserves typing 
lemmas expressions tests simpler terms extend heap 
discussed expression preservation unconventional obligations 
need subtyping preservation lemma show subsumption typing derivation duplicated typing case sr assignment particularly complicated form assignment changes rvalue assignment preservation lemma argue rest heap locations continue type check 
type checking contents canonical forms lemma 
heap subsumption lemma show new rvalue approximate old subsume heap old type 
intuitively need assignments nested specified evaluation order expressions 
assignment escaped location argue heap change type 
cases sr sl need ordering transitivity lemma states ordering relationship typing contexts transitive 
interesting case test expression preservation st uses run time test refine typing information expression intuitively argue cases form st st derive typing refined type information place assignment preservation lemma ensures rest heap type checks refined information 
values effectless lemma ensure 
fact simple observations formed typing contexts typing formedness lemma ordering judgments ordering inversion lemma derive rtyp escaped 
technical lemmas show fact intuitively follows originally rvalue 
preservation statements account evaluation steps allocate memory renamed copies loop bodies 
case ss uses preservation lemma 
case ss trivial 
case ss surprisingly complicated 
statement form value elimination lemma provides interesting results 
turn lemma uses heap subsumption lemma handle subsumption typing introduced 
values effectless lemma ensures typing changes typing context subsumption 
statement form return inordinate amount bookkeeping necessary prove produce typing context return return part argument need weakening lemma ensure formed context restrict ss 
statement may form 
need weakening lemma argue type checks 
interestingly need weakening lemma 
intuitively typing subsumption produce typing context 
case ss case argue systematic renaming 
copying loop body increases number variables allocated statement assumptions prog rule ds sufficiently restrict new variables 
systematic renaming lemma ensures renamed body type checks renamed typing contexts 
restrictions renaming ensure typing contexts mention variables body binds useless renaming lemma ensures renamed body type checks unchanged typing contexts 
need weakening lemma show test type checks new variables introduced 
case ss uses value elimination lemma case ss preservation lemma case ss uses preservation lemma 
case ss allocates memory 
weakening lemma ensures heap type checks 
cases ss ss follow induction 
note interesting arguments proofs auxiliary lemmas 
proof assignment preservation lemmas establish induction applies assumed typing derivation ends sl sr 
values effectless lemma ensures shorter derivation produces weaker context assumptions sl sr ensure produces stronger context 
ordering antisymmetry lemma ensures produces context consumes induction hypothesis applies 
ordering antisymmetry lemma crucial cases subtyping preservation lemma canonical forms lemma derivations sr subsumes rvalues 
value elimination lemma proof uses values effectless lemma heap subsumption lemma show assumed heap type checks weaker context suitably extended 
show assumed statement typechecks extension need weakening lemma complicated renaming issues 
compare weakening lemma 
proof weakening lemma requires weakening lemmas 
heap subsumption lemma proof uses ordering antisymmetry lemma dismiss complications due sl sr 
values effectless lemma proof needs ordering transitivity lemma ensure multiple subsumption steps produce successively weaker results 
ordering inversion lemma typing formedness lemma obvious technical points needed proofs 
lemma typing formedness 

wf dom dom wf 
dom dom 

ltyp wf dom dom wf 
rtyp wf dom dom wf 
tst wf dom dom dom wf dom dom dom wf 
styp wf dom dom wf 
proof 
induction assumed derivation inspection rules wf 
induction assumed derivation 
proof simultaneous induction assumed typing derivations 
cases sr trivial 
cases sr sr follow induction 
case sr trivial 
case sr follows inspection rules aval differs variable aval necessary formedness hypothesis 
case sr follows induction 
case sr follows previous lemma 
case sr follows induction 
case sl trivial 
cases sl follow induction 
case sl follows previous lemma 
case sl follows induction 

proof cases assumed typing derivation 
cases st follow previous lemma inspection rules wf 
case st follows previous lemma fact wf unesc wf unesc wf unesc 
case st follows previous lemma 

proof induction assumed typing derivation 
case ss follows typing formedness lemma 
case ss follows inspection rules wf 
case ss follows invocations induction hypothesis inversion transitivity 
case ss follows previous lemma 
case ss follows previous lemma induction applied branch inversion transitivity 
case ss follows wf unesc inverting shows 
case ss follows induction typing formedness lemma 
case ss follows induction transitivity 
lemma weakening 
suppose wf 
wf wf 

wf wf 
wf wf 
wf wf wf 





ltyp wf ltyp 
rtyp wf rtyp 
tst wf dom tst 
suppose wf dom dom dom dom 
wf styp styp 
furthermore dom dom styp 

tst tst 

styp styp 
proof 
inspection assumed derivation 
inspection assumed derivation 
proof statements induction size 
proof uses previous lemma 

inspection rules 
induction derivation 
proof induction size 
trivial consequence previous lemma 
proof simultaneous induction assumed typing derivations 
cases sr sr trivial 
cases sr sr sr follow induction 
case sr follows induction weakening lemma 
case sr follows induction 
case sr follows induction weakening lemmas 
case sr follows induction weakening lemma 
case sl trivial 
cases sl follow induction 
case sl follows induction weakening lemmas 
case sl follows induction weakening lemma 
proof cases assumed typing derivation ss inversion styp styp inversion transitivity ensures 
styp induction ensures styp 
ss lets derive styp required 
suppose dom dom 
typing formedness lemma styp ensure dom dom 
dom dom 
dom know dom 
dom dom 
styp induction ensure styp 
typing formedness lemma styp ensure wf dom dom 
dom dom ensure dom 
furthermore ensures 
underlined results induction conclude styp 
showed styp 
ss lets derive styp required 
ss inversion tst styp wf previous lemma ensures tst 
assume show styp 
ss derive styp 
ss derive styp wf 
suffices show styp 
know styp 
inverting ensures 
tst typing formedness lemma ensures dom dom dom wf dom dom dom means dom dom dom 
result need styp follows induction underlined results 
ss inversion tst styp styp 
wf previous lemma ensures tst 
tst typing formedness lemma ensures dom dom dom wf 
dom dom dom ensures dom dom dom 
inverting ensures 
ensures 
applying induction underlined results ensures styp dom dom styp 
analogous argument styp dom dom styp 
ss derive results need 
ss rule ss lets derive styp unesc dom 
know wf assumed derivation implies assumption ensures assumptions dom suffice 
wf unesc ss lets derive styp 
ss inversion styp induction styp dom dom styp 
ss lets derive styp 
suppose dom dom 
styp typing formedness lemma ensure dom dom 
typing formedness lemma ensures wf 
weakening lemma ensure 
ss lets derive styp 
ss inversion styp induction styp dom dom styp 
ss derive styp 
furthermore dom dom dom dom 
case derive styp wf 
argued result holds 

inspection assumed derivation 
inspection assumed derivation lemma ordering antisymmetry 










esc 
derive 

derive 

derive 
derive 
proof prove lemmas induction assumed derivation 
transitive case invoke induction hypothesis twice appeal earlier lemmas 
sixth lemma proceed cases 
fifth lemma ensures cases trivial handled lemmas 
fourth lemma third lemma ensures cases trivial handled lemmas 
second lemma ensures cases trivial handled lemma 
lemma ensures trivial case 
prove seventh lemma cases 
prove eighth lemma cases 
prove ninth lemma induction size sixth seventh lemmas 
lemma ordering inversion 
dom 
proof induction assumed derivation lemma ordering transitivity 








proof 
inspection rules 
inspection rules suffices show esc esc ordering inversion lemma ensures result 

inspection rules 

proof induction derivation 
case immediate induction derivation esc esc 
case ordering inversion lemma ensures esc rule derive 

prove stronger result 
proof induction sizes typing formedness lemma ensures 
result trivial 
larger know form respectively 
inversion ensures 
induction ensures 
ordering transitivity lemma ensures 
ordering transitivity lemma ensures derive 
underlined results derive 
lemma values effectless 

ltyp wf 

rtyp wf 
furthermore exists 
styp wf exists wf 
proof 
proof induction assumed typing derivation sl sl sl 
case sl follows 
case sl follows induction ordering transitivity lemmas 
case sl follows induction ordering transitivity lemma 
proof induction assumed typing derivation sr sr sr 
cases sr follow 
cases sr follow previous lemma 
case sr requires inverting derivation derive 
cases sr follows induction 
case sr follows induction ordering transitivity lemmas 
sr follow induction transitivity rule rvalue ordering 

proof induction assumed typing derivation ss ss 
case ss follows previous lemma letting 
case ss inversion ensures styp induction ensures exists wf 
typing formedness lemma ensures wf 
weakening lemma ensures wf 
letting suffices 
case ss inversion ensures styp 
induction exists wf 
weakening lemma ensures 
ordering transitivity lemma ensures 
typing formedness lemma ensures dom dom wf typing formedness lemma ensure wf 
letting suffices 
lemma heap subsumption 
suppose wf wf 
ltyp ltyp 
rtyp rtyp 
dom dom htyp htyp 
proof 
proof induction derivation ltyp sl sl sl 
case sl ordering inversion lemma ensures give type sl lets derive ltyp sl lets derive ltyp case sl inversion ensures ltyp 
values effectless lemma ensures 
ordering antisymmetry lemma ensures result follows induction shorter derivation ltyp 
case sl inversion ensures ltyp 
ordering transitivity lemma ensures 
ordering transitivity lemma ensures induction know ltyp sl derive ltyp 
proof induction assumed typing derivation sr sr sr 
cases sr rule derive rtyp 
sr lets derive rtyp 
cases sr inversion ensures ltyp 
previous lemma ensures ltyp 
sr sr lets derive rtyp 
sr lets derive rtyp 
case sr follows induction 
cases sr sr analogous cases sl sl previous proof 
case sr uses values effectless lemma 
case sr uses ordering transitivity lemma transitivity rule rvalue ordering ordering transitivity lemma 
proof induction derivation htyp 
result immediate 
inversion ensures exists typing derivation ends follows htyp rtyp htyp induction hypothesis ensures htyp suffices show rtyp 
ordering inversion lemma ensures 
result follows heap subsumption lemma 
lemma value elimination 
htyp wf styp styp dom dom prog 
proof styp typing formedness lemma ensures wf 
values effectless lemma ensures exists wf 
typing formedness lemma ensures dom dom 
heap subsumption lemma ensures htyp 
lemma assumptions underlined results derive prog styp 
show weakening lemma ensures styp instantiating lemma 
key lemma distinguishes inductive proof 
wf inversion ensures wf 
show dom follows trivial induction htyp shows dom dom 
showed dom dom 
dom dom 
assumption dom 
dom 
trivially dom dom dom assumption 
showed wf 
assumption styp 
lemma applies 
lemma canonical forms 
suppose wf 

rtyp 
rtyp int 
rtyp int 
rtyp int 
rtyp int 
rtyp int 
rtyp int 
rtyp wf rtyp 
rtyp junk 
proof 
proof induction assumed derivation sr sr 
cases sr sr trivial 
cases sr follows induction 
case sr follows induction ordering antisymmetry lemmas ensure 
fact case sr impossible 

proof induction assumed derivation sr sr 
cases sr sr trivial 
case sr follows induction 
case sr follows induction ordering antisymmetry lemmas ensure 
proof induction assumed derivation sr sr 
case sr trivial 
case sr follows induction 
case sr follows induction ordering antisymmetry lemmas ensure canonical forms lemma eliminates possibility 

proof induction assumed derivation sr 
case sr follows induction 
case sr ordering antisymmetry lemmas ensure 
fact canonical forms lemma inversion know rtyp int 
result follows induction 
result follows canonical forms lemma 
result follows canonical forms lemma 
proof induction assumed derivation sr sr 
case sr inversion ensures values effectless lemma ensures ordering antisymmetry lemma ensures cases sr follow induction 
case sr follows induction ordering antisymmetry lemmas ensure 
proof induction assumed derivation sr sr 
case sr trivial 
cases sr follow induction 
case sr ordering antisymmetry lemmas ensure fact inversion know rtyp result follows induction 
canonical forms lemma ensures 
proof induction assumed derivation sr sr 
cases sr follow induction 
case sr ordering antisymmetry lemmas ensure implies 
fact inversion know rtyp result follows induction 
result follows canonical forms lemma 
result follows canonical forms lemma 
canonical forms lemma ensures 
proof induction assumed typing derivation sr sr 
case sr holds vacuously wf 
case sr holds inversion 
case sr follows induction 
case sr inversion ensures rtyp wf dom 
ordering antisymmetry lemmas ensure dom 
case wf 
induction ensures rtyp sr lets derive rtyp 

lemma corollary canonical forms lemmas ensures lemmas applies canonical forms lemma 
lemma subtyping preservation 
suppose wf 

rtyp ltyp rtyp ltyp 
ltyp rtyp ltyp exists wf esc rtyp 
rtyp rtyp rtyp exists wf esc rtyp proof 
proof induction assumed derivations sr sr 
cases sr follow inversion 
case follows induction 
case sr inversion ensures rtyp wf induction ensures ltyp appropriate 
sl lets derive ltyp case sr inversion ensures rtyp ordering antisymmetry lemmas ensure result follows induction 
ordering antisymmetry lemmas ensure result follows induction 
rtyp canonical forms lemma ensure induction ensures ltyp 
furthermore ordering antisymmetry lemma ensure esc derive 
sl lets derive ltyp 

proof induction assumed derivations sl sl 
case sl statement follows sr derive result 
second statement holds vacuously 
case sl inversion ensures ltyp wf appropriate 
induction results hold place sr lets derive typing results need 
results ordering inversion lemma ensure furthermore wf esc ensures wf esc typing context irrelevant esc 
case sl inversion ensures ltyp 
inspection ensures result follows induction 
inspection ensures 
values effectless lemma ensures 
result follows induction 
induction ensures rtyp inverting ensures esc 
typing formedness lemma ensures wf wf esc required 

lemma corollary previous lemmas 
lemma assignment preservation 
suppose wf wf 


ltyp ltyp 

rtyp rtyp 
htyp htyp proof 
proof cases assumed derivation 
rvalues typing context irrelevant 

proof induction assumed derivation 
rvalues typing context irrelevant 

proof induction assumed derivation sl sl sl 
case sl trivial 
case sl inversion ensures ltyp 
values effectless lemma ensures 
ordering antisymmetry lemma ensures result follows induction shorter derivation ltyp 
case sl follows induction changing 
case sl follows induction assignment preservation lemma sl derive result 

proof induction assumed derivation sr sr sr 
cases sr follow trivially 
cases sr follow assignment preservation lemma 
case sr follows induction sr derive result 
case sr follows argument analogous case sl previous proof 
case sr follows induction assignment preservation lemma sr derive result 

proof induction assumed derivation 
result trivial 
result follows induction assignment preservation lemma 
lemma systematic renaming 
styp dom dom wf rename rename styp rename rename 
proof proof induction assumed typing derivation omitted renaming lemmas judgments 
examples prove ensures rename rename rename rtyp ensures rename rtyp rename rename rename 
lemmas interesting 
lemma useless renaming 
wf dom dom rename 
proof induction derivation wf lemma preservation 
suppose htyp wf 
ltyp exists dom dom wf htyp ltyp 
furthermore 
rtyp exists dom dom wf htyp rtyp 
furthermore 
tst exists dom dom wf htyp tst 
suppose prog dom dom proof prog furthermore 
proof simultaneous induction assumed typing derivations proceeding cases rule 
note trivial induction ensures 
sr cases trivial rule applies 
sr 
rule dr applies sr sr depending derive rtyp int 
case derive sr lets derive rtyp int 
sr rule dr applies inverting htyp ensures rtyp required 
sr 
rule dr applies 
inversion ltyp 
induction exists wf htyp ltyp 
sr lets derive rtyp rtyp 
sr case analogous previous sr place sr place place sr 
inversion rtyp rules dr dr apply 
dr canonical forms lemma ensures subtyping preservation lemma ensures rtyp 
suffices 
dr 
induction exists wf htyp rtyp 
sr lets derive rtyp rtyp 
sr 
rules dr dr apply 
inversion rtyp 
dr subtyping preservation lemma ensures exists wf esc rtyp 
inverting wf esc ensures 
suffices 
dr argument analogous argument case sr rule sr place sr place sr 
rules dr dr apply 
inversion rtyp 
dr argument analogous argument case sr inverting wf esc ensures 
dr argument analogous argument case sr rule sr place sr place sr case analogous case sr int place 
sr 
rules dr dr applied apply 
inversion rtyp rtyp 
dr rtyp lemma assumptions suffice 
dr assume 
case completely analogous 
induction rtyp htyp 
rtyp sr lets derive rtyp 
sr 
inversion ltyp rtyp aval rules dr dr dr apply 
dr proceed cases 
values effectless lemma ensures inverting aval ensures wf inverting wf ensures wf typing formedness lemma ensures wf 
wf derive wf 
rtyp assignment preservation lemma ensures rtyp 
inverting htyp ensures htyp 
assignment preservation lemma ensures htyp 
show rtyp derive htyp 
inverting 
know rtyp 
canonical forms lemma ensures result 
letting satisfies obligation 
second obligation suppose 
heap subsumption lemma ensures htyp 
rtyp wf sr lets derive rtyp 
inverting aval ensures wf esc know wf rtyp 
remains show htyp 
htyp know dom dom 
ltyp values effectless lemma ensure dom esc 
esc wf rules wf esc ensure rtyp 
inverting 
know rtyp 
wf esc ensures canonical forms lemma ensures rtyp 
inverting htyp ensures htyp esc rtyp lets derive htyp 
dr 
induction ensures rtyp htyp 
sr ensures rtyp 
dr 
induction ensures ltyp htyp 
sr ensures rtyp 
sr case follows induction rtyp sr lets derive rtyp 
sr inversion rtyp induction exists wf htyp rtyp sr lets derive rtyp 
furthermore suppose 
ordering transitivity lemma ensure 
induction ensures assume 
sr case follows induction rtyp sr lets derive rtyp 
sl case trivial rule applies 
sl 
inversion rtyp 
rules dl dl apply 
dl canonical forms lemma ensures subtyping preservation lemma ensures ltyp 
suffices 

induction exists dl wf htyp rtyp 
sl lets derive ltyp ltyp 
sl 
inversion rtyp 
rules dl dl apply 
dl subtyping preservation lemma ensures ltyp 
suffices 
dl argument analogous argument case sl sl place sl place place sl case analogous case sr ltyp place rtyp sl case follows induction ltyp sl lets derive ltyp 
proof cases rule derive tst 
st inversion ensures rtyp dom wf 
preservation lemma ensures obligations tst 
ensures rtyp 
dom dom know dom wf 

st lets derive tst st cases similar case st 
st inversion ensures ltyp unesc unesc unesc 
typing formedness lemmas ensure unesc wf unesc wf wf 
inverting ltyp unesc ensures 
proceed cases form dr dr 
step uses dr inspection dl ensures 
similarly step uses dr inspection dl ensures 
preservation lemma ensures obligations tst 
ensures ltyp unesc 
st lets derive tst 
values effectless lemma ensures rule dr applies 
values effectless lemma ltyp unesc ensure unesc unesc 
letting inverting htyp ensures rtyp htyp 
ordering inversion lemma ensures unesc unesc unesc 
antisymmetry lemmas ensure 
canonical forms lemma ensures junk 
furthermore typing formedness lemma ensures dom dom 
established hypotheses necessary heap subsumption lemma show unesc htyp 
assignment preservation lemma ensures htyp htyp 
proceed cases 

depending sr sr lets derive rtyp 
know form inverting wf ensures wf unesc 
htyp means derive htyp 
dom dom derive dom wf 
st lets derive tst 
wf lemma holds case 

trivial induction rtyp ensures int 
sr lets derive rtyp 
htyp means derive htyp 
dom dom derive dom wf 
st lets derive tst 
wf lemma holds case 

show rtyp argument continues 
trivial induction rtyp ensures int 
values effectless lemma ensures exist 
typing formedness lemma ordering inversion lemma ensure maps 
sl sr derive rtyp 
possibly sr know rtyp 
sr lets conclude rtyp 
esc unesc unesc ordering transitivity lemma ensures unesc 
unesc derive unesc 
assignment preservation lemma ensures 
showed formedness hypotheses lemma 
ordering antisymmetry lemma ensures esc required 
st inversion ensures rtyp 
preservation lemma ensures obligations tst 
ensures rtyp st lets derive tst 

proof induction statement typing derivation inversion prog ensures styp proceeding cases rule 
ss inversion ensures rtyp ds applies 
preservation lemma ensures exists dom dom wf htyp rtyp 
ss ensures styp 
inverting ensures derive assumption 
dom dom know dom dom 
dom 
assumption dom ensures dom 
letting 
results underlined hypotheses ensure prog trivial ss case trivial rule applies 
ss 
inversion ensures exists styp styp 
ds ds ds apply 
ds 
inverting ensures letting result follows value elimination lemma 
ds return return 
trivially know return assumptions underlined results just need show styp return 
applying typing formedness lemma styp styp ensures dom dom dom wf 
dom dom dom 
dom dom dom wf ss lets derive styp return 
dom dom 
case dom dom 
inverting wf ensures wf 
wf typing formedness lemma weakening lemma ensure wf 
dom wf ss lets derive styp return 
wf ss derive styp return 
ds 
styp induction ensure prog dom dom 
inverting prog means htyp styp wf dom dom 

weakening lemma styp 
weakening lemma ensures styp 
ss lets derive styp ensure styp 
rewrite styp styp 
know 
lets derive know 
dom dom dom dom know dom 
dom know dom 
underlined results ensure prog 
obligations induction showed 
showed dom dom suffices show dom dom similarly ensures 
ss 
inversion ensures tst styp 
furthermore rule ds applies va rename dom dom wf va dom know 
systematic renaming lemma ensures va rename styp rename 
assumption htyp ensures dom dom 
dom ensure dom dom 
ensures va rename styp dom dom useless renaming lemma rename styp 
rules sr ss derive styp 
styp write equivalent va styp 
assume tst rename derivation rename styp va styp va rename styp tst rename rename styp styp styp need tst rename conclude styp 
proceed cases derivation tst exists weakening lemma tst 
cases st st inversion typing formedness lemma ensure wf dom dom 
dom dom ensures dom dom useless renaming lemma ensures rename tst suffices 
case st inversion ensures suffices show dom wf rename 
omitted systematic renaming lemma ensures rename wf rename wf wf inversion dom dom dom va ensures dom dom dom 
derive dom wf rename 
va derive va dom systematic renaming lemma ensures va 
dom know va dom va va dom 
assumption wf 
underlined results derive prog va 
furthermore va ensures va ss 
inversion ensures tst styp styp furthermore va vb ds ds apply 
va vb 
rules ds ds vb know vb 
value elimination lemma ensures prog styp show result cases derivation tst case st follows inversion ss 
cases st st apply canonical forms lemma ensure rtyp rtyp 
case st apply trivial induction shows left expression 
case st follows inversion ss 
obligations trivial vb case ds analogous case ds junk 
place va place vb place canonical forms lemmas ensure case st apply 
cases st st follow inversion ss 
ds 
preservation lemma ensures exists dom dom wf htyp tst ss lets derive styp 
va vb derive assumption 
dom dom know dom dom 
dom 
assumption dom ensures dom 
letting underlined hypotheses ensure prog 
obligations trivial dom dom ss unesc 
ds applies junk 
assumption htyp 
trivially wf unesc 
trivial inductive argument derivation htyp weakening lemma know htyp 
rule sr lets derive rtyp junk 
derive htyp 
rules sr ss derive styp 
typing formedness lemma assumptions ensure wf 
trivially dom 
inverting ensures dom ensure dom 
underlined results ensure prog 
trivially dom dom ss inverting styp ensures styp wf 
prog 
induction ensures prog dom dom ss lets derive prog 
ss inverting styp ensures styp wf 
prog 
induction ensures prog dom dom ss lets derive prog 
lemma progress 
suppose htyp wf 
ltyp exist 
rtyp exist 

tst junk exist 

styp return exist 
proof 
proof simultaneous induction assumed typing derivations proceeding cases rule sr cases trivial value 
sr rule dr applies 
sr htyp know dom 
rule dr applies 
sr 
induction case value exists case dr applies 
sr 
induction value exists 
case rule dr applies 
case canonical forms lemmas ensure rule dr applies 
sr 
induction value dr applies 
values dr applies 
sr 
induction dr applies 
induction value dr applies 
dr applies dom 
values effectless lemma ensures dom htyp ensures dom 
sr cases follow induction 
sl case trivial sl 
induction value exists 
case rule dl applies 
case canonical forms lemmas ensure rule dl applies 
sl cases follow induction 

proof cases assumed typing derivation 
case inversion ensures subject right expression typing derivation 
case st need subtyping preservation lemma fact 
previous lemma ensures take step value 
case rvalues rtyp hypotheses canonical forms lemma ensure value junk 

proof induction assumed typing derivation proceeding cases rule ss case follows rule ds progress lemma 
ss case trivial return 
ss 
typed induction ensures return take step 
ds ds ds applies 
ss rule ds applies find hypotheses rule hold 
specifically dom dom maps domain distinct hypotheses hold 
ss 
typed test progress lemma ensures take step junk 
case rule ds applies 
case ds ds applies 
ss rule ds applies dom 
form ss implies dom htyp ensures dom 
ss cases follow induction 
bibliography mart abadi luca cardelli 
theory objects 
springer verlag 
alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley 
alex aiken manuel hndrich levien 
better static memory management improving region analysis higher order languages 
acm conference programming language design implementation pages la jolla ca june 
jonathan aldrich craig chambers emin sirer susan eggers 
eliminating unnecessary synchronization java programs 
th international static analysis symposium volume lecture notes computer science pages venice italy september 
springer verlag 
glenn ammons bodik james larus 
mining specifications 
th acm symposium principles programming languages pages portland january 
lars ole andersen 
program analysis specialization programming language 
phd thesis diku university copenhagen 
andrew appel 
compiling continuations 
cambridge university press 
andrew appel 
modern compiler implementation java 
cambridge university press 
andrew appel 
foundational proof carrying code 
th ieee symposium logic computer science pages boston ma june 
andrew appel amy felty 
semantic model types machine instructions proof carrying code 
th acm symposium principles programming languages pages boston ma january 
michael ashley kent dybvig 
practical flexible flow analysis higher order languages 
acm transactions programming languages systems july 
todd austin scott breach sohi 
efficient detection pointer array access errors 
acm conference programming language design implementation pages orlando fl june 
back wilson hsieh jay lepreau 
processes isolation resource management sharing java 
th usenix symposium operating system design implementation pages san diego ca october 
back patrick leigh stoller wilson hsieh jay lepreau 
techniques design java operating systems 
usenix annual technical conference pages san diego ca june 
david bacon robert strom 
guava dialect java data races 
acm conference object oriented programming systems languages applications pages minneapolis mn october 
thomas ball sriram rajamani 
automatically validating temporal safety properties interfaces 
th international spin workshop volume lecture notes computer science pages toronto canada may 
springer verlag 
thomas ball sriram rajamani 
slam project debugging system software static analysis 
th acm symposium principles programming languages pages portland january 
anindya banerjee david naumann 
representation independence confinement access control 
th acm symposium principles programming languages pages portland january 
john barnes editor 
ada rationale volume lecture notes computer science 
springer verlag 
gregory editor 
real time specification java 
addison wesley 
nick benton andrew kennedy george russell 
compiling standard ml java bytecodes 
rd acm international conference functional programming pages baltimore md september 
brian bershad stefan savage pardyak emin sirer marc fiuczynski david becker susan eggers craig chambers 
extensibility safety performance spin operating system 
th acm symposium operating system principles pages copper mountain december 
bruno blanchet 
escape analysis object oriented languages 
application java 
acm conference object oriented programming systems languages applications pages denver november 
matthias blume 
longer foreign teaching ml compiler speak natively 
babel international workshop multi language infrastructure interoperability volume electronic notes theoretical computer science 
elsevier science publishers 
rajiv gupta vivek sarkar 
abcd eliminating array bounds checks demand 
acm conference programming language design implementation pages vancouver canada june 
hans juergen boehm mark weiser 
garbage collection uncooperative environment 
software practice experience september 
herbert bos bart 
safe kernel programming oke 
th ieee international conference open architectures network programming pages new york ny june 
don box chris sells 
essential net volume common language runtime 
addison wesley 
chandrasekhar boyapati robert lee martin rinard 
ownership types safe programming preventing data races deadlocks 
acm conference object oriented programming systems languages applications pages seattle wa november 
chandrasekhar boyapati robert lee martin rinard 
safe runtime downcasts ownership types 
technical report mit lcs tr laboratory computer science mit june 
chandrasekhar boyapati martin rinard 
parameterized type system race free java programs 
acm conference object oriented programming systems languages applications pages tampa bay fl october 
john boyland 
alias unique variables destructive reads 
software practice experience may 
kim bruce luca cardelli benjamin pierce 
comparing object encodings 
information computation 
william bush jonathan pincus david 
static analyzer finding dynamic programming errors 
software practice experience june 
david 
programming posix threads 
addison wesley 

www org 
luca cardelli peter wegner :10.1.1.117.695
understanding types data abstraction polymorphism 
computing surveys 
ccured documentation 
cs berkeley edu ccured 

plg uwaterloo ca 
emmanuel pascal bruno 
applications avec objective caml 
reilly france 
english translation currently available caml inria fr book 
satish chandra tom reps physical type checking acm workshop program analysis software tools engineering pages toulouse france september 
david chase mark wegman kenneth zadeck 
analysis pointers structures 
acm conference programming language design implementation pages white plains ny june 
benjamin chelf dawson engler seth hallem 
write static checkers metal 
acm workshop program analysis software tools engineering pages charleston sc november 
guang ien cheng feng charles leiserson keith randall andrew stark 
detecting data races cilk programs locks 
th acm symposium parallel algorithms architectures pages puerto mexico june 
jong deok choi gupta mauricio serrano sreedhar sam midkiff 
escape analysis java 
acm conference object oriented programming systems languages applications pages denver november 
jong deok choi lee robert callahan vivek sarkar sridharan 
efficient precise datarace detection multithreaded object oriented programs 
acm conference programming language design implementation pages berlin germany june 
edmund clarke jr orna grumberg doron peled 
model checking 
mit press 
christopher colby peter lee george necula fred blau 
certifying compiler java 
acm conference programming language design implementation pages vancouver canada june 
patrick cousot radhia cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
th acm symposium principles programming languages pages los angeles ca january 
crispin cowan calton pu dave maier heather hinton jonathan walpole peat steve beattie aaron perry wagle qian zhang 
stackguard automatic adaptive detection prevention buffer overflow attacks 
th usenix security symposium pages san antonio tx january 
karl crary 
foundational typed assembly language 
th acm symposium principles programming languages pages new orleans la january 
cyclone user manual 
technical report department computer science cornell university november 
current version www cs cornell edu projects cyclone 
grzegorz czajkowski thorsten von eicken 
resource accounting interface java 
acm conference object oriented programming systems languages applications pages vancouver canada october 
das lerner mark 
esp path sensitive program verification polynomial time 
acm conference programming language design implementation pages berlin germany june 
robert deline manuel hndrich :10.1.1.14.7406
enforcing high level protocols lowlevel software 
acm conference programming language design implementation pages snowbird ut june 
david detlefs rustan leino greg nelson james saxe 
extended static checking 
research report compaq systems research center december 
glen 
contextual polymorphism 
phd thesis university waterloo 
dor michael rodeh mooly sagiv 
detecting memory errors static pointer analysis preliminary experience 
acm workshop program analysis software tools engineering pages montreal canada june 
dor michael rodeh mooly sagiv 
checking linked lists 
th international static analysis symposium volume lecture notes computer science pages santa barbara ca july 
springer verlag 
dor michael rodeh mooly sagiv 
checking string manipulations programs integer analysis 
th international static analysis symposium volume lecture notes computer science pages paris france july 
springer verlag 
dawson engler benjamin chelf andy chou seth hallem 
checking system rules system specific programmer written compiler extensions 
th usenix symposium operating system design implementation pages san diego ca october 
dawson engler david chen seth hallem andy chou benjamin chelf 
bugs deviant behavior general approach inferring errors systems code 
th acm symposium operating system principles pages banff canada october 
david evans 
static detection dynamic memory errors 
acm conference programming language design implementation pages philadelphia pa may 
david evans john guttag jim horning yang meng tan 
lclint tool specifications check code 
nd acm symposium foundations software engineering pages new orleans la december 
david evans david 
improving security extensible lightweight static analysis 
ieee software january 
manuel hndrich robert deline 
adoption focus practical linear types imperative programming 
acm conference programming language design implementation pages berlin germany june 
manuel hndrich rustan leino 
non null types object oriented language 
ecoop workshop formal techniques java programs june 
published technical report computing science department university nijmegen 
feather 
formal model sequence points related issues working draft 
document iso iec jtc sc wg std dk jtc sc wg www docs html 
robert bruce findler john clements cormac flanagan matthew flatt shriram krishnamurthi paul matthias felleisen 
drscheme programming environment scheme 
journal functional programming march 
kathleen fisher riccardo pucella john reppy 
framework interoperability 
babel international workshop multi language infrastructure interoperability volume electronic notes theoretical computer science 
elsevier science publishers 
cormac flanagan 
effective static debugging componential set analysis 
phd thesis rice university 
cormac flanagan mart abadi 
object types races 
concur concurrency theory volume lecture notes computer science pages eindhoven netherlands august 
springer verlag 
cormac flanagan mart abadi 
types safe locking 
th european symposium programming volume lecture notes computer science pages amsterdam netherlands march 
springer verlag 
cormac flanagan stephen freund 
type race detection java 
acm conference programming language design implementation pages vancouver canada june 
cormac flanagan rustan leino 
houdini annotation assistant esc java 
fme formal methods increasing software productivity international symposium formal methods europe volume lecture notes computer science pages berlin germany march 
springer verlag 
cormac flanagan rustan leino mark lillibridge greg nelson james saxe raymie stata 
extended static checking java 
acm conference programming language design implementation pages berlin germany june 
cormac flanagan qadeer 
types atomicity 
acm international workshop types language design implementation pages new orleans la january 
matthew flatt robert bruce findler shriram krishnamurthi matthias felleisen 
programming languages operating systems revenge son lisp machine 
th acm international conference functional programming pages paris france september 
matthew riccardo pucella 
phantom types subtyping 
nd ifip international conference theoretical computer science pages montreal canada august 
kluwer 
jeffrey foster 
type qualifiers lightweight specifications improve software quality 
phd thesis university california berkeley 
jeffrey foster manuel hndrich alexander aiken 
theory type qualifiers 
acm conference programming language design implementation pages atlanta ga may 
jeffrey foster alex aiken 
flow sensitive type qualifiers 
acm conference programming language design implementation pages berlin germany june 
jacques didier 
semi explicit class polymorphism ml 
information computation 
david gay 
memory management explicit regions 
phd thesis university california berkeley 
david gay alex aiken 
memory management explicit regions 
acm conference programming language design implementation pages montreal canada june 
david gay alex aiken 
language support regions 
acm conference programming language design implementation pages snowbird ut june 
jean yves girard paul taylor yves lafont 
proofs types 
cambridge university press 
neal glew 
low level type systems modularity object oriented constructs 
phd thesis cornell university 
neal glew greg morrisett 
type safe linking modular assembly language 
th acm symposium principles programming languages pages san antonio tx january 
patrice godefroid 
model checking programming languages verisoft 
th acm symposium principles programming languages pages paris france january 
andrew gordon don syme 
typing multi language intermediate code 
th acm symposium principles programming languages pages london england january 
james gosling bill joy guy steele 
java language specification 
addison wesley 
dan grossman 
existential types imperative languages technical results 
technical report department computer science cornell university october 
dan grossman 
existential types imperative languages 
th european symposium programming volume lecture notes computer science pages grenoble france april 
springer verlag 
dan grossman 
type safe multithreading cyclone 
acm international workshop types language design implementation pages new orleans la january 
dan grossman greg morrisett 
scalable certification typed assembly language 
workshop types compilation volume lecture notes computer science pages montreal canada september 
springer verlag 
dan grossman greg morrisett trevor jim michael hicks wang james cheney 
region memory management cyclone 
acm conference programming language design implementation pages berlin germany june 
dan grossman greg morrisett wang trevor jim michael hicks james cheney 
formal type soundness cyclone region system 
technical report department computer science cornell university november 
dan grossman steve zdancewic greg morrisett 
syntactic type abstraction 
acm transactions programming languages systems november 
martin 
essential idl 
addison wesley 
rajiv gupta 
optimizing array bound checks flow analysis 
acm letters programming languages systems 
seth hallem benjamin chelf xie dawson engler 
system language building system specific static analyses 
acm conference programming language design implementation pages berlin germany june 
niels martin elsman mads tofte 
combining region inference garbage collection 
acm conference programming language design implementation pages berlin germany june 
hamid zhong shao trifonov stefan ni 
syntactic approach foundational proof carrying code 
th ieee symposium logic computer science pages copenhagen denmark july 
david hanson 
fast allocation deallocation memory object lifetimes 
software practice experience january 
samuel harbison 
modula 
prentice hall 
samuel harbison guy steele 
manual fifth edition 
prentice hall 
robert harper 
simplified account polymorphic 
information processing letters august 
robert harper peter lee frank pfenning 
fox project advanced language technology extensible systems 
technical report cmu cs school computer science carnegie mellon university january 
reed hastings bob joyce 
purify fast detection memory leaks access errors 
winter usenix conference pages san francisco ca january 
chris hawblitzel thorsten von eicken 
luna flexible java protection system 
th usenix symposium operating system design implementation pages boston ma december 
mark hayden 
ensemble system 
phd thesis cornell university 
mark hayden 
distributed communication ml 
journal functional programming january 
fritz henglein 
type inference polymorphic recursion 
acm transactions programming languages systems april 
fritz henglein henning henning niss 
direct approach control flow sensitive region memory management 
acm international conference principles practice declarative programming pages florence italy september 
thomas henzinger majumdar george necula gr weimer 
temporal safety proofs systems code 
th international conference computer aided verification volume lecture notes computer science pages copenhagen denmark july 
springer verlag 
thomas henzinger majumdar gr 
lazy abstraction 
th acm symposium principles programming languages pages portland january 
michael hicks nagarajan robbert van renesse 
user specified adaptive scheduling streaming media network 
th ieee international conference open architectures network programming pages san francisco ca april 
gerard holzmann 
logic verification ansi code spin 
th international spin workshop volume lecture notes computer science pages stanford ca august 
springer verlag 
gerard holzmann 
static source code checking user defined properties 
world conference integrated design process technology pasadena ca june 
society design process science 
wilson hsieh marc fiuczynski charles garrett stefan savage david becker brian bershad 
language support extensible operating systems 
workshop compiler support system software pages tucson az february 
peter hearn 
bi assertion language mutable data structures 
th acm symposium principles programming languages pages london uk january 
iso iec international standard programming languages international standards organization 
suresh jagannathan stephen weeks 
unified treatment flow analysis higher order languages 
nd acm symposium principles programming languages pages san francisco ca january 
jikes tm research virtual machine user guide 
www ibm com developerworks oss jikesrvm 
trevor jim greg morrisett dan grossman michael hicks james cheney wang 
cyclone safe dialect usenix annual technical conference pages monterey ca june 
stephen johnson 
lint program checker 
computer science technical report bell laboratories december 
neil jones steven muchnick 
flexible approach interprocedural data flow analysis programs recursive data structures 
th acm symposium principles programming languages pages albuquerque nm january 
richard jones paul kelly 
backwards compatible bounds checking arrays pointers programs 

third international workshop automatic debugging volume link ping electronic articles computer information science link ping sweden 
simon peyton jones john hughes editors 
haskell non strict purely functional language 
www haskell org 
simon peyton jones norman ramsey 
portable assembly language supports garbage collection 
international conference principles practice declarative programming volume lecture notes computer science pages paris france september 
springer verlag 
brian kernighan dennis ritchie 
programming language nd edition 
prentice hall 
kfoury jerzy tiuryn urzyczyn 
type reconstruction presence polymorphic recursion 
acm transactions programming languages systems april 
ahmed keshav pingali 
data centric multi level blocking 
acm conference programming language design implementation pages las vegas nv june 
vikram adve 
ensuring code safety runtime checks real time control systems 
acm international conference compilers architectures synthesis embedded systems pages grenoble france october 
dexter kozen 
efficient code certification 
technical report department computer science cornell university january 
konstantin ufer 
type classes existential types 
journal functional programming may 
lclint user guide version 
splint org guide 
xavier leroy 
unboxed objects polymorphic typing 
th acm symposium principles programming languages pages albuquerque nm january 
xavier leroy 
effectiveness type unboxing 
workshop types compilation amsterdam netherlands june 
technical report boston college computer science department 
xavier leroy 
objective caml system release documentation user manual 
caml inria fr ocaml index html 
sheng liang 
java native interface 
addison wesley 
tim lindholm frank yellin 
java virtual machine specification 
addison wesley 
barbara liskov clu manual 
springer verlag 
hsi yong susan horwitz thomas reps debugging run time type checking 
th international conference fundamental approaches software engineering volume lecture notes computer science pages genoa italy april 
springer verlag 
ma john reynolds 
types abstraction parametric polymorphism part 
mathematical foundations programming semantics volume lecture notes computer science pages pittsburgh pa march 
springer verlag 
raymond mak 
sequence point analysis 
document iso iec jtc sc wg std dk jtc sc wg www docs html 
greg 
bounds checking projects 
www gnu org software gcc projects bp main html 
robin milner mads tofte robert harper david macqueen 
definition standard ml revised 
mit press 
minamide greg morrisett robert harper 
typed closure conversion 
rd acm symposium principles programming languages pages st petersburg fl january 
john mitchell gordon plotkin 
types existential type 
acm transactions programming languages systems july 
mlton program optimizing compiler standard ml 
www mlton org 
stefan saha zhong shao 
principled scavenging 
acm conference programming language design implementation pages snowbird ut june 
greg morrisett 
compiling types 
phd thesis carnegie mellon university 
greg morrisett karl crary neal glew dan grossman richard samuels frederick smith david walker stephanie weirich steve zdancewic 
talx realistic typed assembly language 
nd acm workshop compiler support system software pages atlanta ga may 
published inria technical report march 
greg morrisett karl crary neal glew david walker 
stack typed assembly language 
journal functional programming january 
greg morrisett david walker karl crary neal glew 
system typed assembly language 
acm transactions programming languages systems may 
steven muchnick 
advanced compiler design implementation 
morgan kaufmann publishers 
david park andy chou dawson engler david dill 
cmc pragmatic approach model checking real code 
th usenix symposium operating system design implementation pages boston ma december 
george necula 
proof carrying code 
th acm symposium principles programming languages pages paris france january 
george necula 
compiling proofs 
phd thesis carnegie mellon university 
george necula peter lee 
design implementation certifying compiler 
acm conference programming language design implementation pages montreal canada june 
george necula peter lee 
efficient representation validation proofs 
th ieee symposium logic computer science pages indianapolis june 
george necula scott weimer 
ccured type safe retrofitting legacy code 
th acm symposium principles programming languages pages portland january 
george necula rahul 
oracle checking untrusted software 
th acm symposium principles programming languages pages london england january 
flemming nielson hanne riis nielson chris hankin 
principles program analysis 
springer verlag 
michael 
formalised hol 
phd thesis university cambridge 
michael 
deterministic expressions th european symposium programming volume lecture notes computer science pages amsterdam netherlands march 
springer verlag 
paek jay david padua 
efficient precise array access analysis 
acm transactions programming languages systems january 
patel jay lepreau 
hybrid resource control active extensions 
th ieee international conference open architectures network programming pages san francisco ca april 
bruce 
electric fence 
www gnu org directory packages directory html 
benjamin pierce 
programming intersection types bounded polymorphism 
phd thesis carnegie mellon university 
benjamin pierce davide sangiorgi 
behavioral equivalence polymorphic pi calculus 
journal acm 
benjamin pierce david turner 
local type inference 
th acm symposium principles programming languages pages san diego ca january 
pugh 
omega test fast practical integer programming algorithm dependence analysis 
communications acm august 
hugh 
formalism sequence points 
document iso iec jtc sc wg std dk jtc sc wg www docs html 
john reynolds 
theory type structure 
programming symposium volume lecture notes computer science pages paris france april 
springer verlag 
john reynolds 
types abstraction parametric polymorphism 
information processing pages paris france september 
elsevier science publishers 
jonathon rees eds 
richard kelsey william clinger 
revised report algorithmic language scheme 
higher order symbolic computation september 
radu martin rinard 
symbolic bounds analysis pointers array indices accessed memory regions 
acm conference programming language design implementation pages vancouver canada june 
mooly sagiv thomas reps reinhard wilhelm 
solving shape analysis problems languages destructive updating 
acm transactions programming languages systems january 
stefan savage michael burrows greg nelson patrick sobalvarro thomas anderson 
eraser dynamic data race detector multithreaded programs 
acm transactions computer systems november 
olin shivers 
control flow analysis higher order languages taming lambda 
phd thesis carnegie mellon university 
satish chandra thomas ball krishna thomas reps coping type casts th european software engineering conference th acm symposium foundations software engineering pages toulouse france september 
emin sirer stefan savage pardyak greg defouw mary ann brian bershad 
writing operating system modula 
workshop compiler support system software pages tucson az february 
fred smith david walker greg morrisett 
alias types 
th european symposium programming volume lecture notes computer science pages berlin germany march 
springer verlag 
geoffrey smith dennis volpano 
ml style polymorphic type system th european symposium programming volume lecture notes computer science pages link ping sweden april 
springer verlag 
geoffrey smith dennis volpano 
sound polymorphic type system dialect science computer programming 
splint manual version 
www splint org manual 
bjarne steensgaard 
points analysis linear time 
rd acm symposium principles programming languages pages st petersburg fl january 
nicholas sterling 
static date race analysis tool 
usenix winter technical conference pages san diego ca january 
christopher strachey 
fundamental concepts programming languages 
unpublished lecture notes summer school computer programming august 
bjarne stroustrup 
programming language special edition 
addison wesley 
tucker taft robert duff editors 
ada manual volume lecture notes computer science 
springer verlag 
david tarditi 
design implementation code optimizations type directed compiler standard ml 
phd thesis carnegie mellon university 
glasgow haskell compiler user guide version 
www haskell org ghc 
hugs user manual 
haskell cs yale edu hugs 
mads tofte 
type inference polymorphic 
information computation november 
mads tofte lars birkedal 
region inference algorithm 
acm transactions programming languages systems july 
mads tofte lars birkedal martin elsman niels tommy olesen peter sestoft 
programming regions ml kit version 
technical report university copenhagen september 
mads tofte jean pierre talpin 
region memory management 
information computation february 
david turner philip wadler christian mossin 
type 
th international conference functional programming languages computer architecture pages la jolla ca june 
thorsten von eicken chi chao chang grzegorz czajkowski chris hawblitzel hu dan 
kernel capability operating system java 
secure internet programming security issues mobile distributed objects volume lecture notes computer science 
springer verlag 
christoph von praun thomas gross 
object race detection 
acm conference object oriented programming systems languages applications pages tampa bay fl october 
philip wadler 
theorems free 
th international conference functional programming languages computer architecture pages london england september 
acm press 
philip wadler 
linear types change world 
broy jones editors programming concepts methods sea israel april 
north holland 
ifip tc working conference 
david wagner 
static analysis computer security new techniques software assurance 
phd thesis university california berkeley 
david wagner jeffrey foster eric brewer alexander aiken 
step automated detection buffer overrun vulnerabilities 
networking distributed system security symposium pages san diego ca february 
robert wahbe steven lucco thomas anderson susan graham 
efficient software fault isolation 
acm sigops operating systems review december 
david walker 
typed memory management 
phd thesis cornell university 
david walker karl crary greg morrisett 
typed memory management calculus capabilities 
acm transactions programming languages systems july 
david walker greg morrisett 
alias types recursive data structures 
workshop types compilation volume lecture notes computer science pages montreal canada september 
springer verlag 
david walker kevin watkins 
regions linear types 
th acm international conference functional programming pages florence italy september 
daniel wang andrew appel 
type preserving garbage collectors 
th acm symposium principles programming languages pages london england january 
stephanie weirich 
programming types 
phd thesis cornell university 
joe wells 
typability type checking system equivalent undecidable 
annals pure applied logic june 
joe wells allyn robert muller turbak 
calculus polymorphic polyvariant flow types 
journal functional programming may 
andrew wright robert cartwright 
practical soft type system scheme 
acm transactions programming languages systems january 
andrew wright matthias felleisen 
syntactic approach type soundness 
information computation 
writing efficient numerical code objective caml 
caml inria fr ocaml numerical html 
hongwei xi 
dependent types practical programming 
phd thesis carnegie mellon university 
hongwei xi 
imperative programming dependent types 
th ieee symposium logic computer science pages santa barbara ca june 
hongwei xi robert harper 
dependently typed assembly language 
th acm international conference functional programming pages florence italy september 
hongwei xi frank pfenning 
eliminating array bound checking dependent types 
acm conference programming language design implementation pages montreal canada june 
hongwei xi frank pfenning 
dependent types practical programming 
th acm symposium principles programming languages pages san antonio tx january 
xu 
safety checking machine code 
phd thesis university wisconsin madison 
xu bart miller tom reps safety checking machine code 
acm conference programming language design implementation pages vancouver canada june 
xu tom reps bart miller 
typestate checking machine code 
th european symposium programming volume lecture notes computer science pages genoa italy april 
springer verlag 
yong susan horwitz 
reducing overhead dynamic analysis 
nd workshop runtime verification volume electronic notes theoretical computer science pages copenhagen denmark july 
elsevier science publishers 
