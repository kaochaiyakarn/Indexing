type system equivalent model checker stanford university jens palsberg ucla type systems model checking prevalent approaches program verification 
prominent difference type systems typically defined syntactic modular style model checking usually performed semantic program style 
difference approaches lends complementary type systems explaining program accepted model checkers explaining program rejected 
type system equivalent model checker verifying temporal safety properties imperative programs 
model checker natural may instantiated finite state abstraction scheme predicate abstraction 
type system parametric type checks exactly programs accepted model checker 
uses function types capture flow sensitivity intersection union types capture context sensitivity 
result sheds light relationship approaches provides methodology studying relative expressiveness step sharing results motivates synergistic program analyses involving interplay 
background type systems model checking prevalent approaches program verification 
known approaches essentially interpretations closely related 
despite deep connections prominent difference type systems typically defined syntactic modular style type rule syntactic construct model checking usually performed semantic program style exploring reachable state space model program 
difference type systems model checking significant consequence lends approaches complementary type systems better explaining program accepted model checkers better explaining program rejected 
type inference algorithm accepts program annotates types keywords syntactic modular explaining accepted 
benefits type annotations known aid understanding modifying reusing certifying program 
unnatural explain program rejected type inference algorithm large body explaining source type errors especially context type inference algorithms languages higher order functions haskell miranda ml languages concurrency java :10.1.1.5.4871:10.1.1.46.4848
hand model checker rejects program provides counterexample program trace keywords semantic program explains program rejected 
benefits counterexamples known aid debugging program 
unnatural explain program accepted model checker proof systems model checkers devised 
complementary nature type systems model checking motivates investigating relationship approaches devising methodology studying relative expressiveness sharing results designing synergistic program analyses involving interplay 
result type system equivalent model checker verifying temporal safety properties imperative programs 
model checking terminology safety property temporal property violation witnessed finite program trace equivalently failure assertion program point 
model checker natural may instantiated finite state abstraction scheme predicate abstraction :10.1.1.39.1920
type system parametric type checks exactly programs accepted model checker 
uses function types capture flow sensitivity intersection union types capture context sensitivity 
implications result may summarized follows 
sheds light relationship type systems model checking 
particular shows straightforward form model checking corresponds complex form typing 
finite state model checkers routinely associate statement program set form ranges finite set contexts partial function called transfer function associated intuitively set says begins executing context finish executing context 
example model checkers slam blast magic represents set valuations finite set predicates respect predicate abstraction model program constructed 
likewise type system assigns statement program finitary polymorphic type form bi bi finite 
complex form typing 
conventional type systems employ restricted cases form typing ones requiring intersection types bi union types 

provides methodology studying relative expressiveness type system model checker 
technique proving equivalence novel general successfully applied additional settings stack size analysis deadline analysis class real time programs called programs :10.1.1.142.8630

step sharing results type systems model checking communities 
backward direction equivalence theorem states model checker accepts program program typed 
prove building type derivation model constructed model checker 
obtain model checking type inference algorithm type system 

motivates synergistic program analyses involving interplay type system model checker 
analyses types document correct programs counterexamples explain erroneous programs 
implemented efficiently due correspondence types models types existing program inferred type inference algorithm construct model performing model checking illustrated conversely model constructed model checker infer types shown 
proof architecture overview technique proving equivalence 
typical type soundness theorem states typed programs go wrong 
usually going wrong formalized getting stuck operational semantics 
formally program initial concrete environment initial environment type soundness states typed go wrong concrete semantics 
type checking requires predefined set abstractions types 
existence derivable type judgment implies program desired property 
model checking hand concerned types 
works model semantics answer questions go wrong semantics 
model checking soundness states go wrong semantics go wrong concrete semantics 
equivalence result states typed iff go wrong semantics 
prove forward direction variant type soundness step relation semantics concrete semantics prove backward direction constructively building type derivation model constructed model checker 
important note prove soundness type system model checker 
equivalence result guarantees type system sound iff model checker sound prevent unsound 
proving soundness require define concrete semantics instantiate type system model checker recall parametric 
turn detract generality equivalence result 
rest section imperative language model checker verifying temporal safety properties expressed assertions language 
section type system equivalent model checker 
section prove equivalence result 
section illustrate equivalence means examples 
section discuss related 
section conclude note 
model checker syntax imperative language follows stmt assume assert statement primitive statement instance assignment statement skip statement assume statement assert statement sequential composition statements branching statement looping statement 
sake generality leave primitive statements boolean expressions uninterpreted 
syntax branching looping statements standard literature model checking 
related familiar syntax statements follows assume assume assume assume denotes non deterministic choice denotes negation model checker verifying temporal safety properties programs expressed language 
class temporal safety properties precisely class properties violation witnessed finite program trace equivalently failure assertion program point 
model checker conventional parameterized components finite set contexts 
transfer function primitive statement describing effect contexts 
assume total 
predicate boolean expression denoting set contexts true 
components may instantiated finite state abstraction scheme 
instance scheme predicate abstraction set valuations finite set predicates respect predicate abstraction program constructed 
convenience treat set indices contexts 
range denote corresponding contexts indexed 
semantics model checker 
state stuck kind state get stuck form assert state goes wrong stuck 
program context model checker determines goes wrong 
goes wrong reports counterexample finite trace assert returns finite set reachable states serves proof concrete program go wrong provided model checker sound 
model checking soundness typically proved showing semantics simulates concrete semantics see example 
type system type system assigns type form bi statement program bi subsets 
recall finite type state error assume assume error assert error error semantics finitary 
intuitively type states safe executing statement contexts furthermore begins executing context finish executing contexts bi 
type system includes type handle case empty type handle case bi empty 
type rules shown 
say state typed statement assigned type states safe executing context see rule 
rule type checks primitive statement type captures effect transfer function associated side condition rule states safe executing context assumed total function 
rule type checks statement assume 
side condition rule says safe executing assume context conjunct type states effect skip statement begins executing context true second conjunct type states exist context finishes executing begins executing context false 
rule type checks statement assert 
side condition rule says bi typed assume assert bi bi bi bi bi bi bj bi denotes fixed point function type rules safe executing assert context true type states effect skip statement begins executing context 
rule type checks sequentially composed statements 
side condition says safe executing contexts safe executing begins executing context safe executing context finish executing 
rule type checks branching statements 
side condition says safe executing contexts safe executing 
rule type checks looping statements 
side condition says safe executing contexts safe executing begins executing context safe executing context finish executing 
denote fixed point function type states loop begins executing context finish executing contexts 
bj base case iterations loop finish executing context began executing ii inductive case iterations loop finish executing contexts bj context loop finish executing iterations case th iteration executing context finish executing contexts bj 
equivalence section prove program type checks model checker accepts 
proof type checking model checking similar type soundness consisting progress lemma type preservation lemma key difference step relation semantics model checker concrete semantics language 
lemma progress typed stuck 
proof 
see appendix 
lemma type preservation typed typed 
proof 
see appendix 
straightforward prove program type checks accepted model checker 
lemma type checking model checking typed go wrong 
proof 
suppose typed 
need prove implies stuck 
suppose typed lemma typed 
typed lemma stuck 
proof model checking type checking constructive involves building type derivation model constructed model checker 
definitions show construct types model 
definition go wrong definition statement define follows bs bs assume assert bs assume assert bs bs bs bs bs 
bs key lemma involves showing constructed types yield valid type derivation 
proved induction structure program 
lemma typability 
proof 
see appendix 
straightforward prove program accepted model checker type checks 
lemma model checking type checking go wrong typed 
proof 
lemma bs 
go wrong defn 
bs rule typed 
main result states program type checks model checker accepts 
theorem equivalence typed go wrong 
proof 
combine lemma lemma 
examples section illustrate equivalence result means examples 
example 
consider program lock lock lock assert denote unlocked locked states respectively 
suppose model checker instantiated predicate abstraction case set program predicates say 
easy see state goes wrong semantics typed type system 
result model checker type system reject 
notice state typed type system statement typable see lemma 
instance typed type 
example motivates need making statement typable need type 
example 
consider program lock assume false lock assuming predicate abstraction previous example easy see state go wrong semantics 
lock rendered unreachable state semantics assume false statement result model checker analyze lock 
type system type check code including code dead 
particular assign type lock 
uses type purpose 
type derivation illustrating typed follows lock assume false lock assume false lock example 
consider program assume assume suppose abstraction scheme predicate abstraction suppose 
states go wrong semantics likewise typed type system type 
instance type derivation illustrating state typed follows assume assume assume assume model checker type system accept states related years significant surge interest type systems checking temporal safety properties imperative programs :10.1.1.24.8366:10.1.1.14.7406
instance consider program example type type system instantiated set contexts 
supports specialized type system annotated constrained polymorphic type 
ref int ref int ref singleton type type location int singleton integer type type integer constant singleton types unusual type systems languages xanadu vault type systems alias types refinement types :10.1.1.1.5638:10.1.1.1.5638:10.1.1.14.7406
large body bridging different approaches static analysis notably relating type systems control flow analysis higher order functional languages ii relating data flow analysis model checking order imperative languages 
type systems control flow analysis 
amadio cardelli type system recursive types subtyping shown equivalent certain cfa safety analysis palsberg keefe certain form constrained types palsberg smith unifying different views typing :10.1.1.33.8725:10.1.1.36.3559
heintze proves restrictions cfa equivalent type systems parameterized recursive types subtyping 
palsberg shows equality cfa equivalent type system recursive types unusual notion subtyping 
palsberg turbak show class finitary polyvariant control flow analyses equivalent type system finitary polymorphism form union intersection types 
mossin presents sound complete type flow analysis predicts redex exists reduction sequence redex reduced 
mossin approach uses intersection types annotated flow information related approach flow analysis banerjee 
data flow analysis model checking 
schmidt steffen relate dataflow analysis model checking order imperative languages 
show information computed classical iterative data flow analyses obtained model checking certain modal mu calculus formulae program trace interpretation operational semantics representation program computation tree traces 
type system equivalent model checker verifying temporal safety properties imperative programs 
result highlights essence relationship type systems model checking provides methodology studying relative expressiveness step sharing results motivates synergistic program analyses gain advantages approaches suffering drawbacks 
limitations current language lacks features higher order functions objects concurrency type information extracted model constructed model checker may suitable human reasoning 
intend explore issues context specific verification problems 
acknowledgments originally proved equivalence result setting deadline analysis problem interrupt calculus 
result author master thesis :10.1.1.142.8630
people suggested prove result conventional setting 
proof technique remains essentially 
alex aiken jakob rehof useful discussions 
earlier version appeared th european symposium programming esop 
anonymous esop reviewers insightful comments 
supported national science foundation itr award number 
appendix lemma progress typed stuck 
proof 
induction structure cases depending form 
cases hypothesis typed 

immediate rule fact 

assume 
immediate rules 

assert 
typed rule bi bi rule rule stuck 


typed rule bi bi rule 

rule typed 
typed induction hypothesis stuck 
stuck cases depending form case prove stuck 
rule error 
rule error 
rule 

immediate rules 

immediate rules 
lemma bi bm 
proof 
case analysis rule cases depending rules 
rule 

bi rule bi 
bi bm 
bm bm 
rule 
assume assume bi rule bi bi 
bi bi bm 
bm bm 
rule 
assert assert bi rule bi 
bi bm 
bm bm 
rule 
bi rule bi 
bi bm 
bm bm 
lemma fi fn dm 
di proof 
induction structure cases depending rules 
rule 

di rule bi bi bi di bi choose fi prove fi fn dm 
fi fi 

rule bi lemma bm 
bm bi fn bm bm dm 
rule 

rule di bi bi bi di bi 
rule bi induction hypothesis bm 
choose fi prove fi fn dm 
bm rule 
fi fi 
fn dm bm bm 
rule 
di rule bi bi di bi choose fi bi 
prove fi fn dm 
bi fi bi fi 
fn bn bm bm dm 

rule 
proof similar item 

rule 
di rule bi bj bi di 
bj 
choose fi bi 
bk 
prove fi fn dm 
bi bj bi rule bk bi 
bk bi fi bi 
bk fi 
fn bn 
bk 
bn bk 
bn bk 
bj 
bj dm lemma single step type preservation typed typed 
proof 
typed rule bi bi lemma 
rule typed 
lemma multi step type preservation typed typed 
proof 
induction lemma 
proposition proposition lemma proof 
induction structure cases depending form 
defn 

rule 
assume 
defn 
rule 
assert 
proof similar item 


defn 
induction hypothesis prop 
induction hypothesis 

defn 
suppose 
proof case similar 
rule induction hypothesis 
defn 
bt bt bt prove bt proof induction base case trivial 
prove induction step suppose bt 
defn 
bt bt 
bt induction hypothesis induction rule induction hypothesis induction prop 
completes proof 
bs bs bt bt bt bt rule lemma bs bs proof 
consider defn 
go wrong 
consider need prove lemma prop 
go wrong go wrong 
go wrong defn 
consider need prove rule lemma prop 
go wrong go wrong 
go wrong defn 
lemma typability 
proof 
induction structure cases depending form defn 
rule 
defn 
bs 
bs rule bs 
assume 
defn 
rules 
defn 
bs bs 
bs bs rule bs 
assert 
defn 
rule defn 
bs 
bs rule bs 

induction hypothesis bs 
bs 
prop 
lemma bs defn 

bs bs bs rule bs 

induction hypothesis bs bs 
prop 
defn 
bs bs bs rule bs 

induction hypothesis bs 
prop 
lemma bs defn 

bs bs bs rule bs 
roberto amadio luca cardelli :10.1.1.33.8725
subtyping recursive types 
acm transactions programming languages systems 
torben turbak 
faithful translations polyvariant flows polymorphic types 
proceedings esop european symposium programming pages 
springer verlag lncs 
thomas ball sriram rajamani 
slam project debugging system software static analysis 
proceedings popl acm symposium principles programming languages pages 
anindya banerjee 
modular polyvariant type closure analysis 
proceedings icfp acm international conference functional programming pages 
mike ryan 
explaining type errors polymorphic languages 
acm letters programming languages systems 
chaki edmund clarke alex jha helmut veith 
modular verification software components proceedings international conference software engineering icse pages may 
chaki sriram rajamani jakob rehof 
types models model checking message passing programs 
proceedings popl acm symposium principles programming languages pages 
olaf 
compositional explanation types algorithmic debugging type errors 
proceedings icfp th acm sigplan international conference functional programming pages 
patrick cousot 
types interpretations 
proceedings popl acm symposium principles programming languages pages 
patrick cousot radhia cousot 
temporal interpretation 
proceedings popl acm sigplan sigact symposium principles programming languages pages 
mourad 
synergy modelchecking type inference verification value passing higher order processes 
proceedings amast th international conference algebraic methodology software technology pages 
robert deline manuel fahndrich :10.1.1.14.7406
enforcing high level protocols low level software 
proceedings pldi acm sigplan conference programming language design implementation pages 
dominic duggan frederick bent :10.1.1.14.7406
explaining type inference 
science computer programming 
cormac flanagan stephen freund 
type inference races 
proceedings sas international static analysis symposium 
cormac flanagan stephen freund marina 
type inference atomicity 
proceedings acm sigplan workshop types language design implementation january 
jeffrey foster alexander aiken 
flow sensitive type qualifiers 
proceedings pldi acm sigplan conference programming language design implementation pages 
susanne graf saidi :10.1.1.39.1920
construction state graphs pvs 
proceedings cav th international conference computer aided verification pages 
christian joe wells 
type error slicing implicitly typed higher order languages 
proceedings esop th european symposium programming pages 
nevin heintze 
control flow analysis type systems 
proceedings sas international static analysis symposium pages 
springer verlag lncs glasgow scotland september 
thomas henzinger majumdar george necula weimer 
temporal safety proofs systems code 
proceedings cav th international conference computer aided verification pages 
thomas henzinger majumdar 
software verification blast 
proceedings spin th international workshop model checking software 
springer verlag lncs 
atsushi igarashi naoki kobayashi 
resource usage analysis 
proceedings popl sigplan sigact symposium principles programming languages pages 
gregory johnson janet walz 
flow approach anomaly isolation unification incremental type inference 
proceedings popl th acm symposium principles programming languages pages 
di ma 
bounding stack size interrupt driven programs 
phd thesis purdue university 
david walker robert harper 
effective theory type refinements 
proceedings icfp acm international conference functional programming 
robin milner 
theory type polymorphism programming 
journal computer system sciences 
christian mossin 
exact flow analysis 
proceedings sas international static analysis symposium pages 
springer verlag lncs 
:10.1.1.142.8630
type system equivalent model checker 
master thesis purdue university 
kedar :10.1.1.142.8630
certifying model checkers 
proceedings cav th international conference computer aided verification pages 
kedar 
lifting temporal proofs abstractions 
proceedings pages 
jens palsberg 
equality flow analysis versus recursive types 
acm transactions programming languages systems 
jens palsberg di ma 
typed interrupt calculus 
th international symposium formal techniques real time fault tolerant systems pages 
springer verlag lncs oldenburg germany september 
jens palsberg patrick keefe :10.1.1.36.3559
type system equivalent flow analysis 
acm transactions programming languages systems july 
jens palsberg christina 
polyvariant flow information intersection union types 
journal functional programming may 
jens palsberg scott smith 
constrained types expressiveness 
acm transactions programming languages systems september 
doron peled amir pnueli zuck :10.1.1.36.3559
falsification verification 
proceedings st conference foundations software technology theoretical computer science pages 
doron peled zuck 
model checking temporal proof 
proceedings spin th international workshop model checking software pages 
david schmidt bernhard steffen 
program analysis model checking interpretations 
proceedings sas static analysis symposium pages 
springer verlag lncs 
david schmidt 
data flow analysis model checking interpretations 
proceedings popl th acm sigplan sigact symposium principles programming languages pages 
bernhard steffen 
data flow analysis model checking 
ito meyer editors proceedings tacs theoretical aspects computer science pages 
springer verlag lncs 
li tan rance cleaveland 
evidence model checking 
proceedings cav th international conference computer aided verification pages 
frank tip dinesh 
slicing approach locating type errors 
acm transactions software engineering methodology 
david walker greg morrisett :10.1.1.1.5638
alias types recursive data structures 
proceedings tic rd international workshop types compilation pages 
mitchell wand 
finding source type errors 
thirteenth symposium principles programming languages pages 
hongwei xi :10.1.1.1.5638
imperative programming dependent types 
proceedings lics fifteenth ieee symposium logic computer science pages 
ieee computer society press 

