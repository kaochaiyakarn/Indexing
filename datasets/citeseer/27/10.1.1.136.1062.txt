computing shortest path search meets graph theory andrew goldberg chris march technical report msr tr study problem finding shortest path vertices directed graph 
important problem applications including computing driving directions 
allow preprocessing graph linear amount extra space store auxiliary information information answer shortest path queries quickly 
approach uses search combination new graph theoretic lower bounding technique landmarks triangle inequality 
develop new bidirectional variants search investigate variants new algorithms find efficient practice 
algorithms compute optimal shortest paths directed graph 
give experimental results showing efficient new algorithms outperforms previous algorithms particular search euclidean bounds wide margin road networks 
experiment synthetic graph families 
microsoft research microsoft microsoft way redmond wa www research microsoft com microsoft research la mountain view ca 
email goldberg microsoft com url www com andrew index html 
computer science division uc berkeley 
part done author visiting microsoft research 
email cs berkeley edu 
shortest path problem fundamental problem numerous applications 
study common variants problem goal find point point shortest path directed graph 
refer problem problem 
assume underlying network problem solved repeatedly 
allow preprocessing restriction additional space store precomputed data limited linear graph size small constant factor 
goal fast algorithm answering point point shortest path queries 
natural application problem providing driving directions example services yahoo 
maps microsoft gps devices 
spend time preprocessing maps applications underlying graphs large memory usage exceeding graph size prohibitive 
motivates linear space assumption 
shortest path problems extensively studied 
problem preprocessing addressed example 
nontrivial theoretical results known general problem special case undirected planar graphs slightly superlinear preprocessing space 
best bound context see superlinear output path size path long 
preprocessing geometric information hierarchical decomposition discussed 
related includes algorithms single source shortest path problem algorithms approximate shortest paths preprocessing 
usually solve problem searching small portion graph algorithm running time depends number visited vertices 
motivates output sensitive complexity measure adopt 
measure algorithm performance function number vertices output path 
note measure additional benefit machineindependent 
artificial intelligence settings needs find solution huge search space 
classical search technique finds solution searching small subspace 
search uses estimates distances destination guide vertex selection search source 
pohl studied relationship search dijkstra algorithm context problem 
observed bounds search feasible defined section search equivalent dijkstra algorithm graph nonnegative arc lengths finds optimal path 
classical applications search problem distance bounds implicit domain description preprocessing required 
example euclidean graphs euclidean distance vertices part domain knowledge gives lower bound distance 
contribution new preprocessing technique computing distance bounds 
preprocessing entails carefully choosing small constant number landmarks computing storing shortest path distances vertices landmarks 
lower bounds computed constant time distances combination triangle inequality 
lower bounds yield new class algorithms call alt algorithms search landmarks triangle inequality 
talking triangle inequality respect shortest path distances graph embedding euclidean space metric need 
experimental results show alt algorithms efficient important graph classes 
illustrate just effective approach consider square grid integral arc lengths selected uniformly random interval 

shows area searched different algorithms 
dijkstra algorithm searches large manhattan ball source 
note preprocessing determine graph negative cycle problem infeasible replace input length function equivalent nonnegative 
assume loss generality input length function nonnegative 
known heuristic search 
vertices visited dijkstra algorithm left search manhattan lower bounds middle alt algorithm right input 
pair points manhattan distance times decent lower bound true distance points bounding rectangle contains near shortest paths 
observations mind expect search manhattan distance bounds able prune search area slightly larger bounding box fact 
spite near optimal paths alt algorithm able prune search area smaller bounding box 
intuitive reason performance tune ai techniques 
preprocessing algorithm learns useful paths encodes resulting knowledge landmark distances 
shortest path computations knowledge direct search 
example suppose want find shortest path office mountain view california valley ski resort lake tahoe area california 
suppose landmark new york city 
best way get new york precomputed get highway east follow new york 
best way get valley get highway east exit area follow local highway 
routes share common initial segment takes close destination ski resort 
algorithm takes advantage knowledge precomputed route implicit efficient way stored distances lower bound computations 
effect edges shared segment appear algorithm zero length 
note landmark new york helps times away destination 
phenomenon alt algorithms get performance small number landmarks 
landmark bounds previously variants shortest path computation see previous bounds feasible obtain exact search algorithm 
bounds feasible 
proper landmark selection important quality bounds 
second contribution give algorithms selecting landmarks 
landmark selection methods general graphs take advantage additional information geometric embeddings obtain better domain specific landmarks 
note landmark selection part algorithm may domain knowledge 
set landmarks domain knowledge required 
shall see making bidirectional search correctly nontrivial 
pohl ikeda give ways combining search bidirectional version dijkstra method get provably optimal algorithms 
third contribution improvement pohl algorithm alternative ikeda algorithm 
bidirectional alt algorithms outperform pohl ikeda 
euclidean bounds 
fourth contribution experimental study comparing new previously known algorithms synthetic graphs real life road graphs taken microsoft database 
study variants alt algorithms perform best practice show compare previous algorithms 
experiments give insight alt algorithm efficiency depends number landmarks graph size graph structure 
methodology new may prove helpful area 
output sensitive way measuring performance emphasizes efficiency algorithms shows room improvement assuming algorithm examines vertices shortest path 
best algorithm running road graphs average number vertices scanned varies times number vertices shortest path different types origin destination pair distributions graphs test set closer 
example find shortest path vertices graph vertices algorithm typically scans vertices scanned vertices shortest path vertex tiny fraction total number vertices 
furthermore algorithm performs worse average efficiency occasionally performs better 
alt algorithms orders magnitude efficient bidirectional variant dijkstra algorithm euclidean distance algorithms 
preliminaries input problem directed graph vertices arcs source vertex sink vertex nonnegative lengths arc goal problem find shortest path dist denote shortest path distance vertex vertex respect 
edge lengths dist refer original arc lengths 
note general dist dist 
assume arc lengths real valued mentioned 
potential function function vertices reals 
potential function define reduced cost edge 
suppose replace 
vertices length path changes amount potentials telescope 
path shortest path respect iff shortest path respect problems equivalent 
constant define shift transformation replaces vertices 
shifts change reduced costs 
say feasible nonnegative vertices 
fact known lemma suppose feasible vertex 
dist 
case think lower bound distance observe maximum feasible potential functions feasible 
lemma feasible potential functions max feasible potential function 
proof 
consider feasibility implies 
suppose case symmetric 


combine feasible potential functions minimum observed average convex linear combination feasible potential functions 
maximum context 
feasible lower bound functions take maximum get feasible lower bound function vertex high original function 
labeling method dijkstra algorithm labeling method shortest path problem finds shortest paths source vertices graph 
method works follows see example 
maintains vertex distance label ds parent status labeled scanned 
initially ds nil vertex method starts setting ds labeled 
labeled vertices method picks labeled vertex relaxes arcs sets scanned 
relax arc checks ds ds true sets ds ds labeled 
length function nonnegative labeling method terminates correct shortest path distances shortest path tree 
efficiency method depends rule chose vertex scan 
say ds exact distance equal ds 
easy see method selects vertex selection time ds exact vertex scanned 
dijkstra independently dantzig observed nonnegative labeled vertex smallest distance label ds exact 
refer scanning method minimum labeled vertex selection rule dijkstra algorithm single source problem 
theorem nonnegative dijkstra algorithm scans vertices nondecreasing order distances scans vertex 
note algorithm scan sink know ds exact path defined parent pointers shortest path 
terminate algorithm point 
refer algorithm dijkstra algorithm 
intuitively dijkstra algorithm searches ball center boundary 
run scanning method dijkstra algorithm reverse graph graph arc reversed sink 
reversal path shortest path original graph 
bidirectional algorithm works follows 
alternates running forward reverse version dijkstra algorithm 
refer forward reverse search respectively 
initialization forward search scans reverse search scans addition algorithm maintains length shortest path seen far corresponding path follows 
initially 
arc scanned forward search scanned reversed direction know shortest paths lengths ds dt respectively 
ds dt shorter path seen update path accordingly 
similar updates reverse search 
algorithm terminates search directing selects vertex scanned direction 
note alternation strategy works correctly 
balances forward reverse searches 
show strategy factor optimal line strategy 
note common mistake defining bidirectional algorithm assume algorithm stops vertex shortest path goes necessarily case 
termination path yielding optimal 
theorem sink reachable source bidirectional algorithm finds optimal path path stored 
intuitively bidirectional algorithm searches touching balls centered understand algorithm usually outperforms dijkstra algorithm consider infinite dimensional grid vertex connected neighbors arc length 
distance dijkstra algorithm visits vertices versus bidirectional algorithm 
case bidirectional algorithm gives factor speedup 
search consider problem looking path suppose domain specific function gives estimate distance context search algorithm works dijkstra algorithm step selects labeled vertex smallest value ds scan 
easy see search equivalent dijkstra algorithm graph length function feasible nonnegative theorem holds 
note selection rule search natural chosen vertex path shortest estimated length 
particular gives exact distances algorithm scans vertices shortest paths shortest path unique algorithm terminates scanning exactly vertices shortest path intuitively better estimates fewer vertices scanned 
refer class search algorithms feasible function algorithms 
bidirectional lower bounding algorithms section show combine ideas bidirectional search search 
trivial just run forward reverse searches soon meet 

potential function forward search reverse search 
works reversed graph arc appears reduced cost original graph 
say consistent arcs original graph equal reverse graph 
equivalent const 
easy come lower bounding schemes consistent 
forward reverse searches different length functions 
searches meet guarantee shortest path 
overcome difficulty ways develop new termination condition consistent potential functions 
call algorithms approaches symmetric consistent respectively 
strengths weaknesses 
symmetric approach best available potential functions terminate soon searches meet 
consistent approach soon searches meet consistency requirement restricts potential function choice 
symmetric approach symmetric algorithm due pohl 
run forward reverse searches alternating way 
time forward search scans arc scanned reverse search see concatenation path formed concatenating shortest path forward search shortest path reverse search shorter best path far update best path length needed 
corresponding updates reverse search 
searches scan vertex searches labeled vertices 
algorithm correct search shortest path 
symmetric algorithm improvement pohl algorithm 
forward search scans arc scanned reverse search know shortest path prunes forward search 
prune reverse search similarly 
call algorithm symmetric lower bounding algorithm 
theorem sink reachable source symmetric lower bounding algorithm finds optimal path 
proof 
sink reachable source set labeled vertices nonempty algorithm stops finite value finds path 
path final value length 
suppose contradiction shortest path shorter vertex dist dist vertex scanned searches 
scanned forward search backward search arc scanned forward search backward search 
arc scanned scan updated 
increases value contradiction 
consistent approach potential function consistent algorithm uses forward computation shift constant equivalent correctness wise reverse 
potential functions consistent difficulty select function works 
feasible potential functions giving lower bounds source sink respectively 
ikeda pt ps potential function forward computation pt reverse 
refer function average function 
observed convex combination pt ps 
show consistent algorithm uses function euclidean lower bound functions outperforms standard bidirectional algorithm certain graphs 
improvement relatively modest 
notice pt ps feasible forward direction 
ps ps gives lower bounds distance necessarily ones 
feasibility average pt ps obvious 
slightly intuitive feasibility maximum shown lemma 
define alternative potential function pt pt max fixed problem constant depends implementation uses constant fraction 
easy see pt feasible potential function 
refer function max function 
intuition max function choice follows 
lower bounds distance specifically designed lower bound distances lower bound distances converted lower bound distances significantly bigger far away particular near tend determine value initial period forward search behave uses vicinity second term dominate determine value pt 
reverse search directed shift behave uses choosing properly balance sides vertices total possible scanned 
experiments average function somewhat better performance max function 
performance close may perform better landmark selection heuristics 
computing lower bounds previous implementations lower bounding algorithm information implicit domain euclidean distances euclidean graphs compute lower bounds 
take different approach 
select small set landmarks vertex precompute distances landmark 
consider landmark distance triangle inequality alt algorithms 
dist 
similarly distance dist 
compute tightest lower bound take maximum landmarks bounds 
usually better landmarks 
efficient 
second tighter bound necessarily better search 
intuitively landmark away shortest path may attract search point may desirable 
select fixed size subset landmarks give highest lower bounds distance 
shortest path computation limit subset computing lower bounds 
get understanding alt algorithms suppose map far landmark approximately shortest route consists segment highway segment uses highways segment highway furthermore shortest route follows path highway goes highway path exits earlier takes local roads words choice shortest paths share initial segment 
see 
consider arc segment 
easy see lower bound distances triangle inequality property 
shortest path reduced costs arcs shared path segment zero arcs ones alt algorithm scan 
argument gives intuition bidirectional algorithms landmarks chosen 
backward forward searches follow zero reduced costs path 
consistent algorithm case paths meet resulting path shortest path 
paths need meet usually come close searches expand paths meet quickly 
symmetric algorithm searches paths meet searches biased algorithm terminates faster bidirectional algorithm 
landmark selection finding landmarks critical performance lower bounding algorithms 
denote number landmarks choose 
simplest way selecting landmarks select landmark vertices random 
works reasonably better 
greedy landmark selection algorithm works follows 
pick start vertex find vertex farthest away 
add set landmarks 
proceed iterations iteration finding vertex farthest away current set landmarks adding vertex set 
algorithm viewed quick approximation problem selecting set vertices minimum distance pair selected vertices maximized 
call method farthest landmark selection 
road graphs geometric graphs having landmark geometrically lying destination tends give bounds 
consider map graph drawing plane graph geometric distances strongly correlated 
simple planar landmark selection algorithm works fol graph need planar example road networks nonplanar 
lows 
find vertex closest center embedding 
divide embedding pie slice sectors centered containing approximately number vertices 
sector pick vertex farthest away center 
avoid having landmarks close processed sector processing sector landmark close border skip vertices close border 
refer planar landmark selection 
selection rules relatively fast optimize various ways 
optimized farthest landmark selection algorithm example repeatedly remove landmark replace farthest remaining set landmarks 
optimization technique set landmarks remove landmark replace best landmark set candidate landmarks 
select best candidate compute score landmark select highest score 
fixed sample vertex pairs compute scores 
pair sample compute distance lower bound maximum lower bounds current landmarks 
candidate compute lower bound 
add candidate score 
obtain sample vertex pairs vertex chose random add pair sample 
technique get optimized random optimized planar landmark selection 
cases passes landmarks trying improve landmark step 
set candidates landmark replacement contains landmark randomly chosen candidates 
fixed set candidates sector 
divide sector choose farthest vertex candidate landmark sector 
implementation total number candidates sectors 
optimized landmark selection strategies computationally expensive 
optimized planar selection especially expensive takes hours compute biggest problems tests 
selection rule superior regular planar selection fact best landmark selection rule graphs planar layout 
optimized farthest selection improve regular 
regular farthest selection relatively efficient choice road networks layout information available 
optimized random selection usually superior regular random selection lower performance farthest selection takes longer produce landmarks 
experimental setup problem families short name vertices arcs description latitude longitude range new mexico san francisco bay area los angeles area st louis area dallas area west coast rocky mountains plains western central east coast central eastern table road network problem descriptions sorted size 
tried adding produce worse landmarks 
ran experiments road graphs classes synthetic problems 
road graphs subgraphs graph 
full graph includes roads local highway north america 
vertex intersection roads directed arc road segment 
degree vertices middle road segments example segments intersect map grid 
vertex latitude longitude road segment speed limit length 
full graph big computer experiments ran experiments smaller subgraphs 
subgraphs created choosing vertices inside rectangular range latitudes reducing largest strongly connected component corresponding induced subgraph 
bigger graphs took vertices degrees northern longitude partitioned regions degrees western latitude 
corresponds roughly dimensions united states 
smaller graphs correspond new mexico san francisco los angeles st louis dallas metropolitan areas 
table gives details graphs shorthand names report data 
leaves open notion distance 
graph natural distance notions transit time distances calculated terms time needed traverse road assuming travels speed limit 
distance distances calculated actual euclidean length road segments 
synthetic classes graphs follows grid total vertices directed grid graph vertex connected neighbor left right border vertices fewer connections 
edge weight integer chosen uniformly random set 

note graph directed adjacent vertices necessarily 
tested square grids side length 
gij denote grid graph side edge weights randomly chosen 

example grid edge weights chosen uniformly random 

random vertices arcs random directed multigraph exactly arcs edge chosen independently uniformly random 
edge weight integer chosen uniformly random set 

tested average degree random graphs vertices 
rij denote random directed graph vertices arcs edge weights chosen uniformly random 

natural family graphs 
graph study distributions pairs rand distribution select uniformly random vertices 
natural distribution previously 
produces hard problems reason tend far apart chosen way forcing dijkstra algorithm visit graph 
bfs distribution local 
distribution chose random run breadthfirst search find vertices arcs away chose vertices uniformly random 
road grid graphs 
note corresponding shortest paths tend arcs 
road networks corresponds trips order hour passes road segments 
sense typical distribution 
random graphs graphs small diameters 
compared variants regular bidirectional search report promising representative algorithms 
dijkstra algorithm compare bidirectional algorithm 
ae search euclidean lower bounds 
previously studied 
regular alt algorithm 
bidirectional variant dijkstra algorithm provide basis comparison 
bea bidirectional algorithm consistent potential function average euclidean bounds 
previously studied 
bls symmetric bidirectional alt algorithm 
bla consistent bidirectional alt algorithm average potential function 
blm consistent bidirectional alt algorithm max potential function 
landmark selection algorithms tested compared different landmark selection algorithms general approaches 
algorithms described section follows random optimized random farthest planar optimized planar 
implementation choices euclidean bounds 
road networks exact euclidean bounds offer virtually help distance length function 
get noticeable improvement needs scale bounds 
consistent comments 
scaling may result nonoptimal paths 
interested exact algorithms aggressive scaling parameters different distance time road networks 
resulting codes find paths longer shortest paths average graphs resulting algorithms competitive landmark ones 
landmark selection 
comparing algorithms set number landmarks landmark selection algorithm applicable algorithm case random graphs 
algorithm best efficiency test cases see section maximum number fits memory biggest test problem 
name ae bea bls blm bla table algorithm comparison rand source destination distribution road networks transit time distances landmarks calculated algorithm 
efficiency roman time ms italics 
standard deviations mean indicated parentheses 
name ae bea bls blm bla table algorithm comparison rand source destination distribution road networks distance distances landmarks calculated algorithm 
efficiency roman time ms italics 
name ae bea bls blm bla table algorithm comparison bfs source destination distribution road networks transit time distances landmarks calculated algorithm 
efficiency roman time ms italics 
name ae bea bls blm bla table algorithm comparison bfs source destination distribution road networks distance distances landmarks calculated algorithm 
efficiency roman time ms italics 
data structures 
implementing graph data structure standard cache efficient representation arc lists vertex outgoing arcs adjacent memory 
general attempted write efficient code facilitate flexibility graph data structure algorithms 
algorithm vertex related data may unused 
example store geographic information vertex algorithms euclidean bounds need 
resulting loss locality hurts algorithm performance somewhat probably 
note running times supplement machine independent measure performance affected issues 
experimental results section experimental results 
primary measure algorithm performance output sensitive measure call efficiency 
efficiency run algorithm defined number vertices shortest path divided number vertices scanned algorithm 
report efficiency percent 
optimal algorithm scans shortest path vertices efficiency 
note efficiency machine independent measure performance 
report average running times algorithms milliseconds 
running times implementation dependent 
experiments data fits main memory 
graph fits memory factors lower bound computation time influence running time 
particular euclidean bound computation somewhat expensive floating point operations involved 
despite shortcomings running times important complement efficiency provide better understanding practical performance algorithms consideration 
note complicated bidirectional search algorithms somewhat higher overhead need higher efficiency compete corresponding regular search algorithms 
experiments run redhat linux hp xw workstation gb ram ghz pentium processor 
due limitations linux kernel little gb accessible individual process 
reported data points average trials 
algorithms priority queues multi level buckets 
algorithms euclidean bounds standard heap implementation priority queues described example 
algorithms aggressive bounds lead negative reduced costs making monotone priority queues multi level buckets impossible 
algorithms tested deviation bounds 
efficiency running time data tables high deviation relative mean see table 
efficiency significantly mean greater mean 
surprises efficiency entirely positive 
examples phenomenon 
order avoid clutter omit standard deviations tables 
road networks tables give data road networks types arc lengths input distributions 
algorithms perform better bfs distribution rand distribution 
expected efficiency rand problems generally goes problem size bfs problems efficiency depends problem structure 
road networks west coast map rocky mountain map east coast map uniform maps dijkstra algorithm include vertices labeled scanned 
example runs bidirectional alt algorithm 
input graph represents road network san francisco bay area 
example top input algorithm runs extremely fast second bottom bit worse average query 
dark areas represent scanned vertices light areas represent rest underlying graph 
efficiency bfs problems graphs worse 
minor exceptions observation applies algorithms 
discuss performance 
search euclidean lower bounds offers little efficiency improvement corresponding variant dijkstra algorithm hurts running time regular bidirectional forms 
hand combining search landmark lower bounds yields major performance improvement 
bla algorithm highest efficiency 
efficiency higher roughly factor rand problems factor bfs problems 
fastest algorithms bls bla dominating 
codes landmarks fastest efficiency usually little lower bea 
noted previous section bea ae slower efficiency time compute lower bounds greater 
comparing bla note rand problems bidirectional search usually outperforms regular factor efficiency bfs problems improvement usually factor 
grids main goal grid graph experiments see algorithm performance depends grid graph size arc length range 
tables give data input distributions arc length ranges 


ranges algorithm efficiency similar discuss results 
grid networks geometric euclidean manhattan bounds weak 
run ae bea grid problems 
qualitatively results similar road networks behaved problem structure uniform 
particular efficiency rand problems inversely proportional grid length 
time grid length doubles size quadruples efficiency halves 
bfs problems efficiency algorithms shows dependence problem size 
expected area dimensional circular region increases square area thin region 
dimension length doubled increases factor factor efficiency ratio halved 
grids road networks landmark codes outperform order magnitude 
qualitative results similar numbers quite behaved 
note problems bls slightly lower efficiency usual bla highest efficiency 
rand problems efficiency starts mid percent range drops biggest problem 
bfs problems efficiency roughly meaning vertices scanned output vertex 
random graphs random graphs outperforms orders magnitude terms efficiency running time 
expected ball twice radius expander graph contains orders magnitude vertices 
tables give data graphs 
landmark search significantly improves regular search performance order magnitude faster efficient worse large margin performance bla slightly interestingly bls performance significantly slightly recall classes bls somewhat efficient little faster bla 
random graph experiments suggest bls robust bla 
random graphs techniques improve previous state art best algorithm tested 
shows alt algorithms offer performance improvement graph classes 
name bls blm bla table algorithm comparison rand source destination distribution grid networks landmarks calculated algorithm 
efficiency roman time ms italics 
name bls blm bla table algorithm comparison bfs source destination distribution grid networks landmarks calculated algorithm 
efficiency roman time ms italics 
name bls blm bla table algorithm comparison rand source destination distribution random networks landmarks calculated algorithm 
efficiency roman time ms italics 
name bls blm bla table algorithm comparison bfs source destination distribution random networks landmarks calculated algorithm 
efficiency roman time ms italics 
number landmarks section study relationship algorithm efficiency number landmarks 
ran experiments landmarks bla algorithms 
tables give results road networks 
note landmark bla outperform non landmark codes study 
particular includes bea road networks 
number landmarks increases algorithm efficiency 
rate improvement substantial rand selection landmarks somewhat smaller bfs 
landmarks give significantly better results 
interesting observation small number landmarks regular search higher efficiency bidirectional search 
brings point 
consider memory tradeoff question regular vs bidirectional search 
efficient implementation requires list reverse arcs addition list forward arcs 
storage limit natural graph representations landmarks bla 
code perform better 
data suggests number landmarks large bidirectional search efficient spite landmark deficit 
number landmarks small regular search extra landmarks efficient 
landmark selection tables give data comparing landmark heuristics 
give data choice landmarks similar results hold fewer 
note data give information tradeoff precomputation time efficiency 
keep mind reading data algorithms quite fast bit slower slow hours compute largest graphs 
graph types random landmark selection typically worst efficiency wise reasonably 
farthest modest improvement random retaining feature works arbitrary graph geometric information optimized planar best nearly example 
observe road grid networks difference algorithms pronounced bfs input distribution rand 
intuition typical input bfs endpoints close need sure landmarks far away perspective perspective rand distribution difficult happen endpoints far apart 
concluding remarks proposed new lower bounding technique landmarks triangle inequality landmark selection techniques 
best landmark selection strategies consistently outperform na random landmark selection 
luck plays role landmark selection may room improvement area 
comment alt algorithms dynamic settings arc lengths change note additions deletions modeled infinite arc lengths 
consider semi dynamic case arc lengths increase road networks due traffic congestion road closures 
case lower bounds remain valid algorithms correctly 
hope changes dramatic performance remains 
fully dynamic case drastic changes keep landmark placement periodically recompute distances landmarks 
single source shortest path computation fairly efficient reasonable number landmarks time update distances may acceptable practice 
example road networks update done order minute 
reoptimization techniques see may reduce update name table landmark quantity comparision rand source destination distribution road networks transit time distances landmarks calculated algorithm 
efficiency roman time ms italics 
name table landmark quantity comparision rand source destination distribution road networks distance distances landmarks calculated algorithm 
efficiency roman time ms italics 
name table landmark quantity comparision bfs source destination distribution road networks transit time distances landmarks calculated algorithm 
efficiency roman time ms italics 
name table landmark quantity comparision bfs source destination distribution road networks distance distances landmarks calculated algorithm 
efficiency roman time ms italics 
name table landmark type comparison rand source destination distribution road networks transit time distances landmarks 
efficiency roman 
name table landmark type comparison rand source destination distribution grid networks landmarks 
efficiency roman 
name table landmark type comparison rand source destination distribution random networks landmarks 
efficiency roman 
name table landmark type comparison bfs source destination distribution road networks transit time distances landmarks 
efficiency roman 
name table landmark type comparison bfs source destination distribution grid networks landmarks 
efficiency roman 
name table landmark type comparison bfs source destination distribution random networks landmarks 
efficiency roman 
time 
recompute landmarks efficient landmark selection strategy observe farthest landmark selection takes time updating landmark distances 
experiments near completion learned gutman studies problem similar setting 
gutman algorithms concept reach need store single reach value euclidean coordinates vertex 
indirect comparison imprecise reasons performance fastest reach alt algorithms landmarks appears similar bay area graphs random vertex pair selection 
substantially fewer landmarks algorithm slower 
substantially landmarks algorithm faster 
gutman approach requires assumptions input domain preprocessing time consuming approach adapt dynamic settings 
results interesting 
space limited algorithm faster 
furthermore gutman observes ideas combined search 
interesting see gutman reach pruning alt algorithms noticeably improve efficiency 
possibility lower bounding technique place euclidean lower bounds algorithm 
advantage making reach routing apply arbitrary graph may improve performance map graphs 
leaves open questions computing reach data quickly characterizing graphs approach works 
number landmarks small landmark distances dominate space required algorithm 
note compress distances locality domain knowledge trading space time 
example road networks compression factor easily achievable 
compression techniques interesting direction research 
applications search solving puzzle implicit representations huge search spaces 
interesting see techniques context 
acknowledgments grateful boris cherkassky stimulating discussions help design implementation landmark selection algorithms 
jeff help data gary miller guy blelloch pointing literature bob tarjan satish rao kris hildrum frank mcsherry useful discussions 
cherkassky goldberg 
shortest paths algorithms theory experimental evaluation 
proc 
th acm siam symposium discrete algorithms pages 
cormen leiserson rivest 
algorithms 
mit press cambridge ma 
wagner 
compact roundtrip routing directed networks 
proc 
symp 
principles distributed computation pages 
dantzig 
linear programming extensions 
princeton univ press princeton nj 
fox 
shortest route methods 
reaching pruning buckets 
oper 
res 
dijkstra 
note problems connexion graphs 
numer 
math 
doran 
approach automatic problem solving 
machine intelligence 
dreyfus 
appraisal shortest path algorithms 
technical report rm rand santa monica ca 
rao 
planar graphs negative weight edges shortest paths near linear time 
proc 
nd ieee annual symposium foundations computer science pages 
fredman tarjan 
fibonacci heaps uses improved network optimization algorithms 
assoc 
comput 
mach 
gallo pallottino 
shortest paths algorithms 
annals oper 
res 
goldberg 
simple shortest path algorithm linear average time 
proc 
th esa lecture notes computer science lncs pages 
springer verlag 
goldberg 
shortest path algorithms engineering aspects 
proc 
lecture notes computer science 
springer verlag 
goldberg silverstein 
implementations dijkstra algorithm multi level buckets 
pardalos hearn editors lecture notes economics mathematical systems refereed proceedings pages 
springer verlag 
gutman 
reach routing new approach shortest path algorithms optimized road networks 
proc 
algorithm engineering experimentation sixth annual international workshop 
hart nilsson raphael 
formal basis heuristic determination minimum cost paths 
ieee transactions system science cybernetics ssc 
ikeda min yao hsu imai nishimura hashimoto 
fast algorithm finding better routes ai search techniques 
proc 
vehicle navigation information systems conference 
ieee 
jacob marathe nagel 
computational study routing algorithms realistic transportation networks 
oper 
res 
klein 
preprocessing undirected planar network enable fast approximate distance queries 
soda pages 
jr ford 
network flow theory 
technical report rand 
jr ford fulkerson 
flows networks 
princeton univ press princeton nj 
meyer 
single source shortest paths arbitrary directed graphs linear average time 
proc 
th acm siam symposium discrete algorithms pages 
nicholson 
finding shortest route points network 
computer 
pallottino scutell 
new algorithm shortest paths arc costs change 
networks 
pohl 
bi directional search 
machine intelligence volume pages 
edinburgh univ press edinburgh 
schulz wagner 
multi level graphs timetable information 
proc 
algorithm engineering pages 
lncs springer 
sedgewick vitter 
shortest paths euclidean graphs 
algorithmica 
tarjan 
data structures network algorithms 
society industrial applied mathematics philadelphia pa 
thorup 
undirected single source shortest paths positive integer weights linear time 
assoc 
comput 
mach 
thorup 
compact oracles reachability approximate distances planar digraphs 
proc 
nd ieee annual symposium foundations computer science pages 
wagner 
geometric speed techniques finding shortest paths large sparse graphs 
european symposium algorithms 
zhan noon 
shortest path algorithms evaluation real road networks 
transp 
sci 
zhan noon 
comparison label setting label correcting algorithms computing shortest paths 
journal geographic information decision analysis 

