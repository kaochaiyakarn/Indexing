proc 
european conf 
object oriented programming june lncs vol 
concurrent cycle collection counted systems david bacon rajan ibm watson research center box yorktown heights ny dfb watson ibm com ibm com 
automatic storage reclamation counting important advantages suffered major weakness due inability reclaim cyclic data structures 
describe novel cycle collection algorithm concurrent capable collecting garbage presence simultaneous mutation localized needs perform global search entire data space 
describe algorithm detail proof correctness 
implemented algorithm jalape java virtual machine part recycler concurrent multiprocessor counting garbage collector achieves maximum mutator pause times milliseconds 
measurements behavior cycle collection algorithm set benchmarks demonstrate effectiveness algorithm finding garbage cycles handling concurrent mutation eliminating global tracing 
years ago methods automatic storage reclamation introduced counting tracing :10.1.1.50.9776
time tracing collectors variants mark sweep semispace copying mark compact widely due perceived deficiencies counting 
changes relative costs memory processing power adoption garbage collected languages mainstream programming particularly java changed landscape 
believe time take fresh look counting particularly processor clock speeds increase ram plentiful significantly faster 
environment locality properties counting appealing purported extra processing power required relevant 
time java incorporation garbage collection thrust problem mainstream large mission critical systems built java stressing flexibility scalability underlying garbage collection implementations 
result supposed advantages tracing collectors simplicity low overhead eroded complex attempt address real world requirements large varied programs 
furthermore fundamental assumption tracing collectors acceptable periodically trace live objects heap necessarily scale large main memories increasingly common 
david bacon rajan primary problems counting 
storage overhead associated keeping count object 
run time overhead incrementing decrementing count time pointer copied 
inability detect cycles consequent necessity including second garbage collection technique deal cyclic garbage 
inability collect cycles generally considered greatest weakness counting collectors 
places burden programmer break cycles explicitly requires special programming idioms requires tracing collector collect cycles 
synchronous concurrent algorithm collection cyclic garbage counted system 
concurrent algorithm variant synchronous algorithm additional tests maintain safety properties undermined concurrent mutation data structures 
algorithms tracing mark sweep semispace copying compact algorithms linear size graph traced 
algorithms able perform tracing locally globally trace smaller subgraph 
algorithms implemented new counting collector recycler part jalape java vm implemented ibm watson research center 
jalape written java 
concurrently published describe recycler provide measurements showing concurrent counting system achieves maximum measured mutator pause times milliseconds 
execution times usually comparable parallel non concurrent mark sweep collector occasionally significant variation directions 
concentrate describing cycle collection algorithm sufficient detail implemented give proof correctness gives insight concurrent algorithm works 
provide measurements performance cycle collection algorithms suite java benchmarks 
rest organized follows section describes previous approaches cycle collection section describes synchronous algorithm collection cyclic garbage section presents concurrent cycle collection algorithm 
section contains proofs correctness concurrent cycle collection algorithms 
section presents measurements effectiveness algorithms 
section describes related concurrent garbage collection 

subsections contain detailed pseudocode algorithms skipped reading 
previous cycle collection previous solving cycle collection problem counted collectors fallen categories concurrent cycle collection counted systems special programming idioms bobrow groups certain functional programming styles infrequently invoked tracing collector collect cyclic garbage searching garbage cycles removing internal counts 
excellent summary techniques algorithms chapter counting book jones lins 
algorithm cycle collection counted system devised christopher 
synchronous cycle collection algorithm mart nez extended lins clearly explained chapter book just mentioned 
observations fundamental algorithms 
observation garbage cycles created count decremented non zero value count incremented garbage created decremented zero garbage 
furthermore counts tend predominate decrements zero common 
second observation garbage cycle counts internal internal counts subtracted garbage cycle discovered 
result count decremented reach zero considered candidate root garbage cycle local search performed 
depth search subtracts counts due internal pointers 
result collection objects zero counts garbage cycle collected depth search performed counts restored 
lins extended original algorithm perform search lazily buffering candidate roots exploring immediately 
advantages 
firstly time count candidate root may reach zero due edge deletions case node simply collected count may re incremented due edge additions case may ignored candidate root 
secondly prevent re traversal node 
unfortunately worst case lins algorithm quadratic size graph example cycle shown 
algorithm considers roots time performing count subtraction restoration passes root moving 
lins algorithm perform complete scan candidate roots arrives final root point entire compound cycle collected 
synchronous cycle collection section describe synchronous cycle collection algorithm applies principles mart nez lins requires worst case time collection number nodes number edges object graph competitive tracing garbage collectors 
david bacon rajan rr fig 

example compound cycle causes lins algorithm exhibit quadratic complexity 
improve practicality algorithm allowing resizing collected objects show significant constant time improvements achieved ruling inherently acyclic data structures 
synchronous algorithm similar lins algorithm counts decremented place potential roots cyclic garbage buffer 
periodically process buffer look cycles subtracting internal counts 
major changes algorithm linear time add buffered flag object prevent object added root buffer cycle collection 
turn places linear bound size buffer 
secondly analyze entire transitive closure single graph set graphs 
means complexity algorithm limited size transitive closure turn limited bounded buffered flag 
course practice hope transitive closure significantly smaller 
practice change buffered flag difference running time algorithm second change analyzing entire graph enormous difference run time 
applied lins algorithm unmodified large programs garbage collection delays extended minutes 
pseudocode explanation detailed pseudocode explanation operation procedure synchronous cycle collection algorithm 
addition buffered flag object contains color count 
fields color 
implementation quantities occupy single word object 
concurrent cycle collection counted systems color meaning black free gray possible member cycle white member garbage cycle purple possible root cycle green acyclic red candidate cycle undergoing computation orange candidate cycle awaiting epoch boundary table 
object colorings cycle collection 
orange red concurrent cycle collector described section 
objects start black 
summary colors collector shown table 
green acyclic objects discussed 
algorithm shown 
procedures explained detail 
increment invoked externally pointers added removed overwritten 
invoked root buffer overflows storage exhausted collector decides reason free cyclic garbage 
rest procedures internal cycle collector 
note scan lins algorithm 
increment created count incremented colored black object count just incremented garbage 
decrement node deleted count decremented 
count reaches zero invoked free garbage node 
count reach zero node considered possible root cycle 
release count node reaches zero contained pointers deleted object colored black buffered freed 
buffered buffer freed 
count decremented reach zero considered possible root garbage cycle 
color purple candidate root color set purple 
buffered flag checked see purple performed cycle collection 
buffered added buffer possible roots 
root buffer full condition low memory occurs actual cycle collection operation invoked 
operation phases removes internal counts restores counts non zero collects cyclic garbage 
marking phase looks nodes pointers stored roots buffer cycle collection 
color node purple indicating possible root garbage cycle david bacon rajan increment rc rc roots color black scan decrement rc rc roots rc remove roots release buffered false release color gray children color gray decrement children color black rc rc 
buffered free scan color gray color purple rc color purple 
buffered buffered true color white append roots children scan color black children rc rc color black roots color purple rc color white buffered buffered false color black remove roots children rc free free roots scan fig 

synchronous cycle collection concurrent cycle collection counted systems count zero invoked perform depth search reached nodes colored gray internal counts subtracted 
node removed buffer flag cleared count zero object freed 
considered procedure color garbage subgraph white re color live subgraph black 
phase procedure remaining white nodes cyclic garbage reachable buffer 
procedure node roots buffer collect garbage nodes root buffer removed flag cleared 
procedure performs simple depth traversal graph ats marking visited nodes gray removing internal counts goes 
scan procedure finds gray object count greater object reachable live data call order re color reachable subgraph restore counts subtracted 
color object gray count zero colored white invoked children 
note object may colored white re colored black reachable subsequently discovered live node 
procedure performs inverse operation visiting nodes changing color objects back black restoring counts 
procedure recursively frees white objects re coloring black goes 
white object buffered freed freed buffer 
acyclic data types significant constant factor improvement obtained cycle collection observing objects inherently acyclic 
speculate comprise majority objects applications 
avoid cycle collection inherently acyclic objects significantly reduce overhead cycle collection 
java dynamic class loading complicates determination inherently acyclic data structures 
implemented simple scheme part class loader 
acyclic classes may contain scalars classes acyclic final arrays 
implementation marks objects class acyclic special color green 
green objects ignored cycle collection algorithm david bacon rajan ghf 
purple gray gh gh black gh gh df fol green white fig 

state transition graph cycle collection 
ghf 
orange dead cycle refers green objects collected dead cycle 
simplicity presentation included consideration green objects algorithms modifications straightforward 
determination acyclic classes simple effective usually reducing objects considered roots cycles order magnitude shown section 
static compiler sophisticated program analysis applied increase percentage green objects 
concurrent cycle collection describe concurrent cycle collection algorithm principles synchronous algorithm previous section 
purposes understanding cycle collection algorithm multiprocessor counting system viewed abstractly follows mutators create destroy objects stack heap corresponding increment decrement operations enqueued local buffer called mutation buffer 
periodically mutators send mutation buffers collector applies count updates frees objects counts drop zero periodically performs cycle collection 
time divided epochs mutator transfer mutation buffer collector exactly epoch 
aside requirement normal operation synchronization required mutators collector 
mutation buffers epoch transferred collector increments just completed epoch applied decrements applied epoch boundary 
prevents freeing live data red concurrent cycle collection counted systems occur due race conditions mutators 
advantage approach necessary halt mutators simultaneously 
implementation recycler tracks pointer updates heap snapshots pointers stack epoch boundaries 
algorithm similar deutsch bobrow deferred counting superior number important respects 
implementation concurrent counting similar counting collector detreville 
recycler described detail bacon 
phase cycle collection abstracted concurrent system collection mutators emitting streams increment decrement operations counting collector merges applies operations describe overview algorithm operates 
concurrent cycle collection algorithm complex synchronous algorithm 
concurrent garbage collection algorithms contend fact object graph may modified simultaneously collector scanning addition counts may epochs date decrements deferred epoch 
algorithm relies basic premise synchronous algorithm subset nodes deleting internal edges nodes subset reduces count node subset zero subset nodes cyclic garbage 
subset may represent independent cycles garbage cycles 
graph may modified run basic difficulties 
firstly rely able retrace graph repeated traversal graph define set nodes 
secondly deletion edges disconnect portions graph making global test graph traversal difficult 
thirdly counts may date 
algorithm proceeds phases 
phase variant synchronous algorithm described section obtain candidate set garbage nodes 
wait epoch boundary perform second phase test ensure candidates satisfy criteria garbage cycles 
phases viewed enforcing liveness safety property 
phase enforces liveness ensuring potential garbage cycles considered collection 
second phase ensures safety preventing collection false cycles induced concurrent mutator activity 
liveness finding cycles collect essentially synchronous algorithm find candidate cycles 
due concurrent mutator activity graph may changing algorithm may produce incorrect results 
david bacon rajan perform concurrent cycle collection need second count object denoted crc 
hypothetical count may incorrect due concurrent mutator activity 
implementation able fit counts color buffered flag single header word hash table hold count overflows occur rarely 
liveness phase concurrent algorithm proceeds similar manner synchronous cycle collection algorithm object marked gray cyclic count crc initialized true count true count rc changed 
mark scan collect phases operate cyclic count true count 
procedure collecting white nodes garbage color orange add set possible garbage 
cyclic count ensure event concurrent mutator activity information true count objects lost 
absence mutator activity liveness phase yield set garbage nodes safety phase certify set garbage nodes collect 
presence concurrent mutator activity cause live nodes enter list different ways 
firstly mutator add edge causing procedure incorrectly infer external edges live object 
secondly mutator delete edge causing scan procedure incorrectly infer live object garbage 
thirdly deletion edges concurrent running scan procedure create gray white nodes various values cyclic counts 
eventually reporting mutator activity cause nodes detected re colored nodes encountered re colored mislead runs procedures inferring garbage 
output phase set nodes believed garbage cycle buffer data structure 
divided discrete connected components forms potential garbage cycle 
due mutator activity contents superset actual set garbage nodes contain nodes fail tests safety phase discussed detail section 
safety collecting cycles concurrently second safety phase algorithm takes input set nodes determines form garbage cycle 
nodes marked special color orange identify candidate set concurrent cycle collector 
safety phase algorithm consists tests call test test 
subset nodes object graph passes test test assured nodes subset garbage 
correctness safety phase algorithm determined property output liveness phase selects subgraphs 
property safety phase algorithm considerably simplifies proof correctness code 
concurrent cycle collection counted systems theory possible build cycle collector simply passed random sets nodes safety phase accept garbage reject live 
collector practical pick random subset nodes object graph chances form complete garbage subgraph small 
job liveness phase seen finding sets candidates garbage cycles 
mutator activity small epoch true 
test consists parts preparation actual test 
preparation part performed immediately candidate cycles iterate subset initialize cyclic count node subset count node 
iterate node subset decrement cyclic count children node subset 
preparation computation cyclic count node subset represents number node nodes external subset 
actual test performed epoch boundary iterate node subset test cyclic count zero 
zero member set know exists subset node 
candidate set passes test garbage count running preparation procedure outdated due increment nodes subset 
ascertained test 
wait epoch boundary point increment processing re colors non black nodes reachable subgraphs black 
scan nodes candidate set test color orange 
orange know increment count running preparation procedure say candidate set passed test 
subset garbage nodes external pointers pass tests 
note worry concurrent decrements members subset possible count node drop zero 
possible set garbage pointers garbage cycles 
example candidate set consisting node forms isolated garbage cycle 
cycles pointers cycle right 
know garbage cycles cycle buffer forward pointers garbage cycles followed included previous garbage cycle 
process candidate cycles cycle buffer reverse order 
reasoning described formally lemma section 
candidate set passes tests determined garbage free nodes cycle causes counts nodes outside cycle decremented 
stability property garbage decrement counts concern concurrent mutation 
decrement count orange node decrement cyclic count crc 
candidate cycle considered david bacon rajan previous cycle buffer garbage test succeed augmented computation performed preparation procedure 
reach candidate set cyclic count include count pointers known garbage node 
ensures nodes collected 
formalism understanding structure graph presence concurrent mutation proof correctness algorithm section 
pseudocode explanation pseudocode explanations procedure concurrent cycle collection algorithm 
pseudocode shown figures 
operation subsidiary procedures similar operation synchronous algorithm procedures focus differences concurrent versions procedures 
increment true count incremented 
count incremented node live non black objects reachable colored black invoking 
effect live nodes left gray white concurrent mutation interrupted previous cycle collection 
decrement high level decrementing looks synchronous algorithm count zero object released considered possible root 
possible root perform 
increment effect re leftover gray white nodes may change color purple nodes reachable black problem considered cycle collector considers rest synchronous algorithm 
invoked epoch increment decrement processing due mutation buffers mutator threads completed 
attempts free candidate cycles discovered previous epoch 
collects new candidate cycles preparation prepares test run epoch 
synchronous algorithm phases invoked candidate roots marking scanning collection 
procedure synchronous algorithm 
procedure synchronous algorithm 
remaining root white candidate cycle discovered starting root 
initialized empty procedure invoked gather members cycle color orange 
collected cycle appended 
root white candidate cycle root included previously collected candidate buffered flag set false 
case root removed roots buffer procedure buffer empty 
concurrent cycle collection counted systems increment rc rc roots scan decrement rc rc roots rc color white release empty append release children buffered false decrement remove roots color black 
buffered free color gray color gray crc rc children color purple 
buffered crc buffered true crc crc append roots scan color gray crc color white children scan color black color black roots children color purple rc color white remove roots color orange buffered false buffered true rc append free children fig 

concurrent cycle collection algorithm part david bacon rajan true color red crc rc color orange color purple children color purple color red append roots crc crc crc color black buffered false color orange false color red children free clear color red color orange rc rc color orange crc crc return false return true decrement crc return fig 

concurrent cycle collection algorithm part concurrent cycle collection counted systems similar synchronous version procedure adaptations cyclic count crc true count rc 
color gray set gray crc copied rc invoked recursively children 
color gray crc zero crc decremented check non zero necessary concurrent mutation cause crc underflow 
scan simply adaptation synchronous procedure uses crc 
nodes zero crc colored white non black nodes crc greater zero recursively re colored black 
synchronous version procedure need re increment true count count computations carried crc 
procedure recursively gathers white nodes identified members candidate garbage cycle colors orange goes 
flag set true node stored appended 
candidate cycles collected procedure prepares execution test epoch 
operates individually candidate 
crc initialized rc color set red 
nodes red 
pointer node node crc target node decremented 
nodes re colored orange 
crc field count number outside ofc 
procedure iterates candidate cycles reverse order collected 
applies safety tests test test cycle passes tests cycle freed meaning may reconsidered collection epoch 
procedure returns true color nodes cycle orange indicates increments nodes cycle 
procedure calculates total number external nodes cycle crc fields computed procedure 
returns true number external zero false 
candidate cycle collected due failing safety test procedure re colors nodes 
node candidate cycle purple node candidate orange node purple nodes colored purple placed buffer 
nodes colored black flags cleared 
procedure frees members candidate cycle passed safety tests 
members colored red nodes red 
node decrements counts non red nodes pointed bys 
david bacon rajan node red belongs candidate cycle 
belongs candidate cycle orange case rc crc fields decremented crc field decremented update computation performed previously sigma preparation procedure take deletion cycle pointing account 
belong candidate cycle orange operation performed 
ease presentation pseudocode way maximizes readability 
means code passes nodes strictly necessary 
instance pass merged passes performed combined 
implementation passes combined minimize constant factor overheads 
proofs section prove correctness concurrent cycle collection algorithm section 
graph purpose proof correctness tests garbage useful define graph epoch garbage collector 
epoch collector thread gets set increments decrements mutator threads 
increment refers new node implies creation node 
addition increment implies addition directed edge nodes decrement implies deletion edge 
increments decrements provide source edges practice build graph need build purpose algorithm 
purposes proof useful conceptualize graph 
graph denotes graph generated adding nodes new node inserting deleting edges corresponding increments decrements epoch 
addition node determined garbage freed deleted epoch start empty graph similarly define set roots mutator stacks global class static variables 
roots mutator stacks named increments collected stack snapshots mutator epoch 
roots global variables sources edges implied increment decrement operations source global variable heap variable 
simply union types roots 
define set garbage objects denote set difference minus transitive closure roots epoch roots safety proof correctness concurrent cycle collection counted systems garbage collector safe object collected garbage 
section prove safety algorithm 
epoch collect cycles identified potential garbage epoch set denote contents generated cycle collection epoch collection orange nodes generated concurrent variant synchronous cycle detection algorithm set purple nodes denoted roots search cyclic garbage 
partitioned disjoint sets candidate garbage cycle computed cycle collection algorithm particular purple node due concurrent mutation may contain nodes lemma 
set containing nodes exist fail test 
proof 
way new nodes added increment operations 
concurrent increment operations processed apply test 
processing increment operation node question node re colored orange black 
presence black node cause test fail 
epoch test 
sets denote set containing sets passed denoted passed test denote sets set nodes believed garbage cycle passed test 
denote specific node collection 
denote count node epoch 
definition rc count node graph denote number nodes denote number nodes determined test 
denote hypothetical count computed test 
theorem 
passes test computed values described section denote complement set garbage nodes 
david bacon rajan proof 
definitions delay processing decrements epoch ensures properties true non negative zero garbage node 
non negative zero node collection garbage nodes 
test determine number node nodes definition may differ may new nodes added increasing may nodes deleted decreasing collection passes added time epoch 
zero test test non negative follows zero 
node collection collection garbage 
lemma theorem show test test sufficient ensure set nodes passes tests garbage 
theorem shows tests necessary ensure 
theorem 
test contains garbage nodes 
test necessary ensure candidate set proof 
prove example 
consider graph nodes shown 
cycle detected purple node starting point cycle collection run 
edge nodes cut routines nodes collected set routine form nodes garbage 
increments counts nodes set pass test 
decrements processed epoch epoch decrement node effect nodes operation performed epoch fact nodes detected waiting additional epoch guarantee test epoch edge cut fig 

race conditions uniquely detected concurrent cycle collection counted systems add test test 
purple nodes cycle collection started inside node shown count rc top cyclic count crc bottom 
cut 
making chain nodes arbitrarily long having malicious mutator cut edges just right moment non garbage set nodes pass test arbitrarily epochs 
test detect live nodes consider graph nodes shown 
cycle detected start ing purple node cycle collection run 
new edge added node node routine run shown dashed line count node date 
cycle collector observes newly added edge sum counts equal sum edges 
set nodes collected routine form set increments processed test done pass test 
test detect live nodes notice claiming race conditions shown exhaustive list possible race conditions algorithm face 
sufficient show necessity tests 
tests necessary sufficient ensure safety algorithm 
prove lemma section proof uses notation section 
define complete set nodes closed transitive closure transpose graph complete set nodes includes parents 
david bacon rajan lemma 
test 
complete set nodes pass test proof 
stability property garbage changes counts nodes reasoning passes test 
complete set pass liveness proof correctness test 
garbage collector live eventually collects unreachable objects 
concurrent algorithm subject extremely rare race conditions may prevent collection garbage 
prove weak liveness condition holds provided race condition occur epoch 
demonstrate weak liveness possible candidate cycle contains subset complete garbage cycle nodes subset point nodes live see 
result running variant synchronous cycle collection algorithm mutation continues allowing race conditions ones shown cycles occasionally place live nodes set candidate resulting candidate set fail test test epoch 
occurs cycle reconsidered epoch 
race condition occurs indefinitely garbage eventually collected 
garbage nodes collected epoch called undiscovered garbage epoch practice unable induce race condition leads undiscovered garbage adversary programs 
remains theoretical limitation approach 
solutions problem instance breaking set fails tests strongly connected components included complicate algorithm required practice 
investigating alternative entire cycle collection performing strongly connected component algorithm alternative promising number passes object graph substantially reduced 
concurrent cycle collection counted systems live data fig 

concurrent mutation nodes cause candidate sets undiscovered garbage 
section prove set garbage nodes free race condition leading undiscovered garbage collected epoch considered epoch previously defined set purple nodes epoch set nodes cycle detection algorithm begins searching cyclic garbage 
theorem 
purple set maintained correctly concurrent cycle collection algorithm garbage node reachable purple node 
proof 
procedure ensures garbage set cyclic garbage 
addition decrement adds nodes having decrement non zero purple set 
know cyclic garbage generated processing increments decrements epoch reachable purple set 
remains proved purple set contains roots cyclic garbage previous epochs 
know trivially true epoch assume true epoch prove running routine true epoch result follows induction 
member purple set epoch root garbage cycle 
routine ensures root cycle generated stored position buffer takes white nodes reachable collected reachable root node puts current cycle 
version synchronous david bacon rajan garbage collection algorithm concurrent mutation subgraph garbage nodes garbage nodes current cycle 
addition purple node reachable cycle associated added current cycle 
purple node garbage continue reachable proper handling ensure proper handling node children 
routine put node back purple root set current cycle determined garbage case entire cycle freed node determined live case root garbage cycle 
purple set contain roots garbage cycles survive cycle collect epoch corollary 
cycle buffer generated epoch contains garbage nodes proof 
theorem root garbage cycle contained procedure version synchronous garbage collection algorithm 
concurrent mutation subgraph garbage nodes 
garbage nodes put cycle buffer unfortunately due concurrent mutation may contain live nodes 
nodes live fail tests test test root identified live node discarded 
possible contains set garbage nodes set live nodes shown 
purple nodes creates set candidate con processes tains nodes processes creates candidate set contains nodes includes garbage nodes reachable purple node considered live nodes case fail safety tests algorithm fail detect contained garbage nodes 
furthermore algorithm fail detect garbage nodes pointed garbage 
roots put garbage cycles considered epoch malicious mutator able fool collected epoch 
fact remains collected current epoch 
set nodes undiscovered garbage epoch member live node cycle set cycle set pointed member show garbage nodes set collected denote set nodes collected starting root node epoch lemma 
edges garbage nodes concurrent cycle collection counted systems proof 
routine takes white nodes reachable root current cycle colors orange places set nodes reaches previously colored orange included set included set previous nodes reachable current root exist current cycle cycle collected previously 
nodes collected nodes ward pointers second set edges added running routine 
mutation involving garbage nodes possible 
set nodes collected 
theorem 
garbage undiscovered due race conditions collected epoch 
proof 
corollary know node contained cycle fails test know live node 
case node cycle live case belong garbage node undiscovered garbage belongs nodes belong cycle fails test means edge outside set nodes lemma garbage node comes earlier cycle buffer 
live node garbage node undiscovered garbage garbage nodes cycle belong set undiscovered garbage node garbage node belongs discovered garbage set cycle buffer 
routine process cycles reverse order collected 
free garbage cycles delete edges nodes 
lemma discovered garbage set external pointers 
pass test 
addition delete edges set discovered garbage set pass test 
discovered garbage cycle set pass tests 
corollary 
absence race condition leading undiscovered garbage mixture live garbage nodes set garbage col lected 
proof 
case live nodes contains garbage null set 
result follows theorem 
measurements measurements effectiveness concurrent cycle collection algorithm recycler counting garbage collector implemented david bacon rajan program description applic 
threads objects percent size allocated acyclic compress compression kb jess java expert system kb db database kb mtrt multithreaded raytracer kb jack parser generator kb business object benchmark kb jalape jalape compiler kb cyclic test synth 
kb table 
benchmarks characteristics 
part jalape java virtual machine written java ibm watson research center 
measurements section concentrate operation counting system recycler 
concurrently published detailed measurements system including comprehensive performance evaluation shows sufficient resources recycler achieves maximum millisecond pause time appreciably slowing applications 
benchmarks table summarizes benchmarks 
benchmarks consist mixture spec benchmarks programs early version benchmark accepted spec jalape jalape optimizing compiler compiling synthetic benchmark designed test cycle collector create cyclic garbage gaussian distribution neighbors create smooth distribution random graphs 
source code benchmarks application size total class file size kilobytes 
spec benchmarks run size exactly iterations entire run including jit time counted 
ran benchmarks cpu threads extra cpu ran concurrent collector 
largest benchmark jalape jalape optimizing compiler compiling 
allocates objects determined classloader acyclic marked green 
optimizer represents worst case type program seen cycle collector practice data structures consist entirely graphs doubly linked lists 
cycle collection table summarizes operation concurrent cycle collection algorithm 
cycle collection performed epochs roots buffer exceeded concurrent cycle collection counted systems gray white orange traced alloc 
program ep 
cyc 
roots cycles marked refs 
trace coll 
checked coll 
compress jess db mtrt jack jalape table 
cycle collection 
ep number epochs cyc 
coll number cycle collections 
cycles number collected rejected due tests 
threshold size usually condition triggered cycle collections sooner 
occur epochs 
number surprising results 
despite large number roots considered number garbage cycles usually quite low 
cyclic garbage significant jalape test 
significant compress numbers show multi megabyte buffers hang cyclic data structures application runs memory cycles collected timely manner 
jalape optimizing compiler synthetic graph generator freed objects cycle collector 
surprised number higher virtually data structures potentially cyclic 
appears large proportion objects simple cyclic garbage 
half candidate cycles benchmarks concurrent mutation introduced false candidate cycles false cycles rejected test 
rejected cycles undiscovered garbage collected part set described section 
fact unable create false cycles artificially tried modifying program turn malicious mutator designed solely purpose fooling algorithm 
demonstrates conclusively undiscovered garbage problem theory practice 
table shows different phases cycle collection algorithm proceeded marking gray looking cyclic garbage white provisionally identified cyclic garbage orange 
amount marking varied widely benchmarks 
table shows number followed concurrent counting collector refs 
traced 
normalized total number objects allocated trace alloc 
db benchmark required tracing object 
apparently performs far modification potentially cyclic data structures programs presumably inserting removing database objects index data structure 
david bacon rajan compared tracing garbage collectors counting collector advantage traces locally potential roots disadvantage algorithm requires multiple passes subgraph 
furthermore root large data structure entered root buffer frequently high mutation rates force frequent epoch boundaries live data structure traversed multiple times 
measurements show counting collector cycle collection technique may perform little tracing large amount tracing application dependent 
measurements show cycle collection algorithm practical capable handling large programs cases provide significantly increased locality reduction memory traffic tracing collectors 
recycler described greater detail compared quantitatively parallel mark sweep collector bacon 
related concurrent collection numerous concurrent multiprocessor collectors general purpose programming languages described literature number implemented quite small run multiprocessor 
detreville garbage collectors modula dec firefly workstation comparative evaluation multiprocessor garbage collection techniques 
algorithm counting collector backed concurrent tracing collector cyclic garbage 
unfortunately despite having implemented great variety collectors provides qualitative comparison 
findings agree detreville counting highly effective general purpose programming language multiprocessor 
recycler differs cycle collection backup mark sweep collector 
describe concurrent algorithm inferno system back counting collector 
report counting collects data measurements java show proportion cyclic garbage small varies greatly 
measurements provided uniprocessor sml nj difficult meaningful comparisons 
concurrent multiprocessor collector java know 
generational collector doligez generations shown provide significant improvements throughput 
implemented concurrent multiprocessor collectors tracing algorithms concurrent variants ml generally significantly longer maximum pause times collector 
addition ml produces large amounts immutable data simplifying collection process 
concurrent cycle collection counted systems garbage collector larus ml achieved maximum pause times ms small benchmarks quicksort knuth bendix 
collector requires read barrier mutable objects relies processor consistency avoid locking objects forwarded 
read barriers synchronization instructions generally considered impractical imperative languages weakly ordered multiprocessors barrier require synchronization access mutable object clear algorithm practical imperative languages current generation multiprocessor machines 
lins concurrent cycle collection algorithm synchronous algorithm 
recycler lins separate count cycle collector relies processor supported asymmetric locking primitives prevent concurrent mutation graph 
scheme knowledge implemented 
appear practical stock multiprocessor hardware fine grained locking required mutators collector 
algorithm avoids fine grained locking second count field searching cycles performing safety tests test test validate cycles 
jones lins algorithm garbage collection distributed systems uses variant lazy mark scan algorithm handling cycles 
rely heavy weight synchronization associated message sends receives global termination detection algorithm 
algorithm implemented 
terms cycle collection systems implemented closest rodrigues jones implemented algorithm cycle collection distributed systems 
tracing collector local cycles assume inter processor cycles rare considerably heavyweight mechanisms lists back pointers hand solve problems address fault tolerance 
algorithms collection cyclic data structures counted systems starting synchronous algorithm extended handle concurrent mutation requiring synchronization mutator threads collector 
detailed pseudocode proof correctness concurrent algorithm 
implemented algorithms part recycler concurrent multiprocessor counting garbage collector java measurements show effectiveness algorithm suite significant java benchmarks 
novel important respects represents practical cycle collection counting garbage collector mainstream programming language requires explicit synchronization mutator threads mutators collector 
david bacon rajan contribution proof methodology allows reason graph exists machine implied stream increment decrement operations processed collector 
effect able reason consistent snapshot having take snapshot implementation 
cycle collection algorithm forms key part recycler garbage collector java achieves execution times competitive parallel mark sweep collector holding maximum application pause times milliseconds 
dick attanasio han lee steve smith contributions implementation counting garbage collector implemented algorithms described entire jalape team possible 
anonymous referees comments helped improve 
alpern implementing jalape java 
oopsla conference proceedings object oriented programming systems languages applications denver colorado oct 
sigplan notices 
appel ellis li real time concurrent collection stock multiprocessors 
proceedings sigplan conference programming language design implementation atlanta georgia june 
sigplan notices july 
bacon attanasio lee rajan smith java coffee breaks nonintrusive multiprocessor garbage collector 
proceedings sigplan conference programming language design implementation snowbird utah june 
sigplan notices may 
bacon kolodner nathaniel petrank rajan strongly connected component algorithms concurrent cycle collection 
tech 
rep ibm watson research center ibm haifa scientific center apr 
bobrow managing re entrant structures counts 
acm trans 
program 
lang 
syst 
july 
christopher count garbage collection 
software practice experience june 
collins method overlapping erasure lists 
commun 
acm dec 
detreville experience concurrent garbage collectors modula 
tech 
rep dec systems research center palo alto california aug 
deutsch bobrow efficient incremental automatic garbage collector 
commun 
acm july 
dijkstra lamport martin scholten fly garbage collection exercise cooperation 
hierarchies interfaces bauer eds vol 
lecture notes computer science 
springer verlag new york pp 

concurrent cycle collection counted systems doligez leroy concurrent generational garbage collector multithreaded implementation ml 
conference record twentieth acm symposium principles programming languages charleston south carolina jan acm press new york new york pp 

implementing fly garbage collector java 
proceedings acm sigplan international symposium memory management minneapolis mn oct 
sigplan notices jan 
kolodner petrank generational fly garbage collector java 
proceedings sigplan conference programming language design implementation june 
sigplan notices 
larus concurrent copying garbage collector languages distinguish im mutable data 
proceedings fourth acm symposium principles practice parallel programming may 
sigplan notices july 
concurrent mark sweep garbage collection fine grain synchronization 
proceedings acm sigplan international symposium memory management mar 
sigplan notices 
jones lins cyclic weighted counting delay 
parle parallel architectures languages europe june bode reeve wolf eds vol 
lecture notes computer science springer verlag pp 

jones lins garbage collection 
john wiley sons 
kung song efficient parallel garbage collection system correctness proof 
ieee symposium foundations computer science ieee press new york new york pp 

lamport garbage collection multiple processes exercise parallelism 
proceedings international conference parallel processing pp 

lins cyclic counting lazy mark scan 
inf 
process 
lett 
dec 
lins multi processor shared memory architecture parallel cyclic counting 
microprogramming sept 
proceedings th euromicro conference paris france 
mart nez lins cyclic counting local mark scan 
inf 
process 
lett 

mccarthy recursive functions symbolic expressions computation machine :10.1.1.50.9776
commun 
acm 
nettles toole real time garbage collection 
proceedings sig plan conference programming language design implementation albuquerque new mexico june 
sigplan notices 
rodrigues jones cyclic distributed garbage collection group merger 
proceedings twelfth european conference object oriented programming brussels july jul ed vol 
lecture notes computer science springer verlag pp 

adding garbage collection runtime types strongly typed concurrent language 
tech 
rep csl xerox palo alto research center july 
steele multiprocessing garbage collection 
commun 
acm sept 
