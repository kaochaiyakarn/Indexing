sat abstraction refinement ilp machine learning techniques edmund clarke gupta james ofer 
computer science carnegie mellon university pittsburgh pa emc cs cmu edu 
synopsys beaverton 
synopsys com 
describe new techniques model checking counterexample guided abstraction refinement framework 
abstraction phase hides logic various variables considering inputs 
type abstraction may lead spurious counterexamples traces simulated original concrete machine 
check counterexample real spurious sat checker 
combination integer linear programming ilp machine learning techniques refining abstraction counterexample 
process repeated real counterexample property verified 
implemented techniques top model checker nusmv sat solver chaff 
experimental results prove viability new techniques 
state art model checkers verify circuits latches industrial circuits order magnitude larger 
various conservative abstraction techniques bridge gap 
abstraction techniques preserve behaviors concrete system may introduce behaviors originally 
universal property actl property true system true concrete system 
hand universal property false system may true concrete system 
case behaviors violate property system reproduced concrete system 
counterexamples corresponding behaviors said spurious 
counterexample abstraction refined order eliminate spurious behavior 
research sponsored semiconductor research src contract tj national science foundation nsf 
ccr office naval research onr naval research laboratory nrl contract 

views contained document author interpreted representing official policies expressed implied src nsf onr nrl government entity 
process repeated real counterexample system satisfies property 
case know concrete system satisfies property abstraction conservative 
known techniques automatic manual generating initial abstraction abstraction refinement 
automatic techniques relevant method fully automatic clear practical advantage automation 
methodology iterative abstraction refinement process 
abstraction performed selecting set latches variables making invisible treated inputs 
iteration check system satisfies specification standard obdd symbolic model checker 
counterexample reported model checker try simulate concrete system fast sat solver 
words generate solve sat instance satisfiable counterexample real 
instance satisfiable look failure state state longest prefix counterexample satisfiable 
note process easily performed standard circuit simulator counter example include values inputs 
failure state order refine abstraction 
system transitions failure state exist concrete system 
eliminate transitions refining abstraction making variables visible previously invisible 
problem selecting small set variables visible main issues address 
important find small set order keep size state space manageable 
problem reduced problem separating sets states abstraction unites concrete states refining abstraction opposite operation separation states 
realistic systems generating sets feasible explicitly symbolically 
minimum separation problem known np hard 
combine sampling integer linear programming ilp machine learning handle problem 
machine learning algorithms successfully wide range problem domains data mining problems necessary extract implicit information large database samples 
algorithms exploit ideas diverse set disciplines including information theory statistics complexity theory 
closest current aware described 
current automatic iterative abstraction refinement procedure guided counterexample try eliminate counterexample solving state separation problem 
main differences methods 
abstraction replacing predicates program new input variables abstraction performed making variables invisible hide entire logic defines variables 
advantage approach computing minimal abstraction function easy 
secondly checking counterexample real spurious performed symbolically obdds 
stage sat solver particular task extremely efficient due large number solutions sat instance 
thirdly derive refinement symbolically 
finding coarsest refinement np hard polynomial procedure general computes sub optimal solution 
defined cases procedure computes optimal refinement 
hand avoid complexity considering samples states sets compute explicitly 
doing pay price optimality procedure yields refinement step necessarily optimal necessarily find smallest number invisible variables visible order eliminate counterexample 
suggest method efficient sampling cases allows efficiently compute optimal refinement 
mentioned context similar main difference refinement algorithm computing refinement analyzing failure state combine theorem prover greedy algorithm finds small set previously abstracted predicates eliminate counterexample 
add set predicates new constraint model 
previous abstraction making variables invisible technique different names past include localization reduction kurshan see example 
localization reduction follows typical abstraction refinement iterative process 
starts making property variables invisible 
spurious counterexample identified refines system making variables visible 
variables visible selected variable dependency graph information derived counterexample 
candidates refinement step invisible variables adjacent variable dependency graph currently visible variables 
choosing variables done extracting information counterexample 
relevant described 
valued simulation simulate counterexample concrete model identify invisible variables values concrete model conflict counterexample 
variables chosen set invisible variables various ranking heuristics 
example localization prefer variables close variable dependency graph currently visible variables 
rest organized follows 
section briefly give technical background abstraction refinement model checking 
section describe counterexample guided abstraction refinement framework 
elaborate section counterexample checked refine abstraction 
describe refinement learning problem 
sections elaborate separation techniques 
techniques combined efficient sampling technique described section 
give experimental results section proves viability methods comparing state art model checker cadence smv 
discuss section 
abstraction model checking start brief description abstraction model checking details refer :10.1.1.116.9247
consider program set variables fx xng variable xi ranges non empty domain dxi 
state program assigns values variables set possible states program dx theta delta delta delta theta dxn 
program modeled transition system 
set states 

set initial states 

theta set transitions 
notation denote fact state write transition states abstraction function system surjection maps concrete state state concrete state si denote si state mapped accordingly denote gamma set states definition 
minimal transition system corresponding transition system abstraction function defined follows 
sg 

sg 
intuitively minimality means start state start state transition transition 
simplicity restrict discussion model checking agp formulas non temporal propositional formula 
theory extended handle safety property formulas counterexamples finite paths 
definition 
propositional formula respects abstraction function essence conservative abstraction preservation theorem stated proof :10.1.1.116.9247
theorem 
abstraction corresponding abstraction function propositional formula respects agp agp converse theorem true 
model invalidates specification concrete model may satisfy specification 
case counterexample generated model checker spurious correspond concrete path 
abstraction function coarse validate specification need refine 
definition 
transition system abstraction function refinement 
implies 

exists 
abstraction refinement definitions describe counterexample guided abstraction refinement procedure 
transition system safety property 
generate initial abstraction function 
model check 
return true 

check counterexample concrete model 
counterexample real 
return false 

refine go step 
procedure complete finite state systems 
refinement step partitions state number loop iterations bounded number concrete states 
subsections explain detail perform step 
defining abstraction function partition set variables sets set visible variables denote set invisible variables denote intuitively corresponds part system currently believed important verifying property 
abstraction function abstracts irrelevant details invisible variables 
initial abstraction step refinement step correspond different partitions set variables 
initial abstraction includes variables property 
refinement step move variables explain sub section 
formally denote value variable state set variables fu su denotes portion corresponds variables su 
fv 
partitioning defines abstraction function set states dv theta delta delta delta theta abstraction function simply sv 
need compute minimal abstraction 
arbitrary system abstraction function expensive impossible construct minimal abstraction :10.1.1.116.9247
abstraction function allows compute efficiently systems transition relation functional form sequential circuits 
systems computed directly program text removing logic defines invisible variables treating inputs 
checking counterexample safety properties counterexample generated model checker path smi 
set concrete paths corresponds counterexample fhs smi gamma si si si sig section si simply projection si visible variables 
right conjunct restriction visible variables step values counterexample 
counterexample spurious set empty 
check solving sat solver 
formula similar structure formulas arise bounded model checking bmc 
easier solve path restricted counterexample 
model checkers treat inputs latches counterexample includes assignments inputs 
simulating counterexample restrict values original inputs part definition lie rhs visible variables simplifies formula 
satisfying assignment know counterexample corresponds concrete path means real bug 
try look failure index maximal index satisfiable 
sf longest prefix counterexample corresponds concrete path 
implementation sequentially searches range highest value satisfiable 
long counterexample traces option performing binary search range case number sat instances solve bounded log refining abstraction denote failure index 
denote set states df exists hd df call set deadend states 
definition concrete transition gamma sf 
transition sf sf non empty set transitions oef gamma sf gamma sf agree counterexample 
set transitions oef defined follows oef sf sf sf sf sf sf sf definition oef represents concrete paths step step visible variables steps restricted values counterexample 
denote set states bf exists hbf bf oef call set bad states see 
counterexample exists transition sf sf correspond concrete transition 
transition exists deadend bad states lie state 
suggests mechanism refine abstraction 
abstraction refined new abstraction 
new abstraction puts deadend bad states separate states eliminates spurious transition system 
trace bad fig 

spurious counterexample corresponds concrete path breaks failing state 
failing state unites concrete deadend bad states 
refinement separation learning fs smg ft tng sets states binary vectors size representing assignments set variables definition 
state separation problem find minimal set variables fu ae pair states si tj exists variable ur si ur tj ur 
di bi denote restriction respectively invisible parts di fsi js dg bi bg 
set variables separates di bi refinement obtained adding minimality crucial matter efficiency 
smaller sets visible variables easier model check system harder find 
fact shown computing minimal separating set np hard 
lemma 
new abstraction function separated system 
proof 
refined abstraction function corresponds visible set separates di bi exists 

definition uk uk ui 

ut naive way separating set deadend states set bad states generate separate explicitly symbolically 
unfortunately systems realistic size usually possible 
simplest examples number states large enumerate explicitly 
systems moderate complexity sets computed symbolically bdds 
possible larger systems 
possible generate computationally expensive identify separating variables 
select samples try infer separating variables entire sets samples 
course tradeoff computational complexity generating samples quality separating variables 
complete separation guaranteed counterexample eliminated 
algorithm complete counterexample eventually eliminated subsequent refinement iterations 
experience shows state art sat solvers chaff generate samples short amount time 
fact large relatively easy sat solvers find satisfying assignments equations compared typical sat instances similar size 
idea learning samples studied extensively machine learning literature 
number learning models algorithms proposed 
sections describe techniques separate sets samples deadend bad states denoted sdi sbi respectively 
separation integer linear programming problem formulation problem separating sdi sbi integer linear programming ilp problem depicted 
min vi subject sdi sbi jij vi vi vi fig 

state separation integer linear programming value integer variable ilp problem interpreted vi vi separating set 
constraint corresponds pair states si tj stating variables separates distinguishes states selected 
theta constraints 
example 
consider pairs states 
corresponding ilp problem min vi subject separating lambda separating lambda separating lambda separating lambda optimal value objective function case corresponding optimal solutions 
separation decision tree learning ilp separation algorithm outputs minimal separating set 
algorithm high complexity handle large number variables samples 
section formulate separation problem decision tree learning dtl problem polynomial number variables number samples 
learning decision trees widely practical methods approximating discrete valued functions 
dtl algorithm inputs set examples generates decision tree classifies 
example described set attributes corresponding classification 
internal node tree specifies test attribute branch descending node corresponds possible values attribute 
leaf tree corresponds classification 
data classified starting root node decision tree testing attribute specified node moving tree branch corresponding value attribute 
process repeated subtree rooted branch leafs reached labeled classification 
problem separating sdi sbi formulated dtl problem follows attributes correspond invisible variables 
ilp problem stated integer variables constraints objective function guarantees value 
thought boolean variables 
classifications gamma corresponding sdi sbi examples sdi labeled sbi labeled gamma 
generate decision tree problem 
separating set output contains variables internal nodes decision tree 
lemma 
algorithm outputs separating set sdi sbi proof 
sdi sbi decision tree classify gamma 
exists node decision tree labeled variable 
construction lies output set 
ut example 
going back example corresponding dtl problem attributes classifications gamma 
set examples gamma gamma tree corresponds separating set 
number algorithms developed learning decision trees id 
algorithms essentially perform simple top greedy search space possible decision trees 
implemented simplified version id algorithm described 
ree examples attributes 
create root node tree 

examples classified return root classification 

examples attributes 
label root attribute 
subset examples having value 
add branch root pointing subtree generated attributes gamma fag 

return root 
fig 

decision tree learning algorithm recursion algorithm pick attribute test root 
need measure quality attribute 
start defining quantity called entropy commonly notion information theory 
set containing phi positive examples psi negative examples entropy entropy gamma phi log phi gamma psi log psi phi phi phi psi psi psi phi psi 
intuitively entropy characterizes variety set examples 
maximum value entropy corresponds collection equal number positive negative examples 
minimum value entropy corresponds collection positive negative examples 
define quality attribute reduction entropy partitioning examples measure called information gain defined follows gain entropy gamma je jej delta entropy gamma je jej delta entropy subsets examples having value respectively attribute examples attributes procedure returns attribute attributes highest gain examples 
example 
illustrate working algorithm example 
continuing previous example calculate gains attributes top node decision tree 
entropy gamma log gamma log gain gamma delta entropy ev gamma delta entropy gain gamma delta entropy ev gamma delta entropy gain gamma delta entropy ev gamma delta entropy gain gamma delta entropy ev gamma delta entropy ree algorithm pick label root 
efficient sampling states sampling di bi arbitrary 
show possible direct search samples contain information 
ffi di bi denote minimal separating set di bi finding ffi di bi explicitly computing di bi separating computationally expensive size sets optimal separation techniques worst case exponential 
look samples sdi sbi small compute separate hand maintain ffi sdi sbi ffi di bi 
finding sets refer efficient sampling 
suggest iterative algorithm efficient sampling 
sepset denote current separating set 
initially sepset 
step algorithm finds samples separable sepset computed previous iteration 
computing new pair dead bad states separable sepset done solving phi sepset defined phi sepset oe vi sepset vi oef formulas representing deadend bad states defined equations 
prime symbol oef denotes fact replace variable oef new variable note definition conjunction oef unsatisfiable 
right clause formula guarantees new samples deadend bad states separable current separating set 
algorithm sample separate described uses formula compute minimal separating set di bi explicitly computing separating 
step finds samples di di bi bi separable current separating set sepset 
re computes sepset union sets computed current iteration 
repeating process samples exist guarantees resulting separating set separates di bi note size sepset increase stay unchanged iteration 
sepset repeat forever phi sepset satisfiable derive di bi solution exit sepset ffi sij sij fig 

algorithm sample separate implements efficient sampling iteratively searching states separable current separating set 
algorithm finds single solution phi sepset single pair states di bi 
size sample larger 
larger samples may reduce number iterations require time derive separate 
optimal number new samples iteration depends various factors efficiency sat solver separation technique examined model 
implementation lets user control process adjusting parameters number samples generated iteration maximum number iterations 
experimental results implemented framework inside nusmv 
nusmv frontend parsing smv files generating abstractions 
actual model checking cadence smv implements techniques influence reduction cut points implemented variant id algorithm generate decision trees 
public domain lp solver solve integer linear programs 
chaff sat solver 
modifications chaff efficiently generate multiple state samples single run 
experiments performed iu family circuits various abstractions interface control circuit synopsys 
experiments performed ghz dual athlon machine gb ram running linux 
pre computed variable ordering files experiments 
circuit smv sampling ilp sampling dtl eff 
samp 
dtl time bdd time bdd time bdd time bdd iu iu iu iu iu iu iu iu iu iu iu iu iu fig 

model checking results property 
results 
tables correspond different properties 
compared techniques smv cadence smv sampling ilp sampling separation integer linear programming samples refinement iteration sampling dtl sampling separation decision tree learning samples refinement iteration eff 
samp dtl efficient sampling separation decision tree learning 
run measured total running time time maximum number bdd nodes allocated bdd number refinement steps number latches final abstraction 
original number latches circuit indicated name 
gamma symbol indicates ran memory 
solve property circuits iu iu methods 
experiments indicate technique standard model checking terms execution time required memory 
predicted number iterations generally reduced ilp efficient sampling applied 
cases translates reduction total execution time 
cases smaller sets separating variables resulted larger bdds 
noise experimental results typical bdd techniques 
automatic counterexample guided abstraction refinement algorithm uses sat ilp techniques machine learning 
algorithm outperforms standard model checking terms execution time memory requirements 
refinement technique general extended large variety systems 
example conjunction predicate abstraction apply techniques software model checking 
circuit smv sampling ilp sampling dtl eff 
samp 
dtl time bdd time bdd time bdd time bdd iu iu iu iu iu iu iu iu iu fig 

model checking results property 
research directions 
currently exploring criteria size separating set characterizing refinement 
want explore machine learning techniques solve state separation problem 

sangiovanni 
iterative approach language containment 
cav 


version 
eindhoven univ tech netherlands 

biere cimatti clarke zhu 
symbolic model checking bdds 
tacas 

cimatti clarke giunchiglia roveri 
nusmv new symbolic model checker 
int 
journal software tools technology transfer 

clarke grumberg jha lu veith 
counterexample guided abstraction refinement 
cav 

clarke grumberg long 
model checking abstraction 
acm trans 
prog 
lang 
sys 

das dill 
successive approximation transition relations 
lics 

kurshan 
computer aided verification coordinating processes 
princeton university press 

lind nielsen andersen 
stepwise ctl model checking state event systems 
cav 

mitchell 
machine learning 
mcgraw hill 

moskewicz madigan zhao zhang malik 
chaff engineering efficient sat solver 
dac 

quinlan 
induction decision trees 
machine learning 

quinlan 
programs machine learning 
morgan kaufmann san mateo ca 

silva sakallah 
grasp new search algorithm satisfiability 
technical report tr cse university michigan 

wang ho long zhu ma 
formal property verification abstraction refinement formal simulation hybrid engines 
dac 
