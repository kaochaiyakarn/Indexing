semantics memory management polymorphic languages greg morrisett robert harper september cmu cs school computer science carnegie mellon university pittsburgh pa published fox memorandum cmu cs fox 
research sponsored part advanced research projects agency title fox project advanced languages systems software arpa order 
issued esc ens contract 
part national science foundation 
ccr 
views contained document authors interpreted representing cial policies expressed implied advanced research projects agency government 
static dynamic semantics machine evaluates expressions polymorphic programming language 
traditional semantics machine exposes important issues memory management value sharing control representation 
prove soundness static semantics respect dynamic semantics traditional techniques 
show techniques may establish soundness various memory management strategies including type tag free garbage collection tail call elimination environment strengthening 
keywords management type theory operational semantics garbage collection memory type theory operational semantics remarkably ective tools programming language design implementation 
important uential example provided de nition standard ml sml 
static semantics sml speci ed collection elaboration rules de nes context sensitive constraints formation programs 
dynamic semantics speci ed collection evaluation rules de nes operational semantics program 
static dynamic semantics related type soundness theorem stating certain forms run time error arise evaluation formed program 
methodology de nition standard ml re ned number subsequent studies type theory operational semantics sml related languages 
particular interest purposes variety methods de ning operational semantics deterministic sequential languages 
main approaches emerged evaluation relations transition systems 
evaluation approach typi ed kahn natural semantics extensively de nition standard ml 
transition approach typi ed plotkin structured operational semantics includes approaches machines program rewriting 
approaches share goal achieving fully semantics suppresses irrelevant details avoids speci cation facilitates reasoning programs 
experience shown goals di cult achieve single framework 
case point consider memory allocation behavior programs 
signi cant advantage high level programming languages sml details memory management inaccessible programmer 
example sml impossible determine pair values allocated heap registers 
oversight 
intention free programmer details memory management allow compiler representation choices contingencies entirely programmer control 
see appel critique discussion related points 
applying full abstraction criterion discussed operational semantics languages away details memory management de nition language 
dynamic semantics de nition standard ml avoids explicit treatment memory allocation insofar observable types 
semantics freely forms tuples environments closures recursive data structures regard representation memory 
consequently accounting memory sharing provided semantics 
purposes reasoning extensional behavior programs approach ideal 
issues memory management entirely overlooked 
example important operational semantics serve guide compiler writer data structure representation decisions critically ect performance compiled code 
case essential storage allocation decisions explicit semantics 
important notions space safety tail recursion garbage collection remain vague notions outside scope rigorous semantics 
propose explore operational semantics de ne high level execution behavior programs low level allocation behavior 
consider case study explicitly typed polymorphic programming language unbounded recursion product tuple types natural numbers type 
language su ciently rich encompass important issues including allocation types run time allocation aggregate data structures inductively de ned data structures representation types data structures 
su ciently simple admit rigorous treatment memory allocation behavior sharing storage complex values 
give operational semantics language formulated transition system states machine 
machine state includes heap containing allocated types data environment containing types bindings variables stack containing control information expression evaluated 
operational semantics related type system soundness theorem characterizing shapes values type 
illustrate framework consider detail critical storage management problems 
treatment free copying garbage collection 
collector transition system faithfully captures behavior copying garbage collector including type information parse trace heap values collection 
provide rst proof correctness collector signi cant advance current practice 
addition discuss forms garbage collection tail recursion elimination reduces space required control stack black holing reduces space required environments 
memory management techniques til ml compiler material provides faithful model particular implementation 
framework propose general model variety language implementations 
rest organized follows section syntax static semantics core polymorphic language 
section gc machine evaluating expressions 
section provides gc static dynamic semantics machine proof type soundness 
section consider issue heap garbage speci cation general purpose heap garbage collector 
show soundness particular class collectors heap objects 
section show particular heap garbage collection algorithm type tag free garbage collector tolmach closely related tag free collector til ml compiler 
prove correctness algorithm syntactic techniques similar prove type soundness machine 
section consider kinds garbage machine notably stack garbage environment garbage 
show addition tail call facility eliminate certain class stack garbage addition environment strengthening rules eliminate certain class environment garbage 
correctness memory management techniques shown syntactic methods employed previous sections 
discuss related section summarize conclude section 
gc language section call value variant girard reynolds poly gc morphic calculus 
section de ne machine evaluating expressions 
machine explicit oper gc details pertinent memory management heap control stack environment 
novel aspect gc traditional models type information maintained evaluation order support type tag free garbage collection implemented tolmach til ml compiler 
modeling allocation sharing garbage collection types just important modeling memory management 
simplify machine expressions types restricted gc named form known normal form 
restriction named form amounts requirement result step evaluation allocation bound variable refer result computation 
expression type second order calculus put named form simply introducing type expressions appropriately 
type variable type nat unit named form type type binding nat unit value variable named form expression type expression binding allocation binding succ computation binding case syntax language gc example named form representation expression nat succ type nat type succ restriction named form largely matter technical convenience 
penalty typing rules somewhat complicated expand bindings type variables type checking see section 
advantage easily recover type expression types attached bindings sub expressions 
syntax gc syntax gc language de ned 
types include type variables terms named form representation types nat unit binary products arrow types type abstractions 
types directly decorate gc order allocation sharing type information explicit 
named form type type variable binds named form type binding variable scope named form type 
named form type bindings include primitive constructors nat compound constructors components type variables type abstraction body abstraction named form type 
expressions required named form 
vari gc ables expressions binding named form binding variable scope named form expression type expressions binding named form type binding type variable scope named form expression 
named form expression binding allocation binding computation binding 
allocation bindings correspond values allocated heap 
consist primitive values compound values components variables succ hx recursive abstractions fix 
abbreviate recursive abstraction fix occur free computation bindings correspond computational steps taken evaluation 
consist case expression testing natural numbers projection pairs application term type abstractions 
chosen allocate values simplify presentation 
straightforward modify language support unallocated naturals instance de ning syntactic class small values allowing small values occur bindings 
corresponds machine registers memory locations store values 
binding conventions language familiar bound bound bound bound type bound bound fix andt bound syntactic objects identi ed systematic renaming conversion bound variables 
denote free value variables syntactic object ftv denote free type variables capture avoiding substitution de ned usual binding conventions listed 
typing rules gc typing rules gc value variables 
de ned relative contexts declaring type variables variable type assignment type variable context consider type assignments nite maps value variables types 
order bindings type assignment considered irrelevant variable may declared single type assignment 
forms type variable declarations declarations transparent declarations 
declarations processing polymorphic abstraction transparent declarations processing type binding type 
de ne abstr set bindings context transp domain set transparent bindings dom abstr transp 
precisely abstr abstr abstr ftg abstr abstr transp transp transp transp transp ftg formed type variable contexts de ned follows empty context formed context formed formed dom context formed formed dom free type variables subset abstr 
free type variable occurring transparent binding previously declared type variable 
type assignment formed respect context ftv abstr 
consider type variable contexts equivalent re ordering bindings respects dependencies transparent bindings bindings 
judgments typing rules listed axioms inference rules may derive judgments figures 
intuitively rst judgments substitute transparent type bindings free type variables eliminate nested expressions named form type obtain equivalent conventional type judgments derived conventional typing rules polymorphic calculus 
assume judgment components formed 
example order derive assume formed formed respect side conditions requirement variable bound twice context left implicit 
wellformedness condition rules may derive properties typing judgments 
lemma 
dom ftv abstr 
named form type reduces see type binding reduces see expression type see binding type see typing judgments gc language 
ftv dom ftv abstr 

fv dom ftv dom ftv abstr 

fv dom ftv dom ftv abstr 
gc machine dynamic semantics language transition system gc tween states machine 
machine derived machine felleisen friedman 
states machine quadruple heap stack environment expression language 
heap consists type heap containing gc allocated types value heap containing allocated values 
environment consists type environment providing bindings type variables value environment providing types values ordinary variables 
stack consists composition frames consisting environment term 
organization faithfully re ects conventional implementation gc language abstracts allocation environments 
treatment topic see minamide morrisett harper account closure conversion typed language :10.1.1.141.7192
particular organization fairly accurate model run time data structures til ml compiler 
establish soundness type system de ne syntactic typing discipline states machine prove progress preservation lemmas 
arise simple language considered cyclic data structures compatible syntactic type discipline 
opaque transp look opaque look transp type def 
nat nat nat unit unit unit prod arrow named form type reduction 
var exp type type 
nat nat nat nat succ nat nat nat nat nat case unit hi unit prod hx prod arrow fix arrow xx tg expression typing pointer type environment te 
type heap value nat unit ii type heap th jth 
location value environment 
heap value succ fix eii hhe eii value heap vh 
environment te heap th vh stack hhe eii program answer syntax gc machine di culties extending proofs main results 
contrast complex xed point constructions 
remainder section organized follows section syntax constructs machine 
section static semantics machine 
section transition system machine section proof soundness static semantics respect transition system 
syntax machine syntax states machine 
state program tuple heap stack environment gc expression 
environments contain type environment mapping type variables pointers heap allocated types value environment mapping value variables type variables locations heap allocated values 
important emphasize avalue environment variable type location 
heaps consist type heap mapping type pointers type heap values 
value heap mapping value locations heap values 

type heap values include base constructors nat ary constructors component types pointers heap allocated types type closures ii 
type closures contain named form representation polymorphic type type environment mapping free type variables polymorphic type heap allocated type values 
heap values include primitive values constructed values components locations heap allocated values hl value closures 
value closures hhe eii consist environment named form representation type 
environment closure provides bindings free type value variables closure abstraction 
stacks empty composition stack stack frame 
stack frames hhe eii represented closures environment value abstraction 
environment provides bindings free type value variables abstraction 
intuitively composing closures stack frame obtain current continuation machine 
chose restrict expressions continuation passing style cps gc sml nj compiler need stack machine :10.1.1.55.9444
implementations cps representation memory management stack key issue systems 
choose general framework price slightly complicated machine 
section discuss detail connection cps implementation machine 
answer programs represent terminal states machine subset programs expression portion simply value variable stack empty 
binding conventions governing constructs follows type variables domain te bound ii 
type pointers domain th bound th 
closure hh te eii expression type abstraction type variables domain te bound value variables domain bound locations domain vh bound vh 

program th vh te 
pointers domain th bound vh te 
locations domain vh bound 
type variables domain te bound 
value variables domain bound syntactic forms identi ed systematic renaming bound variables 
write fl denote free locations syntactic object fp denote free pointers value variable type variable may bound environment may location pointer bound heap 
type environments value environments considered equivalent re ordering 
type heaps value heaps considered equivalent reordering respects previously bound pointers locations 
type environments nite maps type variables pointers value environments nite maps value variables type variables locations type heaps nite maps pointers value heaps nite maps locations heap values 
convenient syntactic conventions 
abbreviates te 
te 

abbreviates te 
te 
abbreviates te 

abbreviates te 


abbreviates th 
vh th vh 

abbreviates th vh 
th vh 
abbreviates th 
vh 
abbreviates th vh 

abbreviates abbreviates hh eii hhe eii 
abbreviates union nite maps dom dom 
abbreviates th th vh vh th vh th vh 
dom abbreviates dom th dom vh th vh 
typing rules machine typing rules gc machine de ned type pointer context location type assignment informally type pointer contexts analog type variable contexts location type assignments analog variable type assignments 
type pointer contexts dependencies may consider type pointer contexts location type assignments partial functions 
furthermore types image location type assignment pointer context required closed 
free type variables type pointers 
typing judgments machine 
axioms inference rules deriving judgments figures appendix intuitively judgments extend reduction judgments named form types bindings allocated types type environments type heaps 
example judgment te applies maps pointers types range te maps type variables pointers obtain type variable context mapping type variables types 
similarly judgments extend typing judgments language value environments heap values value heaps 
judgment assigns arrow type stack meaning continuation machine expecting expression evaluate value rest computation produce value 
empty stacks explicitly tagged result type computation 
judgment determines program formed type 
type heap reduces 
value heap described assumptions 
stack hastype 
type environment reduces 
value environment described 
expression type 
technical lemma summarizes properties type system 
te type environment te reduces see allocated type reduces see th type heap th reduces see value environment described see allocated value type see vh value heap vh described see takes produces value see program type see typing judgments gc machine lemma 
te dom te dom abstr rng te dom 

fp dom ftv 

th fp th 

dom abstr 
dom 

ftv 

vh vh dom ftv 

ftv ftv 

ftv 
transition system machine execution machine de ned transition system binary relation machine states programs 
individual steps transition system 
informal description rules te nat nat te unit unit te te te te te te te ii succ succ hi hi hx fix hhe fix eii hhe eii environment substitution return current expression variable stack non empty 
right stack frame popped stack 
frame environment extended old environment binding replaces current environment 
body abstraction frame replaces current expression 
current expression type type environment substituted free type variables yielding type heap value te 
type heap value bound heap new pointer type variable bound type environment tothe pointer body type replaces current expression 
current expression environment substituted free type value variables yielding heap value 
heap value bound heap new location variable bound environment type location body replaces current expression 
zero current expression case variable bound location turn bound heap value 
clause selected current expression 
body current environment pushed stack closure evaluated evaluation complete 
return hhe eii 

te type 

te te 
zero succ proj app tapp 


case 
hhe eii succ case 
hhe eii 
hl 

li hhe fix ii 
hhe eii 

hhe ii 
hhe eii 
transition rules machine result ij fix tabs wrong print nat vh 
print nat vh 
succ print nat vh print unit vh 
hi hi print vh 
hl vh print vh print vh 
hhe fix eii fix print vh 
hhe eii tabs print prog th vh te print vh printing result succ current expression case variable bound location turn bound heap value succ clause selected current expression new binding mapping type location entered environment 
body current environment pushed stack closure evaluated evaluation complete 
proj current expression variable bound location turn bound pair hl 
appropriate component selected depending bound environment type 
computation continues body app current expression variable bound location closure 
body current environment pushed stack 
environment closure extended map location closure argument location respectively new environment taken current environment machine 
body fix abstraction taken current expression evaluated 
notice particular evaluation code closure takes place environment closure current environment 
tapp current expression variable bound location turn bound closure 
body current environment pushed stack 
type environment closure extended map bound type variable pointer argument type bound 
new environment taken current environment machine body abstraction taken current expression evaluated 
assume adding new binding environment heap bound pointer location variable fresh 
rules rules auxiliary operations te de ned 
functions substitute environment free variables binding 
types expressions substitution delayed forming closure consisting environment binding 
example consider evaluation named form expression type nat type fix succ ine th 
nat 
te 

hh te ii te 

nat hhe ii vh 


succ nat 

nat nat 

th nat te 
th 
nat te 

th 

nat app 
th 

te 


th vh te 


return 
th vh nat te 


applying print terminal state yields prog print nat vh print nat 

de ne relation 
union relations de ned transition rules write 



return zero succ proj app tapp 
rule applies program 
de nes partial function closed programs programs 
take 
re exive transitive closure 
say program diverges exists nite sequence programs 



de ne partial function answers results results natural number pair results token fix token tabs 
results wrong de nition evaluation 
de nition stuck program stuck answer print prog unde ned answer exists 
de ne evaluation relation programs results de nition evaluation relation 
exists 
print prog 
diverges 

wrong exists stuck 
fact 
rule apply closed program clear may treat evaluation total function closed programs results 
de nition evaluation function eval need suitable notion observational equivalence programs 
programs equivalent results 
de nition kleene equivalence eval eval 
type soundness prove soundness type system respect execution machine establishing transition system preserves typability typed programs answers admit transition 
viewpoint inspired wright felleisen 
state important lemmas give proof soundness 
proofs important lemmas preservation progress may appendix lemma te substitution th te te lemma substitution th vh te te 
lemma tg formed context 

tg tg 
tg tg 
proof simultaneously induction lemma tg formed context 

tg tg tg 
tg tg tg 
proof simultaneously induction lemma lemma preservation 
lemma canonical forms 
nat succ 
unit hi 

hl 
hhe fix eii 
hhe eii proof inspection heap value typing rules 
lemma progress exists 
answer lemma th vh 
exists print vh 
corollary thenthere exists print prog theorem soundness eval wrong 
proof diverges eval 
diverge exists thatp 

induction number rewriting steps preservation lemma show progress lemma answer 
corollary exists print prog wrong image print prog wrong eval wrong 
heap garbage section consider general de nition garbage heap object needed program order produce result 
notions garbage stack environment considered section 
de nition heap garbage formed program take 
say garbage respect formed de nition garbage allows eliminate portion heap long change observable behavior program 
notice heap object regarded garbage required formedness computation proceed nal answer referring object 
possible drop formedness condition consider semantic de nition garbage expense considerable technical complication 
prefer restrictive de nition simpler closer practice 
implementors variety techniques determine portions heap collected 
important techniques idea accessibility 
formally drop heap binding resulting program free binding gc fp fl gc 
idea gc 
models garbage collector drops zero bindings heap ensures dropped bindings accessible 
note formed program gc 
rule enabled drop empty heap 
furthermore composition simulated single gc 
step 
key property rewriting rules 
lemma gc 
steps gc 
preserves typing fashion 

fp 

fl proof sketch argue case part case part similar 
suppose th vh te 

exists suchthat th 
vh te fp fp fp dom th fp dom th 
may construct derivations th vh te lemma gc preservation gc 
proof induction number bindings dropped lemma 
lemma original progress result see conclude typed program stuck respect 
rules program takes gc 
step 
corollary gc progress printable answer exists gc 


consequently matter add gc 
evaluation relation welltyped program stuck 
add gc 
rewriting rules machine model implementation interleaves evaluation garbage collection 
null collection bindings eliminated possible introduces potential non termination nite repetition gc 
steps 
practice garbage collection steps occur number standard evaluation steps occurred basic block ruling nite repetition vacuous collection steps 
adopt restriction de ning 
relations consider computation sequence gcr gcr 
steps 

gcr 
relation composition gc 
gc 


note gc progress fact exists 
partial function fact gc 
ect expression 
step taken arbitrary gc 
step program taken gc 
step 
program stuck respect gcr 
answer print prog unde ned answer gcr 
de nition gc evaluation relation 
gcr exists gcr 
print prog 
gcr diverges respect gcr 

gcr wrong exists stuck gcr 
addition gc 
steps evaluator ect evaluation result program 
gcr total function mapping closed programs results fact original eval 
note result fail allowed nite repetition garbage collection steps 
showing printing una ected garbage collection 
show gc 
step followed garbage collection 
step postpone 
step taken 
follows simulate gcr 
evaluation sequence 
evaluation sequence 
lemma gc answer gc 
print prog print prog proof sketch gc 
drops bindings change bindings heap gc 
preserves typing print prog implies print prog lemma gc postponement exists 
gc 

gc 

proof suppose 
show case analysis rewriting rule 

preservation know closed gc 

corollary 
gc 
gcr 
exists proof induction postponement lemma 
theorem gc correctness gcr proof simulate 
step gcr empty garbage collection 
gcr 
consequently ifp gcr 
step simply performing 
gc 

suppose gcr gc soundness wrong 
exists gcr 
print prog corollary 
gc 
lemma print prog exists print prog exists nite sequence gc 

gc 

gc 

corollary construct nite sequence 




consequently ifp gcr course gc 
high level taken primitive instruction side conditions require global constraint free pointers locations checking constraint requires examining variable program state 
mechanism needed determine ciently pointers locations safely garbage collected 
section addresses issue 
type tag free heap collection section formulate garbage collection rewriting rule models tag free copying collection style tolmach til ml compiler 
key idea preserve heap objects reached directly indirectly current environment stack 
type information recorded environments evaluation determine shape heap objects 
allows extract locations types heap objects having heap objects 
formalize garbage collection process rewriting system 
gc states tuples form hf ht hf ht heaps set pointers set location pointer pairs gc states hf ht type pointer sets fp png typed location sets fl ln png terminology copying collectors space tospace constitute scan set frontier 
contain pointers locations immediately accessible current environment stack space forwarded space space 
addition tracks pointers types accessible locations 
extra type information determine shape value objects referenced scan set 
instance scan set bound type heap value know bound heap value form hl furthermore described 
basic rewriting rules gc algorithm follows gc 
fpg fp 
gc gc gc dom fpg 
fl pg 
dom fl pg nat case succ fpg fl pg unit hi hl fp fl hhe fix eii ii hhe eii env te 

rng te fl te te gc rule forwards type binding 
space space scan set 
free pointers allocated type added scan set ensuring bindings eventually forwarded space 
notice calculating free pointers allocated type requires tags allocated types tell instance nat 
gc rule skips pointer scan set determine pointer binding forwarded space 
gc rule rule forwards value binding 
fromspace space scan set 
free pointers free locations pointers types describing locations added scan set 
rule type information recorded location determine shape corresponding heap value extract free pointers locations 
particular function takes allocated type returns function pointer allocated type heap value appropriate type returns appropriate sets heap value 
words calculates free pointers locations heap value types locations 
furthermore requires run time tags distinguish instance naturals pairs pairs closures 
need tag information case nat determine heap value succ tag needed anyway support evaluation case expressions 
gc rule rule skips location pointer pair determine location binding forwarded space 
tag free gc algorithm initialized follows tf gc env stack tf gc 
hhe eii qa qb la lb qa la qb lb algorithm begins calculating free pointers free locations types current environment stack 
set pointers typed locations taken initial scan set heap program taken initial space 
algorithm repeatedly applies gc rewriting rules scan set empty 
point take space new heap program 
important properties gc system readily apparent 
gc system drops bindings heap introduce new bindings change existing bindings 
stage computation original heap recovered union spaces 
second rewriting system terminate heap binding moved space space step element discarded scan set binding moved space space 
properties mind prove correctness collection algorithm su ces show tag free gc system get stuck possible empty scan set resulting program closed 
system results closed program system simulated original gc 
rewriting rule proven correct speci cation garbage collection 
critical step showing tag free gc algorithm run completion proving variant ofthe canonical forms lemma 
particular show add location pointer pair scan set bound atype describes heap value bound 
ensures function fact de ned location pointer pair 
furthermore show property new bindings add scan set 
lemma unexpanded canonical forms th vh 
th nat vh succ furthermore nat 

th unit vh hi 

th vh hl 
furthermore 
th vh hh te fix eii te furthermore 
te 

th ii vh hh te eii te furthermore 
te 
proof sketch inspection typing rules 
example consider case know th 
inspection type heap value reduction rules th arrow applies 
know exist th arrow rule 
assumption 
inspection heap typing rules vh hold vh arrow rule 
vh hh te fix eii te furthermore know exist te 
cons rule conclude 
te 
lemma th vh te 
env te 
fp te 
fl te dom 

corollary th vh 
th vh 
fp vh 
fl vh dom 

proof result follows directly de nition unexpanded canonical forms lemma lemma 
corollary th vh 
stack 
fp 
fl dom 

proof result follows directly de nition stack lemma 
formulate set invariants gc state rewriting system 
de nition formed gc state typed program th vh th vh say gc state formed respect 

fp 
fl dom 

dom th 
dom vh dom th 
roughly speaking rst requirement spaces taken constitute original program heap 
bindings lost created system 
second third invariants tell holds free pointers space holds free locations space 
fourth invariant ensures location pointer pairs bound type normalized type assigned location proof original program formed 
fth sixth invariants ensure pointers locations scan set drawn pointers locations bound program heap 
show gc transition system preserves formedness gc states show formedness su cient gc state terminal scan set empty exists transition formed gc state 
lemmas direct analogs preservation progress lemmas proof type soundness machine see section 
proofs lemmas may appendix lemma gc state preservation formed formed respect lemma gc state progress formed respect empty exists gc state correctness gc transition system established showing initial gc state formed formedness terminal state su cient condition guarantee space contains bindings needed keep program closed 
theorem tag free gc correctness exists tf gc 
furthermore gc 
proof th vh te 
exists th vh te 
lemma know exists fp fl dom 
lemma know exists fp fl dom 
know fp fl dom 
initial gc state formed respect gc rewriting system diverge exists gc state hf ht step taken induction length rewriting sequence gc state preservation lemma formed respect transition exists know gc state progress empty 
tf gc 
ht 
formed respect know fp fl dom 
consequently closed gc 
kinds garbage previous sections specify certain class heap garbage collect garbage ecting observational behavior programs 
machine garbage limited heap 
section consider additional forms garbage stack garbage environment garbage source space leaks program 
show implementation may avoid leaks 
general sense frame stack garbage removing frame results kleene equivalent program observationally equivalent program 
likewise binding environment garbage removing binding results kleene equivalent program 
de nitions notions garbage precise 
de nition stack garbage formed program take 
say sub stack garbage respect formed de nition environment garbage formed program environment occurring inp program environment environment closure program obtained replacing say sub environment garbage respect formed program may practical re claim space stack frames environment entries certain points evaluation 
implementations restrict attention certain class garbage stack frames environment bindings 
remainder section examine speci approaches collecting certain classes stack garbage tail call elimination stack garbage collection environment strengthening known black holing environment garbage collection 
tail call collection tail call elimination space optimization implementations avoid unnecessary accumulation control information goal tail call elimination ensure tail recursive procedures execute iterative fashion space requirements imposed code 
framework tail call optimization phrased elimination identity continuations stack 
idea formalized transition rule id 
hhe xii id id 

rule eliminates stackframe code frame syntactically id equivalent identity function 
lemmas show 
preserves types cause typed program stuck 
lemma id preservation id 
proof form hhe xii th vh te te 
exists th vh hhe xii te su ces show 
hold cons 
induction size wecan show exists hhe xii 
su ces show induction size may show 
hold cons exist te 
hold var rule 
consequently 
tail call elimination may improve running time programs avoiding unnecessary stack manipulations decreasing time taken extract pointers locations heap garbage collection 
id corollary id progress 
printable answer exists 

gc 
rule section wish show adding id 
rewriting rules machine ect observable behavior program evaluation 
idr 
union 
id 
relations 
de nition id evaluation relation 
idr exists idr 
print prog 
idr diverges respect idr 

idr wrong exists stuck idr 
show idr total function original eval 
gcr relation show id 
step followed 
step postpone identity frame collection 
step taken 
follows simulate idr 
evaluation sequence 
evaluation sequence 
lemma id postponement exists id 


id 

proof sketch argument proceeds case analysis 
rewriting rule 
interesting case steps return rule 
case possible sub cases depending id identity frame eliminated 
transition right stack frame 
sub case return form hhe ii hhe ii id 
hhe ii return 

return 
hhe ii 
return 



id 

sub case return form hhe ii hhe ii id 
hhe ii return 

return 
hhe ii 
id 

exists 
id 

corollary 
id 
idr 
exists proof induction id 
postponement lemma 
lemma id answer id 

theorem id correctness gcr proof simulate 
step idr 
step simply performing id 
transition 
consequently ifp idr suppose idr gc soundness wrong 
exists idr 
print prog corollary id exists thatp 

lemma 
exists nite sequence id 

id 

id 

corollary construct nite sequence 




consequently ifp idr id proof 
postponement lemma relies crucially ability frames middle stack real implementations avoid pushing identity frames stack 
ect transition push frame stack split transitions frame pushed stack identity frame frame simply discarded pushed stack 
machine zero succ app tapp rules push id frames stack 
composing transitions 
transition applied right stack frame yields new transition rules tail zero tail succ tail app tail tapp case 
succ case 

hhe fix ii 


hhe ii 

easy see adding new rules choosing appropriate tail transition possible yields computation identity stack frames 
certain classes programs optimization crucial order bound amount needed run programs 
particular programs written continuation passing style cps return transition enabled computation assuming computation terminates 
function passed extra argument function continuation result function passed continuation 
ect function applications turn potential tail app transitions 
tail call elimination performed coding style delays return transitions computation assuming program terminates worst results unbounded stack space requirements assuming program diverges 
reasonable behavior observational sense unreasonable behavior practice 
furthermore heap garbage collector process preserve objects reachable unnecessary frames total amount garbage state machine grows quickly 
languages notably scheme require implementations faithfully implement tail call elimination order address practical concerns standard models scheme control stack heap explicit tail call requirement best informal contract language speci cation implementors 
contrast model allows language designer specify requirement precisely asymptotically implementation space machine requires tail rules 
model su ciently argue correctness implementation observational sense overly constraining implementations 
environment strengthening collecting garbage bindings environments collecting garbage bindings heap 
particular reasonable strategy collecting bindings environment determine bindings inaccessible code associated environment drop bindings 
formulate environment garbage collector specifying inference rules allow environment value closure ste ftv dom te te ii ste 
ii se fv dom ftv ftv dom te hh te te eii se 
hh te eii ste 
rule allows strengthen type environment type closure discarding bindings referenced type 
similarly se 
rule allows strengthen type value environment closure long free variables code domain resulting value environment free type variables code value environment domain resulting type environment 
ste 
se 
formulate rewriting rules allow strengthen various environments may arise machine state se th ii ste 
ii 
ii se th 

ii see chase discussion practical space safety issues 
se vh hhe ii se 
hhe ii 
hhe ii se vh 

hhe ii se stack hhe ii se 
hhe ii hhe ii se stack 
hhe ii se env hhe eii se 
hhe eii se env 
taken rules allow trim size kinds environments may occur machine state 
tail call collection trimming environments may allow heap garbage collected fewer heap allocated objects 
proving rules preserve types ect observable behavior programs accomplished way argued results gc 
id 
rules practice implementations perform environment strengthening certain points evaluation just implementations perform tail call elimination conjunction function application 
particular appel suggests space safe implementation strategy closures trim environment variables occur free associated code 
impractical trim current environment instruction trim environments closures pushed stack 
implementations including til ml compiler delay trimming current environment environments stack frames garbage collection invoked 
implementations functional languages perform program transformation known closure conversion eliminate nested higher order functions 
result transformation nested functions replaced record rst component code second component isa pointer data structure containing bindings free variables original function 
code abstracts environment argument function 
application replaced operations extract code environment apply code simultaneously environment argument 
respect closure conversion rei es heap closures machine language constructs fashion cps conversion rei es stack closures machine functions 
gc care taken 
transition rule nite sequences environment strengthening 
closure conversion emitting operations construct environment particular closure possible strengthen environment 
possible di erent closures share portions environment 
particular implementations cam allow closures lexical scope share environment scope 
care taken closures share environment order avoid class space leaks 
particular shared portion environment contain bindings variables occur free code closures 
machine support shared environments fairly straightforward add environments set heap allocated values may shared 
related ideas derived previous matthias felleisen morrisett dissertation simpler machine relied meta level substitution meta level evaluation contexts implicitly represent control state environment computation 
chose details explicit issues tail call elimination environment strengthening addressed 
extended previous addressing issues allocating collecting type information giving full treatment tag free collection context polymorphic language 
literature garbage collection sequential programming languages contains papers attempt provide compact characterization algorithms correctness proofs 
demers give model memory parameterized notion points relation 
result characterize reachability algorithms including mark sweep copying generational conservative sophisticated forms garbage collection 
model intentionally divorced programming language take advantage semantic properties evaluation type preservation 
consequently framework model type tag free collector section 
nettles provides concrete speci cation garbage collection algorithm larch speci cation language 
gc 
transition rule essentially high level line description speci cation tf gc 
rule particular implementation 
hudak gives denotational model tracks counts rst order language 
presents abstraction model gives algorithm computing approximations counts statically 
chirimar gunter riecke proving invariants regarding memory management fora language linear type system 
low level semantics speci es explicit memory management counting 
hudak chirimar assume weak approximation garbage counts 
barendsen smetsers give curry system functional languages extended uniqueness information guarantees object locally accessible :10.1.1.36.3338
provides compiler information determine certain objects may garbage collected written 
tolmach recovery collector variant sml passes type information polymorphic routines execution ectively implementing gc language type tag free collector section 
aditya caro gave type recovery algorithm implementation id uses technique appears equivalent passing aditya flood hicks extended garbage collection id 
past years number papers inference tag free collection monomorphic polymorphic languages appeared literature 
appel argued informally tag free collection possible polymorphic languages recording information statically performing amounts type inference collection process connections inference collection clear 
baker recognized milner style type inference prove reachable objects safely collected give account result 
goldberg recognized possible reconstruct concrete types reachable values implementation ml style language pass types polymorphic routines 
gave informal argument stack frames show values semantically garbage 
fradet gave argument reynolds abstraction parametricity theorem 
papers give complete formulation underlying dynamic static semantics language proofs correctness necessarily ad hoc 
blelloch greiner give machine evaluation parallel programming language nesl 
goal provide provable space time bounds implementation nesl 
machine directly machine 
details formulation representation control information left implicit 
summary machine describing evaluation functional programs 
traditional models functional languages machine exposes important details memory management heap control stack environment 
machine su ciently able conventional techniques specify static semantics prove soundness static semantics respect transitions machine 
machine exposes memory management issues able precisely specify important classes garbage arise evaluation programs including unreachable heap values tail call stack frames unreferenced environment bindings 
class garbage speci cation collector reclaims garbage objects proved collectors ect observable behavior formed programs 
addition detailed speci cation tolmach type tag free copying garbage collector proved correctness 
techniques specify prove correctness collectors establish type soundness machine 
admittedly machine abstracts important low level implementation details memory management 
particular priori considering programs equivalent conversion bound variables re ordering heap environment bindings ignore representation sharing issues environments 
abstracting details greatly simpli es reasoning keeps constraining implementations 
claim model provides important intermediate step establishing correctness wide class existing implementations 
acknowledgments preliminary version matthias felleisen authors 
gratefully acknowledge important contributions matthias felleisen 
grateful chris stone todd wilson morrisett careful reading useful comments suggestions 
aditya alejandro caro 
compiler directed type reconstruction polymorphic languages 
acm conference functional programming computer architecture pages copenhagen june 
aditya christine flood james hicks 
garbage collection strongly typed languages run time type reconstruction 
acm conference functional programming pages orlando june 
andrew appel 
run time tags aren necessary 
lisp symbolic computation 
andrew appel 
compiling continuations 
cambridge university press 
andrew appel 
critique standard ml 
technical report cs tr princeton university princeton nj february 
andrew appel trevor jim 
continuation passing closure passing style 
sixteenth acm symposium principles programming languages pages austin tx january 
andrew appel david macqueen :10.1.1.55.9444
standard ml new jersey 
wirsing editors third int symp 
prog 
lang 
implementation logic programming pages new york august 
springer verlag 
henry baker 
unify conquer garbage updating aliasing 
functional languages 
acm conference lisp functional programming pages nice 
erik barendsen smetsers :10.1.1.36.3338
conventional uniqueness typing graph rewrite systems 
proceedings th conference foundations software technology theoretical computer science bombay new york 
springer verlag 
extended 
guy blelloch john greiner 
provable time space cient implementation nesl 
acm conference functional programming computer architecture pages philadelphia pa may 

scheme storage allocation garbage collection algol 
algol implementation 
north holland publishing amsterdam 
ellen britton 
heap storage management programming language pascal 
master thesis university arizona 
luca cardelli 
typeful programming 
technical report dec systems research center 
david chase 
safety considerations storage allocation optimizations 
acm sigplan conference language design implementation atlanta ga june 
chirimar carl gunter jon riecke 
proving memory management invariants language linear logic 
acm conference lisp functional programming pages san francisco june 
dominique clement despeyroux thierry despeyroux laurent gilles kahn 
natural semantics computer 
technical report rr inria sophia antipolis france june 
william clinger jonathan rees 
revised report algorithmic language scheme 
lisp pointers iv july sep 
guy cousineau pierre louis curien michel mauny 
categorical machine 
jouannaud editor conference functional programming computer architecture volume lecture science 
springer verlag 
demers weiser hayes boehm bobrow shenker 
combining generational conservative garbage collection framework implementations 
seventeenth acm symposium principles programming languages pages san francisco january 
matthias felleisen daniel friedman 
calculus assignments higher order languages 
thirteenth acm symposium principles programming languages january 
matthias felleisen robert hieb 
revised report syntactic theories sequential control state 
theoretical computer science 
michael fischer 
lambda calculus schemata 
lisp symbolic computation november 
pascal fradet 
collecting garbage 
acm conference functional programming computer architecture pages orlando june 
jean yves girard 
interpretation elimination des coupures dans ordre superieure 
phd thesis vii 
benjamin goldberg 
tag free garbage collection strongly typed programming languages 
acm sigplan conference programming language design implementation pages toronto june 
benjamin goldberg michael 
polymorphic type reconstruction garbage collection tags 
acm conference lisp functional programming pages san francisco june 
paul hudak 
semantic model counting abstraction 
acm conference lisp functional programming pages august 
robin milner mads tofte robert harper 
de nition standard ml 
mit press 
minamide greg morrisett robert harper :10.1.1.141.7192
typed closure conversion 
third acm symposium principles programming languages pages st petersburg fl january 
greg morrisett 
compiling types 
phd thesis school computer science carnegie mellon university pittsburgh pa december 
available carnegie mellon university school computer science technical report cmu cs 
greg morrisett matthias felleisen robert harper 
models memory management 
functional programming computer architecture pages la jolla ca june 
acm 
scott nettles 
larch speci cation copying garbage collection 
technical report cmu cs school computer science carnegie mellon university december 
gordon plotkin 
structural approach operational semantics 
technical report daimi fn computer science department aarhus university 
john reynolds 
theory type structure 
colloq 
sur la programmation volume lecture notes computer science pages 
springer verlag 
john reynolds 
types abstraction parametric polymorphism 
mason editor information processing pages 
elsevier science publishers 
amr sabry matthias felleisen 
reasoning programs continuationpassing style 
acm conference lisp functional programming pages san francisco ca june 
acm 
zhong shao andrew appel 
space cient closure representations 
acm conference lisp functional programming pages orlando june 
david tarditi greg morrisett perry cheng chris stone robert harper peter lee 
til atype directed optimizing compiler ml 
acm sigplan conference programming language design implementation pages philadelphia pa may 
mads tofte 
type inference polymorphic 
information computation november 
andrew tolmach 
tag free garbage collection explicit type parameters 
proc 
acm conference lisp functional programming pages orlando fl june 
acm 
paul wilson 
uniprocessor garbage collection techniques 
yves jacques cohen editors international workshop memory management number lecture notes computer science pages st malo september 
springer verlag 
paul wilson 
garbage collection 
computing surveys 
expanded version 
draft available anonymous internet ftp cs utexas edu pub garbage ps 
revision appear 

methods garbage collection algol 
algol implementation 
north holland publishing amsterdam 
andrew wright matthias felleisen 
syntactic approach soundness 
information computation november 
typing rules machine 
te empty te cons te te te 

th nat nat nat th unit unit unit th prod th arrow th te ii 
th empty th cons th th th 
type environment heap reduction 
empty abstr cons 

vh zero nat vh succ nat succ nat vh unit hi unit vh prod hl vh arrow te fix hh te fix eii vh te hh te eii 
vh empty vh cons vh vh vh 
value environment heap typing 
empty 
ftv cons te hh te eii 
prog th vh te th vh te stack program typing proofs main lemmas lemma type preservation 
proof th vh te 
judgment hold prog rule exist th vh te 
proof proceeds cases rewriting rule takes see syntax directed nature typing rules 
case return hh te eii te ande th vh te 
derived cons rule exists te 
hold var rule 
hold cons rule 
cons rule 

case type th 
te vh te 
holds type exp rule exists hold lemma implies te cons th th 
te 
cons te te 

remainder cases form hold exp rule exists 
proof proceeds cases case th vh 
te 
te 
hold lemma implies cons vh vh 

cons 

case zero case 
furthermore vh th vh hh te eii te cons rule hh te eii 
way derived nat rule case succ case 
furthermore vh succ th vh hh te eii te 
cons rule hh te eii 
hold nat conclude nat nat nat cons rule conclude nat 
rule vh nat consequently succ nat 
working backwards vh succ rule nat 
te 
nat 
case proj vh hl 
th vh te 
hold prod rule conclude 
working backwards vh prod rule 

case app form vh hh te fix ii 
th vh hh te eii te 

cons rule hh te eii 
hold arrow rule exists 

consequently hh te fix ii 
hold rule 
exists suchthat te cons 


case tapp vh hh te ii te ande 
th vh hh te eii te 
te cons rule conclude hh te eii 
hold rule exists 
conclude hh te ii 
hold vh rule exists te 
conclude cons te rule te 
te 
lemma lemma progress answer exists 
proof th vh ande te 
derived prog rule exists th vh te 
proof proceeds cases case answer 
suppose hhe eii 
holds case dom 
implies dom 
consequently 

rule 
case type hold type rule conclude ftv dom 
te know abstr 
ftv dom te 
consequently te de ned 


te 
rule 
remainder cases form hold exp rule exists 
proof proceeds cases case holds fv dom 
know fv dom 
consequently de ned 



rule 
case case 
hold nat rule 
nat 
holds fv dom dom 
implies dom 
turn implies nat 
holds implies vh nat 
canonical forms lemma vh succ 
hhe eii 
zero succ rule respectively 
case hold prod rule 
holds dom 
dom dom vh 
holds vh 
canonical forms lemma vh form hl 


li proj rule 
case 
hold arrow rule 

dom holds dom 
furthermore dom holds dom vh vh canonical forms lemma vh form hhe fix ii 
hhe eii 

rule 
case 
hold rule 
holds abstr 
te de ned 
furthermore holds dom dom 
furthermore dom dom vh 
consequently vh 
canonical forms lemma vh form hhe ii ande 


te tapp rule 
lemma gc state preservation formed respect formed respect proof th vh th vh hf ht formed respect formed hf ht fp ht fl ht dom dom th dom vh andp dom th 
argument continues cases rule clear locations entered scan set bound original heap 
case gc hf 
fpg fp ht 
know ht 
suppose ht th vh 
ht fpg 
fp ht 
fp ht fp dom th fpg fpg fp dom th fpg fp dom th fpg fp fp ht 
conclude formed respect case gc fpg dom hf hf ht 
fact formed conclude bound hf ht 
bound hf bound ht 
fp ht conclude fp ht conclude formed respect case gc hf 
fl pg hf ht 
hf ht 
formed know fp fl dom 
lemma know fp ht 
fl ht 
dom 
formed respect case gc fl pg dom hf hf ht 
fact formed conclude bound hf ht 
bound hf bound ht 
fl ht conclude fl ht conclude formed respect lemma gc state progress formed respect empty exists gc state proof gc state non empty assume formed respect program 
fp ht fl ht dom dom th dom vh andp dom th 
non empty fpg conditions know bound hf ht 
bound ht gc applies 
bound hf gc applies 
non empty fl pg condition bound hf ht 
bound ht gc rule applies 
bound hf exists hf condition bound hf ht 
conditions formedness lemma hf ht consequently gc applies 

