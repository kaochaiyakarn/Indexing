meca extensible expressive system statically checking security properties yang ted xie dawson systems laboratory stanford ca describes system annotation language meca checking security rules 
meca expressive designed checking real systems 
provides variety practical constructs effectively annotate large bodies code 
example allows programmers write programmatic annotators automatically annotate large bodies source code 
example lets programmers general predicates determine annotation applied ability easily handle kernel backdoors false positive inducing constructs 
code annotated meca propagates annotations aggressively allowing single manual annotation derive additional annotations experiments freeing programmers heavy manual effort required past systems 
meca effective 
thorough case study user pointer checker annotations check thousands declarations millions lines code linux system 
errors serious having false positives 
categories subject descriptors programming languages languages constructs features software engineering software program verification statistical methods operating system security protection general terms reliability security measurement 
keywords annotation language static analysis 
static analysis find security holes 
bishop describe statically find time digital hard copies part classroom granted fee provided copies distributed profit commercial advantage notice full citation page 
copy republish post servers redistribute lists requires prior fee 
ccs october washington dc usa copyright acm 
time tocttou race conditions privileged unix applications 
finding information leaks intrusion detection checking uses user input 
course significant attention paid finding buffer overflows 
checking analyses progress features needed apply analyses system enjoyed similar advances 
programmers relatively limited means expressing program constructs check 
systems require programmers specify properties external text files 
source annotations largely limited inserting textual names front variables :10.1.1.23.8576:10.1.1.24.8366
focus unary type qualifiers expressing simple properties check impossible painful 
furthermore past systems provide fixed size fits set rules annotations propagate 
hardwired decisions aggressive cause significant number false positives :10.1.1.24.8366
weak require programmers compensate manually inserting impractical large amount annotations 
example systems splint propagate annotations function boundaries programmers annotate function interface needs checked :10.1.1.23.8576
advanced systems race detector flanagan freund overheads roughly annotation lines code cost programmer hour lines code 
past systems give programmers way exploit significant amount latent specifications naming conventions programs :10.1.1.134.9305
redundantly re annotate simply mapping preexisting specifications needed checker 
describes annotation system meca attempts counter problems 
meca extensible annotation language coupled flexible powerful annotation propagation framework 
combined meca mc checking system allows programmers write custom extensions check rich set security properties check capability doing operation untrusted variables :10.1.1.134.9305
meca allows implementors write custom checker define set annotations relevant checker 
annotations programmer annotate checker relevant parts source code 
meca propagates annotations automatically source code possibly checker specific way 
simple propagation examples function calls right hand side assignment left 
aggressive examples include propagating annotations functions assigned function pointer statistical inference annotate function formal parameters possibly conflicting annotation information function callers 
meca designed goals mind 
expressiveness 
extension writers able express program information relevant security checkers 
currently focus requirements common security properties attaching annotations program objects functions variables field types allowing bound 
allow checking common rules variables certain operations permission checks precede mutations 

low annotation overhead 
want minimize user labor minimizes amount programmer mistakes maximizes chance tool 
programmers get effect possible annotation add 

intuitive syntax semantics 
programmers able define annotations express properties direct intuitive way 

low false positive rates 
favor effectiveness soundness want find bugs possible minimizing false positives 
explicitly designed meca written source code bases equivalently new code bases initially built checking mind 
practice annotations sufficient checker check hundreds different locations 
meca combines existing techniques novel ones 
main technical contributions 
simple powerful set annotation primitives 
include data dependent annotations programmatic annotations general ary annotation predicates 

annotation inference uses statistical analysis detect missing annotations 

measurements effectiveness propagation methods 
show meca derive hundreds checks manual annotation best knowledge significantly exceeds ratio current approaches 
section gives quick overview system 
section describes annotation language detail section describes propagation algorithms section discusses annotation inference 
section gives toy example meca find missing permission checks 
section presents main case study uses meca detect illegal uses tainted pointers operating system code 
experiments show system finds errors false positives derives checks single annotation 
section discusses related conclude 
annotated trees gcc parser parser emitter control flow graph mc extension call graph fn pointers 
overview analysis 
overview gives overview meca system 
consists emitter retriever annotation propagator checking extensions 
emitter uses modified version gnu compiler gcc parse checked system source code associated annotations syntax trees asts 
asts serialized dumped disk processing call graph file containing function pointer assignments 
retriever retrieves emitted trees constructs control flow graph function sets ast trees basic blocks branching statements edges 
cfgs linked global call graph processed propagator 
propagator propagates annotations global call graph runs checking extensions 
section describes propagation detail 
checking extensions written system mc checking framework :10.1.1.134.9305
variant written ml programming language features extensions match program features care potentially associating features states tainted applied flow sensitive inter procedural manner control flow paths 
close similarities fact prior system amply documented takes checking system focuses annotation language propagation algorithm 
illustrate pieces fit consider checker enforces property operating system code dereference user tainted pointers 
concreteness refer example repeatedly subsequent sections 
operating system programmers access pointed data special paranoid routines copyin bsd derived systems 
single unsafe dereference crash system worse give malicious party control 
checker def annotation prop annotates binding fnptr binding variable parameter ret function binding binding binding annotation declaration grammar 
rule define set annotations specifying variables parameters fields tainted functions produce tainted values variables fields indicate kernel back doors ostensibly tainted pointer safe explicitly dereferenced 
programmers apply annotations source code manually possibly programmatic annotation automatically marks pointers passed system calls tainted 
meca propagate annotations source code statistically infer additional ones run checker 

annotation language section gives overview annotation language 
syntax grammar annotation keywords defined extension writer 
declared typically reside header file included checked code 
undefined annotations flagged errors catch misspellings mismatches annotations extensions 
annotations appear comments 
programmers place appropriate 
system applies extension program point statement expression path source code extension searches annotations constructs cares 
simple declaration tainted annotation follows tainted annotates variable declaration specifies tainted annotation bind variable variable variable includes actual value returned function obvious parameters global local variables 
shows sample uses 
gives general annotation declaration 
specifier binding specifies annotation bind resolve ambiguities 
example simply language default bindings type qualifier declarations causes difficulties annotations just simple type qualifiers 
programmers specify annotations bind variables general functions function parameters parameter return values ret 
specify annotation binds type programmer gives comma delimited list 
combinations redundant conflict tainted int tainted variable 
struct foo tainted int field tainted foo takes tainted parameter returns tainted pointer 
tainted int foo tainted int dst src tainted 
void memcpy tainted void dst tainted void src unsigned nbytes data copied dst tainted pointer src tainted 
label post tells system content dst tainted call copyin void copyin post tainted dst void dst tainted void src unsigned len sample annotations tainted checker section 
implied tainted void root tainted void tainted root void root void error deref tainted pointer struct ops void void struct ops root struct ops root contrived example illustrate fnptr annotation propagation 
implied annotation root propagates function pointer root assigned tainting parameter passed root 
flagged 
variable includes ret variable ret redundant combination 
annotations bind return type function definition function ret error 
general variable function majority declarations 
prop part declaration allows extension writer specify built propagation methods local fnptr 
local indicates analysis solely intraprocedural default analysis inter procedural formal parameter annotations propagated callers 
fnptr propagates annotations function pointer assignments function annotation assigned function pointer fp annotation propagated functions assigned function pointer 
gives contrived example propagation works 
binding annotations checker needs express relationships multiple program objects different annotations 
stylized way checker define annotation takes multiple arguments objects bound placed argument slots 
gen annotation label annotation args args empty arg list arg list arg arg arg arg gen annotation expr label empty pre post grammar fully general annotation 
example buffer overflow checker define set length annotation specifies integer binds pointed object 
programmer define check access annotation specify length field memcpy binds dst src parameters check access src len check access dst len void memcpy void dst void src unsigned len possibility returned value malloc bound size parameter set length ret sz void malloc unsigned sz check access annotation matched checker extracts arguments uses bound check 
gives general grammar annotations 
annotation comma separated list containing zero elements 
element annotation expression expr 
restrictions expression 
compound expression 
second expression able parsed compiler point 
restrictions annotations refer arbitrary program values function addresses variables general arithmetic expressions macros 
additionally expression refer field names parameters defined refer undefined variables 
annotations functions parameters labeled pre post means annotations bound targets function call 
default annotations bound targets calls 
allowing binding ary expressions provides nice increase expressiveness constructs unary type qualifiers 
support data dependencies checking system path sensitive suppress common infeasible paths general pruning false paths resolving data dependencies undecidable problems 
allow programmers provide help calculation fails built predicate express data dependencies expr expr valid expression implicit pruning obviates need explicit data flow flags introduced vault language 
struct foo non zero value implies struct data comes user 
int user user unknown mark field tainted mark untainted 
user unknown tainted void conservative user non zero mark field tainted 
user tainted void non conservative example structure field annotation coupled unknown keyword 
checker defined annotation 
expr true annotation bound associated object 
expression false negation expression bound tainted 
call annotations imply annotations predicate expression expr imply condition 
possible tainted checker specify parameter dependencies control argument tainted 
example declaration states foo argument tainted bitwise flag constant user flag non zero void foo flag user flag tainted char int flag similar declarations specify structure field indicates pointer structure tainted 
evaluate implication expressions compile time value may unknown 
programmers control implication case special keyword unknown evaluates true expression resolved compile time 
annotation conservative unknown implies tainted unknown implies tainted 
illustrated 
system implements imply annotations keeping track set known predicates path 
encounters program object imply annotations evaluates set known predicates 
programmatic annotations traditionally annotating source code brute force programmers insert place checker need 
reliance manual labor tedious error prone single missed annotation mean check occur process programmer quits annotating lines code 
meca lets programmers automate process programmatic annotations conceptually applied points program conditions satisfied mark program point annotation 
example specify system call parameters tainted write global param current fn sys tainted programmatic annotation specifies applied globally entire checked system global prog scope objs expr annotation scope global file global objs obj obj variable parameter ret function obj obj obj general syntax programmatic annotation declarations 
cares parameters param 
applied parameter function 
part curly braces checks current function name prefixed sys linux kernel naming convention system calls 
returns true parameter marked tainted 
general form rule depicted 
scope controls annotation applied entire system global just file file global 
note annotations overridden local annotations 
object specification controls applied functions return values parameters variables 
expr normal expr described section callout helper functions system provides 
refer program objects special variable names current fn current function current file current file current param current parameter current var current variable 
programmers checks typename program object type typename 
practice major programmatic annotations translate system specific naming conventions viewed ad hoc pre existing annotations checkable annotations 
example falls category 
example exploiting naming convention pointer parameter associated length contains name prefix length parameter foo specified foo len 
programmatic annotations useful programmers supposed manually annotate relevant program objects 
case annotation assertions prevent false negatives detecting missing annotations 

annotation propagation section describes meca flow sensitive bottom inter procedural analysis propagating annotations callees callers 
analysis initialized retrieving base annotations annotated code 
annotations consist annotations functions parameters return values 
annotations build summaries set pre condition post triples 
guard truth assignment set imply conditions pre condition post condition describe annotation bindings callsite 
example code tainted int foo tainted int post tainted void generate summary foo tainted tainted ret tainted tainted guard empty 
pre condition states argument tainted call 
post condition states call return value tainted argument remains tainted storage pointed second argument tainted 
tuple different guard expression 
usually empty guard tuple function 
set summaries function stored summary map indexed function name 
constructing base summaries analysis places annotated functions transitive callers worklist topological order function call graph 
recursive call chains broken arbitrarily 
function dequeued worklist analyzed summary converges fixed point maximum simulation time hit 
callees function analyzed function needs added worklist 
analysis analyzes path function uses caching speed 
tracks values variables symbolic store record assignments 
currently keep track parameter values level dereferences parm parm field 
similarly analysis uses predicate store pred store evaluate conditions prune false paths 
predicate store records simple conditional expressions encountered current path currently expressions composed negation equality inequality simple bit wise masks 
evaluates conditional expression encounters recorded value false skips true false branch 
extensions control annotations propagation expressions extension provided method called extension visit called analysis visited expression 
example tainted checker specify performing arithmetic tainted expression results tainted expression 
intra procedural analysis local function record annotations associated expression current analyzed path annotation store 
annotation store serves purposes 
allows analysis track annotations values correspond flow assignments expressions 
second allows update pre postconditions function summaries 
expression added annotation store analysis checks symbolic store see expression parameter level dereference parameter 
updates function precondition 
analysis reaches path function annotation store update function post conditions 
call function encountered post conditions applied 
depicts contrived example illustrate bottom propagation works 
bar pointer argument experimented deeper value flow analysis level indirection results far worth dramatically slowed analysis rarely gave useful information level tions increased approximation error occurred giving false positives 
void bar tainted void struct char buf void foo char struct char char struct ss sym value bar ss ss sym value bar ss buf ss buf unknown taint formal parameter bar bottom propogation algorithm finishes function foo summarized foo tainted char tainted buf struct char bottom propagation example 
formal parameter tainted redefined final call bar 
annotated tainted annotation propagates bottom propagation analysis 
analysis foo formal parameters annotated 
practice flow sensitivity single important feature ensure accurate annotation information 
falsely propagate annotations go giving false positives 

statistical annotation inference section describes statistically infer formal parameter annotations 
technique useful preventing false negatives caused portion callgraph contains annotations calls leaf function source code unavailable 
automatically infers plausible annotation unannotated functions uses utility metric order procedures worthwhile annotate presents ranking user inspection 
typically inspect top annotate directly 
approach allows users quickly annotate parameters type values confident 
functions annotated code annotated checked re applying bottom analysis new annotations 
precisely goal infer annotation ith formal parameter function denoted agrees callers order inferred annotations 
steps pick annotation compute correct annotation 
step trivial set annotation annotation passed ith argument annotation ith argument callsites known annotation type considered unambiguous set annotation 
practice half functions analyze consistent way 
half need second step compute probability annotation correct 
need step exactly exists actual parameters corresponding annotated conflicting types actual parameters unknown 
briefly defer problem unknowns section assume actual parameters annotated directly annotation propagation 
na ive way compute percentage 
unfortunately ignores population size 
example suppose functions foo baz parameter passed tainted pointer times times respectively 
ratio confidence true ratio bar 
contrast ratio foo coincidental easily change dramatically observations 
percentages ranking ranking scheme statistical hypothesis testing :10.1.1.134.9305
incorporates intuitions outlined institute ranking utilizes population size statistically sound way 
type inference works follows 
binary types wish compute value tells formal parameter type done examining behavior get assign type number callsites function number actual parameters corresponding type number type note annotated type type errors 
quantify reliability type assignment computing likelihood observe type errors 
done assuming errors fixed priori error rate 
model type errors independent binary trials tosses biased coin probability turning type error 
modeling type errors binary trials computed cumulative binomial distribution nx value computed equation called value 
represents number type errors get assign type denote corresponding value 
value defined analogously 
low implies type binary types means strong confidence alternative explanation type low implies strong confidence type assignment implication represent confidence score assignment type formal parameter value computed equation called value 
sum smaller values better correspond successes expected 
type inference typically set generally expected error rate low 
experiments sensitive exact value chosen 
unknowns meta annotations course determine annotation arguments callsite 
presence unknowns indicates possibly checker specific analysis failure 
limited experience unknowns context annotation inference 
initial results indicate innocuous safely ignored indicate construct code checker handle 
case higher proportion unknowns confidence inferred annotations 
section gives example incorporate information annotation inference 
best annotation far discussed ranking formal parameters type confidence 
useful reflect impact annotation 
impact utility annotation increased annotation coverage bottom analysis re applied 
may cumbersome compute approximate measure impact annotating formal parameter number actual parameters annotate number unknowns 
estimate impact annotation confidence type assignment formal parameters type confident unknown actual parameters annotations expect highest impact 
consequently wish rank formal parameters utility annotating type metric utility number actual parameters marked unknown 
complement larger values utility better 
practice utility ranking effective tainted checker rank formal parameters tainted cause greatest impact annotated 

toy capability checker operating systems linux capabilities enforce access control certain sensitive data kernel 
missed capability checks allow user processes bypass security policies potentially gain unauthorized access sensitive data 
section toy example illustrate meca checker flags missed capability checks 
checker defines predicates guard 
guard predicate specifies annotated type variable protected capability 
conversely certain structure fields protected enclosing annotation 
predicates defined lines 
variable flag definitions denotes describe properties program variables 
annotation guard cap sys admin line indicates data field defined line protected field cap contain sys admin capability 
line gives annotation uses protect entire structure just single field 
things interesting suppose useless field line need protection 
case predicate exempt useless enclosing protection 
linux uses function capable capabilities checks 
wrote simple checker tracks successful capability checks path records capability guard annotates variable annotates variable struct guard cap sys int data int cap struct int useless local annotation overwrites guard int data int data int cap guard cap sys admin void foo struct capable cap sys admin data okay data error permission capable cap sys data error wrong permission useless okay example capability checker 
set 
emits error protected object accessed required capability held 
example true branch capability check line extension records structure field cap holds capability sys admin 
checker uses information determine access data line safe 
reports error false branch line right capability 
similarly report error line 
error reported line useless protected 

checking user pointer errors section depth case study meca annotations find uses tainted pointers 
apply ideas linux measure efficacy annotation overhead 
annotations high level checker mirrors description section 
defines single tainted annotation 
programmer manually inserts annotations writes global annotators suppresses false positives kernel backdoors 
system uses flow sensitive worklist algorithm described section propagate annotations call chains function pointers 
depicts representative examples annotations inserted programmer linux code 
come categories programmatic annotations mark chunks code tainted untainted specific annotations suppress false positives selectively marking code untainted expressing data dependencies 
discuss 
described section programmer uses global annotation mark functions prefixed substring sys tainted 
precise annotations linux include asm static inline unsigned long copy user post tainted void tainted const void unsigned long linux include asm string file global param type int tainted linux drivers base sys file global param tainted int sys register root struct sys root root linux ipc shm long sys int char int tainted linux drivers isdn isdn tty isdn tty write struct tty struct tty int user user tainted const char buf int count linux drivers char random static extract entropy struct entropy store flags extract entropy user tainted void buf size nbytes int flags linux include linux module struct kernel symbol unsigned long value const char name mc ignore representative programmer inserted annotations taken linux source files 

lines annotate copy user routine paranoid functions linux move data user kernel space 
similar annotations copyin described section 
lines file scope global annotation marks non integer function parameters string tainted tainted implies error call functions tainted pointer 
functions string functions strlen strcpy dereference arguments coded assembly preventing checker analyzing 
ability single global annotation gives safe easy way express constraint 
examples representative overriding tainting annotations 
lines uses file scope annotation parameters drivers base sys file violates sys naming convention functions true system calls despite prefix 
file annotator overrides previously described global annotator marks sys functions tainted 

lines gives precise override example mark final parameter sys tainted 
annotations suppress kernel backdoors 
lines shows annotation backdoor function 
user parameter non zero pointer buf user pointer 
safe untainted kernel pointer 

lines gives complex example 
bitwise flag parameter constant extract entropy user non zero parameter buf tainted 
described section system analyzes functions data dependent annotations passes 
example system assume user zero buf tainted analyzing body isdn tty write 
crucial feature passes automatically prunes control paths assume user zero 
second assume user zero buf tainted 
system prunes paths assume user zero 
call backdoor function encountered user condition evaluated current calling context 
true corresponding actual argument set tainted 
linux small number backdoor functions 
majority functions implementing interfaces usb serial device type write tty driver write isdn 
grouped functions need annotate annotated function pointer propagation 
linux adding annotations annotate backdoor functions 
precisely suppressing tainting caused kernel backdoors eliminate false positives find bugs hidden hundreds false error messages 
case linux suppression allowed find additional errors allow malicious user print arbitrary kernel data 
lines eliminate dangerous imprecision function pointer propagation 
linux exported functions export symbol assigned structure field kernel symbols value 
assignment contains checking information whatsoever 
doing function propagation disastrous function tainted argument lead thousands false positives 
programmer explicitly annotates struct kernel symbols built annotation mc ignore suppress propagating annotations 
annotations checker essentially follow procedure outlined section 
describe checker specific aspects bottom top propagation annotations respectively subsections 
bottom analysis bottom inter procedural propagation described section propagate annotation call chains 
individual function extension perform intra procedural analysis annotating individual pointers tainted tainted 
extension deploys set customized rules propagate annotations expressions 
shows propagation rules tainted checker 
assign rule means annotation tainted tainted tainted assign tainted tainted tainted type cast tainted tainted addr tainted tainted arith tainted tainted tainted tainted tainting checker propagation rules 
tainted tainted tainted checker sees give annotation 
cast rule shows annotations preserved casts 
rule needed os code casts pointers integers back 
arith rule specifies doing pointer arithmetic tainted pointer change taintedness 
rule reverse arith rule 
addr states assigning address tainted pointer annotate tainted 
rule different rules specifies propagation rule annotation changes 
structure tainted fields tainted 
statistical annotation inference apply techniques discussed section derive annotations formal parameters actual parameters 
formal parameter number actual parameters marked tainted marked tainted 
furthermore additional parameters marked unknown 
wish rank formal parameters tainted impact annotate 
presence unknowns posses interesting problem 
tainted checker large number unknown actual parameters indicates value passed formal parameter pointer 
single dereference actual parameter led annotation tainted 
consequently presence unknowns regardless function passed tainted pointers may indicate polymorphic function take pointer type 
ranking want parameters annotated tainted wish suppress functions 
accomplish introduce notion composite types 
problem types type indicating formal parameter tainted second value passed formal parameter really pointer 
wish rank parameters composite type assignment want parameters tainted values tend pointers 
general suppose separate annotations assign formal parameter 
annotation denoted take types second annotation take types set possible types aggregate annotation cross product sets types ha bi ha bi bi bi 
suppose wish rank formal parameters annotation ha bi 
know compute score type isolation wish compute aggregate annotation 
score just value probability laws basic axioms probability get furthermore assume type assignments second annotation uncorrelated independent rules easily generalize aggregate types involving annotations 
apply rules rank formal parameters score aggregate types 
axioms allow rank formal parameters tainted checker desired manner 
composite value want rank tainted equations score tainted tainted tainted wish rank parameters utility metric cause formal parameters ranked tainted expected impact increased annotation coverage error checking 
equations final score rank parameters tainted 
results section measures effectiveness meca 
terms section define 

manual annotation annotation string added programmers hand 

global annotator programmatic annotation called global annotator 

root annotations annotations come programmers global annotators excluded annotated global annotators 

derived annotations number formal parameters level dereference automatically labeled bottom analysis 
went labeled unknown tainted tainted counted 

check define check program point programmers potentially mistake 
void bar char copyin check 
infers tainted void foo char copyin check 
infers tainted check 
annotations bar parm bar void foo char bar shows count checks construct propagation graph 
user pointer checker consider checks occur pointer dereference pointer passed annotated function annotation inferred 
note underestimate number checks count program points inference happens checks 
example dereference unknown pointer implies pointer tainted performs check pointer unknown count subsequent dereferences pointer checks 
gives example count 

propagation graph node propagation graph represents derived annotation callsite argument argument annotation tainted tainted function parameter passed derived annotation 
note count done way avoid counting vacuous annotations annotated variable passed function annotation leads check 
edge graph represents possible flow annotations parameter 
elide local variables expressions graph counts vastly inflate graph size harder evaluate effectiveness 
example propagation graph contains subgraphs subgraph rooted foo consists foo callsite bar line callsite copyin line 
consists foo callsite bar line callsite copyin line 
annotation overhead key design goals minimize annotation overhead 
section approximately measures meca meets goal counting number annotations annotations derived 
table counts number global annotators number distinct places automatically annotated 
effective global system call annotator tainted system call parameters 
file scope annotators marked parameters tainted illegal call tainted pointer 
stated benefit annotators annotation type global annotator roots generated tainted tainted total table number global annotators tainted tainted qualifiers count places annotated 
cumulative derived annotations cumulative checks cumulative root annotations cumulative derived checks cumulative errors cumulative view data table 
total errors messages file function line number scaled order fit graph 
just labor saved fact eliminate opportunity forget annotation 
table gives number manual annotations counts formal parameters expressions 
average manual annotation derives annotations marks expressions leads checks 
gives cumulative view data 
shows root annotations able derive derived annotations total checks 
coverage checker validates node propagation graph annotation nodes 
larger subgraphs better small ones force nodes internally consistent 
additionally larger number inference events cause pointer annotated tainted tainted graph better labeling occurs cross checked 
ideal subgraphs system labeled tainted tainted tainted tainted average graph size events graph table average subgraph size number related parameters checked average number inference events subgraph pointer dereference passing pointer tainted function 
tainted tainted imply total manual annotations ignore derived parameter declarations declarations manual annotation derived expressions expressions manual annotation checks checks manual annotation table total number manual annotations count derived declarations expressions 
derived parameter declarations counts number unique formal parameters annotated tainted tainted 
derived expressions counts total number expressions automatically tainted untainted 
file name function name line number 
manual annotations total global annotator excluded 
nearly suppressing false positives 
average manual annotation derives annotations expressions checks 
tainted subgraph size number parameters graph shows tainted subgraph sizes total number pointers subgraphs size 
rightmost subgraphs formed function pointer propagation 
inference events 
table shows average sizes tainted tainted subgraphs average number tainting events subgraph 
shows tainted subgraph size total number pointer parameters subgraphs size 
enormous graphs right cross check parameters 
orders subgraphs labeled tainted tainted size shows subgraphs needed cover percentage pointers 
example subgraphs sufficient label pointers annotated robustness annotation propagation stable robust 
noise inputs missing manual annotations program errors pollute propagation graph generate thousands false positives false negatives 
meca achieves robustness massive redundancies statistics 
example annotation function sufficient annotate functions assigned function pointer 
statistical inference formal parameters annotations infer missing annotations 
cumulative number parameters cumulative percentage parameters cumulative number subgraphs cumulative percentage subgraphs graph shows cumulative number subgraphs cumulative number pointer parameters 
subgraphs ordered decreasing order sizes 
subgraphs contains total pointers annotated 
believe key difference meca traditional type inference 
measure effectiveness function pointer propagation computing average node degree number edges propagation graph number nodes 
viewed approximation paths lead specific annotation 
number high breaking path propagation redundant paths keep propagation graph connected 
table shows function pointer propagation increases average node degree factor 
measure effectiveness statistical inference formal parameter annotations run meca tainted annotation function copy user annotates missing roots inferred run meca 
table shows top eleven parameters statistically inferred described section 
bottom ranked parameters shown 
inspected tainted parameters non pointers 
number distinct sources derived annotation metric robustness 
surprisingly statistical fnptr fnptr tainted nodes tainted edges average degree tainted nodes tainted edges average degree total nodes total edges average degree table propagation results function pointer propagation 
ference increased average number distinct sources factor security holes false positives bugs linux allowed malicious user take control machine 
error messages file functions user pointer dereferenced tends dereferenced times function 
table shows bugs broken ease severity exploit 
arbitrary write eleven cases user write arbitrary kernel memory 

arbitrary read cases user read arbitrary kernel memory usually passing user chosen pointer kernel print function 

fault nineteen places user cause kernel crash straightforward way 

fail cases kernel pointer passed routine expected user pointers 
calls fail error code 
errors intentional return values paranoid functions checked intentionally 
annotations described section false positives remained 
linux paranoid functions take kernel pointers global data segment set kernel 
due wrong pointer arithmetic propagation user base kernel base kernel pointer computes user base offset considered kernel pointer 
caused false paths 
predicate analysis sophisticated 
measure effectiveness suppressing false positives rerun analysis imply annotations ignore annotations 
left struct kernel symbols removing cause false positives inspect 
surprisingly false positives file name function name generated run 
gives rare security hole base kernel fs quota tested audited code 
function sys system call 
global annotator parameters including special 
tainted pointer passed lookup dev dereferences 
malicious user trivially cause kernel type warnings fixed arbitrary write arbitrary read fault fail total false positives table user pointer bugs linux broken severity ease exploit 
linux fs quota long sys unsigned int cmd const char special qid id caddr addr lookup special linux fs block dev struct block device lookup const char path path path return err ptr security hole fs quota relevant code shown crash read unfortunate device memory addresses passing value special choosing 
cross checking 
cross checking propagating annotations function pointers extremely effective 
security errors cluster programmer unaware interface rule parameter tainted stay unaware violating rule 
linux eleven write bugs read bugs propagating annotations functions assigned function pointer 
bugs single check functions files contain bugs 
gives representative example 
function sg read second argument buf call function verify area 
function sg read statically assigned field read structure type file operations 
cause system taint second argument functions assigned structure type 
example happens function read assigned variable 
reads second argument annotation propagated variable causes error passed memcpy 
interestingly user pointer name 

related numerous annotation languages designed program checkers 
systems related meca splint esc java :10.1.1.23.8576:10.1.1.24.8366
splint annotation tool detecting variety programming errors null pointer dereferences potential buffer overrun vulnerabilities 
employs simple flow sensitive analysis assisted user provided annotations fast scalable 
splint drawbacks limits usefulness effectively checking large systems 
annotation propagation actual parameters formal parameter annotation rank value rank utility tainted tainted unknown copy user put user get user put user verify area get user copy user copy user access ok user walk clear user table annotation ranking statistical inference annotation utility 
limited meca lacks true inter procedural propagation 
second small set pre defined operators splint allows unary predicates expressing program properties ary predicates 
ignore primitive essentially turns checking segment target code splint provides means systematic suppression false positives 
meca hand allows extension specific suppression hints user provided annotations user tainted example section 
type analysis tool defining inferring checking flow sensitive type qualifiers programs 
employs efficient constraint type inference algorithm propagate user provided information minimize manual annotation 
ambitious meca sound design 
forces soundness conservative alias analysis give false positives 
extra user provided alias specifications needed order suppress large portion false positives 
large amount required limits applicability large existing systems 
furthermore supports unary type qualifiers limits properties express 
esc java descends intellectual tradition program verification 
allows users write arbitrary firstorder logic formulas annotations checks automatic theorem prover 
annotation language express significantly richer set concepts meca 
appears practice meca match power lets checkers define builtin predicates 
esc java lacks extensibility terms defining new checks appears meca applies easily large code bases esc java 
esc java high annotation burden houdini shown annotation templates automatically derive esc annotations 
difference approach theirs statistical inference allows handle noisier samples deriving annotations 
gcc attribute extension allows users annotate declarations programs 
main objective gcc attributes provide gcc compiler hints error reporting syntax type errors detected frontend optimization purposes 
zhang modified gcc perl script annotate local variables certain types unchecked 
viewed hardwired programmatic annotation 
compared approach system allows programmers easily write programmatic annotations source compiler knowledge 
mops system checks security properties loosely related meca 
uses finite state represent security rules slices program state transitions specified rules transforms sliced program pushdown automaton uses model checking techniques check security errors verify absence 
compared meca provides annotation support programmers express general security rules source code 
range security rules check limited dataflow analysis simple syntactical matching variable names 
taintedness problem section explored :10.1.1.23.8576:10.1.1.24.8366
capability checking explored 

described system language expressing checking general security rules 
annotation language expressive direct 
gives programmers novel powers 
ability write programmatic annotations automatically annotate large bodies source code 
ability computationally flexible predicates control annotation applied 
ability handle kernel backdoors false positive inducing constructs 
system tailored getting results real systems 
designed easy suppress false positives 
additionally propagation abilities mean single manual annotation leads derived annotations hundreds experiments freeing programmers manual effort traditional systems 
system effective 
case study user pointer checker annotations check thousands declarations millions lines code linux system 
errors serious having false positives 
system prototype initial experiences indicate give significant traction checking large bodies real code 
linux drivers scsi sg static sg read struct file char buf size count ppos meta second argument buf verify area verify write buf count return static struct file operations sg assigns sg read read field file operations 
second parameter sg read tainted code taint second parameter functions assigned field 
read sg read write sg write poll sg poll ioctl sg ioctl 
linux drivers isdn struct file operations int void assign read read field file operations causes parameter marked tainted 
read read linux drivers isdn read struct file char size tainted function pointer prop 
error dereferencing tainted pointer 
memcpy sizeof security hole cross checking file operations read 
relevant code shown research supported part darpa contract mda stanford networking research center 
dawson engler partially supported nsf career award ted received funding nsf graduate fellowship 
grateful helpful comments yang ken anonymous reviewers 

engler 
programmer extensions catch security holes 
ieee symposium security privacy oakland california may 
bishop 
checking race file accesses 
computing systems pages spring 
chen wagner 
mops infrastructure security properties software 
proceedings th acm conference communications security pages 
acm press 
chou 
static analysis bug finding 
phd thesis stanford university 
deline fahndrich 
enforcing high low level software 
proceedings acm sigplan conference design implementation june 
dor rodeh sagiv 
string manipulations programs integer analysis 
th international symposium sas pages july 
edwards jaeger zhang 
authorization hook placement linux security modules framework 
proceedings ofthe th acm conference computer communications security pages 
acm press 
engler yu chen hallem chou andb :10.1.1.134.9305
chelf 
bugs deviant behavior general approach inferring errors systems code 
inproceedings eighteenth acm symposium operating systems principles 
evans :10.1.1.23.8576
improving security lightweight static analysis 
ieee software january february 
flanagan freund 
type java 
sigplan conference programming language design implementation pages 
flanagan rustan leino 
houdini assistant esc java 
symposium formal methods europe pages mar 
foster aiken :10.1.1.24.8366
flow qualifiers 
proceedings acm sigplan conference programming language implementation june 
freedman 
statistics norton third edition edition 
engler 
ranking analysis counter impact static analysis approximations 
th annual analysis symposium 
evans 
statically detecting overflow vulnerabilities 
usenix security symposium washington aug 
leino nelson saxe 
esc manual 
technical note compaq systems research center oct 
myers liskov 
decentralized model flow control 
proceedings sixteenth acm symposium operating pages oct 
pincus 
personal communication 
developing overflow checker version prefix oct 
ross 
probability models 
academic press london uk sixth edition 
bloch mcgraw 
static vulnerability scanner code 
annual computer security applications conference 
wagner dean 
intrusion detection 
ieee symposium security privacy 
wagner foster brewer aiken 
automated detection buffer overrun vulnerabilities 
network security conference 
san diego ca feb 
zhang edwards jaeger 
static analysis authorization hook placement 
proceedings th usenix security symposium pages aug 
