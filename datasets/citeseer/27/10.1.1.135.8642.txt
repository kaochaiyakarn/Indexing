computationally sound mechanized prover security protocols bruno blanchet may new mechanized prover secrecy properties protocols 
contrast previous provers tool rely dolev yao model 
produces proofs sequences games games formalized probabilistic polynomial calculus 
tool provides generic method specifying security properties cryptographic primitives handle shared key public key encryption signatures message authentication codes hash functions 
tool pro duces proofs valid number sessions polynomial security parameter presence active adversary 
wehave implemented tool tested number examples protocols literature 
exist main approaches analyzing security proto cols 
computational model messages bitstrings adversary probabilistic polynomial time turing machine model close real execution protocols proofs usually manual informal 
contrast mal dolev yao model cryptographic primitives considered perfect modeled function symbols terms possibly equations 
adversary compute 
model possible build automatic verification tools security proofs general sound respect 
seminal abadi rogaway interest relating frameworks see example show soundness yao model respect computational model obtain automatic proofs protocols 
approach limitations computational dolev yao models correspond exactly ad ditional hypotheses necessary order guarantee soundness 
example key cycles excluded definition encryption needed 
propose different approach automat ically proving protocols computational model built mechanized prover works directly computa tional model considering dolev yao model 
blanchet cnrs ecole normale sup erieure paris france mail blanchet di ens fr short version appears ieee symposium security privacy oakland california may 
tool produces proofs valid number sessions security parameter presence active adversary 
proofs sequences games initial game represents protocol prove goal show probability certain security property secrecy negligible game intermediate games obtained pre vious transformations difference probability consecutive games negligible final desired probability obviously negligible form game 
desired probability initial game 
represent games process calculus 
calculus pi calculus calculi 
calculus messages bitstrings primitives functions bitstrings bitstrings 
calculus probabilistic semantics processes polynomial time 
main tool specifying security properties observational equivalence observationally equiv ij adversary negligible prob ability distinguishing 
respect mentioned calculus introduces important novelty key automatic proof security proto cols values variables execution process stored arrays 
instance value th copy process defines arrays replace lists cryptographers manual proofs protocols 
example consider definition security message code mac 
informally definition says adversary negligible probability forging mac correct macs computed calling mac oracle 
cryptographic proofs defines list arguments calls mac oracle checking mac message additionally check inthis list negligible change probability 
calculus arguments mac oracle stored arrays lookup arrays order find message arrays easier automate proofs ways calculus need add explicit instructions insert values contrast lists manual proofs 
trivially sound difficult automate syntactic transformations disappear 
furthermore relations elements arrays easily expressed equalities possibly involving computations array indices 
prover relies collection game transformations inorder transform initial protocol game desired security property obvious 
transformations exploits definition security primitives order obtain simpler game 
de scribed section transformations specified generic way represent definition security primitive observational equivalence ij processes encode functions input function send result back 
prover automatically transform process calls precisely contains subterms terms computations functions process calls functions 
tech nique specify variants shared key public key encryption signature message authentication codes simply giving appropriate equivalence ij rto prover 
game transformations syntactic transformations order able apply definition primitives simplify game obtained applying definitions order prove protocols game transformations organized proof strategy advice trans formation fails suggests transformations applied order enable desired transformation strategy protocols proved fully automatic way 
delicate cases prover interac tive mode user manually specify transformations apply 
usually sufficient specify coming security definitions primitives indicating concerned cryptographic primitive andthe concerned secret key prover infers intermediate syntactic transformations advice strategy 
helpful proving public key protocols security definitions primitives applied leads proof protocol 
importantly prover sound indications user gives shows security property protocol property holds assuming hypotheses 
prover implemented ocaml lines code version available www di ens fr blanchet eng html 
outline section presents process calculus 
section describes game transformations proving protocols 
section gives criteria proving se properties protocols 
section explains prover chooses transformation apply point 
section presents experimental results 
section discusses related section concludes 
appendices contain addi tional formal details proof sketches details modeling cryptographic primitives 
notations recall standard notations 
denote 
mm xm substitution replaces xj mj cardinal set multiset terms replication index 
mm variable access 
mm function application input process nil parallel composition 
nq replication times newchannel channel restriction 
ml ei 
xk ei tk output process 
ml hn 
output new 
im random number 
im assignment defined 
ml conditional find lmj uj ei nj 
ei suchthat defined mj 
mjlj mj pj array lookup syntax process calculus denoted 
finite set ra chooses uniformly assigns tic algorithm 
xm denotes experiment random coins assigning result 
xm coins simple statement 
calculus games syntax informal semantics syntax calculus summarized 
inspired pi calculus calculi 
denote security pa rameter determines particular length keys 
calculus assumes countable set channel names de noted mapping channels inte gers maximum length channel longer messages truncated 
polynomial 
key processes run probabilistic polynomial time 
calculus uses parameters denoted cor respond integer values polynomial security parameter 
denoting interpretation valueof security parameter polynomially bounded efficiently computable function calculus uses types denoted valueof security parameter type corresponds subset bitstring 
bitstring set bit strings special symbol 
set recog polynomial time exists algorithm decides time polynomial length value 
fixed length types types set bitstrings certain length function bounded polynomial 
large types negligible 
polynomials exists forall particular types predefined bool bool true false false true bitstring bitstring bitstring bitstring bitstring 
bitstring nis parameter 
bitstrings leading zeroes 
calculus uses function symbols comes type declaration 
tm value function symbol corresponds toa function 
tm suchthat 
xm computable polynomial time 
xm value 
particular predefined infix notation equality test inequality test values type returning value boolean boolean boolean negation returning values oftype bool 
calculus terms represent computations bitstrings replication index integer serves distin different copies replicated process 
replication indices typically array indices 
vari able access 
mm returns content cell 
mm dimensional array variable variable names 
function application 
mm returns result applying function 
mm 
calculus distinguishes kinds processes input pro cesses ready receive message channel output message channel executing computations 
input process parallel composition nq represents parallel different value newchannel creates new private channel executes semantics input 
ml ei 
xk ei tk explained seman tics output 
output process new 
im chooses number uniformly stores 
im executes 
type fixed length type probabilistic polynomial time turing machines choose random numbers uniformly types 
func tion symbols represent deterministic functions random numbers chosen new 
im tic functions automatic syntactic manipulations easier duplicate term changing value 
process 
im stores bitstring value 
im executes explain process find lmj uj ei nj 
ei suchthat defined mj 
mjlj mj pj ei denotes tuple 
im 
order array tuples taken component wise instance uj ei nj 
ei uj ei 
simple example find suchthat defined tries index defined executes value wise executes words find construct value array index find con struct allows access arrays key purpose 
generally find ei 
um ei nm suchthat defined 
ml tries find values 
um 
ml defined true 
success executes 
case failure executes generalized branches find lmj uj ei nj 
ei suchthat defined mj 
mjlj mj pj tries find branch values uj 
mj 
mjlj mj true 
case success executes pj case failure branches executes mally evaluates conditions defined mj 
mjlj mj value uj ei 
ei nj 

conditions true exe chooses randomly uniform prob ability value uj ei 
ei condition true executes pj 
condi tional defined 
ml executes pif 
ml defined evaluates true 
executes 
conditional defined syntactic sugar find suchthat defined 
ml 
defined 
ml omitted omitted true explain output 
ml hn 
channel 
ml consists chan nel name tuple terms 
ml 
channel names allow define private channels sary access newchannel 
ful proofs channels protocols public 
terms 
ml intuitively analogous addresses ports numbers adversary may guess 
semantic configuration consists asingle output process process currently executed input processes 
output process exe 
ml hn 
looks channel 

evaluate thesame bitstrings 
ml arity available input processes 
input process process blocks 
input process 
ei 
xk ei tk chosen ran uniform probability 
communication executed output message nj evaluated truncated length obtained bitstring probabilistic polynomial time turing machine choose random number uniformly set cardinal power 
isnot power exist approximate algorithms example order obtain random integer choose random integer uni certain large return mod distribution close wish uniform distribution choosing large 
stored xj ei tj process blocks output process follows input executed input process follows output stored avail able input processes execution 
note syntax requires output followed input process needs output messages consecutively simply insert fictitious inputs outputs 
sary schedule outputs sending messages inputs different channels input output allows adversary control network 
instance may write 
nc 
hm 
adversary decide copy replicated process receives message sim ply sending appropriate value branch find may omitted 
note 
trailing output may omitted 
variables defined assignments inputs restrictions array lookups 
current replication indices certain program point process 
im considered program point 
im nm 
abbreviate 
im 
im cur rent replication indices kept mind abbreviation 
variables defined replication arrays example 
im nm 
im 
formally require invariant invariant single definition process satisfies ant 
definition 
im indices 
im current replication indices 
different definitions variable indifferent branches find 
invariant guarantees variable assigned value indices 
item shows definition variable executed indices trace 
invariant defined variables process satisfies variant occurrence variable access 
mm syntactically definition 
mm inwhich case 
mm fact current definition defined condition find process pj process form find lm ei nj suchthat defined 
jlj pj lj 
mm subterm jk 
invariant guarantees variables accessed initialized 
checks definition variable access scope item checked find item 
invariants checked prover game preserved game transformations 
say function 
tm poly injective injective inverses computed polynomial time exist functions tj 
xm xj canbe computed polynomial time length 
xm security parameter 
poly injective define pattern matching construct 
xm abbreviation 
xm tm 
xm naturally construct built injective functions variables 
denote var set variables occur fc set free channels 
similar input processes 
example introduce cryptographic primitives 
definition tmr tmk tms types random seeds keys message authentication codes respectively tmr fixed length type 
message au code consists function symbols mkgen tmr tmk mkgen isthe key generation algorithm argument random bitstring returning key 
usually mkgen ran algorithm separate choice random numbers computation mkgen takes addi tional argument representing random coins 
mac bitstring tmk tms mac mact mac algorithm argument message key returning corresponding tag 
mac deterministic easily encode randomized mac adding additional argument 
check bitstring tmk tms bool check check checking algorithm true valid mac message key 
mac deterministic 
bitstring tmr mkgen mact true mac uf cma satisfies unforgeability chosen message attacks polynomials maxa pr ra tmr 
negligible adversary probabilistic running time oracle access mact check called mact message definition tr fixed length types tk te types 
symmetric encryption scheme consists function symbols kgen tr tk enc bitstring tk te dec te tk bitstring kgen enc dec suchthat bitstring tr dec lr lr defined bitstrings length symmetric encryption scheme ind cpa satisfies indistinguishability chosen plaintext attacks maxa pr ra ra tr ar ra lr negligible adversary tic turing machine running time oracle ac cess left right encryption algorithm bitstrings length returns ra lr encrypts 
example consider trivial protocol mac enc xk fresh random numbers assumed share key xk symmetric tion scheme key message authentication code 
creates fresh key sends encrypted xk mac appended message order guarantee integrity 
goal protocol secret protocol modeled process start new xr tr xk tk kgen xr new tmr tmk mkgen chi qa qb qa nca new tk new xm bitstring enc xk ca mac xm qb check dec xk cb hi receives message channel start begins execu tion generates keys xk choosing random coins xr xr applying appropriate key generation algo rithms 
yields control context adversary outputting channel output copies ready executed context channels ca cb respectively 
session expected context sends message ca 
qa creates fresh key tk assumed fixed encrypts xk random coins computes mac ciphertext sends ciphertext andthe mac ca 
function tk bitstring injection needed 
context expected forward message cb 
qb receives message checks decrypts stores obtained key 
func tion bitstring bitstring 
natural injection check decryption succeeded 
key secret 
context responsible forwarding messages send messages unexpected ways order attack 
trivial running example due length con straints example sufficient illustrate main features prover 
section presents results obtained real istic protocols 
type system type system check bitstrings proper passed function array indices correctly able type variable accesses definition accesses guarded find construct type checking algorithm proceeds passes 
pass builds type environment maps variable names types 
nm definition 
im type occurs replications 
im nm 
tool checks definitions variable yield value properly defined second pass process typechecked type environment simple type system 
type system de tailed appendix defines judgment process typed environment invariant typing process satisfies invariant type environment defined ande 
require adversary typed 
restrict computing power define type cast functions bypass type system similarly type system restrict class protocols consider protocol may contain type cast func tions 
type system just explicit set bitstrings may appear point protocol 
formal semantics semantics defined probabilistic reduction detailed appendix notation term evaluates bitstring environment denote pr chai probability ofthe outputs channel sends bitstring 
isnot free pr chai semantics process probabilistic polynomial time turing machine simulates 
processes run polynomial time number pro cesses created replication length messages sent channels bounded polynomials 
conversely cal simulate probabilistic polynomial time turing machine simply choosing coins new applying func tion symbol defined perform computations turing machine 
observational equivalence context process containing hole 
evaluation con text context built newchannel evaluation context represent adversary denote process obtained replacing hole context process definition ob equivalence adapted definitions previous calculi 
definition observational equivalence processes set variables 
assume satisfy invariants variables types evaluation context said acceptable vif var var var satisfies invariants 
satisfies 
say observationally equivalent variables written ijv acceptable channels bit strings pr chai pr chai ble 
intuitively goal adversary represented context distinguish 
succeeds performs output example ch recognized ch recognized 
ijv negligible probability distinguishing unusual requirement variables comes arrays associated find construct direct access variables context access variables standard settings calculus constructs allow context access variables 
result difficult prove lemma ijv equivalence relation ijv ijv evaluation contexts var var var 
denote ijv particular case contexts acceptable channels bitstrings pr chai pr chai empty write ij ijv ij ijv 
game transformations section describe game transformations low transform process represents initial protocol process desired security property proved directly criteria section 
transforma tions parametrized set variables access 
shall see section contains prove secret 
context contain test queries access variables 
process process ijv 
syntactic transformations defined assignment 
il replace value precisely transformation performed doesnot occur non cyclic assignment 
sev eral definitions simply replace 
il accesses guarded find know 
single defini tion replace game 
ml 
ml il 
additionally update find preserve invariant sure condition find guarantees 
ml defined inthe initial game corresponding condition transformed game 
essentially 
oc transformation typically creates new 

condition 
defined explicitly conditions find order preserve invariant 
definition kept unchanged 
xis referred transformation remove definition referred root replace definition constant 
definition point important value 
example process example transforma tion substitutes mkgen inthe process removes assignment tmk mkgen 
substitution mac xm mac xm mkgen check check mkgen required section 
situation similar xk 
transformation single assign ment rename aims renaming variables variable single definition game useful dis cases depending definition set ei 
transformation applied definitions rename definition different variable 
xm 
terms ei defini tion xj ei replaced xj ei 
branch find fb eu ei en suchthat defined 

ml subterm re placed branches fb xj 
ml 
ml example consider process start new ra tr ka tk kgen ra new rb tr kb tk kgen rb qk qs qk nc th tk tk ka tk kb tk qs th find suchthat defined process qk stores table pairs host name key key ka kb ad choose key process qs queries keys find key host executes executes transformation perform distinguish cases ka kb transformation obtain pro cesses nc th tk tk ka tk kb tk th find suchthat defined suchthat defined suchthat defined simplification sketched th find suchthat defined ka suchthat defined kb suchthat defined defined ka 
simplify prover uses simplification algorithm equational prover algorithm similar knuthbendix completion 
equational prover uses user defined equations form 
xm tm mean environments xj tj true 
exam ple considering mac encryption definitions respectively tmr bitstring check mkgen mac mkgen true mac bitstring tr dec enc kgen kgen enc express poly injectivity function ex ample tk tk tk function symbol denotes inverseof 
similar formulas 
equations come process 
example true false 
low probability collision random values example defined new isa large type 
mm 
implies 
mm negligible probability 
similarly defined new type value part large type value depend negligible probability 
fact depend proved dependency analy sis 
prover combines properties simplify terms forms terms simplify processes 
example simplifies true simplifies similarly branch find removed simplifies false 
details simplification procedure ap proof proposition appendix 
proposition process satisfies invariants process obtained 
satisfies invariants ijv 
applying definition security primi tives security cryptographic primitives defined obser equivalences axioms 
importantly formalism allows specify different primitives 
equivalences prover order transform game observationally equivalent game explained section 
primitives specified equivalences form 
gm ij 
defined fol lowing grammar group functions 
nnew 
new yl tl 
gm replication restrictions 
xl tl fp function fp functional processes term new ei fp random number ei fp assignment find lmj ei suchthat defined mj 
mjlj mj fpj lookup intuitively 
xl tl fp represents takes argument values 
xl types 
tl re spectively returns result computed fp 
observational equivalence 
gm ij 
adversary negligible probability distinguishing functions left hand side corresponding right hand side 
formally functions encoded processes input arguments output result channel shown fp denotes translation functional process fp output process translation group functions put process 
translation nnew 
new yl tl 
gm inputs outputs channel trigger generation random numbers 
yl translation 
xl tl fp inputs argu ments function channel translates fp result fp 
left hand side equiv result fp functions simply term observational equivalence 
gm ij 
abbreviation 
gm ij 
example security mac definition represented equivalence ij new tmr bitstring mac mkgen bitstring ma tms check mkgen ma new tmr bitstring mac mkgen bitstring ma tms find suchthat defined check mkgen ma true false mac check mkgen function symbols thesame types mac check mkgen respectively 
different function symbols left right hand sides prevent repeated application transformation induced equivalence 
add function symbols add equation tmr bitstring check mkgen mac mkgen true mac mac mac check mkgen 
intuitively equivalence ij leaves mac computations unchanged primed function symbols lows replace mac checking check mkgen ma lookup array messages mac key mkgen array mkgen ma return true negligible probability return false 
check succeeded array adversary forged mac 
obviously form requires ris compute check macs equivalence correct 
formally result shows modeling 
fairly easy consequence definition proved appendix 
proposition mkgen mac check uf cma code mkgen mkgen mac mac check check ij 
similarly kgen enc dec ind cpa symmetric en scheme definition equivalence new tr bitstring new enc kgen ij new tr bitstring new enc kgen enc kgen function symbols enc kgen respectively bitstring bitstring function returns bitstring length argument consisting zeroes 
equations zt prove depend fixed length type andt bitstring natural injection 
representationof primitives appendix 
equivalences formalize security assumptions primitives proved correct hand security assumptions standard form mac example 
importantly manual proofs done primitive obtained equivalence reused proving differ ent protocols automatically 
equivalences ij order transform observationally equivalent process observationally equivalent order check ijv prover conditions essentially guarantee uses certain secret variables set implemented functions set occurrences terms corresponding uses variables informally properties 
exist term nm function substitution nm 
precisely applies nm write ei 
evaluation correspond function result nm 
variables occur bound tions occur terms nm min occurrences images restrictions 
precise variables 
gm 
gm nnew 
new yl tl 
gm ei new 
new yl tl ei hi ej ei 
gm ej mei 
xl tl fp ei 
xl tl fp ei hm new ei fp new ei fp ei fp ei fp find lmj ei suchthat defined mj 
mjlj mj fpj fp find lmj ei suchthat defined mj 
mjlj mj fpj fp pairwise distinct channels ei 
il ej 
jl 
translation functional processes processes allowed occur root defined condi tions case value matter just fact defined 
ei ei sequences current replication nm respectively 
prover exists function maps array indices nm ei ea correspond evaluation nm ei ea 
induce correspondence variables variables ei occur nm ea ei ei ea ei ea ei value ei ea ei trace ei prefix 
conditions correspondence satisfy 
example consider process contains enc kgen xr replication enc kgen xr replication xr bound restrictions 
xr nm nm enc kgen 
functions corresponds xr 
functions xr xr correspond xr xr independent images indepen dent random numbers 
correspondence satisfy sound ness conditions function argument term corre sponds ea type ea terms correspond ea value bound new term corre sponds ea evaluate fa new relation associates fa ea injective function numbers correspond independent 
easy check previous example satisfied 
transformation consists steps 
replace restrictions define variables re define fresh variables corresponding variables bound new correspondence variables variables extended include fresh vari ables 
second reorganize evaluation aterm stores values arguments 
function 
xm tm nm fresh vari ables computes nm stores result fresh variable uses variable simply replace nm corresponding functional account correspondence variables full formal description transformation appendix 
proposition shows soundness ofthe transformation proved appendix 
proposition process satisfies invariants process obtained 
satisfies invariants ij polynomials cj jl replication bound ijv 
example order treat example prover indication tmr tr tk fixed type declarations functions mkgen mkgen tmr tmk mac mac bitstring tmk tms check check bitstring tmk tms bool kgen kgen tr tk enc enc bitstring tk te dec te tk bitstring tk bitstring 
bitstring bitstring bitstring bitstring bitstring equations mac mac enc tk zk expresses length indication poly injective generates equations similar equations equivalences ij mac tion enc eq process example prover applies pro cess example described example 
pro cess transformed security mac 
mac xm mkgen check mkgen nm mac mkgen nm check mkgen ma xm ma 
transformation get process start new xr tr xk tk kgen xr new tmr chi nca new tk new xm bitstring enc xk ca mac xm mkgen find suchthat defined xm xm check mkgen true dec xk cb hi false dec xk cb hi initial definition removed replaced anew definition call 
term mac xm mkgen replaced mac xm mkgen 
mkgen find suchthat defined xm xm check mkgen true false yields transformation processes processes 
process looks message array xm contains mac computed key mkgen 
computed check fails false definition security mac 
returns true check mkgen 
applying simplify unchanged find suchthat defined xm xm check mkgen tk cb hi tests true 
false 
simpli fied 
term dec xk simplified knowing xm find condition xm enc xk bythe assignment defines xm xk kgen xr assign ment defines xk dec enc kgen kgen enc 
dec xk injectivity 
assignment equations bitstring 
tk applying xk apply se encryption enc kgen xr kgen xr 
simplify kgen xr tk zk keys length 
obtain game start new xr tr new tmr chi nca new tk new xm bitstring enc zk kgen xr ca mac xm mkgen remains 
lists arrays simplifies transformation need add instructions insert values list variables implicitly arrays 
occurrences mac xi initial process check mj maj replaced find branch occurrence mac 
prover distinguishes automatically cases checked mac maj comes occurrence mac thatis distinguishes cases depending value mj xi 
typically distinguishing cases useful steps proof protocol 
similar situation arises cryptographic primitives specified find 
criteria proving secrecy proper ties define syntactic criteria allow prove protocols 
proofs results appendix 
definition session secrecy process session secrecy qx ij qx 
um nm defined 
um 
um 
um nm defined 
um new fc 
um var 
nm intuitively adversary distinguish process puts value secret outputs random number 
adversary performs single test query modeled 
proposition session secrecy consider process exists set variables defi nitions restrictions new ei ei 
ml restrictions new 
ac cesses variables form ei 
ml qx ij preserves session secrecy intuitively variables depend restriction sent messages control flow independent adversary obtains implementation set computed starting adding variables defined ei 
ml definition secrecy process preserves secrecy rx ij rx nc 
um nm defined 
um 
um nc 
um nm defined 
um find suchthat defined 
um 
um um chy new fc 
um var 
nm 
nm 
intuitively adversary distinguish process puts value secret indices outputs independent random numbers 
definition ad perform test queries modeled rx 
corresponds real random definition se 
shown notion stronger standard approach adversary perform asingle test query reveal queries reveal 
um 
proposition secrecy assume satisfies proposition 
trace evaluation context define ea defining restriction ea follows ea defined new ea int ea ea ea defined ea 
ml ea 
mk environment ea assume evaluation contexts acceptable probability pr ea ea reduces tot ea ea ea negligible preserves secrecy hypothesis verified simplify section detailed appendix 
intuitively hypothesis guarantees ea ea ea negligible probability ea ea defined restrictions independent random numbers 
show notion secrecy composed cor assertions prove security key exchange 
correspondence assertions properties event fm executed events ei fmi executed 
im plemented verification correspondence assertions 
lemma ij preserves session se preserves session secrecy thesame result holds secrecy 
apply technique 
prove preserves session secrecy transformations described section 
propositions obtain process suchthat ijv 
propositions show pre serves session secrecy conclude preserves session secrecy lemma 
example transformations example access considered process tk considered process 
sition considered process preserves session secrecy 
lemma process preserves session secrecy 
process preserve secrecy adversary force sessions replaying message sent 
accordingly proposition satisfied 
criteria section restrictive fact sufficient protocols provided previous transformation steps powerful protocol simpler protocol criteria applied 
proof strategy described available game transforma tions 
explain organize transformations order prove protocols proof successful cryptographic transformation transformation section prover executes simplify tests desired se properties proved described section 
stops order perform cryptographic transformations syntactic transformations proof strategy relies advice 
precisely prover tries execute available cryptographic transformation turn 
transformation fails returns syntactic transformations desired transformation advised transformations 
prover tries perform syntactic transformations 
fail suggest advised transformations executed 
syntactic transformations succeed desired cryptographic transformation may succeed fail new advised transformations soon 
prover determines advised transformations follows assume try execute cryptographic transfor mation need recognize certain term find part parts accesses 
expect function appli cations 
case advise 
forexample contains enc xk look xm kgen xr xr advise xk 
contains xk mkgen xr look mac xm mkgen xr advise xk 
example advised reason 
try execute accesses variable guarded find advise 
check secret session se assignment ei fm assignment defining 
check secret session secret assignment ei fm isdefined restrictions definitions accesses form ei fm advise 
pieces advice ones extend needed 
experimental results successfully tested prover number literature 
protocols tested configuration honest participants willing adversary prove secrecy keys sessions honest participants 
examples shared key encryption encoded symmetric encryption scheme mac example public key encryption ind cca indistinguishability adaptive attacks public key signature assumed cma unforgeability chosen message attacks 
proof prover outputs sequence games built succinct explanation transformation performed consecutive games indication failed 
proof fails prover outputs sequence games game sequence desired property transformed prover 
manual inspection game possi ble understand proof failed attack attack game limitation ofthe prover fact able prove property transform game reasons proto col proved assumptions situation may lead immediately practical attack computa tional model 
otway rees automatically prove secrecy key 
yahalom original version protocol show session secrecy exchanged key protocol secure encrypt mac definition encryption 
confirmation round nb exchanged key 
may reveal information confirmation round prover shows session secrecy show secrecy absence confirmation round adversary may force sessions yahalom key 
needham schroeder shared key key confirmation round may reveal information key 
removing round prover shows session secrecy exchanged key 
prove secrecy exchanged key adversary may sessions protocol key 
prover shows secrecy corrected version 
denning sacco public key prover show session secrecy exchanged key attack protocol 
session secrecy key proved corrected version 
secrecy proved adversary force sessions ofthe protocol key 
model timestamps protocol 
contrast previous examples main proof steps prover manually follows enc crypto sign sign success variable defines table public keys places corresponding principals principals defined adversary variable example 
instruction allows distinguish cases 
instruction crypto means prover apply definition security encryption primitive enc key generated ran dom number 
instruction success means prover check desired security properties proved 
needham schroeder public key protocol au protocol 
prover check authentication transform key exchange protocol ways choosing key nonces na nb shared na nb hash function random oracle model 
na nb session secrecy key proved original protocol due known attack 
corrected version prover shows se key na nb 
original cor versions prover prove session secrecy na nb 
nb failure proof corresponds attack adversary check nb number sending protocol accepts nb 
na failure proof comes limitations prover prover take account na accepted messages contain na sent prevents attack 
case examples failure proof comes limitations prover problem probably solved improving transformation simplify 
denning sacco protocol main proof steps prover manually follows distributed key na nb sign rks crypto enc enc success distributed key na nb proof follows sign rks crypto enc enc crypto na total runtime tests pen ghz version prover 
examples included distribu tion available www di ens fr blanchet eng html 
related results show soundness dolev yao model computational model possible dolev yao provers order prove protocols model 
results limitations particular terms allowed cryptographic primitives satisfy strong security properties correspond yao style primitives require restrictions protocols absence key cycles 
frameworks exist formalizing proofs computational model 
backes pfitzmann waidner designed cryptographic library cluding symmetric public key encryption message authentication codes signatures nonces shown respect computational primitives arbitrary active attacks 
backes pfitzmann relate computational notions secrecy framework library 
framework computationally sound machine checked proof needham schroeder lowe protocol 
canetti introduced notion 
herzog show dolev symbolic analysis prove security protocols framework universal composability restricted class protocols public key cryptographic primitive 
automatic dolev yao verification tool verifying proto cols framework 
lincoln mitchell mitchell ramanathan scedrov probabilistic polynomial time calculus analysis security protocols 
define notion process calculus derive compositionality properties define equational proof system calculus 
datta derek mitchell shmatikov designed computationally sound logic enables prove computa tional security properties logical deduction system 
frameworks mentioned paragraph properties protocols computational sense relies dolev yao prover checked proofs mechanized far know 
laud designed automatic analysis proving protocols shared key encryption passive adversaries 
extended active adversaries session protocol 
closest 
extend considerably handling primitives poly nomial number sessions 
laud designed type system proving se protocols computational model 
type system handles shared key public key encryption un bounded number sessions 
system relies waidner library 
type inference algorithm 
barthe generic model random oracle model interactive theorem prover coq proved signature schemes inthis framework 
contrast specialized prover proofs generic interactive theorem provers require lot human effort order build detailed proof theorem prover check 
halevi explains implementing automatic sequences games useful suggests ideas direction implement 
presents prover security protocols sound model 
prover works little help user handle wide variety generic way produces proofs valid polynomial number sessions presence active sary 
represents important progress respect previous area extended prover provide exact security proofs proofs explicit probability asymptotic result probability negligible prove correspondence assertions 
inthe interesting handle cryptographic primitives diffie hellman key agreements equivalence nnew new ga gb gab ij nnew new new ga gb gc models decisional diffie hellman sumption 
sufficient prover handle protocols diffie hellman key agreements cryptographic transformation require formed chosen copy sin gle replicated process typically case bare chosen different participants protocol 
involved equivalence needed fact equivalences specify security properties primitives need extended essential idea simulating proofs sequences games automatic tool applied protocol crypto graphic scheme 
tool applies fairly direct way security assumptions primitives mathematical reasoning 
best suited proving security protocols high level encryption signatures 
limited proving security primitives lower level primitives subtle mathematical arguments needed 
acknowledgments david pointcheval advice tions computational proofs protocols 
project possible 
initiating 
partly supported project ara 
abadi 
formal eavesdropping computational interpretation 
kobayashi pierce editors theoretical aspects computer soft ware tacs volume lecture notes computer science pages sendai japan oct springer 
abadi needham 
prudent engineering cryptographic protocols 
ieee transactions software engineering jan 
abadi rogaway 
reconciling views computational soundness formal encryption 
journal cryptology 
abdalla 
pointcheval 
password authenticated key exchange party setting 
iee proceedings information security mar 
ad ao bana herzog scedrov 
sound ness formal encryption presence key cycles 
de di vimercati syverson gollmann editors proceedings th european symposium research computer security esorics volume lecture notes computer science pages milan italy sept 
springer 
backes laud 
computationally sound mechanized flow analysis 
proceedings th acm conference computer ccs pages alexandria va nov 
acm 
backes pfitzmann 
symmetric encryption dolev yao style cryptographic library 
th ieee computer security foundations workshop pages pacific grove ca june 
ieee 
backes pfitzmann 
relating symbolic secrecy 
ieee transactions dependable secure computing apr 
backes pfitzmann waidner 
compos able cryptographic library nested operations 
th acm conference computer communication secu ccs pages washington oct 
acm 
backes pfitzmann waidner 
symmetric au simulatable cryptographic library 
editors computer security esorics th european symposium research computer security volume lecture notes science pages norway oct 
springer 
barthe 
machine checked formalization generic model random oracle model 
basin rusinowitch edi tors second international joint conference automated reasoning volume lecture notes science pages cork ireland july 
springer 
baudet cortier kremer 
implementations equational theories passive adversaries 
monteiro editors proceedings nd international colloquium automata languages programming icalp vol ume lecture notes computer science pages lisboa portugal july 
springer 
bellare desai rogaway concrete security treatment symmetric encryption 
proceedings th symposium computer science focs pages miami beach florida oct 
ieee 
full www cse ucsd edu users mihir papers sym enc html 
bellare desai pointcheval rogaway 
re lations notions security public key encryption schemes 
krawczyk editor advances crypto volume lecture notes computer science pages santa barbara nia usa aug 
springer 
bellare kilian rogaway 
security ofthe cipher block chaining message authentication code 
journal computer system sciences dec 
bellare rogaway 
security triple tion framework code game playing proofs 
editor advances cryptology euro crypt proceedings volume lecture notes computer science pages saint petersburg rus sia may 
springer 
extended version available eprint iacr org 
blanchet 
automatic proof strong secrecy 
ieee symposium security privacy pages oakland california may 
blanchet 
computationally sound mechanized correspondence assertions 
th ieee computer security foundations symposium csf venice italy july 
ieee 
appear 
extended version available eprint report eprint iacr org 
blanchet pointcheval 
automated sequences games 
dwork editor crypto volume lecture notes pages santa barbara ca aug 
springer 
burrows abadi needham 
logic au 
proceedings royal society london 
preliminary version appeared equipment systems research center report february 
canetti 
universally composable security cryptographic protocols 
proceedings nd symposium foundations computer science focs pages las vegas nevada oct 
ieee 
updated version available cryptology eprint iacr org 
canetti herzog 
universally composable sym analysis mutual authentication key exchange protocols 
halevi rabin editors proceedings theory cryptography conference tcc volume lecture notes computer science pages new york ny mar 
springer 
extended ver sion available eprint iacr org 
cortier warinschi 
computationally sound au proofs security protocols 
sagiv editor proc 
th european symposium programming esop volume lecture notes computer science pages apr springer 
datta derek mitchell shmatikov andm 

probabilistic polynomial time semantics protocol security logic 
monteiro ed icalp nd international colloquium automata languages programming volume notes computer science pages lisboa portugal july 
springer 
denning sacco 
timestamps key dis tribution protocols 
commun 
acm aug 
halevi 
plausible approach computer aided proofs 
cryptology eprint archive report june 
available eprint iacr org 
herzog 
computational interpretation dolev 
theoretical computer science june 
lakhnech 
completing soundness formal encryption presence active adversaries 
sagiv editor proc 
th eu symposium programming esop volume lecture notes computer science pages apr 
springer 
knuth bendix 
simple word universal algebras 
leech editor computational problems algebra pages 
oxford 
laud 
handling encryption analysis secure formation flow 
degano editor programming languages systems th european symposium pro gramming esop volume lecture notes computer science pages warsaw poland apr 
springer 
laud 
symmetric encryption automatic analyses active adversaries 
ieee symposium security privacy pages oakland california may 
laud 
secrecy types simulatable cryptographic li 
th acm conference computer communications security ccs pages alexandria va nov 
acm 
lincoln mitchell mitchell scedrov probabilistic poly time framework protocol analysis 
acm computer communication security ccs pages san francisco california nov 
lincoln mitchell mitchell sce 
probabilistic polynomial time equivalence security protocols 
wing woodcock davies editors fm world congress formal methods development computing systems volume lecture notes computer science pages toulouse france sept 
springer 
lowe 
breaking fixing needham key protocol fdr 
tools algorithms construction analysis systems volume lecture notes computer science pages 
springer 
mitchell scedrov 
composition protocols probabilistic polynomial time process calculus 
amadio editors concur concurrency theory th international conference volume lecture notes pages marseille france sept 
springer 
micciancio warinschi 
completeness abadi rogaway logic encrypted expressions 
journal computer security 
micciancio warinschi 
soundness formal en presence active adversaries 
naor editor theory cryptography conference tcc vol ume lecture notes computer science pages cambridge ma usa feb 
springer 
mitchell ramanathan scedrov probabilistic polynomial time calculus analysis cryptographic protocols 
theoretical computer science mar 
needham schroeder 
encryption large networks computers 
commun 
acm dec 
needham schroeder 
authentication re visited 
operating systems review 
otway rees 
efficient timely mutual 
operating systems review 
ramanathan mitchell scedrov probabilistic bisimulation equivalence security analysis network protocols 
walukiewicz edi tor fossacs foundations software science computation structures volume lecture notes science pages barcelona spain mar 
springer 
shoup 
proposal iso standard public dec 
iso iec jtc sc 
shoup 
reconsidered 
journal cryptology sept 
backes basin pfitzmann andm 
waidner 
cryptographically sound theorem proving 
th ieee computer security foundations workshop csfw pages venice italy july 
ieee 

machine checked security proofs crypto graphic signature schemes 
de di vimercati syverson gollmann editors proceedingsof th european symposium research computer security esorics volume computer science pages milan italy sept 
springer 
woo lam 
semantic model protocols 
proceedings ieee symposium research security privacy pages oakland california may 
appendices type system section define type system check bitstrings belong expected type 
able type variable accesses defi nition accesses guarded find construct type checking algorithm proceeds passes 
pass build type environment maps variable names 
tm 
tm indices type 
im 
environment built follows defined new 
im 
im 
ml 

im replications subprocess 
im nm 
nm defined find 


im 
suchthat defined 


find 
im nm 
nm 
require definitions variable yield thesame value properly defined process typechecked type environment rules 
defines judgments means term type 
mean output process process typed environment respec tively 

mm 
mm suitable type 

mm called 
te 
tm mj 
mm tvar 
tm mj 
mm tfun 
qe nq qe newchannel mj xj ei tj pe 
ml ei 
xk ei tk tin mj nj tj qe 
ml hn 
tout fixed length type ei pe new ei tnew ei pe ei mj ei lj mjk mj bool pj pe find lmj uj ei nj 
ei suchthat defined mj 
mjlj mj pj typing rules tm mj type tj 
mm type type system requires subterm typed 
furthermore type find lmj uj ei nj 
ei suchthat defined mj 
mjlj mj pj mj type bool nq type new ei fixed length type say occurrence term process oftype type environment 
replication formal semantics definition semantics formal semantics calculus figures 
rest appendix multiset union 
multiset number el ements equal semantic configuration quadruple environment mapping array cells output process currently scheduled multiset input processes running parallel cis set channels created 
semantics defined reduction rules form meaning reduces probabil ity security parameter 
value omitted notation 
index serves distinguishing reductions yield configuration probability different ways certain reduction computed correctly pr 
te probability trace computed follows pr 
pr ej pj qj cj define auxiliary relation evaluating terms simply means term evaluates tothe bitstring environment rule cst simply 
rule serves replication indices substituted constant values reducing 
rule var looks value array variable environment 
rule fun evaluates function call 
rules def def evaluate conditions find defined defined 
ml returns false def returns boolean value def auxiliary reduction relation simply input processes 
relation transforms configurations form rule nil removes nil processes 
terms find conditions cst mj aj 
am dom 
mm 
am var mj aj 
tm aj tj 
mm 
am fun ak mk ak defined 
ml false def ak mk ak false true defined 
ml def input processes nil par nq repl newchannel ca newchannel mj aj 
ml ea 
xk ea tk ca 
ea 
xk ea tk input reduce normal form semantics rules par repl expand parallel compositions repli cations respectively 
rule newchannel creates new channel adds semantic configurations considered equiva lent modulo renaming channels single semantic configuration obtained applying newchannel 
rule input evaluates terms input channel 
input executed communication done output rule 
relation convergent confluent terminating normal forms 
processes configurations normal form start 
rules new find simply reduce scheduled process explained footnote page approximately uniform probability distribution choosing element set power 
choose random integer uniformly certain function ris div mod returns probability elements 
div choose block 
probability case mod small wish choosing large output processes fixed length type new ea 
ea 
new ea ea 
ev ea 
ev dj mj aj ev ev aj ev true aj ev true ej ev ea 
ev find lmj ea suchthat dj mj pj ev ej ev pj find ev ea 
ev dj mj false find lmj ea suchthat dj mj pj find mj aj nj bj reduce 
fa 

fa 
fa 
ea 
xk ea tk bj tj 
ml hn 

ea 

xk ea 
output semantics 
choose 
probability choosing element div approximates rules find find evaluate find 
compute value conditions dj mj find possi ble values indices ea 
conditions rule find executes branch find 
conditions true rule find chooses true case ev ev approximately uni form probability executes corresponding branch ofthe find 
rule output performs communications evaluates channel sent messages selects input desired channel randomly immediately executes 
scheduled process rule receiving process 
process blocks suitable input avail able 
initial configuration running process reduce fc 
definition channel name bitstring say executes chai immediately probability executes chai denoted pr chai 
fc pr chai pt pr wheret set traces 
em pm qm em pm qm cm executes chai immediately ej pj qj cj execute chai immediately fc pr chai 
variable defined section show invariant implies assigned execution process 
multisets max multiset suchthat max max 
define mul variable accesses may defined process follows defined defined defined defined defined nq defined defined newchannel defined defined 
ml ea 
xk ea tk xj ea defined defined 
ml hn 
defined defined new ea ea defined defined ea ea defined defined find lmj ea mj 
mjlj mj pj max ea defined pj defined define defined dom defined defined defined uq defined 
invariant single definition executing games se mantic configuration satisfies invariant defined contain duplicate elements 
lemma satisfies invariant sat invariant 
lemma satisfies invariant 
proof sketch show cases defini tion 

defined 
result fol lows 
satisfies invariant variable de fined value array indices trace 
invariant just executing definition ea defined contain duplicate elements ea dom ea defined defined 
variables defined section show invariant implies defined 
order show property invariant invariant defined variables executing games se mantic configuration satisfies invariant occurrence variable access 
mm dom mj aj 
am dom syntactically definition 
mm inwhich case mj constant index defined condition find process pj process form find lm ei nj suchthat defined 
jlj pj lj 
mm subterm jk 
lemma satisfies invariant sat invariant 
lemma satisfies invariant 
proof sketch 
mm second case variant execute definition 
mm mj constant replication index 
mm added dom rules new find output moves case invariant 

mm third case invariant corresponding find access simply pears 

mm case invariant find selecting branch 
mm jk lj 
show induction subterms 
mm forall mj aj 
am dom hypothesis semantic rule find mj aj 
am dom 

mm moves case invariant cases situation remains unchanged 
satisfies invariant traces 
am dom rule var succeeds considered term occurs defined find consider application rule var array access 
mm defined condition find 
array access variable find mj aj 
am dom 
test 
am dom succeeds 
typing section show type system compatible withthe semantics calculus define notion typing semantic configurations show typing preserved subject reduction 
property semantic configurations typed shows certain conditions inthe semantics hold 
say 
am 
tm aj tj 
define 
rule type constant replication indices 
formulas giving typing rules replication indices may constants say similarly ife lemma proof sketch induction derivation lemma reduce 
proof sketch cases derivation 
case replication noticing 
input lemma 
lemma 
proof sketch lemma previous definitions 
lemma subject reduction 
proof sketch cases derivation lemmas 
immediate consequence lemmas satisfies invariant traces tests fixed length type rule new rule aj tj rule fun test false true def succeed 
runtime proposition process exists time turing machine simulates proof give brief sketch proof 
reader detailed proof different calculus proof adapted calculus length bitstrings manipulated processes polynomial security parameter 
hypothesis received messages limited security parameter 
length random polynomial security parameter hypothesis types 
function symbols correspond functions run time output bitstrings size polynomial size inputs polynomial security param eter 
number copies generated polynomial security parameter total number executed instructions polynomial security parameter easy see instruction runs polynomial time bitstrings polynomial length 
processes run polynomial time 
simplification section define transformation simplify whichis simplify games 
simplification proceeds follows 
uses information sources equations rules user come particular algebraic properties cryptographic primitives facts hold points game due form game dependency information obtained dependency analyses 
dependency analysis tracks variables depend element array program point 
local de analysis tracks terms depend current cell array ei program point 
uses information order infer equalities knuth bendix equational prover 
obtained simplify game replacing term equal term simplifying find system proves taken 
user defined rewrite rules user give kinds information claims form 
xm tm environments xj tj true 
claims typed 

xm 
tm bool 
translated rewrite rules follows form var var generate rewrite rule 
xm tm 
form generate rules 
xm tm false 
xm tm true 
rules instance different constants different 
generate rewrite rule 
xm tm true 
claims form new 
new yl 
xm tm ij var var 
formally claims mean evaluate tothe bitstring cases negligible probability provided 
yl chosen randomly uni form probability 
respectively 
xm type 
tm 

xm may de pend 
yl 
formally approach claims polynomials exists maxa pr ra 
yl ra 
xm 
yl probabilistic turing machine running time 
phrasing requires checking re create 
yl pairwise distinct whichis delicate 
may depend value array indices 
prefer definition substitution allows rename 
yl possi bly equal variables 
claim new 
new yl 
xm tm ij means polynomials exists ble substitutions 
yl variables 

yl 
yj maxa pr ra 
ra 
xm 
probabilistic turing machine run ning time 
claims need adapted definition 
stance write new new pkgen pkgen ij new new pkgen pkgen ij false may pkgen probability fact variable 
claim typed 

xm 
tm 

yl 

claim translated rewrite rule new 
new yl 
xm tm 
term reduces rewrite rule new 
new yl 
xm tm term con text substitution maps xj term type tj yj terms form fm isdefined restrictions new prover built rewrite rules defining boolean functions true false false true bool true false bool bool 

bool bool 
bool true bool false false bool true true bool false prover support commutative function sym binary function symbols suchthat 
equality matching tests performed modulo commutativity 
functions commutative instance rewrite rules may rewrite true false false true true false defined functions declared commutative xor example commutative function 
collecting true facts game facts represent properties hold certain processes 
consider kinds facts defined means defined term means true term evaluates true 
section show howto compute set facts guaranteed hold point game function collects facts hold program point game 
precisely occurrence pof subprocess game computes set facts occurrence 
important process processes occurrences may equal distinguished 
computes set containing pairs ei ei defined just process 
definitions pair definition 
output processes set facts hold output executed stores set 
superscript fut stands fu ture facts hold hold 
function defined 

takes account ei defined input restriction find updates accordingly 
furthermore execute ei ei holds ei defined 
execute find lmj uj ei nj 
ei suchthat defined mj 
mjlj mj pj mj holds pj mj 
mjlj uj ei 
ei defined pj mj holds mj lj calling complete may input output process come processes fp fp fp immediately add facts deduce facts defined precisely defined fp 
mm sub term take account facts known definitions adding fp follows fp fp im fp fp fp ca 
mm im 
defined 
mm subterm 
mm defined definition 
mm process executed reaching facts hold hold indices fp fp 
mm im 
occurrence occurrence code output yielding control code reaching fact fp hold 
syntactically possible code executed reaching reaching output fp fp 
definitions know add facts hold cases intersection definitions operation may add new defined facts fp fixpoint reached order avoid infinite loops execute step definitions defined contains nested occurrences thesame symbol 

consider additional fact serves expressing condition part find failed 
precisely 
um nm 
ml means 
um nm terms 
ml defined false function described collects facts hold occurrence 
called set true nq newchannel 
ml ei 
xk ei tk thenf defined xj ei xj ei 
ml hn 
return new ei thenf defined ei ei return fp ei thenf defined ei ei ei return fp find uj ei nj 
ei suchthat defined mj 
mjlj mj pj pj defined uj ei 
defined ei defined mj 
defined mjlj mj pj uj ei pj 
ei pj mj mj lj return fp pj function nq newchannel 
ml ei 
xk ei tk 
ml hn 
new ei ei thenf eu en 
ml occur 
ml find uj ei nj 
ei suchthat defined mj 
mjlj mj pj eu en 
ml uj 
occur 
ml pj uj ei 
ei nj 
mj 
mjlj jmj 
function facts occurrence sets value case restrictions assignments find takes account variable uj 
newly defined 
facts variables defined removed 
case branch find adds facts hold conditions find fail conditions express branch fact 
construct fact replace applying terms uj ei 
ei 
respectively 
case output code may executed input processes variable may defined code facts removed 
function input processes argument argument empty processes follow 
facts add new facts facts fp implies 
ml defined 
um fact 
um nm 
ml implies false 
um 
precisely execute fp fp 
um nm 
ml dom 

um 
mj subterm defined fp possible images exploring set defined facts fp furthermore previous update adds facts complete computed sets adding facts processes fp fp fp immediately iterate addition consequences 
simplicity current implementation perform iteration 
global dependency analysis variable global dependency analysis tries set variables variables depend particular global dependency analysis succeeds control flow view adversary depend cases negligible probability 
variable defined restrictions new large type 
set variables assignments 
sdep set variables containing 
intuitively sdep superset variables say function uniform antecedents particular true cases uniformly distributed distributed 
restriction image inverse poly injective function 
consider undefined image 
contrast rest allow tobe defined subset 
precisely xk defined pattern matching 
xn xk xk defined know value xk im 
say characterizes part obtained substituting definition dependency cy cle variables substitute variable side definition implies 
fk fm 
fk fm uniform functions 
fk forsome fm renaming variables sdep fresh variables fm subterm fm variables sdep occur fm fm thetype result 
case value uniquely determines valueof 
fk fm simple rewriting prover determine 
consider set terms kind user defined mentioned point section rule rewritten set contains equal ity form 
fk fm 
fk fm 
fk fm 
fk fm fm fm variables sdep occur fm fm wehave characterizes part sdep say characterizes part character part union set defined restrictions 
know variables different defined restrictions de pend absence precise information wecan set sdep say dep intuitively depend adversary see value formally dep 
variables occur input output channels occur terms 
mm 
nk input 
mm ei 
xk ei tk output 
mm hn 

variables defined assignments 
variable occurs variables may occur defined conditions find root 
terms mj processes find lmj ei suchthat defined mj 
mjlj mj pj combi nations terms contain variables form characterizes part occurs characterizes part variable occurs 
item implies result tests depend onthe values variables cases negligible proba bility 
tests characterizes partof depend variables false cases negligible probability thevalue uniquely determines value 
fk fm depend 
fk fm equal ity happens single value 
fk fm yields negligible probability 
fk uni form chosen uniform probability type large 
similarly tests true ex cept cases negligible probability 
checking conditions dep parts code unreachable due tests result known conditions set computed fixpoint iteration starting adding variables defined assignments variables local dependency analysis program point variable local depen dency analysis tries find variables terms depend ei program point ei denotes current definition simplifies game possible 
occurrence process variable suchthat restriction new occurs compute set terms indep indepen dent ei ei denotes current replication indices occurrence process variable suchthat restriction new occurs compute depend 
know set pairs ei depends ei assignments term defining ei function ei 
tuple ei denotes current replication indices define characterizes part ei asfollows 
defined 
mm 
mm replication index indepp 
mm 
mm defined depend dependp 
mm 
mm fresh variable 
write 
say characterizes part ei implies 
fk ei 
fk ei forsome uniform functions 
fk ei subterm ei subterm type result indep indep indep indep nq indep newchannel indep 
ml ei 
xk ei tk 
indep local dependency analysis large type 
case thevalue uniquely determines value 
fk ei property shown simple rewriting prover global dependency analysis denote subterms set subterms term say depend function applications terms indep repli cations indices terms 
mm 
mm depend restrictions depend depend 
terms indepp de pend ei dependp variables component dependp depend ei con ditions guarantee depend ei current replication indices definition depend denote term ob tained replacing ei depend ei denotes replication indices define version equal cases probability 
term defined asfollows case 
proceed fol lows 
depend letm dependp 
obtained re spectively replacing array depend fresh replication indices 
characterizes part ei false 
mis equal false negligible probability case 
similar cases swapping mis 
case true 
case 

false return false 
true return 
true return 
return 
cases 
cases depend indep dependp depend indepp indep 
ml hn 
indep new ei large type depend indep fp subterms depend depend indep indep ei depend indep ei depend depend depend indep ei indep depend depend depend depend depend indep indep depend indep find uj ei nj 
ei suchthat defined mj 
mjlj mj pj mj replace mj false remove th branch true lj replace replace depend indep true replace depend indep mjk depend depend depend indep subterms defined fpj depend depend indep pj depend depend indep local dependency analysis local dependency analysis defined figures function initially called designates function defined 
input processes sets sothat depend gives information propagates indep ei set output process thevalue ei may output read find processes executed soon process output definition lose track exactly variables de pend ei 
variables defined passes control process proved dependent ei remain independent ei indep subprocesses 
case output forgets depend mentioned 
case restriction new ei large type create dependency information newly defined variable variable depends ei defined restriction independent ei 
note ei independent ei adding ei indep 
case assignment ei de ei variable ei depends ei added depend ei depend ei added indep 
case find simplify condition ofthe find remove branches prove negligible probability remove find know branch taken branch find define variables 
furthermore find depends ei variable depend set control flow depends ei assignments fact depend ei signed expression longer keep track precisely variables depend ei 
wise add terms guaranteed defined independent ei indep 
equational prover algorithm inspired knuth bendix differences detailed 
prover manipulates pairs set facts defined set rewrite rules say reduces term context 
rewrite rules considered constants 
prover starts certain set facts 
transforms pairs rules rf means transformed rf reduces rule ora user defined rewrite rule rf 
mm 
rf 
mm defined restrictions new large type false denoting term obtained ing array indices replication indices fresh replication indices proper ties occurs defined restrictions new large type characterizes part obtained optionally applying terms form fm restrictions occurs defined restrictions new large type characterizes part dep variable occurs false program point 
rf reduces rule ror user defined rewrite rule reduces rule rules obtained sides equality 
rule simplifies facts rewrite rules 
rule decom poses conjunctions facts 
rules exploit elimination collisions random values 
rule takes defined restriction large type different cells negligible probability contain ing value 
cells contain conclude negligible probability cell 
rule expresses ble probability equal defined large type characterizes part item establishes dependency analysis second item exploits global dependency analysis third item exploits dependency analysis 
rule applied rules ap plied 
rule transforms equations rewrite rules orienting 
say form fm occur defined 
mm 
mj 
intuitively goal re place defines content variable 
notice ordering knuth bendix gorithm normally uses reduction ordering orient equations 
tried reduction orderings lex path ordering knuth bendix ordering obtained disappointing results prover fails prove equations left unoriented 
simple heuristic succeeds greater risk non termination cause problems practice examples 
believe particular structure equations come conditions find tend variables creating dependency cycles rules systematically applied simplify rewrite rules new rewrite rule added 
terms rewrite rules considered constants rule fact includes deduction critical pairs done standard knuth bendix completion algorithm say yields contradiction prover starting derives false 
game simplification transformations order simplify games transformations exploit information collected explained previous sections 
term game replaced simplified term obtained reducing user defined rewrite rules point section rewrite rules obtained fpm equational prover pm process containing replacement formed user defined rewrite rule avoid complicating game variables value 
find lmj uj ei nj 
ei suchthat defined mj 
mjlj mj pj ei reduces user defined rewrite rules section rewrite rules obtained fpj occur removed th branch find ei replaced mj 
mjlj mj pj replaced ei pj 
intuitively ei thevalue ei computed evaluating performing array lookup 
remove ei looked find replace ei value 
suppose find lmj uj ei nj 
ei suchthat defined mj 
mjlj mj pj 
nl subterm mjk conditions holds def contains def occurs occurs contains lp replications process contains definition lp length longest common pre fix 
nl current replication indices definitions th branch find 
case 
nl defined th branch find taken 
find lmj ei suchthat defined mj 
mjlj mj pj fpj yields contradiction th branch find removed 
find replaced 
find lmj ei suchthat defined mj 
mjlj mj pj fp yields tion replaced 
find eu ei en suchthat fp yields contradiction variables replaced find defines variables eu remove 
find lmj ei suchthat defined mj 
mjlj mj uj outside 
defined conditions find updated ant satisfied 
defined condition defined defined implies defined simplification appears scope con dition added condition 
new game replaced 
simplifications applying game simplifications described fur ther apply transformations move restrictions downwards code possible array access find 
new ei moved replication composition sides ei input 
ml ei 
xk ei tk put 
ml hn 
occurs 
ml 
nk find conditions canbe moved constructs duplicating necessary move find uses branches note restriction new ei input parallel composition replication written output located parallel composition replication syntax processes violated transformation duplicates new ei mov ing find uses branches enables distinguish cases branch created useful proofs 
useless particular case transfor mation remove useless assignments assignments unused assignments ei fm 
removing assignments may variables repeat removal fixpoint reached 
auto particular case definitions variable ac cesses form 
il definition 
il 
il current replication definition array access find rename 
xm different name defi nition 
applying definition security formalization transformation appendix formalize transformation performed equivalences come definition security cryptographic primitives 
require equivalences ij model cryptographic primitives 
satisfy invariants 
furthermore function type corresponding function 
functional processes fp simply terms array accesses current replication indices 
allowing find difficult need rec terms context possibly cally modified form 

structure replications functions number arguments types function 

variables yj defined new xj defined distinct variables 
restriction single function 
xl tl fp transform fx ft fp 
fpm 
im nm 
fx ft fp 
fpm 

im 
order eliminate situations satisfy requirement 

replications resp 
pairwise 
strengthens typing typing variables accessed array indices variables defined replication 

restrictions new occur term min occurs 
guarantees sis zjk mj 
defined land mj 
hypothesis guarantees defined hypothesis 

finds form find lmj suchthat defined zj 
mj fpj fp conditions satisfied lj concatenation current replication indices prefix non empty prefix non empty lj concatenation prefix current repli cation indices sequence uj lj exists 
lj zjk defined syntactically zjk prefix 
find access variables defined different functions variables zjk defined find transformation considerably complicated 
equivalences ij prover process observationally equivalent process observationally equivalent give sufficient conditions process tobe equivalent 
conditions essentially uses certain secret variables set canbe implemented calling functions conditions detail 
define function extract order left right hand sides equivalence 
extract 
xl tl 
xl tl extract nnew 
new yl tl 
gm 
jk 
yl tl extract gj 
jk extract 
gm 
jk extract gj 
jk rename variables variables rdo occur 
assume exist set variables sand set occurrences terms 


term occurs condition part find defined 
ml channel input 

exist sequence bl 
jl extract bl 

yl tl 

xm tm substitution suchthat 
applies abbreviated form nin write ei con ditions hold 
mj yjk variable access zjk mj 
zjk define zjk yjk 

definitions zjk form new zjk 
mj oc cur replications may occur different replications different val ues 

zjk zj 

sequence array indices mj 
mj may 
denote tion maps current replication indices definition zjk mj 
respec tively 
ml set bythe previous definition set index map current replication indices 
substitution index image contain current replication indices denote im index sequence indices definition zjk im index mj 

similarly 

xj term type tj 

occurrences variable zjk root argument find process 
precise term element refers subscript writing yjk yjk zjk zjk xj xj tj tj nm 
define mj 
say terms share se quences random variables yjk yjk zjk zjk nnew 
greatest integer share sequences random variables require 
sets variables zjk nnew zjk disjoint 



nm nm index contain cur rent replication indices 
conditions satisfied exists context ijv terms occur conditions find sis terms may refer variables defined find transformation variables moved outside scope violating invariant 
terms occur channel input transformation input process need perform compu tations find forbidden syntax 
limitation practice terms channels inputs typically current replication indices con tain cryptographic primitives 
hypothesis sequence bl indicates corresponds term hypothesis checks values received inputs proper type 
hypothesis checks vari ables zjk correspond variables defined new proper type 
variables yjk defined new terms correspondingly hypothesis checks corresponding variables zjk hypothesis checks directly context 
distinct variables yjk correspond inde pendent random numbers 
correspondingly hypothesis requires variables zjk created different tions distinct variables yjk accessed withthe indices fixed 
correspondingly hy requires variables zjk indices im index refer yjk indices refer yj indices corre refer zjk sis refer zj index evaluate bit strings index evaluate thesame bitstrings index 
hypothesis hypothesis 
conditions guarantee wecan establish correspondence array cells variables array cells variables defined new correspondence injective function required section term evaluated indices yl 
computed asingle value arguments 
xm 
correspondingly share random variables index evaluate bitstring evaluate thesame bitstring 
compute possible values sets fix point iteration 
start containing bound restriction 
try possible vari ables 
term contains variable try function corresponds succeed add add variables correspond bound restrictions 
fail transforma tion possible 
continue fixpoint reached case occurrences variables terms describe construct process ijv 

move restrictions right hand side occur reception arguments functional processes inside func tional processes 
explained correctness subsequent transformation restrictions appear corresponding part left hand side 
precisely transform right hand side equivalence follows 
jl extract 
jl 

yl tl 

xm tm ml extract 
jl 


lm lm 
xm tm fp fp add sequence random variables 
lm lm occur defined conditions find remove new fp replace new constant cst add fm contains fm 
transformation needed right new random number chosen exactly different call function 
xm tm fp 
guaranteed transformation left hand side evaluated occurrences random numbers yl tl 
ml occurrences corre single call 
xm tm asingle call 
xm tm fp copy fp occurrence 
transformation fp contains choice random numbers times changing result 
ml evaluations occurrences cor respond different calls 
xm tm transformation necessary 

create fresh variables corresponding vari ables right hand side equivalence 
extract bl 


lm lm 
xm tm fp de fine nnew 
create fresh variables jk jk nnew share sequences random variables jk jk nnew variables jk oth pairwise distinct 
create fresh variable xj fresh variable defined new 
update defined conditions finds order pre serve invariant 
precisely defined condition ofa find contains zj 
ml add defined jk 
ml nnew condition 
accesses jk 
ml created transforming term satisfy invariant accesses zj 
ml occur sat invariant 

update restrictions corresponding restrictions hand side equivalence remove replace restrictions corresponding hand side equivalence 
precisely occurs root term mk condition defined 
ml replace definition new cst constant cst occur defined tests remove definition zj add new jk jk foreach nnew new 

transform terms corresponding left hand side equivalence corresponding functional process right hand side term pm cm containing 
note occurs put pm output process 
pm new lk lk nnew nnew xk tk xk cm fpm 
defined follows xj 
il xj 

il 
jk 
ij jk im 
il current replication indices xj 
current replica tion indices variable defined new fpm function array accesses array accesses ex tended terms substitution 
mm 
mm 
cm fp defined recursively follows cm cm cm new fp new cm fp cm fp cm fp cm find fb fp find cm fb cm fp find branches fb cm fb defined asfollows cm suchthat fp suchthat cm fp cm eu en suchthat defined zk mk 
mkl fp eu en suchthat defined zk mk 
mkl im eu ei im cm fp length prefix indices occurs mk 
mkl set zk defined sequences random variables ei isthe sequence current replication indices eu formed fresh variable variable ei en sequence bounds replications extension zk mk 
mkl zk im eu ei zk jk zk mk 
mkl zk eu zk defined input 
essential parts transformation numbered 
step add restrictions create random variables correspond random variables create variables jk place zj initial game chosen zjk forany zj create jk just evaluating step term corresponding fpm delicate part evaluating fp mis case find looking arrays look corresponding arrays mapping 
extension introduce small extension equivalences 
gm ij 
described section 
equiva mode 
gm modem ij 
empty 
mode indi cation prover guide application equivalence changing semantics 
occurrences initial game root terms inside gj 
empty variable defined new gj correspond hypotheses guarantee usage modes 
empty 
sets random variables chosen gj possible combinations applying 

gj form 
xl tl fp restriction 
restriction definition empty mode 
modeling primitives appendix gives definition number prover 
super pseudo random permutations tr large fixed length large fixed length tk kgen tr tk tr kgen kgen tr kgen kgen new tr kgen kgen ij new tr find suchthat defined suchthat defined new find suchthat defined suchthat defined new equivalence expresses encryption tion oracles replaced inverse random permutations 
random permutations built follows tion oracle receive argument passed tothe encryption oracle return previous result receive result previous call decryption oracle argument decryption oracle call return fresh random number 
collisions numbers tr negligible probability ob tain permutations cases negligible probability 
construction similar decryption oracle 
public key cryptography uf cma signature tr large fixed length fixed length ts tpk ts bool skgen skgen tr pkgen pkgen tr tpk tr pkgen skgen true tr pkgen skgen true new tr new tr ij pkgen skgen pkgen skgen nnew tr pkgen new skgen tpk si ts si ij 
nnew tr 
pkgen 
new skgen 
tpk si ts 
find suchthat defined 
pkgen 
si true 
find suchthat defined 
pkgen false 
si lines side equivalence generation public keys computation signature left unchanged transformation 
cation signature si replaced lookup computed signatures signature checked keys pkgen pkgen valid computed signature oracle skgen 
lines right hand side find return true succeed 
lines right hand side returns false lines pkgen line han case key pkgen 
case check signature 
transformation allows reapply transformation value model deterministic signatures similar way removing third argument ind cca public key encryption tr large fixed length fixed length enc enc tpk te dec dec te skgen skgen tr pkgen pkgen tr tpk 

poly injective zt tr dec enc pkgen skgen tr dec enc pkgen skgen new tr new tr ij pkgen pkgen skgen skgen nnew tr pkgen te dec skgen new tpk enc ij nnew tr pkgen te find suchthat defined pkgen dec skgen tpk find suchthat defined pkgen new te enc zt pkgen new enc decryption transformation reduces cpa public key encryption described 
ind cpa public key encryption tr large fixed length fixed length enc enc tpk te dec te skgen tr pkgen pkgen tr tpk 

poly injective zt tr dec enc pkgen skgen new tr new tr ij pkgen skgen skgen nnew tr pkgen new tpk enc ij nnew tr pkgen tpk find suchthat defined pkgen new enc zt pkgen new enc hash functions collision resistant hash function tk fixed length tk bitstring new tk bitstring bitstring ij hash function random oracle model fixed length bitstring bitstring ij bitstring find suchthat defined new note game include parallel protocol process nc bitstring prover incorrectly assume adversary com pute hash function 
particularity related fact random oracle sary implement explicitly access 
xor xor commutative xor xor xor xor 
nnew xor ij nnew modeling xor improved equations particular associativity 
proofs proof proposition proof satisfies invariants proof ijv relies traces traces configuration trace executes chai immediately corresponding con figuration corresponding trace executes chai im 
correspondence obtained replacing internal actions corresponding internal actions sketch proof cases leave case reader 
proof sketch proposition pro cess satisfies invariant definitions variables du occur different branch find invariant variable access xj 
ml comes variable access 
ml 
satisfies invariant access definition case replaced definition witha definition xj xj 
ml definition access defined test case ina defined test access branch find witha condition defined 
nl 
ml nj case 
ml substituted xj 
ml branch find xj 
ml suitable defined condition 
fore satisfies invariant invariant type environment type environment setting 
xm defined 
type typeof definitions xj 
proof obtained proof replacing requests xj ing parts proof correspond find prove ijv 
denote process obtained applying name partial function tuples 
subscripts 
variable infor mally 
trace corresponds xj 
corresponding trace 
de fine function relates configurations configurations trace renamed process show function maps traces probability show de equivalence ijv 
define sarenamej terms sarenamej replaces occurrences appropriate xj 
precisely sarenamej 
ml xj sarenamej 
sarenamej ml mk ak 
dom sarenamej 
ml sarenamej 
sarenamej ml sarenamej 
ml sarenamej 
sarenamej ml sarenamej define sarenamej input output pro cesses follows 
precisely renames name renaming process replaces variable accesses xj definition caused re placement occurs duplicates find renaming variable variable accesses xj find replacement occurs 
definition find un der nested finds guarantee defined itis important follow exactly renaming procedure happened 
formally done ing construct processes distinct occurrence symbol reducing annotated processes 
remember oc symbols constructs cause variable renaming 
sarenamej replaces term sarenamej 
define sarenamej environments xj 


dom 


dom 
unde fined cases 
extend sarenamej semantic configurations sarenamej sarenamej sarenamej sarenamej define sarenamej way 
show sarenamej sarenamej proof proceeds induction inter case 
ml 
derived var mk ak 

induction hypothesis sarenamej mk ak sarenamej 
ml xj sarenamej 
sarenamej ml sarenamej xj 

sarenamej sarenamej show cases reduction sarenamej sarenamej 
sarenamej reduce reduce sarenamej evaluation context acceptable show trace 
em pm qm cm exists trace 

cm proba bility function jm mq cm jm em pm qm cm 
proof proceeds length trace 
induction step distinguish cases depending reduction step trace 
initial case fc fc modify channels 
function defined 

var sarenamej sarenamej fc fc sarenamej reduce fc reduce fc sarenamej step trace definition 
induction hypothesis trace length associated function jm 
configuration em pm qm cm satisfies invariant 
dom em em pm instruction definition xk 
property sarenamej prove indices resp 
xk thesame execution pm 
define jm jm 

show obtain trace length function jm 
step trace find defined condi tion refers induction hypothesis length associated function jm 
fb find pm succeeds certain variables defined find exactly copy defined condition xjm 
defined condition ofthe branch fb pm refers 

find fails pm copies fail 
fore number successful choices find isthe pm 
successful branch taken 
pm executes successful branch build corre sponding trace executing successful branch 
pm executes branch executes branch 
obtain suitable length associated function jm jm find defines 
case item proof applied 
cases easy execute way pm 
show converse property 
cm trace 
em pm qm cm withthe probability mq cm em pm qm cm 
proof similar proof mq cm em pm qm cm channels bitstrings em pm qm cm exe chai immediately cm executes chai immediately 
pr chai pr chai 
ijv 
proof sketch proposition simplify proof variants relatively easy focus proof ijv evaluation context acceptable maximum runtime poly nomial 
denote initial configuration define pmax max large type associated user defined rewrite rules runtime 
probability pmax negligible maximum constant number negligible functions 
shall prove probability desired fact doesnot hold pmax polynomial itis negligible 
proof follows structure simplification algo rithm prove correctness component algorithm separately 
correctness collection true facts 
consider modified semantics calculus process accompanied substitution defines replication indices process 
example rule repl semantics nq 
evaluating term process substitution withthe rule cst rules modi fied accordingly 
judgment means fact holds en vironment substitution 
defined mif true defined 
um nm 
ml forall 
xm nm defined 
ml false 

um 
xm 
extend definition sets 
say correct 


implies fp goal correct occurrences processes process initial configuration fp fq 
show immediately calling fp reduced process result obvious 
proceed cases reduction example ei ei 
wehave defined ei ei 
ei defined ei 
ei fp proceed similar cases 
show immediately calling fp correct 

fp initial configuration property 
configurations conclude 
show invariant fc input output process just thenf fp property obvious preserved updates fq provided defined facts added easily satisfy prove fq fq proof easy cases derivation 
reduce fq fq prove correct ob tained fp fp immediately correct show 


proof proceeds induction length trace initial configuration property follows 
inductive step reduction trace output 

ml hn 

ei 
xk ei tk ei 
xk ei 
reduce 
induction hypoth 
fp fp correct fq fp fp tion hypothesis 
hypothesis 

extension 
reduction output form 
induction hypothesis 
correct fp fp fp fp fp 
show 

output process fore trace output process trace output trace doesnot contain reduction rule output 
proof proceeds induction output result ous 

pm immediate subprocesses pj extension 

definition fp value pj considered immediately 
fpj fpj extension output trace 
induction hypothesis fpj 

show correct ob tained fp im fp fp fp ca 
mm im defined 
mm subterm fp oth correct assume 

show correct fp defined mj aj 
am dom 
definition 
am considered trace 
show 
im fp un der fp 
im am 
desired result follows 
reduction defines 
am considered trace 
fp correct fp exten sion facts hold hold wehave 
im trace 

ex output con figuration output 
substitution changed ex communication 
cases happen 
trace 

executes output 

output 
substitution executing communication 
correct forall fp fp cases fp show 

proof proceeds induction trace 
initial configuration result obvious 
inductive step result obvious 
oth proceed cases reduction trace 
output case result obvious new find cases unchanged definitions variables facts claim variables defined removed find case find lmj uj ei nj 
ei suchthat defined mj 
mjlj mj pj eand unchanged find executed nj 
uj ei 

ei 
defined mj 
mjlj mj false 
nj 
mj 
mjlj jmj 
uj ei 
ei 
induction hy nj 
mj 
mjlj jmj 
show correct fp 
um nm 
ml dom 
um 
mj subterm defined fp correct assuming 

show fp cor rect fp sume 
um nm 
ml 
mj subterm defined fp ak uk ak foreach 



um 
am defined mj mj 
induction mj 
definition facts defined 
ml false false false 
conclude computation fp correct correctness local dependency analysis 
inthe correctness collection true facts denote occurrence process distinguish occur occurrences process 
show soundness local dependency analy sis ignoring modifications game performed 
show soundness game modifications modifications change behavior game negligible probability 
game change part computation depend indep performed modification procedure performing full dependency analysis game modification performing game modification redoing dependency analysis analysis modified game fixpoint reached 
separate dependency analysis game modifications outlined sufficient prove correctness pro cedure 
defined restrictions exists dependp 
obvious case element added dependp assignment ei addition happen isdefined restrictions 
depend indep define equivalence 
depend indep environments depend indep indep depend ea ea ei exists depend ea ei ea defined ea defined defined ea ea ei denotes replication indices definition defined ea defined ea defined defined ea ea 
depend indep environments dif fer variables depend ei contained depend indep 
terms indep value item variables depend value second item variables defined value third item 

dependp indepp show depend expresses correctness definition doesnot depend 
prove induction derivation converse follows immediately swap ping roles 
case 
doesnot depend 
bm 
bm 
hypothesis bj case indepp 
result comes defini tion case replication index 
result holds 
case 

de pend defined restrictions depend depend 

bk 
bk 
induction hypothesis bj 

bk 
bk consider property 
pr dependp dependp ei current replication indices 
pr indepp 
pr ei pr ei denotes current replication definition show dependp holds property expresses correctness local depen dency analysis dependp 
general case property 
item says dependp evaluates contents item says indepp value de fined item important independence properties 
essentially traces differ value ei probability differ values variables depend ei collected depend environments related 
value ei fixed probability environment related times probability reaching environment value ei show holds indep pr depend indep indepp holds indep indepp 
essentially prop erty means added indepp doesnot depend items hold hypoth 
dependp indep dependp indep conversely obviously dependp indep dependp indep dependp indep dependp indep 
proves item con cludes proof 
prove dependp holds decreasing induction process cases inwhich depend follows occurs new ei 
depend indepp defined fp subterms 
item holds triv 
traces non zero probability reach reduction reduces new traces form ei 

correct fp subterms defined fp exten sion proves item 
se mantic rule new pr ei pr condition valueof ei 
item value ei elements indepp defined ei defined 
items ei 
obtain item 
occurs new ei wehave depend dependp indepp indep ei 
traces non zero probabil ity reach reduction reduces new traces form ei 

item comes fact extension 
item comes induction hypothesis fact extension fact ei defined 
ei environment restricted variables defined 
pr ei pr ei pr pr step semantic rule new second induction hypothesis step semantic rule new 
obtain item 
occurs ei traces non zero probability reach reduces traces ei 

ei 
depend dependp dependp indepp indepp ei 
inthis case environments 
show holds induction hypoth 
ei 

dependp dependp dependp indepp indepp 
hypothesis dependp ei ei dependp ei 
item follows immediately induction hypothesis 
item follows fromthe induction hypothesis 

occurs find lmj uj ei nj 
ei suchthat defined mj 
mjlj mj pj pj mjk depend 
dependp indepp indepp indep indepp subterms defined pj depend pj 
wecan show branch find taken withthe probability forthe 
induction hypothesis show holds indepp indep 
concludes proof 
terms suchthat subterms defined fpj depend 
fpj correct fpj term indepp 
indep 
applied indepp 
indepp holds indep 
holds atp indep 

holds indep 
indepp 
define special semantics processes semantics executes process normally configuration dependp dom 
reaching con figuration executes restrictions variables defined restrictions assigned executed restrictions assignments depend second part trace configuration set restricted current replication indices 
designate trace special semantics depend semantics executes executes restrictions variables defined restrictions assigned show property 
pr dependp dependp ei current replication indices 
pr indepp 
pr ei pr dom ei denotes current repli cation indices definition property expresses correctness local differs item 
semantics necessary dependp case control flow depend value ei may certain values ei breaks inequality item 
contrast special semantics computes account control flow problem avoided 
property holds proof 
show holds holds extended values variables restrictions 
variables restrictions defined indices dom dom pr pr dom proves 
show holds holds indepp indepp 
equivalence class ofz 
indepp union equivalence classes indepp adding prob abilities 
conclude holds indepp proof similar show output process small est output process strict subprocess holds indepp holds indepp stead indep 
equivalence indep indepp 
indepp dependp 
item dependp 
proof item pr indepp ei 
case ei traces non zero probability reach reduction traces form ei 
corre sponding trace ei 

ei environment restricted variables defined 
indepp holds 
item holds indepp 
elements indepp de fined item ei defined restrictions con dition indepp item indepp valueof ei indepp indepp dom indepp dom indepp probabilities occur item indepp indepp 
fore item holds indepp 
case new ei defined 
traces non zero probability reach reduction trace reduces new 
similar case 
case new ei defined 
traces non zero probability reach reduction trace reduces new 
item proved case 
consider item ei environment restricted variables defined 
ei replication indices atthe definition 
ei prefix ei 
pr indepp ei pr indepp ei dom indepp pr dom indepp step comes semantic rule new sec ond step step assign ment variables defined restrictions special semantics 
note con dition dom indepp value ei 
inequality proves indepp cases assignment 
defined environment extension ofthe environment item holds holds 
prove item 
trace right hand side inequality 
left hand side decreases traces reach reached inequality holds 
previous results show holds put processes proof proceeds decreasing dependp result 
smallest output process suchthat strict subprocess 
dependp holds indepp 
dependp induction hypothesis holds holds indepp stead 
cases holds indepp 
cases indepp follows case new ei indepp indepp ei 
defined restrictions ei depend indepp holds non zero probability reach reduction trace reduces new traces form ei 

item holds ei 
ei replication indices definition 
ei prefix ei 
item follows pr indepp ei pr indepp ei dom indepp pr dom indepp step comes semantic rule new sec ond step step special semantics new 
inequality proves case find lmj uj ei nj 
ei suchthat defined mj 
mjlj mj pj dependp dependp pj indep indepp subterms defined pj depend 
subterms defined fpj depend depend indepp 
fp correct suchthat pr fp holds case ei 
term depend indep indepp 
holds indepp indepp 
non zero probability considered ei ei holds indepp ei 
result concludes proof soundness 
show soundness 
essentially simplifies evaluate cases negligible probability 
precisely show pr false pmax polynomial proof proceeds induction derivation 
consider false cases simi lar easy 
show false pr true pmax 
dependp dependp 
obtained re spectively replacing array indices fresh replication indices 
assume characterizes part ei depend fixed extension tothe fresh replication indices 
denote classes show forall exists 
fk ei assume exists define environment ea ea ea dom ea ea variables renamed fresh variables 
wehave ea ea ea dom ea ea 
true 
rewriting 
fk ei 
fk ei true 
fk ei 
fk ei exists result holds trivially 
exists function forall 
fk ei true item exists extension fresh replication 
fk ei 
aand depend function ei sx 
fk 

types arguments 
fk respectively type result tk sx 
tk tk tk 
fk uniform 
ei dom 
indices pr true pr ei ei xb sx pr ei ei xb sx pr ei dom item 
dom denotes domain elementof instance smallest 
xe pr ei dom number possible show correctness game simplifications performed 
process sim process simplification ijv 
simplicity consider trans formation time transitivity ij conclude transformations applied 
em pm qm cm cases probability show exists corresponding trace em obtained pm transformation obtained qm cm probability 
induction case obvious game simplifications change input processes 
inductive step reason cases reduction step ofthe trace 
consider cases may altered game simplification 
case replace exclude traces 
negligible probability 
traces 
transformed process way initial process 
case mj false remove th find lmj uj ei nj 
ei suchthat defined mj 
mjlj mj pj traces defined mj 
mjlj mj false rule find set contains ev forany find find process takes thesame branch find probability th branch 
cases similar 
show converse property trace ex cept cases negligible probability exists corresponding trace probability 
forall channels bitstrings em pm qm cm executes executes pr chai pr chai yields desired equivalence ijv 
correctness equational prover 
say 
equational prover starting fp certain se quence 
denote rj th element se quence 
fp wehave fj rj fj rj pm pr fm rm 
show foreach pm pmax polynomial 
proceeds induction 
imme consequence property fp correct 
step pm pm pr fm rm fm rm induction hypothesis pm pmax 
just show rf pr pmax polynomial 
cases derivation rf cases cases reduction uses rule obvious loss probability 
cases reduction uses user rule new 
new yl 
xm tm associated probabil ity assuming user defined claim correct valueof indices restrictions correspond 
yl process provides adversary satisfies definition corresponding user claim 
proof proposition details similar argu ment complicated case 
probability number possible values indices restrictions correspond 
yl polynomial result holds equal number possi ble values indices restrictions correspond 
yl 
case assume 
mj aj 
am 

am 
am 

am 
am chosen randomly uni form probability values probability happens smaller isthe number possible values 
am 
case show characterizes part sdep obtained sub variables definition tuple terms large type uniform functions 
fk type result exists equals variables notin sdep 
fk fm rewritten set 
fk fm 
fk fm 
form rewrite rules fm subterm fm subterm 
variables sdep occur fm fm 
exists equals variables sdep aand defines variables 
fk fm equals variables sdep define variables true rewriting 
fk fm 
fk fm true 
fk fm equals sdep trivially 
exists function 
fk fm sdep 
variables sdep occur fm exists tuple functions ef fm sdep 

fk ef sdep sdep 
consider cases rule 
case show pr pmax forsome polynomial satisfy hypoth rule 
case obtained replacing replication indices fresh replication indices occurs defined restrictions new large type characterizes part obtained optionally applying function symbols form fm defined obtained replacing array replication indices fresh replication indices 
set variables defined excluding characterizes part exist large type functions ef uni form functions 
fk type 
fk ef 
exists exten sion fresh replication indices 
fk ef variables occur function 
ef sx 
fk 

tk types arguments 
tk 
sx 
tk tk tk 
fk uniform 
en vironment giving values variables 
ei dom current replication indices pr ei ef sx pr number possible 
result follows 
second case occurs defined restrictions new large type characterizes part dep variable occurs 
consider traces differ choices dep traces values variables excluding tional traces true considered rule test characterizes part variable occurs 
considered traces value function 
assume true 
obtained variables definition suchthat 
choose definition vari ables set environment 
come rule set 
number independent bounded know ing number different definitions variables number occurrences variables terms 
due properties characterize exist type functions ef uniform functions 
fk type result 
fk ef 
ef sx 
fk 

tk arguments 
fk respectively tk 
sx 
tk tk tk 
fk uni form 
probability true atmost sum choices probabil ity ef sx 
note may depend choice 
probability excluded traces atmost pm number possible number executions test polynomial 
traces excluded false result follows pm 
third case false 
follows immediately correctness local dependency analysis property 
similarly pr 
ml 
nk 
ml hn 
rm pmax polynomial fp fm rm rm extension rm implies fm rm 

correctness game simplification 
simplicity con sider transformation time transitivity ij conclude transformations applied 
foreach trace em pm qm cm negligible probability show exists corresponding trace em obtained pm trans formation obtained qm thesame transformation cm 
proof proceeds induction case simplification input processes simplification terms input channels 
transformed process fq obtained re duces input processes 

equational prover applies fm rm rewrite rule rm applied 
simplify terms input channel user rule 
proof proceeds exactly case 
inductive step reason cases trace 
consider cases transition may altered game simplification 
case reduces user defined rewrite rule replace smallest input output process pm cm contains variable accesses typed game provides adversary conditions definition corresponding user claim item cases user defined rewrite rule situation negligible probability excluded 
cm reduces way pm cm 
case reduces rule re place smallest process pm cm contains set rewrite rules ob tained equational prover pm sume pm output process 
exclude fm rm pm 
probability 
remaining traces rm 
cm reduces way pm cm 
reduce term input similar proof input process qm cm pm 
case find lmj uj ei nj 
ei suchthat defined mj 
mjlj mj pj fpj yields contradiction remove th branch find 
exclude traces defined mj 
mjlj mj true 
set defined reduction rule find 
polynomial div find reduces probability defined mj 
mjlj mj true 
pr defined 
mjlj mj pr pj pr pj rm pj fm rm pj true contradiction 
excluded traces negligible probability 
remaining traces defined mj 
mjlj mj false set contains ev ev find find process takes branch find th branch 
case find lmj uj ei nj 
ei suchthat defined mj 
mjlj mj pj 
nl subterm mjk fol lowing conditions holds definition contains definition oc definition contains lp replica tions process contains definition lp length longest common prefix tween 
nl current replication indices th branch find removed 
show 
nl defined fol lows 
say formula condition holds 
am dom ak min lp dom th multi set inclusion contains definition min lp dom dom index th 
definition contains definition occurs occurs contains lp dom process contains definition xand 
show configuration trace satisfies previous configuration satisfies 
precisely show 
proof cases reduction rule case nil obvious 
rule par case processes generated par applying par case cases remain case definition ap par 
rule repl case processes generated repl repl case cases remain case applying repl 
rules newchannel input remain case 
reduce 
show 
proof cases reduction 
rule find remain case definition 
rules new find case applying reduction reduction defines 
am reduction 
remain case 
rule output fm hn 
ea ea 
xk ea tk cis transformed ea 
xk ea 
reduce 
property shown reduce 
case aand input defines 
am output case case 
remain case 
show th branch find taken find evaluating configuration ofthe trace satisfies 
case 
am dom configuration ik ak forall lp ik th replication index 
case 
previous proof holds initial con figuration case happen empty case contains process 
case 
contains definition obtain conditions holds contradicts hypothesis 
th branch taken removed 
cases handled way similar cases 
show converse property trace ex cept cases negligible probability exists corresponding trace probability 
forall channels bitstrings em pm qm cm executes executes pr chai pr chai yields desired equivalence 
leave proof additional transformations move new useless auto reader 
proof technique similar proving hypothesis proposition section show prove hypothesis 
notations proposition proof simplify previous section 
definition define ei follows ei 
ei new ei 
ml ei ei ei 
ml fp ei denote facts hold current replica tion indices renamed fp ei fp ei ei indices ei pair definitions check ei 
ml ei 
fp ei fp ei ei ei 
ml yields contradiction 
ei 
ml false cases probability account facts known hold 
check succeeds proposition holds shown proposition 
proposition assume pairs defini tions ei 
ml ei 
fp ei fp ei ei 
ml yields contradiction analysis disabled 
pr ea ea reduces ea ea ea ea negligible 
local dependency analysis disabled gives infor mation valid certain process occurrence combine facts obtained occurrences 
proof consider trace ea ea ea ea 
define ea ea respectively trace mapping replication indices ea map ping replication indices ea mapping ei toe ei ea 
environment just definition ea executed configura tion form fp cor rect fp fp ei 
similarly fp ei 
ea ea ei ei 
ea ea ei 
ml ei 

ml 

ml fp fp ei fp ei ei ei 
ml pr ea ea reduces ea ea ea pr 
fp local dependency analysis disabled proof correctness equational prover shown shows rf pr negligible 
fp yields contradiction fp transformed false equational prover 
fp negligible shows desired result 
proof proposition proof proposition idea proof show adversary represented context distinguishes build adversary aa mac key mkgen evaluation context acceptable define probabilistic polynomial turing machine follows 
aa uses oracles mac 
aa simulates copies corresponding computes find suchthat defined check mkgen ma true false stead check mkgen ma copy corresponding aa random number calls oracle mac computing mac mkgen check mkgen ma computes check ma oracle check find suchthat defined false execution turing ma chine stops result ma value 
aa stopped due item returns 
simulation terminates returns 
definition 

aa called mac exists polynomial aa runs time 
definition max pa negligible pa pr ra tmr aa check polynomial pa pa maxa pa negligible hand channel bitstring 
evaluate pr cha pr cha consider categories pairs traces tand traces respectively 
traces configurations forthe replacement processes terminate configurations executes cha 

traces configurations forthe replacement processes corresponding configurations execute cha immediately 

traces configurations forthe replacement processes configurations differ messages ma received chan nel channel forthe second parallel process result differs returned 
case simulating turing machine runs ra tmr mkgen executes aa return ma con struction 
traces fall categories sim traces 
traces category contribution pr cha pr cha traces second category cancel cha pr cha 
pr cha pr cha pr third category pr ra tmr aa pa pr cha pr cha neg ij 
proof proposition introduce notations 
denote lj jk subtrees defined follows tion define 
lm 
lm 
functional process lj jk defined define lj jk 
lj jk immediate sub functional processes lj jk lj jk nnew 
new ym tm lj 
jk lj jk nnew 
new ym tm lj jk 
lj jk define ij jk nj jk jk yk jk lj jl 
xm tm fp lj jl leaf define jl xk jl tk jl order prove proposition define context suchthat ijv ijv 
terms directly context send messages order evaluate terms 
similarly process contains inlined versions functional processes computes result sending messages 
order define define process relay asfollows relay 
gm relay 
relay gm relay nnew 
new yl tl 
gm ei ei hi ei dej ei hi relay ej ei 
relay gm ej mei dej ei dej ei hi relay 
xl tl fp dej ei 
xl tl ei hx 
xli ei bitstring dej ei hri dej ei 
xl tl dej ei hri ei 
il ej 
jl 
relay replicated restrictions relays messages sent channel dej channel corre sponding random numbers 
yl chosen 
random numbers chosen process accepts messages dej yields control back sending pro cess executing outputting dej 
relay process ask times choosing random numbers 
similarly relay function relays arguments function received channel dej channel replies chan nel result function forwarded dej 
relay process allows calling times function values ej ei returns result 
sure follow ing function called times calls arguments 
required thesame structure hypothesis relay relay introduce auxiliary definitions allow define correspondence replication replication indices nm follows 

nl bounds replications definition forany 
length longest common im index im count nl 
nl 
parameters count count 
define function symbols 
nl 
nl nl 
nl 
establishes bi components result 
define tot 
jk sum elements bl equal 
jk counting terms share sequences random variables 
set nj jk tot 
jk nj jk bound replication root lj jk value nj jk available copy desired replicated process need execute 
replication root relay lj jk jki ik bounded nj jk replication relay lj jk jki ik bounded isthe sum 
nl 
nl sequence bounds replications 
order term occurrences arbitrarily tal ordering 
start defined follows 
smallest chosen ordering term oc shares sequences ran dom variables sum smaller elements bl equal ele ments bl counting terms sequences random variables 
define function symbols count nj jk bl 
jk define sequence terms num im index 
im sequence terms implements function explanation transformation section 
precisely ea ea ei ei sequence indices define newchannel newchannel dej ej relay process defined asfollows replace definition new cst constant cst 
pm cm subprocess containing bl 
jl 
dm dj jl dm dj jk replace pm dm hi dm 
dm dm dm 
xm dm bitstring cm fresh variable 
evaluating terms directly sends messages relay process relay 
lemma ijv proof bounds replications relay defined 
outlined proof proposition length bitstrings manipulated polynomial 
define polynomial messages sent cated 
define dej dej truncated evaluation context acceptable relate traces follows assume channels dej occur reductions newchannel chan nels substituted 
easy guarantee renaming assumption simplifies notations proof write forsome bitstring denote th ei th component ofthe tuple ei number elements tuple ei define relation variables variables defined new say 
aj var ea im 
ea ei ak ei en current definition ei th ea th en 
var 
depends 
show relation var partial function thatis 
aj var mv 
aj var mv assume 
aj var ea 
aj var fa 
im 
ea ei ak ei en current replication indices defi nition associated bounds ei th ea th en im 
fa ei ak ei fn current replication indices associated bounds ei th fa th fn 
terms start count computed terms fixed order 
num 
evaluates bitstring start 
sym start 
im 
ea ei im 
fa ei 
definition shares sequences random variables indices defined replications 
ea fa 
hypothesis definition num show induction num im 
ea ei im 
fa ei en current replication indices definition zk associated bounds th ea th fa th en ea fa 
assume num ea num fa longest common prefix index empty defined 
num establishes tuples smaller bounds definition interval 
ea fa 
assume im 
ea ei im 
fa ei 
ind 
im 
ind ea ei ind im 
ind fa ei ind 
hypothesis ind im ind 
ind ei ind im ind 
fa ind ei ind ei ind en ind current replication indices definition zk ind associated bounds 
induction hypothesis ea ind fa ind im 
ea ei im 
fa ei 
ea fa 
length longest common prefix index im 

components im 
components ei compo nents fa equal 
bijection components interval 
components ea fa equal 
ea fa 
conclude ea fa ea fa show function var 
injective 

var 
aj 
var 
aj 
hypothesis sequences random variables 
hypothesis 
definition num start 



trace 
em pm qm probability pm show exists trace 
probability 
em 

dom em dom defined new 
aj dom exists mv 
ak var em mv mv dom em forall mv 
aj em mv 
obtained pm occurrences appear pm obtained qm transforming occurrences appear qm remains relay partial execution remains partial execution precisely relay la jk relay lj jk jki ik 
ak ik la jk lj jk jki ik 
ak ik 
ik replications indices lj jk 
processes correspond respectively process translation subtree lj value replication indices 
ak np 
formed follows 
jk 
ak jk 
ak dom contains dj jk 
ak dj jk 
ak hi possibly times 

jk 
ak jk 
ak dom jk 
ak dom contains ak relay la ak jk andq contains ak la ak jk 
jl 
jl 
dom lj jl leaf la jl contains la jl contains dj jl 
jl jl 
jl jl dj jl 
hri jl possibly times exist ea em ea ei 
em ea ei bl 
jl sequence replication indices 
ak bitstring tot 
jk 
cm dej ej 
pm qz type ofz 

dom exists 
aj dom 
aj var em 

note trace corresponds traces differ val ues em 

defined inthe item 
proof proceeds induction length 
induction step distinguish cases depend ing reduction step trace 
initial case show induction substitutes channel names chan nel names touching dej exist substitutes channel names channel touching dej 
obvious show result par newchannel newchannel 
apply result id fc 
fc fc fc fc fc exist substitutes chan nel names channel names touching dej fc fc relay dej ej newchannel par dej ej par repl relay lj tot remains relay parallel compositions replications lj tot remains expansion parallel compo sitions replications 
obtained andq contain occurrence modified transforming obtained 
reducing normal form obtain reduce fc reduce fc dej ej obtained 
sat desired invariant 
trace executes new 
new step corresponding executes 
cst step 
yields traces value em 
probability pm pm 
contrast yields single probability 
exists 
dom 
var em 

wise point invariant definition 
exist mv 
var em mv mv dom em 
em extension em 
var em mv var em injective mv 
yields contradiction mv dom em 
dom em invariant 
ar ray cell 
defined times 
easy see invariant satisfied 
trace executes ipm trace executes dm hi dm 
dm dm dm 
xm dm bitstring cm ea ei ei sequence current pm bl 
jl 
ak em im ak em im 
step trace executing idm khi idm dm dj jk 
show induction jk 
ak dom invariant satisfied step 
dm hi dm 
dm khi dm jk 
wehave jk 
ak var em 
dom em im occurs im im successfully evaluated 
distinguish cases jk 
ak dom invariant step contains dj jk 
ak dj jk 
ak hi 
execute idm khi idm output steps changing environment jk 
ak dom andthe invariant satisfied step 
dm hi dm 
dm khi dm jk 
ak dom 
hypothesis jk 
ak dom 
invariant step ak relay la ak jk ak la ak jk 
output twice send empty message dj jk 
ak cj jk 
ak new define jk 
ak 
choose em value jk 
ak probability type jk 
output twice send empty message cj jk 
ak dj jk 
ak invariant satisfied step dm hi dm 
dm khi dm 
note probability divided jk jk type jk 
ak 
required invariant jk 
ak defined step step 
jk 
ak dom invariant satisfied step ex cept dm hi dm 
dm dm em im letm step trace executing dm 
xl dm bitstring invariant cases relay la jl jl 
process idm 
xl value xk chan nel dj jl 

output mes sage received relay la jl wards output la jl chan nel cj jl 

reception mes sage la jl jl 
received value em xk jl 

forall jk 
ak var em invariant jk 
ak em jk 
ak em 
im em jk 
ak variables nm defined replications em 
ak nm em nm nm 
il 
il replication indices lj jl 
la jl sends back channel cj jl 
output channel dj jl 
relay la jl output stored ea 
ea order show invariant holds outputs relay process available process dj jl 
jl jl 
jl jl dj jl 
hai em ea ei 
em ea ei bl 
jl 
dj jl 
jl jl 
jl jl dj jl 
hri exist ea suchthat em ea ei 
em ea ei bl 
jl sequence current replication 
em ea ei 

ea ei em ea ei shown proof var function ea ei em ea ei em share sequences sequences random variables ml 
bl bl 
jl nm nm 
ml ea ea em im hypothesis exists term index contain cur rent replication indices 
em ea ei em ebl ei em ea ei em sequence current replication definition 
cases obtain ea icm trace executes icm trace yields invariant 
cases easy sides reduce 
conversely show traces correspond toa trace relation 
technique similar previous proof 
qz traces probabil ity correspond trace probability pm qz 
channels bitstrings em pm qm cm executes chai executes chai immediately pr chai pr chai 
ijv 
lemma ijv proof sketch proof uses technique lemma 
main addition contrast contain functional processes complex just terms 
order handle need define re lation variables variables defined new functional processes variable 
var ea im ea ei ak sequence current replication indices 
function variables show 
related variables value runtime 
delicate case find functional processes fp find lmj suchthat defined zj 
mj fpj fp concatenation prefix replication indices length non empty pre fix uj 
executing find process tests thevalue zjk 
indices 

correspond prefix current replication 
correspondingly transf cm fp tests values related zjk 
var 
lemma process satisfies invariant 
proof process satisfies invariant newly concern fresh variables variables cor respond variables defined new input single definition variables correspond variables defined definitions variables satisfies invariant different branches find 
lemma process satisfies invariant 
proof variable accesses created come cm fp 
show induction fp accesses created transf cm fp corresponding find im 
consider vari able accesses cm existed 
variable accesses created transf cm fpm corresponding find im 
vari able accesses im kinds 
xj 
defined just transf cm fpm 

jk im zj im defined occurs point initial process satisfies invariant addition defined conditions find jk jk defined zj defined implies jk im defined 
im se quence current replication indices jk im defined 

defined fpm satisfies invariant ac cesses 
il fpm occur 
il fpm accesses 

il definition transf cm fpm 
satisfies invariant 
lemma process satisfies invariant 
proof newly added variable definitions xj tj xj new jk jk variable xj def 
variables jk def added variable jk place definition zj hypothesis occur replications type 
type environment defined assume pm cm small est process containing el type environment pm cm er type environment min type environment nm bethe type environment fp know el pm show easy see typed knowing typed 
note er types variables jk xj fpm hypothesis xj tj er xj tj extension order show er show cm fpm say typed fm dom fm implies er fm easy show induction typed er show typed fp type result fp type nm cm fp induction fp 
fp show er cm 
el nm nm contains function sym bol nm nm xj xj mis type hypothesis tj nm nm yjk yjk zjk im type hypothesis nm hypothesis er cm el bya substitution lemma conclude cm 
inductive cases follow easily fp andthe property proved type terms 
case find branch non empty defined condi tions extend follows 
ei current replication indices eu fresh variable variable 
zk jk zk mk 
mkl zk im eu ei 
zk defined zj isdefined indices zk zj im suit able type 
ei types substitution lemma im index eu ei suitable type 
zk zk declared type jk zk mk 
mkl jk ande zk im eu ei jk 
zk defined function put zk mk 
mkl zk eu zk declared replica tions eu suitable type 
variables zk zk declared ofthe type zk mk 
mkl zk eu 
typed 
show er im eu ei im index bool zj zj share sequences random vari ables im index im thesame type indices zj ei type im index eu ei im ofthe type yields desired result 
easy see typed 
fpm type result fp type nm hypoth cm fpm 
proof proposition invariants lemmas respectively 
show ijv 
renaming variables contain variables lemmas ijv ijv ijv transitivity ijv 
proofs section proof proposition acceptable context qx 
relate traces qx follows trace qx executes subprocess 
um qx obtain trace probability just replacing qx subprocesses qx corresponding sub process 
considered trace qx subprocess 
um qx exactly 
um am 
am environment 
um 
hypothesis definition 
am inthis trace restriction new 
am assignment 
am 
ml mk definition 
trace new 
build traces choosing value restriction new 
am new 
value restriction new definition traces trace qx values variables process qx 
probability traces times probability con sidered trace qx traces choose random number trace qx 
traces obtained 
show rebuild trace qx trace reverse construction detailed 
configuration em pm qm cm trace qx corresponding configuration ofthe trace channels bitstrings em pm qm cm executes chai immediately executes chai immediately pr qx chai pr chai qx ij 
proof sketch proposition acceptable con text qx exclude traces ea ea ea ea 
traces hypothesis qx acceptable con text 
removal change result remaining traces ea ea ea definitions ea ea single execution restriction 
ea ea independent random numbers 
proof similar proposition replace tested value ea independent random numbers stead single 
proof lemma prove result 
proof essentially secrecy 
contexts qx acceptable contexts renaming 
um occur 
ij 
lemma qx ij qx ij 
preserves session secrecy qx ij 
transitivity qx ij 
preserves 
