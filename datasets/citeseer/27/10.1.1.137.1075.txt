computation deduction frank pfenning carnegie mellon university draft january notes course carnegie mellon university spring semester 
please send comments fp cs cmu edu 
notes published cambridge university press 
copyright cfl frank pfenning ii contents theory programming languages 
deductive systems 
goals approach 
mini ml language syntax 
substitution 
operational semantics 
evaluation returns value 
type system 
type preservation 
discussion 
exercises 
bibliography iii iv contents chapter question judgement 
small question notion judgement just notions logic explained notions proposition truth instance 
martin meanings logical constants justifications logical laws ml everyday computing deal variety different languages 
ada ml prolog intended general purpose languages 
emacs lisp tcl tex html csh perl sql visual basic vhdl java designed specific domains applications 
examples illustrate computer science researchers system developers engaged language design implementation suspect 
know examples ignorance disregard sound language design principles led languages programs harder write debug compose maintain 
order understand principles guide design programming languages familiar theory 
understand properties complete languages opposed properties individual programs understand pieces language fit form coherent coherent 
notes demonstrate theory programming languages require deep complicated mathematical apparatus carried concrete intuitive computational way 
exceptions material notes fully implemented meta language socalled logical framework 
implementation encompasses languages study algorithms pertaining languages example compilation proofs properties example compiler correctness 
allows hands chapter 
experimentation languages algorithms exploration variants extensions 
briefly sketch approach organization notes 
theory programming languages theory programming languages covers diverse aspects languages implementations 
logically issues concrete syntax parsing 
relatively understood time covered numerous books 
ignore notes order concentrate deeper aspects languages 
question concerns type structure language 
importance type structure design language hardly 
types help sort meaningless programs type checking catches errors program executed 
types serve formal machine checked documentation implementation 
types specify interfaces modules important obtain maintain consistency large software systems 
ask meanings programs language 
immediate answer operational semantics specifies behavior programs usually relatively high level abstraction 
fundamental parts language specification syntax type system operational semantics 
lead meta theoretic questions regarding particular language 
effectively decidable input expression typed 
type system operational semantics fit 
types needed execution program 
notes investigate questions context small functional logic programming languages 
issues arise realistic languages solutions apply 
specification operational semantics rarely corresponds efficient language implementation designed primarily easy reason 
study compilation translation source language target language executed efficiently machine 
course want show compilation preserves observable behavior programs 
important set questions programs satisfy specification example particular function really computes integer logarithm 
similarly may ask programs compute function may implement different algorithms may differ operationally 
questions lead general type theory denotational semantics consider superficially notes 
concentrate type systems operational behavior programs determine programming style 
deductive systems closest programmer intuition language 
amenable immediate implementation direct example denotational semantics 
principal novel aspect notes operational perspective limited programming languages study object language encompasses meta language framework carry investigation 
informally meta language centered notions judgment deductive system explained 
formalized logical framework lf hhp judgments specified high level abstraction consistent informal practice computer science 
lf operational interpretation elf meta programming language pfe pfe providing means computational meta theory 
implementations languages algorithms proofs meta theorems notes available electronically constitute important supplement notes 
provide basis hands experimentation language variants extensions proofs exercises projects related formalization implementation topics theory programming languages 
implementation lf elf called twelf ps available twelf home page www cs cmu edu twelf 
deductive systems logic deductive systems introduced syntactic device establishing semantic properties 
language semantics assigning meaning expressions language particular category expressions called formulas 
furthermore distinguished semantic property truth particular model 
deductive system defined set axioms true formulas rules inference yield true formulas true formulas 
deduction viewed tree labelled formulas axioms leaves inference rules interior nodes label root formula truth established deduction 
naturally leads number meta theoretic questions concerning deductive system 
immediate soundness axioms true truth preserved inference rules 
completeness true formula deduced 
difficulty general approach requires mathematical notion model complex immediately computational 
alternative provided martin ml ml introduces notion judgment true may know virtue proof 
notions judgment proof basic notions proposition truth 
meaning propositions explained rules may establish truth 
martin notions chapter 
informal intended philosophical foundation constructive mathematics computer science 
concerned actual implementation meta theory deductive systems 
refer judgments mean formal judgments substitute synonyms deduction derivation formal proof 
term proof reserved proofs meta theory 
call judgment derivable established deduction axioms inference rules 
derivable judgments defined inductively 
alternatively say set derivable judgments set judgments containing axioms closed rules inference 
underlying view axioms inference rules provide semantic definition language advanced gentzen gen referred proof theoretic semantics 
study deductive systems semantic investigation syntactic means 
investigation theory deductions gives rise constructive proofs properties consistency formula provable gentzen primary motivations 
important reason relevance deductive systems computer science 
study deductive systems pioneering gentzen arrived various styles calculi concepts methods independent particular logical interpretation formalism 
systems style hilbert hb close connection combinatory calculi cf 
characterized axioms small number inference rules 
systems natural deduction gen pra relevant notes directly define meaning logical symbols inference rules 
closely related typed calculi programming languages called curry howard isomorphism 
gentzen sequent calculus considered calculus proof search relevant logic programming computation realized proof search fixed strategy 
notes concentrate calculi natural deduction investigating methods 
definition judgments 
implementation algorithms deriving judgments manipulating deductions 
proving properties deductive systems 
example tasks show mean context description programming language 
range expressions statically typed programming language range types expressions values 
relevant judgments type 
evaluates 
deductive systems 
deductive systems define judgments fix type system operational semantics programming language 

implementation judgments provides program type inference interpreter expressions language 

typical meta theorem type preservation expresses type system operational semantics compatible derivable 
derivable derivable 
context deductive systems define judgments considerations simply exists external semantical notion inference rules measured 
different inference systems lead different notions evaluation different programming languages 
standard notation judgments deductions 
judgment derivation write typographic simplicity application rule inference premises jn general form jn rule name axiom simply inference rule premises show horizontal line 
script letters range deductions 
inference rules schematic contain meta variables 
schematic inference rule stands instances obtained replacing meta variables expressions appropriate syntactic category 
usually drop schematic sake simplicity 
deductive systems intended provide explicit calculus evidence judgments 
complex side conditions restrict set possible instances inference rule 
easily destroy character inference rules evidence judgment may implicit side conditions 
limit side conditions regarding legal occurrences variables premises 
accident formalization techniques directly account side conditions 
side conditions may literature converted explicit premises involving auxiliary judgments 
standard means combine judgments form new ones 
particular employ parametric hypothetical judgments 
briefly hypothetical judgment expresses judgment may derived assumption hypothesis 
succeed constructing deduction substitute chapter 
place original hypothetical deduction obtain unconditional evidence parametric judgment judgment containing meta variable ranging syntactic category 
judged evident provide deduction replace expression appropriate syntactic category obtain deduction resulting instance statements meta theorems generally refer judgment derivable derivable 
judgments deductions objects study subjects judgments 
phrase derivable pervasively tends verbose take liberty stand derivable confusion arise 
goals approach pursue goals notes 
convey certain style language definition deductive systems 
style standard practice modern computer science students theory programming languages understand thoroughly 
secondly impart main techniques proving properties programming languages defined style 
meta theory deductive systems requires surprisingly principles induction structure derivations far common technique 
thirdly reader understand employ lf logical framework hhp twelf system ps order implement definitions related algorithms 
serves purposes 
important allows hands experimentation dry definitions theorems 
students get immediate feedback understanding course material ideas exercises 
furthermore logical framework understanding methodology deductive systems framework provides immediate formal account informal explanations practice computer science 
students develop understanding subject matter functional logic programming 
includes understanding various type systems operational semantics functional languages high level compilation techniques machines constructive logic connection constructive proofs functional programs view goal directed proof search foundation logic programming 
understanding analysis implementation techniques employed apply paradigms realistic practical languages 
notes theory mini ml small functional language including recursion polymorphism chapter 
informally discuss language 
goals approach specification meta theory culminating proof type preservation employing deductive systems 
exercise allows identify common concepts deductive systems drive design logical framework chapter 
incrementally introduce features logical framework lf formal meta language 
show lf implemented elf programming language chapter 
elf endows lf operational interpretation style logic programming providing programming language meta programs interpreters type inference procedures 
meta theory constructive observe meta theoretic proofs implemented executed elf verified completely 
introduce important concepts parametric hypothetical judgments chapter 
develop implementation proof type preservation 
point basic techniques established devote remaining chapters case studies compilation compiler correctness chapter natural deduction connection constructive proofs functional programs chapter theory logic programming chapter advanced type systems chapter 
chapter 
chapter mini ml language unfortunately pays price languages impose discipline types time taken find bugs mistakenly applies cdr atom lisp finds adding property list integer know symptoms 
robin milner theory type polymorphism programming mil preparation formalization mini ml logical framework description language common mathematical style 
version mini ml lies language introduced kah call value pcf plo plo 
description consists parts syntax operational semantics type system 
logically type system come operational semantics postpone difficult typing rules section 
syntax language types centrally affects kinds expression constructs available language 
types include formulation natural numbers products function types 
phenomena theory mini ml explored types subject exercises 
purposes convenient ignore certain questions concrete syntax parsing syntax language backus naur form bnf 
vertical bar separates alternatives right hand side definition symbol 
definitions style chapter 
mini ml language understood inductive definitions syntactic categories types expressions 
types nat theta ff nat stands type natural numbers theta type pairs elements type functions mapping elements type elements type 
type variables denoted ff 
language supports form polymorphism explicitly include polymorphic type constructor language see section discussion issue 
follow convention theta associate right theta higher 
parentheses may explicitly group type expressions 
example nat theta nat nat nat denotes type nat theta nat 
nat nat concrete type excluding type variables expressions allow construct elements type expressions allow destruct elements type 
choose separate languages types expressions define operational semantics recourse typing 
mind typed programs executed 
expressions case natural numbers fst snd pairs lam functions val definitions name fix recursion variables constructs familiar functional programming languages ml stands zero stands successor chooses branch value argument zero non zero 
abstraction lam forms functional expressions 
written reserve formal meta language 
application function argument denoted simply juxtaposition 
definitions introduced val provide explicit sequencing computation name introduces local name abbreviating expression 
incorporates form polymorphism 
recursion introduced fixed point construct fix explained example addition 

syntax possibly subscripted range expressions 
letters occasionally range variables 
boldface font language keywords 
parentheses explicit grouping types 
juxtaposition associates left 
period lam fix keywords act prefix scope extends far right possible remaining consistent parentheses 
example lam stands lam val case denotes expression val case example consider implementation predecessor function predecessor defined 
pred lam case introduces definition mathematical meta language 
second example develop definition addition illustrates fixed point operator language 
informal recursive specification behavior plus 
plus plus plus order express language need perform transformations 
replace clauses specification expressing case distinction mini ml 
plus case plus second step explicitly arguments plus 
plus lam lam case plus point equation form variable plus expression occurrences think function depends fixed point mini ml language allows construct fixed point directly 
fix chapter 
mini ml language example leads definition plus fix add lam lam case add operational semantics account recursive nature computation presence fixed point expressions including possible non termination 
reader may want convince detailed presentation operational semantics correct alternative definitions addition 
plus lam fix add lam case add plus fix add lam lam case add substitution concepts free bound variable fundamental languages 
mini ml variables scoped follows case binds lam binds val binds name binds fix binds occurrence variable expression bound occurrence lies scope binder case refers innermost enclosing binder 
variable said free example occurrences bound occurrence free 
name lam names bound variables may important programmer intuition irrelevant formal meaning expression 
distinguish expressions differ names bound variables 
example lam lam denote identity function 
course variables renamed consistently corresponding variable occurrences refer binder 
lam lam lam lam lam lam lam lam wish explicit refer expressions differ names bound variables ff convertible renaming operation ff conversion 

operational semantics languages meaning invariant variable renaming said lexically scoped statically scoped clear program text considering operational semantics variable occurrence bound 
languages lisp permit dynamic scoping variables semantically transparent difficult describe formally reason 
fundamental operation expressions substitution replacement free variable expression 
write result substituting free occurrences substitution operation sure variable free captured binder may tacitly rename bound variables result substitution uniquely defined 
example lam lam lam lam form substitution called capture avoiding substitution 
meaningful form substitution variable renaming convention pure textual replacement conclude lam lam lam lam clearly nonsensical 
substitution number obvious obvious properties 
class properties may considered part rigorous definition substitution 
equalities form lam lam free 
course exists equations construct language 
second important property states consecutive substitutions permuted certain circumstances provided occur free 
reader invited explore formal definition properties substitution exercise 
take simple properties largely granted 
operational semantics judgment defined evaluation judgment 
read evaluates 
ranges expressions section define notion chapter 
mini ml language value show result evaluation fact value 
informally think representing value definition evaluation judgment inference rules 
remainder notes think axioms inference rules premises explicit distinction axioms inference rules necessary 
definition judgment inference rules inductive nature evaluates 
established set inference rules 
inductive structure deductions notes order prove properties deductive systems 
approach description operational semantics programming languages goes back plotkin plo plo name structured operational semantics kahn kah calls approach natural semantics 
presentation follows style natural semantics 
rules concerning natural numbers 
ev 

ev 
rule expresses constant evaluates 
second expresses constructor argument evaluated constructor eager lazy 
distinction see exercise 
note second rule schematic instance rule valid 
inference rules concern evaluation case construct 
second rules requires substitution introduced previous section 


ev case case 


ev case case 
substitution case evaluates eliminates need environments semantic definitions 
rules declarative nature define operational semantics declaring rules inference evaluation judgment implementing interpreter 
exhibited clearly rules conditional interpreter evaluate branch evaluation depending value 
interpreter structure contained rules fact naive search deduction rules behave differently see section 
simple example expressed rules far consider derivation case 

operational semantics arise derivation pred earlier definition pred ev 
ev 
ev 
ev 
ev 
ev case case 
second premise arises refer deduction judgment 
evaluation deduction simply evaluation deductions play role traces computation 
pairs introduce new ideas 


ev pair 
hv 
hv ev 

hv ev 
form operational semantics avoids explicit error values expressions simply exist value 
derivable 
example trying construct deduction expression case hz zi 
arrives impasse ev 
ev 
ev pair hz zi 
hz zi 
case hz zi 
inference rule allow fill expression obtain valid deduction 
particular kind example excluded typing system argument determines cases natural number 
hand natural semantics preclude formulation explicit error elements see exercise 
programming languages mini ml functional abstractions evaluate 
true languages call value call name semantics considered distinguishing characteristic evaluation compared chapter 
mini ml language normalization 
ev 
lam 
lam 

ev app 
specifies call value discipline language evaluate substitute resulting value function body 
call byname discipline omit second premise third premise 
see exercise 
inference rules inherent inefficiency deduction judgment form 
may copies deduction 

actual interpreter evaluate environment bound simply look value needed 
modification specification straightforward requires closures 
extension language part compilation process section 
rules straightforward understanding function application 
variants depending subject evaluated val name 


ev val 

ev name 
val construct intended computation intermediate results may needed name construct primarily intended give names functions polymorphically 
distinction see section 
come fixed point construct 
considerations example page arrive rule fix 
ev fix fix 
evaluation fixed point construct recursion level evaluates result 
typically uncovers lam abstraction evaluates 
operational semantics 
rule clearly exhibits situation expression value consider fix rule form fix 
ev fix 
fix 
derivable premise fix 
derivable 
fix fix instance ev fix form fix 
ev fix fix 
clearly progress evaluation fix example successful evaluation consider function doubles argument 
double fix lam case representation evaluation tree double uses linear notation amenable typesetting 
lines shown order arise left right depth construction evaluation deduction 
easiest read bottom 
double short hand expression shown definition language order keep size expressions manageable 
furthermore double result unrolling fixed point expression double 
double 
double ev lam double 
double ev fix 
ev 
ev 
ev 
ev double 
double ev lam double 
double ev fix 
ev 
ev 
ev case double 
ev case double 
ev app double 
ev double 
ev case double 
ev case double 
ev app double fix lam case double lam case double chapter 
mini ml language inefficiencies rules alluded seen clearly example need copies evaluation principle unnecessary call value language see exercise 
evaluation returns value discuss type system formulate prove simple metatheorem 
set values mini ml described bnf grammar values hv lam kind grammar understood form inductive definition subcategory syntactic category expressions value successor value pair values lam expression 
alternative equivalent definition values example expressions evaluate see exercise 
syntactic subcategories values subcategory expressions defined deductive systems 
judgment case unary value 
defined inference rules val zz value value val ss value value value val pair value val value definition inductive expression value value derived inference rules 
common mathematical practice different variable names elements smaller set order distinguish presentation 
justified write 
understanding value 
subject theorem 
proof instructive uses induction structure deduction 
central technique proving properties deductive systems judgments define 
basic idea simple establish property deductions judgment show property preserved inference rules assume property holds deduction premises show property holds deduction 
axiom inference rule premises just means prove property outright assumptions 
important special case induction principle inversion principle cases form judgment uniquely determines rule inference applied may conclude existence deduction premise 

evaluation returns value theorem value soundness expressions 
derivable value derivable 
proof proof induction structure deduction 
show number typical cases 
case ev 
value rule val case 
ev 
induction hypothesis yields deduction value 
inference rule val conclude value 
case 

ev case case 
induction hypothesis applied yields deduction value needed show case 
case 

ev case case 
induction hypothesis applied yields deduction value needed show case 
case ends ev pair reason similar cases 
case 
hv ev fst fst 
induction hypothesis applied yields deduction judgment hv value 
examining inference rules see chapter 
mini ml language application val pair rule value value val value 
value derivable needed show 
call form argument inversion 
case ends ev snd reason similar previous case 
case ev lam lam 
lam case immediate lam value rule val lam 
case 
lam 

ev app 
induction hypothesis yields value 
case ends ev letv 
similar previous case 
case ends ev letn 
similar previous case 
case fix 
ev fix fix 
induction hypothesis directly yields value 
pervasive briefly summarize principle structural induction proof 
assume arbitrary derivation 
prove property show induction structure inference rule system defining judgment 
show property holds assumption holds premise 
special case inference rule premises inductive assumptions corresponds base case induction 
suffices establish property derivation constructed inference rules 
particular theorem property states exists derivation judgment value 

type system type system presentation language far types 
types external language expressions judgment may considered establishing property untyped expression view types associated curry cur cf systems style called type assignment systems 
alternative system style church chu chu chu types included expressions typed expression unique type 
discuss system section 
mini ml cl ement language limited polymorphism explicitly distinguishes simple types type schemes restrictions type schemes 
notion polymorphism introduced milner mil dm 
refer schematic polymorphism 
formulation able avoid type schemes completely distinguishing forms definitions polymorphic 
formulation style hannan miller hm han han 
types nat theta ff ff stands type variables 
need notion context assigns types free variables expression 
contexts gamma delta gamma generally omit empty context delta example write delta deal problem variable names 
order avoid ambiguities simplify presentation stipulate variable may declared context gamma wish emphasize assumption refer contexts repeated variables valid contexts 
write gamma type assigned gamma typing judgment gamma states expression type context gamma important meta theory exactly inference rule expression constructor 
say definition typing judgment syntax directed 
course deductive systems defining typing judgments syntax directed see example section 
typing rules natural numbers 
require branches case expression type means matter branches case expression applies evaluation chapter 
mini ml language value expression type 
tp gamma nat gamma nat tp gamma nat gamma nat gamma gamma nat tp case gamma 
case implicit third premise tp case rule information bound variable scope 
stands natural number predecessor value 
note may rename variable case variable name occurs context gamma pairing straightforward 
gamma gamma tp pair gamma theta gamma theta tp fst gamma fst gamma theta tp snd gamma snd rule lam abstraction type expression unique 
characteristic property type system style curry 
gamma tp lam gamma lam gamma gamma tp app gamma rule tp lam implicitly restricted case occur gamma general assumption variable occurs context 
restriction satisfied renaming bound variable allowing construction typing derivation lam lam ff 
fi fi lam lam ff 
fi ff 
note rule need rule looking variables context 
gamma tp var gamma variables occur context rule lead inherent ambiguity 

type system language incorporates val expression compute intermediate values 
strictly necessary may defined lam abstraction application see exercise 
gamma gamma tp letv gamma val may type types occurrences 
words polymorphically various types 
schematic polymorphism ml style polymorphism plays role typing rule name 
achieve example judgment holds name lam hf lam nat theta nat nat clearly expression evaluated hz lam lam act identity function type lam nat nat lam nat nat 
nat nat derivable 
type system explicit polymorphism general judgment expressed lam ff ff ff see section 
different device allowing different types assigned different occurrences type checking name 
achieve substituting checking result typed 
gamma gamma tp letn gamma name note type assigned premise 
require derivation subexpressions typed term guaranteed typed see exercise 
reader may want check rule example typed 
come typing rule fixed point expressions 
evaluation rule substitute fix order evaluate fix welltyped body typed assumption variable type fixed point expression 
lead rule gamma tp fix gamma fix chapter 
mini ml language general typing rules fixed point constructs considered literature notably rule milner mycroft calculus discussed section 
important property system expression uniquely determines inference rule typing derivation 
leads principle inversion type expression draw types constituents expressions 
inversion principle pervasively proof theorem example 
deductive systems similar inversion principles hold turn difficult prove 
lemma inversion context gamma expression gamma derivable inference rule derivation gamma uniquely determined 
proof inspection inference rules 
note imply types unique 
fact illustrated rule lam abstraction 
type preservation come statement proof type preservation mini ml need preparatory lemmas 
reader may wish skip ahead reexamine lemmas needed 
note property weakening state prove substitution lemma typing derivations 
substitution lemmas basic investigation deductive systems pay special attention considering representation proofs meta theorems logical framework 
notation gamma gamma result appending declarations gamma gamma assuming implicitly result valid 
recall context valid variable declared 
lemma weakening gamma gamma gamma provided gamma gamma valid context 
proof straightforward induction structure derivation gamma inference rule context examined tp var applicable declaration context gamma clear presence additional non conflicting declarations alter property 
type derivations differ weakening type declarations gamma identical structure 
permit weakening type declarations gamma structural induction typing derivation 
substitution lemma central 
closely related notions parametric hypothetical judgments introduced chapter 

type preservation lemma substitution gamma gamma gamma gamma gamma proof induction structure derivation gamma gamma 
result intuitive occurs leaf typing derivation substitution supply derivation showing type leaf position exists assumption 
show cases proof detail remaining ones follow pattern 
case gamma gamma tp var gamma gamma lemma reduces showing gamma gamma gamma follows weakening 
case gamma gamma tp var gamma gamma case lemma follows gamma gamma tp var gamma gamma case gamma gamma gamma gamma tp app gamma gamma construct deduction gamma gamma gamma gamma tp app gamma gamma 
known exist induction hypothesis applied respectively 
definition substitution lemma established case 
case gamma gamma tp lam gamma gamma lam case need apply induction hypothesis gamma gamma 
lemma formulated additional context gamma 
chapter 
mini ml language induction hypothesis inference step obtain gamma gamma tp lam gamma gamma lam yields lemma equation lam lam free distinct assume conditions satisfied achieved renaming bound variables 
statement type preservation theorem written way induction argument directly 
theorem type preservation 
derivable derivable derivable 
proof induction structure deduction 
justification inversion refers lemma 
directly form judgment established derivation draw possible forms premise course derivable 
case ev 
show type derivable derivable 
obvious 
case 
ev 
assumption nat nat inversion nat ind hyp 
nat rule tp case 

ev case case 

case assumption inversion ind hyp 

type preservation case 

ev case case 

case assumption nat inversion nat inversion nat ind hyp 
nat inversion substitution lemma ind hyp 
cases ends ev pair ev fst ev snd reason similar cases see exercise 
case ev lam lam 
lam case immediate ev case 
lam 

ev app 
assumption inversion lam ind hyp 
inversion ind hyp 
substitution lemma ind hyp 
case 

ev letv val 
val assumption inversion ind hyp 
substitution lemma ind hyp 
chapter 
mini ml language case 
ev letn name 
name assumption inversion ind hyp 
case fix 
ev fix fix 
fix assumption inversion fix substitution lemma ind hyp 
important recognize theorem proved induction structure expression difficulty pronounced cases fix expressions premises rules general larger expressions 
similarly prove type preservation induction structure typing derivation discussion ignoring details concrete syntax mini ml language completely specified typing evaluation rules 
consider simple simple model interaction implementation mini ml consisting phases type checking evaluation 
phase implementation accepts expressions typed empty context second phase implementation constructs prints value 
derivable 
model simplistic ways example ignore question values printed observed user 
return point section 
self contained language definition means deductive systems establish connection types values expressions mathematical objects partial functions 
seen subject denotational semantics 
example understand intuitively expression ss lam 
discussion denotes function natural numbers natural numbers adds argument 
similarly pred lam case fix denotes partial function natural numbers natural numbers returns predecessor argument greater equal undefined 
intuitive interpretation expressions justified 
step establish result evaluation exists unique 
recall expressions differ names bound variables considered equal 
theorem uniqueness values 

derivable 
proof straightforward see exercise 
intuitively type nat interpreted set natural numbers 
write values nat 
easily seen induction structure derivation value defined inductively meaning denotation value defined trivially immediate bijection closed values type nat natural numbers 
meaning arbitrary closed expression type nat defined ae 
determinism evaluation theorem tells exists uniquely defined 
value soundness tells value 
type preservation theorem tells closed expression type nat meaning arbitrary expression type nat defined unique natural number 
furthermore justified overloading delta notation values arbitrary expressions values evaluate exercise 
consider meaning expressions functional type 
intuitively nat nat meaning partial function natural numbers natural numbers 
define follows ae 
chapter 
mini ml language definition formed reasoning similar observation delta bijection closed values type nat natural numbers 
justified thinking type nat nat consisting partial functions natural numbers natural numbers 
partial functions mathematics understood terms input output behavior terms concrete definition viewed extensionally 
example expressions ss lam ss fix lam case denote function natural numbers natural numbers ss ss 
operationally course different behavior 
denotational semantics induces non trivial notion equality expressions language 
hand immediately clear take advantage equality due non constructive nature 
notion extensional equality partial recursive function recursively axiomatizable write complete deductive system prove functional equalities 
denotational approach extended higher types example functions map functions natural numbers natural numbers functions natural numbers natural numbers natural way 
may development denotational semantics language uniquely determined 
case choices 
especially mathematical domains interpret expressions structure impose leave open 
subject denotational semantics see example gun 
approach meaning expression depends type 
example expression id lam id nat nat reasoning interpret function natural numbers natural numbers 
id nat nat 
nat nat maps function natural numbers 
inherent ambiguity due curry approach types assigned untyped expressions 
remedied natural ways construct denotations independently language types give meaning typing derivations 
approach types interpreted subsets universe meanings untyped expressions drawn 
disadvantage approach give meanings expressions intuitively meaningless ill typed 
second approach give meaning expressions typing derivations 
possible ambiguity assignment types resolved typing derivation choose particular type expression 
hand may consider coherence different typing derivations expression type lead meaning 
meanings compatible way arbitrary decisions type inference lead observable differences behavior 
exercises program 
mini ml language discussed far property easily seen hold expression uniquely determines typing derivation 
complex languages may require non trivial proof 
note ambiguity problem usually arise choose language presentation style church expression contains type information uniquely determine type 
exercises exercise write mini ml programs multiplication exponentiation subtraction function returns pair integer quotient remainder natural numbers 
exercise principal type expression type type obtained instantiating type variables types formulation mini ml unique typed expression principal type mil 
write mini ml programs satisfying informal specifications determine principal types 

compose compute composition functions 
iterate iterate function times exercise write evaluation plus definition plus example page 
exercise write typing derivation shows function double page typed 
exercise explore alternatives definition expressions section 
case give relevant inference rules evaluation typing 

add type booleans replace constructs concerning natural numbers pred zerop 
replace constructs concerning pairs pair fst snd 
replace constructs concerning pairs split hx chapter 
mini ml language exercise consider replacing rule ev fst 
ev fst fst 
show incorrect 
exercise consider extension language unit type written unit disjoint sums inl inr case inl inr example alternative predecessor function return argument zero predecessor 
typing discipline expression pred lam case typable 
inject values disjoint sum type pred lam case inl inr pred nat 
nat optional values type modelled general type 

give appropriate rules evaluation typing 

extend notion value 

extend proof value soundness theorem 

extend proof type preservation theorem 
exercise consider language extension lambda lambda type lists members type introduce appropriate value constructor destructor expressions proceed exercise 
exercise exercise explore operation substitution detail section 
limit fragment containing lam abstraction application 

define free hold variable occurs free 
exercises 
define ff hold alphabetic variants differ names assigned bound variables explained section 
define result substituting operation avoid capture variables free result unique renaming bound variables 

prove ff occur free 

prove ff provided occur free 
exercise exercise explore different ways treat errors semantics 

assume new value error arbitary type modify operational semantics appropriately 
may assume typed expressions evaluated 
example evaluation lam need result error 

add empty type called void containing values 
closed expressions type 
add new expression form abort arbitrary type type add evaluation rules abort 
value soundness type preservation properties extend language 
language compare item 
important semantic property type systems summarized welltyped programs go wrong 
meaning ill typed expressions fst defined distinguished semantic value wrong contrast intuitively non terminating expressions fix shown typed expression meaning wrong 
related phrase statically typed languages type errors occur runtime 
discuss properties expressed framework extent reflected type preservation theorem 
exercise language standard ml mth occurrences fixed point expressions restricted form fix lam means evaluation fixed point expression terminates step value lam fix lam occasionally proposed extend ml construct recursive values 
example fix represent circular value printed finitely 
value defined example fix 
chapter 
mini ml language language expressions values fact value 
intuitively evaluation terminate 
define alternative semantics mini ml language permits recursive values 
modify definition values typing rules necessary 
sketch required changes statements proofs value soundness type preservation uniqueness values 
discuss relative merits languages 
exercise explore alternative operational semantics expressions known values evaluated evaluated 
state prove way new semantics equivalent section 
hint may necessary extend language expressions explicitly separate language values language expressions 
exercise specify call name operational semantics language function application 
lam 
ev app 
constructors successor pairing lazy evaluate arguments 
consider sense val name respective rules 
modify affected inference rules define notion lazy value prove call name evaluation returns lazy value 
furthermore write function observe nat nat lazy value type nat returns corresponding eager value exists 
exercise prove value derivable 
derivable 
values exactly expressions evaluate 
exercise replacement lemma necessary formulations type preservation theorem 
states type implies implies prove lemma 
careful generalize necessary clearly exhibit structure induction proof 
exercise complete proof theorem giving cases ev pair ev fst ev snd 
exercise prove theorem 

exercises exercise non determinism consider non deterministic extension new expression constructors ffi phi evaluation rules 
ev choice phi 

ev choice phi 
phi signifies non deterministic choice ffi means failure choice zero alternatives 

modify type system extend proofs value soundness type preservation 

write expression may evaluate arbitrary natural number 

write expression may evaluate precisely numbers prime 

write expression may evaluate precisely prime numbers 
exercise general pattern matching patterns mini ml defined patterns hp devise version mini ml case natural numbers fst snd replaced single form case expression arbitrarily branches 
branch form variables bound 
define operational semantics 

define typing rules 

prove type preservation lemmas may need 
show critical cases proofs similar ones notes 

language deterministic 
devise restriction language deterministic 

operational semantics require equality expressions functional type 
devise restriction requires equality observable types case inductively natural numbers products observable type 
exercise prove expressions val lam equivalent sense 
context gamma gamma val iff gamma 
lam 
val 
iff lam 
chapter 
mini ml language sufficient guarantee replace expression larger program value program change 
exercise carefully define notion subexpression mini ml prove gamma subexpression typed appropriate context 
bibliography dominique cl ement jo elle despeyroux thierry despeyroux gilles kahn 
simple applicative language mini ml 
proceedings conference lisp functional programming pages 
acm press 
cf curry feys 
combinatory logic 
north holland amsterdam 
chu church 
set postulates foundation logic annals mathematics 
chu church 
set postulates foundation logic ii 
annals mathematics 
chu church 
calculi lambda conversion 
princeton university press princeton new jersey 
cur curry 
functionality combinatory logic 
proceedings national academy sciences 
dm luis damas robin milner 
principal type schemes functional programs 
conference record th acm symposium principles programming languages popl pages 
acm press 
gen gerhard gentzen 
untersuchungen uber das logische 
mathematische zeitschrift 
english translation szabo editor collected papers gerhard gentzen pages north holland 
gun carl gunter 
semantics programming languages 
mit press cambridge massachusetts 
bibliography han john hannan 
investigating proof theoretic meta language functional programs 
phd thesis university pennsylvania january 
available technical report ms cis 
han john hannan 
extended natural semantics 
journal functional programming april 
hb david hilbert paul bernays 
grundlagen der mathematik 
springerverlag berlin 
hhp robert harper furio honsell gordon plotkin 
framework defining logics 
journal association computing machinery january 
hm john hannan dale miller 
meta logic functional programming 
abramson rogers editors meta programming logic programming chapter pages 
mit press 
howard 
formulae types notion construction 
seldin hindley editors curry essays combinatory logic lambda calculus formalism pages 
academic press 
hitherto unpublished note rearranged corrected annotated howard 
kah gilles kahn 
natural semantics 
proceedings symposium theoretical aspects computer science pages 
springer verlag lncs 
mil robin milner 
theory type polymorphism programming 
journal computer system sciences august 
ml martin 
meanings logical constants justifications logical laws 
technical report di logica matematica dipartimento di matematica universit di siena 
ml martin 
meanings logical constants justifications logical laws 
nordic journal philosophical logic 
mth robin milner mads tofte robert harper 
definition standard ml 
mit press cambridge massachusetts 
pfe frank pfenning 
logic programming lf logical framework 
erard huet gordon plotkin editors logical frameworks pages 
cambridge university press 
bibliography pfe frank pfenning 
elf meta language deductive systems 
bundy editor proceedings th international conference automated deduction pages nancy france june 
springer verlag lnai 
system 
plo plotkin 
call name call value calculus 
theoretical computer science 
plo plotkin 
lcf considered programming language 
theoretical computer science 
plo gordon plotkin 
structural approach operational semantics 
technical report daimi fn computer science department aarhus university aarhus denmark september 
pra dag prawitz 
natural deduction 
almquist wiksell stockholm 
ps frank pfenning carsten sch 
system description twelf meta logical framework deductive systems 
ganzinger editor proceedings th international conference automated deduction cade pages trento italy july 
springerverlag lnai 
