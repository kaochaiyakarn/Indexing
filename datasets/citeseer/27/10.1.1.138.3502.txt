stride scheduling deterministic proportional share resource management presents stride scheduling deterministic scheduling technique efficiently supports flexible resource management abstractions introduced lottery scheduling 
compared lottery scheduling stride scheduling achieves significantly improved accuracy relative throughput rates significantly lower response time variability 
stride scheduling implements proportional share control processor time resources cross applying elements rate flow control algorithms designed networks 
introduce new techniques support dynamic changes higher level resource management abstractions 
introduce novel hierarchical stride scheduling algorithm achieves better throughput accuracy lower response time variability prior schemes 
stride scheduling evaluated simulations prototypes implemented linux kernel 
keywords dynamic scheduling proportional share resource allocation rate service service rate objectives schedulers multithreaded systems multiplex scarce resources order service requests varying importance 
accurate control relative computation mail carl weihl lcs mit edu 
world wide web www psg lcs mit edu 
prof weihl currently supported dec sabbatical dec src 
research supported arpa contract ibm equipment dec views contained document authors interpreted representing official policies expressed implied government 
carl waldspurger william weihl technical memorandum mit lcs tm mit laboratory computer science cambridge ma june rates required achieve service rate objectives users applications 
control desirable broad spectrum systems including databases applications networks 
motivating examples include control frame rates competing video viewers query rates concurrent clients databases web servers consumption shared resources long running computations 
general purpose approaches proposed support flexible responsive control service rates 
introduced lottery scheduling randomized resource allocation mechanism provides efficient responsive control relative computation rates wal :10.1.1.129.159
lottery scheduling implements resource management resource consumption rates active clients proportional relative shares allocated 
higher level abstractions flexible modular resource management introduced lottery scheduling depend randomized implementation proportional sharing 
introduce stride scheduling deterministic scheduling technique efficiently supports flexible resource management abstractions introduced lottery scheduling 
contribution cross application generalization flow control algorithms designed networks dem zha par schedule resources processor time 
new techniques support dynamic operations modification relative allocations transfer resource rights clients 
introduce novel hierarchical stride scheduling algorithm 
hierarchical stride scheduling recursive application basic technique achieves better throughput accuracy lower response time variability previous schemes 
simulation results demonstrate compared lottery scheduling stride scheduling achieves significantly improved accuracy relative throughput rates significantly lower response time variability 
contrast deterministic schemes stride scheduling efficiently supports operations dynamically modify relative allocations number clients competing resource 
implemented prototype stride schedulers linux kernel provide accurate control processor time relative network transmission rates competing sockets 
section core mechanism 
section describes extensions support resource management abstractions introduced lottery scheduling 
section introduces hierarchical stride scheduling 
simulation results quantitative comparisons lottery scheduling appear section 
discussion linux prototypes related implementation issues section 
section examine related 
summarize section 
stride scheduling stride scheduling deterministic allocation mechanism time shared resources 
resources allocated discrete time slices refer duration standard time slice quantum 
resource rights represented tickets class objects issued different amounts passed clients 
throughput rates active clients directly proportional ticket allocations 
client twice tickets receive twice resource time interval 
client response times inversely proportional ticket allocations 
client twice tickets wait half long acquiring resource 
throughput accuracy proportional share scheduler characterized measuring differ terminology tickets currencies introduced lottery scheduling wal :10.1.1.129.159
ence specified actual number allocations client receives series allocations 
client tickets system total tickets specified allocation consecutive allocations due quantization typically impossible achieve ideal exactly 
define client absolute error absolute value difference specified actual number allocations 
define pairwise relative error clients absolute error subsystem containing total number allocations received clients 
lottery scheduling offers probabilistic guarantees throughput response time stride scheduling provides stronger deterministic guarantees 
lottery scheduling series allocations client expected relative error expected absolute error stride scheduling relative error pair clients greater independent skewed ticket distributions possible client absolute error number clients 
stride scheduling considerably accurate lottery scheduling error grow number allocations 
section introduce hierarchical variant stride scheduling provides tighter bound client absolute error 
section presents basic stride scheduling algorithm introduces extensions support dynamic client participation dynamic modifications ticket allocations nonuniform quanta 
basic algorithm core stride scheduling idea compute representation time interval stride client wait successive allocations 
client smallest stride scheduled frequently 
client half stride execute twice quickly client double stride execute twice slowly 
strides represented virtual time units called passes units real time seconds 
state variables associated client tickets stride pass 
tickets field specifies client resource allocation relative clients 
client state typedef struct int tickets stride pass client large integer stride constant const int stride current resource owner client current initialize client specified allocation void client init client queue int tickets stride inverse tickets tickets tickets stride stride tickets pass stride join competition resource queue insert proportional share resource allocation void allocate queue select client minimum pass value current queue remove min resource quantum resource current compute pass stride current pass current stride queue insert current basic stride scheduling algorithm 
ansi code scheduling static set clients 
queue manipulations performed time appropriate data structure 
stride field inversely proportional tickets represents interval selections measured passes 
pass field represents virtual time index client selection 
performing resource allocation simple client minimum pass selected pass advanced stride 
client minimum pass value may selected 
reasonable deterministic approach consistent ordering break ties defined unique client identifiers 
lists ansi code basic stride scheduling algorithm 
simplicity assume static set clients fixed ticket assignments 
stride scheduling state client initialized client init allocations performed allocate 
restrictions relaxed subsequent sections permit dynamic behavior 
accurately represent stride reciprocal tickets floating point representation 
efficient alternative uses fixed point integer representation 
easily implemented multiplying inverted ticket value large integer constant 
refer constant stride represents stride corresponding minimum ticket allocation cost performing allocation depends data structure implement client queue 
priority queue implement queue remove min queue operations time better number clients cor 
skip list provide expected time queue operations low constant overhead pug 
small heavily skewed ticket distributions simple sorted list efficient practice 
illustrates example stride scheduling 
clients competing resource ticket ratio 
simplicity convenient stride large number yielding respective strides 
pass value client plotted function time 
quantum client minimum pass value selected pass advanced stride 
ties appendix discusses representation strides detail 
pass value time quanta stride scheduling example 
clients circles squares ticket ratio 
example stride yielding respective strides 
quantum client minimum pass value selected pass advanced stride 
broken arbitrary consistent client ordering dynamic client participation algorithm support dynamic changes number clients competing resource 
clients allowed join leave time state appropriately modified 
extends basic algorithm efficiently handle dynamic changes 
key extension addition global variables maintain aggregate information set active clients 
global tickets variable contains total ticket sum active clients 
global pass variable maintains current pass scheduler 
global pass advances rate global stride quantum global stride stride global tickets 
conceptually global pass continuously advances smooth rate 
implemented invoking global pass update routine global pass value needed due fixed point integer representation strides small quantization errors may accumulate slowly causing state variable associated client store remaining portion stride dynamic change occurs 
remain field represents number passes left client selection 
client leaves system remain computed difference client pass global pass 
client rejoins system pass value recomputed adding remain value global pass 
mechanism handles situations involving positive negative error specified actual number allocations 
remain stride client effectively credit rejoins having previously waited part stride receiving quantum 
remain stride client effectively penalized rejoins having previously received quantum waiting entire stride approach implicit assumption partial quantum equivalent partial quantum 
general reasonable assumption resembles treatment nonuniform quanta section 
may appropriate total number tickets competing resource varies significantly time client leaves rejoins system 
time complexity client leave client join operations number clients 
operations efficient stride scheduling state associated distinct clients completely independent change client require updates clients 
cost results need perform queue manipulations 
dynamic ticket modifications additional support needed dynamically modify client ticket allocations 
illustrates dynamic allocation change lists ansi code global pass drift away client pass values long period time 
practical problem client pass values recomputed global pass time leave rejoin system 
problem avoided infrequently resetting global pass minimum pass value set active clients 
interesting alternatives implemented 
example client credit passes elapse inactive 
client state typedef struct int tickets stride pass remain client quantum real time units cycles const int quantum large integer stride constant const int stride current resource owner client current global aggregate tickets stride pass int global tickets global stride global pass update global pass elapsed real time void global pass update void static int update int elapsed compute elapsed time advance update elapsed time update update elapsed advance global pass quantum adjusted stride global pass global stride elapsed quantum update global tickets stride reflect change void global tickets update int delta global tickets delta global stride stride global tickets initialize client specified allocation void client init client int tickets stride inverse tickets stride remains tickets tickets stride stride tickets remain stride join competition resource void client join client queue compute pass allocation global pass update pass global pass remain add queue global tickets update tickets queue insert leave competition resource void client leave client queue compute remainder current stride global pass update remain pass global pass remove queue global tickets update tickets queue remove proportional share resource allocation void allocate queue int elapsed select client minimum pass value current queue remove min resource measuring elapsed real time elapsed resource current compute pass quantum adjusted stride current pass current stride elapsed quantum queue insert current dynamic stride scheduling algorithm 
ansi code stride scheduling operations including support joining leaving nonuniform quanta 
queue manipulations performed structure 
time appropriate data done stride global pass pass global pass pass stride remain remain allocation change 
modifying client allocation tickets tickets requires constant time recomputation stride pass 
new stride inversely proportional tickets new pass determined scaling remain remaining portion current stride stride stride 
dynamically modify client ticket allocation void client modify client queue int tickets int remain stride leave queue resource client leave compute new stride stride stride tickets scale remaining passes reflect change stride remain remain stride stride update client state tickets tickets stride stride remain remain rejoin queue resource client join dynamic ticket modification 
ansi code dynamic modifications client ticket allocations 
queue manipulations performed time appropriate data structure 
dynamically changing client ticket allocation 
client allocation dynamically changed tickets tickets stride pass values recomputed 
new stride computed usual inversely proportional tickets compute new pass remaining portion client current stride denoted remain adjusted reflect new stride accomplished scaling remain stride stride 
client ticket allocation increased pass decreased compressing time remaining client selected 
allocation decreased pass increased expanding time remaining client selected 
client modify operation requires time number clients 
dynamic changes number clients ticket allocation changes efficient stride scheduling state associated distinct clients completely independent dominant cost due queue manipulations 
nonuniform quanta basic stride scheduling algorithm client consume entire allocated quantum receive entitled share resource 
similarly may possible client usage exceed standard quantum situations 
example non preemptive scheduler client run lengths vary considerably 
fortunately fractional variable size quanta easily accommodated 
client consumes fraction allocated time quantum pass advanced stride stride 
client pass increased scheduled sooner 
client pass increased scheduled 
extended code listed supports nonuniform quanta effectively computing elapsed resource usage time divided standard quantum time units 
extension permit clients specify quantum size require implemented associating additional quantum field client scaling client stride field alternative allow client specify scheduling period 
client period quantum related relative resource share specifying quantity yields 
quantum 
deviations client speci quantum fied quantum handled described redefined elapsed resource usage divided quantum client specific flexible resource management stride scheduling enables low overhead dynamic modifications efficiently support flexible resource management abstractions introduced lottery scheduling wal :10.1.1.129.159
section explain ticket transfers ticket inflation ticket currencies implemented top stride substrate proportional sharing 
ticket transfers ticket transfer explicit transfer tickets client 
ticket transfers particularly useful client blocks waiting 
example synchronous rpc client loan resource rights server computing behalf 
transfer tickets clients essentially consists dynamic ticket modifications 
code modifications implemented invoking client modify tickets client modify tickets 
transfers tickets stride pass increase stride pass decrease 
slight complication arises case complete ticket transfer transfers entire ticket allocation case adjusted ticket value zero leading adjusted stride infinity division zero 
circumvent problem record fraction stride remaining time transfer adjust remaining fraction obtains tickets 
easily implemented computing remain value time transfer deferring computation stride pass values receives non zero ticket allocation return transfer 
ticket inflation alternative explicit ticket transfers ticket inflation client resource rights creating tickets 
ticket inflation deflation simply consists dynamic ticket modification client 
ticket inflation causes client stride pass decrease deflation causes stride pass increase 
ticket inflation useful mutually trusting clients permits resource rights reallocated explicitly tickets clients 
ticket inflation dangerous client resource simply creating large number tickets 
order avoid dangers inflation exploiting advantages introduced currency abstraction lottery scheduling wal loosely borrowed economics :10.1.1.129.159
ticket currencies ticket currency defines resource management abstraction barrier contains effects ticket inflation modular way 
tickets currencies allowing resource rights expressed units local group mutually trusting clients 
currency backed funded tickets primitive currencies 
currency relationships may form arbitrary acyclic graph hierarchy currencies 
effects inflation locally contained effectively maintaining exchange rate local currency common base currency conserved 
currency abstraction useful flexibly naming sharing protecting resource rights 
currency abstraction introduced lottery scheduling stride scheduling 
implementation technique immediately convert ticket values arbitrary currencies units common base currency 
changes value currency require dynamic modifications clients holding tickets currency derived 
scope changes currency values limited exactly clients affected 
currencies group isolate logical sets clients impact currency fluctuations typically localized 
important exception changes number tickets base currency require modifications 
stride scheduling state computed ticket values expressed base units state associated distinct clients independent 
hierarchical stride scheduling stride scheduling guarantees relative throughput error pair clients exceeds single quantum 
depending distribution tickets clients large absolute throughput error possible number clients 
example consider set clients ticket allocation 
schedule minimizes absolute error response time variability alternate ticket client clients 
standard stride algorithm schedules clients order ticket client receiving quanta client receives single quantum 
allocations intended allocation ticket client actual allocation yielding large absolute error 
behavior exhibited similar rate flow control algorithms networks dem zha par 
section describe novel hierarchical variant stride scheduling limits absolute throughput error client quanta 
client example described hierarchical stride scheduler simulations produced maximum absolute error 
algorithm significantly reduces response time variability aggregating clients improve interleaving 
common systems consist small number high throughput clients large number low throughput clients hierarchical stride scheduling represents practical improvement previous 
basic algorithm hierarchical stride scheduling essentially recursive application basic stride scheduling algorithm 
individual clients combined groups larger aggregate ticket allocations correspondingly smaller strides 
allocation performed invoking normal stride scheduling algorithm groups individual clients groups 
different groupings possible consider balanced binary tree groups 
leaf node represents individual client 
internal node represents group clients leaf nodes covers contains aggregate tickets stride pass binary tree node typedef struct node struct node left right parent int tickets stride pass node quantum real time units cycles const int quantum large integer stride constant const int stride current resource owner client current proportional share resource allocation void allocate node root int elapsed node traverse root leaf path min pass root node leaf left null right pass left pass right left resource measuring elapsed real time current elapsed resource current update pass ancestor stride current null parent pass stride elapsed quantum hierarchical stride scheduling algorithm 
ansi code hierachical stride scheduling static set clients 
main data structure binary tree nodes 
node represents client leaf group internal node summarizes aggregate information 
values 
internal node tickets total ticket sum clients covers stride stride tickets 
pass value internal node updated pass value clients covers modified 
presents ansi code basic hierarchical stride scheduling algorithm 
node normal tickets stride pass scheduling state usual tree links parent left child right child 
allocation performed tracing path root tree leaf choosing child smaller pass value level 
selected client finished resource pass value updated reflect usage 
client update identical dynamic stride algorithm supports nonuniform quanta listed 
hierarchical scheduler requires additional updates client ancestors leaf root path formed successive parent links 
client allocation viewed series pairwise allocations groups clients level tree 
maximum error pairwise allocation worst case error accumulate level 
maximum absolute error tree allocation height tree number clients 
error pairwise ratio minimized absolute error reduced carefully choosing client leaf positions better balance tree number tickets node 
dynamic modifications extending basic hierarchical stride algorithm support dynamic modifications requires careful consideration effects changes level tree 
lists ansi code performing ticket modification works clients internal nodes 
changes client ticket allocations essentially follow scaling update rules normal stride scheduling listed 
hierarchical scheduler requires additional updates client ancestors leaf root path formed successive parent links 
note root pass value effectively takes place global pass variable represent aggregate global scheduler pass 
dynamically modify node allocation delta tickets void node modify node node root int delta int old stride remain compute new tickets stride old stride stride tickets delta stride stride tickets done reach root root return scale remaining passes reflect change stride remain pass root pass remain remain stride old stride pass root pass remain propagate change ancestors node modify parent root delta dynamic ticket modification 
ansi code dynamic modifications client ticket allocations hierarchical stride scheduling 
modification requires time propagate changes 
developed operations support dynamic client participation hierarchical stride scheduling wal 
allocate time complexity client join client leave operations number clients 
simulation results section presents results quantitative experiments designed evaluate effectiveness stride scheduling 
examine behavior stride scheduling static dynamic environments test hierarchical stride scheduling 
stride scheduling compared lottery scheduling find stride approach provides accurate control relative throughput rates lower variance response times 
example presents results scheduling clients ticket ratio allocations 
dashed lines represent ideal allocations client 
clear lottery scheduling exhibits significant variability time scale due algorithm inherent randomization 
contrast indicates deterministic stride scheduler produces precise periodic behavior 
throughput accuracy randomized lottery scheduling expected value absolute error specified actual number allocations set clients number allocations 
number lotteries won client binomial distribution 
probability client holding tickets win lottery total identical lotteries tickets simply expected number wins variance deterministic stride scheduling relative error specified actual number allocations pair clients exceeds indepen dent source relative error due quantization 
cumulative quanta cumulative quanta time quanta lottery vs stride scheduling 
simulation results allocations involving clients allocation 
dashed lines represent ideal proportional share behavior 
allocation randomized lottery scheduler shows significant variability 
allocation deterministic stride scheduler exhibits precise periodic havior mean error quanta mean error quanta lottery lottery time quanta error quanta error quanta stride stride time quanta throughput accuracy 
simulation results clients top bottom ticket ratios allocations 
quanta shown stride scheduler quantization error deterministic periodic 
mean lottery scheduler error averaged separate runs 
stride scheduler error single run 
mean lottery scheduler error averaged separate runs 
stride scheduler error single run 
plots absolute error results simulating clients lottery scheduling stride scheduling 
data depicted representative simulation results large range pairwise ratios 
shows mean error averaged separate lottery scheduler runs ticket ratio 
expected error increases slowly indicating accuracy steadily improves error measured percentage shows error single stride scheduler run ticket ratio 
expected error exceeds single quantum follows deterministic pattern period 
error drops zero complete period corresponding precise allocation 
figures data similar experiments involving larger ticket ratio 
dynamic ticket allocations plots absolute error results simulating clients lottery scheduling stride scheduling rapidly changing dynamic ticket allocations 
data representative simulation results large range pairwise ratios variety dynamic modification techniques 
easy comparison average dynamic ticket ratios identical static ticket ratios 
notation indicates random ticket allocation uniformly distributed new randomly generated ticket allocations dynamically assigned quantum 
client modify operation executed change stride scheduling special actions necessary lottery scheduling 
compute error values specified allo cations determined incrementally 
client specified allocation advanced quan tum client current ticket allocation current ticket total 
shows mean error averaged separate lottery scheduler runs ticket ratio 
despite dynamic changes mean error nearly measured static ratio depicted 
similarly shows error single stride scheduler run case relative absolute errors identical clients 
dynamic ratio 
error exceeds single quantum erratic periodic pattern exhibited static ratio 
figures data similar experiments involving larger dynamic ratio 
results allocation comparable measured static ticket ratio depicted figures 
error measured lottery scheduling stride scheduling largely unaffected dynamic ticket modifications 
suggests mechanisms suited dynamic environments 
stride scheduling clearly accurate static dynamic environments 
response time variability important performance metric response time measure elapsed time client completion quantum including completion 
randomized lottery scheduling client response times geometric distribution 
expected number lotteries client wait win variance exhibits dramatically response time variability 
figures client response time distributions lottery scheduling stride scheduling 
shows response times result simulating clients ticket ratio allocations 
stride scheduler distributions tight lottery scheduler distributions geometric long tails 
example client smaller allocation maximum response time quanta stride scheduling maximum response time lottery scheduling 
presents similar data larger ticket ratio 
little difference response time distributions client larger allocation difference enormous client smaller allocation 
stride scheduling virtually response times exactly quanta 
lottery scheduler produced geometrically distributed response times ranging quanta 
case standard deviation stride scheduler distribution orders magnitude smaller standard deviation lottery scheduler distribution 
deterministic stride scheduling mean error quanta mean error quanta lottery lottery time quanta error quanta error quanta stride stride time quanta throughput accuracy dynamic allocations 
simulation results clients top bottom ticket ratios allocations 
notation indicates random ticket allocation uniformly distributed random ticket allocations dynamically updated quantum 
mean lottery scheduler error averaged separate runs 
stride scheduler error single run 
mean lottery scheduler error averaged separate runs 
stride scheduler error single run 
frequency thousands frequency thousands lottery lottery response time quanta frequency thousands frequency thousands stride stride response time quanta response time distribution 
simulation results clients ticket ratio allocations 
client tickets lottery scheduling 
client tickets stride scheduling 
client tickets lottery scheduling 
client tickets stride scheduling frequency thousands frequency thousands lottery lottery response time quanta frequency thousands frequency thousands stride stride response time quanta response time distribution 
simulation results clients ticket ratio allocations 
client tickets lottery scheduling 
client tickets stride scheduling 
client ticket lottery scheduling 
client ticket stride scheduling hierarchical stride scheduling discussed section stride scheduling produce absolute error skewed ticket distributions number clients 
contrast hierarchical stride scheduling bounds absolute error result response time variability significantly reduced hierarchical stride scheduling 
presents client response time distributions hierarchical stride scheduling ordinary stride scheduling 
clients ticket ratio simulated allocations 
excluding allocation response time low throughput clients schedulers 
response time distributions high throughput client 
ordinary stride scheduler runs client consecutive quanta runs low throughput clients quantum 
hierarchical stride scheduler interleaves clients resulting tighter distribution 
case standard deviation ordinary stride scheduler distribution twice large hierarchical stride scheduler 
observed maximum absolute error quanta high throughput client ordinary stride scheduling quanta hierarchical stride scheduling 
prototype implementations implemented prototype stride schedulers modifying linux kernel mhz ibm thinkpad 
prototype enables proportional share control processor time second enables proportional share control network transmission bandwidth 
process scheduler goal prototype permit proportional share allocation processor time control relative computation rates 
primarily changed kernel code handles process scheduling switching conventional priority scheduler algorithm scheduling quantum milliseconds 
ticket allocations specified new frequency thousands frequency thousands response time quanta hierarchical stride scheduling 
response time distributions simulation clients ticket ratio allocations 
response times shown client tickets 
hierarchical stride scheduler 
ordinary stride scheduler observed iteration ratio allocated ratio cpu rate accuracy 
allocation ratio observed iteration ratio plotted second runs 
gray line indicates ideal ratios identical 
observed ratios ideal data points 
stride cpu set tickets system call 
implement support higher level abstractions ticket transfers currencies 
fewer lines source code added modified implement changes 
experiment tested accuracy prototype control relative execution rate computations 
point plotted indicates relative execution rate observed processes running compute integer arithmetic benchmark byt 
second runs executed integral ratio 
cases observed ratios ideal 
ran experiments involving higher ratios observed ratio allocation ranged observed ratio allocation ranged 
experiment examined scheduler behavior shorter time intervals 
plots average iteration counts series second time windows single second execution allocation 
processes remain close allocated average iterations sec time sec cpu fairness time 
processes executing compute bound arith benchmark ticket allocation 
averaged entire run processes executed iterations sec actual ratio 
ratios experiment 
note millisecond time quantum scheduler millisecond quantum degree fairness observed series millisecond time windows 
assess overhead imposed prototype stride scheduler ran performance tests consisting benchmark processes 
performance prototype comparable standard linux process scheduler 
compared unmodified linux groups arith processes completed fewer iterations stride scheduling difference 
standard linux scheduler prototype stride scheduler particularly efficient 
example linux scheduler performs linear scan processes find highest priority 
prototype performs linear scan find process minimum pass time implementation required substantial changes existing kernel code 
network device scheduler goal second prototype permit proportional share control transmission bandwidth network devices ethernet slip interfaces 
control particularly useful applications concurrent ftp file transfers web server replies 
example web servers relatively slow connections internet resulting substantial delays transfers large objects graphical images 
control relative transmission rates web server provide different levels service concurrent clients 
example tickets issued servers requesting user machine domain 
commercial servers sell tickets clients demanding faster service 
primarily changed kernel code handles generic network device queueing 
involved switching conventional fifo queueing queueing respects socket ticket allocations 
ticket allocations specified new tickets option system call 
implemented prototype complete system consider additional forms admission control manage system resources network buffers 
fewer lines source code added modified implement changes 
experiment tested prototype ability control relative network transmission rates local area network 
network test program ttc transfer fabricated buffers ibm thinkpad running modified linux kernel included requests tickets require external data representation 
security concern cryptographic techniques employed prevent forgery theft 
minor modifications benchmark 
extensions specify ticket allocations facilitate coordinated timing decreased value hard coded delay constant 
constant temporarily put transmitting process sleep unable write socket due lack buffer space 
modification observed throughput ratios consistently lower specified allocations significant differences large ratios 
larger delay constant believe low throughput client able continue sending packets high throughput client sleeping distorting intended throughput ratio 
course changing kernel interface signal process buffer space available probably preferable polling 
observed throughput ratio allocated ratio ethernet udp rate accuracy 
allocation ratio observed data transmission ratio plotted runs 
gray line indicates ideal ratios identical 
observed ratios ideal data points 
decstation running ultrix 
machines physical subnet connected mbps ethernet carried network traffic users 
point plotted indicates relative udp data transmission rate observed processes running ttcp benchmark 
experiment started processes sending machine attempting transmit buffers containing kbytes data total mbyte transfer 
soon process finished sending data terminated process unix signal 
metrics recorded receiving machine capture application throughput 
observed ratios accurate data points ideal 
larger ticket ratios observed throughput ratio slightly lower specified allocation 
example allocation resulted actual throughput ratios ranging 
assess overhead imposed prototype ran performance tests consisting benchmark processes 
performance prototype comparable standard linux 
prototype increases length critical path sending network packet unable observe significant difference unmodified linux stride scheduling 
believe small additional overhead stride scheduling masked variability external network traffic users individual differences range 
related independently developed stride scheduling deterministic alternative randomized selection aspect lottery scheduling wal :10.1.1.129.159
discovered core allocation algorithm stride scheduling nearly identical elements rate flow control algorithms designed packet switched networks dem zha par 
despite relevance networking research best knowledge discussed processor scheduling literature 
section discuss variety related scheduling including rate network flow control deterministic proportional share schedulers priority schedulers real time schedulers microeconomic schedulers 
rate network flow control basic stride scheduling algorithm similar zhang algorithm packet switched networks zha 
scheme network switch orders packets forwarded outgoing links 
packet belongs client data stream stream associated bandwidth reservation 
virtual clock assigned stream packets stamped current virtual time arrival 
arrival virtual clock advances virtual tick inversely proportional stream reserved data rate 
stride oriented terminology virtual tick analogous stride virtual clock analogous pass value 
algorithm closely related weighted fair queueing wfq algorithm developed demers keshav shenker dem parekh gallager equivalent packet packet generalized processor sharing pgps algorithm par 
difference distinguishes wfq pgps virtual clock effectively maintain global virtual clock 
arriving packets stamped stream virtual tick plus maximum stream virtual clock global virtual clock 
modification inactive stream link virtual clock caught active streams behavior possible algorithm par 
stride scheduler global pass variable global virtual clock employed wfq pgps follows update rule produces smoothly varying global virtual time 
aware wfq pgps simpler global pass update rule global pass set pass value client currently owns resource 
see difference approaches consider set minimum pass values time 
average pass value increase quantum actual increases occur non uniform steps 
adopted smoother wfq pgps virtual time rule improve accuracy pass updates associated dynamic modifications 
best knowledge stride scheduling cross application rate network flow control algorithms scheduling resources processor time 
new techniques required support dynamic changes higher level abstractions ticket transfers currencies 
hierarchical stride scheduling algorithm novel recursive application basic technique exhibits improved throughput accuracy reduced response time variability compared prior schemes 
proportional share schedulers deterministic approaches proposed proportional share processor scheduling fon mah sto 
require expensive operations transform client state response dynamic changes 
attractive stride scheduling supporting dynamic distributed environments 
algorithm explicitly compared lottery scheduling provides efficient support flexible resource management abstractions introduced lottery scheduling 
stoica abdel devised interesting scheduler deterministic generator employs bit reversed counter place random number generator lottery scheduling sto 
algorithm results absolute error throughput number allocations 
allocations performed efficiently time tree data structure number clients 
dynamic modifications set active clients allocations require executing relatively complex restart operation time complexity 
support provided fractional nonuniform quanta 
maheshwari developed deterministic proportional share scheduler mah 
loosely analogy digitized line drawing scheme maximum relative throughput error quantum supports fractional quanta 
efficient cases allocation worstcase time complexity number clients 
dynamic modifications require executing refund operation time complexity 
fong introduced general scheduling approach called time function scheduling tfs fon 
tfs intended provide differential treatment job classes specific throughput ratios specified classes jobs class scheduled fcfs manner 
time functions compute dynamic job priorities function time job spent waiting placed run queue 
linear functions result proportional sharing job value equal waiting time job class slope plus job class constant 
allocation performed selecting job maximum time function value 
naive implementation expensive jobs grouped classes allocation performed time number distinct classes 
time function values updated infrequently compared scheduling quantum priority queue reduce allocation cost cost rebuild queue update 
fong compared tfs lottery scheduling throughput accuracy comparable waiting time variance tasks orders magnitude larger lottery scheduling 
observation consistent simulation results involving response time section 
tfs offers potential specify performance goals general proportional sharing 
proportional sharing goal stride scheduling advantages terms efficiency accuracy 
priority schedulers conventional operating systems typically employ priority schemes scheduling processes dei tan 
priority schedulers designed provide proportional share control relative computation rates ad hoc 
popular priority approaches decay usage scheduling poorly understood despite fact employed numerous operating systems including unix hel 
fair share schedulers allocate resources users get fair machine shares long periods time hen kay hel 
schedulers layered top conventional priority schedulers dynamically adjust priorities push actual usage closer entitled shares 
algorithms systems generally complex requiring periodic usage monitoring complicated dynamic priority adjustments administrative parameter setting ensure fairness time scale minutes 
real time schedulers real time schedulers designed time critical systems bur 
systems include aerospace military applications timing requirements impose absolute deadlines met ensure correctness safety missed deadline may dire consequences 
widely techniques real time systems rate monotonic scheduling priorities statically assigned monotonic function rate periodic tasks liu sha 
importance task reflected priority tasks shorter periods simply assigned higher priorities 
bounds total processor utilization ranging nearly depending various assumptions ensure rate monotonic scheduling meet task deadlines 
popular technique earliest deadline scheduling schedules task closest deadline 
earliest deadline approach permits high processor utilization increased runtime overhead due dynamic priorities task nearest deadline varies time 
general real time schedulers depend restrictive assumptions including precise static knowledge task execution times prohibitions task interactions 
addition limitations placed processor utilization transient overloads disallowed 
contrast proportional share model stride scheduling lottery scheduling designed general purpose environments 
task allocations degrade gracefully overload situations active tasks proportionally benefit extra resources allocations fully utilized 
properties facilitate adaptive applications respond changes resource availability 
mercer savage tokuda introduced higher level processor capacity reserve abstraction mer measuring controlling processor usage microkernel system underlying real time scheduler 
reserves passed protection boundaries interprocess communication effect similar ticket transfers 
approach works multimedia applications reliance resource reservations admission control restrictive general purpose model advocate 
microeconomic schedulers microeconomic schedulers metaphors resource allocation real economic systems 
money encapsulates resource rights price mechanism allocate resources 
microeconomic schedulers dre mil fer fer wal wal wel auctions determine prices allocate resources clients bid monetary funds 
algorithm proposed uniprocessor scheduling dre distributed spawn system wal rely auctions bidders increase bids linearly time 
auction dynamics unexpectedly volatile auction approaches fail achieve resource allocations proportional client funding 
overhead bidding limits applicability auctions relatively coarse grained tasks 
market approaches rely auctions applied managing pro cessor memory resources ell har che 
stride scheduling lottery scheduling compatible market resource management philosophy 
mechanisms proportional sharing provide convenient substrate pricing individual time shared resources computational economy 
example tickets analogous monetary income streams number tickets competing resource viewed price 
currency abstraction flexible resource management loosely borrowed economics 
stride scheduling deterministic technique provides accurate control relative computation rates 
stride scheduling efficiently supports flexible modular resource management abstractions introduced lottery scheduling 
compared lottery scheduling stride scheduling achieves significantly improved accuracy relative throughput rates significantly response time variability 
lottery scheduling conceptually simpler stride scheduling 
example stride scheduling requires careful state updates dynamic changes lottery scheduling effectively stateless 
core allocation mechanism stride scheduling rate flow control algorithms networks 
contribution cross application algorithms domain processor scheduling 
new techniques developed support dynamic modifications client allocations resource right transfers clients 
introduced new hierarchical stride scheduling algorithm exhibits improved throughput accuracy lower response time variability compared prior schemes 
bala dawson engler paige parsons lyle ramshaw helpful comments 
tom suggesting connection rate algorithms networking literature 
special paige help visual presentation stride scheduling 
bur burns 
scheduling hard real time systems review software engineering journal may 
byt byte unix benchmarks version 
available usenet anonymous ftp locations dec com 
che cheriton 
market approach operating system memory allocation working computer science department stanford university june 
cor cormen leiserson rivest 
algorithms mit press 
dei 
operating systems addison wesley 
dem demers shenker 
analysis simulation fair queueing algorithm internetworking research experience september 
dre drexler miller 
incentive engineering computational resource management ecology computation huberman ed north holland 
ell ellison 
utah scheduler proceedings ieee june 
fer ferguson yemini nikolaou 
microeconomic algorithms load balancing distributed computer systems international conference distributed computer systems 
fer ferguson 
application microeconomics design resource allocation control algorithms ph thesis columbia university 
fon fong 
time functions general approach controllable resource management working draft ibm research division watson research center yorktown heights ny march 
har cheriton 
application controlled physical memory external page cache management fifth international conference architectural support programming languages operating systems october 
hel hellerstein 
achieving service rate objectives decay usage scheduling ieee transactions software engineering august 
hen henry 
fair share scheduler bell laboratories technical journal october 
kay kay 
fair share scheduler communications acm january 
liu liu layland 
scheduling algorithms multiprogramming hard real time environment journal acm january 
mah maheshwari 
charge proportional scheduling working draft mit laboratory computer science cambridge ma february 
mer mercer savage tokuda 
processor capacity reserves operating system support multimedia applications proceedings ieee international conference multimedia computing systems may 
mil miller drexler 
markets computation open systems ecology computation huberman ed north holland 
par parekh gallager 
generalized processor sharing approach flow control integrated services networks single node case ieee acm transactions networking june 
pug pugh 
skip lists probabilistic alternative balanced trees communications acm june 
sha sha klein goodenough 
rate monotonic analysis real time systems foundations real time computing scheduling resource management van eds kluwer academic publishers 
sto stoica abdel 
new approach implement proportional share resource allocation technical report department computer science old dominion university va april 
tan tanenbaum 
modern operating systems prentice hall 
ttc ttcp benchmarking tool 
sgi version 
originally developed army research lab 
available anonymous ftp locations including ftp sgi com 
wal waldspurger 
distributed computational economy utilizing idle resources master thesis mit may 
wal waldspurger hogg huberman kephart stornetta 
spawn distributed computational economy ieee transactions software engineering february 
wal waldspurger weihl :10.1.1.129.159
lottery scheduling flexible proportional share resource management proceedings symposium operating systems design implementation november 
wal waldspurger 
lottery stride scheduling flexible proportional share resource management ph thesis mit appear 
wel wellman 
market oriented programming environment application distributed multicommodity flow problems journal artificial intelligence research august 
zha zhang 
virtual clock new traffic control algorithm packet switching networks acm transactions computer systems may 
zhang 
comparison rate service disciplines proceedings sig comm september 
fixed point stride representation precision relative rates achieved depends stride value relative ratios client ticket allocations 
stride example maximum ticket allocation tickets ratios represented bits precision 
ratios close unity resulting allocations differ part supported 
large integer stride values stride large clients small allocations 
pass values monotonically increasing eventually overflow machine word size large number allocations 
machine bit integers practical problem 
stride example worst case client tickets approximately allocations performed overflow occurs 
allocation millisecond centuries real time elapse overflow 
machine bit integers pass values associated clients adjusted subtracting minimum pass value clients overflow detected 
alternatively adjustments periodically fixed number allocations 
stride example conservative adjustment period allocations 
straightforward approach simply bit integer type available 
prototype implementation bit long long integer type provided gnu compiler 
