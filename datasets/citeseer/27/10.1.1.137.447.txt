semantic foundations concurrent constraint programming concurrent constraint programming sar sr sim ple powerful model concurrent computation notions store constraint process information transducer 
store valuation conception von neu mann computing replaced notion store constraint finite representation possibly infinite set valuations provides partial information possible values variables take 
reading writing values variables processes may ask check constraint entailed store tell augment store new constraint 
general paradigm subsumes terminate data flow concurrent constraint logic programming languages 
develops basic ideas involved giving coherent semantic account languages 
con tribution give simple general formulation notion constraint system system partial infor mation la information systems scott 
parameter passing hiding handled borrowing ideas cylindric algebras henkin monk tarski introduce diagonal elements operations mimic projection information induced existential quantifiers 
se ond contribution introduce notion determinate concurrent constraint programming languages 
combinators treated ask tell parallel composition hiding recursion 
simple model language specification oriented methodology oh 
crucial insight focus observing resting points process stores pro cess producing information 
turns determinate language set resting points process completely characterizes behavior inputs process identified closure operator underlying constraint system 
nat ural definitions parallel composition communication hiding 
example parallel composition agents characterized just intersection sets constraints associated 
give complete axiomatization equality model permission copy fee part granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission association computing machinery 
copy wise republish requires fee aud specific permission 
acm vijay saraswat xerox parc martin rinard stanford university prakash mcgill university preliminary report simple operational semantics dispenses explicit notions renaming plague logic programming semantics show model fully respect semantics 
third contribution extend modelling ideas nondeterminate language language including bounded dependent choice 
context longer sufficient record set resting points process record path taken process sequence ask tell inter actions wit environment reach resting point 
nature constraint communication turns convenient model paths certain kinds closure operators bounded trace operators 
extend operational semantics non determinate case show operational semantics fully consistent model programs denote object model iff context distinguishes operationally 
simple model cc languages facto concurrent logic programming languages handles recursion compositional respect combinators language proving liveness properties programs fully respect obvious notion observation 
aim enterprise simple develop semantic foundations new paradigm concurrent computing sar sr 
basic paradigm 
crucial concept underlying paradigm replace notion store valuation hind imperative programming languages store constraint 
constraint mean possibly finite subset space possible valuations variables interest 
store constraint valuation means stage computation may partial information possible values variables take 
take fundamental possibility state computation may able provide partial information variables interest 
paradigm shift renders usual notions imperative read incoherent 
example may single finitely describable value left return result read operation variable 
similarly assign operation capable prescribing fully formed concrete value variable new value may previous value 
runs difficulties notion store specifies con straints obeyed variables 
sar proposes replacement read notion ask write notion tell 
ask operation takes constraint say uses probe structure store 
succeeds store con information entail tell takes constraint constraints place store 
set valuations describing resultant store intersection set valuations describing original store describing additional con straint 
computation progresses information accumulated store basic ste change value variable rules certain values possible store monotonically refined 
idea monotonic update theo treatment structures id 
structures introduced order ben place update introducing problems interference 
interesting concurrent constraint paradigm seen arising purification logic pro gramming sar enhancement functional program ming generalization imperative programming 
viewpoint dataflow programming concur rent constraint paradigm generalization flow information processes bidirectional 
relate goal symmetrical theory computation advocated girard gir gir 
central notion constraint system isa theory information entailment informa 

theory exists form scott treatment information systems sc 
case natural imagine concurrent processes imposing inconsistent constraints store 
need represent possibility inconsistent information 
app possibilities concurrency quite apparent 
single agent inter acting store ask tell operations num ber agents simultaneously interact store fashion 
synchronization achieved blocking ask agent blocks store strong entail constraint wishes check remains blocked time concurrently ing agents add information store strong entail query 
note particular paradigm notion shared store ideas read write locks synchronization 
basic reason benign form change accumulation information allowed system desired indeterminacy introduced allowing agent block multiple dis constraints simultaneously specify distinct actions invoked corresponding ask condition course say systems state describable cc paradigm state change repre 
sented compromising basic paradigm adapting stan 
dard techniques logic functional programming assignable variables embedded local state recursive gent agent changes value variable merely recurring new value arguments 
languages cc framework janus considerable hope mechanisms representing state change competitive performance traditional assignment techniques 
satisfied store 

view agent computing station thought information transducer 
agent ei ther add constraint store tell suspend information store entail con straint decompose number agents run ning parallel possibly hidden interconnections communicating synchronizing store 
course standard computations unbounded length achieved recursion 
computational significance paradigm 
ideas extremely simple conceal powerful pro gramming paradigm derives strength ver communication mechanism 
possible short describe interesting com munication schemes possible 
shall just attempt indicate basic ideas refer reader detailed treatments sar 
idea variables serve communica tion channels bet multiple concurrently executing agents 
computational framework insist priori partitioning agents producers consumers information variables happens example function application information flows argument function body csp ccs style actor style languages 
fact agent may simultaneously add check constraints vari ables 
computational framework allows lying network transport protocol perform potentially arbitrarily sophisticated inferences messages en trusted course deductions tioned entailment relation constraint system 
agent state constraints sees frees programmer having put agents explicitly collecting messages drawing appropriate inferences reformatting data 
allows high level languages lot com putation expressed merely posting constraints 
constraint system herbrand domain mundane finite trees communication scheme leads interesting idioms incomplete messages short circuits difference lists messages sar techniques colloquially referred stemming power logical variable instance possible embed commu nication channel variable message class object exactly way data 
elegant form dynamic reconfigurability kind difficult achieve simple way frameworks ccs csp 
practicality framework attested fact implemented cc lan guages available including commercial implementation ft 
focusses constraints commu nication control concurrent constraint programming languages 
worth pointing concurrent con straint programming framework concerned nd con communication schemes de essence computation logic programming style 
origins cc framework concurrent logic programming notion constraint logic programing intro 
duced jl mah 
see sar details 
just concurrency takes step wards general architecture computing constraints dependent form constraint systems particular details 
provides coherent attempt articulate vision constraint programming manifest land sussman steele borning 
particular cc framework concerned com introducing controlling logic programming style search non determinism 
goals research defining general class constraint systems concurrent constraint paradigm applies 

presence constraint systems computational engineering problems widespread 
example applications ai usefully viewed terms constraints 
general definition allow define constraint systems data types diverse finite trees streams intervals rational numbers vari ous types functions spaces data types derived knowledge applications 
design constraint systems computational systems lim 
difficult consider data structure interest computer science types records bags arrays hash tables graphs bi nary search trees devise constraint systems interest usefully interestingly embedded cc language 
generality 
cc framework parametrized arbi constraint system 
schematic treatment brings usual advantages results need proven immediately applicable members class 
particular models develop fact class models large class programming languages 
place restrictions nature con straint demand partial information notion means various pieces partial information true objects notion rw tency means certain information hold 
pieces information hold notion entailment 
relationship theories concurrence 
radical new ideas concurrency 
particular note called chemical ma chine due boudol berry mobile pro cesses due milner workers mp 
approaches key new ingredient processes alter interactions mobile 
approach interactions processes dynamic sense predetermined set agents agent limited interact 
relationships need understood carefully 
par interesting understand lambda tion mechanism incorporated concurrent constraint paradigm 
understanding relationships cc languages shall mean cc languages ask tell primitive con cc md useful saz defined outside scope 
mobile processes boudol gamma calculus helpful known encode lazy lambda calculus mi jp 
contributions central task develop semantic foundations programming paradigm discussed 
formalize basic notion con st system operational semantics determinate nondeterminate cc lan guages 
paragraphs discuss contributions detail 
constraint systems 
formalize notion constraint system generalizing simplifying previous treatments sar jl sr 
basic insight treat constraint systems systems partial information style dana scott development information systems operators express hiding information 
programming point view operations allow parameter passing constraint programming languages local variables procedures 
philosophy modeling 
models developed pa philosophy modeling discussed oh hoa 
paragraphs summarize basic ideas ontological commitments style 
crucial philosophy identification tion observation process 
process equated set observations 
set processes identified presenting collection natu rally motivated closure conditions sets observations 
important observations process include ways process go wrong fail meet obligations imposed environment 
process goes wrong detailed modeling process irrelevant emphasis approach guaranteeing long environment honors obligations process process go wrong 
ontological commitment usually captured gan divergence catastrophic happen process goes wrong 
way process go wrong en internal chatter infinite sequence internal actions possibly continually producing output asking environment put giving environment ability con trol execution denying input 
cc framework way process go wrong causes shared store inconsistent state process completely environment 
action environ ment take influence course execution process inconsistent store answer ng ask request 
process free follow branch potentially follow input environment 
particular process recursively calls process engage infinite execution sequence ask operation guarding recursive procedure call answered successfully 
suggests semantic model process produce false distinguished form pro cess engage infinite execution sequence processes treated catastrophic 
approach followed main body 
alternative treatments failure diver gence possible section shall indicate possibilities treated 
determinate constraint programming 
sixteen years ago kahn gave theory determinate data flow kah 
day theory extensions concrete data structures remains dominant theory nate concurrent computation 
simple elegant widely applicable theory emphasis computing directional point point communication channels imposes expressibility restrictions channels carry fully formed values underlying data domain networks dynamically reconfigurable connections passed data communication chan nels channel reader writer 
restrictions kahn theory model useful programming idioms incomplete messages difference lists recursive doubling multiple readers writers communication channel dynamic reconfiguration techniques originally developed context nondeterminate concurrent logic programming ajl inherently determinate usefully ex determinate contexts 
presents simple theory determinate com putation model idioms theory preserves essential features kahn ory substantially extending domain applicability 
programming point view useful interesting focus determinate subset mathematically simpler treatment sacrificing essential novelty major semantic computational ideas underlying cc paradigm illustrated determinate case 
simple algebraic syntax determinate concurrent constraint programs 
op semantics labelled transition system configuration just agent label pair constraints store transition ini store terminates 
transition system able completely avoid substitutions variable renamings considerably simplifying treatment 
past theoretical treatments constraint logic programming various ad hoc techniques rn 
th process taken set con straints resting points process satisfying cer tain properties 
various combinators defined processes corresponding ask tell operations run ning agents parallel creating new loca communication channel 
show denotational se mantics fully respect operational se mantics give sound complete axiomatization equality finite programs finite program equiv 
established purely equational reasoning 
develop slightly different model limits fair infinite execution sequences observed 
models nondeterminate cc languages 
denotation ate somewhat determinate case storing just resting points process associate resting point path followed process reaching point 
path called failure 
denotation set failures 
set identified presenting naturally ted closure conditions sets failures jos example major conditions ensures processes finitely ate 
resulting notion pro cess intuitive easy understand 
combinators cor responding ask tell nondeterminate dependent choice parallel composition hiding defined 
simple op semantics full correspondence semantics established 
particular believe treatment gives completely satisfactory account semantics concurrent logic programming languages 
central issue semantic treatment repre sentation failure 
failure represented sequence ask tell annotated constraints 
strategy followed earlier related languages example sar lev gl gms ask tell far concrete 
store information abstracted usually complex closure conditions en code precise path followed process arrive resting point 
furthermore definition various combi cumbersome need propagate information trace 
chose observations various kinds closure tors 
capture various operational notions interest introduce concept trace operators bounded clo sure operators portions theory relevant 
establish simple relationship nondeterminate determinate semantics showing semantics essentially identical determinate programs ary constraint systems 
summary simple model cc lan guages fully able account nondeterminism divergence permitting model reason ing liveness properties programs 
model shown fully consistent intuitive operational semantics cc programs 
related basic concepts concurrent constraint programming introduced sar sar 
subsequently developed operational semantics bisimulation semantics sr 
line research extends subsumes intents purposes earlier semantics concurrent logic programming languages power logical variable amply rec years numerous authors numer ous survey extended investigated combination functional logic semantics account language concurrent prolog studied cls view defect approach researchers working concurrent prolog moved ask tell cc framework gms 
programming languages lin dl anp 
account basic paradigm comparable kahn original account simplicity generality forthcoming 
noteworthy context pp discusses subset functional pro gramming language id logical arrays anp 
semantic treatment identifies program clo sure operator 
treatment particular kinds arrays dealing parametrized general notion constraint system 
explicitly discuss hiding ask operations tell operation implicit asks 
model 
operational model includes explicit discussion constraints resolved 
achieve considerable simplicity abstracting away details constraint resolution process 
characterization concurrency intersection sets fixed points elaborated hoare hoa setting related unity cm 
develops viewpoint presents char combinators style 
believe concurrent constraint programming lan guages natural setting development ory computing closure operators 
semantics nondeterminate concurrent constraint programming languages active area sr gms gl dbp 
explores simple characterizations possible nant languages representation various sorts trees sets annotated sequences constraints 
notion det studied set logic programming languages mah characterizations kind provide 
gms consider combinators treat having complicated treatment ask tell sequences 
treat recursion 
appear palamidessi dbp dbp propose model similar respects 
particular recognized sufficient take ask tell actions order get model languages 
treatment ignores recursion 
sophistication model lies way finite nondeterminate axioms need introduced order correctly model divergence 
model bp compositional respect choice operator 
development follows closely mark treat ment receptive processes jos 
receptive process accept input environment may produce different output depending input 
gives set axioms reactive processes turn needed order develop model cc languages 
primary differences lie nature communication combina tors treated 
theory treats communication usual ccs csp style exchange uninterpreted environment 
constraint nature cc languages imposes additional structure considered 
demonstrates possible adapt basic model cc setup major reworking confirm robustness conceptualization asynchronous systems 
constraint systems presentation simplified generalized ation sr 
details may 
constraint system 
course assertions things assertion syntactically object programming language 
postulate set tokens giving partial information certain states affairs 
finite state computation program de posited finite set tokens embedded constraint solver may demand know token entailed postulate compact en relation pd pd set finite subsets records inter dependencies 
intention set tokens entail token just case state affairs assert token assert leads definition simple constraint system structure non empty countable set tokens primitive constraints pd relation satisfying pd set finite subsets cl ul ul pc andv extend relation pd pd iff 
define vi 
course implementable language decidable efficient intended class users language demand 
compactness entailment relation ensures semi decidable entailment relation 
token entailed entailed finite set entailment holds checked finite time 
store entail constraint may possible constraint solver say finite stage computation 
treatment systems partial information course known underlies dana scot informa tion systems approach domain theory sc 
simple constraint system just information system consistency structure removed natural set ting conceive possibility execution program give rise inconsistent state affairs 
standard lines states affairs representable system identified set tokens hold 
definition elements constraint system subsets finite subset set elements denoted id define id pe 
ii reality systems underlying concrete concurrent constraint programming languages slightly structure ask tell constraint systems sar 
addi tional structure arises possible state level constraint system imposition certain constraints delayed time associated constraint entailed store implicit ask restriction 
additional structure crucial easily handled extending techniques 
known id complete algebraic lattice compactness gives id element true greatest element denote false glbs denoted intersection lubs denoted closure union 
lub chains just union members chain 
finite elements id just elements generated finite subsets set elements denoted id 
stand elements id means common notations referring elements id tc alert reader noticed constraint system need generate algebraic lattice general scott information systems generate fini domains 
common constraint systems finitary data type defined finitary 
interpretation determinate con current constraint programs need constraint system finitary nondeterminate case 
drop requirement entailment relation compact generate general lattices algebraic 
need entailment relation compact know ideas extended constraint systems 
follows finite constraint shall mean finite set tokens 
take liberty confusing finite constraint dio 
example generating constraint systems 
order vocabulary countably infinite set variables var take arbitrary subset open var formulas entailment relation respect class structures 
pi 
iff structure valuation realizes realizes pi 

simple constraint system 
ii example kahn constraint system 
concretely define kahn constraint system underlying data flow languages kah underlying constraint system domain data elements vocabulary consisting predicate symbols func tion symbols postulate infinite set var variables 
set tokens consist atomic var formulas 
consist single struc ture domain bw set possibly infinite sequences including empty sequence interpretations symbols equality predicate predicate true sequences function maps sequence unit length sequence el ement element function maps sequence sequence obtained drop ping element means finite element dominates finitely elements 
function returns second argument argument returns se quence consisting element argu ment followed elements second argument 
define cn edc aed completing definition constraint system 
note constraint system set elements finitary 
constraint finite entails infinitely constraints form 
constraint system compact en relation algebraicity 
lattice generated entailment closed sets tokens set consisting entailment closure con tain tokens form set consisting contain possible define variant system finitary 
data type streams course finitary 
example herbrand constraint system 
describe example quickly 
ordinary order language equality 
tokens constraint system atomic propositions 
entailment vary de pending intended predicate symbols include usual entailment relations expects equality 
example entail 
equality predicate symbol constraint system finitary 
predicates lattice depend entailment relation 
example rational intervals 
underlying tokens form rational numbers notation means closed interval assume membership assertion primitive token 
entailment relation derived ob vious interpretation tokens 
xl zz xl vi zz yz 
yields compact entailment relation slightly del issue 
assume usual definition tion unions infinite families intervals def compact entailment relation 
exam ple fim ln finite subset ln entail 
may take definition mean finite collection intervals 
case entailment relation definition compact lattice generated algebraic 
appear slightly peculiar respect normal expectations intervals 
join family assertions involving membership nested family intervals yield assertion membership intersection family 
new element dl sits intersection 
example join un new element sits 
clearly lattice entailment relation compact lattice 
worth noting example shows model determinate computations domains 
fact order dense subse lattice model determinate language model nondeterminate languages constraint systems 
known closure operators lattice order dense subset form algebraic complete partial 
extension ideas higher order programming wilf challenging 
hiding constraint systems 
reasonable programming language supports modularity providing notion hiding internal structure agent cent ext 
support hiding family hiding operators underlying constraint system operators capture notion projecting away information 
axiom cylindric algebra hmt 
research plan give principled account hiding choice axioms notions categorical logic 
definition constraint system structure var var simple constraint system var infinite set indeterminate variables variable var ax pd pd operation satisfying el ut ez implies xu xv xu yu xu variable extended continuous function idi idi obvious way xc xu example token set consist subclass var formulas closed existential quantification finite conjunctions 
operator interpreted function maps finite set pi 
tokens set tokens 
pn 
see conditions satisfied 
diagonal elements 
useful programming languages framework necessary consider procedures parameter passing 
usual logic programming languages parameter passing supported substitutions 
trick due tarski colleagues 
class constraint systems discussed trick il providing tokens diagonal formulas var 
formula formula 
generally prime interval pair finite elements finite element properly bet incremental domain related finite elements finite sequence prime intervals interpolates means elements distinct element 
indebted michael huth pointing 
arbitrary constraint system axiomatize required properties oft diagonal elements mt 
demand token set cent ain pair vari ables var token dx satisfying properties 

dxy dxy 
dxy ix defect axiomatization appears oft hln air 
particular categorical logic expounded lambek scott ls haa thorough analysis vari ables variable free calculi relationship 
cast notion constraint system categorical terms able vast body results categorical logic ls course de velopment concept constraint system 
axioms hiding emerge fundamental principles logic suggest logic implicit treatment form coherent logic 
determinate language 
important observations indirectly experiment 
successful choice right kind indirect observation provide remarkably coherent general explanation wide range diverse phenomena 
hoare basic semantic insight crucial observation process set resting points 
process information processing device interacts environment shared constraint representing known common information 
resting point process con straint process initiated eventually halt wit bout producing information 
basic idea semantics nondeterminate language significantly complex semantics determinate language 
reason simple 
determinate language turns sufficient store process just set resting points discuss 
determinate process produce output constraint input const 
identify process function function maps input false process initiated engages infinite execution sequence process ultimately having upgraded store turns information indebted robert seely phil scott observation 
js true 
ure erator semantics consider section resting point process constraint process initiated able new information receiving information outside 
point process may engage infinite execution sequence long produces new information 
shall confuse process input produces false halts process input engages infinite execution sequence 
recall tune specification oriented approach semantics resting points process uniquely determine associated function 
property highlights semantic simplicity ask tell communication synchro mechanism 
operator id corresponding process 
way process affect store adding information 
extensive vc second store accessible process environment input process produces output halts case resting point input process progress wouldn stopped 
idempotent vc consider happens output function information content input 
invocation function corresponds imposition constraint information input increased information output decrease 
function called monotone operator partial order extensive idem potent monotone called closure operator classical consequence operator tar 
closure opera tors extensively studied enjoy beautiful properties shall exploit 
computer science continuous closure operators sc characterize data types 
list basic properties 
tal property closure operator lattice represented range set fixed points 
recovered mapping input element 
easy see idempotence fixed point monotonic ity fixed point 
representation convenient shall confuse closure operator range writing mean fact subset range closure operator iff closed glbs arbitrary subsets glbs exist lattice 
range closure operator non empty contain false 
partial order 
closure operator id df divergences inputs process diverges 
discussed divergences exactly constraints mapped false false 
partial order determinate pro cesses interest partly processes divergences 
intention process im proved process divergences contained point convergence take identical values 
terms fixed points yields definition divergence order closure operators ii bottom element partial order false diverges 
hard see order complete limits chains unions set fixed points 
process algebra section develop simple language nate cc language expressing behavior concurrent determinate constraint processes 
consider agents con structed tells finite constraints asks finite con straints hiding operators parallel composition proce dure calls 
section shall assume fixed cylindrical constraint system diagonal elements usual idi denotes constraint system set elements denotes set finite elements 
define quartic transition relation env ill define operational semantics programming language 
env set par tial functions procedure names syntactic agents 
write 
shall write omitting relevant take mean initiated store agent step upgrade store subse quently behave usual sos style relation described specifying set axioms tak ing relation smallest relation satisfying axioms 
syntax semantics determinate language table 
discuss semantic definitions section 
purposes exposition assume procedures take exactly variable parameter program calls undefined procedure 
system confuse syntactic object consisting finite set tokens semantic object consisting set closure 
tells 
process augments input finite con straint behaves operator terms fixed points just operational behavior described transi tion axiom true true corresponding adding information shared constraint single step 
asks 
constraint process 
process store contains le ss ch infor mation behaves process described function az zf thenf terms range def depending context shall stand syntactic object consisting finite set tokens constraint obtained closure set semantic process imposes constraint store syntactic agent imposes constraint store syntax 
semantic equations 

ai aa xa 
ea id xa 

xd xc ranges basic constraints sets 
syntactic class programs syntactic class sequences procedure declarations syn tactic class agents 
variable underlying con straint system allowed occur user programs 
dummy variable parameter passing 
maps procedure names processes providing environment procedure calls 
notation stand 
table denotational semantics ask tell de terminate cc languages ask operation monotone continuous process argument 
satisfies laws ll ad true true ijd true rule fl parallel composition 
consider parallel composition processes suppose input runs producing 
idempotent unable produce information 
may run producing information enabling additional information production 
system exactly 
set fixed points exactly intersection set fixed points set fixed points fag fng straightforward verify operation defined monotone continuous argu ments 
argument quite simple elegant hides issues substantial complexity 
ba sic property exploited determinate process 
suppose agent initiated hou con ted definitions concurrency computational models fall back sort interleaving basic actions 
store produces constraint leaving residual agent executed 
find subsequent behavior find output produce store necessary maintain explicit represent ation denotation effect input obtained simply running original program 
ba sic reason possible model determinate process accurately just set resting points 
shall see section property true nondeterminate processes 
take denotation process function relation finite stores finite stores necessary preserve information path sequence ssk tell interactions environment followed process reaching resting point 
definition laws follow immediately 
parallel composition commutative associative identity element 
aa baa aa bac aab ac true telling constraints parallel equivalent telling conjunction 
prefixing distributes parallel com position 
cad ud aab ifc ub ifc ub ifd transition rule reflects fact communicate synchronously communication takes place asynchronously information added agent stored shared constraint agent 
aa ab baa baa projection 
suppose process wish define behavior intuitively hide interactions environment 
consider behavior xf input may constrain external process see 
obtain behavior xf observe behavior xc may constrain internal result seen environment xc 
leads define xf xd hiding operators enjoy interesting proper ties 
example show dual closure operators kernel operators operators class denotations determinate pro grams 
order define transition relation xa ex tend transition relation agents form internal store holding information hidden outside 
transition axiom xa yields agent internal store xa xd gd 
axiom reflects fact information hidden xa ail information produces hidden environment 
note may need produced information progress information stored constraint axiom agents internal store ward 
information external store combined information internal store new con straint generated transition retained internal store du xd 
order agents operator need law xc xc order get complete equational axiomatization finite agents containing form xb need constraint system expressive 
specifically require cl var exists written iff 
var exists idi 
written dl cu xd iff xc xd state remaining laws needed obtain complete axiom 
ez ez ez xc xa ei ci di recursion 
recursion handled usual way tak 
ing limits denotations syntactic approximants underlying domain cpo combinators continuous process arguments 
operationally procedure calls handled procedure environment responding ax 
cr dax example append illustrate combinators consider append procedure determinate cc lan guage kahn constraint system append inl inl inl ini append ini 
procedure waits environment equates puts data item communica tion channel executes appropriate branch body 
note ask conditions branches mutually exclusive call execute entire body procedure 
procedure uses operator ostensibly represents parallel execu tion determinate choice operator 
common idiom determinate concurrent constraint programs 
completeness axiomatization 
completeness axiomatization proven normal form 
definition agent normal form iff true properties pi implies ci cj implies di cj ci dj implies di dj lemma agent containing constructs form xb converted normal form equations lemma ang agent normal form ci 
lemma proving complete ness theorem theorem ifl normal form 
laws ll 
sound com plete finite agents built tells asks parallel composition 
addition theorem laws ll ez ex sound complete finite agents 
operational semantics 
order extract environment run define qe li computation transition system sequence transitions environment constrained pro duce 
final constraint transition match initial constraint tram sition 
definition formalizes notion computation starting finite constraint definition transition sequence program possibly infinite sequence ai pairs agents stores po ai ai partial map procedure names syntactic agents domain empty 
transition sequence said terminal finite length stuck constraint agent po 
case called final store 
prove number operational results fairly straightforward way 
lemma operational monotonicity 

fi possible transition az 
essentially operational property 
definition suppose agent store transitions enabled 
say transitions commute az uc aa possible 
lemma immediate character key property determinate agents 
lemma agent transition possible store commute 
theorem proved appealing theorem confluence constraint de terminate program terminal transition sequence final store infinite transition sequence 
terminal transition se quences final store 
theorem allows define observation function programs mapping id terminal transition sequence final store false theorem closure operator 
nontrivial part proof showing idem done induction length reduction sequences lemma 
connect operational semantics denotational semantics 
theorem strong adequacy programs observationally equal iff denotations equal 
denotations programs contain information distinguish programs operationally different 
proof sketch show single re duction step preserves denotational semantics 
show sets fixed points closure opera tors 
order structural induction fixed point induction recursive case 
proofs trivial particularly novel 
full contain thorough discus sion 
remains show denotations programs identified viewpoint operational se mantics behave identically 
definition context program aio agent contains placeholder denoted 
put program context union definitions renaming procedures necessary avoid name clashes replacing placeholder yielding 
theorem full abstraction contexts obs cip obs ciq 
theorem easy prove strong adequacy compositional definition denotational semantics 
alternate semantic treatments semantics notion appropri ate confuse process takes input false halts process diverges input coherent alternative notions handling divergence modelled minor variations theme 
section show briefly gen erate model distinguishes false div generate model associates input limit fair execution sequences program input 
case sketch major idea leave full development exercise reader 
distinguishing div false 
suppose input process observe process diverges observe resultant store 
denotation agent partial function id io 
sort function 
observe determinate cc process engages infinite execution sequence engage infinite execution sequence store domain downward closed 
domain closure operator 
motivates definition definition partial closure operator lattice closure operator downward closed subset range partial closure operator contains information recover function 
particular domain function just downward closure range function 
fact set fixed points partial closure operator characterized quite simply follows lattice set set fixed points partial closure operator iff closed glbs arbitrary non subsets 
added gener ality arises merely fact false required fixed point partial closure operator 
note range partial closure operator cor responding div program diverges input just domain function empty set 
hand range partial closure opera tor corresponding false false 
semantics distinguishes programs 
partial closure operators partially divergence ordering set inputs undefined just complement domain 
surprisingly definition combinators re mains unchanged operational interpretation denotation changed dc ad az xa xd definitions yields partial closure operator process arguments partial closure operators 
defines function monotone continuous process arguments 
connections operational semantics es manner analogous connections 
semantics observing limits 
seman tics treats divergent computation catastrophic treated computation causes store inconsistent 
discussed earlier possible develop different semantics limits fair execution se quences observed 
example semantics associate cc kahn process ones ones 
closure operator maps true limit constraint forces infinite 
previous semantics associate pro gram partial closure operator diverges true 
need define notion fair execution se quence 
stage computation may sev eral enabled transitions reduces agent 
note reduced stage computation reduced successive stage computation transition taken carries reduction 
say transition sequence jair eventually reduces reduced stage common notion needs defining operational semantics concurrent 
semantics denotation process asso input limit sequence store fair execution sequence process 
denotation taken operator id 
denotation closure addition 
reasonable demand process decide produce output examined infinite amount input 
demand continuous directed uf lo terms fixed points hard see set fixed points closure operator continuous iff closed lubs directed subsets 
partial order processes extensional iff bottom element partial order id id limits chains intersection top element false operator maps element false 
surprisingly definition combinators re mains unchanged previous section modulo fact fixed points taken idi just dca xa idi xc xd combinators seen defined yield continuous closure operators process argu ments continuous closure operators monotone continuous process arguments 
result follows commutativity prop erties transitions 
theorem sz fair transition se quences si sz cons yields set constraints theorem allows define observation function programs mapping idi ms icons fair transition sequence relationship denotational semantics 
dis quite brief quite similar previous discussion 
new issues deal transition sequences fair semantic main entirely different order 
operational semantic function defined entire domain generated constraint system just finite elements 
relevant theorems follows 
theorem continuous extension operator idi 
theorem 
theorem full abstraction ifl obs cip obs ciq 
nondeterminate language consider determinate cc language previous section bounded nondeterminate choice 
syntactically admit agent expressions form ci 
cn finite constraints agents ai 
intuitively store agent step reduce affecting store provided ith branch open ci 
branch open agent remains stuck branch open chosen 
axiom dependent choice satisfied relation construct admitted language de notation agent longer function dio 
just relation dlo parallel composition definable 
model process set record process engages environment reaching state resting point progress intervention environment 
sim ple idea turns adequate give denotational semantics fully respect notion observation includes observation divergence final quiescent stores execution sequence 
rest section devoted giving expo sition model 
nature constraintbased communication turns convenient model failures certain kinds closure operators bounded trace operators 
subsection treat basic ideas underlying bounded trace operators turning presentation model 
basic model trace operators 
general provided un constraint system expressive see sec tion finite closure operator represented parallel composition finite set finite sequences asks tells sequence bl 
called trace thought representing closure op erator az 
am trace operator finitary lattice intuitively closure operator represented single possi bly infinite ask tell sequence 
characterizing property trace operator set elements fixed points ns provided exists definition trace operator finitary lattice closure operator disjoint ils fls defined 
set trace operators intuitively definition justified follows 
arbitrary element suppose trace 
fixed point oft possible execute prefix actions including tell action involving constraint stronger 
similarly smallest prefix executed asks able execute ing tell constraint condition trace operator stated elegantly follows 
closure op erator lattice define inverse set elements te 
lemma closure operator trace oper ator iff closure operator 
trace operator 
inverse weakest 
intuitively exactly sequence asks tells asks exactly tells tells exactly asks 
consequently input sequences traversed completely yielding final answer trace operators thought invertible closure operators 
conversely possible show trace opera tor represented canonically sequence ask tell actions closure operator closure operator fixed points 
lemma trace operator represented alternating strictly increasing sequence ask tell actions 
basic idea construction canonical sequence quite simple 
trace operator 
canonical trace corresponding just tr ue tr ue true lemma difficult show lemma var var cylindric constraint system 
dlo jar dio closure operator 
trace operators closed op erations interest naturally arbi parallel composition 
bounded trace operators 
failures process record resting point process information get 
failure represented pair resting point trace operator describing set ask tell interactions needed reach note information interest behavior fn trace operator sub lattice bounded trace operator bto short finitary lattice defined trace operator bounded trace operators special kind partial trace operators specifically range contains maximal element 
partial trace operators just partial closure operators section addition traces 
bt denote set operators 
just partial trace operator bto representable range domain definition just read max greatest fixed point 
various operations defined closure operators applicable obvious adjustments 
constraint shall take bto corresponding imposition just bto set fixed points 
similarly constraint trace operator just bto 
additional operations interest 
discuss operations reflect operational notion extending sequence tell interactions ask tell actions 
finite bto canonical sequence ask tell actions constraint 
define ck read output extended bto corresponding sequence actions 
hard find represent ation terms shall assume expression defined take stand cases 
note ion taken stand contained provided exists 
similarly define notion input extending bto constraint note 
definitions input output extensions hard see sequence ask tell actions 
en corresponding closure operator just 
true ez abused notation writing expression case 
expression case 
write case thought prefix thought extending sequence interactions environment engaged 
partial order expressed directly terms set fixed points 
clearly additional interactions cause take different value points domain possibly define order 
verified definition partial partial order interest follows 
say asks write resting point identical records contributions environment happens just cas ij vz ij just case model set observations dio set finite bounded trace operators id 
process subset obs satisfying certain conditions motivate jos closely 
stage computation process engaged ask tell interactions store 
subse quently may produce output activated input subsequent stage may engage infinite sequence actions requiring input environment progress producing output progresses 
model process divergent infinitely ways output forever causes requiring store inconsistent 
processes finitely 
set failures process divergences defined df 
infinite false situations considered undesirable concerned detailed modelling process example closure operator extends takes different value consider closure operators ob 
tained sequences di cus quite reasonable set regard process produces inconsistent store divergent 
possible give minor variation current treat ment distinguishes process diverges process tells false outside scope 
divergent 
process treated chaotic aa able exhibit behavior whatsoever 
require set possible behaviors process cent sin aii possible behaviors especially diverging ones 
condition impose process es set extensions note df implies df 
action sequence ask tell interactions constituting minimal divergence ask action 
words divergence characterizes inputs environment undesirable cause process break 
definition clear 
distributes finite unions arbitrary intersections arbitrary sets observations 
divergences process characterized nicely lemma false ef conditions best motivated consid ering traces process 
trace process just sequence tell interactions process engage necessarily reaching quiescent state traces process recovered simple way failures just observations extended obtain failure clearly tf distributes arbitrary unions sets observations 
require process exhibits trace possible prefix trace inherent idea trace require process non empty set failures 
condi tion equivalent stating empty bto true 
true true trace process true cc processes asynchronous environment prevented adding constraints store 
possible extend sequence interactions process may environment input action condition tf hard show chain processes fz 
ni tf 
req lre final condition processes 
process engage sequence actions recorded bto engage sequence actions stages environment supply input minimum required process engage 
require failures process closed ask relationship essence condition represents monotonic nature basic ask tell actions 
ready define definition nondeterminate process subset satisfying conditions 
nproc set subsets 
lemma establishes convergence process contain information generate divergences 
converse true 
process define input extensions set cf convergence set df 
lemma df icf true tcf essentially input extension convergent trace process output extension failure process condition output extension convergence divergence extensions 
conversely divergence process prefix input extends convergence convergent trace process chaotic bto divergence 
partial order processes 
usually processes ed semantics ordered called isrn ordering flg fzg corresponds intuition process better deterministic 
completely undefined process chaotic process exhibit possible behaviors information process generated behaviors get ruled senses ordering liberal desired discussed roscoe ros 
example way process improve process dropping convergent behavior sort capability manifested cc combinator csp combinator find convenient adopt divergence ordering proposed roscoe 
ordering better iff diverges fewer places convergent behaviors preserved precisely partial order cg easy see definition implies furthermore element partial order limits increasing chains intersection 
fact 
increasing chain lub ni fi cf ui cfi df na 
theorem nproc complete partial order 
syntax 
ia aa ic ci aj auxiliary definitions 
df ti infinite tf ti fng coh 
li ti jef obs false xd xi ax semantic equations 
cj aj tc false aj elf cj cj cj 
ed xa dex fi dax ua ranges basic constraints finite sets 
syntactic class programs syntactic class sequences procedure de rations syn tactic class agents 
variable underlying con straint system allowed occur user programs 
dummy variable parameter passing 
maps procedure names processes providing environment procedure calls 
notation stand 
table denotational semantics ask tell nondeterminate cc languages process algebra section define various processes combinators nproc including div process immediately diverges tell finite constraints parallel composition nondeterminate choice hiding combinators 
syntax programming language table semantic definitions discussed summarized 
simultaneously define operational semantics language assume procedures take exactly variable parameter program calls undefined procedure 
chaos 
chaotic process whatsoever 
div obs clearly div div 
operationally agent willing progress store 
progress affects agent subsequent behavior div div tells 
consider process immediately terminates augmenting store constraint call process resting points process clearly stores reach resting point process add cto store 
hard see bto satisfies condition inputs domain iff 
process diverge 
diverge iff engage sequence interactions store output bounded reaches state output reach false easy ue uc false definitions establish ri ntc lc false ntc ud defined process 
relevant axiom transition relation agents determinate case axiom 
dependent choice 
consider process cj 
kinds resting points resting points arise cj secondly resting points stronger corresponding 
furthermore generating kind resting point simple form 
output produced process hand path followed reaching resting point fj stronger cj path followed environment willing supply paths fj cj 
leads definition cj fj cj calculated divergences traces cj cj cj je cj fj cj cjs jej jd dz cj combinator monotone continuous process arguments 
special cases operator worth 
case index set singleton dependent choice form choice reduces just ask combinator 
just dependent choice conditional 
terms denotations get flf note agents transition axiom ii reduces just axiom section 
similarly blind unconditional choice expressed 
consider binary combinator defined behave decision arbitrarily compile time 
failures precisely failures easily checked true true 
fng defined true true div agent built blind 
blind choice idempotent associative com zero element 
operationally choice satisfies axioms parallel composition 
resting points fag 
clearly resting point resting point path followed resting point parallel composition paths followed failure set iig going failure fng ij fcf divergences 
divergences arise divergences possibility agents may engage infinite sequence interactions asks demanding input environment stage 
bto fll cor responding mutual feed back common resting point execution branch 
capturing possibilities cc language built arbitrary constraint system subtle 
sim ple formulation possible finitary constraint systems constraint systems finite element dominates finitely finite elements 
case show lemma constraint system nproc df 
suggests determine divergences sufficient determine divergences traces easy trace just trace running parallel trace divergent traces just ed tfl tg 
get ed ed ed proving continuity operator requires care 
basic issue show ed continuous arguments 
operational transition rule agents built aa deterministic case axiom 
projection 
resting point yf iff initiated xd resting point new information xe 
resting point xf iff xd 
route taken xf reach true route prescribed xg obtained extending closure operator id io restricted define obs false xd failures xf xf fu divergences traces process shown xf ed xf operator monotone continuous argument 
transition relation xa de terminate case transition relation ex tended agents internal store 
recursion 
recursion handled usual way limits denotations syntactic approximants underlying domain processes cpo combinators continuous process arguments 
diagonal elements effect parameter passing see table 
operationally procedure calls handled determinate case 
operational semantics operational semantics associates program initial store set possible outputs ob store caveat process diverges produces false output deemed ob 
notation sequence mean terminal transition sequence final store definition program define obs infinite true sequence obs true sequence true sequence relationship denotational semantics 
connection operational semantics denotational semantics theorems 
proofs omitted version 
theorem adequacy results obtained executing program identical resting points program obtained store true 
note weaker correspondence determinate operational semantics identical denotational semantics 
abstraction proof uses notion context previously defined determinate programs 
theorem full abstraction contexts cip ciq 
denotations programs different maximal bto 
shown sequence corre sponding expressed language implies sequence corresponding expressed language 
finite bto context distinguishes programs 

assume loss generality cases df cf 
df diverge 
implies diverge false 
cf 
convergence violates assumption 
relationship nondeterminate determinate semantics set transition rules determinate combinators notion observation determinate nondeterminate semantics 
operational semantics determinate language determinate subset nondeterminate language 
determinate ad semantics fully respect corresponding operational semantics relationship ad 
consider determinate agent equivalence classes cd cn induced ad respectively 
nondeterminate language contexts tell apart agents determinate language cd coarsening cn able re cover determinate program determinate denotation nondeterminate denotation 
definition element nproc determinate 
cf nproc implies ck tf 
cf tf implies cf 
subset determinate processes nproc 
henceforth say determinate mean agent nproc satisfies condi tion element syntactic class determinate processes 
course denotation agents built determinate combinators determinate theorem determinate constructed determinate combinators 
ready define dn associates corresponding element domain denotational semantics determinate agents section 
definition dn cf false 
theorem dn ad agents constructed determinate operators 
prove theorem showing dn closure operator 
show structural induction theorem holds finite agents built deter combinators 
prove theorem recursively defined agents showing dn monotone con 
presents comprehensive treatment specifi cation oriented approach semantics programs writ concurrent constraint programming languages 
treatment includes programs built recursion 
general notion constraint system cleanly separate semantics programming language com semantics underlying data domain 
separation allows uniformly address semantics wide variety concurrent constraint programming lan guages single framework 
languages include concurrent logic programming languages kahn data flow net works 
brings sharp focus complex ity caused having cc languages 
determinate semantics need record stores process need maintain intermediate process state information 
nate semantics hand record stores process may store computation paths store 
plays key role determinate semantics semantics 
connection determinate se mantics nondeterminate semantics defining operator extracts determinate denotation pro gram built determinate ors non determinate denotation 
equational ax complete finite programs built determinate combinators 
presents single transition system determinate nondeterminate languages 
transition system uses diagonal elements local stores eliminate messy variable renaming operations 
directions research 
include foundational concerns addressed implementation issues applications 
intend pur sue issues coming months 
section mention semantic issues 
means exhausted range interesting combinators available determinate cc lan guages 
example glb operator agents available provides sort determinant disjunction 
operators treated complete ver sion 
useful line investigation try characterize sensible combinators may 
general results category theory may help 
variety different semantics correspond ing different notions observations 
develop semantics indeterminate case viewing divergence chaos 
plotkin powerdomain treatment indeterminate tive languages 
subsequent plan de proof systems safety liveness properties cc programs models 
related developing closely related safety model 
believe possible develop theory higher order determinate cc programming languages 
interesting connections theories higher order concurrent processes bb jp mi classical linear logic 
appears concurrent constraint languages may related proof nets girard discussion proof theory linear logic 
connection successful ex concurrent constraint programs arising linear logic curry howard isomorphism 
research supported part darpa contract nsf ccr cornell university nserc mcgill university 
gratefully acknowledge discussions seif haridi tony hoare radha jagadeesan mark ken kahn john lamping keshav pingali gordon plotkin 
debt treatment owes mark development re processes clear read 
held responsible remaining errors 
anp bb cm dbp dbp dl ft arvind nikhil keshav pin 
dat structures parallel computing 
acm transactions principles programming languages ber 
boudol berry 
chemical machine 
proceedings th annual acm symposium principles programming languages pages 
acm 
mani chandy jay misra 
parallel program design foundation 
addison wesley 
de boer palamidessi 
fully ab model concurrent constraint logic lan guages 
proceedings concur 
de boer palamidessi 
fully model concurrent constraint program ming 
june 
doug degroot gary lindstrom editors 
logic programming functions relations equations 
prentice hall 
ian foster steve taylor 
strand new con cepts parallel programming 
prentice hall 
rob gerth mike codish yossi ehud shapiro 
fully denotational semantics flat concurrent prolog 
lics 
gir 
girard 
linear logic 
computer science 
gir 
girard 
proofs types volume cambridge tracts theoretical science 
cambridge university press 
translated appendices lafont taylor 
gierz hoffman keimel law mislove scott editors 
continuous lattices 
springer verlag berlin heidelberg new york 
gl levi 
unfolding fixpoint semantics concurrent constraint logic programs technical report university 
gms haim gaifman michael maher ehud shapiro 
reactive behavior semantics concurrent constraint logic programs 
north mer logic programming conference 
mit press october 
hmt leon henkin donald monk alfred tarski 
cylindric algebras part 
north holland publishing 
hoa hoare 
theory conjunction concurrency 
oxford prg may 
hoa hoare 
models 
proceedings concur august 
jl jaffar jean louis lassez 
constraint logic programming 
proceedings ct sigplan symposium princi 
pies programming languages pages acm january 
jos mark 
receptive process theory 
technical report programming research group oxford university july 
jp jagadeesan panangaden 
model higher order process cal 
paterson editor seventeenth international colloquium automata languages programming pages 
springer verlag 
lecture notes computer science 
jagadeesan panangaden pingali 
fully semantics functional lan guage logic variables 
proceedings ieee symposium logic computer science pages 
kah kahn 
semantics simple language parallel programming 
rosenfeld editor proceedings ifip congress pages august 
shapiro kahn language fcp 
conference fifth generation computer systems december 
lev giorgio levi 
models unfolding rules fixpoint semantics 
proceedings fifth ternational conference symposium logic programming seattle pages august 
lin gary lindstrom 
functional programming logical variable 
proceedings twelfth acm symposium principles programming languages pages january 
ls lambek scott 
higher order categorical logic volume studies advanced mathematics 
cambridge university press 
mah michael maher 
logic semantics class committed choice programs 
th tern conference logic programming 
mit press may mi milner 
functions processes 
paterson editor seventeenth international colloquium automata languages programming pages 
springer verlag 
lecture notes computer science 
mpw milner parrow walker 
calculus mobile processes 
lfcs report ec lfcs university edinburgh 
makkai reyes 
order logic volume lecture notes mathematics 
springer verlag 
oh 
olderog hoare 
semantics communicating processes 
acts informatica 
plotkin 
powerdomain construction 
siam computing september 
ros 
alternative order failures model 
technical report technical monograph prg programming research group oxford university july 
sar vijay saraswat 
partial correctness semantics cp proceedings conference number pages 
springer verlag december 
sar vijay saraswat 
somewhat logical formulation clp synchronization primitives 
proceedings lp 
mit press august 
sar vijay saraswat 
concurrent constraint pro gramming languages 
phd thesis carnegie mellon university january 
appear doctoral dissertation award logic programming series mit press 
sc dana scott 
data types lattices 
siam sc dana scott 
domains denotational semantics 
proceedings icalp 
vijay saraswat ken kahn jacob levy 
jan step distributed constraint programming 
proceedings north american conference logic programming october 
vijay saraswat prakash panangaden martin rinard 
constraint 
technical report xerox parc forthcoming 
sr vijay sara swat martin rinard 
concurrent constraint programming 
proceedings seventeenth acm symposium principles programming languages san fransisco january 
tar tarski 
logics semantics metamathematics 
oxford university press 
translated 

