engineering simple efficient code generator generator christopher fraser laboratories david hanson princeton university todd proebsting university arizona code generator generators tree pattern matching dynamic programming 
describes simple program generates matchers fast compact easy understand 
simpler common alternatives lines icon lines versus lines twig burg 
matchers run times faster twig necessarily slower burg burs bottom rewrite system matchers flexible practical 
categories subject descriptors programming languages processors code gener ation compilers translator writing systems compiler generators general terms languages additional key words phrases code generation code generator generator dynamic programming icon programming language tree pattern matching 
code generator generators tree pattern matching dynamic programming dp 
accept tree patterns associated costs semantic actions example allocate registers emit object code 
produce tree matchers passes subject tree 
pass bottom finds set patterns cover tree minimum cost 
second pass executes semantic actions associated minimum cost patterns nodes matched 
code generator generators model include beg twig burg 
authors addresses fraser bell laboratories mountain avenue murray hill nj hanson department computer science princeton university princeton nj proebsting department computer science university arizona tucson az 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission association computing machinery 
copy republish requires fee specific permission 
acm acm letters programming languages systems vol 
september pages fraser beg matchers hard coded mirror tree patterns way recursive descent parsers mirror input grammars 
dp compile time identify minimum cost cover 
twig matchers table driven variant string matching essence identifies possible matches time 
algorithm asymptotically better trying possible match time overhead higher 
beg matchers twig matchers dp compile time identify minimum cost cover 
burg uses burs bottom rewrite system theory move dp compile compile time 
burs table generation complicated burs matchers generate optimal code constant time node 
main disadvantage burs costs constants systems delay dp compile time permit costs involve arbitrary computations 
describes program called iburg reads burg specifica tion writes matcher dp compile time 
matcher hard coded technique proved effective types code generators 
iburg built test early versions evolved burg specification language interface useful right simpler easier novices understand allows dynamic cost computation admits larger class tree grammars 
iburg results course compilers 
burg iburg produce robust vax mips sparc code generators lcc retargetable compiler ansi 
iburg beg produce similar matchers describes detail standard beg 
particular describes optimizations paid quantifies strengths weaknesses programs compared programs twig burg 

specifications shows extended bnf grammar burg iburg specifica tions 
grammar symbols displayed italic type terminal symbols displayed typewriter type 
denotes zero instances denotes optional specifications consist declarations separator rules 
declarations declare terminals operators subject trees associate unique positive external symbol number 
nonterminals declared presence left side rules 
start declaration optionally declares nonterminal start symbol 
term denote identifiers terminals nonterminals respectively 
rules define tree patterns fully parenthesized prefix form 
nonterminal denotes tree 
operator fixed arity inferred rules 
chain rule rule pattern nonterminal 
start symbol declared nonterminal defined rule 
acm letters programming languages systems vol 
september 
simple code generator generator grammar dcl rule dcl start identifier integer rule tree integer cost cost integer tree term tree tree term tree term fig 

extended bnf grammar burg iburg specifications 











term addi addrlp term cnsti tl disp reg reg reg addi reg rc reg disp reg reg disp disp addi reg con disp addrlp rc con rc reg con cnsti con fig 
sample burg specification 
rule positive external rule number comes pattern preceded equal sign described external rule numbers report matching auser supplied seman tic action routine 
rules optional nonnegative integer cost omitted costs zero 
shows fragment burg specification vax 
example uses uppercase terminals lowercase nonterminals 
lines declare operators external symbol numbers lines give rules 
external rule numbers correspond line numbers simplify interpreting subsequent figures 
practice numbers usually generated preprocessor accepts richer form specification including yacc style semantic actions emits burg specifica tion :10.1.1.131.282
rules lines nonzero costs 
rules lines chain rules 
acm letters programming languages systems vol 
september 
fraser operators operators lcc intermediate language 
operator names formed concatenating generic operator name character type suffix denote character integer pointer operations respectively 
operators denote integer addition addi forming address local variable addrlp integer assignment integer constant cnsti widening character integer integer fetching character 
rules show addi binary unary addrlp cnsti leaves 

matching versions burg generate functions client calls label reduce subject trees 
labeling function label bottom left right pass subject tree computing rules cover tree minimum cost cover 
node labeled indicate pattern associated external rule matches node cost shows intermediate language tree assignment expres sion fragment inti left child node computes address right child computes address fetches character widens integer adds widened value assigns annotations shows results labeling 
denote labels matches denote labels chain rules 
rule denoted shown 
sums costs nonterminals right hand side cost relevant pattern chain rule 
example pattern line matches node addrlp cost node labeled 
pattern denotes disp chain rule line applies cost matching disp plus chain rule 
likewise chain rules lines apply chain rule line denotes reg 
patterns specify subtrees immediate children 
example pattern line refers grandchild node 
separate pattern matches node line pattern covers node 
cost cost matching addrlp disp rule plus 
nodes annotated previous matches nonterminal left hand side rule example addi node matches disp pattern line means matches rules disp right hand side line 
transitivity matches chain rules lines 
chain rules yield cost better previous matches nonterminals 
labeled subject tree reduced traversing top acm letters programming languages systems vol 
september 
simple efficient code generator generator disp addrlp disp reg disp re addi rc reg ii rc reg rc reg reg vci disp reg rc reg lw ito disp addi re con con cnsti rc cm addrlp lm ll disp addrlp reg disp reg rw fig 

intermediate language tree 
performing appropriate semantic actions generating emitting code 
supplied clients burg generates functions assist traversals example function returns identifies subtrees recursive visits 
elaborates :10.1.1.131.282
burg dp compile compile time annotates node single integral state number encodes information concern ing matches costs 
iburg dp compile time annotates nodes data equivalent 
state numbers really pointers records hold data 
versions burg generate implementation label accesses node fields client supplied macros functions uses nonrecursive function state identify matches int label type int label left child int label right child return state label state op label return type typedef macro defines data type nodes 
op label left 
child right child macros functions return respectively node external symbol number left child right child 
state label macro accesses node state number field 
state accepts external symbol number node state numbers node left right children 
returns state number assign node 
unary operators leaves ignores arguments respectively 
acm letters programming systems vol 
september 
fraser 
implementation iburg generates state function uses straightforward implementation tree pattern matching 
generates hard code tables 
state numbers pointers state records hold vectors values successful matches 
state record specification struct state int op struct state left right short cost short rule iburg generates integer codes nonterminals index cost rule vectors define stmt nt define disp nt define rc nt define reg nt define con nt convention start nonterminal value 
state records cleared allocated external rule numbers positive 
nonzero value rule indicates node matched rule defines nonterminal shows implementation state gives cases contributed lines 
state allocates initializes new state record switches external symbol number matching 
nonleaf case statements test match consulting state records descendants 
switch necessary testing leaves 
match succeeds resulting cost computed record called pointer state record code matching nonterminal cost matching external rule number void record struct state int nt int cost int cost cost cost cost rule match recorded cost previous matches 
elements cost vector initialized represent infinite cost match recorded 
call record match calls chain rules 
example second statement addi case tests node matches pattern line 
call record records node matches disp 
chain rule line says acm letters programming languages systems vol 
september 
simple efficient code generator generator int state int op int left int right int struct state struct state left malloc sizeof struct state right op op left right rule 
cost 
switch op case addi break case addrlp rule reg rule rc nt cost reg nt cost rc nt record reg nt record rc nt record stmt nt rule reg iit kk rule con cost reg nt cost con nt record disp nt record reg nt record rc nt record stmt nt record disp nt record reg nt record rc nt record stmt nt break case 
op left rule disp nt break return int left cost disp nt record reg nt record rc nt record stmt nt fig 

implementation state 
acm letters programming languages systems vol 
september 
fraser node matching disp matches reg additional cost gives rise second record call 
likewise calls record due chain rules lines say node matching reg matches rc additional cost general call record transitive closure chain rules reach nonterminal defined match 

improvements generated matcher described previous section practical code generation applications generator easy implement 
students replicated version emits code shown couple weeks 
iburg implements simple improvements generated matchers smaller faster 
im iburg takes lines icon 
short elements rule vector accommodate external rule number nonterminals defined rules 
exam ple lines define disp bits needed record positive values 
definitions mapped compact range integers stored minimum space state records bit fields example struct state int op struct state left right short cost struct unsigned int stmt unsigned int disp unsigned int rc unsigned int reg unsigned int com rule external rule numbers matches retrieved calling rule state number goal nonterminal :10.1.1.131.282
iburg generates implementation rule uses tables map integers compact representation external rule numbers example short decode disp short decode rc short decode stmt short decode reg short decode con int rule int state int struct state struct state state switch case disp nt return decode 
disp rule 
disp case rc nt 
return decode rc rule rc acm letters programming languages systems vol 
september simple efficient code generator generator case stmt nt return decode stmt rule 
case reg ne return decode reg rule reg case con nt return decode con rule 
con packed rule numbers subscripted record code tests match changed 
scheme save space large specifications 
example vax specification nonterminals encoding scheme reduces size rule vector bytes 
packing rule numbers save time takes longer read write decode packed rule numbers smaller structure initialized faster single structure copy 
original vax matcher initial ized rule assignments structure copy slower 
packed fields assignments slower byte structure copy beats original assignments margin costs packed fields 
initialization costs reduced costs set rule field start symbol needs initialization 
rule fields read places rule function tests match 
rule function called top tree traversal begins start symbol goal nonterminal 
finds initializer zero rule number tree failed match fields examined anyway 
match tests require rule tion 
read rule fields descendants read garbage descendants failed match costs infinite prevent recording false match 
improved initializer packing rule numbers longer saves time saves space time cost small measured 
record improved 
cost test record fails tests calls record implement chain rules fail costs increase monotonically 
calls avoided cost test fails 
inlining record accommodates improvement packed rules 
example second statement addi case rule reg rule 
con cost reg nt cost con nt cost disp nt disp addi reg con cost disp nt rule disp closure disp le disp set decode disp maps external rule 
code shows compact approach handling chain rules 
nonterminal reached chain rules iburg generates acm letters programming languages systems vol 
september 
fraser closure records chain rule match cost better previous matches applicable calls closure function 
exam ple closure function disp void closure disp struct state int cost reg nt reg disp cost reg rule reg closure reg incoming cost cost matching right hand side chain rule 
cost plus cost chain rule example line reg disp cost application chain rule sum passed closure function 
closure reg handles chain rules reg lines void closure reg struct state int cost rc nt rc reg cost rc rule rc cost stmt nt stmti reg cost stmt nt rule stmt final improvement saves times leaves abound subject trees code generators 
computation encoding state record data matches compile compile time complicated 
leaves match contents state record easily computed simulating effect assignments closure function calls shown 
state records leaves allocated initialized compile compile time example addrlp case case addrlp 
static struct state reg 
disp addrlp reg disp reg 
disp rc reg addrlp reg disp return int acm letters programming languages systems vol 
september simple efficient code generator generator table improvements iburg matcher icc matcher size size time time version original untuned version inline record add closure routines initialize element rule precompute leaf states pack rule numbers values initialize op left right fields state structure 
brace enclosed initializers cost rule values respectively 
code state see allocates initializes state record needed leaves protected test excludes leaf ops 
table traces addition improvement 
column shows number lines icon iburg helps quantify implementa tion cost 
second column shows number object bytes resulting matcher 
third column times lcc typical cross compilation vax mips processor 
fourth column shows time spent state rule routines 
times seconds 
specifications risc machines show smaller improvements 
closure routines save space implement chain rules place multiple record runs 
initialization improve ment measured trial trivial implement save 
hand packing rule numbers cost time cost appears small cuts size state structure half 
proposed improvements proved 
closure rou inlined measurements showed matcher faster larger initial version 
independently closure routines recoded avoid tail recursion speedup measured 
recoding replaced closure routine case switch state ment switch bound check added unnecessary overhead possible compiler implementation tail recursion better large speedups 
processing done iburg straightforward 
example parsing input writing output account lines respectively line final version 
way comparison new version iburg written lines burg processor lines 

discussion iburg built test early versions evolved burg specification language interface 
initial tests twig twig preprocessor twig produced incorrect matchers large cisc grammars 
error proved hard find twig abandoned iburg written 
acm letters programming languages systems vol 
september 
fraser table times compiling programs spec benchmarks benchmark iburg iburg ool gcc espresso li eqntott initial version completed days lines icon 
final student proof version full burg compatible debugging support lines 
matchers generated iburg slower burg 
table ii shows times compiling programs spec benchmarks versions lcc 
times running compiler proper preprocessing assembly linking time included 
compilations done iris mb running irix times elapsed time seconds lowest elapsed times runs lightly loaded machine 
reported runs achieved percent utilization ratio times user system elapsed 
differences compilation times due entirely differences performance matchers 
profiling shows execution time iburg rule nearly identical burg rule 
inputs iburg matcher accounts percent execution time burg accounts 
percent making burg roughly times faster 
comparable figures twig unavailable correctly process large grammars twig abandoned measurements taken 
nearly complete vax grammar lcc compiled line module twig matcher matcher initial iburg spent twig matcher iburg matcher 
partial mips grammar icc compiled module twig matcher matcher initial iburg spent twig matcher iburg matcher 
versions icc naive emitter slowed complex grammars vax compiler slower 
figures paragraph useful comparing twig iburg naive emitter useless comparisons 
disadvantage burs matchers costs constant dp done compile compile time 
costs twig specifications involve arbitrary computation depend context 
example pattern disp cnsti specifies clear instruction constant twig cost computations inspect subject tree return cost say constant infinity 
acm letters programming languages systems vol 
september simple efficient code generator generator burs specifications handle kind context sensitivity addi tional operators identify special cases 
example calling state lcc labeling pass changes cnsti constant disp specifies clear instruction 
context sensitive cases arise code generation cisc machines handled similarly additional rules 
example recognizing vax indexed addressing mode takes rules lcc specification 
iburg easily extended predicates specified tested matching begs conditions rml iburg useful development 
generated state label functions easy read debug 
mirror specifica tion way code recursive descent parser mirrors ll grammar 
attribute iburg ideal teaching 
course previously twig students prefer iburg 
students inevitable mistakes table driven matcher twig burg numbers table available debugger 
mistakes iburg node explicitly records matching rules costs nonterminal users easily compare matcher actual operation expectations 
acknowledgments section borrows parts written robert henry :10.1.1.131.282
version iburg available anonymous ftp ftp cs prince ton edu pub 
authors note section notes cost tests unnecessary initialize rule fields 
beg carried observation step 
tests outer statement improved addi case section need test rule fields cost tests lce 
statements necessary embedded terminals test rule line 
improvement added iburg 
trials quantify improvement probably saves easier read 

aho efficient string matching aid bibliographic search 
commun 
acm june 

aho johnson optimal code generation expression trees 
acm july 

aho ganapathi tjiang code generation tree matching dynamic programming 
acm trans 
program 
lang 
syst 
oct 

aho sethi ullman compilers principles techniques tools 
addison wesley reading mass 
acm letters programming languages systems vol 
september 
fraser 
balachandran dhamdhere biswas efficient retargetable code generation bottom tree pattern matching 

lang 


chase improvement bottom tree pattern matching 
conference record acm symposium principles programming languages munich germany jan 
acm new york 

landwehr beg generator efficient back ends 
proceedings sigplan conference programming language implementation 
sigplan 
acm july 

ferdinand seidl wilhelm tree automata code selection 
code generation concepts tools 
techniques proceedings international workshop code generation dagstuhl germany giegerich graham eds 
springer verlag new york 

fraser language writing code generators 
proceedings sigplan conference programming language design implementation 
sigplan 
acm july 

fraser hanson code generation interface ansi softw 
pratt 
exper 
sept 

fraser hanson retargetable compiler ansi sigplan 
acm oct 

fraser henry hard coding bottom code generation tables save time space 
softw 
pratt 
exper 
jan 

fraser henry proebsting burg fast optimal instruction selection tree parsing 
sigplan 
acm apr 

griswold griswold icon programming language 
nd ed 
prentice hall englewood cliffs 

hoffman donnell pattern matching trees 
acm jan 

tree transformation compiler systems 
ph thesis computer science division dept electrical engineering computer science univ california berkeley calif dec 

graham optimal code generation expression trees application burs theory 
conference record acm programming languages san diego calif jan 
acm new york pp 


proebsting simple efficient burs table generation 
proceedings sigplan conference programming language design implementation 
sigplan 
acm june 

spec benchmark suite release 
standards performance evaluation oct 
received october revised accepted january acm letters programming languages systems vol 
september 
