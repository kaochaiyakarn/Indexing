automatically generating high quality user interfaces appliances jeffrey nichols december cmu human computer interaction institute school computer science carnegie mellon university pittsburgh pennsylvania thesis committee brad myers chair scott hudson john zimmerman dan olsen jr brigham young university submitted partial fulfillment requirements degree doctor philosophy copyright jeffrey nichols 
rights reserved 
research supported part national science foundation author graduate research fellowship iis iis microsoft general motors pittsburgh digital greenhouse intel 
equipment supporting research generously donated mitsubishi electric research laboratories ibm canada symbol technologies hewlett packard lucent 
views contained author interpreted necessarily representing official policies endorsements expressed implied sponsoring party government 
keywords automatic interface generation aggregate user interfaces handheld computers personal digital assistants mobile phones home theater appliances personal universal controller puc user interface description languages remote controls multi modal interfaces speech recognition smart templates user interface consistency personal consistency familiarity ii automatically generating high quality user interfaces appliances jeffrey nichols iii iv dissertation show appliance usability problems addressed moving user interface appliance handheld device user carrying personal digital assistant pda mobile phone 
approach called personal universal controller puc takes advantage increasing pervasiveness wireless communication technologies allow handheld devices communicate directly appliances 
automatic generation appliance user interface allows puc create interfaces customized platform controller device user previous experience appliances user current environment 
dissertation contributions state art automatic interface generation automatic generation dependency information determine better structure generated user interfaces 
general smart templates technique incorporating domain specific design conventions appliance specification automatically rendering conventions appropriately different platforms different interface modalities algorithms apply knowledge similarity specifications interfaces user previously seen generate new interfaces personally consistent algorithms model content flow appliances generate interfaces combine functionality multiple appliances evaluation puc system compared automatically generated interfaces printers manufacturer interfaces appliances users automatically generated interfaces twice fast times successful common complex tasks 
evaluation shows puc consistency features allow users twice fast new appliance similar appliance previously encountered 
evaluation known user study automatically generated interfaces compared human designs shows automatic generation user interfaces users viable interactive systems 
vi parents vii viii table contents list figures xvii list tables personal universal controller 
outside scope 
contributions 
dissertation overview 
related control appliances 
commercial products 
commercial standards 
standard 
universal plug play 
digital living network alliance 
home audio video interoperability 
jini 
osgi 
research systems 
universal interactor 
ibm universal information appliance 

xweb 
ubiquitous interactor 
ix analyses actual remote control usage 


automatic guided user interface design 
early model systems 

jade 
uide 
humanoid 
mastermind 

trident 
model systems large interfaces platform independence mobi 
concurtasktrees 

ibm pima 
uiml tide 
teresa 

xul 
supple 
aggregate user interfaces 
preliminary user studies hand designed user interfaces 
user studies 
procedure 
evaluation 
study 
participants 
results 
discussion 
study 
participants 
results 
discussion 
analysis interfaces 
requirements 
way communication 
simultaneous multiple controllers 
specific layout information 
hierarchical grouping 
actions state variables commands 
dependency information 
sufficient labels 
shared high level semantic knowledge 
system implementation architecture 
controlling appliances 
generating interfaces controller devices 
pocketpc desktop implementation 
smartphone implementation 
communication 
specification language design principles 
language design 
functional language elements 
xi appliance objects 
type information 
label information 
group tree 
complex data structures 
dependency information 
smart templates 
content flow language elements 
ports 
internal flows sources sinks 
evaluation specification language 
completeness 
learnability ease 
consistency understanding consistency 
evaluating consistency 
applying consistency 
specification authoring study 
study 
study 
discussion 
requirements consistency 
understanding finding similarities specifications 
knowledge base 
mapping graphs 
automatically finding mappings 
handling domain specific conventional knowledge roles 
xii design 
implementing smart template interface generator 
smart template library 
discussion 
interface generation generation platforms 
pocketpc desktop 
smartphone 
speech 
general concepts 
generating interface 
mutual exclusive dependency information 
choosing interaction objects 
modifying interface consistency 
heuristics unique functions 
functional modifications 
structural modifications 
moving 
re ordering 
generating concrete interface 
pocketpc desktop 
creating initial interface 
fixing layout problems 
smartphone 
modifying concrete interface consistency 
results discussion 
aggregating user interfaces scenarios 
xiii content flow understanding systems appliances 
aggregation architecture 
flow interface 
aggregate user interfaces 
active flow controls 
active flow setup 
general setup 
merging controls 
discussion 
usability evaluation interfaces 
protocol 
tasks 
participants 
evaluation usability 
results 
discussion usability 
evaluation consistency 
results 
discussion consistency 
discussion 
discussion 
impact 
contributions 

final remarks 
xiv sample vcr specification specification language xml schema 
element index 
element descriptions 
puc xml language schemas communication protocol schema 
knowledge base schema 
multi appliance wiring diagram schema 
specification authoring study instructions usability study instructions gallery puc interfaces bibliography 
xv xvi list figures 








physical interfaces different appliances copier functionality canon np office copy machine canon mp photo printer hewlett packard printer 
appliances fax special photo printing capabilities 
interfaces generated puc pocketpc different appliances windows media player navigation system gmc denali canon mp printer hp printer 
interfaces generated puc smartphone different appliances windows media player simulated elevator shelf stereo cd radio tape functionality full pocketpc interface generated navigation system gmc denali 
arrows show buttons cause dialog box open copier interfaces generated consistency pocketpc platform copier interfaces generated consistency smartphone platform 
examples flow interface various tasks playing dvd movie video shown television audio coming stereo speakers watching sporting event television listening play radio selecting different sources content presentation powerpoint current source resolving problem dvd player question answer interface 
examples aggregate user interfaces generated user current task playing dvd movie video shown television audio coming stereo speakers presenting powerpoint slides projector watching broadcast television audio playing television speakers recording tape vcr tape playing vcr philips tsu remote control device xvii 


harmony remote control devices models left right 
interface generated winamp pocketpc framework 
reproduced permission 
examples interfaces classroom controller generated supple different devices standard desktop computer mouse touchscreen 
classroom sets lights variable brightness system lcd projector corresponding screen gajos 
reproduced permission 
cx shelf stereo remote control office telephone digital answering machine studies 


prototypes phone stereo interfaces palm 
screenshots implemented phone stereo interfaces pocketpc 
box plots showing range help requests uses external help appliance interface type 
box plots results second user study 

diagram puc system architecture showing communication different components 



interface puc debug server 
main window showing appliances currently simulated server 
interface simulating philips dvd player automatically generated debug server 
screenshots menu interface pocketpc puc interface generator 
desktop interface generator similar menu structure 
backgrounds screenshots show logging panel messages interface generator displayed 
screenshots interfaces smartphone interface generator showing menu interface custom controls built smartphone 

message format puc communication protocol 

examples state variable representing current channel tuned vcr command tape currently vcr 
xviii 
label dictionary playback controls group vcr 
dictionary contains textual labels text speech information 
group tree sample vcr specification 









example list group vcr specification describe list timed recordings may specified user example common type dependency equation specifying variable command available appliance power turned ports section example vcr specification description video tape source content flow example vcr specification 
note dependencies content groups contain source flow anded source dependencies 
vcrs study 
panasonic vcr second study example mapping graph media control functions play pause appliances 
node counts indicate panasonic vcr basis consistency times answering machine dvd player cheap vcr basis consistency just 
answering machine dvd player generated consistent panasonic vcr counts zero diagram showing different roles creation implementation smart template context interface generation process specification snippets showing instantiations different smart templates 
instantiation media controls template play controls windows media player 
instantiation time duration template counter function sony dv camcorder 
instantiation time duration template song length function windows media player 
renders media controls smart template different platforms different appliances 
media controls rendered smart templates disabled windows media player interface pocketpc platform 
media controls rendered interface smart templates enabled xix 
platforms 
top desktop middle pocketpc bottom shows smartphone 
smartphone control maintains consistency user copying layout smartphone version windows media player media player application find platform 
interface overloads pause play button 
different configurations media playback controls automatically generated different appliances screenshots smart templates rendered part gmc denali navigation system pocketpc platform 
demonstrates time absolute smart template clock function 
hour option template changes way time rendered interface seen clock top screenshots 
demonstrates list commands templates integrated puc list controls 
commands adding deleting items located underneath list control edit button part list control 
move commands integrated list control arrow buttons located top selected list item 
demonstrates address template capability integrating pocketpc builtin outlook contact database 
leftmost screen shows interface user pressed select contact button 
pressing button shows middle screen allows user select contact database 
pressing ok dialog causes selected information filled appropriately fields template rightmost screen 

icons currently supported puc status icons smart template 



interface windows media player generated pocketpc 
full interface generated gmc denali driver information console 
smartphone displaying puc interface windows media player automatically generated interface driver information center gmc denali 
user navigates list panes get summary editing panes example interaction speech interface control shelf stereo lighting 

puc interface generation process diagram xx 




demonstration changes tree structure mutual exclusion 
circles represent nodes interface structure represent groups state variables commands 
tree node marked represents state variable values 
node marked parent group 
formulas shown remaining groups show dependencies group variable node dependent tree new mutual exclusion group added contains state variable child groups set mutually exclusive groups 
nodes dependent moved group parent outside mutex group 
containment stacks previous specification mitsubishi new specification samsung dvd vcr results consecutive movements 
shows movement clock group shows rule chains movement clock channel state user interfaces generated desktop puc mitsubishi samsung dvd vcr consistency dvd vcr generated consistent mitsubishi 
note clock functions located status tab mitsubishi setup samsung dvd vcr new status tab consistent interface 
note controls timed recordings located vcr tab samsung dvd vcr 
demonstration bring split dependents rule 
top image shows location resize mode function bottom shows location repeat image function parameters 
column dialog box shown bottom opened pressing repeat image button shown top image 
block lists created timed recordings groups mitsubishi samsung dvd vcr 
vcr type unmapped blocks block lists 
screenshots hp printer interface demonstrating mutual exclusion rules 
special power screen generated second rule 
remaining shots power view 
fax mode printer 
mode accessed tabs bottom screen created rule 
tab seen screen shots copy xxi mode printer resize options set zoom 
resize options state mode different options created third rule 
view copy mode resize options set poster size 
interface generated gmc denali driver information console layout fixing rules rotated fit better page 
high level structure user interface underlying panel shown interface 

example screens automatically generated smartphone interfaces 
opening screen controlling shelf stereo 
dependency information rule created separate lists cd radio screens simulated elevator interface 
particular screen shown user depends user outside inside elevator car 
smartphone rendering smart template interface controlling windows media player application desktop computer 
template design smartphone windows media player application operated right left select buttons phone thumb stick 

diagrams showing second rules optimizing list structure behave 
black solid arrows indicate screens connected red dashed lines indicate changes rules 
note items list promoted top level list placed panel 
items happen labels panel summary pane 
interfaces generated hp canon printers demonstrating effects concrete interface re ordering rule 
note difference order black color cancel buttons 



configuration appliances multi appliance system scenarios home theater presentation room architecture aggregate interface generation features example flow interface configure dvd player play video television audio routed stereo speakers 
active flow control interfaces playing dvd movie video shown television audio coming stereo speakers presenting powerpoint slides projector 


watching broadcast television audio playing television speakers watching broadcast television audio playing receiver speakers 
note volume control appear controlling different appliances 
shots active flow setup aui dvd player receiver television flow 
note interface organized appliance shown tabs bottom screen shots general setup aui home theater setup 
note shots tabs bottom screen represent high level concepts functions organized appliance combo boxes top 
merged function aui featuring clock language sleep timer functions single panel 
pocketpc interfaces generated personal universal controller puc printers discussed 
printers studies larger view built user interface 

results block tasks showing built condition compared appliance 
results second block tasks showing autogen condition compared consistent autogen condition appliance 

puc control character augmented reality application part performed puc technical university vienna 
tracked pocketpc multi purpose interaction device left tangible interface screenshot ar lego application right pda screen capture lego robot control gui 
reproduced permission 
cards specify reminder frequency setting 
cards attached clip 
xml code reminder frequency state variable 

group list parameters card describe list 
list state variable members shown 
xml code describing list 
state variable defined appears code xxiii 
object state variable type cards category state variable contained list group 
note type state variable type card 
xml code category state variable contained list group 
note list selection type variable 
object cards describe add remove commands list 
objects contained group tagged list commands smart template 
xml code describing add remove commands list 
note group contains items 
note dependencies provided delete command 
discussed dependency information section 

dependency card delete command 
note extended names state variables 
may find necessary go back names explicit dependency cards organized variables specification 
list tables table 
appliance adaptors built puc research team table 
appliance simulators built puc research team table 
messages may sent controller device table 
messages may sent appliance controller device 
table 
table 
complete list appliance specifications authored puc research team maximum average counts various aspects puc specifications written date 
table 
mapping types consistency puc system 
table 
description implemented smart templates puc system 
table 
puc functional consistency rules 
table 
consistency moving rules implemented puc 
table 
row layouts supported pocketpc interface generator 
table 
layout fixing rules pocketpc interface generator table 
average completion time total failure data block tasks 
puc condition combination autogen consistent autogen conditions 
built condition puc condition 
indicates significant difference built puc conditions appliance indicates marginally significant difference 
completion times total failures compared way analysis variance failures task compared fisher exact test 
table 
average completion time total failure data second block tasks 
conditions 
indicates significant difference row condition consistent autogen condition appliance indicates marginally significant difference 
completion times total failures compared way analysis variance failures task compared tailed fisher exact test 
people touched life helped find direction kept path finishing thesis 
tried acknowledge people apologies accidentally forgotten 
brad myers guidance advice time carnegie mellon 
brad taught research results clear understandable fashion 
am busiest brad able find time read papers give enormous amount feedback content 
hope half successful researcher mentor career brad 
members thesis committee scott hudson john zimmerman dan olsen providing invaluable comments way shaped direction 
scott hudson efforts organizing ph program putting student feedback brought time student 
scott willing help address problems think program half strong presence 
lucky assistance great individuals course puc project 
particular brandon assisting aspects system implementation chau helping design interface evaluation puc interfaces discussed chapter kevin building adaptors real world appliances helping find problems early version specification language michael higgins joseph hughes maya design helping initial design specification language initial puc server side infrastructure 
thomas harris stefanie roni rosenfeld adopting puc technologies basis speech interface generator 
rajesh shen contributions developing language documentation writing specifications building appliance adaptors 
am equally indebted corporate government sponsors generously funded research provided equipment national science foundation pittsburgh digital greenhouse microsoft general motors intel mitsubishi electric research labs 
influenced including students brad students ph program students faculty doing related universities 
daniel laura james fogarty darren andy ko tan luis von ahn jake gregory abowd ankolekar ryan baker gaetano borriello anind dey jodi krzysztof gajos gary hsieh pedram johnny lee lee ian li sue connor trevor pering kai richter fleming rachel joe roy want 
parents mick sally sister amy support love guidance 
dedicated thesis parents interest computers young age buying learned basic signing take classes programming paying internet service early people knew 
encouragement interests education general am today 
wonderful girlfriend 
am happy able remain close degree programs forced live apart opposite years am thankful time apart 
supported finished 
xxx chapter day users interact computerized devices home office 
average day microwave oven television dvd player alarm clock stereo home computer tracking speed mileage bike copier fax machine telephone answering machine vending machine cd player school 
count mobile phone wristwatch usually carry count normal computers daily computerized components car built years 
devices different interfaces functions common setting internal clock 
devices functionally similar car stereo home stereo media player computer school vastly different interfaces 
problems encountered users today computerized devices 
users spend time learning device environment similar devices know 
part usability problem today computerized appliances created trade offs manufacturers balance 
produce highly usable appliances appliances reach market timely fashion cheap manufacture new features users want 
declining cost sors allows manufacturers cheaply quickly add computation new features appliances unfortunately cost building high quality user interfaces new features expensive time consuming 
trend appliances get computerized features user interfaces get harder brouwer 
wall street journal reports appliances telephones cameras washing machines microwave getting harder result new epidemic man machine alienation gomes 
solution problems move user interfaces appliances intermediary ui device independent appliance manufacturer focuses solely user interface 
ui device handheld computer microsoft pocketpc mobile phone speech system built walls building 
advantage approach people increasingly carrying mobile device ui device 
devices ability communicate devices environment wireless networking protocols wi fi bluetooth 
furthermore mobile devices built specialized interface hardware color touch sensitive lcd screens creation high quality user interfaces easier 
ui device leverage specialized hardware provide superior user interface compared cost effectively built appliance 
potential approaches moving user interface ui device controller device pre programmed interfaces factory users homes 
advantage approach interfaces specifically controller device appliances control 
today universal remote controls pre programmed codes controlling variety home entertainment appliances taught additional codes appliances programming environments allow users create interfaces 
manufacturer controller device provide interface tedious timeconsuming users program interfaces 
controller device downloads complete user interfaces appliances internet 
approach jini sun newman advantage controller device need know advance chapter appliance control 
appliance able provide interfaces different controller devices encounter standard graphical interface touch screens normal desktops interface phones speech interface devices built speech recognizer 
controller devices unique designs watch circular screen dials interaction difficult support approach practical appliance manufacturers produce new interfaces appliances time new handheld device released 
today web technologies seen approach pages carefully designed support large resolution screens render appropriately small devices mobile phones 
controller device downloads specifications appliances uses specifications automatically generate interface customized controller particular design properties user user environment 
important specification support creation interfaces different platforms different modalities contain information appliance order create high quality user interface 
advantage approach controller devices appliances need know advance ensure interfaces usable 
advantage external factors taken account design interface user previous experience functionality connected appliances 
automatic generation user interfaces difficult believe approach promising separates creation user interface manufacturers appliances controller devices 
gives ui devices greater opportunity improve usability current appliance interfaces approaches 
technical focus dissertation automatic generation user interfaces users 
researchers exploring automatic generation user interfaces nearly decades relies interaction designer guide generation process edit resulting user interfaces fix design flaws szekely 
believe users ui device willing spend time effort modify automatically generated interfaces way ui device need generate high quality user interfaces attempt 
chapter previous automatic interface generation focused large part building user interfaces desktop applications task trained human designers produce higher quality artifacts current automated system 
interfaces generated system approach quality human designers focus applying automatic generation techniques create interfaces practical human designer produce 
example automated system produce custom interface individual user human designers limited designing interfaces large user groups 
previous examined interfaces generated multiple platforms model szekely eisenstein exploration automatic generation customize interfaces individual user particular environment situation 
important question ask specific ways ui devices automatic interface generation improve usability appliances 
answer question discuss usability problems approach address 
biggest problems appliance user interfaces large number functions appliances coupled limited number interactive physical elements buttons screens built computerized appliance 
address problem appliances overlap functions button 
example telephone answering machine pressing releasing play button play messages pressing play button holding play new messages 
limited size display screens means appliances rely cryptic messages audio cues give feedback user 
example answering machine beeps notify user speed dial number successfully programmed beeps twice programming failed 
ui devices able address problems reasons 
ui devices afford screens larger higher resolution screens appliances 
screens render lines time allows better explanations error conditions feedback appliance state 
ui device built infrastructure supporting development rendering complex user interfaces 
typically includes toolkit supports creation screen virtual controls buttons sliders set ui guidelines govern interface look feel 
built infrastructure ui device ensure appliance function represented separate control prevent functional overlap chapter appliances hard 
automatic interface generator interfaces easier ui guidelines device allowing users leverage knowledge conventions ui device applications 
usability problem appliances arises multiple appliances system home theater presentation room 
order accomplish tasks users understand appliance individually manipulate appliances properly 
troubleshooting problems occur difficult user determine appliances configured correctly 
common users mistakenly believe problem lies appliance working correctly troubleshooting time users 
interface problems occur reasons user interfaces appliance designed separately cues appliance interface affect operation appliances task performed system appliance functions relevant performing task 
functions important tasks may interfere users progress current task 
ui device automatically generates interfaces address problem account appliances connected 
ui device combine user interfaces multiple appliances single interface customized user task ui device knows task user trying perform appliances perform task 
obtain information developed novel solution observation tasks system appliances involve flow content source appliance sink appliance possibly passing appliances way 
example task playing dvd movie home theater viewed configuring appliances allow content dvd player flow television speakers 
developed scaleable modeling technique content flow information available ui device flow interface concept allow users directly specify high level task perform 
ai planner automatically configure system perform tasks users specify interfaces generated currently active content flows 
advances interface generation automatically generate interfaces combine functionality different sources 
chapter problem users inconsistency similar appliances different manufacturers 
example shows interfaces appliances share similar capabilities 
notice appliances share physical elements number pad screen user interfaces appliances quite different 
methods interaction different office copier see uses large touch screen appliances expensive afford luxury physical buttons navigating menus displayed smaller screens 
labels differ brightness function labeled darkness hp printer exposure canon printer light dark office copier 
organization functions different appliances 
example date time set hp printer fax configuration screen accessed general setup screen appliances 
lack consistency interfaces prevents user familiar appliances leveraging knowledge appliances 

physical interfaces different appliances copier functionality canon np office copy machine canon mp photo printer hewlett packard printer 
appliances fax special photo printing capabilities 
chapter ui devices unique position ensure consistent experience users devices controlling appliances track interfaces users see 
knowledge combined information showing new interface similar previous interfaces automatically generate new interfaces controls labels organization familiar user 
new interfaces personally consistent user previous experiences 
different users may receive different generated interfaces new appliance previous experiences different 
demonstrate automatic generation system ensure consistency generated interfaces consistency valuable practice 
personal universal controller explored ideas system call personal universal controller puc enables ui devices constructed supports automatic generation user interfaces 
generation user interfaces enabled puc specification language allows appliance describe functions way 
goal designing language include information generate high quality user interface include specific information look feel 
decisions look feel left interface generator 
specifications written real appliances puc language see full list table 
specifications describe complete functionality appliances today called universal remote controls typically support common subset appliance functionality 
authoring study specification language subjects previous knowledge learn language produce specification moderate size lowcost vcr 
subjects able learn language average hours produce vcr specification hours 
interface generators implemented produce user interfaces specifications written puc language including graphical interface generators pocketpc microsoft smartphone desktop computers speech interface generator uses universal speech interfaces framework rosenfeld 
graphical interface generators pocketpc smartphone cover different interface styles 
chapter 
interfaces generated puc pocketpc different appliances windows media player navigation system gmc denali canon mp printer hp printer 
pocketpc medium sized touchscreen allows interactions similar desktop computer smaller screen area see 
smartphone small screen touch sensitivity way joystick navigating interface 
result smartphone interfaces list typically deeper hierarchy pocketpc interfaces see 
interface generators tested variety complex appliance specifications including vcrs hp canon printers mentioned navigation system gmc denali 
specification navigation system especially complex easily handled pocketpc interface generator see 
evaluated usability generated interfaces comparing puc produced interfaces hp canon printers see manufacturers interfaces actual appliances see bc 
comparison showed subjects average twice fast times successful puc interfaces complete set representative tasks 
interface generators produce interfaces personally consistent user previous experiences 
new interface generated appliance functionality similar previous appliance user seen interface generator uses special algorithms ensure similar functions represented way placed location 
difficulty generating consistent interfaces chapter 
interfaces generated puc smartphone different appliances windows media player simulated elevator shelf stereo cd radio tape functionality 

full pocketpc interface generated navigation system gmc denali 
arrows show buttons cause dialog box open 
chapter complex copier consistency simple copier consistency complex copier consistent simple copier simple copier consistent complex copier 
copier interfaces generated consistency pocketpc platform 
complex copier consistency simple copier consistency complex copier consistent simple copier simple copier consistent complex copier 
copier interfaces generated consistency smartphone platform 
chapter appliances may share similar functions unique functions included user interfaces 
developed techniques preserving usability unique functions changes consistency 
examples interfaces generated consistency shown pocketpc smartphone 
notice differences original interfaces complex simple 
visual organization interfaces different pocketpc structural organization differs smartphone 
labels quite different start complex copier copy cancel simple copier 
functions located differently interfaces sided copying function located quantity function complex copier sorting functions simple copier 
unique functions function complex copier book copy function simple copier 
note consistent interfaces address differences disrupting usability unique functions 
conducted evaluation rules generating consistent interfaces hp canon printer appliances 
study users knowledge appliance asked perform set tasks puc interface appliances 
tasks users instructed correct method performing task interface asked complete tasks puc interface printer appliance 
second interface generated normally consistency generated consistent interface 
users twice fast average performing tasks second interface interface generated consistent compared users normally generated interface 
interface generator produce user interfaces systems multiple connected appliances home presentation rooms 
interfaces generated full content flow model appliance system assembled appliance specification wiring diagram system supplied third party wiring technology user 
puc provides types interfaces interacting system appliances flow interface allows users specify high level tasks see aggregate interfaces combine functions multiple appliances allow users perform low level actions task see 
chapter puc system produces different kinds aggregate user interfaces 
active flow control interfaces provide access common control functions currently active flows volume controls 
shows example type aggregate user interface 
active flow setup interface provide access common configuration features currently active flows brightness contrast television speaker balance receiver 
general setup aggregate interface contains setup configuration options relate flow parental control settings appliances 
similar functionality multiple appliances 
examples flow interface various tasks playing dvd movie video shown television audio coming stereo speakers watching sporting event television listening play play radio selecting different sources content presentation powerpoint current source resolving problem dvd player question answer interface 

examples aggregate user interfaces generated user current task playing dvd movie video shown television audio coming stereo speakers presenting powerpoint slides projector watching broadcast television audio playing television speakers recording tape vcr tape playing vcr 
chapter merged single interface control certain functions clock language settings 
merged aggregate interface allows user set current time example value migrated automatically appliance system 
order demonstrate feasibility puc system ensure puc supports complexities today computerized appliances thought important puc control real appliances 
accomplish puc system communication protocol allow handheld devices interact appliances set appliances adaptors translate puc protocol proprietary protocols existing appliances 
puc currently able control existing appliances see table error 
source 
complete list easy increase number appliances built support external control 
outside scope puc system taken directions 
section describes issues related puc system explore dissertation help systems users encounter problems automatically generated interface able access help information generated properties interface 
automated help systems created past system uide environment sukaviriya 
automated trouble shooting complex systems functionality complex system home theater system described previous section depends component pieces connected 
example video performance bad dvd player connected vcr may possible record video vcr connected properly 
puc system sufficient information reason problems conceivably help users find solutions particular systems looked part thesis 
service discovery puc controller device able discover appliances environment user may wish control 
efficiently performing task centralized servers focus research projects techniques common included commercial systems upnp upnp chapter jini sun 
puc system relies existing techniques research 
user programming macros facilitating user programming tasks creation user specified macros interesting direction puc research 
area unique puc system exploring user programming contexts 
am confident advances applicable puc system 
security security important issue systems puc 
users keep people driving street maliciously controlling kitchen appliances 
lot interesting done area chosen address thesis 
contributions thesis system automatically generate user interfaces multiple platforms remotely controlling appliances user performance better manufacturer interfaces appliances 
conducted evaluations interface generators demonstrate thesis holds discussed detail chapter 
dissertation number contributions appliance specification language describing complete functionality wide range appliances dependency formulas appliance specifications help determine structure generated user interfaces general smart templates technique incorporating domain specific design conventions appliance specification rendering conventions appropriately different platforms different interface modalities language describing semantic similarities appliance specifications algorithms apply knowledge appliance similarities user history generate new interfaces consistent previous interfaces user seen chapter flow interface concept allows users quickly easily specify high level goals multi appliance system algorithms model content flow multi appliance system generate interfaces combine functionality multiple appliances interface generation software multiple platforms pocketpc microsoft smartphone desktop computers contributions produce appliance interfaces demonstrated user testing usable manufacturers interfaces appliances 
dissertation overview chapter chapter surveys related 
remainder dissertation describes different components puc system building description interface generation process chapters usability evaluation generated interfaces chapter 
chapter describes preliminary studies appliance user interfaces set groundwork design specification language interface generator 
particular importance chapter list requirements system intends control appliances 
chapter discusses general architecture puc system infrastructure needed communicating controlling real appliances 
chapter describes specification language discusses completeness usability 
chapter discusses consistency including previous area consistency means puc system 
chapter covers infrastructure needed generating consistent interfaces including knowledge base stores similarity mappings specifications maintains history interfaces user seen 
chapter describes smart templates technique allows domain specific design conventions included automatically generated interfaces 
puc interface generation process split chapters 
chapter describes process single appliance user interfaces pocketpc desktop smartphone plat chapter forms 
chapter covers generation aggregate interfaces multi appliance systems puc novel content flow information 
chapter describes usability evaluation generated interfaces compared manufacturers interfaces printers evaluation consistency algorithms compared generation consistency 
chapter discusses puc system reviews contributions dissertation outlines directions 
chapter chapter related chapter surveys previous areas research control appliances user interface generation aggregate user interfaces 
control appliances spans products universal remote controls appliance communication infrastructures developed industry academic research 
projects examined user interfaces consumer electronics improved 
user interface generation subject research years name model user interfaces interfaces generated models application domain tasks user perform target platform 
original goal allow programmers typically trained design interfaces produce user interfaces applications 
falls categories fully automatic generation producing interfaces customized user designer guided generation producing maintaining large scale user interfaces 
aggregate user interfaces combine functionality multiple sources produce user interface 
known mash ups idea popular piece new web technologies developers combining data multi ple web sites single site produce compelling visualizations applications 
web mash ups type aggregate interface examples date built hand 
done human computer interaction ubiquitous computing communities automatically generating aggregate interfaces 
web services semantic web communities investigating web service composition focuses infrastructure issues address user interface 
control appliances number systems created controlling appliances 
commercial products available years allow limited control certain electronic appliances companies begun forming standards groups agree new solutions controlling appliances havi havi jini sun upnp upnp 
standards group formed examine standardizing appliance control order benefit people 
research projects explored area xweb olsen jr lieberman 
commercial products years companies selling called universal remote controls replace standard remote controls televisions vcrs single remote control unit 
way infrared protocol issue commands appliances 
typical universal remote control products physical buttons correspond common subset features appliances universal remote control 
televisions usually limited channel volume number pad manually entering channels power button 
example mother universal remote television vcr original remote tv order access television configuration menus 
universal avoid problem teaching feature allows user assign buttons universal remote particular code recorded original remote control 
philips see lcd universal remote control products 
addition able program new infrared codes new appliances users design panels controls 
easy example create specialized screen watching movies dvd player stereo chapter related volume controls watching television controls cable box channels 
users associate multiple codes single button allowing example create macro playing dvd turns dvd player television switches appropriate channel plays dvd 
problem universal programming done manually tedious time consuming task especially large number appliances 
logitech harmony remote see unique universal internally tries maintain record current state appliances control 
limitation remote know state system control done harmony remote advantage remote hide functionality available current state 
user interface simplified task interface shown small lcd screen displays list tasks play movie vcr play dvd list appliances user current state system 
options selected remote sends appropriate codes appliances may instruct user certain tasks insert dvd player 
remote control devices synchronize desktop computer task programming easier 
allows users download remote control layouts device share users internet 
communities created share panels www com www com 
synchronization basis programming harmony remote done web site gives user access harmony extensive proprietary database appliance state information 
synchronization helps decrease 
philips tsu remote control device 

harmony remote control devices models left right 
chapter related time consuming nature programming remote controls appliances user uploaded codes 
appliances programming process just time consuming advanced universal 
commercial standards number industry groups formed create standards remotely controlling devices 
prominent microsoft led universal plug play upnp upnp initiative upnp affiliated digital living network alliance home audio video interoperability havi initiative led world leading manufacturers audio visual electronics havi effort collaboration national institute standards technology nist consortium researchers industry academia 
goal standards initiatives create flexible communication infrastructure easier people control appliances environment appliances interoperate 
industry standards developed enable construction distributed network services 
standards focused generic services specifically electronic appliances 
proposed technologies standards including service discovery description find control appliances 
standards include sun microsystem jini system sun osgi alliance osgi 
standard government legislation requires appliances purchased government government entities usable people wide variety disabilities 
unfortunately appliances built today accessibility features 
international committee information technology standards begun standardization effort currently developing standards 
interface generated winamp pocketpc framework 
reproduced permission 
chapter related universal remote console enable appliances accessible alternative interface access protocol 
controls appliance download specification written parts user interface socket describes primitive elements appliance presentation template describes concrete user interface set resource descriptions give human readable labels help information user interface 
automatically generate interface presentation template display interfaces specified concrete presentation template 
example winamp interface generated framework shown 
provided feedback group past led current design specification 
detailed report available analyzing similarities differences puc systems nichols 
universal plug play universal plug play upnp designed allow user control appliance interoperation 
important units upnp service control point similar appliance controller respectively puc system 
upnp service downloadable description formatted xml lists functions state variables service 
control points connect services download descriptions call functions receive event notifications services 
important difference puc upnp automatic generation user interfaces 
upnp chose avoid automatic generation relies standardized appliance descriptions 
standardized description allows control point know advance functions state variables service allows hand designed user interface created advance control point 
similar havi upnp allow services specify additional functions state variables standardized set clear control point accommodate additional functions variables user interface 
upnp provides way allowing control point download web page control specialized functions service standard web protocols solution results different user interfaces displayed controller device 
upnp products available today including gateway router products streaming av products pan tilt video camera axis communications 
upnp currently chapter related standardized twelve different service descriptions devices appear market number standardized service specifications grows 
digital living network alliance digital living network alliance developing series standards upnp standards improve usability network connected appliances home 
typical usage scenario viewing content networked pc music video pictures stereo television located house 
upnp focus technology focus strictly improving user experience 
guidelines cover technical layer allow easy integration appliances design user interfaces 
products receive certification comply technical ui guidelines 
puc philosophy differs puc allows users decide integrate functionality appliances supports inclusion new appliances envisioned today 
set general cases appliances envisioned today may require revision new classes appliances commonplace 
home audio video interoperability home audio video interoperability havi platform designed specifically consumer electronics devices televisions vcrs works ieee network 
televisions feature havi available today rca mitsubishi electric mitsubishi time produced vcr supported havi 
havi user interface concept television appliance large screen control appliances home network 
ways havi controller control appliance type appliance controlled standardized interface specified havi working committee havi controller hand designed interface built standardized type appliance export level data driven interface basically description hand designed interface includes buttons labels multiple panels appliance export level user interface piece mobile code written java language displays remote control user interface executed havi controller 
interface descriptions puc appliance specification language second third interface description options may allow havi chapter related controller access special features appliance 
main advantage havi proposed industry standards ability control older legacy appliances older protocols av association 
main disadvantage havi size api includes levels interface specification standardized templates types appliances built controller implementation java virtual machine support number legacy protocols 
jini sun jini system designed network infrastructure easier programmers create distributed systems 
puc havi upnp allow controller device manipulate appliance infrastructure general 
system set apis discovering services downloading object represents service making calls object remote procedure call protocol releasing object longer needed 
havi jini relies java platform send mobile code service computer wishes service 
mechanism example display user interface allows human control service 
possible implement system puc top jini protocol jini provide user interface description features puc 
osgi osgi osgi dynamic module system java programming language provides standard primitives allow developers produce applications set small reusable components 
osgi service platform allows modules composed devices networks composition changed dynamically support new tasks 
platform allows modules automatically discovered integrated currently running system 
features allow osgi infrastructure variety smart home projects listed web www osgi org markets asp research systems universal interactor hodes hodes propose similar idea puc call universal interactor adapt control devices 
approach uses user inter chapter related face solutions hand designed interfaces implemented tcl tk interfaces generated language developed called interface definition language idl 
idl features hierarchy interface elements basic data types supports layer indirection allow example light control panel remap switch different physical lights user moves different rooms 
puc focus system infrastructure issues user interface 
clear idl describe complex appliance manually designed interfaces typically generated idl description 
ibm universal information appliance ibm project describes universal information appliance uia implemented pda 
uia uses xml mobile document appliance langauge modal creates user interface panel accessing information 
modal description specifies type widget location size user interface element 
stanford framework distributing composing appliance interfaces different controlling devices 
relies centralized interface manager distribute interfaces handheld devices automatically generating interface times distributing hand designed interface available 
distribute speech interfaces described language controllers support speech 
support automatic generation user interfaces limited mention difficulty generating speech interfaces 
interesting feature ability aggregate appliances provide user interface 
support composition relies set service interfaces functionality services set interface aggregators hand coded build interface particular pattern service interfaces 
user requests interface multiple services looks aggregator matches pattern aggregator returns single interface generated aggregator 
example camera implement interface printer implement interface 
generic aggregator chapter related combination generate combined interface camera printer 
approach limitations overcomes 
generic aggregator able generate interface common properties functions shared service interfaces unique functions may implemented specific service 
second generic aggregators able include design conventions specific services 
example play button appropriate dvd player producer camera 
produce interfaces unique functions appropriate design conventions special purpose interface aggregator need built specific appliances involved 
contrast interface aggregation faithful specific appliance interfaces aggregated includes functionality connected appliances 
xweb xweb olsen jr project working separate functionality appliance device displayed 
xweb defines xml language user interfaces created 
puc specification language xweb language uses tree specifying structural information appliance 
approach interfaces modes unclear remote control interfaces modes commonplace 
xweb supports construction speech interfaces 
approach speech interface design including emphasis fixed language cross application skill transference quite similar universal speech interface approach derived joint philosophy rosenfeld 
xweb language design allows users directly traverse manipulate tree structures speech report hard concept users grasp olsen jr 
interfaces designed puc universal speech interface design differ trying stay closer way people talk task somewhat closer naturally generated speech 
ubiquitous interactor ubiquitous interactor system working separate presentation functionality services 
services described interaction acts somewhat interaction objects puc interface generator chapter related describe interaction user providing information interaction 
general description service augmented service device specific hints provided customization form 
interface generator combines information interaction act customization forms produce final user interface 
unique feature comes customization forms allow service provider supply hints generated interface appear 
gives service providers control generated interfaces allows include brand marks interactions 
analyses actual remote control usage collected usage data consumer electronics real home settings applied machine learning approach discover core set functionality particular user cluster functions task groups 
compared automatic results users intuition discovered approach sufficient building complete user interface 
propose explore mixed approach combines automatic user oriented approaches design user interfaces 
approach differs puc interfaces include full functionality appliance subset containing commonly functions 
am interested applying optimize organization puc user interfaces favor commonly functions including remaining functions 
rich combines task dialog interface direct manipulation interface bring usability consistency consumer electronics interfaces 
interface designed display large screen home television personal computer uses part design difficult adapt today mobile phones 
task portions user interface automatically generated task models direct manipulation portions currently hand designed 
unique aspect combination different interface styles allows users choose interact appliance benefiting structured support 
chapter related system lieberman provides goal oriented user interface consumer electronics may combine features multiple appliances 
puc flow interface see chapter uses planning algorithm automatically configure appliances match user goals 
puc uses database commonsense knowledge find understand possible user goals system 
user specify action wish perform natural language attempt interpret action database create plan 
possible actions restricted contents commonsense database may able support uncommon actions related uncommon configuration appliances new class appliance just added system 
puc contrast able acquire model system appliances subject limitations 
automatic guided user interface design research interface generation long history dating back earliest user interface management systems uimss developed mid cousin hayes 
original goal systems automate design user interface programmers typically trained interface design produce applications high quality user interfaces 
led creation systems late early uide sukaviriya wiecha jade vander zanden humanoid szekely required designers specify models applications automatically generate user interface 
generated interfaces generally modified trained interface designer produce final user interface 
interfaces called model user interfaces models underlying creation 
early model systems drawbacks 
notably creating models needed generating interface time consuming process 
modeling languages steep learning curve time needed create models exceeded time needed manually program user interface hand 
automatic generation user interface difficult task resulted low quality interfaces myers 
systems moved designer guided processes fully automatic approach 
chapter related motivations suggested continued research model approaches beneficial large scale user interfaces assembled existing techniques difficult implement modify detailed models user interface help organize partially automate implementation process 
models help designers re visit interface modifications versions 
need device independent interfaces motivated new research model user interfaces specifically fully automated generation 
area begun explore applications automatic generation create interfaces practical approaches 
example puc consistency feature see chapters generates interfaces personally consistent user previous experience 
systems discussed section generate interfaces knowledge user studies conducted evaluate resulting interfaces 
closest reported study supple gajos discussed asked subjects interface design training produce interfaces presentation room control panel 
developers showed supple generate similar versions interfaces varying task information provided interface generator 
interface study simple functions users performance supple interfaces measured compared interfaces 
sections highlight model systems produced years 
discussion broken discussion early systems early mid systems 
early model systems initial research model systems conducted approximately mid early excellent review early model user interface research szekely 
early systems olsen jr automatically generated menus dialog boxes function signatures strategically placed comments chapter related code implementing application logic 
simplified construction user interfaces programmers implement logic add special comments immediately limited user interface application 
generated user interface rarely sufficient entire application techniques demonstrated showed promise simplifying user interface implementation process 
jade jade vander zanden example early model system automatically generating dialog box layouts textual specification content 
puc specification language jade textual specification contains graphical information keeps specification small allows look feel generated interfaces independent content 
puc system jade allows interface designers manually edit results fix problems automatically generated interfaces 
model systems discussed section similar features allowing interface designer guide generation process edit final user interfaces 
puc system allow manually editing important remember users puc system trained designers rarely time desire modify generated interface 
uide systems late early uide sukaviriya humanoid szekely wiecha expanded ideas complicated models generate sophisticated user interfaces 
uide stands user interface design environment earliest systems 
knowledge base contains information objects actions users manipulate objects pre conditions post conditions action describe true action executed conditions true action executed 
preconditions post conditions similar dependency information puc specification language 
development uide led advances automatic design layout dialog boxes 
shown decision tree constructed performed choosing interface element particular variable action de baar don system kim metrics heuristics create pleasing layouts interface elements 
puc interface generators extend techniques 
interesting tool developed part uide sukaviriya chapter related system automatically generating animated help pre post condition information 
may possible create similar system puc specification dependency information subject 
humanoid humanoid szekely tool supporting creation entire application going creation menus dialog boxes focusing construction interfaces visualizations complex data 
important feature humanoid designer interface integrates design aspects system single environment focuses designer tight design evaluate redesign cycle 
support cycle system explicitly designed application run fully specified 
benefit designers get immediate feedback explore alternatives short amount time 
mastermind mastermind project szekely started collaboration combine best features uide humanoid 
addition modeling capabilities systems mastermind uses task models inform automatic interface designs 
task models nearly new model system 
mastermind systems explore idea generating different interfaces desktop computers handheld computers pagers szekely model decide information interface elements removed interface size decreased 
interfaces generated different device interaction techniques true dramatically different puc interfaces generated pocketpc compared smartphone 
wiecha model interface system developed researchers ibm 
system differs model systems explicit separation concerns layer specification 
layers consist actions modifying data stores dialog specifying control flow style rules defining interface elements layout language user interfaces style programs instantiate style rules run time 
layers designed easier experts different areas collaborate interface design 
example programmers implement actions chapter related style programs interface designers write style rules application experts specify dialog 
important focus making dialog style rules layers highly usable non technical experts class participants wiecha design process 
design process iterative rules expected continually refined acceptable user interface created 
model interface systems create commercial applications including kiosks expo worlds fair spain 
trident trident vanderdonckt model system built time mastermind combines ideas automatic interface generator automated design assistant 
systems trident uses task model application model presentation model basis creating interfaces 
trident system established set steps interface generation process determine organization application windows determine navigation windows determine abstractly behavior presentation unit map presentation unit behaviors target toolkit determine window layout 
step interface designer ask system perform step techniques 
example trident determined layout bottom right method element ask element placed right previous element set heuristics automate decision interface designer explicitly decide resulting interfaces pleasing appearance 
trident task models specified format called activity chaining graph acg automatically determine number windows needed application 
model systems large interfaces platform independence model systems concentrated features earlier systems particularly successful task models describe users goals interface combination multiple interface models produce final interface 
advent xml trend development user interface description languages attempt standardize model formats different model systems 
chapter related mobi mobi puerta model user interface development environment capable producing large scale user interfaces 
mobi development process differs previous systems series declarative models created iteratively starting models users tasks presentation model represents final interface 
models stored relations described different models assist system designer interface building tasks 
mobi component tools helping designers various phases interface design process describing users tasks final guided assembly user interface 
assembly interfaces mobi highly structured process system steps user sub tasks associated interface provides suggestions appropriate controls particular task 
mobi rest model systems building large scale interfaces serve different purpose puc system seen complementary 
conceivable features puc system automatic modifications consistency aggregation user interfaces beneficial larger scale interfaces 
models interface necessary implement features models available interfaces built model development environment mobi 
concurtasktrees early options specifying task models formal specification language lotos iso goms card model systems task models created languages specifying models 
concurtasktrees paterno popular language representing tasks modelbased systems including tide ali teresa mori 
concurtasktrees graphical language modeling tasks designed analysis lotos goms task modeling 
concurtasktrees extends operators lotos allows specification concurrent tasks possible goms 
concur allows specification performing task user system interaction 
special development environment built creating task models concurtasktrees called concurtasktrees environment mori 
chapter related extensible interface markup language puerta general purpose language storing manipulating interaction data mobi 
xml capable storing kinds interaction data including types data stored application task presentation models model systems 
developed software support user interface consulting 
shown language useful porting applications different platforms storing information aspects user interface design project 
may possible express information puc specification language document language supports types information needed concrete descriptions user interfaces 
ibm pima ibm pima project creates specialized interfaces different platforms including pdas phones generic model application banavar 
incorporates automatic generation techniques differs ways layout information included pima generic application model help specialize interface different platforms designers typically tweak specialized interfaces generation 
puc system uses smart templates sophisticated interface generation rules address issues 
pima integrated multi device authoring technology project banavar focuses particular issues authoring web pages may rendered multiple platforms 
uiml tide user interface markup langauge uiml abrams claims provide independent method user interface design differs puc tight coupling interface 
uiml specifications define types components interface code execute events occur 
tide interface design program ali implemented address issues uiml 
tide requires designer specify interface generically task model 
task model mapped designer assistance generic uiml model chapter related refined specific user interface 
process similar pima mentioned 
teresa transformation environment interactive systems representations teresa mori semi automatic system transforming user interfaces different platforms 
allows designers build systems level concurtasktrees modeling language paterno transform model models different abstraction levels including concrete user interface different platforms 
teresa current focus web applications principle extended environments 
current system able automatically generate interfaces practice require designer involvement level abstraction create usable interface 
user interface extensible markup language limbourg allows specification different types user interface models including task domain presentation context models substantial support describing relationships supported models 
explicit goal language support features goals previously developed features 
appears complete specify features puc specification language clear easy language author concise produce specifications easily handled resource constrained device 
xul extensible application markup language microsoft xml user interface language xul different languages specifying user interface developed microsoft mozilla respectively 
major revision net framework eventually vista operating system describe graphics content rendered screen 
xul currently define user interfaces mozilla browsers 
documents written language similar presentation models model systems platform specific elements typically fixed interface modality constraints form factor input techniques 
case languages designed large chapter related screen graphical interfaces 
xul shown beneficial porting applications various platforms type including windows linux macintosh 
puc language differs languages describes appliance functionality specific details user interface allowing specification apply interfaces different modalities substantially different format factors different input techniques 
supple automatic interface generation systems including puc rule approach create user interfaces 
supple gajos uses numeric optimization algorithm find optimal choice arrangement controls cost function 
developers supple experimented including number different factors cost function 
common factors functions cost navigation controls cost particular control function 
additional costs included common tasks user performs gajos consistency interfaces application generated different platforms gajos physical abilities user assistive technology gajos 
shows example interfaces generated supple 
supple approach allows manage trade offs interface design exploring entire design space 
somewhat flexible puc rule approach requires exponentially processing variables interface elements considered 
means supple performance degrade complexity user 
examples interfaces classroom controller generated supple different devices standard desktop computer mouse touchscreen 
classroom sets lights variable brightness system lcd projector corresponding screen gajos 
reproduced permission 
chapter related interface increases 
difference supple interface description contains information puc specification language currently written syntax 
description defined run time objects created programmer second generation uide system 
aggregate user interfaces great deal research automatically combining services especially web services semantic web communities little combining user interfaces 
web services typically takes infrastructure focuses existing standards wsdl uddi daml sycara automatically discover compose services 
web service composition research rarely consider creating user interfaces combined services srivastava 
exception article staab briefly mentions control issues 
user interfaces specifying services connected kim leveraged build editor specifies appliances connected 
systems explored infrastructure issues involved connecting configuring systems multiple appliances 
system newman uses mobile code allow arbitrary devices services interact distribute user interfaces handheld devices users interact 
able automatically provide wiring diagram puc interface aggregation feature provide support automatically generating user interfaces combining user interfaces multiple appliances single aggregate user interface 
am aware systems provided automatic combination user interfaces 
system discussed earlier aggregate user interfaces services implement specific programmatic service interfaces interface aggregators implemented specific combinations service interfaces prevent users aggregating services ways developers anticipate advance 
second system gravity project hall provides mechanism automatically constructing application user interface dynamic set building blocks 
blocks change user context location envi chapter related ronment task focus gravity framework issues discovering available components repairing interface currently visible building block longer accessible 
currently user interface integration building blocks block displayed separate panel gravity application 
important focus puc integrating functions appliance single interface 
aggregate user interfaces known better mashups popular web community merrill 
puc combination functionality multiple appliances seen type 
puc functionality differs mashups 
part puc mashups produced automatically current web mashups produced manually skilled web programmers 
difference puc aggregate interfaces generated perform particular task combine operations data 
web mashups combine data collections set interaction techniques visualizing data map 
visualizations useful value exploring data new ways allowing user manipulating multiple web applications simultaneously accomplish specific task 
chapter related chapter related chapter preliminary user studies previous chapter showed automatically generating high quality user interfaces difficult problem 
step automatically generating remote control interfaces hand designed control panels appliances evaluated quality conducted user studies attempted extract features control panels contributed usability 
approach helped understand features high quality remote control interface nichols nichols apply interface generator software nichols 
hand designed user interfaces common appliances chosen focus hand designed interfaces cx shelf stereo remote control see tele chapter originally jeffrey nichols brad myers 
studying handhelds control smart appliances proceedings international workshop smart appliances wearable computing 
providence ri 
may 
pp 

jeffrey nichols brad myers thomas harris roni rosenfeld michael higgins joseph hughes 
requirements automatically generating multi modal interfaces complex appliances proceedings ieee fourth international conference multimodal interfaces 
pittsburgh pa october 
pp 

cx shelf stereo remote control office telephone digital answering machine studies 

prototypes phone stereo interfaces palm 

screenshots implemented phone stereo interfaces pocketpc 
chapter preliminary user studies phone digital answering machine see 
appliances chosen common readily available combine functions single unit 
owned shelf stereo telephone standard unit installed offices carnegie mellon 
brand particularly common subject population subjects user studies owned systems 
sets interfaces designed appliances low fidelity prototype designs palmos platform see functionally equivalent high fidelity designs implemented visual basic microsoft pocketpc platform see 
different platform high fidelity designs availability microsoft embedded visual basic tool implementation relatively painless 
complexity appliances palm prototypes required approximately hours create improved heuristic analysis prior user study 
pocketpc interfaces required hours design implementation effort create 
pocketpc interfaces improved combination heuristic analysis techniques think aloud studies pilot users 
goals design interfaces functional completeness appliances goal automatically generated interfaces deal full complexity appliances important hand designed interfaces help understanding address goal 
consistency conventions platform anticipated advantage ui device interfaces easier user familiarity platform leverage knowledge better appliance interfaces 
screening ensure user study subjects experts palm pocketpc platforms effort ensure platform consistency order understand difficult goal automatic interface generators 
study low fidelity interfaces showed important subjects feel control appliances 
unfortunately possible pocketpc control appliance software created simulate appearance controlling appliances 
laptop external speakers connected pocketpc wireless network allowing user actions transmitted laptop 
laptop chapter preliminary user studies simulated control generating auditory feedback consistent expected pocketpc controlling appliances 
user studies studies subjects comparisons hand designed pda interfaces interfaces actual appliances 
performance subjects measured metrics including time complete task number errors attempting complete task external help required complete task 
purpose studies discover users performed hand designed interfaces versus interfaces actual appliances discover aspects interfaces difficult 
studies low high fidelity interfaces similar discuss common procedure evaluation methods discussing studies detail 
procedure subject arrived asked fill consent form page questionnaire computer background remote control 
subject worked interfaces possible combinations control order effects 
subject saw actual interface handheld interface stereo interface phone interface necessarily order 
interface user asked set tasks 
finished final questionnaire asked actual appliance pda interface preferred general comments study interfaces 
evaluation order compare interfaces appliances task lists created stereo phone 
list designed take minutes complete actual appliance tasks handheld actual interfaces 
thirds tasks lists chosen easy usually requiring button presses actual appliance 
examples easy tasks playing tape stereo listening particular message phone 
remaining tasks required button presses chosen tasks user perform real life 
chapter preliminary user studies included programming list tracks cd player stereo setting time phone 
anticipated subjects able complete difficult tasks 
subject gave working actual phone stereo user manual asked complete task 
subjects working prototype interfaces allowed press help button available form screen 
interfaces study verbal hint visual basic interfaces second study scrollable screen text indexed topic 
performance subject lists tasks recorded metrics time complete tasks number completing tasks number times external help needed complete task 
time complete tasks measured press button press button completed task 
external help manual actual appliance help screen pda verbal hint experimenter 
purposes study defined pressing button advance progress current task 
repeated button counted additional 
subject try try repeat thing 
interface feedback visibly repeated incorrect steps counted additional 
counted task user requested external help 
study study compared actual appliance interfaces hand designed prototypes see 
handheld portion experimental procedure subjects stylus piece showed picture palm handheld device displaying remote control interface 
subjects instructed imagine picture actual handheld interact accordingly 
subject tapped interface element screen new picture placed old show result action 
auditory feedback required subject pressed play cd panel stereo see test administrator verbally tell subject happened 
chapter preliminary user studies participants thirteen carnegie mellon graduate students volunteered participate study female male 
subjects enrolled school computer science significant computer experience 
owned palm devices time study 
subject palm experience remaining exposure palm devices class friends 
group experience stereo systems 
stereo 
subjects happened stereo brand study 
results results study indicate subjects fewer asked help prototype handheld interfaces actual appliances see 
indicates prototype handheld interfaces intuitive actual interfaces 
time recorded study believed delays created prototypes dominate time required complete tasks 
informal measurements suggested subjects needed half time complete tasks prototypes compared actual appliances 

box plots showing range help requests uses external help appliance interface type 
chapter preliminary user studies discussion users great difficulty actual appliances able understand operate prototype interfaces reasonable ease 
exception prototype stereo interface palm built menu system 
subjects navigated screens accessible menus help think press button menus visible 
spite fact half palm devices regularly aware menu system 
study successful concern prototype interfaces benefited close interaction subject experimenter 
prototype portion study experimenter provided feedback user including verbal hints user requested 
issues new study conducted full implementations interfaces experimenter passive observer active participant 
study second study improved study replacing prototypes full fidelity pocketpc prototypes 
important issue interfaces conventions specific pocketpc operating system 
particular standard ok button exiting dialog boxes displayed top right corner screen 
users pilot tests discover feature unable exit certain screens interface 
interfaces changed goal conventions controlling device 
tutorial program created subjects began study 
tutorial covers ok button text entry location menu bar bottom screen top desktop computers 
participants twelve students carnegie mellon volunteered participate study response advertisement posted high traffic campus newsgroup 
advertisement specifically requested people little knowledge handheld computers 
subjects paid participation study took minutes complete 
men women participated median age chapter preliminary user studies average years experience computers 
subjects self rated skill computers everyday tasks knowledge handheld computers point scale 
average subjects rated knowledge handhelds points skill everyday computers average everyday skill handheld knowledge 
half group owned brand digital answering machines 
results results study indicate subjects performed significantly better pda interfaces metrics time complete tasks number help requests number 
note time measured study longer overhead shuffling papers 
shows box plots comparing handheld actual interfaces metric stereo phone respectively 
appliances users actual interfaces took twice long needed external help times twice mistakes users pda interfaces note improvement similar automatically generated interfaces compared actual interfaces described chapter 

box plots results second user study 
chapter preliminary user studies discussion results second study similar 
subjects need external help complete tasks handheld help 
compares subject average uses help actual stereo uses actual phone 
poor labeling insufficient feedback overloading buttons multiple functions account large difference actual appliances 
worst examples poorly labeled buttons overloaded functions phone 
phone buttons tapped quickly activate function pressed held activate function 
text telephone indicate 
similar problem encountered stereo 
setting timer requires user press combination buttons button press seconds 
stereo display indicator warn restriction users confused prompt disappear acted quickly 
phone suffered underlying technical separation telephone answering machine functions 
buttons phone answering machine 
numeric codes set arrow buttons phone keypad 
subject tried keypad buttons set code 
exception similar phone past 
problems avoided pda interfaces room labels descriptive certain multi step functions put separate screen wizard 
different screens separate infrequently complex functions problematic 
buttons menu items provided user navigate screens labels navigation elements describe general contents screen lead 
particularly problem handheld stereo interface screens 
screens accessible menu bar bottom screen 
subjects study think aloud participants study tentative navigating menus find particular function 
tasks required subject navigate screen menu bar subject commonly opened correct menu closed menu wrong current screen opened menu picking correct item 
chapter preliminary user studies pda stereo interface problems 
particular record function difficult represent interface associated tapes needed available stereo playback modes tape radio cd record button available screen see subjects get confused incorrectly switch tape mode pressing record button 
red circle text label rec button added pilot testing button visible thought people tried tape mode see record button 
change little effect 
analysis interfaces confident interfaces usable interfaces analyzed understand functional information appliance needed designing interfaces 
included questions elements grouped widgets shown time questions suggest information contained specification language 
prototype interfaces showed finding groups similar functions important constructing interface 
groups define elements placed relative elements separated multiple screens 
different screens tab components best examples grouping prototype interfaces see 
grouping separate mode random repeat elements rest elements stereo cd player interface see 
elements cd player modes components half modes 
unfortunately visual groups specified explicitly members may vary target platforms 
example device small screen necessary separate display current disc track controls playing cd 
appropriate puc separated play buttons 
noted grouping information generally specified tree tree interfaces different physical sizes provided tree sufficient depth 
user interfaces designed small screens need branch tree large screen interfaces ignore deeper branches 
chapter preliminary user studies grouping influenced modes 
example shelf stereo mode determines components playing audio 
component play time 
stereo interfaces shown note tabbed interface overlap controls cd player tape player controls independent mode volume available sidebar 
regular grouping information information modes gives explicit ideas user interface structured 
sets controls available time mode probably placed overlapping panels 
designed dependency equations describe appliance mode information language 
prototype interfaces showed feedback important 
important way interfaces provided feedback disabling control user tell function available 
errors users actual appliance interfaces occurred pressed buttons functions currently available 
area dependency information helpful defines exactly control function disabled 
noticed functions appliance manipulating data definable way 
example tuning function radio manipulating current value radio station pre defined increment 
seek function manipulates radio station value changing value radio station clear reception 
manipulation defined value variable need represented differently specification language 
interfaces different labels functions 
example palm stereo interface see label vol refer volume pocketpc stereo interface see volume problem worse smaller devices mobile phones wrist watches 
important specification language include multiple labels interface generator choose designing layouts 
interfaces conventional designs difficult specify language 
example conventional design panes shows telephone keypad layout uses standard icons previous track track shows standard layouts icons chapter preliminary user studies play buttons cd player uses standard red circle icon record 
conventions specified part functional description appliance applicable 
dialing pad convention sense speech interface example 
developed solution addressing problem called smart templates nichols discussed chapter 
requirements hand designed interface led development list requirements puc system fulfill order generate high quality interfaces 
section describes requirements briefly discusses fulfilled puc systems 
way communication important requirements puc type system way communication controller appliance 
obvious requirement system controller downloads appliance specification constructing interface issues commands back appliance 
important way communication maintained entire session controller appliance keep state synchronized 
state synchronization allows graphical interfaces display information current state interface visible actual appliance 
graphical interfaces current state coupled dependency information disable components currently active 
knowledge current state important speech interfaces able respond user queries current state information available visually appliance 
especially helpful blind users user near appliance 
simultaneous multiple controllers important multiple controllers communicate appliance simultaneously 
users expect feature added benefit allowing different interface modalities freely mixed different controller devices tandem 
example user combine handheld controller headset chapter preliminary user studies create multi modal graphical speech interface 
current systems fulfill requirement 
specific layout information appliance specification include information functions appliance include specific information controls positioned screen 
share philosophy xweb olsen jr projects uiml abrams include concrete information description layout 
requirement enforces modality independence limiting detailed designer specify functions appliance 
possible describe concrete interfaces appliance specification language designers tempted include details interface implemented 
disadvantages appliance specifications get longer may turn complete description different types concrete interfaces 
appliance specifications lose forward compatibility puc devices 
variety increase devices screens different interaction styles common 
example specific information dialog box style interface probably useful new watch circular screen nested dials interaction 
advantages automatic generation lost 
example puc ensure interface consistency making certain interactions multiple appliances 
possible puc freedom choose interaction style positioning representing functions 
hierarchical grouping fundamental requirement user interface organization users able intuitively find particular function 
appliance specification easily define organization tree group similar functions 
interface generation process easier concrete interfaces represented tree 
utility trees grouping universally accepted current systems kind tree grouping functions limbourg uses graph 
chapter preliminary user studies actions state variables commands action user take represented appliance specification 
state variables commands succinct way represent manipulable elements appliance 
systems microsoft upnp upnp separate state variables commands act 
means specification radio include station variable tune tune seek seek commands associated variable 
puc system infers functions state variable possible uses commands functions inferred seek seek 
command associated state variable specification languages support commands 
commands required representing functions notion state pressing flash button telephone 
commands useful situations state available manufacturer choice inherent limitation appliance hardware 
dependency information graphical interfaces visual indicator control disabled typical grayed appearance 
information function active specified concisely terms values state variables 
allow graphical interfaces display indicator function available useful inferring information panel structure layout interface 
appliances modes especially benefit approach mode typically associated functions active mode 
dependency information representation analyzed interface generator search sets controls enabled time create graphical interface saves space prevents user confusion displaying controls active mode 
knowledge universal speech interface applications solve problem disambiguation 
dependency information may useful generating help information uide system sukaviriya 
uide built pre post condition information determine particular function available generate instructions making function available 
comparison study graphical interfaces observed users sought help wanted function currently inactive 
chapter preliminary user studies dependency information similar pre post condition information generate kind help uide 
mentioned important dependency information form analyzed interface generators 
original version standard included dependency information dependencies defined arbitrary expressions difficult impossible analyze 
precluded dependency information graphical layout speech generation command help 
puc avoids problem specifying dependency information concise set relations joined logical operations 
puc system aware uses dependency information input automatic interface generator current version standard adopted similar approach 
sufficient labels comparison study hand designed interfaces actual appliance interfaces showed labels important part creating high quality user interface 
labels important part speech interfaces graphical hints assist user understanding interface 
give flexibility interface generator label appliance specification single text string collection text strings pronunciation keys text speech recordings 
pronunciation keys speech recordings help improve quality speech interface 
multiple text strings give graphical interface generator flexibility select label information fit allotted space 
puc system provide just single string text labels approach adopted standard 
shared high level semantic knowledge despite previous requirements recognize impossible encode information appliance specification human design interface 
addition functional information appliance human designer knowledge conventions creating interface 
conventions arrangement buttons telephone number pad country specific format specifying dates 
conventions tend different types appliances usage differ depending functionality appliance 
example media controls play pause appliances chapter preliminary user studies devices play fast forward rewind track previous track 
appliances add common functionality play new button answering machines 
describing convention applied appliance require lot detailed specification violate third requirement including layout information specifications 
developed innovative flexible standardization technique call smart templates allows conventions standardized advance appliance specifications easily describe conventions applied appliance user interface interface generators appropriately render convention appliance controller device various properties user locale 
smart templates discussed detail chapter 
chapter preliminary user studies chapter system implementation fully implemented puc system allowing users control real appliances automatically generated interfaces real handheld devices 
chapter overviews puc architecture discusses aspects implementation discussed 
architecture architecture puc system shown 
puc system main entities appliances provide service user controller devices automatically generate remote control interfaces appliances 
appliances controller devices communicate peer peer approach allows controller device control multiple appliances simultaneously appliance controlled multiple controller devices simultaneously 
way communication required controllers able send commands receive specifications appliance state information appliances 
appliances controller devices communicate custom communication protocol designed operable different network layers wi fi bluetooth zigbee current implementations support tcp ip 
protocol xml messages designed functional elements supported puc specification language 
appliance control systems upnp puc support automatic discovery appliances 
currently user controller device specify server connect ip address name protocol relay name appliances controllable server 
considered including discovery features protocol decided feature outside scope research 
discovery mechanism integrated puc 
particular best location discovery system ensure users controlling appliances intend control example neighbors appliances 
appliances increasingly built communication protocols allow way communication unfortunately protocols proprietary compatible puc protocol 
enable control real appliances build adaptors hardware software translate appliance proprietary protocol puc protocol 
cases possible control actual appliance 
cases forced write adaptors simulate behavior appliances 

diagram puc system architecture showing communication different components 
chapter system implementation controlling appliances built adaptors different existing appliances see table simulators see table 
generic debug server read puc specification create simulator specification provide user interface allows developer adjust state appliance appliance functioning 
user interface generated debug server uses subset algorithms graphical interface generators allows read state variables modified show commands see 
adaptors built created entirely software require appliance attached pc order function 
example sony camcorder controlled av protocol running ieee cable 
adaptors desktop applications typically add capability provided developer adaptors communicate serial port general protocols upnp 
adaptor written entirely software shelf stereo originally mechanism communicating internal state third party 
appliance modified collaborators maya design local pittsburgh design firm custom hardware electronically watched lcd screen stereo determined state set lights currently displayed 
control shelf stereo enabled standard ir protocol stereo remote control 
considered building general adaptors existing appliance control protocols upnp havi 
upnp havi appliance description languages idea build gateway translate protocol appliance description puc specification 
translated specification mapping description language gateway translate protocols fly 
unfortunately able build general adaptors reasons practical fundamental 
practical reason chose build general purpose adaptor appliances designed protocols export functions protocol 
value creating general adaptor fairly low 
fundamentally problems building general adaptor worse 
description languages upnp especially havi nearly detailed produce reasonable puc specification 
havi prob chapter system implementation lem descriptions limited low level description desired user interface including pixel locations sizes control 
links labels associated controls difficult create reasonable puc specification 
upnp descriptions provided functional information right level abstraction grouping information human readable labels 
puc specifications created information resulting interfaces poor best 
table 
appliance adaptors built puc research team home entertainment appliances shelf stereo sony camcorder lighting controls intel upnp light lighting lighting desktop applications microsoft powerpoint microsoft windows media player puc photo browser axis upnp pan tilt zoom camera table 
appliance simulators built puc research team home entertainment appliances panasonic pv vcr gmc denali systems driver information console climate control system navigation system office appliances canon printer hp printer simulated elevator 
interface puc debug server 
main window showing appliances currently simulated server 
interface simulating philips dvd player automatically generated debug server 
chapter system implementation generating interfaces controller devices built graphical interface generators different platforms microsoft pocketpc smartphone collaborated creation speech interface generator researchers carnegie mellon language technologies institute lti 
interface generators speak puc communication protocol generate interfaces specifications written puc specification language 
speech interface generator creates interfaces universal speech interface techniques rosenfeld developed collaborators lti 
generator implemented variety speech technologies developed carnegie mellon including phoenix parser ward sphinx recognizer cmu 
interface generators speech generator attempts determine front appliances user want control automatically generates grammar supports control appliances 
language model pronunciation dictionary automatically generated assist speech recognizer 
graphical interface generators implemented net compact framework 
generators run different platforms net allowed share substantial amount code interface generators 
includes code implements communication protocol parses specification language performs common tasks 
interface generation rules shared platforms platform unique generation rules 
rules discussed detail chapter 
graphical generators custom interface allowing user connect appliances 
custom controls implemented various generators support generation list interfaces add common controls supported compact framework 
pocketpc desktop implementation pocketpc desktop generators similar menu interface allows users connect appliances generate user interfaces 
interface generator menus exclusively generator functions appliance functionality added 
decision part preliminary user studies see chapter showed subjects rarely looked menus appliance functions 
menus 
puc menu shown allows users connect new appliance server choose chapter system implementation 
screenshots menu interface pocketpc puc interface generator 
desktop interface generator similar menu structure 
backgrounds screenshots show logging panel messages interface generator displayed 
server 
appliance servers machines multiple appliances may attached 
servers maintain list appliances connected send list controller devices connect 
servers menu shown shows servers controller device connected hierarchical menu server showing appliances connected server 
user selects appliance hierarchical menu controller device connects directly appliance downloads appliance specification generates user interface 
appliances connected controller device displayed devices menu shown 
generation menu shown gives access various options control generation user interfaces including resetting consistency system opening features multi appliance system 
support generation interfaces necessary implement number custom controls cover functionality net compact framework 
example compact framework panel automatically adds scroll bars controls placed panel viewable area 
necessary implement date time slider combo box organizing panel navigation panels left half different list widgets see shot list widget displaying multiple steps route 
smartphone implementation smartphone interface generation menu interface structure menus slightly different differences smartphone menu design 
chapter system implementation 
screenshots interfaces smartphone interface generator showing menu interface custom controls built smartphone 
smartphone devices soft buttons underneath screen leftmost button invoking common command rightmost button opening single menu 
menu hierarchical items include pocketpc desktop generators 
initial view smartphone interface see shows logging panel initial soft button labels bottom 
screen user press left soft button open connection appliance server right soft button open menu see 
menu hierarchical items corresponding server device generation menus pocketpc desktop generators 
connected servers placed separate sub menu limit number items menu 
multi appliance interfaces implemented smartphone consistency options available generation menu see 
necessary implement custom controls smartphone interface 
interface guidelines smartphone called types interface views see section detailed description controls provided compact framework views 
necessary implement list widget typical list interaction see examples widget panel interactions automatically scrolls user input focus changes see 
necessary implement custom slider widget smartphone version compact framework implement interactive scrollbar 
example custom slider control shown controlling brightness copier 
chapter system implementation communication communication protocol defines different messages may sent appliance controller device 
messages may originate controller devices see table may originate appliance see table 
protocol defines additional messages allow appliances identify appliances 
current design assume lossless underlying networking technology tcp ip protocol include messages sole purpose acknowledge receipt message 
protocol define strict ordering messages controller devices appliances prepared receive message time 
messages puc protocol composed chunks data xml chunk followed optional binary chunk 
binary chunk transmit data typically images easily converted text transferred xml chunk 
chunks data preceded message byte fields containing length data chunks second containing length xml chunk see 
data xml chunk conform communication protocol schema defines message type type parameters 
schema appendix detailed documentation language available online www pebbles cmu edu puc protocol spec html messages designed state variables commands basic functional elements puc specification detail see section 
controller devices may send messages requesting changes state variable invocation command 
response appliances send state change notifications 
messages common sent puc protocol 
state change notifications may sent controller device requests update appliance entire state 
message controller device request appliance specification message appliance send specification document 
puc support binary data complex data formats lists introduces possibility large amounts data need sent controller device appliance needs update state 
address problem lists included list operations allow appliance update portion list chapter system implementation table 
messages may sent controller device 
name description state message requests appliance change designated state value contained message 
command spec request full state request message requests appliance invoke command 
may cause state changes side effects 
message requests appliance send copy specification 
send device spec message 
message requests appliance send state change notification messages state 
state value request message requests appliance send binary state message containing binary data particular state 
message sent controllers get list appliances connected particular server 
server table 
messages may sent appliance controller device 
name description state message sent appliance changes state 
state name value sent 
binary statechange notification device spec alert information server information message may sent different contexts 
sent binary data changed appliance response state message controller 
message contains appliance specification 
sent receiving spec request message 
message contains string message needs delivered user controller 
message sent service discovery manager controller know appliances connected server set appliances changed 

message format puc communication protocol 
chapter system implementation changed resending entire list 
considered adding versioning system lists address problems arise user decided interact list list data updated 
practice list data synchronization problem puc interfaces implemented feature 
puc protocol handles binary data differently limit number large data transfers allow controller device specify binary format compatible capabilities 
state variable binary type changed appliance state notification sent appliance name state variable new binary data 
controller device explicitly request binary data handle data appropriately 
puc specification binary typed state variable may indicate appliance able manipulate binary data sends controller scaling image 
specification indicates appliance feature available controller may specify additional parameters request binary data size image 
appliance send binary data request received controller device 
process prevents extra transfers potentially large binary data ways controller devices process binary data request binary state updated rapidly controller device condense updates request new data speed controller device receive 
chapter system implementation chapter specification language puc specification language carefully designed include just right amount information generate high quality user interfaces easy concise 
important goal language allow experienced specification authors create specification amount time experienced user interface designer need create user interface platform 
accomplishing goal address problem previous automatic guided generation systems specifications required time create simply building user interface hand 
informally experience specification language suggests come close accomplishing goal providing detail interface generators produce high quality interfaces 
chapter starts brief discussion design principles creation specification language building requirements analysis interfaces discussed chapter 
describes design language chapter originally published jeffrey nichols brad myers kevin michael higgins joseph hughes thomas harris 
describing appliance user interfaces abstractly xml proceedings workshop developing user interfaces xml advances user interface description languages 
italy 
may 
pp 
detail highlighting language unique aspects 
conclude informal evaluation observations specification language effectiveness 
design language shown example specification basic vcr appliance specification 
vcr functions users manipulate power common media controls including record eject channel tv vcr list timed recordings take place 
status indicators determining tape vcr tape 
vcr physical input standard television antenna physical outputs antenna standard wire yellow red white plugs composite video stereo audio 
features described specification language shown 
full specification simple vcr appendix snippets simple vcr specification shown language features described 
chapter focuses conceptual aspects language limited discussion syntax 
readers interested authoring specifications see complete language included appendix downloaded puc web site www pebbles cmu edu puc specification html design principles design specification language developed set principles base design 
principles descriptive appliance necessarily able describe full desktop application 
able specify functions appliance including types information earlier model systems included task models presentation models 
possible appliance interfaces fewer functions typical application rarely direct manipulation techniques interfaces 
sufficient detail generate high quality interface hand designed user interfaces discussed chapter 
note principle different 
possible completely describe appliance readable labels adequate grouping information needed generating user interface 
example universal plug play upnp standard upnp chapter specification language cludes appliance description language include sufficient detail generating interfaces 
specific layout information included specification language system requirement described section 
support generation different devices modalities especially small devices graphical speech modalities 
important note previous principle helps address principle suggests specifications may need contain extra information enhance support particular devices modalities 
example specifications may need include labels pronunciation text speech information support generation speech interfaces 
short concise important principles design language 
appliance specifications sent wireless networks processed computing devices lack power today desktop machines 
ensure performance adequate specification language concise 
choose verbose format xml basis language 
chose xml easy parse available parsers 
xml compressible format reduce cost sending specifications network puc system compression 
way specify feature appliance allowed specification language 
principle language easy author easy process interface generator 
impossible author influence look feel user interfaces writing specification particular way 
examples design choices influenced principle shown 
language design design specification language evolved years 
new features complex data structure support content flow information added initial version basic elements language remained 
main categories information described language functional content flow discussed sections 
chapter specification language functional language elements focus language functional aspects appliances directly influence design interfaces 
functional elements language allow specification author describe features appliance features relate features user 
main features specification language functions appliance represented state variables state commands 
state variables specific type information describes manipulated interface 
commands states collectively called appliance objects 
structure hand designed interfaces dependency information 
example suppose interface created shelf stereo system tape cd player 
power screen power button widget shown objects enabled 
power screen shown widgets objects active power 
expect interface panel widgets change tape cd player active 
final representation interface described tree format 
reasonable include tree representation interface specification appliance tree may differ different form factors 
example tree deeply branched small screen wap cellular phone interface tree broader desktop pc interface 
specification language defines group tree deeply branched 
expected information small screen large screen interfaces alike presumably branches ignored large interface 
important domain specific conventions possible interfaces users leverage knowledge previous systems interfaces 
need way include information appliance specifications smart templates technique developed address problem 
items described detail 
chapter specification language appliance objects types appliance objects supported specification language states variables represent data stored appliance 
examples radio station stereo number rings answering machine picks time alarm clock set channel vcr 
variable type ui generator assumes value state may changed value type time state enabled 
example channel state variable see integer type interface generator infer change channel function knows manipulate integer type 
possible state variables undefined value 
commonly happens just interface generated values assigned occur reasons 
commands commands represent function appliance described variables 
may situations invoking command caused unknown change known state variable seek function radio situations state variable known manufacturer choice reason dialing buttons standard phone commands 
vcr specification eject function represented command see 
commands puc specification language explicit parameters may languages upnp 
parameters needed author state variables specify dependencies require user specify variables command invoked 
allowed explicit parameters feature overlapped state variables increased complexity language broken way specify principle 
explanations explanations static labels important explicitly mentioned user interface related existing state variable command 
example explanation specification shelf stereo explain auxiliary audio mode user 
mode user controls explanation explains 
explanations represent early attempt including help information puc specifications rarely 
chapter specification language differences states commands explanations share common property enabled 
object enabled active user interface widgets correspond object manipulated user 
knowing circumstances object enabled disabled provide helpful hint structuring interface items active similar situations grouped items placed panels widgets visible object active 
specifying prior knowledge enabled property discussed detail 
type information state variable specified type interface generator understand may manipulated 
example channel state integer type 
define primitive types may associated state variable binary boolean enumerated fixed point floating point integer string types parameters restrict values state variable 
example integer type specified minimum maximum increment parameters see 
enumerated type small collections values string label 
internally values represented numbers starting 
example enumerated state name channel channel type type name integer min constant value min max constant value max integer type labels label channel label label chan label labels state command name eject labels label eject label labels command 
examples state variable representing current channel tuned vcr command tape currently vcr 
chapter specification language type items value 
enumerated types labels defined values 
types fixed point floating point integer contain numeric values 
integers decimal component fixed point floating point 
fixed point values fixed number digits right decimal point defined required decimal places field 
floating point values arbitrary number digits side decimal point 
fixed point integer types optional increment field restrict values state variable may contain 
increment specified minimum value specified 
parameters specified value state variable equal minimum increment integer 
string type contains string value 
specification authors specify minimum maximum average length string contained variable 
parameters affect size text box generated interfaces display state type 
important note complex types seen programming languages records lists unions allowed specified type state variable 
complex type structures created group tree discussed 
label information interface generator information label appliance objects 
providing information difficult different form factors interface modalities require different kinds label information 
interface mobile web enabled phone probably require smaller labels interface pocketpc larger screen 
speech interface may need phonetic mappings audio recordings label text speech output 
chosen provide information generic structure call label dictionary 
dictionary contains set labels plain text 
dictionary may contain phonetic representations phoneme set cmu text speech labels may contain text sable mark tags sproat url audio recording text 
assumption underlying label dictionary label contained phonetic information plain text approximately meaning 
interface generator label label dictionary interchangeably 
example allows graphical inter chapter specification language labels label play controls label label play mode label text speech text play mode recording au labels 
label dictionary playback controls group vcr 
dictionary contains textual labels text speech information 
face generator longer precise label sufficient screen space reasonable label space tight 
shows label dictionary play controls group vcr textual labels text speech label 
group tree interfaces intuitive similar elements grouped close different elements kept far apart 
grouping information start time timed recording placed real time control current channel creating unusable interface 
avoid explicitly specifying grouping information hierarchical group tree 
specify group tree ary tree state variable command leaf node see 
state variables commands may level tree 
branching node group group may contain number state variables commands groups 
designers encouraged group tree deep possible order help space constrained interface generators 
generators 
group tree sample vcr specification 
chapter specification language extra detail group tree decide split small number controls screens 
interface generators larger screens ignore deeper branches group tree put controls panel 
complex data structures specification language uses group tree specify complex type structures seen programming languages records lists unions 
chose approach felt simplified language followed principle way specify chosen specify complex types state variables authors specified related data single variable record data type multiple variables group 
support complex types added special group elements 
shows example list group element added specifying lists 
specifying list group similar specifying array records programming language multiple list groups nested create multi dimensional lists 
list group implicit length state variable named length contains current length list 
variable undefined list currently members 
specification may define bounds length list order help interface generator create better rendering 
exact size may specified minimum maximum size may specified 
list groups maintain implicit structure keep track list selections 
number selections allowed may defined specification options currently default specified 
list allows list group name list labels label timed recording label labels min constant value min max constant value max selections access read write number state name channel 
state state name starttime date time 
state state name duration time duration 
state list group 
example list group vcr specification describe list timed recordings may specified user 
chapter specification language selection implicit selection variable created contains index current selection undefined means selection 
multiple selections created implicit list group named selections created 
group contains length state list groups selection state contains selected indices 
developed special dependency operator lists named apply true items items items list match dependency equation items list 
second special group union group similar specifying union programming language children union groups appliance objects may active time 
implicit state variable named automatically created union group contains name currently active child 
dependency information way communication feature puc allows know particular state variable command unavailable 
interfaces easier controls representing elements disabled 
specification contains formulas specify state command disabled depending values state variables 
formulas processed puc determine control enabled appliance state changes 
kinds dependencies specified specifies state depended value state variable compare equals true specified state specified value 
greaterthan true specified state value greater specified value 
lessthan true specified state value specified value 
defined true specified state value 
undefined true specified state value 
dependencies composed boolean formulas 
may 
chapter specification language active equals state base power constant value true equals active 
example common type dependency equation specifying variable command available appliance power turned 
specifying dependencies list state variables done special apply operation 
element applies dependencies contains items list returns value depending value true property 
dependencies applied set items items property may set selected 
true property may set 
true dependency formula contained apply element true elements order true returned 
true true returned long dependency formula contained apply true elements 
discovered dependency information useful structuring graphical interfaces interpreting ambiguous abbreviated phrases uttered speech interface 
example dependency information help speech interfaces interpret phrases eliminating possibilities currently available 
formulas interface generation discussed chapter 
smart templates smart templates allow specification author indicate portions specification high level semantic meaning user 
interface generator encounters portions specification attempt generate interface matches user expectations 
author specify smart template group state variable command parameter 
example channel state variable marked channel smart template 
smart templates described detail chapter 
chapter specification language content flow language elements information content flow useful describe relationships appliances connected multi appliance systems 
specification language allows authors describe input output ports appliance possesses internal content flows ports 
internal flows include sources represent content originates appliance dvd player playing dvd vcr playing videotape 
display devices internal televisions receiving broadcast signals antennas defined sources content originate inside tuning device 
broadcast signals described special external source routed viewable user 
sinks represent locations content may displayed user stored retrieval 
example television screen receiver speakers vcr tape recording may sinks content home theater scenario 
pass throughs represent appliance ability take content input redirect outputs 
example televisions capability audio received input making available output appliances 
tuning appliances cable television set top boxes represented pass throughs usually take multi channel input antenna output single channel data 
wiring information system appliances combined port content flow information appliance build model content flow entire system 
content flow model useful generating interfaces aggregate functions multiple appliances 
generation aggregate user interfaces described detail chapter 
ports input output ports appliance define appliance relationship outside world 
order match user intuitive understanding ports specification authors encouraged create port physical plugs exist outside appliance 
tools information help users correctly wire chapter specification language ports inputs port name vhf antenna content type multi channel av physical type inputs outputs port name vhf antenna content type multi channel av physical type port group name output content type av port name video content type video physical type rca port group name audio content type component audio port name right content type component audio right physical type rca port name left content type component audio left physical type rca port group port group outputs ports 
ports section example vcr specification 
systems 
specification language supports port groups allow author give single name collection related ports typically ports carry piece larger content stream 
example output port group combination physical video port physical left right audio ports 
port group convenience easy specification authors define video stream uses output port needing specify ports 
internal flows sources sinks internal flow types specified basic pieces dependency formula defining flow active description ports associated flow list state variables commands groups modify behavior flow 
specification language sinks divided sub types recorder renderer describe sink content receives 
shows example source content flow example vcr specification 
ports may associated flow depend type flow 
output ports may associated source input ports sink allowed pass 
port dependency formula may specified defines port active flow 
activate particular port particular flow dependency formulas satisfied 
channels important concept content flow specifications 
pass sink receives multi channel input channel variable may specified appliance specifies particular channel tuned 
language specify channel multi channel stream replaced appliance ex chapter specification language ample vcr specification describe output tape source appear channel see 
set variables commands groups modify behavior flow important generation aggregate user interfaces 
example set allows tint brightness contrast functions television associated screen sink 
content group active equals state base power constant value true equals active content group active equals state base controls tv vcr constant value true equals active source name tape content type av active equals state base status constant value true equals equals state base controls mode constant value equals equals state base controls mode constant value record equals active output ports port group name output port name vhf antenna channel output ports objects group name base controls objects source 
description video tape source content flow example vcr specification 
note dependencies content groups contain source flow anded source dependencies 
chapter specification language evaluation specification language discussing interface generation important questions ask specification language language complete specify functionality appliance 
language easy learn 
completeness members puc research group including masters student staff members specification language author specifications different appliances see table 
tried cover large range appliance types write specifications highly complex appliances including high mitsubishi samsung dvd vcr combo player printers hp canon navigation system gmc vehicle 
table shows statistics specifications written far 
table shows puc specifications average quite complex particularly gm navigation system specification nearly twice complex specification 
specifications cover functions appliance giving confidence language capable representing common obscure functions appliance 
conclusively prove language completeness writing specification possible appliance believe sufficient evidence existing specifications suggest language may complete 
lowest level description seen specifications state variables commands adequate describing functional elements appliance 
higher levels hierarchical group tree sufficient representing organization dependency formulas descriptive specify behavior restrictive facilitate analysis applied generated interfaces 
main difficulty language design came supporting complex data structures particularly lists appliances 
design elements language driven primarily gm navigation system specification contains lists complex data destinations 
iterations specification led current design combined grouping list union features capable chapter specification language representing forms structured data 
design modification specifications including home entertainment office appliances 
question design support interactive list operations adding deleting moving items 
operations quite common appliances manipulating play list mp adding timed recording vcr changing route list navigation system 
standardizing operations language appropriate operations variations particular operation add add add 
experimentation table 
complete list appliance specifications authored puc research team home entertainment appliances shelf stereo receiver md television disc dvd player mitsubishi hd panasonic pv vcr philips dvd player samsung dvd dvd vcr combo player sony receiver sony camcorder lighting controls intel upnp light lighting lighting gmc denali systems driver information console climate control system navigation system office appliances telephone answering machine canon printer projector hp printer complex copier simple copier desktop applications laptop video controls microsoft powerpoint microsoft windows media player puc photo browser puc list task manager alarm clocks equity industries alarm clock timex weather alarm clock axis upnp pan tilt zoom camera simulated elevator table 
maximum average counts various aspects puc specifications written date 
functional elements groups labeled groups smart templates max tree depth ave tree depth max average gm nav including gm navigation system specification chapter specification language specifications including navigation system spec decided limit language expressiveness list operations specified normal commands state variables 
decision eliminates direct manipulation operations sufficient specifications written 
may possible support certain unrestricted direct manipulation operations arbitrary moves smart template implemented current puc system 
learnability ease evaluated learnability ease specification language formal authoring study informal experiences users inside outside puc research group 
formal study conducted subjects learned language reading tutorial document see appendix doing exercises approximately hours 
subjects asked write specification low panasonic vcr took average hours complete 
focus study consistency resulting specifications learnability se details study preparation specific results discussed see chapter details 
subjects able learn language sufficiently short hour period write valid specifications vcr 
suggests language easy learn 
informally draw people learned specification working puc research group 
course years different people language write specifications number different appliances 
picked basics language day proficient weeks 
people technical university vienna pisa puc system learned specification language see chapter details 
specifications complex average written members puc research team able learn language online documentation easily needing ask questions mail 
cases difficult aspects specification writing identifying variables commands appliance organizing variables commands group hierarchy 
believe tasks inherently difficult represent chapter specification language weakness specification language 
experienced authors develop strategy start identifying variables commands little focus organization specify group hierarchy variable commands identified 
course identifying variables commands appliance may difficult engineers originally built appliance 
specification language may easier makers appliance learned shown authoring study 
chapter specification language chapter consistency puc system automatically generate interfaces consistent interfaces user seen previously 
chapter discusses meaning consistency general puc system describes infrastructure needed puc generate consistent user interfaces 
rules generating consistent interfaces discussed interface generation rules chapter 
understanding consistency consistency subject research user interface community years debate consistency apply effectively 
grudin day workshop experts unable produce definition consistency grudin 
reisner said consistency loosely defined doing similar things similar ways inconsistency occurs designer competent user employ different assignment rules reisner 
kellogg kellogg chapter previously published jeffrey nichols brandon brad myers 
uni form automatically generating consistent remote control interfaces proceedings conference human factors computing systems chi 
montreal quebec canada 
april 
pp 
proposed consistency single definition suggests defined framework types consistency different levels 
types consistency internal consistency application external consistency multiple applications 
different levels conceptual communication physical 
grudin grudin adds type consistency called analogical meant describe consistency world outside computer system 
definitions gets close concept consistency helps operationalize consistency automatic system 
fortunately fair amount examining factors lead consistency lack thereof 
breaks user interface formal model usually set production rules describes actions users take order accomplish tasks 
barnard barnard positional consistency important command language meaning common parameters functions placed position 
conducted command line interfaces may apply today graphical user interfaces guis 
reisner reisner explored consistency drawing applications users fewer mistakes interface structurally consistent 
reisner case structural consistency defined terms production rules describing interface 
interface rules similar action form structurally consistent interface uses rules different forms inconsistent 
example shape selection application inconsistent shapes selected pressing select button flipping switch desired shape type pressing go button action required select text shape keyboard available 
second application rule moving cursor box specifying desired shape type structurally consistent 
consistency reisner explores application examine users learned drawing application subsequently performed second 
form consistency puc system aims provide 
polson collaborators showed common elements theory knowledge transfer experimental psychology account positive transfer effects observed usage consistent user interfaces polson 
case common elements shared steps needed accomplish task different chapter consistency applications 
experiments word processing applications polson showed effects transfer due consistent interface substantial cases application different versions application different applications polson 
cases transfer occurred large number external cues indicate users previous knowledge apply 
suggests puc create new interfaces steps similar previous interfaces new interfaces appear visually similar old interfaces users realize previous knowledge reused 
exploring user interfaces application consistent different platforms 
denis denis describe common problems arise creating multi platform applications differing sets functions different partitioning functions data ability recover context changing platforms 
identify problems continuity break knowledge continuity task continuity 
knowledge continuity refers properties interface labels layout task continuity refers ability users change devices middle workflow 
suggest set design principles dealing problems similar labels organization interfaces 
expands ideas relating existing theory breaking idea knowledge continuity parts perceptual cognitive functional 
perceptual continuity interfaces similar appearance 
cognitive continuity occurs users understand underlying concepts interface 
functional continuity occurs set functions available platforms 
denis suggest design guidelines address continuity guidelines sufficiently concrete apply puc automatic interface generation 
far identifies benefits consistency researchers may consistency carried far 
particular grudin grudin shows examples consistent design decision beneficial ease learning ease expert 
grudin important factor interface design matching user interface user tasks consistency 
consistency explicitly considered beneficial user tasks 
agree grudin position puc consistency generation rules favor usability interface consistency 
chapter consistency generation techniques able avoid grudin issues consistency 
consider grudin illustrative example placement house 
placing drawer consistent design grudin argues central easy find location 
usable design place location table kitchen garage swiss army equipment 
example different placements grudin declared particular design consistent best particular design user configuration user expects 
call configuration personally consistent design consistent user personal view located home 
puc interface generators attempt achieve personal consistency meaning functions appearance location user expects 
way puc attempts avoid inconsistency occurs designer competent user employ different assignment rules reisner 
grudin notes ease learning ease may require conflicting designs prevents consistent design interfaces optimized different purposes 
personal consistency helps puc generate interfaces suit user particular situation novice just learning appliance functions expert familiar appliances type 
happens novice user learned interface wishes expert 
case flexibility automatically generating interfaces allows puc regenerate interface design experts place design novices 
evaluating consistency process evaluating consistency interface time consuming difficult 
number systems created help automate collection usage data help evaluation consistency ivory 
sherlock glean specific features automatically evaluating consistency interface 
sherlock mahajan uses heuristic approach evaluate task independent qualities user interfaces consistency 
includes looking visual properties widget sizes font choices terminology issues inconsistent abbreviations spelling errors 
system capable evaluating dialog boxes visual basic visual principle tool run user interface translated sherlock textual interface de chapter consistency scription language 
output sherlock collection tables display metrics 
designers look consistency problems searching tables outlier values 
glean kieras predictions human performance user interface gomsl goms goals operators methods selection rules language model 
gomsl important unique ability accurately predict transfer times tasks john useful finding consistency problems similar tasks 
unfortunately gomsl model created user interface analysis conducted 
way automatically generate model shown possible types goms models john 
applying consistency number methods developed help ensure interface consistency 
platform interface guidelines toolkits developed apple macintosh help designers applications consistent platform 
usually guidelines best common functions defining standard menu structure easy open save files access clipboard functions 
specific consistency guidelines proposed described nielsen nielsen 
include maxims information location screens mechanism maintaining consistency called design languages designers ensure common features branding shared family products 
supple systems address consistency user interfaces automatic design 
system wiecha successful producing consistent interfaces family applications displays world fair multiple versions application 
interfaces generated rule approach consistency resulted rules applied interaction technique place condition 
note puc achieve consistency generation rules interface rely underlying appliance models 
appliances type may substantially different underlying models contributions finding similarities underlying models creating consistency similarities 
chapter consistency supple gajos automatically generates layouts user interfaces optimization approach choose controls arrangement 
initial research conducted adapting supple support creation consistent user interfaces application different platforms gajos 
supple create consistent interfaces underlying appliance models differ 
rich attempts address consistency problem consumer electronics devices combining task model approach direct manipulation interface 
goals provide consistency current system relies designers create direct manipulation portions interface appliance supply task model 
provide way search possible inconsistencies devices automatically adjust interfaces help user transfer knowledge interfaces 
specification authoring study started consistent interface generation studying inconsistencies arise user interfaces created puc 
puc interface generator uses rule process see chapter guaranteed produce interface appliance specification inconsistencies arising interface due differences specifications similar appliances 
order understand specifications differ conducted studies investigate questions specifications vary different appliances share similar functions 
specifications vary different authors 
studies focus specifications vcrs require specification language features usually needed specify complex appliances lists smart templates 
study study addressed question specifications vary different appliances similar functions examining specifications wrote different vcrs 
vcrs complicated features mitsubishi hd hs digital vcr samsung dvd dvd vcr combo player final vcr cheapest model find local best buy store panasonic pv 
chapter consistency wrote specifications ensure quality high 
recruit authors study wanted control differences arise authors 
tried follow manufacturers designs appliances possible sure differences specifications due differences appliances 
specifications took total week complete 
order analyze vcr specifications identified state variables commands referred objects shared appliances 
objects identical counter status variables tracked tape vcr 
objects similar completely identical 
example differences objects labels tv vcr vcr tv boolean states vcr 
objects contained values supported features vcrs 
example vcrs state variable specifies input coming antenna cable 
panasonic vcr supports options samsung adds extra option called auto automatically select appropriate value 
mitsubishi vcr auto value supports additional input types vcrs cable box digital cable 
functions shared vcrs specified quite differently 
example vcrs supports timed recording feature specify tv programs user wishes record 
way specify time program recorded differed devices 
mitsubishi panasonic vcrs variables start time time recording samsung matching variable start time different variable specifies duration recording 
case underlying data quite different function identical 
analyzed organization vcr specifications differences 
general high level groups shared mitsubishi hd hs samsung dvd panasonic pv 
vcrs study 
panasonic vcr second study 
chapter consistency tions exact placement groups varied somewhat 
example vcrs power state top level groups status setup 
mitsubishi panasonic vcrs groups controls timed recordings top level 
samsung dvd vcr groups located top level vcr group appliance support dvd mp players 
study second study examined variations specifications written vcr different authors 
study particularly interested seeing organization varied specifications 
panasonic vcr study recruited students university electrical computer engineering department subjects 
chose subjects expect specification authors industry background 
study subjects knowledge puc specification language started 
writing vcr specification subjects trained language written document exercises examples list application 
chose written training ensure learning experience subject 
list application example incorporated feature language different vcr affect subjects specifications 
training authoring took substantial amount time hours hours respectively allowed subjects take materials vcr home complete study course weeks 
subjects paid participation completing training returning vcr turning valid specification 
subjects specifications contained top level groups setup functions basic controls 
group timed recordings placed group location 
timed recordings top level group chose place basic controls group 
advanced controls group placing group top level putting inside basic controls group 
common groups subjects different strategies organize functions 
example subject organized functions belonged tv vcr method organize basic controls setup groups 
chapter consistency subjects placed objects different locations hierarchy 
example repeat play command put advanced playback controls group specification setup group 
functions defined differently cases subject commands play pause buttons state variables 
discussion studies specifications differences written author appliance 
differences may specification similar functions organization functions 
number variety differences particularly surprising demonstrates challenges puc faces creating consistent interfaces 
combine results prior interface consistency synthesize set requirements consistency puc system 
requirements consistency puc define consistent user interface easier learn incorporates elements organization familiar user previous interfaces 
context appliance interfaces mean new copier interface easier learn uses labels previously learned copier interface see clock easier set new vcr interface clock controls located place interface hierarchy 
order facilitate knowledge transfer interfaces polson suggests tasks similar steps sufficient external cues applications polson 
facilitate puc requirements consistent user interfaces interfaces manipulate similar functions way interfaces locate similar functions place requirements help ensure user tasks similar steps facilitate knowledge transfer 
illustrate fundamental separation puc functional consistency structural consistency 
interfaces functionally consistent set controls similar functions 
interfaces structurally consistent similar functions similar organizational groups 
types consistency independent addressed separately puc 
chapter consistency order knowledge transfer occur sufficient external cues indicate applications 
cases puc gets important external cue free users aware type appliance memory similar appliances past 
reinforce cue requirements help increase users perceptions consistency interfaces interfaces familiar labels similar functions interfaces maintain similar visual appearance studies show situations may arise requirements followed 
example similar functions may different representations control 
unique functions may affect order controls appear screen affect layout require larger controls wider labels 
situations fundamental trade maintaining consistency previous interface appropriately rendering new appliances functions 
address problem puc go grudin grudin favor consistency 
case puc move unique functions separate panel affect layout 
solution negative consequences usability important functions moved non intuitive location extra features similar function appear exist 
better favor usability situations puc requirement usability unique functions important consistency similar functions common result requirement consistent user interfaces similar visual appearance 
may benefit having different visual appearance users able learn user interface conceptually similar application easily interface labels different visual appearance 
requirements apply user interfaces puc generates illustrate actions puc take ensure consistent interfaces 
pre requisite requirements interface generators provide method find similar functions multiple appliances chapter consistency general requirement system wants create consistent interfaces implementation method specific particular type input system receives 
case puc input written specification language provides functional model appliance 
puc method finding similarities may applicable systems functional models may apply systems types input task models 
final requirement applies puc design 
puc consistency decisions previous interfaces users experienced possible puc generate consistently poor interfaces users start poor interfaces 
order address puc handle requirement users able choose appliance consistency ensured requirement affects puc consistent interface generation fundamental level data structures include information possible consistency choices means keep track current choice 
support developed mapping graph structure puc consistency algorithms discussed section 
architecture supports ability users choose consistency interactive interface support user choice subject 
understanding finding similarities specifications order support consistency puc interface generator understand new specification similar previous specifications interfaces generated 
knowledge base knowledge base important piece puc architecture supporting consistency 
stores previously generated specifications mappings specifications information interface designs built specifications 
important elements knowledge base mappings functions different appliances 
mappings automatically generated rules manually specified user available download internet 
chapter consistency mapping defines relationship similar functions specifications 
approach simplifies authoring mappings author mapping needs examine differences specifications considering differences relate specifications 
processing mappings simplified consistency algorithms currently need understand differences specifications specification generated specification serving basis consistency 
drawback approach mappings required pairs appliances similar functions limiting technology widespread similarities appliances included knowledge base 
puc supports different types mappings identified specifications written authoring studies 
mapping type described table 
types generally applicable creating mappings type functional specification language type puc unique smart templates construct see chapter 
order specify store mappings xml language developed specifying mappings schema appendix 
basic elements mapping language correspond mapping types described table mapping type child elements allow parameters specified 
chose ontological approach knowledge base reasons 
current ontology languages rdf owl herman useful understanding relationships concepts described nouns adjectives 
example ontology help computer understand bear animal fur animals fur mammals concepts necessary achieve consistency nouns actions verbs actions complex multiple steps may constrained particular order 
differences similar actions may occur steps ordering constraints steps 
general ontology languages owl may able represent actions drawbacks specialized processing required analyze ordering constraints steps description action requires substantially overhead language designed described actions concurtasktrees paterno 
chapter consistency second ontologies rely hierarchy understand concepts generalize 
bears animals example shows small aspect hierarchy allows generalization 
create useful action ontology appliances appliance operation need placed hierarchy generalized operations 
determining generalized operations appropriately labeling significant time consuming challenge furthermore probably useful complete appliances 
solution mappings require entire appliance space mapped useful incrementally added appliances specified 
mapping graphs mappings similar functions multiple specifications grouped mapping graph 
central purpose mapping graph help determine appliance basis consistency function 
mapping belongs mapping graph mapping graph set similar functions knowledge base 
example power media controls vcr tv functions separate mapping graphs containing mappings specific functions 
example mapping graph media controls function shown 
find specification ensure consistency puc consistency algorithms start node represents appliance generated traverse mapping graph find node user seen 
node maintains count times basis consistency 
discussed earlier may impossible ensure consistency similar functions specifications different represented edges mapping graph 
example panasonic vcr represents play pause state variable cheap vcr uses commands 
possible convert representations mapping infinite cost 
costs allow mapping graph traversals ensure consistency maintained endpoints traversal result 
may wonder bother include infinite cost edges mapping graph 
zero cost edges available infinite cost edges may traversed ensure consistency labels similar function 
chapter consistency table 
mapping types consistency puc system 
name description general allows series operations appliance matched series operations appliance support repetition 
possible operations invoking command changing value state variable 
state node list group maps state variables 
particular values state may mapped shortcut available define states entirely equivalent values 
specifies node group tree specification similar node specification 
node represent group command state variable 
specifies lists contain data 
groups multiple mappings 
groups nested 
template maps smart templates smart templates described detail chapter 

example mapping graph media control functions play pause appliances 
node counts indicate panasonic vcr basis consistency times answering machine dvd player cheap vcr basis consistency just 
answering machine dvd player generated consistent panasonic vcr counts zero 
chapter consistency automatically finding mappings collaboration brandon explored automatically extracting mappings new specification previous specifications user controller device stored 
challenge automatic mapping lack substantial semantic information function specification 
finding mappings specifications similar previous schema ontology matching database community 
matching tried numerous approaches including matching help machine learning doan 
matching techniques take advantage availability database containing instances data specified schema 
contrast instance information available puc specifications generation anyway puc state variables possible values 
built separate matching systems 
intuition puc data structures names label dictionaries variable types 
second similarity flooding technique melnik developed schema matching incorporates organization 
system performs best finding mappings vcr test cases total mappings false positives 
currently system successful integrate puc results systems useful starting place human create mappings specifications 
area require investigating means improve matching algorithms incorporating thesaurus appliance terminology leveraging existing mappings specifications 
explore approach size knowledge base quite small 
chapter consistency chapter consistency chapter handling domain specific conventional knowledge common problem automatic interface generators interface designs conform domain specific design patterns users accustomed 
example automated tool produce standard telephone keypad layout 
problem challenging reasons user interface conventions designers described interface generators able recognize apply conventions analysis interface specification 
systems wiecha dealt problem defining specific rules application apply appropriate design conventions 
systems kim rely human designers add design conventions interfaces automatically generated 
solutions acceptable puc system 
defining specific rules appliance scale puc device rely user modifications user trained interface designer 
user trained chapter originally published jeffrey nichols brad myers kevin 
improving automatic interface generation smart templates proceedings intelligent user interfaces iui 


pp 
time desire modify interface generated especially interface generated needed perform specific task 
developed solution problem called smart templates augment puc specification language primitive type information high level semantic information 
interface generators free interpret semantics smart template appropriate augment automatically generated interface conventions expected user 
smart templates specially designed integrate hand designed user interface fragments implement conventions automatically generated interface 
templates designed scale different appliances requiring help user generation 
interface generators required understand template templates designed full functionality template available user interface generator understand template 
roles design implementation smart template involve people different roles shown visually users controller devices interfaces containing smart templates produced automatic interface generators 
specification authors write specifications appliances 
expect authors appliance manufacturers specifications written third parties 
specification authors learn available smart templates template registrar may instantiate specifications 
specification authors required templates specifications course strong benefit doing potential increase generated interface quality 
interface generator programmers build software automatically generates user interfaces 
programmers employed controller device manufacturer third party 
programmers learn available smart templates template registrar choose templates implement properties requirements target controller device 
requirement interface generator support smart template highly recommended date time templates 
chapter handling domain specific conventional knowledge 
diagram showing different roles creation implementation smart template context interface generation process 
template registrar global entity manages list smart templates defines required optional parameters templates 
new templates may developed registrar proposed entities 
design steps development smart template 
template registrar defines new template 

specification author instantiates template times appliance specification 

interface generator aware template uses special interface code appropriately render template specification 
smart templates defined advance template registrar ensure agreement specifications authors instantiate templates specifications interface generator programmers write code renders templates 
agreement need absolute flexibility built design allow benefits user specification authors generator programmers adhere fully smart template standards 
user chapter handling domain specific conventional knowledge able access appliance functionality worst case user interface rendered special smart template rules 
registrar defines new smart template giving template name defining set specification restrictions template 
specification author instantiates template adding attribute group variable command name template conforming template restrictions section specification see 
interface generator encounters section specification referencing template knows invoke special code written generator programmer appropriately render template 
generator encounters template know normal generation rules render template contents 
possible smart template defined primitive elements specification language 
example shows instance media controls smart template rendered generator knowledge template group name controls media controls labels label play controls label labels state name mode type enumerated item count item count enumerated value labels map index labels label label labels map map index labels label play label labels map map index labels label pause label labels map value labels type state command name labels label prev label labels state command name labels label label labels state group group name counter time duration labels label counter label labels state name hours type integer type state state name minutes type integer min min max max integer type state group state name time duration type string type labels label length label labels state 
specification snippets showing instantiations different smart templates 
instantiation media controls template play controls windows media player 
instantiation time duration template counter function sony dv camcorder 
instantiation time duration template song length function windows media player 
chapter handling domain specific conventional knowledge shows instance rendered generators different platforms know template 
restrictions specification allow smart templates parameterized allows cover common unique functions appliance 
parameters specified terms primitive elements specification language consist list state variables commands template may contain definitions names types values properties elements 
elements may optional support functions instantiations template 
example representations play controls allowed template single state enumerated type set commands 
single state item enumeration labeled 
labels play optional record 
multiple commands command represent function play 
functions represented command optional 
template allows commands functions commonly included group play controls including previous track functions cd mp players play new function answering machines 
allowing combinations states commands template definition allows single smart template applied multiple kinds appliances see 
challenge template registrar find different combinations states commands appliance implementer 
easier appliance specification writers templates need modify appliance internal data representation order interface controller infrastructure 
example appliances may able export playback state want option specify playback function command 
example time duration template 
windows media player duration song available single integer sony dv camcorder playback counter available string see specifications 
representations accommodated time duration smart template allows puc implemented cleanly appliances translation needed suit requirements puc 
note regular specification language specify smart template represented 
new techniques need learned specification authors customize smart templates 
chapter handling domain specific conventional knowledge interface generator implements special generation rules template 
allows template rendered appropriately controller device bits interfaces specifically created template controller device 
hand designed interfaces include platform specific controls consistent user interfaces device 
case time duration smart template implementation platform different standard control manipulating time interface generators 
unfortunately platforms built controls media playback media controls smart template renderings appropriate different platforms 
smartphone implementation mimic interface smartphone version windows media player consistent application device see 
smart templates able intelligently choose rendering contents template 
example implementation time duration template renders time units meaningful implementation media controls smart template renders buttons functions available 
implementations pocketpc desktop extend intelligently laying 
renders media controls smart template different platforms different appliances 
media controls rendered smart templates disabled windows media player interface pocketpc platform 
media controls rendered interface smart templates enabled platforms 
top desktop middle pocketpc bottom shows smartphone 
smartphone control maintains consistency user copying layout smartphone version windows media player media player application find platform 
interface overloads pause play button 
different configurations media playback controls automatically generated different appliances 
chapter handling domain specific conventional knowledge buttons lines depending space enlarging buttons greater importance play grid create aesthetically pleasing arrangements see 
puc interface generators robustly deal content smart template conform restrictions specified template registrar 
content encountered interface generator understand content passed back rendering normal interface generation process 
approach cases smart template rules understand content able produce rendering better normal generator 
example time absolute template support optional variables define time rendered enumeration specifying hour hour time format see 
variables encountered puc pocketpc generator saves passes back interface generator normal rendering 
allow template know user changes variables take changes account rendering absolute time values interface 
situations interface generator may explicitly decide implement entire smart template interface generated normal interface generator sufficient 
example speech interface generator implement template best interaction speaking words play interface produced 
code smart template controller device access special features data specific controller device 
example address phone number smart templates puc pocketpc interface generator implemented take advantage built outlook contacts database pocketpc 
appliance requires entry address phone number template provides special button opens dialog box allows users pick contacts 
return puc interface appropriate information database automatically filled appliance fields 
integration particularly useful navigation system interface allows users quickly specify destination navigate contacts see 
potential controller specific implementation take advantage special physical buttons controller device possesses 
example controller special buttons volume volume smart template automatically allow buttons control volume current ap chapter handling domain specific conventional knowledge 
screenshots smart templates rendered part gmc denali navigation system pocketpc platform 
demonstrates time absolute smart template clock function 
hour option template changes way time rendered interface seen clock top screenshots 
demonstrates list commands templates integrated puc list controls 
commands adding deleting items located underneath list control edit button part list control 
move commands integrated list control arrow buttons located top selected list item 
demonstrates address template capability integrating pocketpc built outlook contact database 
leftmost screen shows interface user pressed select contact button 
pressing button shows middle screen allows user select contact database 
pressing ok dialog causes selected information filled appropriately fields template rightmost screen 
appropriate 
current pocketpc implementations media controls template allow left right directional buttons track previous track functions available 
chapter handling domain specific conventional knowledge implementing smart template interface generator implementation smart template accommodate required optional parameters template 
templates puts significant burden implementer handle different possible inputs reflect differences user interface 
implementation challenge greater merged templates smart templates contain smart templates 
example date time template merged template contain instance date time absolute templates 
merged templates complex implement implementer able handle different input combinations constituent templates 
implementation complexity smart template reduced separating implementation task layers data translation layer converts data back forth appliance format defined specification template data structure 
template data structure contains possible data template format flags define optional parameters instance template 
data template data structure changes layer converts data back appliance format sends changes appliance 
interaction layer creates user interface common data structure allows user manipulate template data 
changes user template data structure updated data translation layer notified 
layers separate instantiation template specification generation interface 
template data structure sole point communication layers 
approach particularly beneficial situations templates represent single data type date time may different formats specification 
situation implementing data conversion complex interface generation basically matter underlying data format separating data conversion simplifies interface generation generation needs deal single data format 
merged templates easier implement data conversion layers constituent templates re create merged template data structure 
chapter handling domain specific conventional knowledge reduces cost implementing merged template sub task creating interface generation algorithms 
code shared platforms implementations pocketpc smartphone data conversion layers shared 
new interface generation layers needed address differences platforms cost implementing template may reduced substantially 
layering approach remove complexity implementation smart template 
differences specification template reflected generation template requires complexity template addressed layers 
smart template library puc research team implemented different smart templates shown table 
templates collectively illustrate features discussed previous sections 
full description smart templates available web www pebbles cmu edu puc highlevel types html built smart templates uses templates improve puc interfaces differ somewhat initial intentions puc supports state variables binary type 
variables contain images sounds data easily communicated puc text communication protocol 
smart templates chosen handle binary information reasons 
appropriate interface generators handle kinds binary data 
smart templates attractive optional design case lack smart template handling particular binary data type means data interface 
second controls needed displaying binary data need custom built particular platform smart templates capable adding generated interface 
binary typed data requires extra communication negotiate particular sub types data image formats particular platform supports 
extra communication differ type binary data managed requiring different chapter handling domain specific conventional knowledge implementations type 
data translation layer smart templates different binary data types ideal place code 
list operations handled smart templates allowing special integration controls handling list data possible 
challenge puc faced handling lists represent list operations 
different kinds list operations add delete move insert different variations practical include firstclass elements specification language add add add 
ultimately decided list operations specified separate commands outside list operated 
building generation rules list interfaces list interfaces easier generate interface generator identify commands operated 
furthermore commands added items list automatically display dialog box enable editing newly added item 
solution chose create list commands smart template merged template may contain multiple templates 
constituent templates include list remove list clear list move 
list templates allow operations grouped appropriately list control add operations perform correct dialog box opening behavior move commands handled directly inside list control displayed separate commands away list 
important note list templates allow better list interfaces possible puc interface generators produce adequate list interface knowledge templates 
discussion unique feature smart templates ability integrate small snippets user interfaces interfaces automatically designed 
allows design conventions users expect included appliance user interfaces allowing flexibility interfaces generated multiple platforms features consistency aggregation 
smart templates provide consistency interfaces different appliances ensure controls similar kinds functions see 
chapter handling domain specific conventional knowledge smart templates limitations 
complexity size template limited cost implementing template interface generator 
template registrar standardize template large set functionality entire appliance vcr cost hand designing interface flexible accommodate wide variety functionality vcr may prohibitive 
functionality template large percentage entire appliance benefits possible automatic generation techniques consistency lost majority user interface longer generated automatically 
important note standardization needed smart templates quite different pursued current industry projects upnp upnp 
upnp specification appliance 
means manufacturers printers example sit room agree set functionality printers 
user interfaces printers standard 
standard agreed manufacturers may add custom functions functions appear upnp printer user interfaces 
smart templates standardize functionality finer grain level 
easier manufacturers agree features media controls example compared printer vcr 
smart templates affect manufacturers ability innovate 
new functions extend functionality existing smart template added appliance rendered normal interface generator 
unusual consumer electronics manufacturers produce appliances high remote controls appliances 
situation specification authors interface generator programmers reasonable believe manufacturers develop house smart templates improve appliances interfaces remote controls 
proprietary templates understood interface generators interfaces generated appliance sub par compared competing appliances 
particularly bad proprietary template replaced common template media controls preventing basic conventions applied appliance interface 
chapter handling domain specific conventional knowledge table 
template name address channel date date time way image description implemented smart templates puc system 
description represents aspects street address including street name number city state zip code 
primarily navigation system supports entry zip codes appliances need location information configure program guides pocketpc platform template integrates builtin outlook database allow users automatically insert contact information fields puc interface 
represents channel television station radio tuning parameter appliance 
template needed support automatic manipulation channels multi appliance interfaces discussed chapter offers better support channel manipulation currently afforded automatic interface generation 
example buttons provided manipulating channels arbitrary numeric entry puc normally supports 
represents calendar dates 
date formats supported match internal implementation particular appliance including integers strings multivariable formats 
template allows special date manipulation control controller device platform 
merged template date time absolute 
individual templates transform specification format common format special control available allows simultaneous manipulation date time 
specialized template represents control lighting source 
template supports arbitrary scale optional support direct functions 
template primarily lighting control 
represents way directional control pad dvd player navigation system 
template includes optional support enter button appears middle directional buttons 
general hope specification authors avoid control navigation onscreen menus replicated puc 
situations navigation map content displayed puc control may needed 
represents image type 
currently template interfaces powerpoint photo browser app 
images transmitted puc state variables binary types 
template negotiates appliance get image size type compatible controller device 
image list list commands handles list objects include object handles image template 
typical representation template user interface overlapping views list thumbnails images single record view shows larger image fields list 
template primarily interface photo browser appliance 
represents common operations supported list add remove clear move 
template allows operations better integrated list controls particularly moving items 
chapter handling domain specific conventional knowledge media controls phone number status icons time absolute time duration zoom controls represents functions controlling playback variety media including common functions play pause common functions play new answering machines reverse play audio tapes multiple playback speeds vcrs dvd players 
represents phone number controls entering phone number standard phone keypad 
address template pocketpc template integrate built outlook database allow users automatically insert numbers fields puc interface 
status icons template grouping template special templates representing variety status indicators typically represented icons contained 
currently different indicators supported puc including ones specifying tape appliance device busy see complete list 
represents absolute time day opposed duration time 
template commonly clock function appliance uses 
date template handle related preference variables user prefers hour time daylight savings time currently effect 
preferences affect representation time absolute templates appliance 
different representations time supported including integer string multivariable representations 
represents duration time required stopwatch appliance 
time absolute template different representations time duration supported including interface string multi variable representations 
represents controls zooming appliance interface typically standard looking glass icons 
template intended primarily appliances content displayed puc 
busy camera connected computer connected copy protected black ink memory card inserted network connected loaded tape player color ink 
icons currently supported puc status icons smart template 
chapter handling domain specific conventional knowledge chapter interface generation chapter discusses interface generation algorithms puc system 
interface generators rule approach operates stages 
stage appliance specification converted user interface platform specific details 
second stage converts user interface platform specific concrete user interface 
important contributions interface generators mutual exclusions determine structure interface algorithms manipulate new interfaces consistent previous interfaces user seen 
chapter originally published different papers jeffrey nichols brad myers michael higgins joseph hughes thomas harris roni rosenfeld 
generating remote control interfaces complex appliances proceedings th annual acm symposium user interface software technology uist 
paris france 
october 
pp 
jeffrey nichols brandon brad myers 
uniform automatically generating consistent remote control interfaces proceedings conference human factors computing systems chi 
montreal quebec canada 
april 
pp 
jeffrey nichols brad myers 
controlling home office appliances ieee pervasive computing 
july september 
pp 

generation platforms interface generators implemented graphical interfaces different platforms pocketpc smartphone desktop generator built speech universal speech interface rosenfeld techniques 
graphical generators built net compact framework allows code shared platforms common functions parsing specifications communicating appliances 
interface generation rules shared pocketpc desktop pocketpc smartphone 
speech interface generator produced masters project student carnegie mellon university language technologies institute harris 
chapter briefly summarize interface generator works describe interfaces produces generator discussed detail peripherally involved construction 
pocketpc desktop pocketpc interface generator puc primary development platform features implemented pocketpc migrated platforms 
platform set hardware requirements oems windows ce operating system runs top compliant hardware 
hardware platform requires screen touch sensitivity 
way directional pad available physical application buttons see 
current interface generator focuses touchscreen media controls smart template physical buttons see chapter 
pocketpc interface generator produces interfaces appear pocketpc applications pocketpc owners leverage existing knowledge interfaces 
generator attempts avoid scrollbars possible causes interfaces include overlapping panels manipulated tabs organizing control 
dialog boxes created certain situations 
techniques allow complex functionality appliance accessible user interface 
pocketpc menus bottom screen reserved controlling interface generator controlling appliances 
decision preliminary user studies showed users typically look appliance chapter interface generation smartphone smartphone interface generator uses microsoft windows ce smartphone platform 
platform set hardware requirements windows ce operating system 
pocketpc required screen smaller touch sensitivity 
interaction takes place way directional pad nora 

interface windows media player generated pocketpc 
full interface generated gmc denali driver information console 
functionality menus see chapter 
shows example interfaces generated windows media player driver information console dic gmc denali 
input output technologies pocketpc touch sensitive medium sized screen similar desktop result generation rules pocketpc desktop 
main difference desktop pocketpc generators choice controls slightly better desktop controls available pocketpc 
remainder chapter discuss rules generating pocketpc interfaces assumed rules generating desktop interfaces noted 
chapter interface generation mal phone keypad home back buttons soft buttons labels shown smartphone screen see left side 
smartphone interface generator creates interfaces follow microsoft smartphone user interface guidelines 
pocketpc chose approach interfaces consistent smartphone applications allowing users leverage knowledge smartphone control appliances 
guidelines stipulate interfaces list hierarchy leads summary panes viewing data editing panes modifying data 
generator follows guidelines focuses optimizing structure lists hierarchy shallow list requires screen 
shows smartphone full generated interface gmc denali dic 
interface generator tries keep interface list format possible variable manipulated constraints list 
case editing pane created contains appropriate controls 
interface generator may create summary panes number read state variables grouped 
note list hierarchy created interface generator static users learn hierarchy time remember locations commonly functions 
user interface guidelines state left soft button invoking commonly function interface 
button currently 
smartphone displaying puc interface windows media player automatically generated interface driver information center gmc denali 
user navigates list panes get summary editing panes 
chapter interface generation assigned perform back function experimented approaches 
speech speech interface generator creates interface puc specification interaction techniques shriver 
goal universal speech techniques balance flexibility natural language interfaces difficult implement typically convey limitations users structure specialized hierarchical menu speech interfaces 
structure set common interaction primitives designed learnable minutes applicable interfaces user encounters 
interaction primitives allow users navigate manipulate understand interface built techniques 
studies conducted evaluate users acceptance interfaces transference skills interface 
studies show users prefer interfaces natural language interfaces needed help users learn remember interaction primitives 
speech interface generator differs graphical interface generators connects multiple appliances multiple appliances network requests specifications automatically generates interface allows control appliances collectively 
includes building grammar parser language model pronunciation dictionary recognizer 
generated grammar compatible phoenix parser ward library parse user utterances 
grammar generated appliance contains phrases query control 
query phrases include determining groups available states commands available values states take values currently hold 
control phrases allow user navigate groups issue commands change states 
appliance specific grammars grammar compiled single combined grammar representing speech interface understand 
note different interface aggregation multiple connected appliances discussed chapter combined speech interface organized appliance re organization functions different appliances 
speech interface generator chapter interface generation implemented tested shelf stereo sony camcorder multiple devices 
shows example user interacting system 
speech interface translates group tree appliance specification tree 
tree concrete representation interactions take place system user consists nodes phrasal representations 
node actionable incomplete 
actionable node contains phrase uttered cause device state change 
incomplete node contains phrase requires information acted uttering phrase causes system prompt user completion options derived node children 
grouping information represented structure tree influences exploration disambiguation scope 
user system user system user system user control system control system system voice options control control control control voice options system global lights lights user system user system user system user system user system user system user system user system user control control stereo voice options stereo power bass volume stereo power stereo turned options stereo power bass volume mode cd stereo power options options radio band seek forward seek reverse radio station 
system radio station user radio station system changes station 
example interaction speech interface control shelf stereo lighting 
chapter interface generation unique challenges generating interface techniques puc specification language 
language distinction state variables commands best described variable visual interface speaker volume better thought command spoken interface louder 
addressed adding support verb labels specification language specify command words manipulate state variable speech interface 
secondly visual environment groupings functionalities widgets need name grouping implied adjacency visual cue frame 
speech interfaces grouping assigned word phrase directly accessed 
specification language require groups labels making appropriate names hard impossible find 
may necessary require labels group speech interfaces needed determine necessary 
speech interface benefits 
example choosing long list names easy speech challenging visual interfaces 
general concepts overview puc generation process graphical interfaces shown 
process consecutive phases fall categories 
generation phases creates new interface data structure previous structure attributes appliance controller device account 
consistency phases modify current interface data structure match elements previous interfaces user previously seen 
consistency phases knowledge base find matching elements choose appropriate modification 
types interface data structures generation process 
specification structure created parsing specification document written xml 
second user interface contains complete knowledge interface organized choice controls appliance functions 
third concrete user interface varies depending target platform interface generation 
structures common generation platforms rules creating user interface consistency rules operate user interface shared different platforms 
chapter interface generation phases designed produce consistent user interfaces 
mapping phase analyses new appliance specification automatically find previous specifications users seen 
phase adds new information knowledge base 
functional structural phases modify user interface ensure functions appearing previous interfaces manipulated way appear location new interface 
concrete phase clean visual consistency problems created interface generator transformation user interface concrete interface changing orientation panels adding additional organization 
discovered creation consistency algorithms needed ensure consistency take place third fourth phases operate user interface 
means consistency rules shared platforms modification 

puc interface generation process diagram chapter interface generation generating interface interface created appliance specification 
structure interface taken specification group tree modified analysis dependency information 
interaction objects assigned state variables commands placed structure interface 
result set controls hierarchical tree transformed concrete interfaces various platforms 
parts process analysis dependency information structure assignment discussed 
mutual exclusive dependency information interface generator uses specification group tree basis structure interface tree just specification author interpretation structure appliance 
structure may missing relative importance different pieces existing structure may clear 
example appliance specification shelf stereo group node branches represent main modes stereo cd tape radio 
generator needs discover group particular appliance create interface structure important branches clear 
appliance modes best mode control placed separate overlapping panel save space improve usability hiding controls active 
cases specification author may included structure mode interface generator needs means detecting possible inserting appropriate structure 
dependency information address issues concept mutual exclusion 
sets components shown active time interface generator decide sets components placed different groups groups marked important carry concrete interface 
way solve problem specification authors place marker groups mutually exclusive branches 
relying dependency information marker specification design easier 
finding cases mutual exclusion making tree fit author give tree hierarchy appropriate dependency information help generator infer structure 
structure inferred flat tree group 
chapter interface generation unfortunately task determining mutual exclusiveness arbitrary set state variables commands shown np hard 
reduce difficulty problem considering mutual exclusion respect single variable location specification group tree 
algorithm starts obtaining list state variables commands states depend 
practice small number variables specifications 
algorithm iterates list starting state depended variables commands 
usually states depended represent higher level modes algorithm prefers create high level structure earlier process 
state algorithm finds location group tree gets pointer state parent group 
dependencies state collected parent group children analyzed find mutual exclusion 
mutual exclusion group tree re arranged children mutually exclusive set children dependent state placed group 
parent group marked containing mutual exclusion taken account transforming user interface concrete interface 
shows example tree transformed take mutual exclusive situations account 

demonstration changes tree structure mutual exclusion 
circles represent nodes interface structure represent groups state variables commands 
tree node marked represents state variable values 
node marked parent group 
formulas shown remaining groups show dependencies group variable node dependent tree new mutual exclusion group added contains state variable child groups set mutually exclusive groups 
nodes dependent moved group parent outside mutex group 
chapter interface generation choosing interaction objects interaction objects representations controls buttons sliders concrete user interface 
idea developed vanderdonckt vanderdonckt build models user interfaces ported different platforms reason puc user interface 
puc uses delay selection concrete control properties concrete interface known available layout space context list panel 
interface generator chooses aio state variable command decision tree de baar 
different tree designed interface generator platform supports different set controls accounted tree 
parameters tree include object state command type state variable constraints type variables variable read example commands represented button aio read state variables usually represented label aio 
modifying interface consistency user interface created phases modify interface ensure consistency previous interfaces 
phases 
functional phase mapping examined user interface may modified ensure functional consistency 

structural phase organization user interface modified consistency 
phase helps ensure structural consistency 
phase puc transforms interface concrete user interface 
functional phase precedes structural phase phases executed opposite order 
chose order implementation reasons easier find functions user interface structural phase moves 
rules phases simultaneously balance consistency previous interfaces usability new interface 
particularly important dealing functions unique new interface 
changes functional consistency chapter interface generation applied disrupting usability unique functions structural changes broader impact potentially unintended consequences 
rules ensuring structural consistency carefully applied ensure usability unique functions substantially diminished 
heuristics unique functions order address issue usability unique functions heuristics structural consistency rules followed making changes involve unique functions 
heuristics necessary reasons 
best approach dealing unique function analyze function related functions appliance mappings 
relationships understood unique function moved changed functions strongly related 
unfortunately understanding unique function relates elements specification difficult specification language contains cues discover kind information 
second reason heuristics lack formal studies suggest specific methods balancing usability unique functions consistency 
particular central premise unique functions kept consistent interface example moved special panel unique functions collected 
testing premise conducting detailed studies unique function issue subjects 
heuristics move unique functions siblings 
unique functions middle group follow preceding sibling 
unique functions group reordered 
central assumption heuristics unique functions kept near surrounding elements initial specification 
particularly important moving functions may far away initial location specification 
re ordering heuristics violate assumption functions located group 
added functions top usually important left place 
functions bottom usually important reorganization upward items prominent 
chapter interface generation functional modifications functional phase ensures functional consistency inspecting function new specification determining previous function new function consistent making changes interface ensure consistency 
previous function consistent traversing mapping graph see chapter 
previous function set functional consistency rules transform new specification form consistent previous specification 
order determine particular rule apply puc iterates rules finds rule matches mapping 
puc rule rules carefully ordered ensure specific matching conditions tested generic matching conditions 
puc currently implements functional consistency rules shown table 
rule modifies portion new specification match previous specification 
example change invoke change rule convert state variable state variable command invoked variable change take effect 
part conversion command new specification hidden new command added 
command hidden converted state variable automatically invoke command value set user 
command added appliance informed variable change user invokes new command interface 
table 
name state puc functional consistency rules 
description ensures similar variables label possible control invoke change invoke change change time template node ensures similar commands label converts situation changing variable appliance repeatedly invoking command converts situation appliance state variable state variable command invoked variable change take affect converts situations appliance uses start time time appliance uses start time duration ensures smart templates label control style ensures nodes mapped node mapping label chapter interface generation structural modifications goal structural phase ensure functions located place new interfaces 
phase divided sub phases moving reordering 
moving rules need ensure functions placed similar groups re ordering rules ensure functions consistent ordering groups 
sub phases rely mappings node template list mappings identify similar groups specifications 
uniform uses information rearrange groups structure previous specification 
moving moving sub phase traverses user interface group tree searches mappings 
difficulties may arise processing mappings determine move necessary 
new specification may mutual exclusive groups planned move may cross boundaries groups 
easiest case item dependent mutually exclusive state moved mutually exclusive groups 
extra needed moved item available new location interface 
opposite case dependent item moved mutually exclusive groups trickier item may disabled may clear item new location 
difficult case occurs item needs move group mutually exclusive 
case extra moved item available dependencies conflict organization automatically generated interface generator 
rules address problem discussed 
second difficulty arises mapping variable command specification items adjacent 
refer situation split mapping items split multiple locations specification 
split mappings arise situations options single function specification represented separate functions specification single function specification duplicated second specification available context 
example situation mitsubishi samsung dvd vcr specs front display setting controlled state variable samsung variables mitsubishi separately control brightness chapter interface generation content front display 
example second situation hp canon printers 
hp specification global buttons starting copy fax scan functions depending current mode 
canon separate buttons starting copies starting faxes starting scans 
set buttons canon mutually exclusive printer modes time 
different rules moving items 
rules handles simplest case moving items adjacent specifications cross mutually table 
consistency moving rules implemented puc 
name split 
mutex 
description move single item moves adjacent items location new specification similar location similar items previous specification 
move single moded item performs move move single item rule handles situations move cause items move mutually exclusive group boundary 
example canon printer fax setup functions setup mode fax mode hp printer generating consistent interface printers requires moving items group conflicting dependencies 
cases rule removes dependencies moved items automatically handles needed mode switches background user uses moved item 
move split moded items handles moves mapping single item specification mapped multiple items specification multiple items mutually exclusive 
example rule handles situation buttons start copying scanning hp canon printers 
move split items bring split dependents similar move split moded items rule rule handles moves single item specification mapped multiple items specification 
multiple items may mutually exclusive rule 
works group mappings contain state mapping task mappings 
typically means appliance set functionality moded functionality available simultaneously specification 
functionality split spec rule handles moving dependent pieces appropriate locations 
chapter interface generation sive group boundaries 
remaining rules address particular combinations split mutually exclusive situations 
table shows different moving rules 
important feature moving sub phase data structure called containment stack purpose containment stack keep track similar parent groups sub phase traverses tree 
stacks created new appliance previous appliance 
mappings specifications included containment stack entry stack known refer existing location specifications 
example containment stack clock group mitsubishi samsung dvd vcr shown 
clock located different group specifications reflected containment stack 
moving rules check containment stacks see top group mappings different 
mappings different requirements moving rule met mapping objects moved group corresponds previous specification top group mapping 
example suppose generating samsung dvd vcr interface consistent mitsubishi 
top group mappings base setup dvd vcr base status different 
items specification adjacent move cause item cross mutual exclusive group boundary means move single item rule applied 
moving rule take clock group move dvd vcr base status group similar group name see 
note moving algorithm chains appropriately 
example clock group dvd vcr contains variable specifies channel clock information extracted 
similar state variable located setup group clock group 
puc moved clock group clock channel variable containment specifications afterward longer true 
algorithm applied channel variable difference containment containment stacks calculated variable current location 
algorithm move channel variable back consistent location setup group see 
note movement visible generated interfaces shows clock group setup tab clock set variable shows clock group status tab clock set variable 
chapter interface generation moving rules copy appropriate missing structure previous specification new specification 
example suppose additional group named datetime clock group base status group mitsubishi specification 
case generating samsung interface consistent mitsubishi moving rule moved clock group base status group created new group named datetime base status group placed clock group new datetime group 
labels datetime group mitsubishi specification replicated newly created group 
recreating missing structure gives interface generator options adding organization creating concrete interface 
move single moded item rule handles moves cross boundaries mutually 
containment stacks previous specification mitsubishi new specification samsung dvd vcr results consecutive movements 
shows movement clock group shows rule chains movement clock channel state 
mitsubishi consistency samsung dvd vcr consistency samsung dvd vcr consistent mitsubishi 
user interfaces generated desktop puc mitsubishi samsung dvd vcr consistency dvd vcr generated consistent mitsubishi 
note clock functions located status tab mitsubishi setup samsung dvd vcr new status tab consistent interface 
note controls timed recordings located vcr tab samsung dvd vcr 
chapter interface generation exclusive groups 
mentioned situations move may create unusable situation moved items disabled interface generator may accidentally impossible enable items action required enable items located far away moved items 
cases rule causes moved item dependencies generated user interface 
item enabled actual dependencies indicate 
user manipulates item disabled interface generator appropriate mode changes background confirms users change returns modes back original settings displaying changes user interface 
example hp printer fax setup functions located fax mode canon printer functionality setup mode 
hp interface consistent canon fax setup functions moved setup tab appropriate modifications enabled 
rule allows users change fax setup settings 
user modifies fax setup function rule causes interface generator automatically change fax mode apply user change switch back setup mode 
done quickly background causing noticeable confusing changes user interface 
move split items rule handles situation item specification mapped multiple split items specification front display functions mitsubishi samsung vcrs discussed 
behavior rule differs depending direction consistency ensured 
new specification contains split items previous specification contains single item split items moved location similar single item 
situation reversed single item duplicated locations split items previous specification 
version rule try modify single item match split situations find generalizable way information currently available mappings 
example making samsung interface consistent mitsubishi rules information able split samsung overlapping brightness content control front display independent controls match function split mitsubishi 
control brightness placed matching location brightness control mitsubishi done control content 
chapter interface generation bring split dependents rule handles particular situation specifications 
specific example appears hp canon printers 
hp printer options resizing copied image including zooming creating poster multiple pages repeating image multiple times single page 
options chosen time hp 
canon printer options features independent 
particular image repeat function resizing options 
speaking generally rule addresses situation appliances share functionality functionality moded appliance 
situation described knowledge base group mapping contains state mapping multiple task mappings involving states state mapping 
moving rule needed situation functionality may located place specification mode state variable 
new hp printer consistency canon printer consistency canon printer consistent hp 
demonstration bring split dependents rule 
top image shows location resize mode function bottom shows location repeat image function parameters 
column dialog box shown bottom opened pressing repeat image button shown top image 
chapter interface generation specification contains functionality functionality moved near state variable 
previous specification contained functionality moving rule creates new button appropriate mode change places button similar location functionality previous specification 
functions dependent mode moved location new button see 
re ordering reordering sub phase moves functions groups ensure consistent ordering 
example shows parameters timed recording different ordering mitsubishi samsung dvd vcr 
sub phase moving sub phase traverses user interface encounters mapping 
reordering rules operate children node moving sub phase need apply rules leaf nodes group tree 
reordering rules executed group sub phase determines previous specification group consistent 
sub phase creates block list data structure group new specification equivalent group previous specification 
block list important allows rules analyze manipulate functions functions list underlying representation structure user interface tree 
tree structure problematic function objects span multiple levels tree hierarchy case mapping samsung dvd vcr shown 
set adjacent objects mapping block stored list order appear generated interface see 
consecutive unmapped objects stored blocks list 
block lists processed reordering rules resulting new block list specifies final ordering group 

block lists created timed recordings groups mitsubishi samsung dvd vcr 
vcr type unmapped blocks block lists 
chapter interface generation current reordering phase rule starts searching block lists new previous specifications find blocks mapping 
blocks reordered match previous specification 
unmapped blocks moved block precedes accordance second unique function heuristic 
example notice type block followed block new location 
unmapped blocks block list re ordered accordance third unique function heuristic see section 
generating concrete interface user interface created modified ensure consistency time generate concrete user interface 
sections describe concrete interface generated pocketpc desktop smartphone platforms 
pocketpc desktop pocketpc desktop interface generators process generating concrete interfaces split steps 
step generates initial version user interface important structural elements 
second step looks layout problems initial version generated interface panels require scroll bars display content controls wide display labels 
problems rules attempt fix problems adding organization changing layout 
approach user interface built minimum amount organization needed size screen number appliance functions 
minimal organization beneficial allows users see functionality interface fewer screens reduces number clicks necessary navigate functions 
creating initial interface concrete interface represented interface tree describes panel structure user interface 
children root tree represent different windows interface leaf nodes represent panels interface 
branch nodes specify child panels placed relative set panels separated vertical horizontal edges set overlapping panels 
panel described leaf node contains list rows describe controls placed relative chapter interface generation 
rows different possible layouts shown table 
layouts labeled formats preferred create simple grid labels left controls right 
controls content displayed entire panel full width row 
full width row multiple items row available screen space limited 
interface tree assembled traversing structure user interface applying set concrete interface construction rules 
types rules set creates new panel structure mutually exclusive groups specification set find appropriate concrete interaction object cio aio place cio row 
rules add structure concrete interface mutual exclusion 
rules look particular properties mutually exclusive situation create structure properties 
rules create structure final rule creates default structure fits situation 
commonly mutual exclusion rule creates overlapping panels controlled tab control sidebar non dependent items see 
rule requirements table 
row layouts supported pocketpc interface generator 
row name example description labeled column labeled column full width single control shown right optional label shown left 
space allowed label fixed panel typically available width 
controls shown right optional label shown left 
label space fixed panel value labeled column row 
control occupies entire width panel 
multiple items overlapping panels see multiple controls occupy entire width panel 
controls sized fit needs necessary proportionally enlarged fill full panel width 
row allows overlapping panel added inline rest controls 
fourth mutual exclusion structure rule discussed 
chapter interface generation set controls mutually exclusive value mutually exclusive state state labels values 
requirement necessary overlapping panel control control possible values state variable 
set controls value variable panel created user change state variable value blank panels allowed 
second requirement ensures proper labels available panels 
third requirement tabs interface multiple sets tabs quite confusing 
tabs exist structure added third rule discussed 
second organizing rule special case rule handling power button 
power button unique situation typically item specification functions specification active power variable set particular values usually boolean true 
situation second rule create overlapping panels top interface 
panels power button allows user turn appliance 
state special appliance screen shown label showing appliance name large power button 
state shows controls appliance appropriately organized see 
third rule places non dependent items mutual exclusion state panel normally 
immediately mutual exclusion state overlapping panels 
screenshots hp printer interface demonstrating mutual exclusion rules 
special power screen generated second rule 
remaining shots power view 
fax mode printer 
mode accessed tabs bottom screen created rule 
tab seen screen shots copy mode printer resize options set zoom 
resize options state mode different options created third rule 
view copy mode resize options set poster size 
chapter interface generation row added containing panel mutually exclusive sets controls 
user manipulates control mutual exclusion state top overlapping panel changed display panel currently active controls see 
interface tree creation process traverses user interface tree maintains concrete panel represents current portion interface 
set rules add rows panel aio encountered interface 
process adding new row requires steps appropriate cio chosen aio appropriate row chosen cio 
cio chosen querying aio set criteria platform specific method aio return appropriate cio platform criteria 
criteria currently supported read cio needed cio list 
criteria maximum size supported 
cio set rules choose appropriate row 
remaining rules applied rule created row 
rule checks see current cio located labeled group just cio cios buttons checkboxes 
case labeled column row created cios group label 
second rule checks cio see requires full width layout creates full width row cio 
third rule creates labeled column row cio label aio 
mentioned rules prefer labeled row formats create simple regular grid labels controls 
labeled row format provide sufficient space controls format may changed layout fixing rules discussed section 
user interface completely traversed panel structure added cios created placed rows concrete sizing panels rows cios determined 
size determined pass depth traversal concrete interface tree 
pass calculates minimum preferred size panels cios contain 
second pass determines actual size panel available screen space minimum preferred 
second pass actual panel size smaller panel minimum size row wide minimum width layout problem noted interface generator 
layout problems addressed layout fixing rules discussed section 
chapter interface generation 
interface generated gmc denali driver information console layout fixing rules rotated fit better page 
high level structure user interface underlying panel shown interface 
table 
layout fixing rules pocketpc interface generator 
problem name description insufficient height insufficient width fix tabs fix combo box panel fix vertical split fix horizontal split fix row buttons fix dialog box fix column label fix column label fix wide column breaks long panel multiple overlapping panels controlled tabs 
requires panel contains labeled groups controls placed tab tab name 
breaks long panel multiple overlapping panels controlled combo box top panel group 
fix tabs rule requires panel contains labeled groups controls placed panel panel name combo box 
breaks long panel separate panels oriented vertically 
items groups moved panel items placed panel 
allows fixing rules add organization second panel 
similar fix vertical split rule creates panels oriented horizontally vertically 
looks multiple consecutive buttons panel compresses fewest number rows possible width panel buttons labels 
looks labeled group controls panel moves group controls dialog box replaces original panel button opens dialog box 
problem occurs column row label column row replaced full width row displays control space left label 
problem occurs labeled column row label controls moved row save space displaying label 
problem occurs column row label label control placed separate rows label control 
chapter interface generation fixing layout problems rules fixing layout problems insufficient height width see table 
layout problem rules tested order rule provide fix problem 
rule fixes problem new interface searched layout sub problems apparent fix applied 
process repeated layout problems remain remaining problems fixed rules 
example interface gmc denali driver information console layout fixing rules appear long column controls shown 
column longer screen height layout fixing rules applied fix problem 
rule fix tabs rule finds long panel broken labeled groups 
tabs organize interface rule break long panel overlapping panels labeled groups 
tabs allow user navigate panels 
longer trip section broken fix combo box panel rule create overlapping panels trip information personal trip business trip groups see final interface 
smartphone smartphone interface generator produces list interfaces interfaces pocketpc desktop interface generators 
different style interfaces leads unique design challenges smartphone interface generator 
important challenge hierarchical list structure intuitive user functions quickly time minimizing number different screens generated interface 
number editing panes minimized especially prevent situations control editing pane 
part minimizing editing panes deciding particular variable manipulated list item control editing pane 
challenge navigation quicker significantly violating structure described appliance specification 
final challenge deciding function assign left soft button supposed invoke commonly function current screen 
creating intuitive list hierarchy important challenges smartphone interface generator users unable interact appliance chapter interface generation find functions want 
list hierarchy built starting topmost group user interface 
list constructed making child group labeled child list 
aio encountered added list item 
groups required labels groups interface corresponding child lists concrete interface 
may mean lists created larger shown screen rules attempt address problem generation process 
mutually exclusive set functions encountered usually additional action required changes interface structure 
result list building process set functions available separate list accessed parent list see 
case user choose set functions enabled interface appliance read mode interface generator may create overlapping lists switched state appliance see 
optimizing list structure navigation ensures users spend time finding features interface time features 
challenge optimizing balancing structure built constraints smartphone user interfaces 
constraints smartphone interface need addressed navigation particularly important smartphone interfaces items shown list screen users constantly navigate list hierarchy 
means smartphone interface generator try depth list hierarchy shallow possible place maximum number functions screen 
list structure reflect properties appliance deviate significantly initial structure 
editing panes necessary smartphone interface functions manipulated list 
example state variable enumerated type edited combo box slider supported smartphone list interface 
functions instantiated list items corresponding control editing pane 
commands seek example smartphone chapter interface generation allow screen buttons invoke commands pocketpc interfaces 
smartphone interface generator optimizes navigation rule approach 
rules applied iteratively depth traversal list hierarchy 
rules applied bottom rules applied children list applied list 
children list traversed priority order measure importance specification author defines function group appliance specification 
traversing way ensures rules flexibility optimizing important functions interface 
currently rules optimizing navigation applied order discussed 
looks particular set features list hierarchy change list set features 
rules decisions particular function displayed list item control editing pane 
discussion functions displayed list called items functions displayed editing pane called panel items functions called list panel items restrictions function may displayed aio selected function user interface 
rules minimize number editing panes may accessed current list 
rules applied current list contains panel item 

example screens automatically generated smartphone interfaces 
opening screen controlling shelf stereo 
dependency information rule created separate lists cd radio screens simulated elevator interface 
particular screen shown user depends user outside inside elevator car 
smartphone rendering media controls smart template interface controlling windows media player application desktop computer 
template design smartphone windows media player application operated right left select buttons phone thumb stick 
chapter interface generation rules searches situations number empty slots parent list greater number list items 
list items promoted parent list 
current list replaced editing pane remaining items placed pane see 
note causes panel list items displayed editing pane 
side effect occasionally creating summary panes list panel items labels see 
second rule searches situations panel item 
generator looks sets panel items labels common prefix suffix 
set editing pane created items set placed 
list item opens editing pane labeled common portion label associated set see 
originally considered having additional rule moved panel items single editing pane sets labeling item opened pane label parent group concatenated term controls decided rule believed user hard time guessing functions panel label navigation cost terms number key presses giving panel item editing pane different having panel unrelated controls 

diagrams showing second rules optimizing list structure behave 
black solid arrows indicate screens connected red dashed lines indicate changes rules 
note items list promoted top level list placed panel 
items happen labels panel summary pane 
chapter interface generation third rule looks remaining panel list panel items assigned editing pane 
list panel item assigned list remaining panel item editing pane discussed 
editing panes created item assigned editing pane list optimize number items list 
fourth fifth rules similar second rules manipulate list items 
fourth rule eliminates unneeded child lists moving items parent list room 
rule promotes important items list hierarchy traversed priority order 
fifth rule tries break lists items shown screen 
method doing uses common label prefixes suffixes just second rule 
child lists built reverse priority order current list contains items 
experimented different methods assigning function common soft button smartphone 
initially puc button move list hierarchy duplicated functionality physical back button 
helped novice phone users navigate interface felt useful assign common functions appliance button 
investigated approaches static approach priority information appliance specification adaptive approach recorded usage information 
method chooses function screen ranking functions screen priority information specification language 
tie puc chooses function occurs appliance specification 
function chosen screen functions change interface built 
second method adaptive means function assigned soft button changes user interacts interface 
puc selects function searching recorded usage information function function 
usage information puc uses algorithm method select function 
soft button currently changed time screen changes user invokes function experimenting times subject 
approach back may assigned soft button usage information suggests thing user move hierarchy 
chapter interface generation formal evaluation conducted methods 
non adaptive approach advantage users memorize function assigned interface priority information specification reliable pick right function 
example power button picked main screen shelf stereo fact function 
adaptive approach fix problem relies actual usage data cognitive load keeping track function currently assigned button high 
usually faster remember keypad shortcut function read label soft button 
may adaptive approach beneficial interface significant period time regular users smartphone interface generator verify 
methods suffer small area available label soft button 
cases possible display sufficient label space provided interface particularly name value function need shown 
solution icons puc system currently way specification author include icons label functions 
modifying concrete interface consistency preceding sections discussed phases puc interface generation process 
point process transformed appliance specification user interface modified interface ensure consistency transformed interface concrete user interface specific generation platform 
final user interface displayed user rules check concrete interface inconsistencies previous interfaces provide fixes 
inconsistencies may occur reasons 
pocketpc desktop mismatch deep hierarchy interface flat hierarchy concrete interface 
mis match introduces inconsistencies ordering controls panel discovered extra depth user interface 
second concrete interface generation may different controls organization placed panels different orientations previous user interface 
concrete consistency rules pocketpc desktop im chapter interface generation plemented address issues 
currently concrete consistency rules smartphone interface generator far need 
difficulty implementing rules determine panels correspond new interface previous interface 
current approach determining correspondence link panel highest level group contains user interface 
panel new interface corresponds panel previous interface groups panels mapping 
perfect algorithm example mix controls groups different levels specification effective cases tried date 
concrete consistency rule addresses re ordering rows panels 
panels correspond previous new interface rows panels converted block lists new block list re ordered previous list list converted back rows 
process similar re ordering user interface 
shows example reordering rule affects canon printer interface generated consistent hp printer 
second third rules address inconsistencies may arisen generation concrete interface 
second rule adds overlapping panel organization user interface previous interface control placed hp consistency canon consistent hp concrete rules canon consistent hp concrete rules 
interfaces generated hp canon printers demonstrating effects concrete interface re ordering rule 
note difference order black color cancel buttons 
chapter interface generation overlapping panels 
exact type overlapping panel widget chosen previous interface 
third rule modifies sidebar panels puc interface generator creates overlapping panels 
rule checks orientation side panel may horizontal vertical ensures orientation previous interface 
results discussion concrete interface generated modified concrete consistency rules interface user 
generation process fast run actual pocketpc smartphone devices differs interface generation systems handhelds offloaded generation remote server gajos 
complex appliance interface puc generated gmc denali navigation system takes approximately minutes generate hewlett packard ipaq pocketpc device mhz intel xscale processor running net compact framework 
appliances take minute generate 
interfaces including navigation system generate seconds current desktop computer 
consistency rules noticeably affect generation time pocketpc smartphone 
biggest impact performance time pocketpc layout fixing phase re layout interface layout fix order evaluate new layout sub problems created 
interface generator successfully generate interfaces specifications puc team authored 
discussed chapter collection specifications covers wide range appliance types includes complex specifications 
chapter shows generated interfaces usable human designed interfaces complex printers believe representative complex appliances puc system 
chapter shows consistency algorithms shown usability benefits 
interface generator trade offs 
rule approach chose benefits including allowing timely generation interfaces low resource handheld devices ability produce output input drawbacks common rule systems 
particular new rules designed carefully avoid unintended interactions existing rules 
interface genera chapter interface generation tion involves balancing trade offs rules poorly suited making decisions optimally balance trade offs 
different rule approaches iteratively improve interfaces generation pocketpc desktop interface generators start simple add complexity smartphone generator starts complex simplifies guarantee optimal result 
sensitive structure interface order rules applied 
optimization algorithms predictable require far computational resources process 
hybrid approach may successful subject research 
chapter interface generation chapter aggregating user interfaces chapter discussed puc automatically generates user interfaces single appliance 
chapter describes puc able generate user interface combines functionality multiple appliances connected system 
key input generation process content flow model describes different routes content take system source appliance possibly appliances sink appliance content displayed user recorded 
content flow model puc creates types interfaces flow interface allows users quickly specify high level goals system appliances aggregate interfaces provide low level control flow active 
interface aggregation features puc collectively known 
chapter originally published jeffrey nichols brandon chau brad myers 
automatically generating interfaces systems multiple appliances proceedings th annual acm symposium user interface software technology uist 
switzerland 
oct 
pp 
home theater presentation room 
configuration appliances multi appliance system scenarios home theater presentation room 
scenarios chapter scenarios demonstrate puc interface aggregation features home theater presentation room 
home theater setup see includes appliances television md sony audio receiver str de attached speakers philips dvd player identical panasonic vcrs pv 
setup supports common tasks watching television watching movie dvd videotape listening radio 
supports number complicated tasks copying tape vcr tape vcr watching television channel recording channels 
tasks mixed watching sporting event television listening radio broadcast play 
certain tasks impossible setup recording dvd videotape recording radio recording tape vcr tape vcr 
show puc flow interface clear user flows possible 
presentation room configuration physical devices see projector vcr laptop 
laptop functions separated independent logical appliances include powerpoint windows media player applications task manager control external video port 
configuration supports common presentation tasks showing slides showing video laptop showing video vcr tape 
chapter aggregating user interfaces content flow understanding systems appliances order generate aggregate user interfaces puc needs knowledge appliance system relates 
current integrated user interfaces built technology require new configuration information system appliances 
approach requires users typically pay professional system integrators create integrated interfaces 
puc goal support generation aggregate interfaces minimal effort part user 
ideally required user scale number appliances connected multi appliance system 
content flows appliances multi appliance system useful understanding system generating aggregate interfaces 
particular content flows important properties 
content flows closely related user goals multi appliance systems 
example home theater user may want watch dvd movie involves seeing video television hearing audio stereo speakers 
accomplish appliances home theater configured allow content dvd player flow appropriate places 

content flows system described separate flows appliance combined wiring diagram showing appliances connected 
important property divides modeling manufacturers appliances 
system specific input needed puc aggregation algorithms diagram showing appliances connected supplied application wiring technology user 
furthermore separation pushes manufacturers complexity content flow model internal flows appliance 
order support content flows sections added puc specification language specify physical ports appliance internal content flows ports see section 
content flows appliance represented different structures chapter aggregating user interfaces sources represent content originates appliance dvd player playing dvd vcr playing videotape 
display devices internal televisions receiving broadcast signals antennas defined sources content originate inside tuning device 
broadcast signals described special external source routed viewable user 
sinks represent locations content may displayed user stored retrieval 
example television screen receiver speakers vcr tape recording may sinks content home theater scenario 
represent appliance ability take content input redirect outputs 
example sion scenario capability audio receives input making available output appliances 
tuning appliances cable television set top boxes represented usually take multi channel input antenna output single channel data 
structure particularly important allows track flow content origination point multiple appliances final destination 
previous systems newman foltz sources sinks model path data system 
approach difficult know content device receiving input redirected output determining full content flow impossible 
knowledge full content flow start finish task user trying perform determined useful interface generated 
aggregation architecture puc controller device performs aggregation content flow information appliance specifications generates aggregate user interfaces information 
aggregate interface available puc allows users interfaces generated individual appliances 
view aggregation architecture shown 
puc interface aggregation requires types input order function 
requires wiring diagram describes multi appliance system wired chapter aggregating user interfaces currently specified hand xml see schema appendix 
wiring diagram contains number wire pairs corresponding physical wires connect appliances 
second input required set puc appliance specifications appliances multi appliance system 
combining information puc creates complete model possible content flows entire system see center portion generate user interfaces 
aggregate interface generation knowledge base primarily generate consistent interfaces see section 
context aggregation information allows puc create interfaces organize functions multiple appliances meaningful way 
puc produces kinds interfaces help users interact multi appliance systems 
flow interface fbi allows user quickly create activate content flows appliances tapping dragging icons desired sources sinks 
architecture aggregate interface generation features 
chapter aggregating user interfaces screen 
goal interface high level tasks easy execute multi appliance system 
puc generates aggregate user interfaces combine functions multiple appliances single user interface 
various types aggregate user interfaces support different tasks multi appliance system 
active flow control aggregate combines common control functions associated active content flows single interface goal making common content manipulations volume control easy access 
setup aggregates infrequently configuration parameters easy user access goal supporting expert usage appliance system 
aggregates merge functions occur multiple appliances single point control interface 
allows user things set current time aggregate change automatically broadcasted appliance system 
flow interface fbi designed allow users quickly specify flow source content content sinks 
example user specify flow dvd player disc television screen receiver speakers 
user activates flow puc inspects dependencies flow elements generates plan satisfy dependencies executes plan enable flow 
flow enabled active flows user specified system prompt user dialog box attempt help user resolve problem 
examples fbi shown 
idea fbi clear interaction user interface order start watching dvd movie described 
shows fbi initial blank state 
near top screen blank flow empty spaces source sink arrow 
bottom screen appliance bar contains icon corresponding appliance source sink system 
appliance bar may grow upward allow space available appliances system shown 
appliance icons currently assigned hard coded matching function interface generator version download icons appliances internet 
additional flows may added screen pressing add flow button top screen scrollbar right allows scrolling chapter aggregating user interfaces flows added list shown 
envision usage scenarios interface user creates flows common tasks switches user uses just flow modifies necessary suit current task 
user wishes flow icon dragged appliance bar empty spaces blank flow 
empty space highlights icon dragged indicating appliance icon may placed 
dvd icon placed source location see content type icons appear left side arrow icons appliance bar corresponding appliances sinks dvd player source grayed 
includes icons correspond sources broadcast television radio icons vcr icons sinks dvd content home theater particular wiring configuration 
user see receiver television available appliances dvd player 
scenario user drags television empty sink space flow 
point green play button enabled configuration corresponds valid flow note television speakers sink audio content 
asterisk arrow right side indicates flow interface infer type content route television specified sinks 
user wishes add receiver additional sink 
split button pressed underneath arrow left 
causes flow split arrows new empty sink space created see 
add receiver speakers sink user drag receiver empty space 
scenario puc able automatically infer tv speakers audio sink added flow 
user wanted audio come sets speakers 
example flow interface configure dvd player play video television audio routed stereo speakers 
chapter aggregating user interfaces indicated tapping content type icon television selecting audio video content type 
user click play icon flow title bar invokes planner automatically activate flow 
successful plan appliances automatically configured play icon turn green icon turn white bubble appear inform user flow activated 
shows interface user dismissed bubble 
plan bubble appear help user resolve problem see 
difficulty planning algorithms graphplan algorithm puc uses produce useful error messages planning fails 
puc uses approximation checks search conflicting appliance variables active flows allowing useful error message produced 
conflict check searches dependencies newly specified flow see read variables values activating new flow impossible 
variables usually reflect physical status appliance user address informed 
example variable dvd player set false user pressed play icon previous example 
happened system ask user rectify problem 
current language error message somewhat provide predefined strings common problems disc dvd player see 
puc checks variable conflicts checks see currently active flows conflict new flow 
perform check examines dependency information associated newly specified flow dependencies active flows looking variables value flows active simultaneously 
situation puc immediately goes back user ask conflicting flows user wants 
puc obvious conflicts exist executes planning algorithm find valid plan activating new flow 
plan system carry plan create right configuration variables activate new flow maintain state existing flows 
planning algorithm may fail second order dependencies conflict 
experience conflicts rare occur puc asks user choose finding plan activates chapter aggregating user interfaces specified flow disables currently active flows finding plan activates specified flow considering effects flows 
plan case user prompted carrying plan clear flows deactivated new plan 
fbi provides way navigate aggregate user interfaces puc interfaces individual appliances 
upper right corner fbi navigate pull menu allows user navigate different aggregate user interfaces generated discussed 
double clicking appliance icon appliance bar flow allows user navigate full interface individual appliance 
aggregate user interfaces fbi provides interface users accomplish high level goals system watching dvd movie home theater 
need provide user finer grain control individual appliance functions 
example user may wish pause dvd playing take phone call go slide powerpoint presentation 
user discover movie dark requiring adjustment brightness television keystone setting needs adjusted projector 
address problems puc provides user aggregate user interfaces combine functions appliances system create useful task specific interfaces 
puc currently generate different active flow control active flow setup general setup merged functions 
important note user access time full interfaces appliance 
goal provide access full set appliance functionality particular aggregate interface provide interfaces meaningful sets functionality appliances system user current task 
active flow controls active flow controls aui combines commonly functions related currently active flows 
show examples active flow control aggregates generated active flow playing dvd receiver television chapter aggregating user interfaces 
active flow control interfaces playing dvd movie video shown television audio coming stereo speakers presenting powerpoint slides projector watching broadcast television audio playing television speakers watching broadcast television audio playing receiver speakers 
note volume control appear controlling different appliances 
controlling presentation room copying tape vcr watching television audio coming television receiver speakers 
puc identifies functions active flow controls aui stages 
stage functions extracted appliance specifications mentioned flow dependencies currently active flows noted related appliance content flow model 
second stage functions filtered select common functions users want manipulate 
puc uses heuristics filtering stage information available specification directly identify commonly functions appliance 
heuristic eliminate functions associated setup nearly specifications contain high level group name setup similar 
group identified knowledge base achieving consistency 
puc uses knowledge base mapping information identify setup group appliance filters functions contained setup groups 
second heuristic eliminates functions modified cause flow active 
eliminates power functions easily accessed input select variables stereo television vcr tv functions vcrs situations number variables may common overlap functioning fbi 
exceptions rule media control functions play pause included 
chapter aggregating user interfaces user may deactivate flow pressing eject feel users annoyed functions easily available users easily recover functions way deactivates flow 
active flow setup active flow setup aui combines setup functions related currently active flows 
puc identifies functions aggregate stage process active flow controls aui 
earlier aggregate second stage filtering process aggregate takes functions setup group 
process typically finds functions affect output currently active flows infrequently brightness contrast controls television speaker level controls receiver 
aui include controls cause flow active best controlled fbi 
active flow setup aui organized appliance desired setup function typically easier find organization 
see shots active flow setup interface generated flow dvd receiver television 
originally tried organize aggregate content type case home theater give top level groups audio video created lower quality interfaces 
approach worked reasonably appliances functions classified place content flow receiver television flows receive audio 
shots active flow setup aui dvd player receiver television flow 
note interface organized appliance shown tabs bottom screen 
chapter aggregating user interfaces video content respectively 
appliances handled audio video content approach relied knowledge base ability identify sub groups corresponded audio video 
possible approach viable improvement consistency sub system 
general setup general setup aui see combines setup functions appliances related content flow 
functions typically include things parental content restrictions time functions software upgrade controls configuration defaults 
functions aui extracted iterating specifications appliances eliminating functions previous 
additional filtering step removes functions setup group 
general setup aui organized high level collections functions identify existing appliance appliance 
attempt identify high level collections knowledge base search toplevel groups setup groups may name 
groups name may identified uniform contents identified similar 
groups catch groups preferences large variance types functions contain 

shots general setup aui home theater setup 
note shots tabs bottom screen represent high level concepts functions organized appliance combo boxes top 
chapter aggregating user interfaces merging controls settings system appliances single value set migrated appliances requiring user laboriously set value appliance 
examples include time clock language english sleep timer turns appliance selected number minutes 
settings occur appliances merged 
example usually wrong set channel vcrs television value simultaneously set devices powered time 
setup functions combined depending particular function similar functions appliance types 
example dvd player television contrast setting inappropriate set simultaneously 
merged functions aui handles small number functions appropriate combine see 
previous aggregates knowledge base identify similar functions appliances merged 
interesting explore volume function merged appliances flat volume technique developed baudisch baudisch 
shown apply quite volume unclear applicable kinds settings brightness contrast 

merged function aui featuring clock language sleep timer functions single panel 
chapter aggregating user interfaces discussion important concept design puc interface aggregation content flow model help users accomplish high level goals 
approach constrained domains home presentation rooms believe extended support features discussed 
example detailed modeling content types able find content flows users goals find optimal path particular content user viewing 
particularly important problem types content home theater grow encompass numerous high definition video audio standards may supported varying levels different appliances different types wires 
problem considering content flows help puc understand lights order view projected powerpoint presentation 
extreme solution extend content flows way final content sink user eyes ears require extensive modeling room lighting user perceptual capabilities order successful 
practical approach may provide basic models lights projectors interact environment content sinks important locations room allow puc reason interactions appliances environment 
content flow concept prove extensible appliance domains videoconferencing systems manufacturing processes 
aggregation approach limited correspondence content flows tasks user wants perform 
correspondence scenarios considered approach works 
scenario puc may effective kitchen tasks center recipes 
recipes content flow appliances suggests content flow may descriptive generate useful task interfaces kitchen appliances 
chapter aggregating user interfaces chapter usability evaluation studies generated interfaces conducted examine usability interfaces generated puc 
study compared generated interfaces existing interfaces functionality hypothesis interface quality longer limiting factor automatically generated interfaces 
results users automatically generated interfaces twice fast times successful users existing interfaces set independent tasks varying difficulty 
second study examined puc algorithms automatically generating interfaces consistent user previous experience see chapters 
hypothesis automatically generated interfaces provide benefits shown study user customizations impractical human designers provide 
study users trained tasks study interface 
users successfully perform tasks asked perform tasks second different interface similar functionality 
results showed users twice fast second interface generated puc chapter submitted publication jeffrey nichols chau brad myers 
demonstrating viability automatically generated user interfaces submitted publication 
consistent interface compared second interface generated consistency algorithms disabled 
user studies compare interfaces different printer appliances hewlett packard hp high quality interface including color lcd canon mp features interface turned harder learn hp 
represented top line consumer models manufacturers complex printers available home time purchase 
printers chose appliances studies reasons complex appliances typically difficult trivial ones wanted test puc appliances challenging generation algorithms 
printers complicated appliance types explored containing variables commands hp canon 
chosen studies different main functions including copying scanning photo manipulation represented user interface 
special configuration options main functions initial setup process difficult time consuming 
possible puc control printers simulating control easy achieve configuring computer print documents printers correct appearance task user currently performing 
resulted realistic setting users puc interfaces allows better comparisons puc interfaces existing manufacturers interfaces 
existing manufacturers interfaces printers comparisons conducted studies 
puc generated interfaces microsoft pocketpc device see 
discussion user studies starts description interfaces compared common protocol studies 
followed sections presenting discussing results studies 
chapter usability evaluation hp printer consistency canon printer consistency hp printer consistent canon printer canon printer consistent hp printer 
pocketpc interfaces generated personal universal controller puc printers discussed 
interfaces studies compare puc generated interfaces manufacturers human designed interfaces appliances compare puc generated interfaces consistency different printers 
manufacturers interfaces shown 
puc specifications printers needed order puc generate interfaces 
wrote initial specification canon printer staff member wrote initial specification hp printer 
different writers specifications specifications consistency user study wanted specifications contain similarities differences realistic scenario specifications written separately different manufacturers 
specifications written approach actual specification writers expected take 
writers generally faithful design actual appliances took advantage features puc specification language 
example language allows multiple labels function added extra labels detail necessary 
puc language calls writers include organizational detail possible order support generation devices small screens chapter usability evaluation canon mp hp 
printers studies larger view built user interface 
chapter usability evaluation followed guideline 
initial specifications tested interface generators ensure correctness went iterations deemed high quality studies 
note testing similar debugging program iteratively testing user interface necessary ensure functions forgotten understandable labels advantage puc system improvements needed migrate properly interfaces generated platform 
note specifications included features appliances features tested 
resulting generated user interfaces complete represent features accessed appliance user interfaces 
specification hp consists lines xml containing variables commands specification canon lines xml containing variables commands 
puc consistency algorithms need information similarities specifications see chapter 
automatic system generate initial set mappings printer specifications 
revised resulting mappings produce complete set consistency study 
specifications mappings puc produce different interfaces studies puc hp consistency puc canon consistency puc hp generated consistent puc canon interface puc canon generated consistent hp see 
combined built interfaces printers results total interfaces studies 
complete screenshots interfaces viewed appendix protocol subjects puc interfaces short tutorial interface pocketpc handheld device 
necessary puc design assumes users familiar device pocketpc interface quirks frustrate users aware ok button dialog boxes located title bar top screen 
intention puc people personal devices reasonable expect familiar user interface device 
chapter usability evaluation subjects performed block tasks interfaces just described 
completing tasks subjects received instruction quickest method performing tasks just performed 
receiving instruction task subjects required perform task errors 
additional instruction available tasks needed subject 
instruction period completed successfully subject performed second block tasks different interface printer 
goal instruction subjects capable possible appliance testing second appliance 
simulated scenario expert user new appliance familiar functionality expect impact puc consistency algorithms 
task blocks users required perform task provided user manual instruction printer interfaces 
users allotted maximum minutes perform task allowed move task succeeded maximum period complete 
chose minutes pilot studies suggested subjects finish window succeed 
recorded time took subjects complete task 
subject finish allotted period recorded completion time minutes marked task completed 
protocol independent variables type interfaces subject order subject appliances 
different configurations interface type studies built built interface followed built interface hp followed canon 
autogen puc interface consistency appliance hp followed puc interface consistency canon 
consistent autogen puc interface consistency appliance hp followed puc interface appliance canon generated consistent interface hp 
chapter usability evaluation consistent autogen configuration designed fulfill assumption puc consistency algorithms assume users receive benefit consistency encounter new device familiar previous interface 
configurations allow testing usability consistency 
usability tested comparing built configuration 
consistency tested comparing autogen consistent autogen configurations 
test configurations possible orderings hp followed canon vice versa subjects study design 
subjects design possible learning carefully controlled compare performance usability consistency studies 
tasks tasks designed subjects perform block study 
tasks chosen realistic printer cover wide range difficulties independent possible success failure task affect subsequent tasks 
point especially important minimize possibility subject notice element task working earlier task 
effect minimized somewhat presenting task description subjects completed previous task prevent subjects working second block remembering tasks block 
tasks order subjects listed 
order tasks varied subject learning effects exist tasks despite best efforts eliminate effects subject 
task wording paraphrased brevity exact wording tasks appendix 
send fax number stored third speed dial 

configure fax function number busy 

configure fax function document received larger default size resized fit default 

configure fax function print error report problem receiving fax 
chapter usability evaluation 
black white copies document placed scanner printer 

imagine find copies dark 
improve changing setting device 

page picture determine produce page instances picture repeated 

device remembers current date time 
determine interface values changed changing required 
tasks carefully written language favored user interfaces tested 
cases easy interfaces terminology 
cases words appear interfaces 
example documents language demonstrate goal task 
participants subjects male female volunteered study centralized sign web page managed carnegie mellon university 
subjects students cmu university pittsburgh average age median age 
subjects older years 
subjects paid time varied minutes hour half depending configuration interfaces 
subjects randomly assigned conditions 
evaluation usability evaluate usability puc interfaces task completion times failures built condition compared conditions 
analysis data block condition interest second block influenced differently subjects experiences block 
results shows average completion time tasks appliance comparing built condition conditions combined refer puc condition 
note data autogen consistent autogen condi chapter usability evaluation tions combined interfaces block conditions 
compare completion times failures block conducted way analyses variance 
analyses built condition puc condition 
table shows data detail analyses comparing user performance task 
hp appliance subjects significantly faster total task completion time puc interface completing tasks half time puc interface vs built interface 
subjects failed significantly puc interface fifth failures puc interface compared built interface total failures users vs 

results block tasks showing built condition compared appliance 
tasks total time hp built puc canon built puc failures hp built puc canon built puc table 
average completion time total failure data block tasks 
puc condition combination autogen consistent autogen conditions 
built condition puc condition 
indicates significant difference built puc conditions appliance indicates marginally significant difference 
completion times total failures compared way analysis variance failures task compared fisher exact test 
chapter usability evaluation subjects difficulty canon interfaces compared hp interfaces conditions see significant benefits puc interface built interface 
subjects significantly faster puc average total completion times puc interface built interface half time 
subjects failed significantly puc total failures users tasks puc interface total failures built interface fewer failures average 
performed analyses comparing built condition combined puc condition data second block tasks 
analyses significant matched results block number failures tasks hp printer 
case failures analysis possible zero failures subjects puc hp interface failure subjects built hp interface 
discussion usability results show users perform faster tasks puc interfaces compared printers built interfaces 
canon printer puc interfaces significantly faster nearly individual tasks tasks marginally significant task automatically re dialing busy number different 
task task failed users puc interfaces canon wide margin 
believe task particularly hard users canon printer configuration features sending receiving faxes complex seemingly overlap unrelated functions language difficult understand 
functions difficult represent cleanly puc specification language may carried complexity generated interfaces 
fewer individual tasks hp printer puc interface significantly faster built interface tasks 
believe hp printer designed interface perform especially easier tasks 
tasks puc interfaces excel generally difficult tasks tasks require users find obscure settings deep interface 
chapter usability evaluation minute maximum completion time chosen goal limiting failures total tasks 
data subjects performing tasks total tasks failures recorded 
gives failure rate high goal range 
time measurements cut minutes worry biased results 
failures built condition 
suggests results show built condition slower correct allowing time condition slower 
study usability block tasks compares performance novice users 
question puc equally successful expert users 
users experts mistakes probably benefit harder built appliance interfaces puc interfaces 
fewer steps required navigate functions puc interfaces 
furthermore puc interfaces provide visual context user current location interface 
believe features allow users experts puc interface faster built interfaces perform faster experts 
results second study suggest may true discussed section 
evaluation consistency evaluate consistency completion times interfaces autogen consistent autogen conditions compared second block tasks 
compare built condition consistent autogen condition see consistency improve today appliance interfaces 
results shows average completion times task second block autogen consistent auto gen conditions 
table shows data detail includes built condition failure data conditions 
oneway compare completion times various conditions 
failures discussed nearly subjects able complete tasks autogen consistent autogen conditions results analyses failures shown table 
chapter usability evaluation subjects canon printer hp significantly faster total task completion time consistent puc interface compared normal puc interface built interface 
total completion time consistent puc interface average twice fast normal puc interface vs times faster built interface vs 
hp printer subjects significantly faster consistent puc interface canon printer compared normal puc interface built interface 
average total com 
results second block tasks showing autogen condition compared consistent autogen condition appliance 
tasks total time hp autogen consistent built canon autogen consistent built failures hp autogen consistent built canon autogen consistent built table 
average completion time total failure data second block tasks 
conditions 
indicates significant difference row condition consistent autogen condition appliance indicates marginally significant difference 
completion times total failures compared way analysis variance failures task compared tailed fisher exact test 
chapter usability evaluation time consistent puc interface twice fast normal puc interface vs times faster average built interface vs 
appliance subjects considered possible compare total completion times blocks tasks conditions 
built autogen conditions significantly different block second built condition marginally significant autogen condition may direction 
consistent autogen condition significantly different block second 
discussion consistency results show users perform faster tasks consistent interfaces compared interfaces 
effect appliances due tasks 
expected normal puc interfaces appliances consistent tasks benefit change consistent interfaces 
hoped see consistency effects remaining tasks factors affected tasks 
change ensure consistency task copying involved changing placement copy cancel buttons screen see 
apparently visual search new button placement affect subjects speed compared normal puc interfaces 
change ensure consistency task changing fax error printing 
function needed task located fax configuration functions located different places appliances fax mode hp setup section canon interface 
change consistency performed puc move configuration functions location user originally saw 
observations subjects actions appeared manipulation worked studies 
unfortunately error reporting function different appliances way puc consistency system manipulate 
hp interface consistent canon interface users needed time understand functions different correct change 
canon interface consistent hp interface interface generator chapter usability evaluation nate choice placing needed functions dialog box accessible pressing button 
button open dialog placed buttons distracted subjects button needed find 
tasks see significant benefit consistency appliances 
tasks marginally significant benefit consistency just appliance task hp task canon 
similar task tasks slightly different appliances ways puc consistency system change 
believe means subjects able leverage previous knowledge spend time thinking appliances worked slowing 
important note situations puc consistency algorithms interface significantly worse users task canon interface generated consistent hp 
consistency system able provide benefits similarities appliances hurt user differences 
question ask benefits appear consistency due factor generation process 
believe rules added consistent interface generation changes new interface differences previous interface user seen 
rules perform modifications improve user interface independent consistency 
discussion studies limitations 
type appliance printers tested instances type 
discussed earlier believe printers chose representative complex appliances 
require puc specification language advanced features lists smart templates see chapter 
printers carefully chosen complex representative different common interface styles 
chose hp part estimation best interface printer available 
studies shown puc generate interfaces exceed usability manufacturers interfaces 
automatic generation create appli chapter usability evaluation ance interfaces allows flexibility design interface allows interfaces modified particular user 
consistency feature studied example second study showed consistency beneficial users 
manufacturers may object consistency branding may removed interfaces worse branding competitor may added place 
position branding affects usability appliance custom labels certain functions particular sets steps needed complete particular tasks user consistency system allowed modify 
branding marks names logos preserved appropriately 
support branding marks consistency marks feature may added puc system 
important question allows puc generate interfaces better built interfaces appliances 
needed improve built interfaces 
believe puc interfaces better appliance interfaces reasons 
puc instance control multiple functions 
buttons sliders puc interface function 
contrast appliances overload multiple functions buttons 
example printer interfaces provide number multi purpose buttons control panel including directional pads ok buttons number pads see behavior changes depending function selected printer menu 
particular problem manufacturer interface canon modes certain buttons feedback 
users experiment determine buttons pressed situations 
puc addresses feedback problem controls currently available 
puc screen allows longer better labels shown function 
screen allows dimensional layout give clues organization interface 
example tab control allows users see immediately multiple groups controls groups 
functions displayed main portion screen grouped functionality decreases number functions screen may interface easier parse 
order improve built interfaces usability puc manufacturers probably need invest larger screens appliances 
screens allow organization interface clearer hopefully eliminate need chapter usability evaluation multi purpose buttons 
physical buttons functional indicator lights show button pressed 
problems poor labels addressed basic user centered iterative design 
question remains economical manufacturers improvements 
screens indicator lights buttons add substantial manufacturing cost appliance low profit margin 
usability marketing point clear consumers value price instances 
believe puc excellent solution appliance manufacturers currently find situation 
chapter usability evaluation chapter preceding chapters shown puc system able generated user interfaces usable interfaces built today appliances 
puc system extended interface generation technology support design interfaces personally consistent individual user information content flow call produce aggregate interfaces systems multiple appliances 
chapter discusses high level issues surrounding puc system describes puc systems impact date reviews contributions dissertation describes possible directions 
discussion puc system designed specifically produce interfaces appliances 
generate kinds interfaces limited scope applications supported 
application needs dialog box style controls interfaces generated 
puc may able produce interfaces applications need display large amounts data support complex data structures capability rigorously tested appliances tested far 
applications manipulate long text strings mail editors theoretically handled puc framework current interface generators limited support rendering large text boxes interface 
application interfaces generated puc 
particular puc support generation applications direct manipulation painting circuit design applications 
support direct manipulation limitation previous model systems able support direct manipulation required substantial extra modeling effort provide information allow interface generator produce reasonable interface 
systems required designer involvement process guide generation fix mistakes 
limitations puc system illustrate fundamental trade modeling effort ability generator produce complex interfaces 
highly detailed model may allow interface generator produce highly complex interfaces support direct manipulation building model necessary amount detail may require substantial effort 
design puc system explicitly tried optimize trade appliance interfaces 
preliminary user studies allowed design specification language contains sufficient information generate usable interface concise easy 
accomplish appliance interfaces subset possible interfaces 
optimizing specification language conciseness ease resulted including features commonplace model systems 
significantly puc specification language include task model 
appliances task information necessary tasks step 
example play tape increase volume involve pressing button sliding slider 
complex tasks programming timed recording vcr rendered understandably puc steps dependencies steps 
today appliances interfaces may require complicated inter dependent steps complete tasks complication inherent appliance functionality due limited interface capabilities appliance 
puc limited ability provide interface tasks accomplished interface complicated steps 
biggest challenges puc consistency algorithms appropriately dealing unique functions organization similar appliances 
chapter chapter describes heuristics address problem solutions limited lack useful semantic information unique functions 
part due puc relative semantics understand similarity puc knows functions similar similar relate functions appliance 
better information puc informed decisions place functions create new organization 
course better information come cost additional modeling appliance detailed information automatically extracted appliance specifications 
large part multi appliance interface problem discussed chapter arises multiple appliances connected requires user interact multiple interfaces accomplish single task 
obvious solution integrate appliances single monolithic appliance interaction designer carefully construct user interface 
fact solution seen consumer electronics shelf integrate amplifier cd player radio audio devices 
problem approach allow innovation 
audio appliances integrated years ago today place devices 
puc allows users easily interact systems appliances enables appliance manufacturers pursue design new appliances may added systems 
guarantee interface produced manufacturer integrated appliance usable functionality multiple appliances integrated single monolithic appliance 
fact combined appliance interface probably harder design complicated functions integrated appliance support single appliance 
examples current systems suggest manufacturers succeed difficult design challenge brouwer gomes 
system puc succeed product real world important ask questions consumers find value system 
manufacturers support system 
years usability important criterion consumers purchasing new appliance brouwer 
price features important chapter factors appearance brand 
consumers purchase products puc technology usability need important factor buying decisions 
think reason believe consumers buying habits may changing 
example dominates market large part highly usable 
reviews technology products particularly web sites cnet com routinely evaluate usability usual factors price performance 
course customers decide buy products include puc manufacturers need include technology products 
issues manufacturers technology importantly loss control products interfaces 
manufacturers want include branding marks interfaces want assurance customers attribute fault manufacturer poor interface generator produces bad interface product 
current puc system support including brand marks feature added 
unfortunately obvious solution second problem educating consumers 
hope manufacturers may find issue concern consumers demand usable interfaces puc offer interfaces cost hand designing interfaces house 
puc devices provide far better interaction hardware cost effective put appliance 
hope manufacturers willing adopt puc technologies shown interface generation offer benefits possible hand designed interfaces actual appliances 
particular ability puc provide improved interfaces automatically systems multiple appliances implemented generation approaches 
considerable value generating interfaces personal consistency shown evaluation 
generation consistent interfaces issue concern manufacturers particularly branding concerned 
current version puc consistency system quite changes inappropriate copying label appliance interface interface appliance competing brand 
example mitsubishi appliance automatic rewind function labeled appliances interactions sony cd players different behavior track button manufacturers pressing track button sony immediately starting player chapter advances track track 
difference interactions described specification language differences copied inappropriately new interface consistency algorithms 
philosophy branding manufacturers interactions may detrimental usability appliance 
situations exactly described previous section 
appropriate manufacturers logos brand marks maintained consistent user interface different names behaviors functions appear appliances just confuses users 
course manufacturers agree puc system probably altered allow certain interactions preserved consistency algorithms 
may possible simply allowing markers added specification define labels configurations state variables commands changed consistency algorithms 
cost important factor affect manufacturers adopt system puc 
puc requires features way communication access functions appliance support reliable physical communication layer ir bluetooth wi fi zigbee 
features add development cost new appliance changing appliance software writing functional specification 
features add manufacturing cost unit adding new hardware support new wireless communication protocol 
increase manufacturing cost substantially worse increase development cost manufacturing cost increases multiplied number units produced 
increases development cost support puc may substantial 
example manufacturers develop form functional specification part product development process 
specifications may include kinds information puc specification provide starting point 
intuition writing puc specification appliance add substantially development cost appliance current industry practices 
manufacturers working add support general communication infrastructures upnp appliances 
technologies similar server side requirements needed puc supporting access state appliance notify external entities state changed 
possible chapter existing implementations infrastructures may easily adaptable support technologies puc 
extra development manufacturing costs support puc may offset reduction costs 
particular manufacturers may choose reduce complexity appliance interfaces favor making functions available puc interface 
choice reduce development cost physical interface developing simpler interface cost complex manufacturing cost unit fewer buttons smaller screens needed simpler interface physical appliance 
unfortunately cost trade may occur appliances initially deployed puc technology manufacturers may unwilling certain functionality available interface technology achieved broad acceptance 
unfortunately development costs increase order build puc technologies appliances 
need motivating factors manufacturers justify extra cost incurred adding functionality 
possible motivations increasing usability appliance adding accessibility appliance interface users disabilities goal integrating appliance interface appliances may connected 
remains seen issues motivate manufacturers adopt standards add technologies appliances 
impact puc system adopted manufacturers computerized appliances affected development standard different research groups specification language component project undergraduate class university alabama 
group described section developing standard moving interfaces appliances remote control device puc purpose providing accessible user interfaces users physical cognitive disabilities 
initial draft specification sufficiently functionality appliance allow generation interfaces wide variety platforms meet requirements needed system provides remote chapter control appliances see section 
provided initial analysis technology nichols interactions led standard adopt design decisions included puc system 
current version standard improved puc share differences 
information available similarities differences puc system nichols 
puc system research projects 
group technical university vienna led dieter puc research augmented reality applications 
project puc provide handheld control augmented reality characters resulting publication leading augmented reality conference 
shows example puc action project 
group italian researchers integrated puc system middleware system called 
system allows communication common device communication protocols including upnp 
puc provides user interface capability middleware allowing users control upnp devices 

puc control character augmented reality application part performed puc technical university vienna 
tracked pocketpc multi purpose interaction device left tangible interface screenshot ar lego application right pda screen capture lego robot control gui 
reproduced permission 
chapter puc specification language component project conducted spring semester cs generative programming class university alabama 
goal project provide framework allow mobile application run device regardless device operating system interaction technologies 
students initially tried languages xul laszlo describe user interface form rendered differently multiple platforms 
discovered puc language fit requirements producing interfaces 
students produced rudimentary code generator puc language continued summer reu undergraduate research project 
collectively projects show puc system value researchers outside puc research team 
projects show need distributing user interface different platforms puc technologies accomplish goal 
furthermore existence projects suggests puc technologies easy learn people adopt successfully little support contributions dissertation describes complete system improve usability today complex computerized appliances moving user interface handheld device user carrying 
interfaces automatically generated customized controller device user particular configuration appliances user 
generation process supported specification language capable describing complete functionality wide range appliances 
language tested authoring study showed authors previous experience learn language hours write complete specification low cost vcr hours 
dependency information specification language interface generators infer structure user interface 
dependencies multiple sets functions mutual exclusive interface generator take special action placing sets functions separate overlapping panels 
smart templates technique allows domain specific design conventions referenced appliance specifications rendered appropriately generated interfaces 
templates chapter parameterized allowing templates specifications different appliances different functionality 
templates described primitive elements specification language allows interface generators render template generator pre programmed understand template 
support consistency language developed describing semantic similarities appliance specifications 
language describes similarities relative terms sufficient ensuring consistency may easier specify ontology techniques 
puc rules achieve consistency generated interfaces 
rules ensure functional structural consistency heuristics ensure usability unique functions harmed changes consistency 
evaluations rules showed users twice fast new interfaces generated consistent compared interfaces generated consistency rules 
content flow useful model describing tasks users may wish perform system multiple connected appliances home theater presentation room 
flow interface allows users specify execute high level tasks system 
aggregate interface generators created content flow combine functionality multiple appliances produce useful task interfaces 
puc graphical interface generators implemented different platforms including pocketpc microsoft smartphone desktop computers 
collaborated research group produce speech interface generator puc framework demonstrating puc specification language sufficiently create interfaces multiple modalities 
puc interface generator evaluated show subjects interfaces produced system twice fast times successful compared interfaces currently available today computerized appliances proving thesis underlying 
directions build dissertation 
chapter far built graphical interface generators different platforms mobile platforms interface generation implemented 
interesting build generators platforms substantially different looked 
example smart phones manufacturers similar interface styles microsoft smartphone platform interface generator supports 
interesting platform explore limited interaction capabilities smart phones 
support platform necessary build user interface supports common functionality appliance creating interfaces full functionality appliance current generators 
challenge reliably determine functions users want full appliance specification 
group tree priority information specification language contain information help making decision determining proper threshold functions keep versus functions omit may difficult find 
particular unfortunate appliance set items list commands operate list set included generated interface 
interesting create interface generator web interfaces 
generator able integrate ideas existing generators adapt web page layout particular device web pages rendered 
new web technologies create appliance interfaces web page similar levels interactivity interfaces currently generated puc 
interface generators built existing platforms interesting build new device specifically designed support puc system 
today high universal remote controls touchscreens number physical buttons controlling common functions volume channel see latest philips puc designed control broader range appliances just home equipment 
physical buttons appropriate puc 
soft buttons trade assigning functionality versus showing functions organized hierarchy done puc current generated interfaces 
chapter generation rules implemented puc interface generators 
current rules sufficient generating interfaces appliances specified room improvement 
rules improve generation interfaces lists especially helpful puc currently rules dealing common types list structures 
rule creates grid certain dimensional list structures lacking 
list data supported current smartphone interface generator need port current rules pocketpc develop appropriate controls differentiate lists functions basis smartphone interface lists data stored appliance 
interesting approach explore mixing optimization approach generating interfaces supple rule approach puc currently uses 
numerical optimization algorithms useful converting user interface concrete layout example benefit information puc mutual exclusion rules specifying particular organization interface 
optimization useful achieving structural consistency interfaces rules may needed ensure unique functions handled appropriately predictably 
key resource constrained platforms handheld devices puc limit optimization areas provide benefit providing reasonable performance 
directions explore specification language 
firstly authoring study discussed chapters designed primarily explore inconsistencies specifications understand usability issues language 
depth authoring studies valuable better understand difficulties users writing specifications improve language 
secondly current authoring study suggested valuable create tool assist users creating new specifications 
existing tools writing xml helpful writing specifications language properties conducive direct xml editing 
example typical process writing specification enumerate state variables commands organize appliance objects appropriate group hierarchy 
reorganizing hierarchies difficult xml better supported direct manipulation interaction 
object names change organization changes tool manage names automatically 
chapter third direction explore specification language analyze additional information added 
latest version interface description language features may useful add 
design separates labeling information functional interface description places labels separate resource file 
particular resource file interface generation may changed support different locales example users different cognitive abilities 
functional specification includes notification construct represents quick dialog box style interaction displayed event occurs appliance 
puc support text alert dialog boxes displayed request appliance dialogs specification language appear response special sent communication protocol 
specifying messages explicitly allow language dialog box modified interface generator 
appropriate example part interface mentioned dialog box modified consistency rules 
puc consistent interface designs basic requirements discussed section 
requirements current consistency highlevel benefit elaboration 
particular different dimensions consistency achieved 
lexical consistency requires interfaces labels functions 
functional structural consistency defined earlier mean respectively functions controls functions located location 
related different dimension structural consistency navigational consistency requires users take steps navigate function 
navigational consistency implies structural consistency example interfaces structurally consistent consistent different controls navigate different areas interface 
visual consistency means interfaces roughly appearance dimensions 
differences appliances possible achieve consistency dimensions simultaneously 
needed examine trade offs different dimensions understand dimensions important users productivity 
lexical consistency example constant requirement structural consistency important chapter visual consistency puc consistency rules adapted put emphasis visual aspects consistent interfaces 
valuable explore value consistency versus amount similarity appliances 
dissertation focuses achieving consistency appliances share similar functions appliances share functions 
appliances similarities need consistency rules changes 
functional consistency rules nearly helpful structural consistency rules just harmful helpful 
similar functions different appliances may different context disrupted function moved 
furthermore experience home theater appliances noticed different appliances share high level structure control setup groups high group hierarchy little low level hierarchy 
situation moving rule may move function deep hierarchy child high level group 
moved function prominent appropriate 
needed understand situations structural consistency rules help hurt knowledge integrated consistency rules 
possibility may revisit ideas sparse branch significant consistency discussed nichols need software able reliably detect types consistency 
particular threshold number similar unique functions groups different appliance specifications sufficient specify groups sparse significant 
consistency algorithms rely entirely similarity information contained puc knowledge base 
assumed knowledge base contain false mappings similarity information collected automated schema mapping algorithm 
needed understand impact errors knowledge base current consistency rules rules changed mitigate problems arise 
needed mapping algorithms 
particular interesting explore mapping improved leveraging existing content knowledge base 
knowledge base provide information match 
possible knowledge base contain information sources false positives mapping algorithm filter generated mappings reduce errors 
chapter puc consistency algorithms ensure personal consistency ordering effect new interfaces generated previous interfaces 
aspect previous interfaces bad low quality element copied new interface 
requirements consistency algorithms support user choice users control consistency applied choose best possible interface 
interface allow users choices implemented 
unclear users know better interface available see consistency algorithms 
additional needed understand users aware options build interface allows choice 
interfaces generated previous interfaces opportunity seed consistency system high quality interfaces variety different common appliance types 
interfaces actual appliances modified consistency rules high quality interfaces hopefully producing higher quality result 
concept applied individual functions ensuring certain annoying situations unneeded confirmation buttons occur interfaces 
experimented idea interesting see far technique taken produce improved interfaces 
puc currently provide mechanism user customizations 
target users trained interface designers may wish modify interfaces produced system 
mechanism take form interface builder designed structure underlying specification language 
customizations noted consistency system influence design interfaces 
possible users create macros automate certain functions appliances 
important problems multi appliance systems puc currently address helping initial wiring system trouble shooting problems occur 
features added puc lieberman approach relies planning system similar puc wiring problems addressed tool helps users specify diagram needed build puc system wide content flow model 
tool help users determine best wire system support flows expect 
worth noting takes different approach configuration including wiring instructions plans generates user task user system 
ensures chapter users able perform task possible configuration system better perform kind analysis setup time experience users want system regular basis 
puc currently generates different kinds aggregate user interfaces interesting explore improving existing set building new kinds aggregate interfaces 
promising direction usage aggregate interface ideas 
context sensitive aggregate interface interesting especially provide right function right time 
aggregate interfaces usage context adapt user time may create problems users interface changes unexpected way previously available functions removed hidden 
area promising producing interface adaptation methods high level user driven 
mean users give broad descriptions functionality desire interface system produces interface system user engage iterative design process produce product similar user desires 
process driven visualization allows users see actual usage design suggestions 
example user perform task realize perform task 
user open usage visualization selection corresponding task just performed system produce interface specifically selection 
conduct formal evaluation interfaces generated systems multiple appliances 
informal evaluations prototypes flow interface performed design results incorporated final design 
evaluation aggregate interfaces sure users perform type interface 
goal allow inexperienced user walk home theater room able system wait set things 
may interesting compare flow aggregate interface designs interfaces produces today integrated interface products philips logitech harmony universal 
final usability study puc interface noticed users failed failed control expected 
asked perform task typical process users navigate panel believed function 
function users heuristic search rest chapter interface looking function 
users performing exhaustive search quite common open panel contained function find function believe function panel 
users asked missed functions case common response suggests users benefit searchable user interface users provide keywords view list results current interface controls functions embedded search result interface 
tasks performed dramatically faster approach assuming desired control appeared near top search results 
number issues approach 
biggest search rarely returns result user looking 
case user may believe function exist 
concern worry number functions interface lower example number pages web 
interface search liberal returns results fairly chance desired function appear 
worry users easily specify search query handheld device text entry difficult may time consuming just searching interface 
definite concern hope addressed creating query interfaces rely part selection list appliance specific words 
approach leverage consistency system 
example user open previous interface indicate function looking search engine return results current interface similar 
worry situation user searches function appliance 
consistency search problem easy address knowledge base inform user current interface contain similar functions 
forms search issue need addressed 
potential benefits searchable user interface 
example searching function user search task 
system recognize task steps perform separate searches task steps attempt assemble aggregate interface task searches 
heuristics location items specification allow multi function appliances combination vcr dvd recorder produce grouped results appliance main functions 
example timed record task search multi chapter function recorder produce results recording show vcr tape recording dvd 
dissertation focuses generating interfaces may potential ideas evaluate hand designed user interfaces 
example manufacturer compare hand designed interface new appliance previous products 
representation interfaces information similarities possible build evaluation process determine puc existing consistency rules changes new interface previous products 
report information help designers understand new interface inconsistent previous products help improvements 
evaluations examine puc specification appliance differs hand designed interface identify areas interface structure particularly deep difficult access dependencies 
hurdle techniques evaluate hand designed interface providing evaluation system model interface understand 
ideal ask interface designer provide model require extra produce knowledge needed stored implicitly hand designed interface require interface designer learn modeling language 
point particularly important interface designers programmers may training produce adequate model hand designed interface 
important area developing techniques infer useful interface models 
ideally model inferred existing concrete interface succeed design decisions influenced final design may apparent final artifact 
example imagine panel containing controls 
design process designer may chosen remove bounding rectangle grouped subset controls panel 
grouping may necessary particular concrete interface useful model contain information extra grouping analyses 
suggests may interesting explore automatically inferring interface models interface design process 
model hand designed interface enable automated system modify hand designed interfaces support features puc explored automatically generated interfaces aggregation consistency 
number challenges chapter building system automatically modifies existing interfaces 
important understand information needed hand designed interface order appropriate modifications differs information needed automatically generate user interface 
possible information needed modify interface smaller needed automatically generate interface concrete interface available 
example label information needed model contained interface 
modification algorithms may need extra information concrete interface links specify labels go controls 
second challenge understand modify interface way consistent original hand design 
example interface layout may grid changes take account 
thirdly system needs real interfaces implemented current interface toolkits java swing net framework 
may issues 
example automatic modification system deal custom controls quite common existing interfaces 
useful understand features toolkits include help automatic modification 
implications supporting consistency hand designed interfaces quite interesting especially web applications 
today competing web sites orkut support basically functionality slightly different user populations 
automatic modification aggregate similar functionality ensure consistency possible automatically create mash similar web sites provides access data web sites unified web interface 
understanding pros cons approach finding applications benefit subject 
dissertation explored ways automatically generated interfaces may support features impractical include hand designed interfaces consistency aggregation 
important area find areas automatic generation may provide benefits hand designed interfaces 
area particular may significant value automatic generation interfaces users physical cognitive disabilities 
model user automatic interface generator may able produce interfaces specifically designed accommodate user disabilities 
high variance disabilities different users problem particularly challenging model describing users capabilities chapter need quite broad rules necessary generate interface need take account wide range possibilities 
researchers started examining direction far results demonstrating success wide range disabled users 
final remarks dissertation attempted demonstrate thesis system automatically generate user interfaces wide variety platforms remotely controlling appliances user performance better manufacturer interfaces appliances 
evaluations puc system suggest interface generators produce interfaces faster manufacturers interfaces today computerized appliances 
going forward believe research described dissertation implications user interface design research 
design suggests automatic design considered products interfaces may constrained external factors individual user customization may substantial benefits 
research suggests important direction developing new techniques automatic generation create interfaces customized individual 
chapter chapter appendix vcr specification appendix contains full specification sample vcr example discussed chapter 
xml version encoding utf spec xmlns www cs cmu edu pebbles puc name version puc guid eaf ac labels label simple vcr label labels groupings group name base state name power apply type type name labels label power label labels state group name active equals state base power constant value true equals active group name status status icon group state name access read tape status indicator apply type type name labels label tape label labels state state name access read tape status indicator apply type type name labels label tape label labels active equals state constant value true equals active state group group name controls labels label controls label labels group name media controls active equals state constant value true equals active labels label play controls label label play mode label text speech text play mode recording au labels state name mode type enumerated item count item count enumerated value labels map index labels label label labels map map index labels label play label labels map map index labels label pause label labels map map index labels label rewind label appendix sample vcr specification labels map map index labels label fast forward label labels map map index labels label record label labels active equals state constant value true equals active map value labels type labels label mode label labels state command name eject labels label eject label labels command group state name channel channel type type name integer min constant value min max constant value max integer type labels label channel label labels state state name tv vcr type boolean value labels map index true labels label vcr label labels map map index false labels appendix sample vcr specification label tv label labels map value labels type labels label tv vcr label labels state group group name labels label timed recordings label labels list group name list labels label timed recording label labels state name channel apply type type name labels label channel label labels state group name starttime date time labels label start time label labels state name date date type string type labels label date label labels state state name time time type string type labels label time label labels state group state name duration time duration type integer type labels label duration label labels state list group group name commands list commands appendix sample vcr specification command name add list add labels label add label labels command command name delete list remove labels label delete label labels command command name clear list clear labels label clear label label clear label labels command group group group group groupings ports inputs port name vhf antenna content type multi channel av physical type inputs outputs port name vhf antenna content type multi channel av physical type port group name output content type av port name video content type video physical type rca port group name audio content type component audio port name right content type component audio right physical type rca port name left content type component audio left physical type rca port group port group outputs ports content flow pass content type av active equals state base power constant value false equals active input ports port name vhf antenna input ports output ports port name vhf antenna output ports pass content group active equals state base power constant value true equals active content group appendix sample vcr specification active equals state base controls tv vcr constant value true equals active source name tape content type av active equals state base status constant value true equals equals state base controls mode constant value equals equals state base controls mode constant value equals active output ports port group name output port name vhf antenna channel output ports objects group name base controls objects source pass content type av input ports port name vhf antenna input ports processing block channel value block processing output ports port name vhf antenna output ports pass content group pass content type av active equals state base controls tv vcr constant value false equals active input ports port name vhf antenna input ports output ports port name vhf antenna output ports pass recorder name tape content type av active equals state base status appendix sample vcr specification constant value true equals equals state base status constant value true equals equals state base controls mode constant value equals active input ports port name vhf antenna channel state base controls channel port input ports objects group name base controls objects recorder content group content flow spec appendix sample vcr specification appendix sample vcr specification appendix language appendix online documentation specification language www pebbles cmu edu puc specification html xml schema xml version encoding utf xs schema www cs cmu edu pebbles puc qualified xmlns www cs cmu edu pebbles puc xmlns www cs cmu edu pebbles puc xmlns xs www org xmlschema top level element xs element name spec xs complextype xs sequence xs element name labels type xs element name aggregate spec type minoccurs maxoccurs xs element name types type minoccurs maxoccurs xs element name groupings type xs element name ports type minoccurs maxoccurs xs element name content flow type minoccurs maxoccurs xs sequence xs attribute name name type xs string required xs attribute name version type required xs attribute name guid type xs string optional xs complextype xs element attribute types xs simpletype name xs restriction base xs string xs enumeration value puc xs restriction xs simpletype xs simpletype name xs restriction base xs string xs enumeration value xs enumeration value parent xs enumeration value xs restriction xs simpletype xs simpletype name xs restriction base xs string xs enumeration value read xs enumeration value read write xs restriction xs simpletype xs simpletype name xs restriction base xs string xs enumeration value xs enumeration value multiple xs restriction xs simpletype xs simpletype name xs restriction base xs integer xs value xs value xs restriction xs simpletype xs simpletype name xs restriction base xs string xs enumeration value xs enumeration value xs enumeration value xs restriction xs simpletype xs simpletype name xs restriction base xs string xs enumeration value xs enumeration value selected xs restriction xs simpletype xs simpletype name xs restriction base xs string xs enumeration value audio xs enumeration value component audio xs enumeration value video xs enumeration value component video xs enumeration value av xs enumeration value multi channel audio xs enumeration value multi channel video xs enumeration value multi channel av xs restriction xs simpletype elements xs complextype name xs sequence appendix specification language xs choice minoccurs maxoccurs unbounded xs element name label type xs string minoccurs xs element name ref value type xs element name phonetic type xs string xs element name text speech type xs choice xs sequence xs complextype xs complextype name xs attribute name state type xs string required xs complextype xs complextype name xs attribute name text type xs string required xs attribute name recording type xs string xs complextype aggregate spec types xs complextype name xs attribute name name type xs string required xs complextype xs complextype name xs attribute name appliance type xs string required xs attribute name object type xs string required xs complextype types section xs complextype name xs choice minoccurs maxoccurs unbounded xs element name group type xs element name list group type xs element name union group type xs element name state type xs element name command type xs element name explanation type xs element name type type xs choice xs complextype xs name xs attribute name type name type xs string required xs attribute name type xs string optional xs attribute name priority type optional xs xs complextype name xs sequence xs element name active type minoccurs maxoccurs xs element name labels type minoccurs maxoccurs xs choice minoccurs maxoccurs unbounded xs element name group type xs element name list group type xs element name union group type xs element name state type xs element name command type xs element name explanation type xs element name apply type type xs choice xs sequence xs ref xs complextype xs complextype name xs sequence xs element name labels type minoccurs maxoccurs appendix specification language xs element name active type minoccurs maxoccurs xs choice minoccurs maxoccurs unbounded xs element name group type xs element name list group type xs element name union group type xs element name state type xs element name command type xs element name explanation type xs element name apply type type xs choice xs sequence xs ref xs attribute name access type xs complextype xs complextype name xs sequence xs element name labels type minoccurs maxoccurs xs element name active type minoccurs maxoccurs xs choice minoccurs maxoccurs unbounded xs choice minoccurs maxoccurs xs sequence xs element name min type minoccurs maxoccurs xs element name max type minoccurs maxoccurs xs sequence xs element name item count type xs integer xs choice xs element name selections type minoccurs maxoccurs xs element name group type xs element name list group type xs element name union group type xs element name state type xs element name command type xs element name explanation type xs element name apply type type xs choice xs sequence xs ref xs complextype xs complextype name xs sequence xs element name labels type xs element name active type minoccurs maxoccurs xs sequence xs ref xs complextype xs complextype name xs sequence xs choice minoccurs maxoccurs xs element name type type xs element name apply type type xs choice xs element name labels type minoccurs maxoccurs xs element name active type minoccurs maxoccurs xs element name required type minoccurs maxoccurs xs element name default value type xs sequence xs ref xs attribute name access type optional xs complextype appendix specification language xs complextype name xs sequence xs choice minoccurs maxoccurs xs element name binary type xs element name boolean xs element name enumerated type xs element name type xs element name type xs element name integer type xs element name list selection type xs element name string type xs choice xs element name value labels type minoccurs maxoccurs xs sequence xs attribute name type name type xs string required xs complextype groupings section xs complextype name xs choice minoccurs maxoccurs unbounded xs element name group type xs element name list group type xs element name union group type xs element name apply type type xs choice xs complextype xs complextype name xs sequence xs element name active type minoccurs maxoccurs xs element name labels type minoccurs maxoccurs xs choice minoccurs maxoccurs unbounded xs element name group type xs element name list group type xs element name union group type xs element name state type xs element name command type xs element name explanation type xs element name apply type type xs choice xs sequence xs ref xs complextype xs name xs attribute name name type xs string required xs attribute name type name type xs string optional xs attribute name type xs string optional xs attribute name priority type optional xs xs complextype name xs sequence xs element name appliance type minoccurs maxoccurs xs element name labels type minoccurs maxoccurs xs element name active type minoccurs maxoccurs xs choice minoccurs maxoccurs unbounded xs element name group type xs element name list group type xs element name union group type xs element name state type xs element name command type xs element name explanation type appendix specification language xs element name apply type type xs choice xs sequence xs ref xs attribute name access type xs complextype xs complextype name xs sequence xs element name appliance type minoccurs maxoccurs xs element name labels type minoccurs maxoccurs xs element name active type minoccurs maxoccurs xs choice minoccurs maxoccurs unbounded xs choice minoccurs maxoccurs xs sequence xs element name min type minoccurs maxoccurs xs element name max type minoccurs maxoccurs xs sequence xs element name item count type xs integer xs choice xs element name selections type minoccurs maxoccurs xs element name minoccurs maxoccurs xs element name group type xs element name list group type xs element name union group type xs element name state type xs element name command type xs element name explanation type xs element name apply type type xs choice xs sequence xs ref xs complextype xs complextype name xs choice xs element name constant type xs element name ref value type xs choice xs complextype xs complextype name xs attribute name value type xs string required xs complextype xs complextype name xs attribute name number type required xs attribute name access type optional default read write xs complextype xs complextype name xs attribute name type name type xs string required xs attribute name name type xs string optional xs attribute name priority type optional xs attribute name access type optional xs complextype xs complextype name xs attribute name name type xs string required xs complextype xs complextype name xs sequence xs element name appliance type minoccurs maxoccurs xs element name modifies state type minoccurs maxoccurs xs element name labels type appendix specification language xs element name active type minoccurs maxoccurs xs sequence xs ref xs complextype xs complextype name xs sequence xs element name appliance type minoccurs maxoccurs xs element name labels type xs element name active type minoccurs maxoccurs xs sequence xs ref xs complextype xs complextype name xs sequence xs element name appliance type minoccurs maxoccurs xs choice minoccurs maxoccurs xs element name type type xs element name apply type type xs choice xs element name labels type minoccurs maxoccurs xs element name active type minoccurs maxoccurs xs element name required type minoccurs maxoccurs xs element name default value type minoccurs maxoccurs xs element name completions available minoccurs maxoccurs xs element name server side error correction minoccurs maxoccurs xs sequence xs ref xs attribute name access type optional xs complextype xs complextype name xs attribute name type name type xs string required xs complextype xs complextype name xs sequence xs choice minoccurs maxoccurs xs element name binary type xs element name boolean xs element name enumerated type xs element name type xs element name type xs element name integer type xs element name list selection type xs element name string type xs choice xs element name value labels type minoccurs maxoccurs xs sequence xs attribute name type name type xs string optional xs complextype xs complextype name xs sequence xs element name map type minoccurs maxoccurs unbounded xs sequence xs complextype xs complextype name xs xs element name labels type minoccurs maxoccurs xs element name active type minoccurs maxoccurs xs xs attribute name index type xs string appendix specification language xs complextype xs complextype name xs xs element name min type minoccurs maxoccurs xs element name max type minoccurs maxoccurs xs element name average type minoccurs maxoccurs xs xs complextype xs complextype name xs sequence xs element name active type minoccurs maxoccurs xs sequence xs attribute name list type xs string xs complextype xs complextype name xs sequence xs element name min type minoccurs maxoccurs xs element name max type minoccurs maxoccurs xs element name specific values important minoccurs maxoccurs xs sequence xs complextype xs complextype name xs sequence xs element name min type minoccurs maxoccurs xs element name max type minoccurs maxoccurs xs element name incr type minoccurs maxoccurs xs element name specific values important minoccurs maxoccurs xs sequence xs complextype xs complextype name xs sequence xs element name type xs integer minoccurs maxoccurs xs element name min type minoccurs maxoccurs xs element name max type minoccurs maxoccurs xs element name incr type minoccurs maxoccurs xs element name specific values important minoccurs maxoccurs xs sequence xs complextype xs complextype name xs sequence xs element name item count type xs integer minoccurs maxoccurs xs sequence xs complextype xs complextype name xs sequence xs minoccurs maxoccurs unbounded xs sequence xs complextype xs complextype name xs choice minoccurs maxoccurs unbounded xs element name type xs element name type xs element name type xs element name apply type xs element name defined type xs element name undefined type xs element name equals type xs element name greaterthan type xs element name lessthan type appendix specification language xs element name true xs element name false xs choice xs attribute name ignore type optional xs complextype xs complextype name xs choice minoccurs maxoccurs unbounded xs element name type xs element name type xs element name type xs element name apply type xs element name defined type xs element name undefined type xs element name equals type xs element name greaterthan type xs element name lessthan type xs element name true xs element name false xs choice xs complextype xs complextype name xs choice xs element name constant type xs element name ref value type xs choice xs attribute name state type xs string required xs complextype xs complextype name xs choice minoccurs maxoccurs xs element name type xs element name type xs element name apply type xs element name defined type xs element name undefined type xs element name equals type xs element name greaterthan type xs element name lessthan type xs choice xs complextype xs complextype name xs choice minoccurs maxoccurs unbounded xs element name type xs element name type xs element name type xs element name apply type xs element name defined type xs element name undefined type xs element name equals type xs element name greaterthan type xs element name lessthan type xs choice xs attribute name list type xs string required xs attribute name items type optional xs attribute name true type optional xs complextype xs complextype name xs sequence xs element name inputs type minoccurs maxoccurs xs element name outputs type minoccurs maxoccurs appendix specification language xs element name input output type minoccurs maxoccurs xs sequence xs complextype xs complextype name xs choice minoccurs maxoccurs unbounded xs element name port type porttype xs element name port group type xs choice xs complextype xs complextype name porttype xs attribute name name type xs string required xs attribute name content type type required xs attribute name physical type type xs string required xs complextype xs complextype name xs choice minoccurs maxoccurs unbounded xs element name port type porttype xs element name port group type xs choice xs attribute name name type xs string required xs attribute name content type type required xs complextype xs complextype name xs choice minoccurs maxoccurs unbounded xs element name content group type xs element name source type xs element name renderer type xs element name recorder type xs element name pass type xs choice xs complextype xs complextype name xs sequence xs element name active type minoccurs maxoccurs xs choice minoccurs maxoccurs unbounded xs element name content group type xs element name source type xs element name renderer type xs element name recorder type xs element name pass type xs choice xs sequence xs complextype xs complextype name xs sequence xs element name active type minoccurs maxoccurs xs element name output ports type minoccurs maxoccurs xs element name objects type minoccurs maxoccurs xs sequence xs attribute name name type xs string required xs attribute name content type type required xs complextype xs complextype name xs sequence xs element name active type minoccurs maxoccurs xs element name input ports type minoccurs maxoccurs xs element name objects type minoccurs maxoccurs xs sequence xs attribute name name type xs string required appendix specification language xs attribute name content type type required xs complextype xs complextype name xs sequence xs element name active type minoccurs maxoccurs xs element name input ports type minoccurs maxoccurs xs element name processing type minoccurs maxoccurs xs element name output ports type minoccurs maxoccurs xs element name objects type minoccurs maxoccurs xs sequence xs attribute name name type xs string optional xs attribute name content type type required xs complextype xs complextype name xs choice minoccurs maxoccurs unbounded xs element name object type xs element name group type xs choice xs complextype xs complextype name xs attribute name name type xs string xs complextype xs complextype name xs choice minoccurs maxoccurs unbounded xs element name port type xs element name port group type xs choice xs complextype xs complextype name xs sequence xs element name active type minoccurs maxoccurs xs element name channel type minoccurs maxoccurs xs element name objects type minoccurs maxoccurs xs sequence xs attribute name name type xs string required xs attribute name channel type xs string optional xs complextype xs complextype name xs attribute name state type xs string optional xs attribute name value type xs string optional xs complextype xs complextype name xs choice minoccurs maxoccurs unbounded xs element name block type xs choice xs complextype xs complextype name xs sequence xs element name active type minoccurs maxoccurs xs element name channel type minoccurs maxoccurs xs element name port type minoccurs maxoccurs unbounded xs sequence xs attribute name channel type xs string optional xs attribute name port type xs string optional xs complextype xs complextype name xs attribute name name type xs string xs complextype xs schema appendix specification language element index element name active apply apply type binary block boolean channel command constant content flow content group description contains dependency information appliance object group objects 
defines relation dependencies contained grouped logical operation block 
defines relation dependencies contained 
applies dependency relations list data 
allows re existing type block specification 
binary type encompasses kind binary data including images sounds 
smart template appropriately interpret render binary data 
specifies channel blocked appliance passing multi channel content stream 
boolean type takes true false values 
content flow descriptions define particular channel content may flow 
defines command appliance object 
specifies state variable completions available server 
defines constant value place accepted 
defines section describes internal content flows appliance 
groups content flows purpose specifying dependencies apply 
appendix specification language element name default value defined enumerated description specifies default value state variable 
interface generator values ui needs prompt user new value demo offline interface 
conjunction active element define dependency state variable value 
enumerated type define number items enumeration item count tag 
labels defined tag 
equals explanation false greaterthan group groupings incr inputs input output conjunction active tag define equals dependency information state variable 
defines explanation appliance object 
false dependency expressions 
fixed point type variables take form decimal values fixed decimal point location 
minimum maximum increment values defined min max incr tags 
floating point type variables take form decimal values 
minimum maximum values defined min max tags 
conjunction active tag define greaterthan dependency information state variable 
define nodes group tree 
defines section includes group tree 
defines increment integer fixed point variable 
restriction means variable value equals minimum increment integer 
defines section describes input ports appliance 
defines section describes input output ports appliance 
appendix specification language element name input ports item count integer label labels lessthan list group list selection map min max modifies state object description defines input ports pass recorder renderer content flow 
denote values enumerated type list group 
labels items defined value labels tag 
integer type variables take form integers 
minimum maximum increment values defined min max incr tags 
defines label included label dictionary 
defines label dictionary appliance object group 
map tag specifies dictionary associated specific value variable 
conjunction active tag define lessthan dependency information state variable 
specifies special group represents list data 
variables contained group multiple values item list 
list selection type variables specify selection list different location spec list defined 
specifies label dictionary specific value variable 
defines minimum value numeric variable may take 
defines maximum value numeric variable may take 
allows command specify invocation modify state specification 
negates value dependency equation 
defines relation dependencies contained 
defines object related content flow 
appendix specification language element name objects outputs output ports pass phonetic port port group ports processing recorder ref value renderer required description defines section groups objects related content flow may specified 
defines section describes output ports appliance 
defines output ports pass source content flow 
defines pass content flow 
provides pronunciation information speech interfaces specification language 
pronunciations may included label dictionary 
defines position decimal point fixed point type 
defines port appliance 
defines group ports appliance 
defines section ports appliance described 
defines processing appliance content stream pass content flow channel blocked 
defines content flow sink records stream sent 
define dynamic value value space parameter tags tag depends value numeric state variable 
ref value set maximum numeric state variable value state variable 
elements may dependencies locations 
defines content flow sink renders stream sent 
specifies circumstances state variable value required 
element omitted state variable definition value required state variable active 
value required contents element satisfied 
appendix specification language element name selections server correction source spec specific state string text speech true type types undefined union group value labels description defines number selections allowed list user allowed modify selection 
specifies state variable error corrected server side 
specifies list group natural order may arbitrarily sorted user interface 
defines source content 
specification begins tag 
defines specific values numeric type interesting user opposed position value range 
defines state variable appliance object 
string type variables take form strings 
defines text speech entry included label dictionary 
true dependency expressions 
describes value space state variable ex boolean integer 
labels values take 
section specification authors may define types re specification 
conjunction active element define dependency state variable value 
specifies special group children may valid value 
contains map tags provide label dictionaries specific values variable 
appendix specification language element descriptions spec spec name sample specification version puc spec specification begins element 
name specified name attribute machine readable name parser 
contained labels element specifies human readable names appliance 
placement element spec required xml header xml version encoding utf parameters name required name appliance defined specification version required version specification language 
current valid values puc puc puc puc 
document describes puc guid required global identifier specification 
contain groupings labels types ports content flow types types types contains snippets specification author reuse groupings section 
placement inside spec element may contain group list group union group state command explanation type appendix specification language groupings groupings groupings contains entire group tree 
placement inside spec element may contain group list group union group group group name priority group defines nodes group tree 
group nodes may assigned label dictionary labels tag 
group nodes may specify dependencies members active tag 
dependencies applied rest member dependencies logical operation 
group unique name local name concatenated names parent groups 
placement inside groupings group list group types union group elements parameters name required local name group 
type name required types section optional defines type name smart template represents group children 
priority priority group assigned relative objects parent group 
appendix specification language may contain labels active state command explanation group list group union group list group list group name priority list group defines special node group tree represents list 
list group qualities regular group may contain extra elements describing features list 
list group automatically creates states 
length state stores current length list 
state undefined value items list 
selection state stores current selection 
multiple selections allowed selection treated list group allowing list operators apply applied 
elements provided item count min max allow specification writer pre specify constraints size list 
placement inside groupings group list group types union group elements parameters name required local name group 
type name required types section optional defines type name smart template represents group children 
priority priority group assigned relative objects parent group 
may contain appendix specification language labels active state command explanation group list group union group selections item count min max union group union group name access read union group defines special node group tree represents union 
union group qualities regular group 
contain extra elements describing union 
union group automatically creates state named defines active child variable group 
access parameter state defined access attribute union group element 
placement inside groupings group list group types union group elements parameters name required local name group 
type name required types section optional defines type name access defines users interact variable 
possible values read read write 
smart template represents group children 
priority priority group assigned relative objects parent group 
may contain labels active state command explanation group list group union group appendix specification language selections selections number access read defines number selections available list user may change current selection 
placement inside list group element parameters number required number allowed selections 
possible values multiple 
access defines users interact variable 
possible values read read write 
specifies list group natural order arbitrarily sorted user interface 
placement inside list group element state state name statename access read write priority state defines state variable appliance object 
placement inside group list group types union group parameters name required name state variable 
appendix specification language type name required types section optional defines type name priority priority state assigned relative objects group 
smart template represents group children 
access defines users interact variable 
possible values read read write 
may contain active apply type completions available default value labels required server side error correction type command command name priority command defines command appliance object 
placement inside group list group types union group parameters name required name command 
type name required types section optional defines type name priority priority state assigned relative objects group 
may contain active labels modifies state appendix specification language modifies state modifies state state base power specifies command modify state specification 
may interface generator appropriately display changes caused invoking command 
placement inside command element 
parameters state required name state modified 
explanation explanation name priority explanation defines explanation appliance object 
labels block required explanation object defines text explanation 
placement inside group list group types union group parameters name required name explanation 
type name required types section optional defines type name priority priority state assigned relative objects group 
may contain active labels appendix specification language type type name typename type describes value space state variable ex boolean integer 
labels values take 
placement inside state types tag parameters type name name type object 
required element contained types block 
may contain binary boolean enumerated integer list selection string value labels apply type apply type name typename allows re existing type block specification 
element exactly cutting pasting type block 
data shared states groups apply type 
type declared earlier specification document 
placement inside state group list group union group element parameters type name required name appliance object 
name optional element inside state element 
priority optional element inside state element 
appendix specification language access optional element inside state element type applied state variable union group 
default value default value default value specifies default value state variable 
interface generator values ui needs prompt user new value demonstrational purposes 
placement inside state element may contain constant ref value required required required contains dependency information defines value state variable required successful operation appliance 
content element active element 
element specified object required 
ensure object required create element containing true element 
placement inside state element may contain apply defined equals false greaterthan lessthan true undefined binary binary appendix specification language binary type contains kind binary data sounds images 
smart template type ensure proper interpretation rendering 
type may contain arbitrary tags act parameters particular smart templates recognize 
placement inside type element may contain arbitrary tag 
boolean boolean boolean type takes true false values 
placement inside type element enumerated enumerated enumerated enumerated type define number items composite type contains item count element 
note value labels element contain map elements map enumerated values label 
enumerated values particular enumerated type denoted item count value labels section contain different mappings values labels 
enumerated type values treated integers range number items type 
zero valid value enumerated type 
important specify index map tag placement inside type element appendix specification language may contain item count item count item count item count denote enumerated values enumerated type fixed number items list group 
labels items defined value labels tag 
placement inside enumerated list group elements fixed point type variables take form decimal values fixed decimal point 
location fixed decimal point specified element 
minimum maximum increment values defined min max incr tags 
placement inside type element may contain incr max min defines position decimal point fixed point type 
placement inside tag appendix specification language floating point type variables take form decimal values 
minimum maximum values defined min max tags 
placement inside type element may contain max min integer integer integer integer type variables take form integers 
minimum maximum increment values defined min max incr tags 
placement inside type element may contain incr max min specific values important specific values important specific values important defines user want modify integer type specific values supports 
slider control enables imprecise changes value 
placement inside integer element 
appendix specification language list selection list selection list selection list selection type variables represent independent selection list specification 
particular useful situations aspect appliance configured list item list selected normal operation channels vcr tv 
placement inside type element may contain active incr 
max 
min incr incr max max min min describe minimum maximum increment values variable may take 
increment may defined floating point type 
placement inside incr integer incr string elements 
may contain constant ref value string string string string type variables take form strings 
specify parameters length string help interface generators 
placement appendix specification language inside type element may contain min max average average average average describe average length string 
placement inside string element may contain constant ref value value labels value labels value labels contains map tags provide label dictionaries specific values variable 
placement inside type element may contain map map map index value map specifies label dictionary specific value variable specified index parameter 
certain values variable enabled dependency information specified enclosed active element 
appendix specification language placement inside value labels element 
parameters index required value associate dictionary may contain labels active labels labels labels defines label dictionary appliance object group 
placement inside command explanation group list group state spec map elements 
may contain label ref value phonetic text speech text speech text speech text mute recording mute au defines text speech entry included label dictionary 
text parameter may contain embedded sable markup tags 
placement inside labels element parameters text required text spoken 
may contain embedded sable tags 
recording recording text available appendix specification language label label label defines label included label dictionary 
placement inside labels element may contain string phonetic phonetic phonetic defines pronunciation included label dictionary 
placement inside labels element may contain string phonemes representation active active ignore parent active contains dependency information appliance object group objects 
defines relation dependencies contained grouped logical operation block tags 
placement inside command explanation group list group map list selection state elements 
parameters appendix specification language ignore dependency inheritance group tree 
possible options omit option parent may contain apply defined equals false greaterthan lessthan true undefined apply apply list items true apply apply dependency information lists information 
different ways dependencies applied 
apply block true dependencies true item list true items list true items list 
particular choice chosen true attribute 
placement inside active apply elements 
parameters list required name list group dependencies applied 
true sets apply returns true 
possible options 
may contain apply defined equals false greaterthan lessthan true undefined defined defined state conjunction active tag define appliance object depends state variable having defined value 
appendix specification language placement inside active apply elements 
parameters state required name state depended undefined undefined state conjunction active tag define appliance object depends state variable having defined value 
placement inside active apply elements 
parameters state required name state depended equals equals state value equals conjunction active tag define equals dependency information state variable 
placement inside active apply elements 
parameters state required name state depended may contain ref value constant appendix specification language greaterthan greaterthan state value greaterthan conjunction active tag define greater dependency information state variable 
placement inside active apply elements 
parameters state required name state depended may contain ref value constant lessthan lessthan state value lessthan conjunction active tag define dependency information state variable 
placement inside active apply elements 
parameters state required name state depended may contain ref value constant appendix specification language defines relation dependencies contained 
placement inside active apply elements 
may contain apply defined equals false greaterthan lessthan true undefined defines relation dependencies contained 
placement inside active apply elements 
may contain apply defined equals false greaterthan lessthan true undefined defines relation dependencies contained 
placement inside active apply elements 
may contain apply defined equals false greaterthan lessthan true undefined appendix specification language true true specifies true value dependency formula 
placement inside active apply elements 
false false specifies false value dependency formula 
placement inside active apply elements 
ref value ref value state statename define numeric value value space parameter tags tag depends value numeric state variable 
set maximum numer state variable value state variable 
placement inside max min average incr elements 
parameters state required name state variable numeric type appendix specification language constant constant value define constant value location accepted ref value element 
placement inside max min average incr elements 
parameters value required constant value 
completions available completions available specify completions available state variable 
placement inside state server side error corrections server side error corrections specify variable automatically error corrected 
placement inside state appendix specification language ports ports ports defines section physical ports appliance described 
placement inside spec element 
may contain inputs input output outputs inputs inputs inputs defines physical input ports appliance 
placement inside ports element 
may contain port port group outputs outputs outputs defines physical output ports appliance 
placement inside ports element 
may contain port port group appendix specification language input output input output input output defines physical ports appliance simultaneously inputs outputs 
placement inside ports element 
may contain port port group port group port group name output content type av port group defines group physical ports 
construct useful grouping ports activated simultaneously 
referencing name port group content flow shorthand referencing contained ports 
placement inside inputs input output outputs port group elements 
parameters name required name port group 
unique names ports port groups level 
content type required content type carried ports contained group 
may contain port port group appendix specification language port port name right content type component audio right physical type rca port name input video channel port element different uses 
ports block defines physical port appliance 
full name port similar naming appliance objects form name port group names port groups contain port 
port element may contain elements content 
second content flow block defines port port group content accepted input produced output 
port element may contain elements 
name complete unique port name defined ports block 
placement inside inputs input output outputs port group elements 
second inside input ports output ports elements 
parameters name required name port group 
unique names ports port groups level 
content type required content type carried ports contained group 
physical type required type physical port appliance 
rca vga channel available second element 
defines channel multi channel stream 
may contain second active channel objects appendix specification language content flow content flow content flow defines section internal content flows appliance described 
placement inside spec element 
may contain content group source pass recorder renderer content group content group content group defines group content flows purpose defining dependencies apply content flows group 
placement inside content flow content group elements 
may contain active content group source pass recorder renderer source source name tape content type av source describes source content appliance 
placement inside content flow content group elements 
parameters name required name source 
content type required type content produced source 
appendix specification language may contain active output ports objects pass pass content type av pass describes pass content appliance 
placement inside content flow content group elements 
parameters content type required type content produced source 
may contain active input ports processing output ports objects recorder recorder name tape content type av recorder describes content sink records content stream received input 
placement inside content flow content group elements 
parameters name required name source 
content type required type content produced source 
may contain active input ports objects appendix specification language renderer renderer name screen content type video renderer describes content sink renders content stream received input user 
placement inside content flow content group elements 
parameters name required name source 
content type required type content produced source 
may contain active input ports objects input ports input ports input ports describes input ports may content flow 
placement inside pass recorder renderer elements 
may contain port output ports output ports output ports describes output ports may content flow 
placement inside pass source elements 
appendix specification language may contain port processing processing processing defines processing may done content stream passed appliance 
placement inside pass element 
may contain block channel channel value channel state base controls channel defines channel multi channel content stream modified appliance 
parameter options 
placement inside port element 
parameters value defines state value channel 
state defines state variable group contain value channel operated 
appendix specification language block block channel block defines block operation may applied appliance channels multi channel content stream 
operation active channel received input passed output 
placement processing element 
parameters channel defines channel block may contain active channel objects objects objects defines set groups appliance objects related control content flow 
placement inside pass recorder renderer port elements 
may contain group object appendix specification language object object name base power defines object related control content flow 
name resolve appliance object specification group 
placement inside objects element 
parameters name required name appliance object specification 
appendix specification language appendix specification language appendix puc xml language schemas puc uses xml communication protocol store mappings knowledge base describe systems multiple appliances 
xml languages described appendix 
communication protocol schema xml version encoding utf xs schema www cs cmu edu pebbles puc puc protocol qualified xmlns www cs cmu edu pebbles puc puc protocol xmlns www cs cmu edu pebbles puc puc protocol xmlns xs www org xmlschema puc protocol consists byte header xml content optional format independent binary content 
header divided byte chunks 
chunk integer giving full length message including header 
second chunk integer giving length xml portion message 
integers sent network byte order 
xml content described schema 
binary content may arbitrary format 
format usually defined element accompanying xml message 
xs element name message xs complextype xs choice minoccurs maxoccurs xs element name state change notification type xs element name state change request type xs element name binary state change notification type xs element name state value request type xs element name command invoke request type xs element name spec request xs element name device spec type xs element name full state request xs element name server information request xs element name server information type xs element name alert information type xs string xs element name register device type xs element name unregister device type xs choice xs complextype xs element xs complextype name xs sequence xs element name state type minoccurs maxoccurs xs sequence xs complextype xs complextype name xs xs extension base xs string xs attribute name content type type xs string xs extension xs xs complextype xs complextype name xs sequence xs element name state type xs string minoccurs maxoccurs xs minoccurs maxoccurs unbounded xs sequence xs complextype xs complextype name xs sequence xs element name command type xs string minoccurs maxoccurs xs sequence xs complextype xs complextype name xs sequence xs element name spec type xs string minoccurs maxoccurs xs sequence xs complextype xs complextype name xs sequence xs element name server name type xs string minoccurs maxoccurs xs element name device type minoccurs maxoccurs unbounded xs sequence xs complextype xs complextype name xs sequence xs element name name type xs string minoccurs maxoccurs xs element name port type xs integer minoccurs maxoccurs xs sequence xs complextype appendix puc xml language schemas xs complextype name xs sequence xs element name port type xs integer minoccurs maxoccurs xs sequence xs complextype xs complextype name xs choice minoccurs maxoccurs xs sequence xs element name state type xs string xs element name value type xs sequence xs element name data type xs element name change type xs element name insert type xs element name delete type xs element name replace type xs choice xs complextype xs complextype name mixed true xs sequence xs element name undefined minoccurs maxoccurs xs sequence xs complextype xs complextype name mixed true xs sequence xs element name undefined minoccurs maxoccurs xs sequence xs attribute name state type xs string xs complextype xs complextype name xs choice xs element name data type xs element name change type xs element name insert type xs element name delete type xs element name replace type xs sequence xs element name value type minoccurs maxoccurs unbounded xs sequence xs choice xs complextype xs complextype name xs choice xs element name data type xs sequence xs element name value type minoccurs maxoccurs unbounded xs sequence xs choice xs complextype xs complextype name xs sequence xs element name el type minoccurs maxoccurs unbounded xs sequence xs attribute name state type xs string required xs complextype xs complextype name xs sequence xs element name el type minoccurs maxoccurs xs sequence appendix puc xml language schemas xs attribute name state type xs string required xs attribute name index type xs integer required xs complextype xs complextype name xs attribute name state type xs string required xs attribute name type xs integer required xs attribute name length type xs integer required xs complextype xs complextype name xs sequence xs element name el type minoccurs maxoccurs unbounded xs sequence xs attribute name state type xs string required xs attribute name type xs integer required xs complextype xs complextype name xs sequence xs element name el type minoccurs maxoccurs unbounded xs sequence xs attribute name state type xs string required xs attribute name type xs integer required xs attribute name length type xs integer required xs complextype xs schema knowledge base schema xml version encoding utf xs schema www cs cmu edu pebbles puc kb qualified xmlns www cs cmu edu pebbles puc kb xmlns www cs cmu edu pebbles puc kb xmlns xs www org xmlschema top level element xs element name puc knowledgebase xs complextype xs sequence xs element name spec store table type minoccurs maxoccurs xs element name spec map type minoccurs maxoccurs unbounded xs sequence xs complextype xs element attribute types xs simpletype name xs restriction base xs string xs enumeration value allowed xs enumeration value allowed xs restriction xs simpletype xs simpletype name xs restriction base xs string xs enumeration value indexed xs enumeration value indexed xs restriction xs simpletype xs simpletype name xs restriction base xs string xs enumeration value manual xs enumeration value regular automatch xs enumeration value transitive automatch appendix puc xml language schemas xs restriction xs simpletype xs simpletype name xs restriction base xs float xs value xs value xs restriction xs simpletype xs simpletype name xs restriction base xs string xs enumeration value sparse xs enumeration value branch xs enumeration value significant xs restriction xs simpletype xs simpletype name xs restriction base xs string xs enumeration value equivalent xs enumeration value fully contained xs enumeration value overlapping xs enumeration value overlap xs restriction xs simpletype xs simpletype name xs restriction base xs string xs enumeration value function xs enumeration value organization xs restriction xs simpletype spec store table types xs complextype name xs sequence xs element name spec type minoccurs maxoccurs unbounded xs sequence xs complextype xs complextype name xs sequence xs element name location type xs string minoccurs maxoccurs xs element name generated interface location type xs string minoccurs maxoccurs xs element name object count type xs integer minoccurs maxoccurs xs element name similar specs table type minoccurs maxoccurs xs element name mappings table type minoccurs maxoccurs xs sequence xs attribute name name type xs string optional xs attribute name guid type xs string required xs complextype xs complextype name xs sequence xs element name mapped type minoccurs maxoccurs unbounded xs sequence xs complextype xs complextype name xs attribute name path type xs string required xs attribute name type type optional xs attribute name spec name type xs string optional xs attribute name spec guid type xs string required xs complextype xs complextype name xs sequence appendix puc xml language schemas xs element name spec entry type minoccurs maxoccurs unbounded xs sequence xs complextype xs complextype name xs sequence xs element name similar objects type xs integer minoccurs maxoccurs unbounded xs element name branch type minoccurs maxoccurs unbounded xs sequence xs attribute name name type xs string optional xs attribute name guid type xs string required xs attribute name similarity type required xs complextype xs complextype name xs attribute name spec group type xs string required xs attribute name spec entry group type xs string required xs complextype spec map types xs complextype name xs sequence xs choice minoccurs maxoccurs unbounded xs element name group type xs element name mapping type xs element name state mapping type xs element name list mapping type xs element name template mapping type xs element name location mapping type xs choice xs sequence xs attribute name spec guid type xs string required xs attribute name spec name type xs string optional xs attribute name spec guid type xs string required xs attribute name spec name type xs string optional xs complextype xs complextype name xs sequence xs element name label type xs string minoccurs maxoccurs xs element name source type minoccurs maxoccurs xs element name cost type minoccurs maxoccurs xs choice minoccurs maxoccurs unbounded xs element name mapping type xs element name state mapping type xs element name template mapping type xs element name location mapping type xs choice xs sequence xs complextype xs complextype name xs attribute name type required xs attribute name type required xs complextype xs complextype name xs attribute name type type required xs attribute name confidence type optional xs complextype xs complextype name xs sequence xs element name label type xs string minoccurs maxoccurs xs element name source type minoccurs maxoccurs xs sequence appendix puc xml language schemas xs attribute name spec type xs string required xs attribute name spec type xs string required xs complextype xs complextype name xs sequence xs element name label type xs string minoccurs maxoccurs xs element name source type minoccurs maxoccurs xs element name cost type minoccurs maxoccurs xs sequence xs attribute name spec type xs string required xs attribute name spec type xs string required xs complextype xs complextype name xs sequence xs element name label type xs string minoccurs maxoccurs xs element name source type minoccurs maxoccurs xs element name cost type minoccurs maxoccurs xs choice minoccurs maxoccurs xs element name values equivalent xs sequence xs element name value type minoccurs maxoccurs unbounded xs sequence xs choice xs sequence xs attribute name spec state type xs string required xs attribute name spec state type xs string required xs complextype xs complextype name xs sequence xs element name spec type minoccurs maxoccurs xs element name spec type minoccurs maxoccurs xs sequence xs attribute name spec type xs string optional xs attribute name spec type xs string optional xs complextype xs complextype name xs choice minoccurs maxoccurs xs element name constant type xs element name range type xs element name defined xs element name undefined xs choice xs complextype xs complextype name xs attribute name start type xs string required xs attribute name type xs string required xs complextype xs complextype name xs attribute name value type xs string required xs complextype xs complextype name xs sequence xs element name label type xs string minoccurs maxoccurs xs element name source type minoccurs maxoccurs xs element name cost type minoccurs maxoccurs xs choice minoccurs maxoccurs xs sequence xs element name initial type minoccurs maxoccurs xs element name step type minoccurs maxoccurs appendix puc xml language schemas xs sequence xs sequence xs element name spec type minoccurs maxoccurs xs element name spec type minoccurs maxoccurs xs sequence xs choice xs sequence xs complextype xs complextype name xs sequence xs element name spec type minoccurs maxoccurs xs element name spec type minoccurs maxoccurs xs sequence xs complextype xs complextype name xs sequence xs choice minoccurs maxoccurs unbounded xs element name change type xs element name invoke type xs element name repeat type xs choice xs sequence xs complextype xs complextype name xs sequence xs element name count type minoccurs maxoccurs xs choice minoccurs maxoccurs unbounded xs element name change type xs element name invoke type xs element name repeat type xs choice xs sequence xs complextype xs complextype name xs choice xs element name variable type xs element name constant type xs choice xs complextype xs complextype name xs attribute name command type xs string required xs complextype xs complextype name xs choice minoccurs maxoccurs xs element name constant type xs element name variable type xs element name increase type xs element name decrease type xs choice xs attribute name state type xs string required xs complextype xs complextype name xs attribute name name type xs string xs complextype xs complextype name xs attribute name value type xs string optional xs attribute name wrap type optional xs complextype xs complextype name appendix puc xml language schemas xs attribute name value type xs string optional xs attribute name wrap type optional xs complextype xs complextype name xs sequence xs element name label type xs string minoccurs maxoccurs xs element name source type minoccurs maxoccurs xs sequence minoccurs maxoccurs xs element name spec type minoccurs maxoccurs xs element name spec type minoccurs maxoccurs xs sequence xs sequence xs attribute name spec list type xs string required xs attribute name spec list type xs string required xs complextype xs complextype name xs choice minoccurs maxoccurs xs element name list index type xs element name state type xs choice xs complextype xs complextype name xs attribute name type type optional xs complextype xs complextype name xs attribute name name type xs string required xs attribute name type type optional xs complextype xs schema multi appliance wiring diagram schema xml version encoding utf xs schema www cs cmu edu pebbles puc wiring qualified xmlns www cs cmu edu pebbles puc wiring xmlns www cs cmu edu pebbles puc wiring xmlns xs www org xmlschema xs element name puc wiring description xs complextype xs sequence xs element name appliances type minoccurs maxoccurs xs element name wires type minoccurs maxoccurs xs element name preferred flows type minoccurs maxoccurs xs sequence xs attribute name name type xs string xs complextype xs element xs complextype name xs sequence xs element name appliance type minoccurs maxoccurs unbounded xs element name external source type minoccurs maxoccurs unbounded xs sequence xs complextype xs complextype name xs attribute name name type xs string required xs attribute name spec guid type xs string required appendix puc xml language schemas xs attribute name server type xs string required xs attribute name port type xs string required xs complextype xs complextype name xs attribute name name type xs string required xs complextype xs complextype name xs sequence xs element name connect type minoccurs maxoccurs unbounded xs sequence xs complextype xs complextype name xs sequence xs element name start type minoccurs maxoccurs xs element name type minoccurs maxoccurs xs sequence xs complextype xs complextype name xs attribute name name type xs string required xs attribute name port type xs string optional xs complextype xs complextype name xs sequence xs element name flow type minoccurs maxoccurs unbounded xs sequence xs complextype xs complextype name xs attribute name appliance type xs string required xs attribute name name type xs string required xs complextype xs schema appendix puc xml language schemas appendix authoring study instructions appendix contains tutorial document created teaching puc specification language subjects specification authoring study 
document starts page preserve formatting 
specification authoring study developing personal universal controller puc system improve user interfaces common home office appliances moving interface handheld computer 
system relies specification language capable describing complete functionality appliance user may encounter 
handheld computer uses specification appliance automatically generate user interface remotely controls appliance 
benefits system user interface generated new appliance consistent interfaces user similar appliances 
example interface generated handheld controlling vcr conference center consistent interface controlling vcr home 
study create functional specifications suitable interface generation puc system 
start learning specify appliance reading working small specification list application 
write specification appliance provided mitsubishi 
may optionally write additional specification appliance owner manual 
author specifications xml language developed 

general concepts describing appliance functionality section describes general concepts method describing appliance functionality 
concepts applicable regardless authoring method choose study 
important concepts language functions appliance represented state variables state commands 
state variables specific type information describes manipulated interface 
commands states collectively called appliance objects 
structure prototype interfaces dependency information 
example suppose interface created shelf stereo appendix specification authoring study instructions system tape cd player 
power screen power button widget shown objects enabled 
power screen shown widgets objects active power 
expect interface panel widgets change tape cd player active 
final representation interface described tree format 
reasonable include tree representation interface specification appliance tree may differ different form factors 
example tree deeply branched small screen wap cellular phone interface tree broader desktop pc interface 
prefer specifications define group tree deeply branched 
information small screen large screen interfaces alike branches ignored large interface 
domain specific conventions appliance interfaces standard number pad telephone standard play icons media players 
interfaces generated puc system need include conventions generated interfaces developed smart templates help identify pieces specification conventions applied 
items described detail 
appliance objects types appliance objects supported specification language 
states variables represent data stored appliance 
examples radio station stereo number rings answering machine picks time alarm clock set 
variable type ui generator assumes value state may changed value type time state enabled 
possible state variables undefined value 
commonly happens just interface generated values assigned occur reasons 
commands function appliance described variables 
may situations invoking command caused un appendix specification authoring study instructions known change known state variable seek function radio situations state variable known manufacturer choice reason dialing buttons standard phone commands 
explanations descriptive information appropriate include label state command important simple group label 
represents early attempt including help information specifications 
explanations rarely specifications 
differences states commands explanations share common property enabled 
object enabled active user interface widgets correspond object manipulated user 
knowing circumstances object enabled disabled provide helpful hint structuring interface items active similar situations grouped items placed panels widgets visible object active 
specifying prior knowledge enabled property discussed detail dependency information sub section 
label information common property appliance objects need specify rich labeling information flexibility generating interfaces different form factors 
support specifying labeling information concept label dictionary 
place specification label entered label may provided 
expected labels contain general information vary terms length detail 
interface generator choose longest label fits space allocated screen 
labels specified appliance object linked particular values appliance state type 
state variable types appliance state type object associated 
type information determine kinds widgets manipulate state parameters recognize smart templates 
appendix specification authoring study instructions different kinds types specification boolean enumerated fixed point floating point integer list selection string types different set parameters specified 
boolean type variables value true false 
enumerated type small collections values string label 
internally values represented numbers starting 
example enumerated type items value 
enumerated types labels defined values 
types fixed point floating point integer contain numeric values 
integers decimal component fixed point floating point 
fixed point values fixed number digits right decimal point defined required decimal places field 
floating point values arbitrary number digits side decimal point 
fixed point integer types optional increment field restrict values state variable may contain 
increment specified minimum value specified 
parameters specified value state variable equal minimum increment integer 
list selection type special type linking value state variable selection list appliance description 
usually user configured set common values setup portion interface wants select values interface 
specify name list variable select 
optionally may specify dependencies values list order restrict list items may selected 
string type contains string value 
currently parameters type 
appendix specification authoring study instructions group tree proper structure important part user interface 
language hierarchical group tree specify structure 
leaf nodes tree appliance objects branch nodes groups 
node tree name child parent 
node locally unique name globally unique name constructed pre pending names nodes parents 
character separate name 
example locally unique name state variable globally unique name stereo cd 
specification contain states stereo tape 
note root name stereo re name specification 
necessary explicitly refer state variables specification 
may done name starts globally unique name 
root name unique full name 
examples tape cd assuming groups states named cd tape 
types groups normal list union 
normal group putting related data similar record programming language 
list union groups special behavior normal groups discussed section 
lists specifying list group similar specifying array records programming language multiple list groups nested create multi dimensional lists 
list group implicit length state variable named length contains current length list 
variable undefined list currently members 
specification may define bounds length list order help interface generator create better rendering 
exact size may specified minimum maximum size may specified 
list groups maintain implicit structure keep track list selections 
number selections allowed may defined specification options currently default specified 
list allows selection implicit selection variable created contains index current selection undefined means selection 
multiple selections created appendix specification authoring study instructions implicit list group named selections created 
group contains length state list groups selection state contains selected indices 
unions union group similar specifying union programming language children union groups appliance objects may active time 
implicit state variable named automatically created union group contains name currently active child 
dependency information dependency information specified appliance object boolean equation 
information gives interface generator approximate priori knowledge object enabled see appliance objects section information 
kinds dependencies specified 
dependencies specifies state depended value state variable compare 
equals true specified state specified value 
greaterthan true specified state value greater specified value 
lessthan true specified state value specified value 
defined true specified state value 
undefined true specified state value 
dependencies composed boolean formulas 
may 
specifying dependencies list state variables done special apply operation 
element applies dependencies contains items list returns value depending value true property 
dependencies applied set items items property may set selected 
property may set 
true dependencies contained apply element true elements true returned 
true dependencies contained apply true appendix specification authoring study instructions elements 
true dependencies satisfied element return true 
smart templates smart templates standardized advance specification authors specify highlevel conventions interface generators understand 
number templates defined described smart templates appendix document 
smart template specification author things tag group appliance object name smart template 
ensure group appliance object conforms restrictions specified smart template 
appendix document describes restrictions smart template 
may find smart templates defined expressive appliance specifying 
encounter situation please mark group object appropriate smart template name specify contents template match functionality appliance 
help improve extend smart templates 

authoring appliance specification xml extensive documentation xml language available web www pebbles cmu edu puc specification html documentation smart templates available www pebbles cmu edu puc highlevel types html xml editors appendix specification authoring study instructions special xml editor authoring specifications easier process 
support editors study home edition visual studio net 
may different editor necessarily able help problems 
important reason xml editor ensure specification proper format validating schema 
feature xml editor need download schema puc specification language available www pebbles cmu edu puc puc xsd strongly recommend schema editor guarantees document correctly formatted 
home edition home edition freely downloaded link origin com download components html near top page find links downloading requesting free license 
application installed running screen appendix specification authoring study instructions create new file open tools menu top page select options item 
dialog box open containing set tabbed panes 
click tab editing pane 
done see screen red circle recommend autom 
append mandatory children new elements checkbox circled red 
feature cause curious behavior puc language schema 
click ok exit dialog box 
create new appliance specification opening file menu selecting new dialog box displayed appendix specification authoring study instructions sure xml document selected click ok see dialog box sure selected schema click ok downloaded puc schema see link note location save file 
see dialog box click browse button find puc schema file local hard drive 
click ok create new file 
application screen look appendix specification authoring study instructions may start writing specification 
see screen looks image repeat instructions turning automatic append mandatory children feature 
appendix specification authoring study instructions visual studio net create new xml document visual studio open file menu new sub menu select file item 
dialog box displayed appendix specification authoring study instructions select xml file right pane click open new xml file created visual studio 
validate xml file puc schema need copy puc schema file particular location visual studio directory structure add specific statement top new file 
schema file see link placed visual studio directory common packages schemas xml visual studio directory location visual studio installation 
typically program files microsoft visual studio net may vary depending installation 
copied schema file start specification line spec xmlns www cs cmu edu pebbles puc name version puc name attribute may filled appropriate name choice 
xmlns attribute important defines visual studio schema want validation 
verify visual studio appropriately linked file schema open xml menu select validate xml data item 
see error schema visual studio locate schema document 
validation ensure formed xml document validate data schema 
double check copied schema file appropriate directory 
appears correct try restarting visual studio application 
problems please contact appendix specification authoring study instructions 
example specification walkthrough walk design specification hypothetical list application 
note example uses process building specification need mimic process designing specifications 
know best process writing specs part study exploring different methods outputs 
list application functionality list items detailed information item including description category completion date completion flag add delete functions list items sorting functionality list category completion date completion flag customizable list categories add delete functions category list items reminder frequency setting may weekly daily hourly display preference choosing show completed tasks regular appliance able discover details various functions 
important explore features user manual appliance ensure specification accurate possible 
defining state variable start specifying state variables reminder frequency display preference 
variables value manipulated user 
choose separate commands settings general better state variable possible 
card method start defining state variable object card 
shows object card reminder frequency state variable 
object card de appendix specification authoring study instructions fines state variable state variable type card attached specify type state variable shown 
reminder frequency set different values picked enumerated type state contains items 
labels specified values enumerated type done attaching label cards type card see 

cards specify reminder frequency setting 
cards attached clip 
may noticed object card shown reminder frequency setting priority value specified 
may wonder value came especially priority values chosen relative members group contains state variable 
value chosen specification process knew items group state variables 
cases difficult assign priority value initially defining object contents group contains object known 
xml state variable components card formatted schema see 
appendix specification authoring study instructions state name priority type enumerated item count item count enumerated value labels map index labels label weekly label labels map map index labels label daily label labels map map index labels label hourly label labels map value labels type labels label reminder frequency label label reminder freq label label reminders label labels state 
xml code reminder frequency state variable 
display preference setting state variable definition similar shown reminder frequency variable 
exercise suggest writing description variable comparing cards xml shown appendices respectively 
specifying list data lists specified special list group feature specified group card see list group element xml see 
decided list bounds selection decisions re appendix specification authoring study instructions descriptions see 
note card system list parameter card attached group card define bounds selections 

group list parameters card describe list 
list state variable members shown 
list group name list priority selections number 
list group 
xml code describing list 
state variable defined appears code 
variables contained list group multiple values value item list 
familiar programming languages similar defining array records structs 
list item values description completion date category completion flag list group contain different state variables 
specification description completion date completion flag variables left exercise category variable discussed sub section 
list list application contains valid categories list item may 
exercise suggest attempt specify list group including state variable 
check referring completed specifications appendices list selection type appendix specification authoring study instructions categories variable list value items categories list 
means enumerated type variable know advance categories user choose 
language supports problem list selection state variable type 
case create category variable list group list selection type 
type specify selects item category list specification 
user changes category list changes automatically appear choose modify list items 
cards xml category state variable shown respectively 

object state variable type cards category state variable contained todo list group 
note list selection type state variable type card 
state name category priority type list selection list setup categories list type labels label category label labels state 
xml code category state variable contained list group 
note list selection type variable 
providing user interface modifying list data appendix specification authoring study instructions description list application includes functions adding removing items list categories list 
description language chosen smart template defining special functions allowing interface generators take special action rendering 

object cards describe add remove commands list 
objects contained group tagged list commands smart template 
group name commands list commands priority command name add list add priority labels label add item label label add label label add label labels command command name delete list remove priority labels label delete item label label delete label label delete label labels active greaterthan state todo list length constant value greaterthan defined state todo list selection active command 
xml code describing add remove commands list 
note group contains items 
note dependencies provided delete command 
discussed dependency information section 
appendix specification authoring study instructions smart template case called list commands 
may wish read description template appendix order understand usage 
group tagged template may contain number commands tagged specialized templates list add list move list clear case wish add commands adding removing items list add commands implement list add list remove templates 
cards commands shown xml shown 
note list xx smart templates restrictions labels dependencies commands information vary depending described 
ways add data list example commands implemented list add smart template different labels 
command type important fill information object group interface generator know smart template 
case included information generator create interface 
information missing possible 
variable uses smart template specification variable completion date list 
exercise suggest find appropriate smart template apply specifying state variable 
dependency information looked xml code delete command may noticed command includes dependency information 
specifically delete command available zero items list item list selected 
card dependency formula see attached object card delete command 
appendix specification authoring study instructions 
dependency card delete command 
note extended names state variables 
may find necessary go back names explicit dependency cards organized variables specification 
organizing specification state variables commands lists defined consider organizing description useful interface generator 
general try hierarchy deep possible interface generator small screen device able intelligent decisions separate pieces user interface 
specification chose main groups 
group contains todo list consists list containing list data group list commands modifying data 
group list commands contains sorting function 
second main group called setup contains display preference setting reminder frequency setting list categories 
find specifications functions included list application required organization 
mentioned organization data important interface generator may affect quality interface generated specification 
sure put effort designing interface hierarchy accurate intuitive appliance 
appendix specification authoring study instructions appendix 
smart templates smart templates defined address date date time way way enter list commands media controls time absolute time duration zoom controls format templates described 
address overview represents address entered navigation system 
contents template supports multi state form 
sense support single state string form contains parsable address required 
required states template 
allows template number situations partial piece address needed zip code 
different states template state represents name street 
may string enumerated type 
support completions server side error correction features available 
state represents number apartment suite address 
state may string integer type 
integer may type appendix specification authoring study instructions tions bounds increment 
labels state taken account order know number suite apartment state represents street number address 
integer type restrictions bounding optional 
support completions server side error correction features available 
city state represents city address 
string enumerated state 
support completions server side error correction features available 
state state represents state province address located 
may string enumerated type 
zipcode state represents zip code address 
may string integer enumerated type 
support completions server side error correction features available 
country state represents country address 
may string enumerated type 
support completions server side error correction features available 
date overview template describes data stores date 
appliance store display current date record date pre defined action taken 
template currently supports single state multiple state instantiations 
contents contents smart template may represented different ways 
state string type may multiple states may 
single variable case type restrictions string state variable string type 
value state variable date string iso international standard formats 
appendix specification authoring study instructions multiple states represent date form month state may integer type bounds enumerated type items 
day state integer type ranging 
constant maximum may point state variable gives proper maximum month 
maximum set constant value user interface enforce proper maximum month year 
year state integer type 
bounds variable optional 
negative values state variable interpreted years bc positive years ad 
increments may specified state 
date time overview template combines date template time absolute template form complete representation dates times 
contents contents smart template may represented different ways 
state string type may template may contain groups separately instantiate date time absolute smart templates 
state variable restrictions string state variable string type 
value state variable date time string iso international standard formats 
groups groups tagged date tagged time absolute 
groups conform restrictions smart templates 
way overview template represents way directional control 
appendix specification authoring study instructions contents template may applied group includes commands 
commands left command left button directional control 
right command right button directional control 
top command top button directional control 
bottom command bottom button directional control 
way enter overview template represents way directional pad enter function 
contents template include way smart template extra command enter enter command list commands overview template commands manipulate list data adding deleting moving list items 
example nested template means template contains templates 
case list commands template may contain list add list remove list clear list move list templates 
tricky aspect list commands template linking template instance list manipulates 
done requiring template level immediately precede list group manipulates 
suggest pair commands list group placed group required 
contents list commands template supports multi state form 
constituent templates list add list remove list clear list move list move appendix specification authoring study instructions single commands 
constituent templates may outside template 
mentioned instance list commands template placed level specification tree immediately preceding list group command modify 
requirement true templates outside list commands template 
descriptions constituent templates list add commands template add new item list 
server receiving command insert item list appropriate location list 
template implementation automatically display dialog box case may rely required infrastructure determine editing dialog box displayed 
list remove commands template delete item list preferably currently selected item 
list clear commands template remove items list 
list move commands template move currently selected item higher index 
list move commands template move currently selected item lower index 
media controls overview template represents interactions control playback audio visual media cd mp vhs tape 
template supports state representations controls handles related functions track previous track 
contents appendix specification authoring study instructions smart template may represent controls single state variable commands 
state representation enumerated type standardized labels mapped value type section 
state name mode 
labels described 
labels may included addition standardized ones benefit interface generators don recognize smart template 
label identifies state media stopped 
play label identifies state media playing 
pause label identifies state media paused 
rewind label identifies state media 
fast forward label identifies state media fast forwarding 
record label identifies state media recorded 
state information available appliance command description may 
representation include commands 
commands included mode state included description 
allowable commands play pause command activated appliance playing 
command activated appliance playing 
command activated appliance pause playback 
rewind command activated appliance 
command activated appliance fast forwarding 
record command activated appliance recording 
appendix specification authoring study instructions addition having state set commands additional states commands may specified integrated rest playback controls 
commands command activated track selected 
command activated previous track selected 
note playback modes may possible probably considered 
include reverse play fast forward playing vs stopped rewind thing different speeds fast forward rewind play new answering machines time absolute overview template specifies absolute time time day 
includes time value parameters time time zone hour mode contents template supports single multi state specification methods 
single state method may represent absolute time value hour units 
value may rendered hour time value am pm depending configuration user device 
multi state method may include parameters time value described 
single state form may primitive types integer string value state variable contain number seconds midnight 
increment allowed 
appendix specification authoring study instructions value state variable form hh mm ss hh mm hours minutes seconds 
note time duration template digits may omitted significant 
words meaning 
arbitrary number digits may representing fractions second 
multiple states represent time absolute template form time state specifies time 
may types listed format 
state combination hour minute states may included 
hours state integer type 
minimum maximum 
state required time state specified may included time state defined 
minutes state integer type ranging 
state specified time state specified may included time state defined 
seconds state integer type ranging 
state included time state optional 
state optionally specified time zone 
enumerated type value label form gmt gmt specifies number hours greenwich mean time 
labels include common names time zone eastern gmt ensure generators equipped smart template render understandable interface 
state optionally specifies currently daylight savings time 
state boolean type 
state optionally specifies time specified hour mode 
state boolean type labels value 
value la appendix specification authoring study instructions hr hr 
state exists linked rendering time value included 
increments may specified significant unit 
example particular template defines hours state minutes state increment may specified minutes state 
template defines possible states may increment specified fraction state 
time duration overview template describes data stores duration time 
media player devices describe length song current playback point song display amount cooking time remains 
template supports resolutions fractions second seconds minutes hours 
fractions second resolution purposely left ambiguous may defined specification designer defining range state 
milliseconds fraction timer application frame number vcr video application 
contents contents smart template may represented different ways 
state primitive types may multiple states integer type may 
state smart template applied directly state see example 
allowable types integer value state variable contain number seconds time duration 
fixed point may set necessary 
value state variable contain number seconds time duration 
decimal component represents fractions second elapsed 
floating point value state variable contain number seconds time duration decimal component representing fractions seconds duration 
string appendix specification authoring study instructions value state variable form hh mm ss fff mm ss fff hh mm ss mm ss hours minutes seconds fractions second 
note optional omit digits significant 
words valid 
note digits required fractions second component 
multiple states represent time duration form hours state integer type 
minimum maximum may optionally specified 
minutes state integer type ranging hours state specified 
minimum maximum optional hours specified 
state included hours seconds states specified 
seconds state integer type ranging minutes state specified 
minimum maximum optional minutes specified 
state included minutes fraction states specified 
fraction state integer type 
ranges may specified fit type fraction 
increments may specified significant unit 
example particular template defines hours state minutes state increment may specified minutes state 
template defines possible states may increment specified fraction state 
zoom controls overview template represents controls zooming appliance 
contents template may include commands included zoom command 
appendix specification authoring study instructions zoom command 
appendix specification authoring study instructions appendix 
complete xml specification list application xml version encoding utf spec xmlns www cs cmu edu pebbles puc name version puc labels specification labels label puc list application label label list app label label list label labels groups groupings group name todo priority labels label list label label list label labels list group name list priority selections number state name completed priority type boolean value labels map index true labels label done label labels map map index false labels label incomplete label labels map value labels type labels label completed label labels state appendix specification authoring study instructions state name category priority type list selection list setup categories list type labels label category label labels state state name description priority type string type labels label description label label desc label labels state state name date priority type string type labels label finish label label due date label label due label labels state list group group name commands list commands priority command name add list add priority labels label add item label label add label label add label labels command command name delete list remove priority labels label delete item label label delete label label delete label labels active greaterthan state todo list length constant value greaterthan appendix specification authoring study instructions defined state todo list selection active command state name priority type enumerated item count item count enumerated value labels map index labels label category label labels map map index labels label completion date label label date label labels map map index labels label completed label labels map value labels type labels label sort label label sort label labels active greaterthan state todo list length constant value greaterthan active state group group group name setup priority labels label setup label labels state name priority type enumerated item count item count enumerated appendix specification authoring study instructions value labels map index labels label items label label label labels map map index labels label incomplete items label label incomplete label labels map map index labels label past due items label label past due label labels map map index labels label completed items label label completed label labels map value labels type labels label display preference label label display pref label label display label labels state state name priority type enumerated item count item count enumerated value labels map index labels label weekly label labels map map index labels label daily label labels map map index appendix specification authoring study instructions labels label hourly label labels map value labels type labels label reminder frequency label label reminder freq label label reminders label labels state group name categories priority labels label category setup label labels list group name list state name category type string min constant value min average constant value average max constant value max string type labels label category label labels state list group group name commands list commands command name add list add labels label add category label label add label labels command command name delete list remove labels label remove category label label remove label labels command group group group groupings appendix specification authoring study instructions spec appendix specification authoring study instructions appendix specification authoring study instructions appendix study instructions appendix contains informal document describing process employed printers 
document starts page preserve formatting 
conditions user group sequence interfaces number users physical hp physical canon physical canon physical hp puc hp puc canon puc canon puc hp puc hp uniform canon puc canon uniform hp setup equipment questionnaires background questionnaire post questionnaire actions study study hardware move pda printer position connect usb cable pda desktop point camera pda printer warm printers add appendix usability study instructions software start start stopwatch start remote display st device st task st device start recording save task times stopwatch reset stopwatch study recording save video file save task times stopwatch script research team investigating create better interfaces everyday appliances 
physical today ll multi function printers complete tasks 
ll doing set tasks printers ll set tasks printer 
puc puc puc uniform today ll controlling multi function printers complete tasks 
ll doing set tasks controlling printers ll set tasks controlling printer 
won directly interacting printers ll controlling handheld computer 
handheld computer 
multi function printer 
copier 
fax machine 
multi function printers re going print copy fax scan black white color 
study take minutes 
ll record audio video time take complete tasks 
information remain anonymous 
start sign consent form complete questionnaire 
appendix usability study instructions puc puc puc uniform re going exercises 
just familiarize interface handheld 
take time 
exercise pocket pc tutorial 
handheld computer called pocket pc 
second imagine interface shown configuration dialog box word processor 
actual tasks 
please complete offer help 
min complete task 
complete task min proceed 
min haven completed task ll prompt ask move 
required keep trying minutes finish task mins passed 
ll explicitly tell re done task ll say re done 
say means re done keep trying 
procedure task 
task ll ask turn look screen handheld computer 
ll give card task instruction 
take time read instruction time spend reading won count minutes 
keep card task put table 
look necessary 
re reading instruction ll reset interface look start new task 
appendix usability study instructions tasks appendix usability study instructions appendix usability study instructions appendix puc interfaces appendix contain number screenshots interface generated puc interfaces appliance simulators created 

full interface hp printer generated consistency seen users usability study 
appendix gallery puc interfaces 
full interface canon printer generated consistency seen users usability study 
appendix gallery puc interfaces 
full interface hp printer generated consistent canon printer seen users usability study 
appendix gallery puc interfaces 
full interfaces canon printer generated consistent hp printer seen users usability study 
appendix gallery puc interfaces appendix gallery puc interfaces bibliography ali mir ali manuel perez marc abrams eric shell 
building multi platform user interfaces uiml computer aided design user interfaces france may 
pp 

association trade association 
av digital interface command set 

www ta org 
banavar banavar authoring technology web applications ieee pervasive computing 
july sept 

pp 

banavar banavar lawrence bergman yves danny jeremy sussman 
tooling system support authoring multi device applications journal systems software 


pp 

thomas dieter 
agents talk hit back animated agents augmented reality proceedings third ieee acm international symposium mixed augmented reality washington nov 
pp 

barnard barnard hammond morton long 
consistency compatibility human computer dialogue interactional journal man machine studies 

pp 

baudisch patrick baudisch john steve ball 
flat volume control improving usability hiding volume control hierarchy user interface proceedings chi vienna austria april 
pp 

peter 
joy xul 

developer mozilla org en docs joy xul 
brouwer brouwer raymond bennett endo van nes hugo donald gentner 
interfaces consumer products computer chi human factors computing systems monterey ca may 
pp 

card stuart card thomas moran allen newell 
psychology human computer interaction 
hillsdale nj lawrence erlbaum associates 

cmu cmu 
carnegie mellon dictionary 

www speech cs cmu edu cgi bin 
cmu cmu 
speech cmu 
pittsburgh pa 

www speech cs cmu edu 
de baar de baar foley coupling application design user interface design conference human factors computing systems monterey california acm press 

pp 

denis charles denis laurent 
inter usability multi device systems conceptual framework multiple user interfaces 
eds 
john wiley sons 
pp 


digital living network alliance home page 

www org 
doan anhai doan pedro domingos alon halevy 
reconciling schemas disparate data sources machine learning approach sigmod 
pp 

eisenstein jacob eisenstein jean vanderdonckt angel puerta 
applying model techniques development uis mobile computers intelligent user interfaces santa fe 
pp 

lehman morales munson 
universal information appliance ibm systems journal 
october 

pp 

www research ibm com journal sj html 
trevisan jean vanderdonckt 
continuity property mixed reality systems comparative study portugal january 
pp 

foltz mark foltz 
gesture configuration intelligent environment proceedings mit student oxygen workshop 
gajos gajos weld supple automatically generating user interfaces intelligent user interfaces portugal 
pp 

gajos krzysztof gajos david christianson raphael hoffmann tal shaked henning jing jing long daniel weld 
fast robust interface generation ubiquitous applications seventh international conference ubiquitous computing ubicomp tokyo japan 
pp 

gajos krzysztof gajos anthony wu daniel weld 
cross device consistency automatically generated user interfaces proceedings nd workshop multi user ubiquitous user interfaces san diego january 
pp 

gajos krzysztof gajos jing jing long daniel weld 
automatically generating custom user interfaces users physical disabilities assets portland 
appear 
gomes lee gomes 
appliances pcs complex wall street journal online 
may 
www pebbles cmu edu puc wsj pdf 
grudin jonathan grudin 
case user interface consistency cacm 
cacm 
oct 

pp 

hall richard hall 
gravity supporting dynamically available services client side applications proceedings esec fse helsinki finland september 
pp 

bibliography harris thomas harris roni rosenfeld 
universal speech interface appliances international conference speech language processing icslp korea 
havi havi 
home audio video interoperability 


www havi org 
hayes philip hayes pedro szekely richard lerner 
design alternatives user interface management systems experience cousin human factors computing systems san francisco ca apr 
pp 

herman ivan herman jim hendler 
web ontology language owl semantic web activity 

www org owl 
hodes todd hodes randy katz edouard servan schreiber lawrence rowe 
composable ad hoc mobile services universal interaction proceedings third annual acm ieee international conference mobile computing networking acm mobicom budapest hungary september 
pp 

georgia tech 
projects universal remote console standard 
atlanta ga 

www gatech edu projects technology images winamp html 

universal remote console specification 
alternate interface access protocol 
washington december 
iso iso 
information processing systems open systems interconnection lotos formal description technique temporal ordering observational behavior 

ivory melody ivory marti hearst 
state art automating usability evaluation user interfaces acm computing surveys 
december 

pp 

john bonnie john david kieras 
goms family user interface analysis techniques comparison contrast acm transactions computer human interaction 


pp 

john bonnie john dario ken koedinger 
predictive human performance modeling easy chi vienna austria april 
pp 

kellogg wendy kellogg 
conceptual consistency user interface effects user performance proceedings interact conference human computer interaction stuttgart september 
kieras david kieras scott wood anthony hornof 
glean computer tool rapid goms model usability evaluation user interface designs eighth annual symposium user interface software technology pittsburgh pa nov 
pp 

kim kim marc yolanda gil 
intelligent assistant interactive workflow composition intelligent user interfaces iui madeira portugal 
pp 

bibliography kim won kim james foley 
providing high level control expert assistance user interface presentation design human factors computing systems amsterdam netherlands apr 
pp 

lieberman henry lieberman jose espinosa 
goal oriented interface consumer electronics planning commonsense reasoning intelligent user interfaces sydney australia 
pp 

limbourg limbourg jean vanderdonckt benjamin laurent bouillon victor lopez 
language supporting multi path development user interfaces th ifip working conference engineering human computer interaction jointly th international workshop design specification verification interactive systems hamburg germany 
pp 

jayant philips bernstein rahm 
generic schema matching cupid th vldb conference 
mahajan mahajan shneiderman 
visual textual consistency checking tools graphical user interfaces ieee transactions software engineering 


pp 

melnik sergey melnik hector garcia molina rahm 
similarity flooding versatile graph matching algorithm application schema matching th icde san jose ca 
pp 

merrill duane merrill 
mashups new breed web app 

www ibm com developerworks library mashups html 
microsoft microsoft 


msdn microsoft com library ms 
luca maurizio gabriele 
framework prototype interoperability middlewares xml web services international conference consumer electronics january 
pp 

mori mori fabio paterno carmen santoro 
design development user interfaces multiple logical descriptions ieee transactions software engineering 


pp 

mori mori fabio paterno carmen santoro 
support developing analyzing task models interactive system design ieee transactions software engineering 
september 

pp 

myers brad myers scott hudson randy pausch 
past user interface software tools acm transactions computer human interaction 


pp 

newman mark newman keith edwards trevor smith 
user interfaces needed infrastructure recombinant computing uist paris france october 
pp 

bibliography nichols nichols myers studying handhelds control smart appliances rd international conference distributed computing systems workshops icdcs providence ri may 
pp 

nichols nichols myers higgins hughes harris rosenfeld shriver requirements automatically generating multi modal interfaces complex appliances pittsburgh pa 
nichols jeffrey nichols brad myers michael higgins joseph hughes thomas harris roni rosenfeld 
generating remote control interfaces complex appliances uist paris france 
pp 

www cs cmu edu pebbles papers pdf 
nichols jeffrey nichols brad myers 
report standard 

www cs cmu edu papers cmu puc report pdf 
nichols jeffrey nichols brad myers kevin 
improving automatic interface generation smart templates intelligent user interfaces portugal 
pp 

nichols jeffrey nichols brad myers 
generating consistent user interfaces appliances workshop multi user ubiquitous user interfaces mu san diego ca 
pp 

www com papers pdf 
nielsen jakob nielsen 
usability engineering 
boston academic press 

markus annika 
ubiquitous interactor device independent access mobile services computer aided design user interfaces madeira 
pp 

olsen jr dan olsen jr programming language basis user interface management human factors computing systems austin tx apr 
pp 

olsen jr dan olsen jr sean travis nielsen william paul 
cross modal interaction xweb proceedings uist acm siggraph symposium user interface software technology san diego ca 
pp 

jeffrey pierce charles isbell jr dewan 
comparing user intelligent remote control interface generation personal ubiquitous computing 
april 

pp 

osgi osgi 
osgi alliance home page 

www osgi org 
paterno fabio paterno mancini 
concurtasktrees diagrammatic notation specifying task models interact sydney australia 
pp 

polson peter polson 
test common elements theory transfer sigchi conference human factors computing systems new york ny acm press 

pp 

bibliography polson peter polson 
consequences consistent inconsistent user interfaces cognitive science applications human computer interaction 
hillsdale nj lawrence erlbaum 
lee fox hanrahan winograd 
service framework ubiquitous computing environments comp atlanta georgia 
pp 

puerta puerta eisenstein common representation interaction data th international conference intelligent user interfaces san francisco 
pp 

puerta angel puerta 
model interface development environment ieee software 
july august 

pp 

reisner reisner 
formal grammar human factors design interactive graphics system ieee transactions software engineering 
march 
se 
pp 

reisner reisner 
inconsistency interact 
pp 


design languages bringing design software 
winograd ed 
new york addison wesley acm press 
pp 

rich charles rich candy sidner neal lesh andrew garland booth markus 
graphical user interface framework human computer collaboration ieee international conference distributed computing systems workshops june 
pp 

rosenfeld roni rosenfeld jr olsen dan alex rudnicky 
universal speech interfaces interactions new visions human computer interaction 

viii 
pp 

nick brian katrina chapman 
code generation mobile devices domain specific xml source languages 


unix eng ua edu reu doc 
john lorne 
user interface consistency user applications effects mental models journal information management systems 


pp 

shriver shriver toth zhu rosenfeld unified design human machine voice interaction extended abstracts chi seattle wa march april 
pp 

pavel jerome euzenat 
survey schema matching approaches journal data semantics 

sproat sproat hunt ostendorf taylor black sable standard tts markup international conference spoken language processing sydney australia 
bibliography srivastava srivastava java koehler 
web service composition current solutions open problems workshop planning scheduling web grid services 
pp 

staab steffen staab web services done ieee intelligent systems 


pp 

sukaviriya sukaviriya james foley 
coupling ui framework automatic generation context sensitive animated help acm sig graph symposium user interface software technology snowbird utah oct 
pp 

sukaviriya sukaviriya james foley todd griffith 
second generation user interface design environment model runtime architecture human factors computing systems amsterdam netherlands apr 
pp 

sun sun 
jini connection technology 


sycara katia sycara massimo paolucci ankolekar naveen srinivasan 
automated discovery interaction composition semantic web services journal web semantics 


szekely szekely sukaviriya castells declarative interface models user interface construction tools mastermind approach th ifip working conference engineering human computer interaction grand resort 
pp 

szekely pedro szekely ping luo robert neches 
facilitating exploration interface design alternatives humanoid model interface design human factors computing systems monterey ca may 
pp 

szekely pedro szekely 
retrospective challenges model interface development nd international workshop computer aided design user interfaces namur namur university press 
june 
pp 

stefanie roni rosenfeld 
speech graffiti vs natural language assessing user experience hlt naacl boston ma 
upnp upnp 
universal plug play forum 


www upnp org 
vander zanden brad vander zanden brad myers 
automatic look feel independent dialog creation graphical user interfaces human factors computing systems seattle wa apr 
pp 

vanderdonckt vanderdonckt 
knowledge systems automated user interface generation trident experience technical report rp namur notre dame de la institut informatique 
vanderdonckt vanderdonckt 
advice giving systems selecting interaction objects user interfaces data intensive systems 

pp 


resource description framework rdf 

www org rdf 
ward ward 
cmu air travel information service understanding spontaneous speech darpa speech natural language workshop 
bibliography wiecha charles wiecha william bennett stephen john gould sharon greene 
tool rapidly developing interactive applications acm transactions information systems 
jul 

pp 

bibliography 
