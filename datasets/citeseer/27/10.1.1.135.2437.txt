dynamic software updating michael hicks dissertation computer information science faculties university pennsylvania partial fulfillment requirements degree doctor philosophy scott nettles supervisor dissertation val tannen graduate group chair copyright michael hicks dissertation achievement bears name possible help 
foremost god 
hidden guiding force life source strength writing document days graduate student 
close second family especially wife 
especially patient understanding anticipated year process ended years 
son timothy born research close companion writing dissertation 
days asleep typed away park bench 
times divided time baby provided great joy possible challenging complete 
parents deserve credit things teaching things come hard 
brother served constant source inspiration showing short term sacrifice lead reward love possible 
support people difficult complete ph know research advisor 
scott patient encouraging guide showing way demanding move faster slower ready 
provided structure allowed great independence encouraging exploration self improvement 
done research areas creating foundation exciting things come 
advisor jonathan smith 
jonathan generous support scott left penn nearly years ago 
getting degree 
jonathan wonderful friend support looking best interests despite inconvenience 
committee input feedback 
competence programming language theory owe benjamin pierce 
wonderful course type systems provided insight information greatly broadened understanding area 
greg morrisett great source insight intuitions systems person completely relevant way programming languages designed implemented 
greg students karl crary stephanie weirich contributed greatly theoretical aspects specifically chapters process taught lot area 
lee mark segal provided excellent suggestions drawing research experience dynamic updating 
working distributed systems lab wonderful experience personally professionally 
friends contributed iii varying levels preceded 
jonathan moore member mike jon show research companion projects owe success 
importantly jon wife jessica best friends 
scott alexander result claim thesis inadvertently provided thesis topic 
received excellent feedback encouragement great including luke hornof steve muir jessica ioannidis angelos keromytis 
forget games ii day find way experiences add value research possible see levine bl 
wonderful years 
iv dynamic software updating michael hicks supervisor scott nettles important applications run continuously interruption changed fix bugs upgrade functionality 
date existing general purpose methodology dynamic updating achieves practical balance flexibility robustness low overhead ease 
new approach imperative languages provides type safe dynamic updating native code extremely flexible manner code data types may updated programmer determined times permits automated tools aid programmer updating process 
system dynamic patches contain updated code code needed transition old version new 
novel aspect patches consist verifiable native code vnc see nec mwcg native code accompanied annotations allow line verification code safety 
discuss patches generated automatically applied novel dynamic linking technology vnc systems code compiled updateable 
concretely illustrate validate system implemented sizeable application dynamically updateable web server called flashed 
discuss experience building maintaining flashed 
performance experiments show updateable flashed runs roughly slower static various workloads 
contents iii motivation 
redundant hardware 
state transfer 
dynamic linking 
thesis 
goals criteria evaluation 
evaluating past characteristic 
flexibility 
robustness 
efficiency 
ease 
summary 
approach strategy 
limitations 
evaluating approach 
contributions 
roadmap 
background tal 
popcorn 
control flow 
data 
functions 
parametric polymorphism 
type abstraction 
added features 
vi dynamic linking tal background 
static linking 
dynamic linking 
tal load 
load calculus 
untyped load calculus 
adding types 
adding named types 
properties load calculus 
implementation 
passing types runtime 
load 
checked cast 
discussion 
load calculus type environment masks 
implementing type environment masks 
dlpop dynamic linking tal load dlpop type safe dlopen 
compilation 
dynamically linked files 
statically linked files 
dlpop library 
discussion 
examining dyninit 
programming linking strategies 
dynamic updating dynamic patches :10.1.1.161.3137
changes code data :10.1.1.161.3137
changes type definitions :10.1.1.161.3137
limitations :10.1.1.161.3137
enabling dynamic patches :10.1.1.161.3137
code data updates :10.1.1.161.3137
updating type definitions :10.1.1.161.3137
dlpop update dlpop supporting updating :10.1.1.161.3137
patches :10.1.1.161.3137
dlpop update library :10.1.1.161.3137
compilation :10.1.1.161.3137
discussion :10.1.1.161.3137
updating pointers functions data :10.1.1.161.3137
loaded code garbage collection :10.1.1.161.3137
updating indirection :10.1.1.161.3137:10.1.1.24.6526
vii building updateable systems constructing dynamic patches 
automatic patch generation 
apply patches 
interrupt model 
invoke model 
flashed updateable webserver building flashed updateable 
update timing 
fatal error handling 
updating flashed practice 
update chronology 
patch construction 
testing patches 
lessons learned 
performance dynamic updating component costs 
runtime overhead 
load time overhead 
start time overhead 
space overhead 
application performance 
flashed performance 
functional languages :10.1.1.24.6526
pointers updateable definitions :10.1.1.24.6526
closures :10.1.1.24.6526
limitations :10.1.1.24.6526
object oriented languages :10.1.1.40.2507
update validity state visibility :10.1.1.40.2507
globally visible state :10.1.1.40.2507
module protected state :10.1.1.40.2507
thread maintained state :10.1.1.40.2507
data :10.1.1.40.2507
active networks :10.1.1.40.2507
improvements :10.1.1.40.2507
unchecked updates :10.1.1.40.2507
namespace management security :10.1.1.40.2507
updating types :10.1.1.40.2507
contributions :10.1.1.40.2507
viii proofs formal properties tal load load calculus 
syntax 
operational semantics 
static semantics 
properties type environments 
properties heaps 
properties type derivations 
type soundness 
related state transfer 
process migration 
checkpointing 
general purpose persistence 
linking 
static linking 
dynamic linking 
dynamic updating 

dynamic module replacement argus 
conic 

reconfigurable polylith 
line software version change 
erlang 
dynamic ml 
dynamic classes 
dynamic java 
dynamic java classes 

guarded software updating 
dyninst 
dynamic architectures 
bibliography ix list tables evaluating previous general purpose updating systems 
summary changes versions flashed 
overhead got 
time load link patches flashed 
breakdown space overhead components files linked dynamic linking dynamic updating 
symbol object file overheads due dynamic linking updating 
space overhead flashed compiled loading updating 
list figures plug extensibility extensions plugged extension interface running program 
trusted untrusted components implementation tal 
modules linked 
untyped load calculus syntax 
operational rules untyped calculus excluding load 
rules load untyped calculus 
typed load calculus syntax minus named types changes formedness types heap types 
formedness expressions heaps programs 
load calculus syntax including support named types 
additional modified rules defining formedness types heap types expressions heaps programs 
type environments type environment values operators relations implementation load 
code sequence tal macro instructions 
operational rules load type environment mask 
dlpop library interface 
dlpop dynamic loading example 
compilation dynamically loadable code 
compilation statically linked code 
popcorn code dynamic symbol table lookup 
compilation dynamically loadable code resolve functions demand compilation dynamically loadable code runtime code generation example file main pop pop main function :10.1.1.161.3137
dynamic patch main pop main pop :10.1.1.161.3137
dynamic patch main pop main pop stub :10.1.1.161.3137
dynamic patch main pop main pop stub :10.1.1.161.3137
alternative notion dynamic patch pop main pop convert :10.1.1.161.3137
ways update code data :10.1.1.161.3137
methods updating type definitions replacement renaming :10.1.1.161.3137
patch description interface code files :10.1.1.161.3137
patch description interface code files :10.1.1.161.3137
xi converting patch file popcorn file :10.1.1.161.3137
converting patch file popcorn file :10.1.1.161.3137
compiling code loadable updateable :10.1.1.161.3137
compiling patch file loadable updateable :10.1.1.161.3137
compiling statically linked file updateable :10.1.1.161.3137
file fnptr pop uses function pointers :10.1.1.161.3137
attempt patching code :10.1.1.161.3137:10.1.1.24.6526
patch fnptr pop :10.1.1.161.3137:10.1.1.40.2507
copying array dynamic update :10.1.1.161.3137
indirection dynamic symbol table :10.1.1.161.3137:10.1.1.40.2507
implementation module hashtable dynamic symbol table :10.1.1.161.3137
dynamic symbol table rollback list dynamic update :10.1.1.161.3137
building maintaining updateable program 
structure automatic patch generator tool 
old new versions example file foo pop 
patch supporting files generated foo pop 
models updating single threaded program 
structure flashed flashed update procedure 
timeline major flashed updates 
code accessing external values got 
component costs dynamic linking relative file size 
space overhead loadable updateable flashed object files 
space overhead loadable updateable flashed types files 
log test 
flash flashed throughput mbits sec log test 
flash throughput url tests 
correlating overhead url file size :10.1.1.24.6526
transforming fnptr pop loadable updateable :10.1.1.24.6526
transforming fnptr pop notice updates function pointers :10.1.1.24.6526
interface popcorn fn module :10.1.1.24.6526
active router supporting user extensions :10.1.1.24.6526
facts load success case proof subject reduction :10.1.1.40.2507
xii chapter computer programs non provide continuous uninterrupted service 
especially true mission critical applications telephone switches financial transaction processors airline reservations air traffic control systems 
addition importance internet link global economy broadened needs making non service important sophisticated users participating commerce 
non systems immune need upgrades bug fixes 
simplest case software changes require system shut updated brought back line 
approach consequences 
state accumulated application lost old application shut 
second processing progress time shutdown canceled 
situations consequences acceptable 
example program state cache kind losing affect performance correctness 
similarly properly architected transaction system prevent canceled processing adversely affecting stable state 
worst case lost state canceled processing may translate lost revenue compromised safety incorrect execution 
general non systems require ability update software service interruption 
goal show dynamic software updating achieved practical general purpose manner flexible efficient robust easy 
demonstrate thesis built dynamic updating system show desired characteristics 
furthermore system built non trivial dynamically updateable application flashed webserver 
explain flashed updated time doing show system flexible easy 
argue flashed robust due measures promote program patch correctness including automated safety checking automatic patch generation compilation library support simple implement small trusted component 
show updating system imposes negligible overhead flashed performance 
motivation enabling dynamic software updating new problem solutions exist widely deployed 
past approaches general purpose application specific generally employ mechanisms realize dynamic updating state transfer dynamic linking 
past systems employ state transfer redundant hardware 
highlight elements approaches point weaknesses motivating 
redundant hardware systems require dynamic code updates non frequently employ redundant hardware support fault tolerance 
result updating approaches assume redundant hardware 
generally speaking perform line upgrade approaches secondary machine loaded new code passed necessary state primary switched primary system 
example approach employed digital messaging system airlines developed maintained ari 
system uses centralized special purpose router relaying messages aircraft 
enable dynamic updates improve robustness router consists machines primary hot standby 
primary machine software addition performing message processing engineered communicate state standby machine periodically demand 
system needs updated new software loaded standby machine immediately requests state transfer primary initialize 
machines switch roles updated machine primary starts processing messages 
standby machine loaded new software completing update 
architecture similar employed lucent ess tm circuit switches es 
systems avoid transferring state directly machines keeping stable storage say database 
new version program starts reads startup state database 
primary secondary architecture frequently generalized arbitrarily machines increase availability 
incoming transactions routed available servers servers brought needs demand 
example visa mainframe computers run line transaction processing system 
system updated times year tolerates downtime pes 
parts system brought updated new software brought back line operating mainframes continue process transactions 
popularity technique combining redundant hardware state transfer obviously effective 
especially appealing situations redundant hardware required anyway support fault tolerance 
prefer formulate approach dynamic updating requires redundant hardware reasons 
redundant hardware adds cost complexity 
system require redundant hardware reasons prefer require software updating 
fact systems require non service employ fully redundant hardware 
examples include communications components updates year quite high unable get visa better explain number 
regardless believe updates occur reasonably frequently 
routers firewalls nat translators sophisticated internet servers medical monitoring systems 
furthermore non redundant systems necessarily require non service certainly benefit 
example having reboot pc time os upgraded prefer realize updates dynamically 

updating system requiring redundant hardware relevant systems happen 
hand concerns fault tolerance say updating may prevent sharing implementation mechanisms state transfer hand resulting design general modular 
state transfer addition redundant hardware state transfer performed processes running machine 
general making application updateable state transfer uses redundant hardware requires programmer system things 
identify state need transferred new version 
call persistent state persist application versions 
state referred ephemeral 

develop means encode decode persistent state means transfer old new version 

build new version able start old version decoded state potentially transforming state usable new code 
application specific approaches employ state transfer ones described previous subsection typically require programmer perform tasks tedious potentially quite difficult impossible 
example relating point state stored operating system process file descriptor associations readily transferred machines processes persistent 
similarly state stored application libraries may available hidden library interface 
example current value seed random number generator 
regarding point complicated persistent state tedious encode decode 
example pointers need platform independent captured simply recording address running process 
addition depending state encoded transferred restarting program state overly time consuming example state information stored incrementally log format entire log replayed regenerate state seg 
application specific state encoding decoding transfer state get job done prefer general purpose approach ignoring points focusing truly application specific task state transformation 
prefer assume state program potentially persistent removing guesswork possible error programmer 
frees database special purpose mechanism requirements demand simplifying program construction 
furthermore system perform encoding decoding state automatically opposed requiring programmer 
number general purpose approaches enable state transfer developed 
example checkpointing pla general purpose persistence means generally automatically capture program state restart support process migration smi 
approaches number problems 
application specific state transfer os level datastructures general captured 
includes file descriptors open socket connections 

approaches process image dependent simplifies process capturing restoring state state unusable different process images 
interesting updating process new code image obviously change capture restore state 

approaches provide portable state capture different architectures hof rs state stored form principle allow different process images 
practice case 
captured state matches structure capturing program importantly stack making simple program problematic 
furthermore general pointers distinguished integers user assistance problem occurs conservative garbage collection bw 
source source translation enable portable state capture introduces potentially significant overhead running code due code insertions required unwind stack 
despite limitations automatic state transfer successfully employed number systems scenarios perform support dynamic updating gj hof tta 
particular os resident data structures need captured global state simple program structure appreciably changed automatic state transfer serve elegant means upgrade halting service 
limitations state transfer preclude application larger systems commerce servers connection data socket file descriptor table stored os 
rules sizeable class applications losing connections update time unacceptable 
problems solved application specific approaches effort 
short state transfer core dynamic updating technology requires sacrificing flexibility general purpose tool potentially performance adding complexity cost application specific approach 
way programmer bears greater burden software updateable 
specialty operating systems perform state capture eros ssf 
main program client extension interface extension extension plug extensibility extensions plugged extension interface running program 
dynamic linking systems employ dynamic linking realize software adaptability 
sense dynamic linking converse state transfer trying move program state different program move program state 
result need redundant hardware redundant processes programmer longer needs identify persistent state develop means capture restore 
programmer need transform state necessary new code requirement state transfer 
addition dynamic linking popular quite simple implement decreasing system complexity verify loaded code safe java simplicity safety improve system robustness 
dynamic linking flexibility problems 
common dynamic linking implements plug extensibility approach loaded code constrained match pre defined signature expected clients correctly formed loaded code called plug 
plug ins systems including called extensible operating systems spin bsp exokernel commodity operating systems linux adaptable distributed systems cactus cac ens web browsers 
plug extensibility insufficient dynamic updating simply parts system plug ins allowed change 
plug extensibility essentially plug extensibility technique abstracts shape loadable code 
loaded code accessed running program client extension interface 
extensions internally consisting arbitrary functionality may accessed client extension interface change time 
idea illustrated abstractly 
plug extensibility programmer things 
identify elements program subject change 
plug ins program 

create common interface components rest program 
plug ins systems 
example linux kernel plug ins things implement socket handlers various protocols 
handler interface networking code consisting socket interface functions 
handler implement open function connect function close function user attempts open socket particular type say ipx handler socket type loaded open function invoked 
uses socket ipx handler 
active programmable network implementations frequently employ plug extensibility wgt mbc having goal evolving network service demand 
example consider planet active internetwork 
planet level architecture provides lightweight limited programmability packets network general purpose extensibility routers 
packet headers replaced programs written special purpose language plan hkm resulting greater flexibility traditional headers 
packets arrive node evaluated plan programs may call node resident service routines form second level architecture 
service routine space extensible allowing new service routines installed removed stopping execution system 
implemented dynamically linking code implements new service registering symbol table plan interpreter 
planet services plug ins 
time plan program invokes service service name looked symbol table corresponding service routine returned function pointer 
lookup code know particular services type function returned match extension interface just socket handler linux match socket interface 
case services take arguments variable length list plan values plan packet return plan value 
plug ins convenient kinds changes may give current code interface deal changes 
linux case socket code care code calling perform proper kind function setting socket object returning 
similarly plan services caller plan interpreter cares service function performs action arguments returns plan value 
plug ins simply easily implement bounded changes program easily support arbitrary changes dynamically 
potentially parts system plug ins changed 
example add new service routines planet upgrading service api plan programs alter planet low level components plan interpreter way plan programs encoded wire way packets queued code implements features plug subject change 
argue system constructed possible components plug ins 
argued extensively hn task converting program hand components plug ins non trivial 
furthermore converted program harder read contains sizeable amounts scaffolding code enable various types plug components 
prefer conversion automatic allowing programmer write code traditional manner 
essence approach taken realizing dynamic software updating 
thesis discussed far existing technologies dynamic software updating important limitations 
employing redundant hardware adds system cost complexity needed enabling technologies state transfer dynamic linking flexible 
current solutions employ applicationspecific techniques places extra burden programmer obviously formulated approaches general 
past researchers recognized problems formulated generalpurpose approaches dynamic updating achieve reasonable level success 
defer detailed discussion strengths weaknesses systems chapter summarize saying prior system emphasizes system practicality 
result motivated explore space possibilities general purpose dynamic software updating systems eye building system practical 
practical updating system 
practical system flexible limitations change reflected dynamically stopping service 
addition practical system robust potential error chance system crash behave incorrectly 
efficiency primary importance non systems high performance 
system hard generally means ease burden crafting dynamic updates critical system success 
existing generalpurpose systems lack areas flexibility robustness efficiency ease 
aim improve state art dynamic software updating drawing successes past efforts overcoming limitations 
short aim show dynamic software updating meaning arbitrary modification program runs achieved practical manner flexible robust efficient easy 
prove assertion explored space defined criteria carefully analyzing mechanisms prior experimenting new mechanisms 
result research analysis built system arguably meets requirements flexibility robustness efficiency ease 
test system practicality built non trivial application webserver system update time 
experience eminently useful demonstrate updating system practicality process updating webserver shed light areas improve updating system 
chapter carefully defining evaluation criteria flexibility robustness efficiency ease 
evaluate specific past general purpose dynamic updating light criteria identifying techniques successful pointing areas need 
outline approach chapter argue satisfies evaluation criteria 
remainder dissertation describes approach detail 
chapter goals believe practical system dynamic software updating satisfy criteria flexibility robustness efficiency ease 
chapter define criteria detail context argue sufficiently measure practicality updating system 
evaluate past approaches highlighting previous systems setting stage approach chapter remainder dissertation 
criteria evaluation examine evaluation criteria closely flexibility judge effectively system supports dynamic updates 
flexible system able reflect needed change point 
ideally general purpose updating system flexible part running program updated way requiring downtime 
specifically arbitrarily altering source files program creating version able reflect changes dynamically running program 
updating system ideal impossible reflect change dynamically 
programmer retain ability determine program execution update applied 
words restrictions timing update say avoid race conditions manipulating existing state imposed programmer system 
system imposes timing restrictions update update properly applied 
system may provide means aid programmer properly time update programmer provided constraints 
example delay applying update certain functions modules inactive 
robustness applications candidates dynamic updating mission critical continuously provide correct service 
making program updateable compromise requirement 
particular greater chance system crash lose data perform incorrect operations fail due update greater risk application uses 
proving updates correct undecidable cf 
gup improve robustness dynamic updates mechanisms realizing number tractable ways providing full guarantee correctness reduce possibility error 
identified important robustness properties updating systems seek achieve 
safety malformed incorrect updates cause running system crash 
guarantee requiring updates safe 
particular safe update perform illegal operations lead crash dereferencing null pointer indexing array outside bounds adding integer string typically notions safety encompass understood programming language concept 
java virtual machine jvm ly popularized safety security mechanism loaded code 
context non mission critical systems safety especially powerful property rules crashes halt service result lost transactions inconsistent state 
safety verified automatically 
case program updates prefer verify safety system uses update say load time 
checking simplifies safety violations handled update easily discarded known unsafe 
safety ensured runtime checks safety violations may go undetected time making harder remove faulty update return system safe configuration 
completeness rigorously show dynamic update correct show complete meaning update addresses changes new version old 
words change call old new source code corresponding code element update addresses 
just important makeup dynamic update time applied choosing incorrect time may things result inconsistent state due race conditions 
show timing update result error 
simplicity correct updates little applied buggy implementation 
way reduce implementation errors simple simpler system easier understand greater likelihood correct 
prefer simple updating methodology 
complicated process building updating system greater chance error 
system enforces safety defined concerned trusted computing base tcb 
security terminology tcb defined system hardware software function correctly order enforce security policy 
context policy enforced loaded code safe tcb consists code verifies safety code verifier relies 
improve likelihood tcb correct prefer kept small simple ss 
added motivation case elements implementation reside outside tcb implementation provably safe 
rollback enabled prefer updates correct applied line system mistakes slip past testing verification procedures 
desire means roll back system original form discovering applied update buggy 
systems may support rollback limited window update 
example rejecting update safety checking viewed small rollback window rolling back failed state transformation say due raised exception presents larger window 
rolling back arbitrary times update obviously general 
efficiency systems require non service high performance web servers transaction processors enabling program updateable impact performance little possible 
ease system applicability determined ease 
fine tools products ignored simply easy 
consider system easy reduces workload programmer reduces complexity tasks performed 
way updating system easy clearly separate process update development software development 
example new version software finished patches developed dynamically update running system new version 
way developers construct software test needing think updates effectively making software construction patch construction modular components development process 
modularity known technique reducing complexity 
automation employed reduce programmer workload making system easier 
fact automatic safety checking described cited means reduce programmer workload software complexity prevents large class bugs cropping 
forms automation may useful means identify changes versions software 
argued practical system criteria necessary argued total criteria sufficient 
criteria important evaluating updating systems 
example deployable system readily applied legacy systems language families 
example portable system variety architectures 
elegant system 
elegant mathematical definition 
important criteria believe lesser importance 
need flexible robust usable low overhead system worry portability portability central goal building useful system 
may readily consider goals foundation establish 
system flexibility robustness efficiency ease sf si dynamic linking argus conic polylith erlang dynamic ml dynamic dynamic java classes dyninst ok flexibility timing abbreviations robustness property abbreviations enforces dynamic constraints sf safety ok timing restrictions completeness si simplicity rollback enabled table evaluating previous general purpose updating systems evaluating past number researchers designed built software approaches dynamic updating different emphases 
section examine number systems light criteria practicality identifying 
shall see number inherent tradeoffs design decisions concerning updating system 
table summarizes evaluation past general purpose dynamic updating 
systems mechanisms consider roughly chronologically dynamic linking exists various languages lee argus blo bd conic mk fs sf polylith hof online software version change gj gup erlang hau dynamic ml dynamic hg dynamic java classes mpg snc guarded software updating tta tta dyn inst bh :10.1.1.109.1634:10.1.1.36.8435
systems proposed acr fully explored examine 
addition consider past general purpose approaches application specific methodologies 
detailed survey related appendix 
useful surveys gupta gup segal sf 
purpose filling table criteria quantitative follows flexibility broken parts changes effected dynamically changes take place program execution 
consider system fulfilled part allows essentially arbitrary updates significant programming language feature restricted dynamic updates 
break updates take place parts 
identify system imposes restrictions update timing 
second note system provides support enforcing dynamic timing constraints 
robustness broken sub criteria identified safety sf table completeness simplicity si rollback enabled 
system provide automatic provable property demonstrated gupta gup undecidable consider system support provides support programmer ensure 
consider system efficient works high performance code imposes negligible runtime cost programs updating relative programs 
consider system easy provides means reduce complexity updating problem 
example system provide clear separation regular update development provide automated means developing patches user interested particulars system referred sb attempted text highlight key aspects system requiring exhaustive summary 
presentation structured evaluation criteria 
flexibility flexibility important criterion regard software updating flexible system line update possible 
hand higher flexibility means reduced robustness terms implementation update complexity possibly reduced safety 
systems favored robustness flexibility chosen limit application domain 
example dynamic ml limits flexibility favor completeness ease 
updating system practical support essentially arbitrary updates 
consider facets flexibility changes effected dynamically system changes effected 
changed systems satisfy aspects flexibility criterion 
flexible system permits changes functions data type definitions loop bodies concurrent programs 
erlang dyninst similarly flexible special support loops additionally support updating type definitions little consequence loaded code type checked 
argus permits replacement groups distributed multi threaded processes called guardians 
contrast previous systems sacrifice flexibility favor criteria 
dynamic linking number systems app nicely supports extensible software useful effecting arbitrary change see 
hand basic implementations reasonably simple program bindings stable easy see dynamic change correct 
approaches polylith state transfer underlying updating technology suffer limitations technology see 
hand systems fit distributed context state transferred programs machines 
systems exercise tradeoffs 
conic programming environment distributed systems considers changes process level allowing adding moving removing processes process communication channels 
changes process code supported state preserved understanding effects update simpler 
dynamic ml permits updating modules export types module signatures may change arbitrary ways functions data change type 
restriction allows elegant copying garbage collection change implementation type 
focuses legacy software customization software evolution consider number useful changes dynamically changing type definitions 
dynamic java classes permit user directed state transformation system fills default values new state permit arbitrary changes class signatures 
restrictions ensure classes updated correctly 
restricts new code existing state modification requires new code roughly external behavior terms messages sends old code restrictions permit old new versions code run concurrently permitting rollback old code errors detected see 
restrictions systems added value areas system practical terms supporting wide array dynamic changes 
changes take place systems permit changes take place time program execution dynamic ml dynamic java classes forbid updates active code code activation record stack 
typically ensure version module class may system time 
similarly conic requires updates occur modules quiescent meaning modules performing processing waiting receive transactions 
cases intent increase update robustness preventing ill timed updates 
unfortunately ill timed updates prevented perfectly legal updates ruled 
cases updates active code allowed systems transition old new code defined points procedure calls erlang object creation dynamic classes 
dyninst updates take place immediately old code modified place jump trampolines mitigate entry exit new code snippets 
systems provide system enforcement programmer determined timing constraints 
argus conic modules updated quiescent quiescence defined programmer part module definition 
systems support delaying updates certain timing constraints met 
example user specify update delayed number modules procedures inactive 
cases constraints truly dynamic argus statically defined part module 
provide obvious increase flexibility mechanisms largely unproven 
possible reasons determining appropriate constraints undecidable general little experience realistic applications systems 
robustness assurances robustness updating system little practical flexible integrity non system question 
tradeoff flexibility robustness exists contexts 
example strongly typed languages java lose expressiveness unable pointer arithmetic manual memory management ensure programs crash java flexible flexible 
addition facets robustness increase complexity implementation 
system strive provide high level robustness preserving reasonably high level flexibility 
existing systems favor different sides flexibility robustness tradeoff 
dynamic ml favors robustness supporting type safe language sml guaranteeing complete patches providing rollback 
supporting features led complex implementation 
hand dyninst provides high degree flexibility uses unsafe language relies complicated implementation little support assure patches correct 
dyninst focuses robustness targeted instrumenting existing programs modifying arbitrarily long term simplifying typical modifications 
systems fall 
consider robustness property individually 
safety providing safety effective ways ensuring high degree robustness 
cases safe programs crash boon non systems 
anecdotally safe programs crash barring implementation bugs small tcb important 
statically typed languages sml catch bugs type checking phase 
said safety comes slight decrease flexibility making safe languages inappropriate contexts 
said number previous approaches safe languages java sml majority systems 
safe languages erlang statically typed meaning dynamic update safety ascertained link time 
erlang dynamically typed meaning type errors may arise runtime making potentially difficult system recover faulty update error arise long update applied 
number soft type systems developed erlang somewhat mitigating problem mw aa 
completeness system complete programmer may assured update addresses changes resulting new version code 
completeness essentially syntactic property definition changes old new version update contain code deals change 
past systems concerned enabling dynamic updating mechanisms form content updates 
little attention paid completeness closely tied update mechanism realize 
exception dynamic ml provides simple updating interface 
module replaced implementation types may change 
update existing module code replaced new code existing instances type translated new implementation user provided code 
user writes new module version new code provided ensuring update module complete 
case narrow scope may updated localizes notion completeness 
general case completeness global property essentially requiring automated support prove presence 
systems possible ensure update programmer assistance 
dynamic ml dynamic java classes provide inadequate support 
systems module update may occur time module active necessary module inactivity sufficient guard race conditions 
example module manipulating updated module state update occurs 
problem fixed extensive changes systems 
gup prove imperative programs proce certain circumstances 
simplicity simple implementation correct introduce fatal errors :10.1.1.24.6526
simple implementation tends portable 
unfortunately simplicity quality flexibility robustness tradeoff comes play 
particular flexibility comes larger potentially complicated implementation 
systems simple implementations erlang simple hau describes implementation sufficiently flexible 
systems provide flexibility complex group mechanisms 
example enforce system imposed programmer specified timing constraints runtime requires support examining program stack return addresses pointing relevant module lee fs mpg potentially means delaying update addresses lee fs 
presence multi threading thread stacks traced determining activeness may require locking procedure entry exit lee 
uses segmented virtual memory requiring potentially complex os support implemented directly simulated user space argus leverages language constructs persistent transactions recovery difficult implement 
systems enforce type safety require verification software part potentially large trusted computing base 
particular trusted compiler employed updating systems argus conic dynamic ml dynamic linkers ocaml haskell 
source language safety checked compilation target language safety assured effect trusting compiler introduce violations 
argus ocaml conic go bit ensuring target code link safe interface advertised target code confirmed verified consistent context running program linked 
java systems verify safety target code java jvm compiler javac untrusted 
target code virtual machine bytecode trust jvm interpreter trust just time jit compiler translates jvm code machine code verification 
rollback enabled robustness properties look prevent errors arise conversely rollback reverse damage caused faulty update 
past systems focused enabling updateable programs rollback considered important 
systems provide short term rollback 
argus provides rollback updating system se transaction facility leveraged updating system 
parts update transaction rolled back failure 
dynamic ml provides similar kind rollback 
new code type loaded existing instances type converted match definition new code 
translation process exception raised entire update aborted system rolled back state just update occurred 
dynamic ml leverages copying garbage collection mechanism enable 
system proposed general form error detection rollback :10.1.1.40.2507
updated code runs separate process concurrently existing code changes messages sent new code checked accuracy acceptance tests messages sent old version logged 
erroneous message detected old version restored 
switch semantically consistent employs checkpointing technology pla checkpoint state old version known consistent system roll back state failure 
checkpointing enable new version state old version 
unfortunately enabling error detection recovery technology limit flexibility underlying updating system see 
efficiency systems appear reasonably efficient demonstrate experimentally adding additional runtime overhead modest added indirection function call 
exceptional cases sacrificed level efficiency gain elegant flexible updating model 
introduces high function call overhead due extensive locking sequences call 
support owes need track active procedures modules multiple threads 
similarly potentially high procedure call overhead uses system calls os leverage segmented virtual memory simulating segmented virtual memory user space reduces cost loss flexibility 
segmented virtual memory allows multiple versions code coexist allowing relaxed transition semantics update 
dynamic java classes lose significant performance majority support dynamic updating built single bytecode interpreted jvm simplify implementation 
dyninst loses performance due trampolines change function results branch trampoline code saves restores machine state jumping returning new code 
ease systems focused usability favoring flexibility robustness 
result systems lack clear separation update development versus normal development meaning code relating updates intermixed normal development code making development maintenance difficult modular 
little focus automation reduce update complexity 
systems nicely separate update code normal code dynamic ml 
programmer writes new version program old concern patches 
development testing finished state transformer function written transform running program state form usable new version 
dynamic ml similar functions defined type module changed 
dynamic java classes degenerate form dynamic ml class transformation code generated automatically somewhat 
conic separates reconfiguration directions normal code 
systems provide automated support reduce complexity updating process 
provide support enforcing runtime timing constraints 
support marginally helpful determining correct constraints quite complicated 
automatically enforce certain syntactic constraints 
argus transactions greatly simplifies keeping runtime state consistent update 
hand syntax semantics argus language unintuitive 
summary maximizing benefit updating system means trading various evaluation criteria 
mechanisms approaches explored past extensive system focused certain areas design space cases favoring robustness flexibility performance reverse 
prior system effectively balanced tradeoffs truly practical 
section describe borrowing mechanisms systems placing emphasis simplicity ease arrive practical system 
chapter approach previous systems strengths areas flexibility robustness low overhead ease system strong areas 
chapter outline approach argue finds sweet spot meeting evaluation criteria provides sufficient flexibility robustness imposes low overhead easy 
outlining strategy taken designing building general purpose updating system describing major elements system process 
discussion evaluate system show meets evaluation criteria 
strategy section describe strategy took developing dynamic software updating system 
start considering core technology employ describe build ultimately support general purpose dynamic updating 
presentation strategy mirrors structure remainder document section serves technical overview outline applicable indicate chapters develop point 

build dynamic linking 
obvious mechanisms choose foundation approach state capture restore polylith code insertion trampolining dyninst dynamic linking 
state capture known flexibility limitations see 
trampolining number disadvantages including implementation complexity execution time overhead platform dependence 
type safe dynamic linking meets quite number evaluation criteria shown table lacks sufficient flexibility see 
strategy start dynamic linking build needed flexibility top keeping simple implementation small trusted computing base 
essence alluded develop automated way converts program module plug 

verifiable native code 
existing type safe dynamic linking implementations drawbacks 
cases trusted computing base includes trusted compiler source language safety verified target language safety 
systems java verify target language safety cost slow byte code interpreter including large jit compiler tcb 
verifiable native code vnc systems proof carrying code pcc nec typed assembly language tal mwcg mitigate problems permitting native code verified safety :10.1.1.40.2507:10.1.1.24.6526:10.1.1.24.6526
approach avoids performance cost byte code interpretation security cost having compiler tcb 
implementation chose typed assembly language 
tal defines framework native machine code coupled annotations provably safe 
tal safe code things addition type safe memory safe pointer forging control flow safe jumping arbitrary memory locations stack safe modifying non local stack frames 
tal implemented intel ia instruction set implementation called talx mcg includes tal verifier prototype compiler safe language called popcorn tal 
chapter describes tal popcorn detail 

implement dynamic linking vnc tal 
existing vnc systems support dynamic linking 
result implement dynamic linking vnc 
implementation simple possible small tcb impose low overhead linked code flexible build necessary updating mechanisms top 
roughly dynamic linking requires operations loading new code running program linking code existing code managing symbols code dynamic linkages 
maximize flexibility minimize complexity need trust divided dynamic linking implementation trusted untrusted components trusted part takes care loading untrusted part takes care linking symbol management 
trusted part called tal load consists extensions tal language runtime system including special load primitive loads module verifies safety runtime type representations needed build type safe symbol table 
implementation tal load theoretical underpinnings described chapter 
untrusted part builds tal load provide compiler library support dynamically linking popcorn modules 
provide api popcorn programs called dlpop similar dlopen lin common dynamic linking api unix programs 
implementation dlpop described chapter 
dlpop consists tal code code generates tal code verified safety improving robustness 
components approach summarized 
define notion dynamic patch 
implementation dynamic linking tal need consider build enable dynamic updating 
step define unit dynamic update 
case update consists dynamic patches defined half chapter :10.1.1.161.3137
dynamic patch existing module described new version module code data needed support updating module dynamically 
important part update code state transformer function dynamic ml computes new module starting state old module 
notion dynamic patch cleanly separates new code update support code normal development take place independently patch development 
existing structure trusted untrusted runtime system verifier libraries compiler additions load cast primitives type representations linking updating library loadable file compilation updateable file compilation static linking alterations trusted untrusted components implementation tal 
appropriate changes program patches written including new module code additional code needed transform state 
patch compiled single tal module applied dynamically linking running program 

enable running programs dynamically 
patch dynamically linked state transformer function invoked transform existing state running program fixed new code 
approach linking state transformation relink existing program modules new code 
old code running time update referenced stack continue control exits new calls updated module go new code 
approach taken erlang 
care taken ensure code unreachable soon longer needed includes removing old code dynamic patch dynamic symbol table linking 
way old module longer active safely garbage collected 
benefit approach reuses functionality support dynamic linking 
doing keeps implementation simple requires additions tcb introduces additional overhead 
furthermore allowing running code updated system places limits time patch applied 
enable dynamic patches described detail second half chapter :10.1.1.161.3137

ensure updates type correct formed 
relinking process type correct 
particular updated module changes type functions data system ensure doing violate type safety 
simplest way simultaneously update modules refer functions data 
alternatively programmer define stub functions having old type interposed old callers new functions 
stub functions useful implementing transitional computation incremental state transformation 
properly handle type definitions changed 
identify changed type definitions patch creation transparently rename type name compile time deal changes linking updating 
programmer manually translate old type instances new ones state transformer stub functions approach avoids implementation complexity reduced flexibility systems dynamic ml dynamic java classes 
ensure update damage system state transformation supporting rollback style dynamic ml 
state transformation function raises exception entire state system rolled back update 

generate patches automatically 
program dynamically need consider generate patches 
past approaches required programmer generate patches entirely hand notably state transformer stub functions 
greatly reduce burden developed tool generate patches automatically described half chapter 
tool identifies changes program version generates patch 
changes addressed generating patch code inserting placeholder generating code possible programmer may address change 
tool ensures patches complete system easier 

ensure patches timed 
set formed patches need determine appropriate time apply running program 
support mechanisms enforce user provided timing constraints runtime rely programmer construct program perform updating ensuring advance updates timed 
result avoid implementation complexity imposed runtime enforcement mechanisms lose flexibility programmer code system anticipate updating 
experience added burden minimal benefit enforcing dynamic constraints largely unproven 
issues timing explained chapter 

validate system realistic application 
problem past systems failed validate abstractions realistic programs 
example polylith dynamic java classes considered toy programs dynamic ml lacks implementation entirely 
validate approach decided build reasonably complete webserver incrementally starting basic implementation adding sizeable features time 
deploying version system publicly updated times significant new functionality 
process critical informing design especially development patch generator compiler 
webserver measure overhead imposes running program 
limitations approach described number limitations 
approach necessarily tied imperative languages implementation language popcorn sort 
hand limitation feature low level imperative languages serve target language styles 
particular begun explore approach apply functional object oriented languages progress topic chapter 

seamlessly support advanced language features popcorn 
particular support updating exceptions exception constructors implemented support updating function pointers types 
know way update function pointers types sketch chapter 
support updating long running loops 

experience single threaded programs owing fact tal popcorn currently support multi threaded programming 
approach just multi threaded programs ensuring difficult 

consider distributed programs 
problem dynamically updating multiple distributed processes necessarily complex subsumes problem consider updating single process 
feel approach fits previous approaches updating distributed systems conic polylith require single process implement 

briefly consider problem updating programs source code available 
able support useful certain active network implementations allow multiple parties load code network routers 
result user may partial view entire system complicating process updating 
consider issue somewhat chapter 

rigorously consider problem proving update 
provide support flexibility users construct applications updates valid better worse previous systems 
limitation arguably important mentioned providing means proving updates timed providing framework establish reasonable property important 
evaluating approach designing system focused retaining high level flexibility performance system robustness ease 
approach flexible update major features popcorn system imposed timing restrictions 
system robust type safe code popcorn tal simple implementation dynamic linking code relinking small trusted computing base due tal approach dynamic linking complete patch files imposes unreasonable timing restrictions 
approach slightly efficient statically linked code overheads result load time verification extra indirection imposed dynamic linking 
developing updateable software simplified clean separation software patch development automated patch generator 
compared previous systems system nearly flexible efficient robust easy 
relative decrease flexibility efficiency quite minimal results significantly larger gains robustness ease 
contributions proving thesis contributions 
primary contribution show build practical general purpose updating system flexible robust low overhead easy 
prior approach practical 
prove point construction corresponding contribution updating system implementation meets desired criteria 

developed complete framework safe dynamic linking verifiable native code 
system built enable dynamic linking native code way safe flexible support variety dynamic linking updating strategies 

defined implemented notion dynamic patch cleanly separates concerns program patch development 
simplifies development process program code maintainable program polluted code relating dynamic patching 

employed novel approach dealing changes type definitions renaming 
approach works practice avoids implementation complexity true type replacement employed systems dynamic ml dynamic java classes 

developed tool automatically generates patches versions program 
tool greatly simplifies process developing dynamic updates ensures updates complete 

show vnc technology flexible support dynamically updateable programs 
vnc increases robustness running program dynamic patches 

built sizeable updateable application updateable webserver 
far know largest application described general purpose dynamic updating literature updated non trivial ways lengthy course time 

show direct measurement dynamic impose low overhead 
systems documented performance data 
roadmap remainder document fully describes approach outlined chapter supporting arguments 
presentation mirrors description system 
background chapter chapters describe approach adding dynamic linking tal 
chapter presents trusted component implementation called tal load chapter describes implementation safe dynamic linking api built tal load standard approach unix systems 
chapters describe build dynamic linking support dynamic updating 
chapter describe extend untrusted dynamic linking mechanisms support updating :10.1.1.161.3137
chapter describe process building updateable systems approach considering issues timing patch generation 
case study chapter describe implementation updateable webserver 
chapter analyze performance dynamic linking dynamic updating component costs application performance 
measure application performance impact compare throughput measured updateable non updateable versions webserver 
chapter considers conclude chapter 
chapter background chapter provide background typed assembly language popcorn help reader understand code examples rest document 
reader interested code examples primarily high level ideas safely skip chapter refer back needed 
tal concise description tal tal home page tal typed assembly language tal extends traditional untyped assembly languages typing annotations memory management primitives sound set typing rules 
typing rules guarantee memory safety control flow safety type safety tal programs 
typing constructs expressive encode source language programming features including records structures arrays higher order polymorphic functions exceptions data types subtyping modules 
just importantly tal flexible admit low level compiler optimizations 
consequently tal ideal target platform type directed compilers want produce verifiably safe code secure mobile code applications extensible operating system kernels 
implemented variant tal intel ia architecture called talx written compiler safe language called popcorn talx 
detail concerning features syntax semantics tal doing aid reader understanding 
refer interested reader introductory tal theory mwcg :10.1.1.24.6526:10.1.1.24.6526
relevant information concerning talx implementation 
implementation includes number tools including tal assembler linker called popcorn compilers 
addition performing assembly linking verifies tal files safety verifies linking process safe theoretical details link checking gm :10.1.1.13.9240
popcorn compilers consist simple bootstrap compiler sophisticated optimizing compiler 
bootstrap compiler written objective caml ocaml ler descendant functional language ml 
compiler largely unoptimized particular lacking register allocator uses stack heavily 
newer sophisticated version compiler written popcorn 
version implements register allocation number traditional optimizations 
implementation uses ocaml version compiler essentially easier modify efforts underway add necessary features newer compiler 
excellent somewhat dated talx implementation particularly way popcorn compiled talx mcg 
popcorn section describes essential aspects popcorn language 
sections taken mcg 
section taken largely popcorn language manual texts required minor alterations reflect current implementation 
section describes features added popcorn support dynamic linking source source translation described chapter 
popcorn language purposely looks includes standard enhancements flexible variable declarations namespace mechanism 
unsafe features pointer arithmetic generic address operator pointer casts missing 
compiling features safely impose significant performance penalty popcorn code 
popcorn advanced features exceptions parametric polymorphism 
program popcorn constructed files typically having suffix pop containing number top level definitions including function data type definitions 
consider popcorn file separate module modules share global namespace 
popcorn compiler uses preprocessor popcorn programs ifdef include program execution begins pop main function analogous main 
quick example hello world program written popcorn include core void pop main printf hello world included file core contains frequently routines including file printf function function special syntax expanded compiler series calls functions core argument processing command line handled separate library opposed argc argv control flow basic control constructs popcorn break continue identical test expressions type bool result type relational logical operators bool 
tal team providing text permission greg morrisett karl crary neal glew dan grossman richard samuels frederick smith david walker stephanie weirich steve zdancewic 
popcorn switch construct differs execution falls cases 
furthermore default case required cases exhaustive 
argument switch test expression int char union exception 
example find occurrence character array int answer true switch arr case answer break break default array subscripts bounds checked run time example throw exception arr contain 
exceptions may different types exception handlers may switch name exception java 
exception names hierarchical 
data currently simple types popcorn bool char short int string float unsigned variants numeric types 
strings require null terminator 
arrays strings carry size support bounds checks 
special size construct retrieves size array string 
popcorn tuples useful encoding anonymous structures multiple return values 
new construct creates new tuple new struct union values 
example code performs component wise doubling pair ints int int new int int dbl new popcorn kinds structure definitions struct struct refer collectively struct definitions 
resemble struct difference struct struct values types defined struct null primitive construct language 
values types defined struct checked null field access failure results exception 
note field order matters 
struct int float equivalent struct float int constitute different types 
unions popcorn ml datatypes unions 
variant consists tag associated type possibly void 
example union tree void leaf int tree tree node value union type particular variant determined tag may treated 
switch determine variant expression bind corresponding value variable 
continuing example write int sum tree switch case leaf return case return case node return sum sum notice declaring value union type prepend union keyword say tree opposed union tree true struct value declarations 
addition type declaration may declaration files requires prepending declaration extern typically done data 
feature important types described 
functions popcorn functions essentially functions syntactic differences 
array function pointer modifiers function return type follow argument list function takes arguments returns integer array type int opposed int function takes arguments returns function ints ints type int int 
second function pointers syntax regular function prototypes declaration int int int popcorn 
avoid ambiguity function pointers may declared globals 
example code allowed int int return int int error get restriction global function pointers encapsulated struct tuple function pointers local declarations problematic 
parametric polymorphism popcorn functions struct union declarations may parameterized types 
example define lists struct list hd list tl declare variable holds list ints instantiate type parameter int list explicit type instantiation expressions necessary example new list null type int list 
having polymorphic functions means write length function works type list 
polymorphism particularly useful function pointers 
example write map function unclear compiler function declaration extern int function function pointer different representations list map list null return null return new list hd map tl call function look int list 
string list map int string type abstraction popcorn supports type abstraction ways qualifier form existential types mp referred popcorn abstype prepending struct union declaration keyword hide implementation external client code 
example lists implementation struct list hd list tl list clients define list type implementation extern list type parameter list needed omitted type null polymorphic 
abstraction enforced tal module system follows ml style module systems notion opaque types see hl ler 
second way defining types class mechanism called abstype abstype important part dynamic linking implementation include complete tutorial taken slight formatting changes popcorn manual comes talx distribution 
existential types abstype data declared abstype keyword form class data built existential types mp similar respects primitive form object type 
abstype particularly useful wants manipulate heterogeneous data structures 
struct union abstype polymorphic 
structs unions abstype hide certain types 
typical abstype want export information type 
instance representing objects may want hide types instance variables expose types methods 
furthermore methods take instance variables extra arguments 
example closure may represented environment function environment argument produces result 
structs unions abstype values created new 
manipulate abstype value construct open abstracted type scope 
simple example suppose different representations dimensional points polar cartesian appropriate operations defined extern struct polar int mag int angle extern polar add polar polar polar extern polar sub polar polar polar extern polar mul polar polar polar extern struct cartesian int xcoord int ycoord extern cartesian add cart cartesian cartesian extern cartesian sub cart cartesian cartesian extern cartesian mul cart cartesian cartesian unfortunately popcorn allow mix polar cartesian values directly example mixing list 
abstype allow particular representation type case point polar cartesian package operations values types 
example define generic point object follows struct point rep data add point sub point mul point abstype point point rep informally abstype definition defines new type point hides abstracts representation field data allowing mix different point representations 
example define point polar point int mag int angle polar point rep pol new point rep new polar mag angle add polar sub polar mul polar return new point pol point cartesian point int int cartesian point rep car conventional lambda calculus style notation popcorn code expressed type definitions point rep data add point sub point mul point point point rep point rep type operator takes type argument point existential type applies type operator point rep type variable new point rep new cartesian add cart sub cart mul cart return new point car notice function definitions return point values return type mention representation point polar cartesian 
point create point new point pol new point car abstracted representation 
lot casting object particular class java interface types class implements lose specific information kind object manipulate interface 
definitions creating points polar cartesian define instance list mixes kinds points point list points new list polar point new list cartesian point new list polar point null write function manipulate list exposed interface 
simple example follows point rep double point rep point rep pr new data pr add point pr data pr data return new point rep new data pr add point pr sub point pr mul point point double point point pr point rep new pr double point rep pr return new point new pr example code define polymorphic function rep data type returns new point representation data type 
simply adding old point representation data packaging operations 
function manipulates point rep values points 
double point function need take point representation apply double point rep function representation 
body double point uses statement open point scope statement bound point representation type variable bound type point representation data 
pr type point rep type named scope body 
body call double point rep function pr 
type double point rep take point rep produce point rep get back point rep result 
placing new point rep value new pr point 
return new point result function 
function double point element list points double value point point list list map double point points known map function denoted list map applies function provided argument case double point element list provided second argument case points returning results new list case bound variable 
statement allows unpack open data type scope 
really means gives way name type limited amount code get underlying value 
notice open different points type checker forces different names points respective point representation types treated point point point pr point pr point pr add point data data fails type check 
example attempt add point data point data fails typecheck 
reason point representation incompatible point representation 
tempted rewrite code replace pr point pr point fails type check 
pr add point data data popcorn type checker reject 
general popcorn requires semantically distinct type variables syntactically distinct implicitly vary 
added features support converting files loadable updateable source source translation described detail chapters needed add features popcorn :10.1.1.161.3137
briefly describe features 
operator supporting generic operator safe manner problematic original popcorn design left 
central problem address stack allocated value result dangling pointer result escapes outside scope value declaration local variable address returned caller 
hand data tied local scope acquiring address safe 
particular address global values safe 
addition address heap allocated data safe long value results formed 
simple case address particular field struct tuple 
example struct definition list int list new list new list null int list elem tl elem new list null line create element list 
second line acquire address second field element 
result type field added level indirection encoded tuple type 
third line dereference address assign new list element 
effectively changes tl pointer list point new element 
effect list values 
example take address tuple member int int int new int field field code effect address second field declared tuple assigning value 
approaches extend nested structures tuples 
total implemented global variables fields struct tuple values 
arrays strings heap allocated popcorn handled straightforward associated header stores length needed bounds checks 
address middle string require constructing new header alias substring store length 
add feature needed 
class exception constructors popcorn exceptions class initially popcorn exception constructors exception names 
exception constructor thought tag distinguishes particular exception 
example exceptions exception constructor shared exceptions bear name 
particular exception constructor declared exception foo int exn new foo declare new exception constructor foo declare foo exception storing variable support deferring identity exception constructor dynamic link time allow exception constructors class 
continuing example int econ foo exn new econ declare variable econ type int meaning hold exception constructor carries int argument 
assign econ construct foo 
econ build exception 
similarly allow fields switch case statements refer variables containing exception constructors just exception constructor constants example bool catch exn void exn try raise handle switch case print string caught passed exception return true 
define function takes arguments exception constructor exception function raises exception catches checks constructor switch 
case refers variable passed function 
identifiers global initializers simplify construction indirection tables dynamic linking see allow global initialization expressions contain variables long variable constant example int int illegal expression illegal value depends value int int legal int int return struct fnptr int int fnptr new fnptr legal code legal expressions appearing constant expression new fnptr constant calculated compile time 
type representations tal popcorn employ type erasure semantics 
particular types class manner particularly polymorphic functions data entirely parametric meaning particular identity type concern contribute runtime computation 
result class types safely eliminated final executable code 
may wish types intensionally hm meaning wish examine identity determine program behavior 
way called intensional polymorphism allows computations types 
setting types erased resulting executable take part computation 
types intensionally approach dynamic linking 
keep tal type erasure semantics able compute types runtime introduce type representations normal term language 
defer discussion syntax representations explain dynamic linker 
chapter dynamic linking tal dynamic linking foundation approach dynamic updating 
purposes performance robustness opted verifiable native code implementation platform designed methodology dynamic linking previously existed 
example pcc touchstone system dynamic linking ad hoc crafted support loading extensions non pcc os kernel nl special cln pcc system java lacks dynamic linking support altogether writing 
implement dynamic updating vnc dynamic linking need design dynamic linking facilities verifiable native code implement tal 
quick dirty just support updating wanted implementation stand 
approach designed meet criteria 
flexibility 
primarily concerned dynamic linking foundation dynamic updating prefer design dynamic linking approach general 
able support typical source language linking entities java classes ml modules object files loading linking operations 
furthermore adding add little complexity basic approach 

security 
type safe dynamic linking proposed means run untrusted code type safe code certain access information creating pointer integer dereferencing 
take care designing implementing approach secure 
particular type system sound trusted computing base tcb implementation small 
fact code type safe value type system check code sound programs type safe ill behaved able forge pointer 
definition type system proof typed programs behave secure manner critical importance 
term trusted computing base comes security terminology case refers infrastructure ensures loaded code type safe 
bug trusted computing base lead security violation code apparently safe may able exploit weakness say forge pointer 
early implementations java insecure due sort failure dea :10.1.1.39.3682
reduce possibility bugs prefer small simple trusted computing base 
result improved confidence system security consequently robustness 
vnc systems tal employ sound type systems small tcb adding dynamic linking vnc want way preserves type system soundness overly expand tcb 

efficiency 
dynamic linking impose little overhead programs terms space time 
goals dynamic linking mirror goals dynamic updating meeting set firm foundation updating approach 
chapter dynamic linking framework tal called tal load joint done stephanie weirich karl crary 
framework consists small additions tal enable program dynamic linking facilities type safe manner including monolithic addition tcb 
additions simple formal proof soundness straightforward 
furthermore approach specific tal possible implement verifiable native code systems 
complete framework dynamic linking verifiable native code 
remainder chapter organized follows 
informal definitions linking dynamic linking discussion concrete 
motivate outline tal load framework dynamic linking tal 
formalize framework prove sound 
describe implementation tal 
chapter discuss tal load core popcorn implementation dlopen lin unix library provides dynamic linking services programs 
informally program linking approaches tal load 
performance data dynamic linking dynamic updating chapter 
background understand build dynamic linker tal low level language need understand typical dynamic linkers high level languages 
knowing design lower level primitives tal map higher level dynamic linking abstractions 
describing programs linked statically examine dynamic linking changes landscape 
ultimately break typical dynamic linker implemented code loading linking symbol management 
static linking non trivial programs constructed program modules 
definition module differs programming language module collection definitions map symbol names simply symbols code fragments writing karl crary carnegie mellon university stephanie weirich cornell university 
breakdown person contributions chapter 
delineation module typically single source file 
example consider module stored file int int int return int int return module contains definitions mapped constant symbols mapped functions 
symbols mentioned module code refer definitions module 
programs consist module case symbols refer definitions modules 
example break files shown 
int int int return extern int int int int return modules linked 
function integer defined file function defined result symbol mentioned external say module imports symbol modules combined single program process called linking 
modules arguments program called linker combines modules code resolves externally defined symbols matching appropriate definitions modules 
case linker resolve definition file linker resolve module imported symbols symbols exported modules module may definitions available modules linking 
example popcorn definitions prepended keyword static 
dynamic linking originally process linking occurred statically construct programs separately compiled modules 
linking occurred program execution requirement resolved program run 
programming environments support dynamic linking program may invoke dynamic linker runtime extend new modules 
new modules added imports resolved exports modules running program 
dynamic linker perform tasks load module memory running program link loaded module running program manage program symbols dynamic linkages 
dynamic linkers implement tasks details differ 
consider task closely loading loading entails reading module disk network making formedness checks mapping program address space 
wellformedness checking varies programming environment 
example java modules called classfiles verified respect certain safety properties including type safety added program 
contrast object file loaders concerned formedness object file metadata checks assure code contained type safe formed 
linking linking entails resolving imports loaded module exports running program 
linking process varies programming environment 
particular question imports resolved question dynamic linking implemented 
linking typically performed times load time demand 
case module imports resolved immediately loaded resolved linkage fails 
case imports resolved just program 
amortizes linking process program execution avoids linking symbols needed particular run 
dynamic linking interface unix systems called dlopen lin allows linking styles java links classes demand 
dynamic linking typically implemented indirection code rewriting 
case external compiled indirected table 
linking consists filling table 
native code extra code fragments allow resolved demand cf 
elf virtual machine architecture jvm incorporate demand linking instruction semantics 
code rewriting links modules rewriting code point directly appropriate external definitions 
elf dynamic linking standard implemented dlopen uses indirection approach indirection table called global offset table got linux kernel loadable module facility called uses rewriting approach 
symbol management link loaded module running program requires addresses program symbols available dynamic linker 
symbols maintained kind datastructure symbols questions symbol management 
considering question circumstances certain symbols available linking 
mentioned definitions declared static available linking loaded module symbols considered local module defined 
addition symbols may precluded linking security concerns 
objective caml ocaml ler program modules define safe interface subset actual module interface safe interface available dynamic linking 
approach taken step alien ale symbol availability depends privilege loading code 
possibility symbols may resolved different values 
example untrusted code linked version open works files tmp directory trusted code resolved normal open function 
tal load tal serves target high level languages dynamic linking tal general accommodate wide variety dynamic linking approaches described 
considering straightforward flawed means adding dynamic linking tal motivate actual approach 
consider defining primitive load dynamically loads links tal module running program 
informally load type load sig option load takes arguments expected signature loaded module stored variable binary representation module stored 
signature description module contents including names types functions names definitions user defined types 
load parses checks formedness links unresolved module exported definitions running program 
compares module actual signature expected signatures match returns module caller 
part process fails load returns null signal error 
example say tal module corresponds file page 
module compiled tal stored file tal 
program wishes dynamically link tal invoke function program contain popcorn code load sig int int read file tal null return handle error 
call load signature argument indicates loaded module contain single function maps integers integers 
second argument containing contents tal obtained function option type sml usually defines constructor indicate undefined values popcorn null exposition 
read file 
module loaded linked stored variable resolved value defined running program 
dynamic linking successful null invoke function error occurred take action 
reasonably simple intuitive number obstacles implementing approach 

require way manipulate modules data stored variables returned load giving modules class status 
context rich type system class modules require complicated formalization lillibridge lil restrictions expressiveness result ml variants tal permit modules manipulable data second class status hmm ler 

signature argument load essentially type data 
implementing types data typically done type passing semantics requires types runtime representation explicit control programmer 
tal prefers type erasure semantics typing annotations stripped away affecting program computation semantics incompatible 

code loading linking symbol management occurs part load 
result system flexibility diminished policy decisions concerning linking symbol management fixed 
example load performs linking load time precluding java semantics linking done demand 
addition provides means incorporate source language security policies concerning symbol management precluding module local protected symbols linking 
furthermore entire implementation load trusted outside tal type system reducing system security 
improve flexibility parameterize load accommodate different styles linking break trusted component parts closely map common source language operators approach taken dug 
dynamic linking functionality tcb 
allow dynamic linking operations flexible reduce additions tcb reduce prominence load primitive part dynamic linking framework program source level dynamic linking approaches 
expect load perform tasks loading linking symbol management reduce role load just loading allow linking symbol management programmed tal features tal carefully selected new features 
result improved flexibility policy decisions concerning linking symbol management programmed tal 
improve system security expand tal tcb code support loading 
call framework tal load 
describe framework informally explaining addresses problems mentioned 
avoid class modules 
class modules theoretically problematic modules may contain type definitions referred type components function data definitions collectively referred value definitions 
difficulty arises meaning type component depends module type defined 
arbitrary expressions module type having type component difficult compile time determine type equal name problem arises know identities types names including paths compare 
type components instance named types types 
named types implement generative types structs datatypes ml 
tal avoids type component problem making named types globally scoped 
result modules program may define type having name identity type known compile time just name 
need load return value module type consists type value definitions new loading primitive called load returns tuple containing module exported value definitions 
exported type definitions added global program type interface maintained loader running program 
interface list currently defined types definitions type checking ensure imported type definitions modules loaded consistent ones defined 
essence loader responsible ensuring loaded code defines duplicate type names 

require type passing semantics type argument load explicit representation types data style crary cwm 
create special values called type representations correspond types represent relationship known typechecker 
allows type representations participate proof type safety explicit control programmer 

expect linking symbol management programmed tal fixed part load restrict load load tal modules imported values modules required closed respect values 
ensures load responsible linking tal modules managing program value symbols 
hand tal modules import externally defined type definitions maintained program type interface described 
support linking compile source language modules import values closed tal modules idea encode mechanisms needed implement linking tal code 
example compile source level external local data cells ultimately store external values 
module loaded cells filled appropriately dynamic linker written tal 
essence indirection approach implementing linking described previous section 
example consider module page 
close module shown extern int int int int return compiled closed static int int null int int return translated extern function pointer 
initially value set null dynamic loading linker set value defined running program 
type safe language popcorn null checks inserted ensure dereferenced function filled 
dynamic linker track running program symbols program type safe symbol table tal 
type representations existential types mp special checked cast operator implement type dynamics 
go greater detail compiling dynamic linking implemented symbol table chapter 
remainder chapter carefully describe tal load 
section formalization load primitive variant polymorphic lambdacalculus captures relevant elements tal load 
prove calculus call load calculus type safe 
section describe implementation tal load talx mcg implementation tal 
show implementation adds little talx trusted computing base 
particular majority functionality load unmarshalling type checking tal object files part talx tcb 
close discussion increase flexibility load simple extension 
load calculus designed load calculus balance tensions 
wanted simple proof soundness overly tedious tal correspondence terms intended result type soundness believable 
balance tensions load calculus essentially variant studied polymorphic lambda calculus gir rey proofs soundness known formulated allocation style semantics 
formulation cf 
mh program heap explicitly considered programs closely correspond actual machine language programs 
tal programs nature imperative programs alter values stored heap essentially treating heap locations cells har 
programs keep program type environment described informally previous section purpose modeling named types 
section load calculus 
describing untyped version calculus giving flavor evaluation programs showing ill formed programs go wrong add types intention typed go wrong calculus key property type soundness 
add named types formulation model type components tal modules 
entire labels vars expressions ref assign load values heaps ln vn programs untyped load calculus syntax calculus proof soundness appendix originally done jointly stephanie weirich cornell university hw presentation completely new 
untyped load calculus syntax untyped load calculus describe programs evaluate operational semantics 
syntax syntax untyped load calculus shown 
program consists heap expression evaluate heap models program memory including code data expression models execution 
comparing load calculus programs typical unix processes heap equivalent process code segment static data segment runtime heap expression represents program counter stack 
expressions divided classes 
contains standard lambdacalculus expressions variables integers abstractions applications 
second class contains expressions relating program heap standard interface cells har labels allocation ref assignment assign dereference 
third class contains load expression perform dynamic linking 
heap represented finite map labels values values subset expressions consisting integers labels abstractions 
intuitively label address memory pointing function data 
labels created statically part initial program dynamically allocation 
example modeling module shown page initial program heap label maps integer label maps function adds argument value stored label operator indicates label formalization appendix includes type heap mask described section 
beta ref ref dom deref assign assign ref ref assign assign assign assign congruence operational rules untyped calculus excluding load dereferenced obtain value stored 
heap store values allocated program runtime expression ref intuitively expression evaluates stores resulting value newly allocated memory location 
contents memory location changed assign convention consider expressions equivalent conversion lambda bound variables 
heap labels may converted intuition addresses program may relocated affecting program correctness 
code examples meaningful include additional operators addition integers 
standard lambda calculus powerful encode shorthand changes addition integers encoded church numerals result compromised 
semantics define operational semantics load calculus deterministic step reduction operator call value discipline 
rules including load shown 
rules computation rules define program evaluates rewriting remaining congruence rules define order evaluation left right call value 
beta rule performs function application substitution define capture avoiding substitution term occurrence variable term rules operate heap 
notationally write denote heap 
heap ln vn dom refers set 
ln rng vn 

heap 
operation undefined ref rule allocates unique label heap stores value 
deref rule extracts value mapped label heap 
assign rule overwrites existing mapping label heap simple example consider evaluation program translation file see 
program invokes function argument ultimately returning example program starts empty heap allocates label store integer increments assign ref assign assign assign assign running program load new code load primitive 
loaded code form normal program thought loaded code initialization expression 
semantics load tal load described expect initialization expression return values defined program 
informally loading code load consists merging loaded code heap running program executing loaded code initialization expression continuing computation running program result initialization 
merge operation fails initialization expression invoked running program continues alternate path 
crux load operation merging program heap loaded code heap 
heap merging disjoint union defined formally 
definition heap merge merge define dom dom disjoint union disjoint maps defined merge hi load es ef ei hi ei load success load es ef ef load failure load es ef load es ef congruence rules load untyped calculus permit conversion heap labels condition met convert heaps 
loaded programs expected closed meaning labels mentioned heap expression part refer labels defined heap program completely relocatable 
expectation contrast typical formulations heap linking mtal gm program fragments car dug systems assume free labels refer resolved definitions programs linked names labels meaning :10.1.1.13.9240
case assume sort linking take place term language sketched show detail 
formal rules load shown 
argument load binary representation program represented integer 
loading begins converting binary representation program hi ei function maps integer arguments programs modeling filesystem 
second arguments load success failure expressions 
merge hi heap running program merged heap loaded code hi load success rule success expression es applied loaded program initialization expression ei execution continues merged heap expression ef load failure original program heap untyped calculus failure expression really necessary load really fail add types number potential failure conditions arise 
example consider 
running program loads code defines single function adds argument initialization expression returns loading program running program invokes function value defined heap 
load types int ref heap types 
ln expressions 
load values 
type contexts contexts typed load calculus syntax minus named types changes calculus defined programs evaluate answers expression part value having form diverge terminate 
ill defined programs ones expression part program value possible evaluation rule apply 
programs termed stuck programs cf 
mh 
attempt identify syntactic forms stuck programs intuition program incorrectly constructed 
example program stuck rule evaluate program value 
dereference operator expects argument label heap argument abstraction 
subsection add types calculus 
type system designed typed programs stuck real world crash 
adding types add types calculus far 
tal load supports type components modules extend calculus support named types defer doing subsection 
syntax calculus modified include types shown 
shown syntax 
types include integer type int arrow types cell types heap label types ref type variables polymorphic types 
heap types map heap labels types 
abstraction load expressions decorated types added expression forms support parametric polymorphism type abstraction type int ref rng formedness types heap types application 
values include type abstractions 
support type checking define type contexts lists type variables contexts lists mappings variables types 
static semantics typed calculus defines judgments assert program formed 
wellformedness defined inductively 
program formed heap expression formed 
heaps formed may wellformed heap type similarly expressions formed may formed type 
judgments type heap type formedness shown 
types checked formedness relation type variable context 
context sure type variable properly quantified 
heap type formed types mentioned range formed 
judgments expressions heaps programs shown 
expression typing rules standard noteworthy rule load 
mentioned earlier term argument mapped runtime program type int 
type argument indicates expected type loaded program initialization expression 
second term argument success expression applied loaded code initialization expression take argument type returning result type 
final term argument failure expression executed loading fails type match return type success condition type load expression 
heap formed values range type indicated heap type program formed heap expression formed 
dynamic semantics operational semantics typed calculus untyped calculus see figures exceptions 
additional evaluation rule int load int ref ref ref ref dom ref assign formedness expressions heaps programs type application standard tapp type application substitutes type occurrence type variable body abstraction 
second load success rule changes verify loaded program formed hi ei merge hi load load success hi ei heap merging defined addition loaded program formed hi ei type matches type argument passed load 
result change require type passing semantics type argument passed load runtime 
adding named types far calculus considered define programs modules having type components 
subsection complete formulation calculus adding type environment notion program allows definition named types 
motivating approach named types additions calculus support 
motivation load primitive forbids loading programs free variables heap interpretation linking allow programs resolve undefined definitions program heap 
expect source level modules external compiled closed tal modules process linking source module level reflected compiled tal code 
briefly outlined previous section closing module compilation fairly simple 
example consider sml module forming part library supports opening reading text files structure struct type int val string val string 
module consists value definitions type component implemented integer 
client module fun doit val myfile txt say wanted dynamically link code program uses module 
need compile longer externally defined module 
way convert externally referenced values locally defined values mentioned section able type erasure semantics tal load introducing term representations types style crary cwm 
val string int option ref ref val int string option ref ref fun doit val myfile txt initially fill indicating value module dynamically loaded filled proper value 
run difficulty externally defined values named type 
named types noteworthy considered equal names match regardless implementations 
particular consider code sequence named type int named type int fun bad eq code function bad eq fail type check values different named type implemented integers 
see problem closing module values named type consider wished hold type 
result replace type definition int 
attempt close client code result val string option ref ref val string option ref ref external values eliminated external type 
easily create hole type values type equality needs checked load time load checks loaded code formedness 
named types known type checker solution problem extend notion program include type interface notes named types definitions program 
possible sml module system tal module system uses global type namespace meaning type name defined program 
sml types name differentiated module defined 
remainder subsection syntax semantics having support named types 
syntax extensions typed calculus syntax support named types shown 
programs extended include type interface form xi xe types type environments nn type environment values type interfaces xi xh expressions reveal values programs load calculus syntax including support named types pair type environments map type names implementations types extended include type names 
xi mentions named types imported modules xe mentions named types defined exported 
example type interface sml program fragment defines types int int case type names map types int 
type names map implement type abstraction 
example named type type interface client code defining function doit interface reverse values named type considered isomorphic values named type definition coercions hide reveal witness isomorphism 
example convert value type 
converting back integer simply require reveal reveal 
reveal permitted named type disallowing code looking value formalize case static semantics 
static semantics formedness judgments adjusted account type environment judgments figures shown 
additional judgment type environment formedness 
old judgments wellformedness additionally requires type environment context 
types judgment changes 
type wellformedness rules add type environment context additional rule named types states named reveal xp dom rng rng dom xi xh xi xh xi xh xi xh xp xi xh xh xp additional modified rules defining formedness types heap types expressions heaps programs type formed mentioned type environment 
change judgment reflected judgments heap heap type formedness 
new judgment type environment formedness states type environment formed types mentioned range formed 
named types may mutually recursive formed type environment closed type names appearing range appear domain 
expressions judgment rules added context 
new rules named types reveal 
reveal coerce expression having named type result type maps type environment coerce expression named type type type environment map 
semantics allows named types opaque 
particular expression reveal typed 
set forbidding coercion implementation type 
practice label loaded code mapping type heap mask loading 
dynamic semantics operational semantics changes slightly far 
programs extended include type interface 
load existing operational rules added definition program 
example beta rule beta second add evaluation rules named types type interface reveal reveal reveal reveal congruence essence unroll guarantees value coerced named type examined revealed 
prove typed programs hide reveal keywords erased affecting program behavior implementation 
change semantics load accommodate type interfaces 
additionally merge type interfaces loaded code running program condition doing typed 
type interface merging operator link sure named types defined loaded code mesh appropriately named types provided program 
type interface merging operator link defined terms operators relations type environments type environment values shown 
write denote heap 

heap 
nn dom refers set 
nn rng 

type environment value operations derived poset 
operators standard definitions relationship type environment values list types represents enumeration possible types 
type environment operator extends operator type environments operating members type name extension extension 
type interface linking defined formally definition 
stated informally linking type interfaces results combining export environ resolving type names imports interfaces ments type environment values operators meet approximates relations compatible type environments operators restriction restricted labels dom disjoint union union disjoint maps defined merge relations union compatible maps defined maps dom dom disjoint dom dom disjoint link compatible dom dom compatible dom dom type environments type environment values operators relations names defined exports 
merging imports subtracting labels mentioned combined exports 
operations formed export environments disjoint imports compatible 
add restrictions prevents import environment interface replacing mapped name export environment interface 
doing break abstraction enforced hide reveal 
definition type interface linking link require module type imports resolved linking running program import type environment required empty 
requiring resolved imports facilitates loading modules time mutually recursive type definitions 
particular loaded module indicates imports definitions types expects modules loaded akin extern declaration types 
module loaded exports confirmed match previously loaded module imports 
implement relaxation requires uniform representation named types case named types pointer types 
heap labels conversion permitted type names type names participate linking particular name meaning 
furthermore assume type environments xh export values 
slight modification follow approach mtal gm designate subset domain xh exports rest heap consists local type names :10.1.1.13.9240:10.1.1.13.9240
local names allowed vary linking limited scope defining module program 
take approach implementation 
operational rule load success xh merge hi xi xh link xi xi xh load ei xi hi ei load success difference rule previous subsection condition type interfaces 
able link type interface running program loaded code xi xh link xi 
properties load calculus important formal property system type safe property called type soundness 
particular program typed execute welldefined fashion indefinitely completes particular value typed program get stuck formally stated theorem type safety value reduced rule operational semantics 
note multi step reduction relation indicating zero applications single step relation 
type safety proven standard technique showing subject reduction progress lemma subject reduction lemma progress value exists 
stated informally subject reduction indicates program type take reduction step resulting program applying reduction rule type 
progress indicates typed program take evaluation step value having type 
relevant proofs appendix implementation implemented tal load talx follows 
added trusted library base talx implementation implements load primitive 
second preserve tal type erasure semantics allow computing types added term representations types tal 
added checked cast operator permit construction type safe dynamic symbol table tal checked cast described chapter 
remainder section detail additions talx 
passing types runtime recall load requires type argument examined runtime sure matches type loaded code 
tal maintains type erasure opposed type passing semantics meaning types erased runtime assured computational effect 
addition load tal defined previously violate premise types computational effect able erase types 
preserve tal type erasure semantics added term representations types approach crary cwm 
way pass type argument load runtime pass term argument representing type allowing types safely erased 
informally defines term representations types called terms types classify terms called types 
example term represent type int rint type term int 
type singleton type value inhabits representation 
type checker guarantees correspondence type variable checked statically representation type runtime 
addition tal trusted computing base kept small things 
represent terms binary format types tal disassembler 
second provide way tal dynamically introduce terms appropriate syntax cwm 
doing require reflect entire binary format types type system tal 
allow terms static data segment built directive 
consequently closed types may represented 
restriction proven problematic cases elaborate chapter 
load implementation load essentially type load option addition containing module data load takes term representation type argument described 
actions load illustrated 
binary representation named type string containing name prevents problems revealing implementation type types occurs type dynamics 
expected export type rt object file type info disassembly verification disassemble disassemble expected tal type exported tal values vs success type check exported tal types ts tal implementation failure typeof vs 
success merge ts return vs program type interface implementation load failure exported tal values vs null square boxes indicate unconditional actions diamond boxes indicate actions may succeed fail 
square diamond box data inputs outputs indicated boxes arrows illustrate data control flow 
components talx system load performs functions 
disassembly argument rt indicates expected type exports disassembled internal representation tal types 
succeed type tuple type element type represents type object file exported values 
second argument load byte array representing object file typing annotations 
information parsed tal disassembler produce appropriate internal representation tal implementation 

verification tal implementation type checked context program current type interface essentially procedure described load calculus 
done calling static link checking code gm providing argument :10.1.1.13.9240
type checking succeeds result list exported values exported types 
values gathered tuple type compared expected type 
types match tuple returned option type caller exported named types combined form new program type interface 
failure null returned 
majority functionality described results addition tal trusted computing base 
particular tal type checker disassembler integral part tcb 
implement trusted library combined ocaml code implements features talx code specific load 
new code performs tasks loads object file maintains program type interface 
loading code written serves library entry point maintenance code written ocaml interface existing ocaml code processing tal modules 
loading talx assembler compiles tal modules separate files object file containing code data types file containing type annotations simplicity contents files denoted single argument 
talx implemented windows linux object file format system differs windows uses cof object files linux uses elf object files 
talx assembler produces format correct os compiled run 
load called code implementing loader invoked turn calls ocaml code perform majority actions depicted 
ocaml code returns success object file loaded memory 
loading code linux kernel dynamically load modules 
describe code elf object files files similar 
file parsed performing formedness checks extracting elf file section headers describe file format 
file relocatable object file normally produced compiler separate compilation 
sections interest code data sections relocations section symbol tables 
second code data logically arranged order alignment specified file elf standard total required size computed 
third externally defined symbols resolved 
buffer allocated code data copied buffer tal uses garbage collection buffer allocated gc allocator 
code relocated relative allocated buffer address 
address buffer returned caller result load 
undesirable features implementation 
process parsing object file duplicates done talx disassembler albeit different purpose disassembler combine object file types file produce tal implementation 
result type checking code written ocaml loading code written way fix problem integrate implementation components say ocaml 
time consuming task great research benefit 
troublesome feature resolve link external symbols loading process 
part motivation approach perform linking outside tcb avoiding additional complexity 
fact symbols linked mechanisms outside tcb show chapter 
trusted symbols easily linked way 
symbols part macro instructions allocation necessary reuse buffer containing object file data avoid copy :10.1.1.161.3137
reason load effectively changes type buffer argument type 
placing object file contents fresh buffer prevents modifying buffer alias having type 
avoid copy proving aliases exist alias types wm :10.1.1.1.5638
tal instruction machine code expansion malloc malloc ptr movl gc malloc eax call eax addl esp eax eax je memory code sequence tal macro instructions part tal 
tal macro instructions instructions don map directly machine instruction machine instruction sequence sequence may include external symbols 
expansion malloc instruction shown table 
see expansion external calls gc malloc memory 
file closed respect calls shown primitive 
file containing malloc instruction dynamically loaded external calls resolved loader 
rewriting code directly relocations provided object file 
patching symbols object file directly manner ramifications 
code loaded file shared os level processes patched symbols gc malloc may different addresses process 
second patched symbols dynamically updated patched symbol re bound 
implies dynamically update garbage collector example 
practice symbols form part macro instructions need patched talx symbols 
furthermore trusted language elements reasonable may updated code verified safe may dynamically linked approach 
turns allow certain symbols introduced compiler linked implicitly manner convenience right close file loading source source translation preceding compilation 
initial implementation integrated translation compilation able properly deal symbols added compiler 
may hybrid approach possible explored 
link symbols implicitly module truly closed reasonable ask link symbols way answer greatly reduce flexibility security 
motivated moving symbol management outside tcb better control symbols stored datastructure users various privilege levels interfaced changing trusted computing base rely system verify code safe 
furthermore update linking management code runtime needs change 
example imagine wanting increase strength cryptosystem authenticate source loaded code linking decisions 
totally rely implicit linking technology described things 
implicit linking necessary tal macro instructions may approach improved 
particular symbols referred macro sequences gc malloc loaded address share code processes 
modern operating systems support separate process address spaces elf files allow loaded address program component specified possible 
furthermore allow relocation process take place outside tcb preceding call load 
disassembler check particular fixed address checking wellformedness macro instruction sequences looking external symbol 
maintaining program type interface implemented program type interface follows form described 
simplicity wrote code ocaml reusing existing trusted datastructures 
representations type interfaces xi xe exist part types files verify static link consistency 
initial initialized small bit code generated tal static linker determined program type interface 
computing new type interface runtime done trusted code static link verification 
short maintaining type interface runtime largely reuses existing trusted code noticeably expand tcb 
checked cast aside providing type information load types useful implementing dynamic types 
dynamic types may implement type safe symbol management describe section 
allow limited examination terms simple primitive called checked cast checked cast 
option informally checked cast takes value type casts type types equal 
operation trivial add comparing types part tal typechecker 
add tcb 
full implementation including typecase checked cast need primitive wei 
discussion part benefit having symbol management linking outside tcb allows greater flexibility different mechanisms situation calls implementing linking policy 
example assign users cryptographic key checked user loads code system 
linking takes place information related user privilege determine symbols available 
different policies different situations affecting tcb 
specializing linking types consider user privilege requires extra trusted machinery types managed linked inside tcb type checker 
increase flexibility keep tcb small observe type linking trusted type management need 
particular allow caller load provide type environment mask restrict program type interface 
idea tcb keeps track standard program interface linking library library mitigates access load primitive dlpop library described chapter maintains number restricted interfaces mapped certain level privilege 
load called library check privilege calling user apply appropriate type environment mask load 
section alterations load calculus particular parts pertaining load support type environment masks complete formulation proof soundness load calculus appendix includes mask 
touch implement masks tal load 
load calculus type environment masks type environment mask simply type environment restrictive running program export type environment 
caller limit definitions may seen loaded code 
support masks augment load expression take additional argument expressions load term argument binary representation type environment mask remaining arguments representation loaded program success expression failure expression 
typing rule load changes int int load type environment mask integer loaded code argument operational rule load uses function map integer actual type environment runtime simulating filesystem 
operational rules load shown 
load failure congruence rules essentially altered support extra mask argument 
load success rule changes linking running program type interface xi xh loaded program interface xi replace xh mask way type names defined program mentioned mask unavailable loaded code 
result link operation type interface 
export type environment merged program export type environment xh restore type names removed mask linking 
load xh merge hi xh xh xi link xi xi xh load ei xi xi hi ei xh load success load load failure load load load load operational rules load type environment mask congruence mask intended restrictive program heap meet conditions xh condition guarantees mask defines strictly fewer compatible types program export type environment 
operator defined follows iff dom dom xh condition guarantees loaded code import type environment import type names defined program export type environment defined mask 
condition necessary keep final export type environment disjoint final import environment final program formed see 
complete load calculus proof soundness appendix includes type heap mask defined 
implementing type environment masks implementing type environment masks require small effort majority code occurring outside tcb 
operation affects tcb addition type environment mask parameter load 
object file argument type mask just contents understood implementation load 
need extend type system qualify type environment masks mask reflected direct way running program 
contrast type argument load match type value returned 
type environment masks binary format storage tal types files just adopt format existing assembly disassembly code changing tal tcb 
number design decisions terms type environment masks practice created managed 
discuss 
chapter dlpop dynamic linking tal load tal load forms trusted component dynamic linking approach 
chapter describe untrusted component builds tal load provide full featured dynamic linking facilities 
concretely implementation type safe version dlopen lin standard dynamic linking methodology unix systems 
version called dlpop provides functionality popcorn 
describing dlpop detail serves purposes 
concretely demonstrates flexibility afforded tal load 
second importantly forms foundation approach dynamic updating call dlpop update 
dlpop dlpop update share interface implementation different semantics dlpop symbol bindings fixed load time changed dlpop update bindings may redirected new updated code data 
modified dlpop create dlpop update described chapter :10.1.1.161.3137
reasonable question chose implement version dlopen dynamic linking interface com 
answer twofold 
source language popcorn wanted implement library familiar programmers 
second dlopen provides functionality approaches general validating claim tal load flexibility 
claim section explain programmed approaches including java windows dll com com objective caml ler rou flatt felleisen units ff spin domains 
describing dlpop ways differs dlopen follow description implementation written tal load 
dlpop type safe dlopen unix systems provide compiler support library utilities interfaced header file dynamically linking object files 
call methodology dlopen principal function provides version called dlpop 
dlpop library interface depicted identical dlopen type safe 
describe interface detail noting differences dlopen thorough extern handle extern handle dlopen string fname extern dlsym handle string sym rep typ extern void handle extern exception string extern exception extern exception string dlpop library interface description dlopen may unix documentation lin 
dlpop dlopen provide core functions handle dlopen string fname name tal object file dlopen dynamically loads file returns handle operations 
imports file symbols declared extern resolved exports symbols declared static running program previously loaded object files 
returns dlopen call function init function defined loaded file 
dlpop dlopen dlopen type checks object file throwing exception failure 
addition exception raised loaded file imports symbol running program symbol running program match type expected import loaded file 
dlopen error conditions reported returning null handle dlpop handle guaranteed null 
dlsym handle string sym rep typ handle loaded object file string naming symbol representation symbol type dlsym returns pointer symbol value 
dlopen dlsym take type argument function returns untyped pointer null failure type void requires programmer perform unchecked cast expected type 
contrast version takes type representation argument typ indicate expected type type checked actual type runtime 
practice typ pointer type value returned requested symbol 
tal extended popcorn representation types rep implementing tal types 
term representing type popcorn denoted repterm 
create representation type free type variables tal type argument dlsym closed type 
requested symbol object file exception thrown passed type match type symbol exception thrown 
void handle dlopen file associated handle 
particular file symbols unavailable linkages memory file freed programmer sure hope 
dangling pointers symbols file 
dlpop nulls library loaded file unavailable linkages 
user program loaded file nulling file unreachable garbage collected 
possibility dangling pointers 
basics dlopen advanced features currently supported dlpop 

dlopen automatically loads object files dynamically loaded file depends conveniently supporting recursive files 

dlopen supports ability optionally resolve function demand load time long underlying object file format supports 
elf object files support demand linking functions procedure linkage table 

dlopen provides kind finalization calling user defined function fini unloading object files 
foresee technical difficulties adding features need arise 
particular implemented variant dlopen allows caller specify list object files load files may mutually recursive 
prototype extern handle string filenames extending dlopen implicitly load needed files demand mean adding bit information file compilation 
demand function symbol resolution feasible possible compilation strategy support described approach described section 
lastly finalization implemented garbage collectors particular boehm demers weiser collector bw current tal implementation 
simple modify loader described associate user memory allocated loaded file 
depicts simple dlpop 
user statically links file main pop execution dynamically loads object file loadable result compiling loadable pop looks function executes 
dynamically linked file external function resolved load time exports main pop 
implementation dlpop similar implementations dlopen follow elf standard dynamic linking requires library compiler support 
elf dynamically loadable files compiled data note type argument dlsym inferred popcorn compiler 
explicit syntax int int dlsym repterm int int int int dynamically linked code loadable pop extern struct imported definition type int int extern int imported function uses static int cnt static variable exported static void init load time initializer cnt int int exported function new cnt imported type return imported func static code main pop static int num static variable exported struct exported type definition int int int exported function uses num return void pop main handle dlopen loadable load file int int look function dlsym repterm int int call close file dlpop dynamic loading example indirected global offset table got object file :10.1.1.161.3137
slot table logically labeled name symbol resolved 
file loaded dynamically dynamic linker fills slot address actual exported function value running program exported symbols collected dynamic symbol table dynamic linker 
table consists list hashtables object file constructed compile time stored special section object file 
files loaded unloaded hashtables linked unlinked list respectively 
describe dlpop implementation pointing differences elf approach 
similar spirit dlpop inherently secure dlopen written tal load operations verifiably type safe 
mistake implementation may result incorrect behavior loss safety result crash 
describe changes popcorn compiler describe implemented dlpop library 
compilation elf approach files involved dynamic linking specially transformed 
initial implementation transformation occurred part code generation compiler 
moved source source translation preceding standard compilation 
chief benefit debugging easier pretty print results transformation readable popcorn readable tal code 
provided modular design issues dynamic linking separated code generation 
dynamic linking transformation popcorn compiler independent 
specifically additional features added popcorn optimizing compiler see gain benefit superior code 
dynamically linked files dynamic transformation performed stages 
example shows entire translation dynamic code 
code added altered result transformation shown boxes 
translated code automatically generated identifiers suffixes avoid name clashes 
discussion suffixes omitted possible brevity 
global offset table got define got file translate externally defined functions data refer slots got 
call function changed got 
elf got part object file dlpop got implemented verifiable language tal compiled popcorn 
consequence table verifiably typed 
got type got structure type containing single element function type element filled load time value main pop 
actual got declared variable got 
avoid null checks got slot initialized dummy value correct type possible 
case function static int cnt extern struct int int static int int new cnt return got static void init cnt static exception string static int fn raise new static struct got int static got got new got fn static bool updated flag false static bool done init flag false void dyninit loadable lookup string rep lookup closure void update string rep update closure bool init updated flag updated flag true update update closure repterm int int got lookup lookup closure repterm int init done init flag done init flag true init compilation dynamically loadable code :10.1.1.161.3137
additions alterations part compilation boxed 
correct type fn created simply raises exception 
fn initialization expression needed allow top level initialization expressions refer identifiers long resulting expression constant see 
slots having type create dummy value initialize slot null insert null checks table access order satisfy type checker 
tal verifier guarantees null checks left mistake 
dyninit function second generate special dyninit function called load time fill slots got proper symbols 
approach differs elf got filled dynamic linker implemented part dlopen library 
loading program point view dyninit function abstracts process linking file 
dyninit function takes arguments functions lookup update provide access dynamic symbol table closures functions lookup closure update closure respectively flag init indicates call user defined init function 
symbol address stored got dyninit look address name type lookup function fill appropriate got slot result 
similarly dyninit call update name type address symbol wishes export 
cases respective closure argument passed function argument 
argument caller dyninit provide information customizes lookup update functions closures parametrically polymorphic implementation closures may differently caller different circumstances affecting dyninit 
init function defined file called init flag set false 
dyninit function consists tal code linking operations verifiably type safe 
verification prevents example lookup requesting symbol name receiving symbol unexpected type 
checked setting dlopen operation result crash 
just module loaded calling dlopen dyninit function called just 
linking error occurs dyninit execution symbol requested lookup error simply propagated caller dlopen 
constructed linking passes supports linking modules mutually recursive 
pass modules loaded register exported non static symbols calling update 
example function registered variables init cnt declared static 
lookup calls fails pass error ignored symbol may registered module loaded 
second pass updates performed variable updated flag set pass 
lookups performed time failed symbol resolution truly signifies error propagated caller 
init flag set true pass init function called linking completed 
furthermore file records init function called setting done init flag called invocations 
making exports static exports dynamically linked files designated dyninit object file export dyninit changing symbols static 
way call load dlopen expect get dyninit function result 
statically linked files statically linked files changed adding dyninit export symbols dynamically linked files 
startup program calls dlpop function dyninit function statically linked files call dyninit properly constructed lookup update functions 
shows translated static code 
notice pop main dynamically exported call update function num declared static 
code calls statically linked file currently inserted tal static linker 
calls stored bit code generated register program type interface see 
expedient having tal linker generate code call dyninit function unsatisfying mixing abstractions 
tal linker concerned tal load way 
better approach phase preceding static linking object files libraries link generates popcorn code perform calls 
having phase completely decouple dlpop tal load reduce size tcb generated code properly type checked 
dlpop library dlpop interface implemented popcorn library 
central element library type safe implementation dynamic symbol table managing symbols exported running program 
describe symbol table describe dlpop functions conjunction 
dlpop encodes dynamic symbol table elf list hashtables mapping symbol names addresses hashtable linked object file 
time new object file loaded new hashtable added 
dynamic symbol table constructed start time calling dyninit functions statically linked object files mentioned previous section 
entry hashtable contains name value type representation symbol running program name key 
entries uniform type existential types mp hide actual type value ht string 
hashtable update table new symbol result calling update dyninit pack value type representation existential package hiding value type insert package table symbol key 
looking symbol having type query hashtable symbol name 
hashtable returns entry containing value type hashtable contains mappings 
static int num struct int int int num return void pop main handle dlopen loadable int int dlsym repterm int int static bool updated flag false void dyninit main lookup string rep lookup closure void update string rep update closure bool init updated flag updated flag true update update closure repterm int update update closure pop main repterm void pop main compilation statically linked code 
additions alterations part compilation boxed 
static abstype entry rep static find string entry hashtable list start string entry hashtable list string name rep typ start try entry hash lookup start hd name er return pop checked cast er er typ handle switch case symbol start start tl case failure cast failed raise name raise name popcorn code dynamic symbol table lookup type representation type 
value unpacked binding type variable term variables table rep table value 
term variables type representation value looked having type respectively 
call checked cast table rep table value type representations table rep compared converting table value type type match 
implementation function find implements symbol lookup described 
portion dynamic symbol table symbol name type representation find returns value symbol having type specified 
code find shown 
type declared type entry popcorn syntax type line 
hashtable start entries dynamic symbol table find looks symbol call hash lookup 
entry syntax er see tutorial existential types popcorn 
binds existential type variable entry binds tuple rep variable er 
performs popcorn version checked cast success cast value returned failure exception failure raised immediately caught exception raised 
call hash lookup fails throw exception caught loop continues hashtable 
list hashtables reached symbol exception raised 
dlpop library essentially consists wrapper functions load dynamic symbol table manipulation routines dlopen recall dlopen takes argument name object file load 
opens reads object file 
compilation strategy chosen loadable files export single symbol function 
call load dyninit function type receive back dyninit function result 
load returns indicating error dlopen raises exception 
new hashtable created custom update function crafted adds symbols 
returned dyninit function called custom update function lookup function works entire dynamic symbol table 
dyninit completes new hashtable added dynamic symbol table returned caller type handle dlsym function receives type argument call term arguments handle string representing symbol name representation type handle object returned dlopen actuality hashtable object file dlsym simply attempts look symbol hashtable described raising exception symbol 
value checked cast operation fails expected type match actual type value table exception raised 
operation simply removes hashtable associated handle dynamic symbol table 
attempts look symbols handle unsuccessful 
rest program longer handle object file safely garbage collected 
closing emphasize value way implemented dlpop 
tal load dlpop implemented verifiable language provably safe 
load constitute trusted elements implementation elements small 
flaw exists dlpop result constitute violation safety 
discussion look closely aspects dlpop 
particular detailed justification benefit dyninit function 
discuss implement dynamic linking strategies tal load flexibility 
examining dyninit add dyninit function fill got loaded files note exported symbols easily followed elf approach writing separate dynamic linker called startup dlopen 
construct dyninit function file generate symbol table file stored static data segment essentially elf stores table special section object file 
calling load dlopen expect returned table global offset table symbols static 
file symbol table added global dynamic symbol table entries got filled 
save time linking export table constructed save space file 
abstracting process linking calling function loaded file number benefits 
allows means object file resolves imported symbols change affecting dlpop library 
example order save space allow got entries null changing option type eliminate got altogether runtime code generation described section 
knew symbols remain unused loading program shared library resolve demand making dummy functions perform symbol resolution doing dyninit function approach shown 
tricky technical point existential types declared abstype popcorn store lookup function closure 
lookup function packed closure argument existential package unpacked just need call lookup 
second dyninit allows loaded file customize operations performed link time 
example imagine mobile code setting certain symbols may available untrusted applications 
mobile code performing linking dyninit react linkage failures take appropriate action 
example finds certain expected service available linking choose request alternate service 
dyninit simplifies implementation policy decisions loading code regard symbol management 
example loading code may wish restrict access symbols security criteria case customize lookup function provided dyninit throw exception restricted symbol requested 
customization done closure argument lookup example implement list restricted symbols 
possibility lookup choose provide alternative safe version symbol prevent access altogether 
example loaded code imports open lookup provide version allows opening files tmp directory :10.1.1.161.3137
dyninit drawbacks 
addition added start time overhead additional space loaded file type dyninit function change source language linking strategy meaning modules different dyninit intermixed 
example explain chapter number changes dyninit support dynamic updating type sufficient 
security threat code dyninit consuming excessive resources linking risk exists anyway user defined init function untrusted code general 
experience needed determine dyninit benefits outweigh costs current impression positive 
programming linking strategies framework tal load implement safe flexible efficient dynamic linking native code illustrated programming safe dlopen library popcorn 
dynamic linking approaches proposed high low level languages 
subsection things 
describe dynamic linking interfaces high level languages describe typical implementations explain program tal load resulting better security due type safety reduced tcb size 
second look low level mechanisms implement dynamic linking explain program framework 
demonstrate tal load flexible encode typical dynamic linking interfaces mechanisms higher level safety security 
java java user defined may invoked retrieve instantiate bytes class ultimately returning class object caller 
classloader may means locate bytes class relies trusted functions classloader classloader instantiate verify class respectively 
invoked directly classloader analogous dlopen 
returned classes may accessed directly dlsym cast entity known statically interface superclass analogous type argument passed dlsym 
standard jvm implementation linking occurs demand program executes unresolved class variable accessed classloader called obtain instantiate referenced class 
linking operations occur tcb checks unresolved class variables occur part jvm execution symbol management occurs 
implement tal load approach dlpop compile classes got dyninit function resolve register symbols 
classloader may locate class bytes exactly java means programmable tal simply wrapper function similar dlopen calls load invokes dyninit function class dynamic symbol table 
static int cnt extern struct int int static int int new cnt return got static void init cnt static exception string extern struct core opt static abstype fn string rep static fn core opt closure null static string name rep typ closure null raise new closure return name typ static int fn got repterm int return got static struct got int static got got new got fn static bool updated flag false static bool done init flag false void dyninit loadable lookup string rep lookup closure void update string rep update closure bool init updated flag updated flag true update update closure repterm int int closure core opt fn lookup lookup closure init done init flag done init flag true init compilation dynamically loadable code resolve functions demand 
differences boxed 
support incremental linking alter compilation java tal hypothetically speaking ways 
compile got holds externally defined classes allow null values contrast dlpop default values 
time class referenced got null check performed null call classloader load class filling result got 
simply follow pointer 
strategy depicted dyninit function longer fills got load time simply registers symbols dynamic symbol table 
cases tal load approach moves symbol management check unresolved verifiable language reducing size tcb 
windows dll com windows allows applications load dynamically linked libraries dll running applications interface implementation quite similar dlopen elf respectively minor differences see levine pps 
:10.1.1.40.2507
dlopen elf dll type safe benefit regard implementation tal load 
dll vehicle load manipulate common object model com com objects 
com objects treated abstractly clients providing access interfaces consisting function pointers 
com objects implement interface provides function called runtime determine object implements particular interface 
called globally unique identifier guid names desired interface 
guids incorporated type system source languages user cast object returned interface type expected mistake potentially resulting crash 
implementing com tal load straightforward added benefit proven type safety interfaces 
changed take type parameter addition guid expected interface ensuring proper type returned interface 
objective caml modules ocaml provides dynamic linking bytecode runtime system special module facilities implement ocaml applet system mmm rou 
essentially implements dlopen dlsym easy encode tal load 
contrast jvm ocaml verify extensions formed relies trusted compiler 
ocaml dynamic linking similar type safe functional languages haskell 
applets initialization procedures expected modify data structures running program point code 
example running program define global variable current applet points function implementing current applet 
new applet loaded initialization code alters current applet variable point entry function 
approach benefit runtime type analysis checked cast required flexible 
ocaml modules may unloaded simplifies implementation inflexible 
tal load implementation ocaml interface improve current implementation ler ways 
linking operations occur outside tcb 
second extension formedness verified assumed 
units units ff software construction components quite similar modules 
unit may dynamically linked static program invoke primitive takes arguments unit binary format list symbols needed resolve imports 
linking consists resolving imports executing unit initialization function 
invoke similar dlopen symbols link provided explicitly maintained global table 
units implemented dlpop dynamic symbol table 
compiling dyninit function take functions lookup update take arguments list symbols needed fill imports 
function fill got entries symbols call user defined init function unit 
implementation invoke call load call dyninit function arguments supplied invoke 
part initial inspiration dyninit function came units invoke function 
current units implementation ff similar described written scheme dynamically typed language 
linking errors dyninit may handled gracefully system result thrown exceptions scheme result runtime type errors halting system service 
spin extensible operating systems community explored number approaches dynamic linking 
example spin bsp kernel may load untrusted extensions written type safe language modula 
spin dynamic linking operates objects called domains collections code data exported symbols 
domains quite similar units functionality invoke spread separate functions creation linking initialization useful operations including unlinking combining 
operations provided trusted domain module 
furthermore operations subject security checks runtime criteria 
example domain linked interface interface seen may depend caller privilege 
implement domains techniques described addition filters take security information account 
tal load improve security current spin implementation ways ocaml domain implementation trusted ensure safety integrity extensions verified relegated trusted compiler 
tal module system implemented talx mtal modular typed assembly language gm provides typed version standard static linking facilities :10.1.1.13.9240
typed module assembly language dug alternative module system tal provides different model linking including dynamic linking 
tal load extension tal allow dynamically linking mtal modules 
tal load seen ways solve similar problems 
implemented 
adds simple notion class modules tal explicit coercions accompanied runtime checks type system remains decidable 
operations provided module values spin domains described 
modules linked form third module circumstances linking customized 
particular coercions provided remove exported names module rename types values 
addition modules linked symbols program modules 
provides primitives reflection 
particular dlsym essentially dlpop dlsym 
mtal tal load simplification named types global 
module loaded type components added global namespace 
class modules contain type components introduces level hierarchy 
result provides dlsym operation looking type component module prior retrieving value type 
provides primitives creating loading dynamically linked libraries respectively operation similar load compile time 
major difference tal load tal load intended programming sorts operations provides primitive result smaller tcb 
hand goal preserve statically verify constraints expressed source module language assembly language level 
easily implement majority tal load notion handle implemented dlpop analogous class module 
breaking linking functionality dlpop dlopen various linking primitives straightforward values tricky types possible type environment mask see hide global types loaded modules existential types implement dlsym implementation properties statically verified dynamically checked load 
hand programming provides flexibility 
case values program additional module coercions essentially control module symbol table 
example add security information table linking done spin 
low level dynamic linking mechanisms useful low level dynamic linking mechanisms may franz fra 
technique presents implement versions dlopen opposed elf methodology called load time rewriting 
pay indirection penalty got dynamic linker rewrites callsites external correct address 
essentially link trusted symbols tal macro sequences described 
technique simple form runtime code generation 
popcorn tal extended support type safe runtime code generation extension called cyclone hj 
cyclone implement load time rewriting outside tcb 
compile functions indirect external got create template functions external 
dyninit called template function invoked appropriate symbols calling lookup returning custom version original function closed respect provided symbols 
function registered dynamic symbol table update 
advantage approach process rewriting proven completely safe 
example static code compiled shown 
strategy eliminates overhead linking indirection function invocation bar eliminated value location emitted fill 
major disadvantage code rewriting general code may shared processes 
notable disadvantages particular implementation 
mutually recursive functions problematic template functions called particular order 
requires relevant lookups constructing function update take pass approach described perform updates lookups 
possible solution level indirection recursive calls backpatching correct values 
insert indirections judiciously compile time tricky 
disadvantage template functions copies functions filling holes place making copies general necessary context 
cost doing low especially relative verification 
mentioned previous chapter chapters done jointly karl crary stephanie weirich 
karl basic idea load primitive perform basic loading closed terms analogous primitive available standard ml new jersey implementation 
extension say syntax cyclone may hj 
intuitively syntax codegen 
copies code parentheses returning pointer fresh function 
occurrence fill codegen value inserted directly copied code 
way generated code specialized constants values known runtime 
static int cnt extern struct int int static void init cnt static int int int return codegen int int new cnt return fill static bool done init flag false void dyninit loadable lookup string rep lookup closure void update string rep update closure bool init int lookup lookup closure repterm int int int update update closure repterm int int init done init flag done init flag true init compilation dynamically loadable code runtime code generation 
differences boxed 
build source level linking strategies top karl suggested existentials coupled term representations symbol table 
stephanie split initial implementation compiler wrote initial dlpop library tal 
stephanie implemented type representations tal designed important checked cast primitive separate wei 
implemented load final dlpop infrastructure including source source translation plus features added popcorn enable popcorn version dlpop support mutually recursive 
measurements writing 
stephanie split theoretical chapter dynamic updating turn attention core dissertation dynamic software updating :10.1.1.161.3137
dynamic updating approach consists basic steps 
module changed previous version 
construct dynamic patch reflects differences 

compile dynamic patch loadable tal file 

dynamically link file running program 

transition running program patch 
demonstrated chapters dynamic updating design implementation aims practical cleanly meeting evaluation criteria defined chapter 
inherit tal load dlpop simple flexible safe framework loading files 
define notion patch separates changed module code additional code data needed support updates 
result cleanly separate processes software patch development making system easier maintain 
extend dlpop support updating reapplying core linking technology slight modifications dlpop library compilation approach 
result preserve simple implementation small trusted computing base impose additional overhead 
chapter describes design implementation approach arguing flexible robust easy 
defining notion dynamic patch explore mechanisms considered enable dynamic patching mechanisms chose 
dlpop update extension dlpop implements dynamic updating 
chapter complete argument describing build dynamic patches automatically ensure application timed 
dynamic patches dynamic patch describes dynamic changes versions program module 
define dynamic patch influences system flexibility ease ideally able express arbitrary changes file cleanly separate constructs required patching new code allowing software development static int num struct int int int num return example file main pop pop main function process cleanly separated patch development :10.1.1.161.3137
affects system robustness implementing patch semantics quite difficult resulting large complex implementation 
notion dynamic patch incrementally arriving definition suitably flexible keeping new code separate code germane patching 
dynamic patches differ static patches created applied unix programs diff patch deal state running program 
abstractly define dynamic patch file pair new version file optional state transformer function convert existing state accumulated form usable new code transformer defined old new code state old state copied new code properly transformed 
notion patch similar gupta gup defines essentially single patch entire program patch changed file 
system patches may reflect nearly arbitrary changes file dynamically particularly function data definitions type definitions 
look cases turn describe limitations patch definition 
changes code data example consider file main pop page subset shown :10.1.1.161.3137
function increments num track number times called returns sum fields argument type suppose modify return product arguments creating new version main pop 
dynamic patch converts main pop main pop shown state transformer function trivial copies existing value num old version num variable new version general arbitrary transformations possible :10.1.1.161.3137
illustrates notion patch actual syntax implementation 
stub functions new version main pop static int num struct int int int num return state transformer void main pop num main pop num dynamic patch main pop main pop patches applied individual files programs problem applying single patch exported code data changes type existing changed items access old incorrect type :10.1.1.161.3137
example consider new version adds new argument call new file version main pop existing callers different modules call single argument constituting type error 
general problem corrected simultaneously applying patches correct callers 
situations sense transitioning version program sense patch files changed 
hand situations changed file callers changed 
example proposed active networks multiple parties may download code routers customize packet processing 
case party may wish update code update callers code belonging parties 
example may wish break large update smaller updates process updating system disruptive lee lee considers way methodically breaking larger updates smaller ones 
situations allow patches include stub functions 
stub function type old version interposed old callers new definitions get types right 
patch main pop main pop main pop stub shown :10.1.1.161.3137
third part patch mapping functions main pop stub functions replace 
case stub function called stub simply inserts default value new argument existing callers call stub code loaded link new new type 
patches applied types updated functions change stub functions perform incremental transitional computation 
example suppose event system 
time program prepared process event calls function get event returns value type event 
say wish update way events gathered wish change implementation get event perform additional different new version main pop static int num struct int int int int num return state transformer void main pop num main pop num int stub return dynamic patch main pop main pop stub operations :10.1.1.161.3137
assume get event keeps queue events waiting processed 
write patch change ways 
write state transformer function copy contents old queue events new get event 
alternatively stub function retrieve queued events old function switch new old events remain roughly static bool got old events false event stub get event got old events event old get event old version null return got old events true return get event new version differentiate old version get event new prepending old version old 
stub way deals old state incrementally opposed performing transitional computation patch time 
obvious benefit pause load time due state transformation may critical reduce service outage transforming large amounts state 
hand existing code call stub function old state processed imposing extra overhead 
avoid cost define special syntax allow stub function update clients point actual function stub state transformation complete 
code change new version main pop static int num struct int int int int num return state transformer void main pop num main pop num int stub old new return dynamic patch main pop main pop stub event stub get event event old get event old version null return relink get event get event return get event new version call relink cause existing clients call actual function subsequent calls :10.1.1.161.3137
construct implemented depend mechanisms realize dynamic updating general discuss chapter 
obvious construct data analogous stubs 
patch changes type global variable functions running program refer variable changed 
case global data declared static additional files involved functions local file affected 
data exported files refer data updated 
changes type definitions changes may occur type definitions declare named types program 
example change function arguments changed definition include third field 
case choose express change patch depends implementation strategy 
technique choice consider approach subsection 
simple way express changed type syntactically differentiate type old definition new manipulate data conforming types 
patch style shown :10.1.1.161.3137
stub function stub takes argument having old type syntactically shown having type old creates value type copying existing fields argument assigning third field 
new function called newly created value 
style patch implies program may values old new version execution 
benefit dealing changes data due changed type completely programmer control implementation complex 
limitations notion patch designed flexible limitations ensure simple implementation 
particular patch definition provide means deal data stack requirement programmers manually handle existing data may prove burdensome consider point turn 
transforming stack state transformation function considers global state including heap static data segment stack 
result direct means programmer transform data pointed stack 
contrast system dynamic ml automatically transform data having changed type may 
preventing direct manipulation stack consequences 
old code data may time active new code 
advantageous need translate return address running code return new version caller 
caller changed significantly difficult decide return 
hand having versions function data active program may lead incorrect unpredictable behavior 
way handle multiple versions stub functions 
old code calls new functions stub functions 
functions attempt ensure consistent semantics admittedly determining reasonable behavior quickly quite complicated simple situations 
second consequence implementation burden reduced 
particular need support general way traversing stack 
type safe runtime stack traversals require extra semantic information available runtime needed debugger 
adding mechanism system tal increase trusted computing base 
opted simpler implementation cost reduced flexibility 
describe avoid dealing stack patch time constructed application permit updates stack essentially empty 
required slightly restructuring application 
reason believe systems tal may ultimately support stack tracing allow type safe implementation debuggers garbage collectors thread schedulers security checkers interesting revisit issue point experiment possible approaches 
transforming existing data supporting updating type definitions require programmer explicitly deal data old type ignoring converting new type 
new version main pop static int num struct int int int int num return state transformer void main pop num main pop num old convert new return alternative notion dynamic patch main pop main pop convert simple intuitive choice places added burden programmer :10.1.1.161.3137
alternate semantics allow version type data time enforced system 
case may include type conversion functions patch indicate data old type transformed new leave system invoke functions needed 
semantics patch file shown :10.1.1.161.3137
case need explicitly define stub function :10.1.1.161.3137
idea system properly convert data convert needed general include additional mapping patch file description indicate conversion function applied changed type 
alternative approach roughly employed dynamic ml :10.1.1.161.3137
disadvantage greater burden implementation data tagged type means exist finding converting data dealing erroneous conditions 
furthermore system directed automatic approach converting old data may inflexible certain applications 
particular may want translate data differently depending data lives stack heap part program 
favor programmer directed data conversion results simpler implementation smaller trusted computing base 
furthermore experience flashed see manual conversion difficult 
experience show benefits automated conversion outweigh implementation complexity easily add approach 
techniques dissertation complement implement system directed conversion 
summary preferred definition dynamic patch stub set new code state transformer function acting heap static data stub set set mappings functions corresponding stubs 
notion flexible easy reflect nearly arbitrary changes files code germane dynamic patching cleanly separated state transformer stubs new code 
fact generate patches automatically described chapter claims ease 
enabling dynamic patches going specific details implementation dynamic patches motivation overview approach 
presenting general implementation strategy 
consider possible mechanisms context strategy 
evaluate mechanisms settle approach 
details implementation section 
general strategy realize dynamic updating dynamic linking 
dynamically link dynamic patches running program transform state program transition new code 
solve problems 
concrete syntax set dynamic patches compile patches loadable tal files order dynamically link program 

enable program dynamically patched 
program able dynamically link patches existing code transitioned new code patches 
example callers existing functions redirected new versions functions patches 
term process enabling files redirected enabling file updateable 
solve problems follows consider second problem 
dynamic linking enable special compilation combination library routines 
particular updateable program modules compiled updateable modules linked updating library 
determining solve problem observe patches updateable 
program patched code patch part program updated time 
mechanisms realize updating applied statically linked modules program dynamic patches 
words dynamic patches loadable updateable statically linked modules updateable 
compile patch files tal files directly simplify modularize implementation compiling patch files popcorn files compiling popcorn files loadable updateable 
way reuse compiler code needed normal popcorn files 
defer discussing compile patch files popcorn files section 
remainder section evaluate mechanisms enabling popcorn file updateable considering tradeoffs flexibility efficiency ease 
understand mechanisms needed consider parts program change result patch code data type definitions 
start mechanisms enable updating code data mechanisms updating type definitions 
int afunc int bfunc return bfunc return int afunc int bfunc return bfunc return code relinking int bfunc return code data updates new int afunc int bfunc return bfunc return int afunc return bfunc indirection table int bfunc return indirection table int bfunc return indirection ways update code data new patch dynamically linked state transformed existing function calls data redirected stubs new definitions patch :10.1.1.161.3137
basically ways code relinking indirection 
code relinking rest program relinked loading patch result old definitions redirected refer new ones 
idea illustrated function afunc relinked call new version function bfunc :10.1.1.161.3137
indirection requires modules compiled modules indirected global indirection table 
update consists loading patch altering appropriate entries table point patch 
analogue example shown :10.1.1.161.3137
approach advantages disadvantages 
relinking process updating active dynamic linker go entirety program fix existing code point new code 
indirection updating passive existing code compiled notice changes 
result linker need keep track existing code simply changes table cost extra indirection access definitions table 
cases responsibility state transformer function convert data contains pointers changed function data definitions 
example program defines table function pointers functions pointed changed state transformer function go table fix pointers point new code 
indirection approach modified allow function data pointers updated automatically consider possibility 
chosen code relinking main benefits avoids extra indirection reduces overhead simple implement enhancing robustness 
particular implement code relinking reusing code links loaded module modification applying existing program modules loading linking patch 
apparent burden need keep track code able relink old code resolve external loaded patches 
ultimately take hybrid approach elements compiled notice updates relinked 
possibility explored compile function pointers extra indirection requiring code relinked 
ease requirement state transformer translate pointer data 
describe idea detail 
updating type definitions consider changes definitions named types patched files 
basically approaches take replacement renaming 
replacement applying patch replaces existing notion type definition new 
example consider module defines type struct int patch changes definition struct int int update definition dynamically sound manner things 
update type checking context 
type check loaded files patches new old 
mapping types definitions type checker called type checking context reflect new definition 

update existing instances data program ostensibly type compatible new pass value having old type function expecting new type get incorrect behavior 
absence subtype relationship old new versions convert existing data old type heap stack static data area new 
furthermore code old type program replaced 
exception case type data type code adt replaced 
typechecking context struct int int replacement typedef struct int typechecking context struct int typedef struct int new typedef struct int int typedef struct int new typedef struct typechecking context int struct int int new struct new int int renaming methods updating type definitions replacement renaming approach illustrated left side :10.1.1.161.3137
result updating definition module existing instance converted new type type checking context properly altered 
module additionally defined code code changed properly process new type 
alternative approach type renaming 
allowing type definitions replaced maintain fixed notion type definition rely compiler define new type logically replaces old syntactically renaming occurrences old name new 
renaming similar idea conversion scoped programming languages type definition override definition name surrounding scope overriding type renamed avoid clash 
consequence renaming compile time existing instances old type left patch applied state transformer function stub functions patch convert old instances update time 
type checking context retains definition old type adds new new type 
approach shown right side :10.1.1.161.3137
new version defines different type new logical replacement existing instance left type checking context retains definition adds new new 
effect programmer responsibility converting type new necessary 
advantages approaches 
type replacement general quite flexible easy maintains identity type program lets definition change 
system updates values changed type user provided code long programmer updated modules type 
program notion old new versions type system ensure logically convert old types invisibly 
restriction prevents update type code program values type :10.1.1.161.3137
contrast type renaming allows loading new types logically replace existing ones placing burden programmer convert values old new type 
renaming provides freedom timing updates program aware versions 
implementing type renaming quite simple requiring runtime support dynamic linking 
practical require standard method renaming type definitions compile time different developers choose inconsistent names result program errors 
problem solved cryptographic hash md og type definition including name arrive consistent name 
contrast type replacement requires way find classify existing instances having type way change old version new 
furthermore ensure type updates occur code uses active requires heavyweight mechanisms track modules fs lee gj 
favor simpler type renaming approach complex easier type replacement approach 
type renaming correctly implemented simple portable relying facilities available type safe dynamic linkers 
particular changes tal load support renaming extensive changes tal runtime tal load meet requirements type replacement 
experience renaming types compile time having multiple notions type program proven problematic 
approaches mpg cited runtime type dispatch operators instanceof java reason performing type replacement believe study needed bring light problems type renaming context 
dlpop update dlpop supporting updating implement updating approach far described modified dlpop implementation described previous chapter new version called dlpop update differentiate 
decisions designing updating approach changes needed tal load compiler dlpop library 
means trusted computing base remains unchanged adding updating 
furthermore changes compiler library small 
changes dlpop allow updating mirroring presentation previous chapter 
describing concrete syntax dynamic patch compile patches popcorn code 
describe enable programs patched parts 
describe changes dlpop library perform relinking explain compile programs correctly participate process 
main patch implementation main pop interface ifc main pop sharing renaming ifc main pop extern int main local num static void init new num main local num int stub return new patch description interface code files page patches implementation dynamic patches closely follows description :10.1.1.161.3137
contents patch described patch description file containing parts implementation filename interface code filename shared type definitions type definitions rename 
parts describe patch implementation file state transformer stub functions second file 
final parts type namespace bookkeeping 
shared type definitions types new file common old changed definitions renaming list new name 
compiler uses information syntactically replace occurrences old name new 
illustrate patch description file interface code file patch page shown :10.1.1.161.3137
implementation file main pop contains implementation code shown page :10.1.1.161.3137
interface code file ifc main pop shown 
defines state transformer init stub function stub number namespace conventions interface code file 
interface code file may need refer different versions variable differentiate prefix 
variable may new version defined implementation file syntax new example see state transformer assigns current version num referring new num 
similarly calls new version referring new stub function syntax stub interface code file defined stub stub function static variable file pop syntax local convention applies locals defined previous version file local variables new implementation prefixed new indicated 
example see existing num variable declared static main pop name main local num 
main patch implementation main pop interface ifc main pop sharing renaming new md struct int int int ifc main pop extern struct int int extern int main local num static void init new num main local num int stub new new new return new patch description interface code files old version variable local may prepended old :10.1.1.161.3137
alternatively old version variable defined old implementation file 
refers newest version externally defined variable 
particular variable updated patch applied simultaneously refers updated version 
example shows patch description interface code files patch shown :10.1.1.161.3137
case type changed new implementation longer sharing list 
renaming list indicates new name value calculated md hash new definition 
stub function converts existing data old type type new calling new function occurrences name new changed md indicated patch description file 
compiling patch file popcorn patch file prepared compilation converting normal popcorn file 
definitions implementation file variables sharing list resolve old version definitions link time 
second defined variables non extern implementation file prefixed new 
third interface code file implementation file concatenated 
mappings renaming list applied file type names 
results applying process patches shown figures shown figures respectively :10.1.1.161.3137
points worth highlighting 
clarification interface code file namespace semantics note implementation file concatenated actual value br zjx hd put md 
readability indicate value calculated custom rest dissertation 
static int new num extern struct int int int new int new num return extern int main local num int stub return new static void init new num main local num converting patch file popcorn file :10.1.1.161.3137
changes additions new implementation file boxed 
interface code file compilation symbols defined implementation prepended new implicitly available interface code 
example need extern new new num :10.1.1.161.3137
words writing interface code file programmer assumes access implementation file namespace 
essentially ways compiled state transformer function 
approach took call copy translate approach new module copy updated state state transformer copies transforms old state new module 
slightly different approach call inherit approach new module link state old code state changed type 
inherit approach reduces copying allows incremental updates support short term rollback 
cover point depth 
dlpop update library dynamic linking enable dynamic updating special compilation statically dynamically linked files combination library implementing updating api 
describe implementation api describing protocol occurs library loaded file dyninit function 
subsection describe compile files participate protocol programs correctly updated 
dlpop update api dlpop see page static int new num struct md 
int int int int new md 
new num return extern struct int int extern int main local num static void init new num main local num int stub md 
new md return new converting patch file popcorn file :10.1.1.161.3137
changes additions new implementation file boxed 
semantics dlopen 
dlpop update module loaded name module running program existing module replaced loaded 
function similarly changed 
roughly speaking algorithm dlopen dlpop update works follows 
say want dynamically update module call 
dynamically load patch provided argument dlopen call load 

create hashtable symbols add dynamic symbol table pointer dyninit function 
dlpop hashtables dynamic symbol table stored module function needed perform relinking described 
leave hashtable dyninit function old version dynamic symbol table need 

link calling dyninit function 
arguments pass lookup function looks symbols entire dynamic symbol table dlpop update function adds symbols new hashtable false init flag indicating init function executed 
updating protocol expects dyninit function perform actions look needed symbols lookup 
register symbols update function 
result newly created hashtable contain date entries module entries stub functions 
old modules properly relinked dyninit registered stub functions overriding new versions functions 
execute module init function 
dynamic patch state transformation function 

dyninit fails exception thrown new hashtable removed dynamic symbol table effectively rolling back changes revert old version 
exception handled caller dlopen 
form rollback essentially dynamic ml argus :10.1.1.161.3137
case key rollback global data redefined patch file opposed inherited existing version 
way state transformer modify new copy state leaving old copy untouched safe roll back 
defining data new file assures old code garbage describe 

relink rest program 
module old version dyninit called non standard lookup update functions 
lookup lookups favor stubs new versions hashtable queries look overridden stub function returning actual function dynamic ml achieves similar condition space copying garbage collector piggybacking state transformation process top garbage collection 

compilation dynamically updateable files assures dyninit function code program old code perform calls lookup update 
update pass function change dynamic symbol table simply prints warning called 
old version needs relinked case active 
case lookup function differs slightly described 
lookup finds requested symbol new version table wrong type looks old version symbol older hashtable 
circumstance occur new version symbol changes type case data define stub function 
old code going shortly new code allow code old version symbol 
contrast allow relinking old symbols current code effectively enforcing current code current data 
exception thrown dyninit function relinking type error symbol lookup new hashtables removed program relinked restoring previous state 
circumstance occur loaded patches derived program compiles statically 

links dynamic symbol table old hashtable weak pointers 
weak pointers keep data garbage collected reachable non weak pointer program 
item pointed weak pointer collected pointer set null called collected table 
fixes links hashtable list previous elements previously pointing collected table point 
unfortunately tal currently support weak pointers underlying garbage collector adding straightforward 
essentially weakness qualifier added type system pointers having qualifier require null check preceding 
lieu implementing weak pointers just leave old tables list doing accurately estimate impact program heap containing patch code 
decided remove old tables update ensure program construction removed code active update discuss flashed constructed regard 
old code remain active need relinked obviously relinking take place hashtable dyninit old code list 
procedure changes somewhat dynamically linking multiple patches time 
particular linking occurs passes opposed passes dlpop see 
pass patches dynamically loaded dyninit functions invoked invocation look old symbols prepended old prefix potentially overwritten calls update passes 
old variables state transformer stub functions appearing interface code file described 
second passes passes dlpop 
second pass performs updates module third pass performs remaining lookups calls module init function 
process relinking described 
compilation subsection describe compile files updateable fulfilling role updating protocol described 
translation source similar translation files participating dynamic linking see 
basic differences 
files statically dynamically linked compiled got external indirected got 
allows statically linked files including libraries relinked dynamic update 
particular module relinked got new symbols module updates 

dyninit function change properly participate updating protocol mentioned stub functions registered corresponding replacement functions 
ensures old files relink stub functions 
addition registering global symbols update dyninit register static symbols 
doing common practice dynamic linking internal symbols interest protected external files 
support dynamic updating need allow state transformer module patch access global state includes static variables 
mentioned prepend static variables filename local storing table avoids name clashes static variables files having name 
mentioned dlpop update library dynamically links multiple patch files uses pass algorithm pass looks old symbols prepended old prefix potentially overwritten passes 
call dyninit perform early lookups subsequent calls 
state transformation function executed variables replaced modules 
prevents new module having spurious pointers old module keeping garbage collected 
explained greater detail 
changes concrete look examples 
look patch files compiled loadable updateable look updating translation differs statically linked files 
static int cnt extern struct int int static int int new cnt return got static void init cnt static exception string static int fn raise new static struct got int static got got new got fn static bool looked old flag false static bool updated flag false static bool done init flag false void dyninit loadable lookup string rep lookup closure void update string rep update closure bool init looked old flag looked old flag true init return updated flag updated flag true update update closure repterm int int update update closure loadable local cnt repterm int cnt got lookup lookup closure repterm int init done init flag done init flag true init compiling loadable pop page updateable loadable :10.1.1.161.3137
differences page boxed :10.1.1.161.3137
dynamically linked files apply patch running program compile popcorn described compile file loadable updateable 
show compiling loading updating differs compiling just loading illustrates file loadable pop shown page compiled loadable updateable :10.1.1.161.3137
parts boxes indicate changes compilation file updateable compared transformation shown loading page :10.1.1.161.3137
file 
differences reflected dyninit function changed ways 
preliminary code block look functions replaced stubs 
case stubs lookups take place 
notice case init flag set dyninit function return immediately code block 
correctly pass algorithm noted 
want function file linking execute lookup code block updates doing updates overwrite symbol tables entries needed early lookup calls patches simultaneously applied 
linking file init flag set rest dyninit execute 
second change dyninit function calls update static variable case variable cnt 
see symbol name provided update simply cnt loadable local cnt 
consider translation patch file shown :10.1.1.161.3137
file transformed popcorn file shown compiled loadable updateable results compilation shown :10.1.1.161.3137
changes code shown boxed :10.1.1.161.3137
key things notice 
early lookup code queries old address main local num 
versions state transformation init function old address acquired replaced new call update just 

update function export new function stub function stub function exported new version 

call init got entry old num variable replacing dummy tuple new 
result initialization new code pointers old code 
additional implementation points important 
compile code global offset table external require extra indirection 
described change code runtime code generation eliminate indirection 
doing require changes relinking procedure described new code generated functions updated symbols updated symbol table 
addresses existing symbols program stable 
second got stores external symbols variables direct 
means subset function calls data translation tal occurrences changed loadable local cnt gets translated loadable local cnt 
static int new num extern struct int int static int new int new num return static int stub return new static void init new num got main local num static struct got int main local num static got got new got main local num new static bool looked old flag false static bool updated flag false static bool done init flag false void dyninit main lookup string rep lookup closure void update string rep update closure bool init looked old flag looked old flag true got main local num lookup lookup closure main local num repterm int init return updated flag updated flag true update update closure main local num repterm int new num update update closure repterm int stub update update closure repterm int int new init done init flag done init flag true init got main local num new compiling transformed patch file loadable updateable :10.1.1.161.3137
changes due dynamic transformation boxed 
program pay indirection penalty 
time approach essentially requires updates occur granularity files individual data procedures 
callers updated static procedure original file call old version 
statically linked files compiling statically linked files updateable differs somewhat compiling participate dynamic linking 
mentioned statically linked files compiled just dynamically loadable ones defining got early lookup code block regular calls lookup 
statically linked files relinked update dyninit semantics 
file main pop page compiled updateable shown differences translation dynamic linking shown page boxed :10.1.1.161.3137
note default functions need generated got statically link actual functions needed 
see got initialized static got got new got dlsym dlsym dlopen dlopen symbols dlsym dlopen resolved static linking 
overwritten values calls lookup dyninit invoked program startup 
overwriting symbols just artifact supporting relinking 
change startup code generated call dyninit statically linked file 
just generate call statically linked module generate passes linking pass calling module 
mirrors pass dynamic linking algorithm described 
dyninit raises exception process caught returns error code caller 
third pass call returns error code static linking failed program halts 
discussion covered details implementation dynamic updating deferred discussion details point 
discuss properly update data contains pointers functions data updated 
discussion reveal difficulty updating exceptions exception constructors 
indicate ensure old code garbage collected 
finish comparing earlier implementation dynamic updating indirection current implementation 
updating pointers functions data mentioned data contains pointers changed definitions altered state transformer function responsibility programmer 
subsection look closely process updating data 
void pop main handle got dlopen loadable int int got dlsym repterm int int got static struct got dlsym handle string rep handle dlopen string void handle static got got new got dlsym dlsym dlopen dlopen static bool looked old flag false static bool updated flag false void dyninit main lookup string rep lookup closure void update string rep upd closure bool init looked old flag looked old flag true init return updated flag updated flag true update upd closure repterm int update upd closure main local num repterm int num update upd closure pop main repterm void pop main got dlsym lookup lookup closure dlsym repterm handle string rep got dlopen lookup lookup closure dlopen repterm handle string got lookup lookup closure repterm void handle compiling statically linked file main pop page updateable :10.1.1.161.3137
changes relative standard transformation statically linked files see page boxed :10.1.1.161.3137
main pop definitions shown due space constraints 
int int return struct fnptr int int static fnptr ptr intfn new fnptr int int return ptr intfn void change int intfn int ptr intfn intfn file fnptr pop uses function pointers :10.1.1.161.3137
discussion focuses solely function pointers ideas proposed solutions apply equally pointers arbitrary data 
consider code shown pop :10.1.1.161.3137
defines simple function stores pointer function variable ptr intfn 
function invokes ptr intfn calculating result 
consider happen patch fnptr pop new version subtracts adds argument 
incorrect attempt patch shown :10.1.1.161.3137:10.1.1.24.6526
state transformer function new version ptr intfn assigned new version static initializer new code 
program call change value initializing new ptr intfn incorrect 
proper patch constructed knew program call change fixed number values ptr intfn values instance externally defined functions construct patch shown fnptr pop :10.1.1.161.3137:10.1.1.40.2507
state transformer function init check old value ptr intfn see matches old values designated old old respectively assign appropriate new version 
new version assigned 
defensive measure assuming case tested old version ptr intfn contains old version assigning new version throwing exception 
exception caught dynamic linking code changes rolled back described 
experience far approach adequate dealing function pointers 
particular written patches dynamically updateable webserver flashed described chapter 
approach drawbacks 
know possible values function pointer note changed part simultaneously applied patch old old fnptr patch implementation fnptr pop interface sharing renaming fnptr pop int int return struct fnptr int int static fnptr ptr intfn new fnptr int int return ptr intfn void change int intfn int ptr intfn intfn attempt patching code reassign appropriate value :10.1.1.161.3137:10.1.1.24.6526
second pointers may stored inside data inaccessible 
third change function definition file may update state stored file file changed 
may function pointers older versions stack accessible state transformer function 
consider points turn 
function pointers unknown value imagine cases feasible determine possible values function pointer program execution 
particular source code analysis sophisticated dataflow analysis conservatively determine possible values global variables 
making determination priori impossible programs source code available case extensible systems 
example linux kernel allows dynamically loading modules implement protocol handlers modules install function pointers protocol handler list 
system suitable state transformer function written difficulty help system 
way help dlpop update keep track changes symbols linking provide function state transformer functions map changed values updated sym oldval rep rep updated sym arguments global variable may contain updated value type representation variable type representation expected type new version 
oldval updated list fnptr patch implementation fnptr pop interface fnptr patch patch sharing renaming fnptr patch pop extern struct fnptr int int extern int old int extern int old int extern fnptr old ptr intfn extern int int extern int int static void init ptr intfn old new ptr intfn ptr intfn old new ptr intfn new ptr intfn patch fnptr pop return new version provided new version type specified :10.1.1.161.3137:10.1.1.40.2507
example state transformer change static void init new ptr intfn updated sym ptr intfn repterm int int repterm int int function updated sym goes update list looking see value stored ptr intfn function changed due update returns new value 
example ptr intfn contained old new value returned 
updated sym find old value updated attempts cast oldval new type returns 
cast operation fail implying new version changed function defined type programmer error occurred throw exception signal 
stub function defined type returned 
updated sym possible update state containing pointers knowing possible values pointers advance 
thing indicated advance particular global variable contains pointers 
furthermore case possible values pointer known advance updated sym easier write state transformer functions compare line function lengthy test previous version 
implemented updated sym changes required correctly construct updating list linking dlpop update library 
accommodate stub functions properly updating list maps original version function stub new version prefers stub case new version changed type 
practice sym quite slow due fact update list potentially long comparison requires runtime checks call checked cast 
better constructing transformation opposed updated sym know possible values advance 
pointers data tal popcorn allows definition data ways existential types mp module level abstraction mechanism similar ml opaque types signatures hl ler 
mechanism data constructed contains pointers updateable data data implementation hidden difficult identify update pointers state transformer function 
note exceptions implemented existential types updating exceptions data components similarly difficult 
cases sufficiently rich interface data may avoid problems 
example popcorn hashtable library implements hashtables type table 
say module contains global data type hashtable table table stores function pointers 
table new version directly table update pointers 
hashtable module defines iterator function void iter void table function iter iterates entire contents table invokes function key data pairs 
key data contained pointers new implementation invoke iter incrementally create new hashtable data pointed new values 
general way solve problem indirection 
particular function pointer data compiled contain extra level indirection data dynamic symbol table updated update automatically reflected data 
explore idea deeply section 
indirection may insufficient cases 
example exceptions implemented tuple tal argument pointer exception tag called exception constructor 
gle pointer read ensure type soundness 
implies update exception constructor reflected extant exceptions 
may restriction relaxed certain circumstances met plan explore 
way deal problem update exception constructors renaming just types 
updating global variables files updated sym possible write state transformers independent values function pointer may 
particular module stores pointer function module updated contain new definition change reflected global variable 
reason state transformer run code change variable change 
furthermore necessarily run transformer state may permitted access may know exists 
reasonable approach problem designate module init function called time system performs update 
relinking old modules function called dyninit 
re init call updated sym shown relevant global variables 
updating function pointers stack approach outlined allows state transformer function properly alter static data heap allocated data reachable static data containing function pointers update 
pointers functions may stored stack heap allocated data reachable stack arguments functions approach apply data stack simply stack class directly manipulable state transformer function 
deal stack allocated function pointers 
question part larger question concerning timing dynamic updates 
moments program execution may dynamic update legally take place 
instance piece code updated running return address stack old code akin having function pointer stack 
system take approach respect update timing programmers construct programs existing state stack safely ignored state transformer 
justify position length 
loaded code garbage collection programs require dynamic updating run quite long time potentially need updates ensure old code garbage collected system longer needed 
memory footprint system grow unreasonably large 
problem ensuring garbage collection reachability module longer needed program reachable datastructures 
loaded module may referenced ways entries dynamic symbol table directly 
case module loaded symbols stored hashtable part dynamic symbol table 
symbols mapped pointers loaded module 
long hashtable module dynamic symbol table module reachable 
second case module may refer directly symbols module dynamic symbol table 
occurs ways got module points symbols new version module refers corresponding symbols old version state transformer stub functions 
example patch shown init function assigns main local num modern virtual memory systems unreferenced memory get paged pose performance problem :10.1.1.161.3137
int old version code data int new static void init new local new version copying array dynamic update old version num corresponding variable new version :10.1.1.109.1634:10.1.1.161.3137:10.1.1.24.6526
patch file translated dynamically loadable updateable shown got entry old variable filled early lookup block dyninit :10.1.1.161.3137
old version module longer needed update hashtable removed dynamic symbol table meaning old module longer reachable dynamic symbol table 
furthermore code remains program relinked symbol hashtables point new code old 
remaining old code new code got case old symbols referenced new init stub functions 
case init null executed init function dyninit 
shows call init got entry value main local num replaced dummy tuple new :10.1.1.161.3137
case nulling got entry sound symbol main local num referenced init function rest program init function called new file called code outside new file init function exported call update 
conditions untrue nulling operation disallowed compiler issue warning 
similar nulling operation take place allow stub functions replace longer needed described 
particular time stub replaced old module symbols may got long stubs 
making determination may possible compile time may depend stubs replaced 
require dynamic counter stub referenced symbol 
old code referenced directly new code way old variable refer data stored static data segment old module variable copied variable new module 
situation shown :10.1.1.161.3137
code data popcorn arrays defined pointers contiguous area memory :10.1.1.40.2507
example old version array containing elements 
popcorn compiler allocates contents default initialized global arrays static data area array set point allocated buffer 
new version module loaded state transformer function copies contents old array new version causes new variable point data old code 
result entire old module kept alive data new module 
ways problem 
change state transformer copy contents old array contents new array 
reasonable approach long old array aliased variable alias redirected new version technology described 
second change implementation load separately allocate code data segment module old data prevent old code reachable 
better separately allocate static data definition allowing garbage collection finer granularity reduces impact problem solving 
third avoid statically allocated data altogether perform initialization start time load time 
practice far combination third approaches 
observed statically allocating large chunks data sense expect patch program simply data copied old new versions 
hand exception constructors aliased versions order maintain consistent semantics reasons described 
exception constructor essentially unique tag identifies particular kind exception 
exception caught exception tag examined determine exception identity 
exceptions maintain consistent identity versions tag change 
module defines exception constructor new version module loaded new version refer old version constructor keeps entirety old code alive allocated single block 
result performing fine grained allocation static data loading necessary enhancement 
updating indirection settling relinking method code data updating reasons enumerated implemented updating indirection 
purposes comparison summarize highlights implementation 
indirection relink rest program update compile program notice update automatically 
possible got entry point corresponding entry dynamic symbol table 
patch dynamically linked dynamic symbol table entry modified point new definition 
result caller effectively points new version illustrated :10.1.1.161.3137
afunc indicate bfunc field got structure extracted got bfunc dereferenced got bfunc int afunc return got bfunc got bfunc int return got bfunc got bfunc int bfunc return dynamic symbol table indirection dynamic symbol table called got bfunc :10.1.1.161.3137
approach adds level indirection relinking 
implement approach number changes file compilation dlpop update library 
change module hashtable entry shown module entry current approach shown left modified form right :10.1.1.161.3137
indirection approach extra indirection added module symbol table storing symbol value entry store pointer value tuple 
rollback simpler describe 
updated new hashtable added dynamic symbol table dlpop update 
new stub version symbol added new table share old version tuple assuming symbol changed type tuple changed point new entry 
shown :10.1.1.161.3137
new version symbol changes type entirely new entry added new hashtable effectively overriding old 
shown time tuple changed old value stored rollback list :10.1.1.161.3137
entry rollback list contains pointers changed tuple old value pointer old version function bfunc 
error occurs linking initialization new hashtables removed entries processed restore old tuples 
rollback list entry tuple element assigned old value 
linking operations complete normally old hashtables simply removed 
note indirection approach need worry weak pointers relinking need occur 
type lookup passed dyninit change got loaded code store pointer symbol table entry pointer symbol returned just addition functions access table pass tupled type representation interested contents tuple 
includes update function passed dyninit dlsym function dlpop update changed unintuitive type extern dlsym handle string sym rep typ semantics function difference term provided third argument requires extra level indirection provided type 
caller bfunc int bfunc return bfunc hashtable int int entry bfunc dlpop update table entry caller bfunc int bfunc return bfunc hashtable int int entry bfunc alternate table entry implementation module hashtable dynamic symbol table shown module see int bar int dlsym bar repterm int int saw example int bar int dlsym bar repterm int int reason readily seen looking implementation dlsym dlpop update dlsym handle string name rep typ string entry hashtable list tail null mod tab null tail mod tab tl return find mod tab tail name typ function find shown requires typ tupled checked cast operation works properly :10.1.1.161.3137
construct type representations dynamically type representations non closed types construct tupled type representation non tupled dlsym retain intuitive type having implementation rollback list 
old caller bfunc int bfunc int bfunc return return new bfunc int int entry bfunc bfunc int int entry bfunc hashtable old hashtable new dynamic symbol table rollback list dynamic update dlsym handle string name rep typ string entry hashtable list tail null mod tab null tail mod tab tl return find mod tab tail name repterm effect similar change adding typecase slightly altering hashtable entry type find function :10.1.1.161.3137
mentioned allowing dynamic construction deconstruction type representations adds fair amount complexity system fact complete implementation system named types matter research 
evaluating preferred approach relinking comparison indirection relinking superior number reasons 
performance benefit indirections external 
second process dynamic linking simpler need extra rollback list extra indirection dynamic symbol table type dyninit change 
furthermore presence dyninit function relinking simple elegant 
third potential drawback relinking having track old code really drawback modules tracked global symbol table anyway 
cases runtime code generation reduce number indirections zero relinking indirection respectively 
chapter building updateable systems building dynamically updateable software raises concerns enable programs dynamically patched best build apply patches programs 
previous chapter addressed concern chapter focus 
particular consider questions generate patches updateable programs ensure applied correct time 
presenting answers questions complete argument updating approach flexible robust easy support criteria 
consider aspects robustness 
patch set patches complete addresses changes program old new version 
completeness ensures programmer forgotten address aspect changed file 
patch completeness provides guarantee changes correct proving general undecidable 
ensure patches complete written tool compares old new version file identifies relevant changes generates patch reflects changes 
cases tool able generate proper stubs state transformer code cases difficult leaves placeholders programmer 

correctness patch determined independently time applied particular choosing poor time cause race conditions state transformation 
provide framework programmer determine patches timed 
past approaches lee fs provided support enforcing user provided timing constraints runtime 
user specify update applied certain modules functions inactive 
principle adds flexibility properly timing dynamic updates practice technology difficult correctly hard implement 
benefit mechanisms largely unproven impose potentially high overhead implementation burden chose implement 
require programmer construct program know updateable effect enforcing timing constraints software construction time runtime 
addition making implementation robust automated patch generator system easier 
developing testing version version source version source accept pop string pop cold pop common pop data pop file pop pop loop pop main pop maint pop match pop name pop pop pop scanf pop parse pop timer pop update pop changed changed changed changed changed changed changed changed changed accept pop string pop cold pop common pop data pop file pop pop loop pop main pop maint pop match pop name pop pop pop scanf pop parse pop timer pop update pop compile run compile run version program dynamic update version program patch patch patch patch patch patch patch patch patch patch patch patch building maintaining updateable program program patch generator quickly identify partially generate patches changed files reducing workload programmer 
chapter organized follows 
section describe process developing updateable software patch building phase fits patches generated 
focus attention implementation automatic patch generator 
second section look question program execution patches applied ensure executed properly 
consider potential timing models justify approach requiring programmer construct updateable software accept updates appropriate times 
describe reasonable programming pattern constructing updateable programs 
chapter describe applied principles techniques described chapter constructing flashed dynamically updateable webserver 
constructing dynamic patches typical way develop software follows 
version program revision number corresponding program source associated revision probably archived revision control software cvs fog 
changes need fix bugs add new features current version modified effect changes 
changes thoroughly tested modified source assigned new revision number compiled tested archived deployed 
short software change start current source modify test deploy changed program new version 
approach building dynamically updateable systems alters process slightly 
just programmers changes current sources compile test result create new version 
new version stable halting existing version deploying new patches created reflect differences old new versions software 
system patch files generated automatically 
programmer fills parts state transformer stub functions automatically generated 
patches dynamically applied old version software migrating new version 
development process depicted 
current version software consists number source files compiled run 
moving version files changed 
changes tested compiling running software making sure works 
testing complete patches created changed files 
cases patches needed files contents change cf 
pop due changes definitions types files defined 
patches dynamically applied currently running version resulting running program equivalent version 
new version retains state old version negligibly interrupts cancel service patches applied 
benefits dynamic updating shut old version restart new running program state lost processing forcibly canceled 
maintenance process described cleanly separates software development patch development 
separation possible notion patch implementation cleanly separated software 
furthermore patches describe nearly arbitrary changes running program 
systems patches limited certain forms software development similarly limited 
example dynamic classes hg changes instance methods data may reflected dynamically class static methods data evolve :10.1.1.109.1634
result process development hampered may expressible patch 
example new static methods added programmatically replace old ones old ones remain cluttering code obscuring meaning 
hand times writing valid state transformer possible altering source files 
example may existing state respects invariant new version state respects 
old source flashed updateable webserver described chapter 
old file new file current type map old type map type convert file changed funs compare changed funs old type defs unchanged data changed data types changed types share types rename interface code file structure automatic patch generator tool patch file current type map type convert file state transformed respect new invariant new code changed temporarily accept state having old invariant longer needed 
experience changes rare consider issue chapter describing experience flashed 
automatic patch generation novel aspect approach automatic generation patch files 
feature originally designed system easier tedious write state translation stub functions hand 
proven invaluable minimizing human error necessary state translation stub function accidentally left 
turns simple syntactic comparison files informed type information job identifying changes partially generating patch code 
section explain patch generation algorithm couple examples 
implementation patch generator illustrated 
inputs patch generator takes new file old file current typename map old file typename map current type conversion file 
new file required arguments optional 
results patch generation patch file interface code file updated typename map updated type conversion file new old files differ patch file generated outputs generated needed 
descriptions patch file types may 
patch generation broken stages identification generation 
identification phase shown compare defs box 
takes old new files inputs set named types known changed 
set starts empty may initialized contents current typename map file file explained detail 
algorithm works follows 
old new files parsed type checked 
definition new file corresponding definition looked name old file 
case type definitions struct union declarations bodies definition compared note patch generator similar spirit database schema evolution system developed garland gks 
different name type added set changed types 
case value declarations bodies compared syntactically account differences type definitions particular syntax function may remain old new version function changed type definition mentioned body changed 
furthermore function considered changed static data functions changed reason explained shortly 
results identification phase number sets describe differences files 
sets functions changed functions changed retained old type data declarations change data declarations changed named types change named types change 
sets inputs generate patch file supporting files including interface code file type conversion file typename map file 
cover turn 
interface code file interface code file generated 
old file contained global data state transformer init function generated 
data global variables unchanged exception constructors reasons explained chapter assignment statement created old new versions num propagate state :10.1.1.161.3137
global variables changed type appropriate code generated convert data old new type possible 
code generated inductively examining types old new version 
cases type considered array type tuple type types versions corresponding data simply copied 
arrays loop generated translate elements piecewise tuples translation statement generated tuple element 
type considered named type name old new version different definition call appropriate type conversion function convert 
type conversion functions generated automatically described 
values different type translated cast example boolean int int float 
complicated translations possible tuples added fields implemented 
translation code generated automatically comment inserted init function indicate inserted hand 
patch generator generates default stubs functions changed type 
basic modes possible 
simplest mode generator creates function body having old type inserts statement raises exception 
mode useful patches running program applied simultaneously case stub functions invoked exception signals unexpected error 
second mode automatically generate call new version function translating arguments appropriately shown page :10.1.1.161.3137
point applied patches simultaneously implement mode straightforward reapplying existing code 
functions changed content type comment included init function stub generated old callers type affected 
typename map file identification phase patch generator keeps track type definitions changed generates new names types 
new name determined md hash pretty printed type definition includes type name meaning definition generate name 
allows development patches multiple programmers worry choosing incompatible type names 
mapping old new name stored typename map file 
file read patch generated global fact type changed informs local process patch generation particular file 
updated map file written generation completion 
furthermore typename map file old version may consulted types changed name result earlier patches properly named current set patches 
type conversion file type conversion functions constructed extent possible data conversion old new versions named type vice versa 
state transformation stub code mentioned 
type conversion functions stored separate file file read start written patch generation completion new conversions functions changed types covered 
type conversion file dynamically loaded running program patches 
struct types field unchanged type copied field added default value field changed type translated 
case translation possible placeholder consisting string xxx fill left programmer fill appropriate value 
currently support translation types int float struct union types calling appropriate type conversion function 
union types value old union type cases construct value new type 
field removed new version default case needed deal values variant specially put placeholder default branch mentioning missing field 
field unchanged value simply reconstructed tag new type 
field changed type new value reconstructed value translated new type 
translation similar struct placeholder translation possible 
note unions structs data may null null check added 
type conversion functions patch generation general automation built definition names helpful names change 
instance adding removing fields structure definition changing types fields detected patch generator changed type generate majority routine convert elements old type new 
new version changes name patch generator think new type opposed modified version existing generate conversion routines 
difficulty changing names arises areas particular file synchronization tm bp able apply solutions patch generation system 
example problems alleviated permitting user inform generator old new relationships old version old foo pop struct int int int return new version new foo pop struct int int int int return old new versions example file foo pop definitions having different names 
example illustrate patch generator action consider example 
illustrates old new versions file foo pop 
new version changed ways type structure changed include additional field result function changed type takes value new type old providing files input patch generator results output files shown 
patch description file new foo patch interface code file new foo patch pop typename map file typename map file containing type conversion functions convert patch pop 
patch generator observes type changed generates name new version md hash definition 
stores mapping typename map indicates renaming list patch description file 
typename map file input patches program files change considered changed definition different 
interface code file new foo patch pop defines state transformer function init translate array stub function takes value new type array translation loop generated piecewise translates elements array calling type conversion function old new function defined convert patch pop explained 
stub function simply raises exception indicating existing caller properly updated 
note array conversion entirely correct new version array needs allocated copying take place 
retaining information identification phase concerning globals allocated statically dynamically allow translation precise 
file convert patch pop contains type conversion functions translating values old new versions oft 
interface code files old new versions differentiated prefix new versions prepended new old versions prefix 
note case default value generated added field conceivably inserted comment remind user appropriate value necessary 
file properly compiled treat patch referring patch description file convert patch interface convert patch pop renaming new md struct int int int indicating convert patch pop interface file namespace dealt properly 
furthermore specify mapped name new version renaming list 
function old new translates element old type new 
function called new value type allocated initialized fields shares old value 
new added field patch generator inserts default value field 
function new old translates reverse direction dropping value new field 
general functions old new useful state transformation new old functions useful stub functions returning value old type existing caller 
illustrate union types translated type conversion file consider example 
existing file defines union type tree describing elements binary tree union tree void leaf tree tree node choose change definition allow arbitrary numbers children array pair union tree void leaf tree node conversion code generated change extern union tree void leaf tree tree node extern union new tree void leaf new tree node new tree tree old new tree new tree switch case leaf new new tree leaf case node new new tree node xxx fill return tree tree new old new tree tree switch case leaf new tree leaf case node new tree node xxx fill return conversion functions argument examined cases 
leaf case new leaf value constructed corresponding type 
node case patch generator know automatically translate arrays tuples imagine reasonable translations leaves placeholder xxx fill programmer fill appropriate value 
automatic patch generator key element implementation reasons 
greatly reduces workload programmer care tedious aspects generating patch files 
experience far code generated requires alterations experience 
second guarantees patches complete identifies changes versions file generates needed transition code leaves placeholders reminding programmer 
advantages improve likelihood patch complete reducing possibility error improving robustness 
apply patches far concentrated entirely dynamic updates realized formed updates consist 
equally important question updates performed 
understand question timing important consider models updating interrupt model invoke model 
explain past dynamic updating approaches interrupt model determining appropriate update times difficult ostensibly provides greater flexibility requires greater implementation complexity invoke model model choice 
new foo patch implementation new foo pop interface new foo patch pop renaming new md struct int int int new foo patch pop include core extern struct int int extern extern new old new static void init int idx idx idx size idx new idx old new idx prefix stub int raise new core stub int new typename map new md struct int int int convert patch pop extern struct int int extern struct new int int int new old new null return null new new new return new old new null return null new return patch supporting files generated foo pop interrupt model program update invoke model program update time interrupt notify conditions possible met resume transition relink transform state call dlopen return relink transform state defined transition models updating single threaded program interrupt model general possible formed update applied bad time resulting incorrect state 
example consider file patch shown figures respectively :10.1.1.161.3137
patch state translation function copies current value num new version 
new code uses new version num 
patch applied inactive currently running stack fine 
old version begins execution just patch applied increment old version num copied result new version num reflect call part scenario occurs assume program updated moment execution 
implies interrupt driven model updating program interrupted point execution update takes place program resumed 
model generalized 
performing update moment interruption update delayed certain conditions satisfied 
example lee programmer specifies conditions patches update update idle specifies procedures updated procedures activations thread stack 
called interrupt model visualized top portion 
execution program interrupted time necessary conditions satisfied program context switches perform update atomically 
control mean update performed parallel program execution frequently case existing systems update appear atomic program 
implies synchronization 
returns running program point program transitions new code 
example procedure running update took place old continue run new invoked 
systems procedures may updated active mpg sf transition new code occurs immediately program resumption 
able enforce timing conditions runtime adds update flexibility specifying conditions updates correct necessarily straightforward 
fact gupta shown problem correct timing general undecidable 
show developed model dynamic updating defined notion update validity gup 
model running program pair program code program state encapsulating notion stack heap machine registers 
update pair new program code state transformer function maps old state new state analogous notion dynamic patch described 
applying update yields new program 
update valid new program state eventually reachable 
reachability defined follows 
state relative code reachable program legal initial state evaluate time inputs 
authors show general determining change valid undecidable relating halting problem 
show certain conditions met change may take place state transforming functions may validity proved formally describe conditions 
bloom develop similar complicated model argus blo bd 
automated means generally determining valid update time possible previous researchers developed techniques identify program patterns valid update points 
advanced developed gupta compares old new versions code including functions stack allocation heap allocation identifies syntactic analysis program points preserve update validity 
analysis quite conservative handle algorithm changes program functionality 
lee lee describes way decompose valid update set smaller valid updates 
directed graph constructed node graph represents function replaced edge implies updated strongly connected components graph represent functions updated 
lee formalize procedure updated cases easy determine types functions change straightforward 
furthermore valid update known guidance provided finding update 
systems simply impose restriction updates may occur inactive code mpg sf guarantee race conditions occur 
enforcing timing constraints runtime expensive terms performance implementation complexity 
system test update constraints runtime way identify set active procedures 
procedure required idle set program continues execute updating active set goes change set testing idle conditions met 
fs relies fact programs single threaded active set effectively stack set checked extra code checks stack depth procedure return 
supports multi threading function call requires synchronized access global structures store fact function active quite costly 
problems described identifying valid dynamic timing constraints arise practice uncertain 
systems mentioned presents analysis says 
simple cases considered realistic application experience 
led believe flexibility potentially increased timing enforcement mechanisms mechanisms may may result actual gains calling question loss performance increase implementation complexity 
invoke model problem timing greatly simplified requiring program coded outset updates permitted understood times 
transfers timing enforcement issue runtime software construction time assuming interrupt model program aware updateable updates may conceptually occur time require program coded perform updating invoking updating procedure 
model call invoke model illustrated bottom half 
program notified perform update calls update procedure dlopen appropriate moment apply appropriate patches 
patches applied update procedure returns program continues left 
properly constructed transition new code understood time 
choosing appropriate update time differs models 
interrupt model old new version files compare determine times amenable updating resulting list constraints 
update times negatively determined determine update may performed relative particular update hand 
hand invoke model requires choosing time amenable update 
requires programmer think abstractly updates create conditions interfere updates 
example experience general approach structuring applications updates timed system 
possible program structuring believe works 
problem arbitrary update times fold 
running procedures manipulating state want transform interaction state transformer procedures result race conditions 
prevent essentially want delay state transformation running code completed transactions manipulating global state 
notion transaction formalized database community series operations occur far rest program concerned 
programming languages including popcorn support formal transactions consider informal notion 
particular program transaction computational sequence performs self contained piece 

want transition new code defined 
functions activation records stack functions updated old code run functions exit re entered 
program structured reasonable way running functions may exit re enter new code timely fashion leading potential problems 
example old code continue operate old copies global state properly communicating computation new code 
solve problems requiring program unwind stack update time 
code currently executing exit performing meaningful state manipulating computation 
active functions exited program restores stack state calling new code resumes computation transformed state 
way piece code executing including event loop updated timely manner 
important identify program transactions implementing unwinding program 
particular updates applied active transactions 
allows stack safely unwound restarted meaningful completed 
event programs easily restructured unwind restart computation 
particular event handler essentially implements transaction update notification processed start event loop transactions outstanding 
loop exited restarted new code 
take basic approach flashed describe detail chapter 
approach apply multi threaded programs 
thread notified event pending 
threads complete outstanding transactions unwind stacks 
check main program thread time update applied 
main thread notifies remaining threads may restart point new code 
discussion fact invoke model fixes moment update advantage disadvantage 
hand confidence update correct timing greater know exactly updates occur determine interact system 
hand choosing update time may difficult accommodate updates unknown composition update time chosen poorly may limited updates perform correctly update program accept updates times 
experience program structure described derives approach flashed priori choosing reasonable update time affected changes patch express greatly improved confidence correctness 
advantage fixed timing significant disadvantage fewer times update minimal 
furthermore valid program may exist 
example methods proposed proponents interrupt model modification determine chosen update point reasonable 
example gupta syntactic analysis determine chosen update time reasonable update perform 
may able change update reasonable perform different update prepare system 
example discovered potential race condition exists due thread accessing state update update thread acquire mutex accessing state apply update mutex state transformation 
fair determining proper update timing largest unexplored area 
results single threaded event driven programs little practical knowledge way multi threaded programs 
encouraged updating multi threaded programs onerous invoke model model successfully employed multi threaded erlang programs 
believe ripe opportunity apply formal methods proving update valid hope pursue formalizing update validity invoke model 
particular plan prove unwind structure described sound hope analysis reveal possible program 
possibility consider formal transactions added language support proper update timing 
past adding transactions programming languages useful starting point wing 
chapter flashed updateable webserver show dynamic updating infrastructure useful practice built substantial application dynamically updateable webserver high performance webserver flash 
original flash consists roughly lines code performs competitively highest performance web servers available today measurements 
version called flashed editable flash port majority flash functionality popcorn omit advanced features 
advanced version flashed roughly lines popcorn code 
addition illustrating updating system building flashed informed justified design 
built flashed patched publicly running server significant new features 
doing realized areas updating system improved 
example developed automated patch generator attempts construct patches flashed hand process tedious error prone 
prior systems lack serious application inform design way making claims grounded experience 
chapter focus things 
section describe constructed flashed updateable structuring invoke model 
second section describe generated tested patches flashed patches tested applied practice 
goal illustrate updating system flexible handle non trivial changes easy 
chapter measure flashed performance assess overhead imposed updating system 
building flashed updateable invoke model applying dynamic updates needed enable flashed relative flash receive update notices respond applying indicated patches appropriate time 
addition ensure flashed runs nonstop alter errors handled 
describe changes detail 
update timing flash structure suited invoke model particular unwind program pattern defined previous chapter 
constructed event loop implemented function mainloop called main initialization main pop int main set 
void true mainloop void mainloop set true select break process events start main mainloop dlopen mainloop update loop pop time call call mainloop process events loop pop update break call mainloop version process events 
structure flashed flashed update procedure calls modules things 
calls select check activity existing client connections connection listen socket 
second processes client activity writing data previously requested files processing new requests 
accepts new connections 
part implementation flashed shown 
flash event loop mainloop function file loop pop 
overwhelming majority mainloop unchanged version added maintenance command interface support update notification patch application 
maintenance command interface maintenance command interface allows separate application running machine connect webserver send textual commands 
select checks connection requests maintenance listen socket calls function accept connection process request 
request update request indicated command update non empty list dynamic patch filenames called dynamically update corresponding modules program 
implement unwind pattern need clear stack exiting mainloop function re entering 
things allows mainloop function updated 
particular mainloop contains infinite loop handling events update loop pop include different version mainloop program counter leave old version mainloop enter new version 
properly unwind restart stack created updating loop file outside loop pop shown file update loop pop 
updating loop just infinite loop continually calls mainloop 
update request completes successfully case returns true break event loop exit mainloop 
update update loop pop relinked call new version mainloop 
program execution proceeds correctly slight changes set code mainloop executed 
entire updating sequence shown bottom 
webserver starts main performs initialization setup finishing calling 
enters infinite loop calls mainloop 
webserver processes events receives update request calls dlopen way 
update finishes successfully control returns mainloop immediately breaks returns 
call mainloop relinking update go new version mainloop processing events 
course existing state modified necessary state transformer function preserved loop invocations 
odd extra file update loop pop owes fact implementation dumps old hashtables symbol table code updated 
described action acceptable general old tables retained weak pointers case code active time update need relinked 
update loop pop structures system old code needed update 
particular put updating loop main loop relinked update 
main pop updated old hashtable main pop thrown 
return address stack call mainloop point original main pop 
main pop updated second time original version main pop relinked symbol table dumped second version 
control returns mainloop goes back main pop jumps wrong mainloop function second version 
ensure situation arise updating file update loop pop 
short term workaround allow examine old code garbage collected weak pointers proper long term solution 
fatal error handling second change flash fatal errors handled 
flash contained places errors detected program execution aborted calling exit 
aborts acceptable non program hand detected conditions indicate program functioning properly 
keep program running sure properly things 
changed cases exit called throw exception 
mainloop function infinite loops updated having jump loop go newest updated loop header erlang implements functionality tail recursive call new looping function 
adding features system possible modification popcorn compiler updating library 
catches unexpected exceptions prints diagnostics 
second reset program state sure consistent 
example mainloop shuts existing connections receiving exception restarts loop 
addition exception thrown module maintains state state reset exception thrown 
program continue service repaired online albeit loss information connections 
updating flashed practice having built webserver updateable real test update 
wanted learn flexible system practice easy develop apply correct patches 
decided construct flashed incrementally deploy publicly 
actions simulate process maintaining non system evolves 
furthermore holding accountable publicly tempted shut system convenience updating infrastructure circumstances 
exercise extremely fruitful 
learned construct patches effectively test line apply 
furthermore code originated different developer flash sources tempted write application nature system 
hand updates system contrived neatly partitioned functional components 
partitioning match actual development process flash may represent difficulties arise writing patches 
experience shows approach effective provided evidence improved 
example exercise building patches flashed led development automated patch generator 
update chronology flashed implementation undergone number changes resulting versions 
initial implementation version lacks version features cgi directory listings performance enhancements pathname translation caching file caching 
consists eighteen source files roughly lines popcorn code 
deployed version host project home page modifications support pathname translation caching version 
testing version built statically constructed patches tested applied dynamically 
repeated process version adds file caching version adds directory listings 
version consists source files lines popcorn code 
brief chronology showing evolution public server shown 
started version flashed cis upenn edu october host resetting local module state sense flashed way state partitioned modules sense general reset program state kind generic interface 
appropriate policy application dependent 
oct oct oct nov initial version index html version completed date parsing fix version feb version fixed date parsing bug added pathname translation caching added mb file cache added new maintenance commands handling previously fatal exceptions eliminated spurious message dynamic directory listing timeline major flashed updates changed loc total interface loc version files types changed source patches auto hand table summary changes versions flashed flashed home page :10.1.1.161.3137:10.1.1.24.6526
applied patches version october version november version february :10.1.1.161.3137
patches tested line separate copy server various conditions convinced correct applied line server 
mistake patch flag properly set applied fix october 
addition applied roughly small patches debugging purposes print current symbol table 
patch construction description changes version patches required summarized table 
columns table show changes source code previous version including number changed added source files including header files number changed type definitions number changed added lines code 
columns describe patches including total number patches generated including type conversion file total lines generated code patch interface code files lines added changed hand 
things notice table 
number patches generated exceeds number changed source files type definitions files changed meaning functions files types effectively changed 
second number lines interface code automatically generated far exceeds amount modified added hand 
say process modifying automatically generated files simple cases large portion total tedious done automatically 
example generated lines include extern statements refer old new versions changed definitions placed hand 
importantly patch generator guaranteed patches complete changes identified automatically changes needed addressed programmer 
alterations generated files usually forms 
translate data 
global array stores handler function connection indexed connection number 
handler function takes argument connection handling connection type httpd conn type changed versions type handler functions changed 
state transformer needed initialize new array functions correspond old versions techniques described resulting patch similar shown page :10.1.1.161.3137:10.1.1.40.2507

complete type conversion functions 
number spots patch generator provide suitable values new changed fields union struct definitions 
example conn contains field stores function called timeout httpd conn argument 
httpd conn changes reason field changes type takes httpd conn argument 
conversion routine insert meaningful default values functional types leaves placeholder 
current implementation timeout function choosing correct value simple 

initialize new state functionality 
versions new entity added pathname translation cache version file cache version version separate helper program perform directory listings 
statically linked executable entities initialized main preceding event processing mainloop 
updated dynamically initialization code main executed executed part state transformer function 
copied relevant code add significantly described 
cases alterations non trivial 
patch version version adds file cache 
versions flashed httpd conn contains field struct type 
elements type contain information file particular url refers including modification date size contents versions earlier entry constructed scratch request thrown connection closed 
version entry inserted file cache created shared concurrent connections requested file 
difficulty connection complete code releasing values expects values respect certain invariants 
constructing entries context respect invariants trivial 
slightly change source version specifically routine deal specially values problematic 
prevent confusing invariants maintained file cache software 
fortunately changes fairly simple case may complicated changes necessary cases 
disprove assertion software patch development separate processes 
able create patches making changes source 
consider development process updateable software iterative develop version software statically test develop patches test patch development changes needed source go back test static program 
experience needed understand process burdensome reasonable cases pollution source code accommodate time patches excessive 
patch component totally straightforward version adds directory listing support 
listings acquired parallel computation slave process parent process continue service connections 
listing gathered slave notifies parent transmits information 
start time slave process forked waits instructions main program 
difficulty slave process separate executable module flashed program clear current program state located 
particular flash flashed coded expect executables stored directory 
flash invoked directory flash resides lost particularly change current working directory pages serve 
update needs able find directory initialize slaves 
code patch guess executables 
looks see original argv saved global state reasons absolute path extract directory 
calls try current directory long user specify directory serve documents 
tries absolute path provided programmer patch 
throw exception cause update rolled back 
case implies able parameterize patches useful 
example load patch provide initialization function directory location 
difficulty type user defined init function differ depending arguments needed 
deal problem specifying user defined init function generically types 
example type void init 
array init takes arbitrarily sized array parameters parameter coupled type 
init function checked cast extract parameters expected types 
facilitate parameterized init change dlopen able take lists parameters modules open pass dyninit loading module dyninit turn pass init 
final case non trivial patch initialize global data file call required old version data input data patch call 
difficulty occurs external data needed new patched version implies state transformer run possible ordering patches provided 
case just old version data immune issues ordering 
problem practice requires experience 
patch construction difficult automatic generator 
furthermore come cases construct reasonable patch 
worth asking scalable approach certainly automatic identification changes scalable existing approaches lack support 
non systems consist tens hundreds thousands lines code difficult identify tricky invariants altering automatically generated patches systems 
experience far promising experience needed answer question 
testing patches seen patch construction trivial needed test patches line version server applying public server 
applied patches load extreme load conditions sure various circumstances applied public server 
addition apply patches test executable compiled existing sources sure actual public executable patches applied publicly 
important flashed development process tal implementation patch generator changed fix bugs tweak various features old executable patches built source differed somewhat ones deployed 
testing patch application load conditions easy just start server apply patches see new functionality works 
course approach fails fully exercise state transformers little state transform particular existing connections served 
test patches extreme load conditions benchmarking software software measure updating overhead flashed throughput described push server limits applying patches 
doing revealed flaws initial state transformer code 
example writing patch add file caching neglected check null transforming field existing httpd conn values connection array valid connections field null 
connection closed httpd conn structure kept connection array nulling fields including separate bitmap identify httpd valid 
initial version state transformer assumed httpd connection array valid added null check assumption proven false 
testing flashed non trivial rigorous level industry standards 
dynamic updating system practical rigorous testing techniques possible testing patching process resulting executable 
general standard testing techniques test patched executable 
example employ coverage testing tools xsu identifies tests exercise control flow paths program 
tools possible patch application running program accurately represented current source code 
apply coverage techniques state transformers patch time 
way compile patches linked statically prior version program allowing coverage tool identify paths patches conjunction rest program 
having done coverage tool able identify shape program state exercise various paths state transformers 
looking patch testing interesting useful 
lessons learned running server revealed aspects system 
instance learned soon deployed server version tal verifier buggy checked subset basic blocks loaded files 
verifier part trusted computing base updated 
ultimately shut system recompile new version verifier 
february deployed version time :10.1.1.161.3137
accommodate changes verifier trusted code allowing linking verification 
human error compiling server forgot enable exporting static variables compiling library code 
problem apparent attempted dynamically update dynamic updating library 
library properly removing old entries dynamic symbol table wanted patch library fix problem clean existing symbol table 
symbol table declared static available patch 
result update library effectively precluded state properly transferred 
system flexible extremely easy 
unable express change needed 
furthermore system flexible ways 
example number occasions loaded code print dynamic symbol table calling existing function updating library sure symbol names referenced patches particularly ones chosen static variables matched ones table 
loaded code print state file translation caches sure things working 
having verifier check patches loaded greatly enhanced system robustness 
example tried apply patch files incorrectly generated implementation file path mentioned patch description file pointed wrong directory 
result type definitions incorrect fact caught verifier 
applied patch state translation function failed account null instances updating library caught exception rolled back changes symbol table 
unsafe language resulted non system stopping core dump 
chapter performance point argued system dynamic updating flexible robust easy having system works practice 
chapter support claim approach imposes low overhead 
performance system parts 
look component overheads terms space time imposed dynamic linking updating load dlpop dlpop update statically linked programs 
second look updating overhead imposed application performance 
consider webserver flashed comparing throughput updating enabled throughput 
measurements performed isolated benchmarking cluster consisting machines connected com fast ethernet mb switch 
machine dual mhz pentium ii split level caches instruction data kb way set associative write back pseudo lru replacement :10.1.1.24.6526
second level way set associative cache unified kb byte cache lines operates mhz 
machines receive rating specint mbs memory 
run fully patched version redhat linux uses linux kernel version :10.1.1.40.2507
dynamic updating component costs execution time overhead imposed dynamic linking relative popcorn programs static linking occurs points time runtime dynamic load time program start time 
runtime externally defined symbol indirected got 
load time running program verify copy loaded code load link executing dyninit function relink rest program doing dynamic updating 
startup statically linked code construct initial dynamic symbol table register program type interface 
runtime overhead runtime overhead incurred global offset table got stores symbols external module function calls variable external symbols indirected table 
non updateable programs got dynamically linked modules updateable programs require modules contain got statically dynamically linked 
got got external variable assignment var movl eax movl got eax movl eax var movl eax esi movl eax movl eax esi external function call func call func movl got eax movl eax eax call eax code accessing external values got timer function call assignment overhead got got got got table overhead got measurements cycles 
essentially unoptimized popcorn compiler code sequences function calls variable got shown 
got access requires additional instructions move got address register get address proper got field 
slight change tal overhead optimized single instruction 
particular combine instructions movl got eax target esi eax variable case 
arithmetic sort currently allowed tal easily implemented relocation offsets supported elf object files got compiles relocation got offset trick employed gcc 
measured elapsed time due added instructions cluster machines elapsed time measured cycle counter instruction 
results shown table 
column shows overhead cycle counter architecture 
determined measuring read stored value cycle counter twice intervening computation 
remaining values obtained measuring desired code sequence subtracting cycle counter overhead result 
median measurements code sequence effect throwing outlying cases code got pointers hot cache 
cases added instructions resulted cycle overhead 
tempting assess overhead context real program 
say dynamic updating adds overhead function call 
worst case 
called function perform computation dwarfs cycle overhead added call 
computation performed cycles impact 

external symbols incur overhead functions variables module got 
program structured multiple source files affect total overhead 
better assess impact added cycles need examine impact application performance 
shown flashed application performance suffers overhead variety conditions 
second got overhead arises imported values 
recall imported values type nature default got value stored potentially null field got 
result principle got access value requires null check 
see overhead occur practice 
modules export values constructor functions produce values exception current code base popcorn core library defines stdin stdout stderr type file 
cases typically define type allow null value sort option type meaning null check occurred anyway 
load time overhead load time loading patch new module basic operations loading module linking relinking rest program 
look cost operations turn 
loading performed tal load load primitive implementation shown page 
major operations load disassembly verification 
verification performed phases consistency checking link checking collectively labeled type check interface checking labeled typeof vs 

verification load instantiate load code data object file program address space described construct tuple exported items conforming load type argument 
module loading dlpop library link module things calling returned dyninit function 
measured component costs patch files version flashed trends summarized drawing data table 
files applied due mutually recursive pass linking algorithm 
total time apply patches cost relinking program update time includes old versions modules replaced modules :10.1.1.24.6526
time consistency checking disassembly file size component costs dynamic linking relative file size 
axis total size types object files patch bar sums total time perform dynamic linking patch 
explicitly show disassembly consistency checking dominate total overhead combine overheads see total time dominated verification general consistency checking particular averaging disassembly second largest overhead averaging :10.1.1.161.3137
gm verification generally linear size files verified find essentially true :10.1.1.2.4977
load time operations table 
files listed order size corresponding bars left right 
total time operations shown rightmost column seconds percentage total time operation shown adjacent columns 
table clear cases verification dominant cost linking including relinking loading relatively inexpensive 
contexts loading times magnitude problem 
example seconds pause time intrusive os reboot :10.1.1.24.6526
case webserver infrequent pause worse just inconvenient user harmful system 
contexts may reason want shorter update times dlopen executes atomically gets done updating long pause update program tantamount temporary loss service 
identified means reducing load time cost 
verification times particularly consistency checking improved 
example proof carrying code nec demonstrated small verification times albeit different type system file info load link total patch name size bytes verification loading time secs convert read master timer accept file dir master main data cold loop average table time load link patches flashed tal implementors recognize gains gm :10.1.1.161.3137:10.1.1.40.2507:10.1.1.40.2507:10.1.1.24.6526:10.1.1.2.4977:10.1.1.2.4977
furthermore disassembly optimized 
second verification performed parallel normal service 
verification completes linking remains negligible overhead 
case completely trusted system flashed example safely turn consistency checking phase verification run loaded module machine 
leaving link checking interface checking ensures loaded code meshes running program module level link checking caught bug described trusts contents loaded module formed 
consistency checking time consuming operation greatly reduce total update times result 
breaking verification operation server client machines explored java 
start time overhead start time execution begins statically linked module dyninit function executed create initial dynamic symbol table program type interface program 
costs operations depend number symbols type definitions exported module libraries 
measured cost flashed consists source library files 
module cost registering symbols module order milliseconds registering program type interface similarly cheap 
result total time roughly seconds negligible reasons 
order time taken perform startup operations reading program disk 
second importantly expect programs dynamic linking uses got exports globals exports static dynamic linking dynamic updating file linked file linked statically dynamically statically dynamically table breakdown space overhead components files linked dynamic linking dynamic updating 
updating long running making larger start times inconsequential 
space overhead compiling popcorn files dlpop dlpop update adds additional code annotations source file resulting extra space overhead object file types file 
majority additional space linking little effect system runtime performance 
break component space overheads justify problem practice look particular overheads occur flashed 
symbol overheads object file space overheads arise symbol loosely related file size 
symbol overheads due dyninit function got 
overhead added exported symbol cases static symbol dynamic updating imported symbol got 
points summarized table 
overheads got runtime affect performance due additional space takes space added instructions required altering program cache locality characteristics 
attempted measure effect expect minimal application performance impacted shown 
symbol overheads shown table overheads pertaining imported symbols relevant got imports add overhead 
imported exported symbols dlpop imposes space costs string representation symbol name type representation instructions dyninit function perform linking instructions bytes exported symbol instructions bytes imported symbol 
popcorn strings length field extra pointer easier translation style strings adding words style representation 
import overheads may reduced currently large due compiler simplistic approach assuring left right evaluation order 
symbol dyninit type got dummy name code rep slot value ref total import function data export key symbol name length size symbol type representation number times symbol referenced table symbol object file overheads due dynamic linking updating got imported symbol requires got slot default value extra instructions symbol got 
default function simply throws exception resulting instructions bytes 
default value pointer points dummy value appropriate type initialized null 
cost pointer bytes plus size null value additional bytes case integers characters strings values structured type 
call uses got adds instructions see resulting extra bytes 
size type representations large bytes functions 
function type representations encode types arguments returned values calling convention 
mitigate cost somewhat sharing type representations elements type 
calling convention uniform improve overhead sharing type components representations 
doing require able construct type representations smaller components currently support 
addition object file overhead types file requires added type information new entities object file notably annotations various control point labels dyninit function strings type representations stored static data segment dummy values 
information types file discarded load time verification analyze overheads detail 
impact performance space overheads affect runtime performance ways argue practice performance negligibly impacted 
additional space occupy memory application particularly application heap cause application page 
believe problem reasons 
memory relatively inexpensive larger physical memory requirement cost prohibitive 
second additional overhead contribute program memory footprint paged updates 
majority space overhead file size bytes common match name dlpop static dlpop dynamic dlpop update static dlpop update dynamic standard compilation scanf timer accept file string filename data main parse space overhead flashed object files compiled loading updating link time meaning needed normal execution 
link time space overheads due dyninit function symbol names type representations dummy functions constitutes bytes overhead symbol bytes symbol definition got 
hand elements needed time update performed due strategy relinking permanently paged 
indirection described relinking solve problem introduce extra level indirection 

program cache locality negatively influenced 
expect problem reasons point 
majority space overhead linking occupy space cache 

dynamic linking updating may distributed environment la java extra space result added network transmission time loading file network 
turns types files type representations highly compressible gzip need contribute excessive network transmission time 
overheads practice having considered source space overheads abstractly consider overheads manifest practice 
shows measured increase size object cold loop file size bytes common match name dlpop static dlpop dynamic dlpop update static dlpop update dynamic standard compilation scanf timer accept file string filename data main parse space overhead flashed types files compiled loading updating files flashed due support dynamic linking updating shows increases types files 
axis shows popcorn file compiled axis shows size compiled file 
file cluster bars black part bar indicates size file compiled normally support dynamic linking updating 
bar cluster shows space added file compiled 
particular dlpop static bar indicates added space compiling file export symbols dynamically linked files dlpop dynamic indicates added space compiling file dynamically loadable dlpop update static file compiled statically linked updateable dlpop update dynamic file compiled loadable updateable 
correspond columns shown table 
worst case dynamic updating support increases object file size accept pop best increases parse pop 
considering percentages somewhat misleading overhead really related file size number symbols imports exports number times imported symbols referenced 
see comparing cold pop roughly adds information due dynamic updating pop size adds :10.1.1.40.2507
file cold pop large functions importing symbols exporting symbols pop small functions data exporting symbols importing symbols 
general dynamic updating adds greater overhead statically dynamically cold loop linked files dynamic linking 
difference slight dynamically loadable files just exported local symbols pronounced statically linked files due lookups required updating 
interesting phenomenon object file size increases updateable files loadable compare dlpop update static bar dlpop update dynamic bar types file size decreases compare bars 
statically linked files initialize got members extern values resolved static linker meaning mtal interface file size stored types file increases dynamically loadable version defines dummy functions 
particularly interested reader table presents underlying information graphs 
table read row wise 
loading column serves base case overhead rightmost columns indicate space overhead employing particular compilation approach 
second columns show size bytes object file types file generated compiling popcorn file normally 
column follows additional overhead various compilation strategies shown bytes relative loading case object file types file percentage loading size 
rightmost columns grouped dynamic linking dynamic updating considering files statically linked dynamically linked 
example accept row indicates compiling accept pop normally results object file size types file size 
pop involved dynamic linking linked statically export symbols dynamically linked files adds bytes object file bytes types file shown columns :10.1.1.161.3137
additions constitute overhead object types files respectively compared normal compilation 
compiling accept pop updateable dynamically loadable columns adds bytes object file bytes types file compared normal compilation constituting overhead files respectively 
application performance argued primary impact dynamic updating performance added level indirection external symbol due got dynamic linker 
course overhead affects application performance depends application 
particular depends ratio time application spends referring external symbols compared performing 
higher ratio greater impact 
section consider performance particular application flashed webserver understand effect dynamic updating overheads 
note measurements dynamic linking include extra logic due current support updating compiled pass pass algorithm 
causes somewhat larger compiled described chapter 
file pop loading dynamic linking dynamic updating static dynamic static dynamic accept string cold common data file loop main match name scanf parse timer table space overhead flashed compiled loading updating flashed performance measure server performance version freely available webserver benchmarking system mj :10.1.1.161.3137:10.1.1.40.2507:10.1.1.24.6526
httperf single highly parameterizable executable process acts client 
generate loads variety ways able simulate multiple clients non blocking sockets 
ensure server saturated multiple httperf clients executed concurrently different machines 
throughput measured sampling server response fixed intervals reporting average standard deviation run sampled throughput printed test 
version sample time fixed seconds run concluded performing set number requests 
changed code allow sample time vary allow fixed time tests ensuring equal number samples various runs 
understand cost updating compared statically compiled updateable versions versions flashed 
addition compared difference version statically compiled updating enabled version patched line 
suspected case worse performance due larger memory footprint poorer cache locality 
particular retain original version code text segment new code loaded heap 
various versions flashed ran kinds tests 
cases machine ran flashed server machines ran httperf clients 
case ran log test simulate typical client activity 
client uses identical containing list files request corresponding weight file 
request determined pseudo randomly weight 
test run specified time clients halted relevant data collated 
performance metrics potentially interesting focus server throughput 
log test throughput measured terms bytes served webserver unit time 
ran url tests reduce amount variability httperf clients request url constantly duration test 
throughput reported terms connections second 
log test log test obtained webstone benchmarking system web file shown 
column indicates url second column indicates weight assign comment third column indicates file size bytes 
webstone documentation claims list fair representation server load file traffic 
reduce variability sampled numbers second sample times 
ran test close minutes yielding samples 
observed skewed distributions cases report median mean quartiles describe variability 
shows results measurements 
axis varies server version columns show throughput flashed respectively fourth column shows throughput flash compiled gcc version flag point compare performance throughput mb file html file html file html file html file html log test 
static updateable updated server version flash flashed throughput mbits sec log test flash flashed :10.1.1.161.3137
axis shows throughput mb note start 
version flashed measured server performance compiled updating support labeled static updateable respectively patched line labeled updated example updateable flashed compiled directly version sources updated flashed compiled version patched twice dynamically 
server show median throughput quartiles bars trials range bars serves confidence interval pg 
overhead due updating difference performance server version medians static updated updateable versions 
cases overhead negligible compared measured variability 
flashed updated code slightly faster statically linked updateable code reverse true version 
fact relative absolute locations code updated program different updateable may source difference modules affected differently cache policy 
addition heap sizes updated program uses heap store update code updated version garbage collects 
general difference confidence interval numbers may due experimental variation deterministic difference 
url test log test characterizes typical performance shortcomings 
actual activity seen server variable sample sample urls requested aggregate clients may differ sample 
extended sample time seconds mitigate problem value relatively speaking sizeable variability 
particular semi interquartile range difference high low quartiles divided roughly median compared median tests describe 
second problem log test provides sense worst case overhead files requested test quite large time dominates overhead imposed updating 
address problem sample variability ran tests request url repeatedly 
examine dominates updating overhead considered variety url file sizes files kb files 
url second sample time ran test just minutes totalling samples 
calculated median quartiles 
results shown format 
thing notice variability decreased particular typically median case files interquartile ranges rarely overlap cluster points 
range axis differs graph starting 
error bars files size rest appear significant scale axis smaller 
understand trends exhibited graph graphed overhead due updating shown axis url file size shown kb kb kb files logarithmic scale presentation purposes axis percent overhead non updateable static flashed 
basic trends 
overhead decreases size file increases 
byte file see overhead kilobyte file overhead 
added time overwhelms extra processing cost 

general relative overhead due updating decreases version number flashed increases 
seen comparing updateable lines points marked boxes comparing updated lines points marked 
explanations phenomenon 
processing time request decreases file network transfer time remains impact updating decreased 
second fewer external version versions 
runtime penalty extra indirection occurs definitions current file fewer kinds lower overhead 
discover relevant fraction modified popcorn compiler insert counters global data functions differentiating throughput throughput static updateable updated server version url file html static updateable updated server version url file html static updateable updated server version url file html static updateable updated server version url file html flash throughput url tests external static variables :10.1.1.24.6526
re built versions flashed ran tests 
versions server percentage dynamic external definitions respectively meaning version incurs lower penalty indirection relative non updateable version :10.1.1.161.3137

relative overhead updated updateable versions inconsistent updated version performs better updateable 
follows pattern log test 
flash point compared performance fully optimized version flash flashed results comparison shown figures 
general performance quite similar flashed version 
particular performance flash flashed larger files nearly identical performance slowdown relative static flash updateable flash updateable flash updated flash updateable flash updated url file size correlating overhead url file size flash smaller files log test slightly worse :10.1.1.24.6526
expected flash consistently outperform flashed surprised version flashed reverse true 
course cost file processing due cpu intensive task certainly favor implementation 
case draw tal pcc general viable platform medium performance intensive applications 
chapter significant advance state art areas study :10.1.1.24.6526
section consider areas closely 
look relevance approach kinds programming languages notably functional object oriented languages 
particular look difficulty encoding closures classes updateable approach 
second look closely question update validity briefly formulate idea facilitate reasoning stateful properties modules isolation rest program 
third look prime application domain technology active networks discuss done realize technology active networks 
consider features worth supporting including unchecked updates secure linking updating types 
functional languages core reason additional complexity dealing function data pointers described comes notion dynamic patch 
approach updates code performed automatically updating data may contain pointers updateable definitions left state transformer function 
approach unreasonable imperative language popcorn infrequent function pointers 
applying approach functional programming languages may result far greater difficulty 
languages extensive function pointers specifically closures function pointers combined environment writing state transformer find pointers difficult general essentially impossible pointers hidden inside inaccessible data 
consider alternate approach updating function pointers consider developed technique applied closures 
pointers updateable definitions consider notion patch says program data contains updateable definitions data updated automatically point updated definition requiring programmer state transformer function described 
automatic approach taken dynamic ml functional language standard ml :10.1.1.161.3137:10.1.1.24.6526
case dynamic ml cost complicated trustworthy implementation 
possibility implementing semantics adding tcb introduce compile time extra indirection pointer treated data 
particular storing pointer variable store pointer variable got entry 
pointer extracted variable dereferenced extra time point closer dereferenced better notices changes got relinking 
consider example page manipulates function pointers :10.1.1.161.3137
want compare file normally compiled updateable compile indirection function pointers 
shows file transformed loadable updateable standard manner described chapter surprises :10.1.1.161.3137
transformation added indirection function pointers got differences shown boxed 
thing notice code fnptr pop changed declarations having type int int changed type int int 
includes declaration fnptr struct type argument change result actual ptr intfn function requires extra dereference just called 
syntax indicates read tuple analogous syntax writable tuples 
read tuples created making regular tuple casting read shown field variable ptr intfn code int int new fn 
reason tuples read explained shortly 
time function referenced name address got entry entry delaying dereference actual call got address tupled function pointer original function type got entry address type 
function defined file normally got entry need 
case example got entry created function properly initialized 
furthermore need initialize global variable ptr intfn got entry dyninit function ptr intfn got tupled function pointers properly polymorphism allow type applications go tuple example consider polymorphic list operations fold right append code function flatten extern fold right list accum extern list append list list list flatten list list return fold right append null compiling file loadable updateable yields portions omitted static int int return struct fnptr int int static fnptr ptr intfn new fnptr static void change int intfn int ptr intfn intfn static int int return ptr intfn static bool looked old flag false static bool updated flag false void dyninit fnptr lookup string rep lookup closure void update string rep update closure bool init looked old flag looked old flag true init return updated flag updated flag true update update closure fnptr local ptr intfn repterm fnptr ptr intfn update update closure repterm int int update update closure repterm int int update update closure change repterm void int int change transforming fnptr pop standard manner loadable updateable :10.1.1.161.3137:10.1.1.24.6526
static int int return struct fnptr int int static fnptr ptr intfn new fnptr int int new fn static void change int int intfn ptr intfn intfn static int int return ptr intfn static exception string static int fn int raise new static got got new got static struct got int int static bool updated flag false static bool looked old flag false void dyninit fnptr lookup string rep lookup closure void update string rep update closure bool init looked old flag looked old flag true init return updated flag updated flag true update update closure fnptr local ptr intfn repterm fnptr ptr intfn update update closure repterm int int update update closure repterm int int update update closure change repterm void int int change ptr intfn got transforming fnptr pop automatically notice updates function pointers :10.1.1.161.3137:10.1.1.24.6526
differences boxed 
static struct got fold right list list append list list static got got static list flatten list list return list got fold right list list list got append null key boxed part type application applied tuple got append cast read got append function :10.1.1.24.6526
modifications tal verifier popcorn type checker allow sort deep type application occur 
allowing type application occur tuple sound tuple value changed reason read tuples 
consider code id return int int return void foo new id int int int illegal int new error 
polymorphic id function types increment function int int 
body foo create tupled function pointer initialized id function having type 
alias tuple refined type int int ok far 
problem occurs third line change contents function alias change contents constituting type error 
contain function type contains function type int int 
result invoking tuple new increments pointer contents tuple tuple 
coercions writable tuples unsound 
explain somewhat informally applying type application read tuple sound 
say type modifiers source read sink read write 
known subtyping relations sound formulated reynolds language forsythe rey source source sink benjamin pierce helping 
sink sink source furthermore rule known sound intractable mit denotes capture avoiding substitution occurrences rule states universal type may particular instantiation universal type may assumes type erasure semantics underlying representation type instantiated type :10.1.1.24.6526
rules correctly approximate type instantiations tuple passing source containing polymorphic function 
standard application subtyping type checking rules functions type term follows source int int int source int int int source source int int source source source int int source int int source int int int source int int int place polymorphic subtyping rule propose add simpler rule tailored type application sources source source intuitively rule hint type checker apply polymorphic subtyping rule 
simplifies type checking may key decidability 
formally proving tal sound addition 
focused type application really type application just instance general problem deep coercions deserves study context 
closure function pointer environment extern abstype fn closure function pointer environment extern fn fn apply closure argument extern apply fn closures interface popcorn fn module approach greatly simplifies process constructing dynamic patches solves problem update data part type :10.1.1.24.6526
point useful general particularly helpful allowing closures updated 
typed encodings typically package function pointer environment inside existential type type environment closure consists function takes environment argument type returning type actual environment :10.1.1.141.7192
function part closure updated relevant definitions pointed environment updated 
see apply indirection approach closures consider encoding closures provided popcorn fn library 
key portions interface shown 
existential type declaration fn type closures type polymorphic function fn constructs closure function pointer environment function apply applies closure argument function existential package calls function pointer environment provided argument apply closure argument apply fn return defer explanation adopted approach 
applying transformation fn interface get extern abstype fn extern fn fn extern apply fn closures store tupled function pointer similarly fn requires tupled pointer argument :10.1.1.24.6526
apply function apply closure argument apply fn return extra dereference added just invocation 
way implementation function changed dereference point new version 
environment contents updateable transforming environment provided argument fn 
limitations approach described captures essence functional languages simplify patch construction popcorn clearly need experience real functional source language see features interact transformation 
problems approach 
popcorn implemented transformation function pointers described adopted reasons 
intuitively transformation complete program notice data updated proven 
requires 

transformation changes types functions 
results problems 
translation files compiled updateable files compiled loadable freely intermixed program 
importantly libraries compiling updateable code statically linked slight performance penalty 
result need set system libraries 
change types functions longer case 
hand having multiple sets libraries case versions updateable uncommon 
example libraries unix systems historically compiled profiling information library determined link time inconvenience programmer 
second changing function type may invalidate type representations conjunction function 
example consider source code int int int int dlsym repterm int int int int code looks function handle function takes function argument :10.1.1.40.2507
translated code int int int int dlsym repterm int int int int got mismatch actual type type passed dlsym tupled function pointer argument type representation argument dlsym similarly tupled 
obviously clear automatically tupling functional parameter types type representations correct require investigation 

dlpop library uses function pointers calling dyninit functions loaded code compiling indirect pointers problematic 
due disconnect compiler library compiler going add indirections function pointers compiling dlpop library aware 
avoid problem thought compiling dlpop library standard manner having function pointers indirected 
problem calls library routines take function pointers arguments hashtable iter takes function operate element provided hashtable 
call function normal function pointer hashtable module compiled expect tupled function pointer 

discussion focused function pointers problems arise pointers data 
take address top level definition say defining variable type int store array definition updated pointer array point old definition 
may identifying data transforming code manipulates just done function pointers straightforward looked 
object oriented languages step understanding approach applied object oriented oo languages consider oo features encoded functional languages draw previous discussion 
popular encoding oo features calculi pierce turner object encoding pt :10.1.1.17.9345
framed language extension polymorphic calculus includes records subtyping type operators 
tal type system includes features subtyping restricted implying tal sufficient target oo languages :10.1.1.40.2507
encoding pt functional pierce showed applies slight alteration imperative settings pie :10.1.1.17.9345
objects encoded records having existential type type state abstracted record consists fields containing state containing methods state 
example single dimensional point object having methods getx setx type point state methods getx int setx int element type point unpack existential call desired method object state additional arguments 
example invoke getx method object methods getx state subtyping features allow structural notions subtyping 
example different version points cpoint define methods point additionally include methods set get color 
version places regular points virtue fact methods record contains functions point 
basic notions pt builds traditional abstractions oo programming including classes inheritance self :10.1.1.17.9345
objects encoded manner quite similar closures techniques described previous section objects updateable 
real world object oriented languages features difficult encode way 
example java scoping allows object access fields object class 
java instanceof implies objects identifiable class runtime 
way identity tags similar ones exceptions popcorn glew gle describes tagging mechanism 
tag identity problematic updating exceptions see 
general functional languages experience needed real oo source languages determine oo features interact poorly transformation fundamentally see tal suitable target oo languages 
update validity state visibility explained allowing code change arbitrarily result incorrect behavior timing considered 
believe invoke model simplifies finding correct update points done aid programmer process 
particular hope formalizing conditions relevant updating may enable automated determination proof valid update points 
previous formal lee fs serve starting point investigation 
simplify process reasoning program updates able consider individual modules isolation :10.1.1.40.2507
specifically consider information module state visible modules program 
knew precisely ways program modules access manipulate module state better update module 
thought little notion state visibility details 
particular look classes program state consider visibility state indicate state may correctly updated 
globally visible state state globally visible directly accessible rest program defined non type 
case state visible entirety program modules may manipulate state time manner desire 
programming modular style globally visible state avoided favor particular functions manipulate state adt module protected state explained 
module protected state globally visible state module protected state visible functions module 
know exactly functions may manipulate state insert mapper procedures functions alter state 
example say module routing node routing table static host host list routing table null host lookup host dest lookup dest routing table returning result suppose want change type routing table include route metric stored integer 
naively think simply translate old state new inside init function load time 
code module currently manipulating state inconsistent 
past approaches sought prevent inconsistency forbidding updates occurring module updated running 
goal find ways constraints necessary 
way write stub functions translate state executing new functions static host int host list new routing table null extern host host list routing local routing table null static bool done translation false host stub lookup host dest done translation translation old new return new lookup dest way code old module operating table new version loaded complete operation old representation operation table perform translation :10.1.1.40.2507
eliminate check see translation done stub update described 
concern maintaining mutual exclusion 
example multiple threads may access router table may update thread old version thread enters new version 
means threads potentially operate different versions table 
point code allow thread access state expect appropriate protections mutexes place 
translation code similarly mutexes alter state safely 
stating formally useful 
thread maintained state thread maintained state local particular thread 
erlang essentially kind available state mutation possible server threads crafted functions carry state arguments 
way clients may access thread local state communication thread message passing events rep 
isolates data making simpler reason changes 
example updating server thread erlang arm easily apply technique context 
data data having type may manipulated certain functions rest program treat abstractly providing essentially sort visibility module protected state 
dynamic ml exploits property allowing implementation data program manipulation functions changed :10.1.1.161.3137
drawback transformation state may incremental requires complex runtime support forbids manipulation functions update 
implement type updating renaming allow different versions types data coexist newer versions adt different name 
say example implements type represent symbol tables module client maintains data type symboltable upload new code improves implementation symboltable 
contain routines translate data type symboltable update client new symbol table technique exactly module protected state translation routines 
potential drawback approach may code conversion routines functions exported symboltable proposed gup object oriented programs 
advantage security old implementation preserved 
limit ability perform conversions data representation accessible 
dynamic ml takes approach incoming packets user user core services base functions queue demux user outgoing packets active router supporting user extensions allowing updating code access representation old version :10.1.1.161.3137:10.1.1.40.2507
system allow 
touch idea 
active networks active networks networks elements way programmable 
prototype active network systems provide programmability router extensibility routers extended loaded code implement new functionality cases extensions unloaded 
systems take approach include alien ale planet mbc name 
systems code extensions plug ins constrained interface system predefined manner 
example alien extensions receive packets registering queuing machinery called core 
planet extensions services called packet programs constrained match interface expected plan interpreter 
notion limitations plug extensibility hn 
general usefulness systems enhanced dynamic software updating 
particular limited loading unloading extensions matching predefined interface component running system potentially altered 
updating modules active network router difficult examples considering far 
central reason exact makeup code system known code 
particular router shape shown 
consists basic functions core services provided router owner pockets code loaded various users 
router supports dynamic software updating user may wish update piece code unaware clients code 
user wished update repository information maintained service loaded say changing type may inadvertently break clients code 
support updates complete knowledge code making system requires characteristics :10.1.1.40.2507
system able enforce boundaries user code 
particular user able modify access bindings user code permission 
implies proper presentation namespace linking user credentials 
approach dynamic linking pays dynamic symbol table implemented updated type namespace controlled type heap masks load see 
similarly sure user code safe 
user loads code expecting service old interface 
verify code running tal verifier detect code incorrect interface load aborted 

updated module provide way old clients call new code old type 
provide characteristic stub functions 
global data may change type code updated refers 
ensured relinking process old client dyninit function called perform lookup global variable old type result error causes rollback occur 

clients may store pointers updated code way update pointers 
currently meet requirement update re init functions called relinking see 
alternatively move indirection approach data described changes reflected automatically 

changes named types supported isolation 
particular redefines named type easy client type 
type replacement strategy completely straightforward 
way communicate new name type clients 
simple calculated md hash implementation 

system structured updates valid 
idea state visibility explored handy considers updates modules isolation entire system 
clearly mechanisms place realize code updating active router 
areas need study 
updating types difficult new name type generated automatically client may know implementation type 
second need better understand restrict structure system evolutionary ability compromised updates reflected correctly 
instance services general export global data module protected state 
user code directly accesses global state state updateable client updated state 
addition restrictions support validity described may practical restrictions active router structure 
improvements conclude chapter considering potential improvements system :10.1.1.40.2507
unchecked updates dynamic updating system proven flexible changes reflect dynamically 
fundamentally allow updating verifiable native code impossible update trusted computing base 
expect changes level rare critical saw need update verifier verifies parts patch see 
technical difficulties mention robustness issues relax limit providing lower level interface dynamic loader circumventing pcc general 
namespace management security system designed support fine grained management symbols types security purposes explore possibility 
speculate implement secure symbol management 
part benefit having symbol management linking outside tcb allows greater flexibility different mechanisms situation calls implementing linking policy 
example assign user cryptographic key authentication purposes code loaded 
symbol requested function dyninit policy check determine user sufficient privilege acquire symbol 
exception raised leaking information user existence symbol case raised 
better different values requested symbol may provided privilege 
example unprivileged users requesting open symbol may get version open works files tmp directory 
furthermore operations implemented tal code part tcb safely replaced updateable system need arises 
example want switch different cryptosystem flaws current 
extending load allow type heap masks described formalized type management possible 
idea module different type heap mask level privilege making fewer named types available 
need able access construct relevant masks program type heap changes newly loaded code 
abstractly require operations obtain relevant type heap masks module load combine masks create various notions program type interface passed load 
requirement type heap mask manipulation trusted different alternatives crafted different situations 
way determine mechanisms appropriate consider extent type heap masks need manipulated dynamically 
minimum compiler generate various type heap masks relevant particular module add static data extracted call load :10.1.1.40.2507
runtime provided function combine masks takes type heap masks arguments returns result merging masks operator defined page 
masks combine masks generate subject security policy 
masks generate determined statically scheme suitable policy need change runtime 
consider having load generate module program type interface return exported values 
manipulate mask function remove typedef takes arguments mask type name returns mask minus mapping type name 
provide function having signature causes mapping treated 
benefit approach dynamicity 
time load called type interface returned permissive program 
policy determined runtime thin environment depending privilege user loading code 
general approach taken number systems hk 
dynamic approaches possible 
provide functions allow direct construction masks adding bindings 
example provide function add binding takes mask type name type representation returns mask binding type name type 
clear level flexibility useful simply mask sub heap program type interface maintained tcb 
adding constructed bindings mask probably useful combining masks returned load removing bindings masks 
experience needed really determine abstractions sufficient 
updating types described popcorn supports module level types 
particular structures unions declared meaning code local file may see type implementation enforced tal verifier 
result dynamically linked file able see implementation type 
general behavior desirable prevents loading new code update replacement implementation type 
possible proposal outlined namespace security apply types 
particular verifier maintain restrictive type environment allows breaking abstraction linker code pass restrictive environment cases ones type implementation updated 
provides insight question updating types sew 
chapter dissertation show updating code data running program dynamic software updating achieved general purpose manner flexible efficient robust easy :10.1.1.40.2507
demonstrate thesis described design implementation dynamic updating system argued desired characteristics flexibility system permits changes programs granularity individual definitions functions types data 
furthermore allow definitions change arbitrary ways notably functions data may change type named types may change definition 
system permits updates occur time code updated active providing programmer greater control 
approach uses imperative language widely usable 
robustness system dynamic patches consist typed assembly language tal mwcg :10.1.1.24.6526:10.1.1.24.6526
result patch crash system perform incorrect actions proven respect important safety properties 
implementation builds top basic dynamic linking keeping implementation simple 
furthermore developed means loading dynamic patches unduly expand trusted computing base improving confidence system safety 
automated patch generator ensures patches completely specified 
programmer free ensure updates timed system imposed timing restrictions 
problem occurs linking state transformation update rolled back previous state 
efficiency system imposes modest runtime overhead associated dynamic linking 
tal programs patches consist native code giving obvious performance benefits compared interpreted systems java 
ease construction patches largely automated clearly separated typical development process 
new software version completed tool compares old new versions source files develop patches reflect differences 
total automation undecidable tool generate useful patch code majority cases leaving placeholders programmer infrequent cases :10.1.1.40.2507
patches encapsulate issues relating dynamic change cleanly separated normal development code simplifying software maintenance 
dissertation supported assertions describing system design implementation component performance characteristics 
addition drew experience building non trivial dynamically updateable application flashed webserver 
explained publicly deployed version flashed developed dynamically updating significant ways period months doing showed system flexible robust supported assertion easy 
addition measured flashed performance showed updating system imposes negligible overhead flashed performance 
represents significant advance state art 
particular prior general purpose updating system adequately meets evaluation criteria 
criteria chosen system flexible may able express desired change dynamically requiring service interruption system robust incorrect patches crash system cause misbehave system simplify building maintaining updateable software limited scope magnify chance user error system imposes high overhead useless large potential runs high performance server systems 
addition stands significant advance validation dynamic updating systems 
far aware prior general purpose approach performed detailed performance assessment prior study published experience significant application 
contributions described research dissertation number specific contributions revolve design evaluation dynamic software updating system 
developed complete framework safe dynamic linking verifiable native code 
system built enable dynamic linking native code way safe flexible support variety dynamic linking strategies 

defined implemented novel notion dynamic patch cleanly separates concerns program patch development 
simplifies development process program code maintainable polluted code support dynamic patching 

employed novel approach dealing changes type definitions renaming 
approach works practice avoids implementation complexity true type replacement employed systems dynamic ml dynamic java classes mpg :10.1.1.161.3137

developed tool automatically generates patches versions program 
tool greatly simplifies process developing dynamic updates ensures updates completely specified 

show verifiable native code vnc technology particular typed assembly language flexible support dynamically updateable programs 
vnc increases robustness running program dynamic patches 

built sizeable updateable application updateable webserver 
far know largest application described general purpose dynamic updating literature updated non trivial ways lengthy course time 

show direct measurement dynamic impose low overhead 
systems documented performance data 
appendix proofs formal properties tal load chapter presents complete proof soundness type safety 
presentation proof bottom starting properties system needed final proof 
start properties type environments properties heaps properties type derivations proof type safety 
load calculus load calculus incrementally summarize syntax static semantics operational semantics 
definitions heap linking type interface linking operations type environments repeated main text see definition page definition page page respectively 
note formulation includes type heap mask defined 
syntax labels vars operational semantics types int ref type environments 
nn type env values type interfaces xi xh expressions reveal ref assign load values heaps 
ln vn programs heap types 
ln type contexts contexts operational semantics deterministic rewriting rules expressing call byvalue evaluation order 
rules load type environment operators defined page type interface linking operator link definition page heap linking operator merge definition page 
please refer details 
xh merge hi xh xh xi link xi xi xh load ei xi xi hi ei xh load success load load failure beta reveal reveal ref ref dom deref assign assign tapp reveal reveal load load load load ref ref assign assign assign assign static semantics congruence judgments static semantics bottom type formedness type environment formedness heap type formedness expression formedness heap formedness program formedness xp 
int ref dom rng rng int int load int ref reveal ref ref xp ref dom xi xh xi xh xi xh xi xh xp xi xh ref assign xh xp properties type environments lemmas corollaries developed section purpose proving load case subject reduction section 
lemma type environment equalities suppose type environments 





:10.1.1.161.3137


proof fails 
assume 
dom furthermore dom 
analogous reasoning 
proof trivially likewise 
suppose undefined 
reverse case happen assumption 
proof include names removing names removing ones lemma type environment merge xa xb xa xb 
lemma type environment weakening suppose defined 





proof 
proof induction 

int int 
domain range change remaining cases follow induction 

rng 
follows 

proof induction 
follows trivially induction rule abstraction type application part needed verify type added context 
reveal note definition rest follows induction 

dom 
follows 
corollary suppose defined 





lemma type environment redundancy elimination proof sketch name type environment contains name subtracting redundant names interfere type formedness 
properties heaps lemmas corollaries developed section proof subject reduction load ref cases 
lemma heap weakening dom type 


proof 
show rng 
rng true inversion 
rng 
follows trivially assumption changed domain 
proof induction 
follows trivially induction 
abstraction type application cases need new type 
corollary 


lemma heap redundancy elimination exists dom dom 
proof show dom 
obvious removed label properties type derivations lemma type type substitution proof proof induction case int follows trivially 
case assumption 
remaining cases follow simple induction 
lemma ref case subject reduction 
lemma regularity 
proof proof proceeds induction derivation 
case int 
follows directly int 
case 
assumption inversion 
case 
assumption 
case 
inversion result formed 
induction 

case 
induction inversion 
case load 
induction 
case rule side condition case reveal :10.1.1.161.3137
rule side condition assumption 
weakening 
case ref ref induction ref follows directly 
case 
induction ref induction 
case assign 
induction 
case 
induction 
case inversion induction type type substitution 
lemmas proof substitution 
lemma weakening dom dom 
derivations depth 
lemma permutation permutation permutation 
derivations depth 
lemma substitution 
proof proof induction 
case int int 
case 

case 
assumption result follows 
case follows induction weakening permutation 

case 
follows induction 
case load 
follows induction int int load 
case follows induction case reveal :10.1.1.161.3137
follows induction reveal 
case ref ref follows induction ref ref case 
follows induction ref 
case assign 
follows induction ref 
assign 
case 
follows induction weakening 
case 
follows induction 
lemma type substitution 
proof proof induction 
cases trivial induction 
selected cases case load 
induction int int 
type type substitution load 
case follows induction 
closed 
case reveal 
follows induction reveal 
lemma proof progress develop type soundness 
lemma canonical forms int ref proof proof examination step typing derivation 
rules require expression non value require non empty context 
remaining rules produce types correct values 
type soundness type soundness proven subject reduction progress standard 
lemma subject reduction proof proven showing type environment formedness heap typing formedness heap formedness expression formedness brevity refer points proof ewf respectively noted assume hold assumption 
proof induction typing derivation 
case beta 
application inversion xi xh xi xh ewf follows substitution xi xh 
evaluation rule xi hi ei xh 
xi link xi xh merge hi xh xh merging formed heaps fact linking formed type environments fact xi xi hi loaded program formed fact xi xi xi xi hi xi xh running program formed xi xh xi xh xi xh xi xh load inversion expression typing judgment xi xh int xi xh int xi xh xi xh facts load success case proof subject reduction case load success xi xh load establish ewf 
useful facts shown 
define satisfies fact satisfies fact define defined dom dom dom hi dom hi fact prove formedness new program establish xi xi xh xi xh xi xh definition 
xi xh xh xh xi xh xh xi xh lemma 
xh associativity commutativity 
xh lemma fact xh 
xi xh xh xh xh true long dom xh xh dom xi xi 
true fact fact xi xi xh xi xi commutativity 
xh xh true lemma 
lemma apply show xi xh xi xi 
true lemma 
lemma apply show xi xi fact xh xi see xi xh fact xi xi fact xi xi fact xh xi fact 
show xh show dom xh dom xh xi 
know xh xh dom xh dom xh dom xi xh xi fact dom xh xh know dom xi fact xi xh xi associativity commutativity 
fact xi xh fact xi xi 
lemma result xi xh xi xi 
equivalent 
consider possibilities 
fact xi xh xi xh 
xi xh equivalently xi xh 
type environment weakening xi xh xi xi shown proof equivalent 
fact xi xi xi xi 
similar weakening 
may conclude equivalent hi 
consider possibilities 
fact xi xh xi xh 
xi xh xi xi 

hi 
follows similar reasoning 
ewf know xi xh xi xh 
weakening argument 
may conclude formedness result 
case load failure xi xh load xi xh ewf follows directly xi xh 
case reveal xi xh reveal xi xh typing derivation xi xh reveal concluded xi xh xi xh xi xh proves ewf 
case ref xi xh ref xi xh follows assumption 
show follows 
consider typing derivation xi xh ref inversion ref xi xh 
may assume dom heap redundancy elimination side condition evaluation rule 
choose 
show show xi xh consider arbitrary dom dom xi xh assumption heap weakening 
show xi xh show xi xh follows typing derivation xi xh ref previously concluded xi xh lemma xi xh show show xi xh consider arbitrary dom dom xi xh assumption heap weakening 
show xi xh show xi xh follows assumption noted 
show ewf note xi xh ref case deref xi xh xi xh 
inversion xi xh ref furthermore 
program formedness xi xh implies xi xh desired result 
case assign xi xh assign xi xh :10.1.1.161.3137
follow assumption 
show show xh consider xi xh follows assumption changed labels 
show xi xh 
inversion xi xh ref implies inversion 
inversion xi xh gives desired result 
ewf show xi xh 
follows trivially inversion 
case tapp type 
inversion xi xh xi xh doing get xi xh 
may apply type substitution conclude xi xh case congruence rules follow induction 
lemma establish useful lemma progress defined corollary 
lemma xi xh xi xh xi xh xi xh value exists xi xh 
proof proof induction xi xh xi xh 
consider expression typing rules value case app cases value induction exists xi xh 
congruence xi xh 
value induction exists xi xh 
congruence xi xh 
values 
canonical forms beta reduction xi xh steps xi xh 
case load load arguments value induction exists xi xh 
congruence load take step 
values canonical forms integers conditions load success hold representation type environment representation typed program link compatible current type environment xi xh load 
load fail step rule applies xi xh load xi xh 
case reveal reveal 
value congruence rule applies 
value type canonical forms xi xh reveal xi xh reveal reduction 
case ref ref 
value congruence rule applies 
xi xh ref xi xh ref reduction 
case deref 
value congruence rule applies 
value type ref canonical forms inversion dom deref reduction xi xh xi xh 
case assign assign 
values congruence rule applies 
value type ref canonical forms inversion dom assign reduction assign lv 
case tapp :10.1.1.161.3137
value congruence rule applies 
type canonical forms tapp reduction 
corollary progress value exists 
say term stuck value rule operational semantics applies 
type safety requires typed term stuck theorem type safety stuck 
proof proof induction number steps execution progress show new state subject reduction show new state typed 
appendix related section survey related dynamic software updating 
looking enabling technologies dynamic update state transfer dynamic linking area describe past static linking component systems 
examine systems directly targeted modifying running program discussion serves supplement analysis 
briefly describe related area dynamic reconfiguration software architectures 
surveys dynamic updating approaches gupta gup segal frieder sf 
state transfer term state transfer refer systems capture program state restart program saved state 
state transfer implement dynamic updating restarting new program old program state problems doing 
state transfer typically implement process migration smi checkpointing pla general purpose persistence 
briefly consider area 
process migration process migration loosely describes techniques move running processes network different machines load balancing access remote resources 
excellent survey techniques smith smi 
process migration systems typically require program manually save state automated checkpointing technique save restore state 
checkpointing checkpointing technology seamlessly capture program state save restore 
simplest checkpointing approaches architecture specific copy pages program heap stack plus state registers store file 
program easily restarted kind machine code addresses data 
library simple elegant approach kind checkpointing implemented user space 
unfortunately user space library capture os resident data mappings file descriptors open sockets pipes operating systems implement checkpointing eros ssf capture relevant process data 
user space os approaches drawback saved state program architecture dependent 
done architecture independent checkpointing 
example hof rs developed means instrumenting program capture state abstractly 
achieved performing source source translation original program programmer identified points program capture global state 
addition extra code added function calls capture restore stack 
approach solves architecture specificity checkpointing program dependent 
particular layout stack matches expected call sequence original program 
furthermore languages strongly typed thwart mechanisms properly capturing restoring pointers problem observed garbage collection community led called conservative collection bw 
general purpose persistence general purpose persistence gpp cf 
approach program data stable execution 
program crashes running restarted saved state 
gpp generalizes database systems stable data need stored extracted explicitly stable store special interface 
program data manipulated normal fashion system ensures persistent automatically 
different approaches identify persistent data different ways 
example data marked syntactically programmer declare stable int 
approach persistence reachability data reachable number pointer dereferences persistent root persistent 
nettles toole describe way garbage collection elegantly identify save reachable persistent data 
sure saved data consistent gpp typically coupled database style transactions 
argus system described employs gpp transactions aid updating approach 
linking systems dynamic linking add new code running program 
flexible dynamic updating dynamic linking support extensible adaptable systems 
section look research dynamic linking starting origins static linking finishing common component systems 
static linking problems face developing dynamic linker updater superset faced traditional static linkers 
number papers formal descriptions linking considered operation safe 
cardelli car developed small module system simply typed lambda calculus proved linking system type safe 
glew morrisett gm expanded cardelli approach setting tal type safe assembly language :10.1.1.13.9240:10.1.1.13.9240
flatt felleisen ff defined program units class software components showed linking units type safe 
incremental linking ql analogous dynamic update done compile time runtime 
motivation update executable place modules changed time program linked reconstruct entire executable scratch reduce link time 
requires redirection pointers old code new 
dynamic linking term dynamic linking mean different things literature 
instance refers action parts conceptually static program loaded incrementally 
case executable file holes filled program start time just runtime loading modules 
operating systems implement approach allow dynamically loaded libraries dll interest reducing executable size library code stored executable facilitating changes library requiring application recompilation 
dynamic linking may refer operation new modules may loaded running program execution program 
case program holes extended new functionality 
dorward dss refers operations incremental dynamic linking respectively adopt convention 
franz fra presents overview history dynamic incremental linking approaches may implement incremental linking load time indirection load time rewriting runtime rewriting load time compilation dynamic compilation 
cases modules loaded just program execution 
load time indirection modules compiled modules indirectly link table 
linking reduces filling link table module appropriately essentially mechanism dlpop see chapter 
load time rewriting pay penalty indirection external call runtime call sites external overwritten correct address static linkers alternate implementation dlpop runtime code generation mimics approach see 
runtime rewriting lazy implementation approach waits accessed rewritten 
approaches consider pushing elements compilation code generation entire compilation process runtime 
prevents need fixing links links generated runtime 
ho olsson ho earliest approaches dynamic linking system lacks type safety loaded symbols may coerced incompatible types runtime program integrity program modules may unloaded leaving dangling pointers 
interface modern dynamic linking library unix dlopen lin described informally 
dynamic linking provided number object oriented languages notably java ag special means dss hg dlopen 
systems preserve type safety case lack strong typing weakens property 
specialized systems require newly loaded classes related subtypes classes running program java impose restriction 
java dynamic linking incremental 
newer implementations java allow class unloading code unreachable reachability conditions conservative guess 
functional languages provide dynamic linking particular scheme sch dr haskell ocaml rou proposed sml app implemented far tell 
type safety running program preserved dynamic linking 
implementations implement dynamic unlinking allowing code garbage collected straightforward 
dr scheme dr allows dynamic linking units ff described current units implementation dynamically typed weaker type safety guarantees statically typed implementations possible 
tal load approach developed approaches designed dynamically linking verifiable native code vnc 
vnc native code coupled annotations ensure safety formally verified 
existing flavors vnc tal mwcg updating approach pcc nec :10.1.1.40.2507:10.1.1.24.6526
duggan proposes typed modular assembly language dug 
defines number extensions underlying assembly language express dynamic linkages similar tal load drawback larger tcb 
see details 
peterson haskell implementation hugs appel hot sliding approach sml app claim support dynamic update really support plugin extensions bindings fixed static dynamic linking time 
result program extensive provision incorporating new code may limited cases described 
approach specialpurpose updating approaches spin bsp dynamic protocol architectures including active networks hn click modular router 
lot interest called software components defined systems com com corba cor 
components application independent typical dynamically loadable libraries contain information allow application query contents 
components com particular 
dynamic updating research dynamically updating running programs goes back years 
dynamic updating term appears number past including dynamic software reconfiguration dynamic code replacement dynamic code improvement line software version change 
examined formal foundations dynamic update number systems described implemented 
look avenues chronologically 
earlier systems exist lee systems support dynamic updating called dynamic modification system lee 
nearly years passed remains flexible dynamic updating systems envisioned 
designed multi threaded variant modula called coo permits changes module definitions including type function data definitions loop bodies allow infinite loops updated 
environment integrated updateable program associated command interpreter source code management system compiler supporting runtime environment 
fact approach different socalled top level environments available typical functional programming languages scheme cf 
scheme sch ml cf 
objective caml ler 
systems user define compile modules user update existing code 
updates performed special command specifies modules update updated 
condition specified list modules functions active new code installed running program see 
implementing runtime environment enforce called conditions costly terms performance implementation complexity 
aimed provide flexible updating system particular concern update correctness 
part benefit integrated approach system intimate knowledge running program executable image source code makeup 
result attempted changes program type checked context rest program 
approach achieves effect typed assembly language substantially larger trusted computing base 
addition system runtime enforcement conditions provides programmers mechanisms ensuring updates applied correct time 
theoretical aid enforcement mechanisms lee defined algorithm partitioning update smaller updates see unfortunately criteria ensuring proper timing update large small 
deficiency determining reasonable update timing remains large part field today 
dynamic module replacement argus argus programming language building reliable distributed applications lis clu programming language 
argus distributed application consists guardians essentially unix processes communicate rpc interface 
typical unix processes guardians equipped mechanisms allow restarted crash 
particular programmer identifies portion guardian state stable 
stable state persistent program operation recovered storing disk state kept consistent database style transactions 
distributed programming environments supporting reconfiguration conic polylith see connections guardians rerouted dynamically 
bloom describes design dynamic updating system blo bd guardian code replaced runs 
maximize flexibility preserving type safety bloom allows collections guardians called subsystems replaced simultaneously 
allow groups modules updated running program simultaneously reason single modules guardians replaced functions modules guardians program change type 
guardians replaced coerced quiescent state meaning transactions computed system abort running transactions wait complete 
new guardians started old guardians state possibly alteration 
notice new guardians old guardians redirected 
done requiring rpc call perform extra lookup find version function called performance cost 
application level approach replacement argus proposed day day bd 
replacement individual guardians takes place standard argus facilities crash recovery 
replace guardian old guardian crashed new version restarted existing state old 
able start new guardian old state old state encoded crash time decoded replacement guardian starts approach polylith see 
existing guardians properly redirected new guardian expected rpc handle special exception 
guardian rpc call exception raised try relocate function attempting call 
finding new guardian directs call 
approach disadvantages required user individual guardians replaced 
largest lesson argus fault tolerance mechanisms ensuring consistent state transactions general purpose persistence leveraged provide form dynamic updating cost greater implementation burden 
conic conic mk distributed programming system allows distributed components application reconfigured 
argus applications conic applications consist number processes distributed network communicate defined entry points 
process communication channels separate process code channels redirected runtime configuration manager 
conic language ensures connections typed 
conic redirect connections processes provide system level support update code running process possible argus 
requires conic applications coded capture transfer state similar flexible application level approach proposed day argus day 
fs sf procedure oriented dynamic update system developed mark segal frieder provides incremental update procedures running program 
multiple versions procedure may coexist updates automatically delayed syntactically semantically sound determined compiler programmer respectively 
updates permitted non active procedures 
syntactically active procedures runtime stack may called new version procedure updated 
semantically related procedures defined programmer having non syntactic dependency 
procedure currently active semantically related procedure considered semantically active 
procedures code change version version considered active 
forbidding updates active code loses flexibility long running top level functions replaced 
procedure may updated active system waits longer active 
programs single threaded set running procedures effectively stack extra code inserted compiler check stack depth procedure return determine procedures longer active 
updates applied entire program runs version 
procedures interface changes result dynamic update available old code analogous stub functions 
translate arguments required old interface required new call new function translate result returned old code 
similarly mapper procedures translate static data migrated versions combination mapper procedures essentially equivalent state transformer function 
invoked procedure call mapper procedures invoked update time 
implemented overloading segmented virtual memory infrastructure 
procedure calls notated sparse addresses contain version information 
versions numbers things index segment table multiple versions program separate segments program 
may map calls segment 
approach quite similar indirection see flexible single known indirection table point symbols current version program segment register index table indirection tables program version 
segmented virtual memory provides flexibility comes cost performance segmented addressing typically requires system calls user space simulation avoid cost impose 
reconfigurable polylith polylith hof distributed programming system supports reconfiguration 
forms reconfiguration supported structural geometric modular 
reconfigurations concern number individual processes termed modules distributed program connections third considers implementation individual processes 
structural change alters makeup program redirecting communication channels adding deleting processes 
geometric change tantamount process migration 
changes provided conic described 
modular change process program altered polylith terminology dynamic software updating methodology modular change 
polylith processes special library communication channels structural changes occur altering processes 
bindings processes altered seamlessly 
geometric modular changes require process level participation perform state capture restore 
system modular changes may occur reconfiguration points specified advance programmer basically implementing invoke updating model see 
application level approach argus updating occurs starting new relocated version program captured state 
polylith deficiencies state transfer regarding updating see support machine independent process migration certain flexibility limitations see 
polylith provides automatic support state capture restore requires programmer aid 
particular compile time transformation automatically capture program stack time update 
capturing heap static data require assistance programmer 
similarly automatic transformation generate code restore stack program restarted 
major drawback structure semantics stack remain unchanged new version process program automatically generated code altered hand drastic changes program structure hand alterations nearly impossible 
furthermore transformation properly deal data stored stack function data pointers 
result code needs inserted hand 
hand programs structured stack capture totally avoided heap data capture required advocate structure system 
specific performance data polylith available note stack capture routines result number extra checks added runtime stack restored 
course program structured checks infrequent 
line software version change gupta framework doing dynamic update implemented state transfer programs written gj 
subsequent establish formal groundwork reasoning dynamic update general gup 
implementation state transfer running program state captured new code started existing state 
state capture occurs copying stack data area new process meaning mechanism 
system allows user code migrate different interfaces uses state transformation function global state 
procedures runtime stack may updated 
framework automatically delaying update active procedures far tell 
advantage platform dependent state transfer easily implemented framework standard tools special compiler support required general purpose checkpointing library 
standard drawbacks 
stack heap data copied procedures data new program addresses 
prevents straightforward addition new global data 
gupta important contribution formal framework understanding dynamic update valid proof determining update validity general undecidable 
basic framework described 
light framework gupta considers different programming language styles including imperative languages procedures imperative languages procedures object oriented languages 
unfortunately basic result undecidability interesting useful formalism extend realistic languages easily 
theoretical lee bloom argus known validity programmer writing updateable programs 
improved formal framework needed 
erlang erlang dynamically typed concurrent purely functional programming language designed building long running telecommunications systems 
erlang provides language level library support dynamic updates modules running programs 
updates permitted running code update take effect called external source 
approach calls old module call old new code 
erlang provide looping constructs functional languages loops programmed tail recursion 
loops updated call procedure caller module fully qualified function iter module syntactically specifies recursive call iter simply iter new version function called available 
versions code available system time current old version code explicitly deleted exists new code may loaded certain library routines may detect old code 
main strengths erlang simplicity interface implementation implementation described hau 
erlang employs indirection realize updating see fully qualified calls indirected indirection table table entries redirected load time intra module calls directly addressed 
requires little compiler support simple dynamic linking 
approach erlang uses invoke model interrupt model 
reasoning updates erlang straightforward key language features data write mutation thread communication occurs message passing 
effect thread change long lived data passing modified copy recursive call threads may access data distilled form message passing 
way essentially function calls modules stateless state carried thread argument list way get state managed thread called server erlang jargon erl pass message receive response separate function call 
jargon information leakage see call state 
course reasoning global state simpler room inconsistency 
result programming patterns update barrier synchronization ensure update correctness 
patters described erlang specification erl 
main drawback erlang lack load time checking 
result problems due type incorrect change delayed program execution time may difficult recover determine reason problem 
dynamic ml dynamic ml proposed implementation ml enables distributed agent programming replacement module components runtime including signatures structures :10.1.1.161.3137
structure replaced match signature interface old version 
definitions added module visible revealed subsequently replacing module signature wider 
additionally programmer allowed implementation non transparent type definitions new module 
multiple versions module allowed coexist adt implementation changes user provide series conversion routines translate values type new implementation 
formal semantics dictate conversion performed atomically copying garbage collection initiated update 
live values implementation changed copied space filtered conversion routines error occur conversion resulting thrown exception update aborted reverting old representations fromspace 
version module exist program updates may performed active modules 
approach number advantages 
system employs automated mechanisms ensure correctness simplify creation updates 
particular updates coded functors old new implementation advantage functors specified language familiar programmer type safety guaranteed compiler 
furthermore compiler guarantee type conversion functions updates provably complete 
copying garbage collection means type translation rollback elegantly leverages standard implementation requirement 
furthermore sophisticated collector replicating collection allow state transformation occur concurrently program execution 
sorts changes may effected implementation limited 
particular instances module export translucent non type implementation known client 
sorts types may changed doing break assumptions compiled client code 
furthermore running code updated update timing programmer control 
conversely components deleted signature replaced followed structure 
dynamic classes hj gray designed implemented mechanisms dynamic update classes hg :10.1.1.109.1634
implementation requires programmer specially code classes may dynamically replaced proxy class dynamic 
dynamic allows objects multiple versions dynamic class coexist maintains pointer version class directing constructor calls class instance methods executed class created object 
implementation simple portable demonstrates appeal object oriented code replacement instance methods instance operations consistent lifetime newer version class loaded 
approach simple portable lacks flexibility key ways 
static methods may replaced 
due part library implementation adding compilation approach similar mitigate problem 
result system appear severely restricted conceptually global data anticipated deployment 
second existing instances changed class changed model requires existing instances die naturally 
may prevent useful program 
dynamic java dynamic java acr proposes alterations java runtime allow runtime replacement classes java program 
dynamic ml modules versions class may simultaneously authors specify ways code may updated incrementally object old class referenced converted suit new class 
old object pointed new version lazily mutual exclusion sure object converted different threads 
implemented extending objects classes pointer respective substitute version 
mention proposal semantics correctness updates 
dynamic java classes dynamic virtual machine dvm modified java virtual machine jvm implements dynamic java classes mpg 
essence dvm implements new trusted functions default classloader allow users replace java classes dynamically 
dvm requires classes replaced logically load time existing instances old class compatible new class accessed 
prevents arbitrary syntactic semantic changes class old clients may class incorrectly 
easily ensure updates correct majority updating functionality integrated java runtime 
consequences 
dvm tcb larger extra implementation reducing assurances security 
second changes defined system implementation specific quickly transfer jvm library compilation approach 
implementation rely byte code interpreter due problems justin time jit compilers modern virtual machines 
consequently dvm performance far current standards java 
dynamic interposition tools snc software library exploits presence indirection table elf object file store external file extant shared libraries 
library overrides standard dynamic linker customize indirection tables filled allowing users rebind definition normally associated interpose function original definition 
designed chiefly customize third party executables enable performance monitoring service customization lacks infrastructure germane dynamic updating including patch generation facilities specialized compilation 
guarded software updating tai propose approach upgrading software long lived deep space missions called guarded software updating tta tta 
proposed system designed avionics architecture generalize multiprocessor architectures principle 
chief contribution transparent message protocol test new software runs gradually building trust new software correct 
replacement software process begins execution old version continues run shadow mode meaning messages logged new software version messages sent 
erroneous message new software message different process influenced new software detected system switches old version 
switch semantically consistent employs checkpointing technology pla checkpoint state old version board processes state known consistent 
switch takes place relevant processes rolled back necessary checkpointed state 
erroneous message detection occurs transparently 
normal calls send receive messages go middleware library performs checkpointing logging necessary checks messages accuracy 
message accuracy checked user provided acceptance tests predicates indicating message wellformed 
general error detection assumed localized exchanged messages forms possible error checked 
details process loading executing new software version provided 
process appears roughly follows 
load new software process image idle processor 

start process checkpointed state process replaced 

switch old process shadow mode 
updating procedure see potential drawbacks regarding flexibility system 
new version able state old version just preventing number possible changes 
similar restriction appears placed external behavior new process respect messages sends 
order new old processes exhibit message behavior stimulus realm defined acceptance test 
words new software restricted roughly message protocols old version precluding changes protocols 
despite disadvantages successful ways 
old new versions run separate processors performance overhead additional code message sending receiving primitives 
constraining form updates system easier reducing complexity 
importantly unique ability test roll back software updates line 
particular system dynamic ml argus permit short term rollback immediately update roll back update long operation 
techniques allow longer term rollback applicable software updating approaches 
example able program error detection recovery protocol library system addition general special purpose 
dyninst dyninst dynamic instrumentation bh defines api patching running program dynamically generated code :10.1.1.36.8435
template approaches runtime code generation systems clm hj dyninst allows arbitrary changes determined runtime 
particular user may specify essentially syntax trees compiled inserted running program specified points 
enabling technology metric description language mdl uses machine specific techniques insert code running system 
essence programmer identifies point program say instruction inside procedure body snippet piece code insert 
process called mutator attaches process inserts snippet desired point replacing existing instruction branch base trampoline contains code common snippets 
trampoline saves registers jumps mini trampoline contains actual snippet code 
code completes returns base trampoline restores registers executes copy replaced instruction returning main program 
dyninst main advantage program updated requiring special compilation 
furthermore performance penalty paid code updated includes cost added branch cost save restore appropriate registers 
authors state benefit approach special purpose engineering need performed new software version 
infer transformation expected 
debug flag needs turned points properly identified standard compilation 
hand methodology dyninst couple disadvantages 
api defined portable implementation code changes defined system level sourcecode level 
furthermore implementation update trampolining quite difficult error prone compared compiler inserted indirection example 
second guarantee inserted snippet interact running program particular type unsafe code easily inserted crash system 
third little support long term evolution system 
example alterations done hand authors state ultimately expect high level analyses target api 
addition little concern maintaining consistent state 
lack support largely design dyninst intended analysis purposes running program instrumented count certain events debug anomalous behavior 
dynamic architectures realm software engineering extensive body examining system architectures 
system architecture provides view system implementation considering interactions high level components modules objects heavyweight entities processes machines 
number tools exist constructing analyzing system architectures facilitating implementation 
dynamic architectures model systems may change execution identify mechanisms needed implement system 
ore identified additional features dynamic architecture static including modification operations modification constraints legal modification times 
dynamic architectures typically allow reconfiguration style conic polylith state preserving update existing components 
bibliography es ess switch 
www lucent ssg com switching products configurations switch shtml 
aa joe armstrong thomas arts 
practical type system erlang 
technical report erlang user conference 
mart abadi luca cardelli benjamin pierce gordon plotkin 
dynamic typing statically typed language 
acm transactions programming languages systems april 
mart abadi luca cardelli benjamin pierce didier 
dynamic typing polymorphic languages 
journal functional programming january 
preliminary version proceedings acm sigplan workshop ml applications june 
acr jesper andersson marcus tobias 
run time support dynamic java architectures 
proceedings ecoop workshop object oriented architectures 
july 
ag ken arnold james gosling 
java programming language 
addison wesley 
hicks ioannidis keromytis smith 
scalable resource control active networks 
hiroshi editor proceedings second international working conference active networks volume lecture notes computer science pages 
springer verlag october 
ale alexander 
alien generalized computing model active networks 
phd thesis university pennsylvania september 
app andrew appel 
hot sliding ml december 
unpublished manuscript 
ari www com 
arm joe armstrong 
development erlang 
sigplan international conference functional programming pages 
acm june 
joe armstrong robert virding mike williams 
concurrent programming erlang 
prentice hall second edition 
bd toby bloom mark day 
reconfiguration module replacement argus theory practice 
software engineering journal march 
bh bryan buck jeffrey hollingsworth :10.1.1.36.8435
api runtime code patching 
journal high performance computing applications :10.1.1.40.2507
bl nathaniel brian neil levine 
cheat proof playout centralized distributed online games 
proceedings twentieth ieee computer communication society infocom conference 
ieee april 
blo toby bloom 
dynamic module replacement distributed programming system 
phd thesis laboratory computer science massachussets institute technology march 
bp benjamin pierce 
file synchronizer 
fourth annual acm ieee international conference mobile computing networking mobicom october 
full version available indiana university technical report april 
bsp brian bershad stefan savage pardyak emin gun sirer david becker marc fiuczynski craig chambers susan eggers 
extensibility safety performance spin operating system 
proceedings th acm symposium operating system principles pages copper mountain resort colorado 
bw hans juergen boehm mark weiser 
garbage collection uncooperative environment 
software practice experience 
cac cactus project university arizona 
www cs arizona edu cactus 
car luca cardelli 
program fragments linking modularization 
fourth acm symposium principles programming languages pages 
acm january 
clm charles consel julia lawall renaud marlet gilles muller jacques noy scott thibault volanschi 
tempo specializing systems applications 
acm computing surveys symposium partial evaluation september 
cln christopher colby peter lee george necula fred blau ken cline mark 
certifying compiler java 
proceedings acm sigplan conference programming language design implementation pldi june 
cof microsoft portable executable common object file format specification 
msdn microsoft com library specs msdn htm 
com microsoft com technologies 
www microsoft com com default asp 
coo cook 
mod language distributed programming 
ieee transactions software engineering 
cor omg corba website 
www corba org 
cwm karl crary stephanie weirich greg morrisett 
intensional polymorphism type erasure semantics 
third acm international conference functional programming pages baltimore september 
extended version published cornell university technical report tr :10.1.1.40.2507
day mark day 
replication reconfiguration distributed mail repository 
master thesis laboratory computer science massachussets institute technology april 
dea drew dean :10.1.1.39.3682
security static typing dynamic linking 
proceedings fourth acm conference computer communications security april 
dr dr scheme homepage 
www cs rice edu cs plt packages drscheme 
dss sean dorward ravi sethi jonathan 
adding new code running program 
proceedings usenix technical conference pages april 
dug dominic duggan 
sharing typed module assembly language 
proceedings third acm sigplan workshop types compilation september 
dawson engler frans kaashoek james toole jr exokernel operating system architecture application level resource management 
proceedings th acm symposium operating systems principles pages copper mountain resort colorado december 
ens ensemble distributed communication system 
www cs cornell 
edu info projects ensemble 
erl erlang design principles february 
www erlang org doc doc doc design principles part frame html 
ff matthew flatt matthias felleisen 
units cool modules hot languages 
proceedings sigplan international conference programming language design implementation pages 
acm june 
fog karl franz fogel 
open source development cvs 
group 
fra michael franz 
dynamic linking software components 
ieee computer march 
fs frieder mark segal 
dynamically updating computer program concept prototype 
journal systems software september 
steven gribble eric brewer joseph hellerstein david culler 
scalable distributed data structures internet service construction 
symposium operating systems design implementation 
gir jean yves girard 
une extension de interpr tation de del analyse son application des coupures dans analyse la th orie des types 
fenstad editor scandinavian logic symposium pages 
gj deepak gupta pankaj 
line software version change state transfer processes 
software practice experience september 
deepak gupta pankaj gautam barua 
formal framework line software version change 
transactions software engineering february 
gks garlan krueger staudt 
structural approach maintenance structure oriented environments 
sigsoft sigplan software engineering symposium practical software development environments pages palo alto ca :10.1.1.40.2507:10.1.1.24.6526
acm 
stephen gilmore chris walton :10.1.1.161.3137
dynamic ml dynamic types 
technical report ecs lfcs laboratory foundations computer science university edinburgh december 
gle neal glew 
low level type systems modularity object oriented constructs 
phd thesis cornell university january 
gm neal glew greg morrisett :10.1.1.13.9240:10.1.1.13.9240
type safe linking modular assembly language 
sixth acm symposium principles programming languages pages 
acm january 
gm dan grossman greg morrisett :10.1.1.2.4977
scalable certification typed assembly language 
proceedings third acm sigplan workshop types compilation september 
gup deepak gupta 
line software version change 
phd thesis department computer science engineering indian institute technology kanpur november 
har robert harper 
simplified account polymorphic 
information processing letters 
hau hausman 
turbo erlang approaching speed evan tick giancarlo editors implementations logic programming systems pages 
kluwer academic publishers 
hg sli hj lmt robert gray :10.1.1.109.1634
dynamic classes lightweight mechanism update code running program 
proceedings usenix annual technical conference june 
hj luke hornof trevor jim 
certifying compilation run time code generation 
journal higher order symbolic computation 
earlier version appeared partial evaluation semantics program manipulation january 
hk michael hicks angelos keromytis 
secure plan 
stefan editor proceedings international workshop active networks volume lecture notes computer science pages :10.1.1.24.6526
springer verlag june 
extended version www cis upenn 
edu papers ps 
hkm michael hicks pankaj jonathan moore carl gunter scott nettles 
plan packet language active networks 
third acm international conference functional programming pages 
acm september 
hl robert harper mark lillibridge 
type theoretic approach higherorder modules sharing 
proceedings acm sigplan sigact symposium principles programming languages pages january 
hm robert harper greg morrisett 
compiling polymorphism intensional type analysis 
proceedings second acm symposium principles programming languages pages san francisco california 
michael hicks jonathan moore scott alexander carl gunter scott nettles 
planet active internetwork 
proceedings eighteenth ieee computer communication society infocom conference pages 
ieee march 
jeffrey hollingsworth barton miller marcelo gon alves oscar xu ling zheng 
mdl language compiler dynamic program instrumentation 
proceedings international conference parallel architectures compilation techniques pages november 
hmm robert harper john mitchell eugenio moggi 
higher order modules phase distinction 
seventeenth acm symposium principles programming languages pages san francisco january 
hn michael hicks scott nettles 
active networking means evolution enhanced extensibility required 
hiroshi editor proceedings second international working conference active networks volume lecture notes computer science pages :10.1.1.24.6526
springer verlag october 
ho wilson ho ronald olsson 
approach genuine dynamic linking 
software practice experience april 
hof christine 
dynamic reconfiguration 
phd thesis computer science department university maryland college park 
hw michael hicks stephanie weirich 
calculus dynamic loading 
technical report ms cis university pennsylvania april 
basics java class loaders 
www javaworld com javaworld jw jw indepth html 
clarifications java language specification may 
java sun com docs books unloading rationale html 
john levine 
linkers loaders 
morgan kaufman 
lee lee 
dynamic modification system 
phd thesis department computer science university wisconsin madison april 
ler xavier leroy 
manifest types modules separate compilation 
acm symposium principles programming languages pages portland oregon january 
ler xavier leroy 
objective caml system release 
institut national de recherche en informatique automatique inria 
available caml inria fr 
lil mark lillibridge 
translucent sums foundation higher order module systems 
phd thesis carnegie mellon university school computer science pittsburgh pennsylvania may 
lin dlopen 
linux programmer manual december 
lis barbara liskov 
distributing programming argus 
communications acm pages march 
ly tim lindholm frank yellin 
java virtual machine specification 
addison wesley 
mbc bhattacharjee sanders calvert zegura 
bowman implementation active network 
proceedings seventh annual allerton conference communication control computing september 
mcg greg morrisett karl crary neal glew dan grossman richard samuels frederick smith david walker stephanie weirich steve zdancewic :10.1.1.24.6526
talx realistic typed assembly language 
second workshop compiler support system software atlanta may 
mh greg morrisett robert harper 
semantics memory management polymorphic languages 
gordon pitts editors higher order operational techniques semantics 
cambridge university press 
mit john mitchell 
type inference approach reduction properties semantics polymorphic expressions summary 
proceedings acm conference lisp functional programming pages new york 
acm 
mj david mosberger tai jin 
httperf tool measuring web server performance 
workshop internet server performance pages 
acm june 
mk jeff magee jeff kramer 
dynamic configuration distributed systems 
ieee transactions software engineering april 
robert morris eddie kohler john jannotti frans kaashoek 
click modular router 
symposium operating systems principles pages :10.1.1.40.2507
jeff magee jeff kramer morris sloman 
constructing distributed systems conic 
ieee transactions software engineering june 
minamide greg morrisett robert harper :10.1.1.141.7192
typed closure conversion 
third acm symposium principles programming languages pages st petersburg florida january 
mp john mitchell gordon plotkin 
types existential type 
acm transactions programming languages systems july 
mpg scott pandey jeff earl barr fritz barnes 
runtime support type safe dynamic java classes 
proceedings fourteenth european conference object oriented programming june 
robin milner mads tofte robert harper david macqueen 
definition standard ml revised 
mit press cambridge massachusetts 
mw simon marlow philip wadler 
practical subtyping system erlang 
second acm international conference functional programming 
acm june 
mwcg greg morrisett david walker karl crary neal glew :10.1.1.40.2507:10.1.1.24.6526
system typed assembly language 
acm transactions programming languages systems may 
nec george necula :10.1.1.40.2507
proof carrying code 
fourth acm symposium principles programming languages pages paris january 
nl george necula peter lee 
safe kernel extensions run time checking 
second symposium operating systems design implementation pages seattle october 
scott nettles james toole 
implementing orthogonal persistence simple optimization replicating collection 
proceedings third international workshop object orientation operating systems pages asheville nc usa :10.1.1.40.2507
og glenn 
hmac md ip authentication replay prevention 
internet rfc february 
james toole scott nettles 
concurrent replicating garbage collection 
proceedings conference lisp functional programming 
acm june 
ore 
issues runtime modification software architectures 
technical report uci ics tr department information computer science university california irvine august 
james plank beck gerry kai li 
transparent checkpointing unix 
proceedings usenix winter technical conference 
vivek pai peter druschel willy zwaenepoel 
flash efficient portable webserver 
proceedings usenix annual technical conference pages monterey june 
pes david 
monsters box 
wired 
pg pratt gibbons 
concepts nonparametric theory 
springer verlag 
john peterson paul hudak gary shu ling 
principled dynamic code improvement 
technical report yaleu dcs rr department computer science yale university july 
pie benjamin pierce 
mutable objects 
www cis upenn edu papers mutable ps 
international workshop persistence java september 
www sun com research forest uk ac gla dcs pj html 
pla james plank 
overview checkpointing uniprocessor distributed systems focusing implementation performance 
technical report ut cs 
pt benjamin pierce david turner :10.1.1.17.9345
simple type theoretic foundations object oriented programming 
journal functional programming 
ql russell quong mark linton 
linking programs incrementally 
transactions programing languages systems january 
rep john reppy 
concurrent programming ml 
cambridge university press 
rey john reynolds 
theory type structure 
colloquium sur la programmation volume lecture notes computer science pages 
springer verlag 
rey john reynolds 
design programming language forsythe 
report cmu cs carnegie mellon university pittsburgh pennsylvania june 
rou fran ois 
web navigator applets caml 
proceedings th international world wide web conference computer networks telecommunications networking volume pages 
elsevier may 
rs volker 
portable checkpointing heterogenous architectures 
symposium fault tolerant computing pages 
sch scheme 
org 
seg mark segal 
personal communication 
sew peter sewell 
modules types distributed versioning 
proceedings eighth acm symposium principles programming languages pages london january 
sf mark segal frieder 
fly program modification systems dynamic updating 
ieee software pages march 
emin gun sirer marc fiuczynski pardyak brian bershad 
safe dynamic linking extensible operating system 
workshop compiler support system software tucson february 
emin gun sirer robert grimm arthur gregory brian bershad 
design implementation distributed virtual machine networked computers 
proceedings seventeenth symposium operating systems principles december 
smi jonathan smith 
survey process migration mechanisms 
acm operating systems review sigops 
snc albert serra navarro toni cortes 
application level support dynamic extension flexible composition 
proceedings usenix annual technical conference march 
ss jerome saltzer michael schroeder 
protection information computer systems 
proceedings ieee 
ssf jonathan shapiro jonathan smith david farber 
eros fast capability system 
symposium operating systems principles pages :10.1.1.40.2507
tal typed assembly language homepage 
www cs cornell edu 
tool interface standards committee 
executable linking format elf specification may 
tm andrew tridgell paul 
rsync algorithm 
technical report tr cs canberra act australia 
samba anu edu 
au rsync 
tta ann tai kam tso leon chau william sanders 
board guarded software upgrading space missions 
proceedings eighteenth digital avionics systems conference 
tta ann tai kam tso leon chau william sanders 
low cost error containment recovery methods guarded software upgrading 
proceedings twentieth international conference distributed computing systems pages april 
web webstone benchmark information 
www 
com webstone 
wei stephanie weirich 
type safe cast 
proceedings fifth acm sigplan international conference functional programming languages 
acm september 
jeannette wing manuel gregory morrisett scott nettles 
extensions standard ml support transactions 
acm workshop ml applications pages 
wgt david wetherall john guttag david tennenhouse 
ants toolkit building dynamically deploying network protocols 
ieee april 
chris walton stephen gilmore 
machine module replacement 
technical report laboratory foundations computer science university edinburgh june 
wm david walker greg morrisett :10.1.1.1.5638
alias types recursive data structures 
proceedings third acm sigplan workshop types compilation september 
xsu telcordia software visualization analysis 
com 
yemini sushil da silva 
programmable networks 
proceedings ifip ieee international workshop distributed systems operations management september 

